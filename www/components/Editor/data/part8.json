{"files_changed":{"files":[[2808,"//! This module implements the `Any` trait, which enables dynamic typing\n//! of any `'static` type through runtime reflection.\n//!\n//! `Any` itself can be used to get a `TypeId`, and has more features when used\n//! as a trait object. As `&dyn Any` (a borrowed trait object), it has the `is`\n//! and `downcast_ref` methods, to test if the contained value is of a given type,\n//! and to get a reference to the inner value as a type. As `&mut dyn Any`, there\n//! is also the `downcast_mut` method, for getting a mutable reference to the\n//! inner value. `Box<dyn Any>` adds the `downcast` method, which attempts to\n//! convert to a `Box<T>`. See the [`Box`] documentation for the full details.\n//!\n//! Note that `&dyn Any` is limited to testing whether a value is of a specified\n//! concrete type, and cannot be used to test whether a type implements a trait.\n//!\n//! [`Box`]: ../../std/boxed/struct.Box.html\n//!\n//! # Smart pointers and `dyn Any`\n//!\n//! One piece of behavior to keep in mind when using `Any` as a trait object,\n//! especially with types like `Box<dyn Any>` or `Arc<dyn Any>`, is that simply\n//! calling `.type_id()` on the value will produce the `TypeId` of the\n//! *container*, not the underlying trait object. This can be avoided by\n//! converting the smart pointer into a `&dyn Any` instead, which will return\n//! the object's `TypeId`. For example:\n//!\n//! ```\n//! use std::any::{Any, TypeId};\n//!\n//! let boxed: Box<dyn Any> = Box::new(3_i32);\n//!\n//! // You're more likely to want this:\n//! let actual_id = (&*boxed).type_id();\n//! // ... than this:\n//! let boxed_id = boxed.type_id();\n//!\n//! assert_eq!(actual_id, TypeId::of::<i32>());\n//! assert_eq!(boxed_id, TypeId::of::<Box<dyn Any>>());\n//! ```\n//!\n//! # Examples\n//!\n//! Consider a situation where we want to log out a value passed to a function.\n//! We know the value we're working on implements Debug, but we don't know its\n//! concrete type. We want to give special treatment to certain types: in this\n//! case printing out the length of String values prior to their value.\n//! We don't know the concrete type of our value at compile time, so we need to\n//! use runtime reflection instead.\n//!\n//! ```rust\n//! use std::fmt::Debug;\n//! use std::any::Any;\n//!\n//! // Logger function for any type that implements Debug.\n//! fn log<T: Any + Debug>(value: &T) {\n//!     let value_any = value as &dyn Any;\n//!\n//!     // Try to convert our value to a `String`. If successful, we want to\n//!     // output the String`'s length as well as its value. If not, it's a\n//!     // different type: just print it out unadorned.\n//!     match value_any.downcast_ref::<String>() {\n//!         Some(as_string) => {\n//!             println!(\"String ({}): {}\", as_string.len(), as_string);\n//!         }\n//!         None => {\n//!             println!(\"{:?}\", value);\n//!         }\n//!     }\n//! }\n//!\n//! // This function wants to log its parameter out prior to doing work with it.\n//! fn do_work<T: Any + Debug>(value: &T) {\n//!     log(value);\n//!     // ...do some other work\n//! }\n//!\n//! fn main() {\n//!     let my_string = \"Hello World\".to_string();\n//!     do_work(&my_string);\n//!\n//!     let my_i8: i8 = 100;\n//!     do_work(&my_i8);\n//! }\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::fmt;\nuse crate::intrinsics;\n\n///////////////////////////////////////////////////////////////////////////////\n// Any trait\n///////////////////////////////////////////////////////////////////////////////\n\n/// A trait to emulate dynamic typing.\n///\n/// Most types implement `Any`. However, any type which contains a non-`'static` reference does not.\n/// See the [module-level documentation][mod] for more details.\n///\n/// [mod]: crate::any\n// This trait is not unsafe, though we rely on the specifics of it's sole impl's\n// `type_id` function in unsafe code (e.g., `downcast`). Normally, that would be\n// a problem, but because the only impl of `Any` is a blanket implementation, no\n// other code can implement `Any`.\n//\n// We could plausibly make this trait unsafe -- it would not cause breakage,\n// since we control all the implementations -- but we choose not to as that's\n// both not really necessary and may confuse users about the distinction of\n// unsafe traits and unsafe methods (i.e., `type_id` would still be safe to call,\n// but we would likely want to indicate as such in documentation).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Any: 'static {\n    /// Gets the `TypeId` of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::{Any, TypeId};\n    ///\n    /// fn is_string(s: &dyn Any) -> bool {\n    ///     TypeId::of::<String>() == s.type_id()\n    /// }\n    ///\n    /// assert_eq!(is_string(&0), false);\n    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n    /// ```\n    #[stable(feature = \"get_type_id\", since = \"1.34.0\")]\n    fn type_id(&self) -> TypeId;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: 'static + ?Sized> Any for T {\n    fn type_id(&self) -> TypeId {\n        TypeId::of::<T>()\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Extension methods for Any trait objects.\n///////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for dyn Any {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Any\").finish_non_exhaustive()\n    }\n}\n\n// Ensure that the result of e.g., joining a thread can be printed and\n// hence used with `unwrap`. May eventually no longer be needed if\n// dispatch works with upcasting.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for dyn Any + Send {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Any\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\nimpl fmt::Debug for dyn Any + Send + Sync {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Any\").finish_non_exhaustive()\n    }\n}\n\nimpl dyn Any {\n    /// Returns `true` if the boxed type is the same as `T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &dyn Any) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// is_string(&0);\n    /// is_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n        // Get `TypeId` of the type this function is instantiated with.\n        let t = TypeId::of::<T>();\n\n        // Get `TypeId` of the type in the trait object (`self`).\n        let concrete = self.type_id();\n\n        // Compare both `TypeId`s on equality.\n        t == concrete\n    }\n\n    /// Returns some reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &dyn Any) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// print_if_string(&0);\n    /// print_if_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n        if self.is::<T>() {\n            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on\n            // that check for memory safety because we have implemented Any for all types; no other\n            // impls can exist as they would conflict with our impl.\n            unsafe { Some(&*(self as *const dyn Any as *const T)) }\n        } else {\n            None\n        }\n    }\n\n    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut dyn Any) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// let mut x = 10u32;\n    /// let mut s = \"starlord\".to_string();\n    ///\n    /// modify_if_u32(&mut x);\n    /// modify_if_u32(&mut s);\n    ///\n    /// assert_eq!(x, 42);\n    /// assert_eq!(&s, \"starlord\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n        if self.is::<T>() {\n            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on\n            // that check for memory safety because we have implemented Any for all types; no other\n            // impls can exist as they would conflict with our impl.\n            unsafe { Some(&mut *(self as *mut dyn Any as *mut T)) }\n        } else {\n            None\n        }\n    }\n}\n\nimpl dyn Any + Send {\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &(dyn Any + Send)) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// is_string(&0);\n    /// is_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n        <dyn Any>::is::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &(dyn Any + Send)) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// print_if_string(&0);\n    /// print_if_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n        <dyn Any>::downcast_ref::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut (dyn Any + Send)) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// let mut x = 10u32;\n    /// let mut s = \"starlord\".to_string();\n    ///\n    /// modify_if_u32(&mut x);\n    /// modify_if_u32(&mut s);\n    ///\n    /// assert_eq!(x, 42);\n    /// assert_eq!(&s, \"starlord\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n        <dyn Any>::downcast_mut::<T>(self)\n    }\n}\n\nimpl dyn Any + Send + Sync {\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &(dyn Any + Send + Sync)) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// is_string(&0);\n    /// is_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n        <dyn Any>::is::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &(dyn Any + Send + Sync)) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// print_if_string(&0);\n    /// print_if_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n        <dyn Any>::downcast_ref::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut (dyn Any + Send + Sync)) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// let mut x = 10u32;\n    /// let mut s = \"starlord\".to_string();\n    ///\n    /// modify_if_u32(&mut x);\n    /// modify_if_u32(&mut s);\n    ///\n    /// assert_eq!(x, 42);\n    /// assert_eq!(&s, \"starlord\");\n    /// ```\n    #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n        <dyn Any>::downcast_mut::<T>(self)\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// TypeID and its methods\n///////////////////////////////////////////////////////////////////////////////\n\n/// A `TypeId` represents a globally unique identifier for a type.\n///\n/// Each `TypeId` is an opaque object which does not allow inspection of what's\n/// inside but does allow basic operations such as cloning, comparison,\n/// printing, and showing.\n///\n/// A `TypeId` is currently only available for types which ascribe to `'static`,\n/// but this limitation may be removed in the future.\n///\n/// While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth\n/// noting that the hashes and ordering will vary between Rust releases. Beware\n/// of relying on them inside of your code!\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct TypeId {\n    t: u64,\n}\n\nimpl TypeId {\n    /// Returns the `TypeId` of the type this generic function has been\n    /// instantiated with.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::{Any, TypeId};\n    ///\n    /// fn is_string<T: ?Sized + Any>(_s: &T) -> bool {\n    ///     TypeId::of::<String>() == TypeId::of::<T>()\n    /// }\n    ///\n    /// assert_eq!(is_string(&0), false);\n    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n    pub const fn of<T: ?Sized + 'static>() -> TypeId {\n        TypeId { t: intrinsics::type_id::<T>() }\n    }\n}\n\n/// Returns the name of a type as a string slice.\n///\n/// # Note\n///\n/// This is intended for diagnostic use. The exact contents and format of the\n/// string returned are not specified, other than being a best-effort\n/// description of the type. For example, amongst the strings\n/// that `type_name::<Option<String>>()` might return are `\"Option<String>\"` and\n/// `\"std::option::Option<std::string::String>\"`.\n///\n/// The returned string must not be considered to be a unique identifier of a\n/// type as multiple types may map to the same type name. Similarly, there is no\n/// guarantee that all parts of a type will appear in the returned string: for\n/// example, lifetime specifiers are currently not included. In addition, the\n/// output may change between versions of the compiler.\n///\n/// The current implementation uses the same infrastructure as compiler\n/// diagnostics and debuginfo, but this is not guaranteed.\n///\n/// # Examples\n///\n/// ```rust\n/// assert_eq!(\n///     std::any::type_name::<Option<String>>(),\n///     \"core::option::Option<alloc::string::String>\",\n/// );\n/// ```\n#[stable(feature = \"type_name\", since = \"1.38.0\")]\n#[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\npub const fn type_name<T: ?Sized>() -> &'static str {\n    intrinsics::type_name::<T>()\n}\n\n/// Returns the name of the type of the pointed-to value as a string slice.\n/// This is the same as `type_name::<T>()`, but can be used where the type of a\n/// variable is not easily available.\n///\n/// # Note\n///\n/// This is intended for diagnostic use. The exact contents and format of the\n/// string are not specified, other than being a best-effort description of the\n/// type. For example, `type_name_of_val::<Option<String>>(None)` could return\n/// `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not\n/// `\"foobar\"`. In addition, the output may change between versions of the\n/// compiler.\n///\n/// This function does not resolve trait objects,\n/// meaning that `type_name_of_val(&7u32 as &dyn Debug)`\n/// may return `\"dyn Debug\"`, but not `\"u32\"`.\n///\n/// The type name should not be considered a unique identifier of a type;\n/// multiple types may share the same type name.\n///\n/// The current implementation uses the same infrastructure as compiler\n/// diagnostics and debuginfo, but this is not guaranteed.\n///\n/// # Examples\n///\n/// Prints the default integer and float types.\n///\n/// ```rust\n/// #![feature(type_name_of_val)]\n/// use std::any::type_name_of_val;\n///\n/// let x = 1;\n/// println!(\"{}\", type_name_of_val(&x));\n/// let y = 1.0;\n/// println!(\"{}\", type_name_of_val(&y));\n/// ```\n#[unstable(feature = \"type_name_of_val\", issue = \"66359\")]\n#[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\npub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n    type_name::<T>()\n}\n"],[2809,"#![allow(missing_docs)]\n#![unstable(feature = \"raw\", issue = \"27751\")]\n#![rustc_deprecated(\n    since = \"1.53.0\",\n    reason = \"use pointer metadata APIs instead https://github.com/rust-lang/rust/issues/81513\"\n)]\n\n//! Contains struct definitions for the layout of compiler built-in types.\n//!\n//! They can be used as targets of transmutes in unsafe code for manipulating\n//! the raw representations directly.\n//!\n//! Their definition should always match the ABI defined in\n//! `rustc_middle::ty::layout`.\n\n/// The representation of a trait object like `&dyn SomeTrait`.\n///\n/// This struct has the same layout as types like `&dyn SomeTrait` and\n/// `Box<dyn AnotherTrait>`.\n///\n/// `TraitObject` is guaranteed to match layouts, but it is not the\n/// type of trait objects (e.g., the fields are not directly accessible\n/// on a `&dyn SomeTrait`) nor does it control that layout (changing the\n/// definition will not change the layout of a `&dyn SomeTrait`). It is\n/// only designed to be used by unsafe code that needs to manipulate\n/// the low-level details.\n///\n/// There is no way to refer to all trait objects generically, so the only\n/// way to create values of this type is with functions like\n/// [`std::mem::transmute`][transmute]. Similarly, the only way to create a true\n/// trait object from a `TraitObject` value is with `transmute`.\n///\n/// [transmute]: crate::intrinsics::transmute\n///\n/// Synthesizing a trait object with mismatched types—one where the\n/// vtable does not correspond to the type of the value to which the\n/// data pointer points—is highly likely to lead to undefined\n/// behavior.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(raw)]\n///\n/// use std::{mem, raw};\n///\n/// // an example trait\n/// trait Foo {\n///     fn bar(&self) -> i32;\n/// }\n///\n/// impl Foo for i32 {\n///     fn bar(&self) -> i32 {\n///          *self + 1\n///     }\n/// }\n///\n/// let value: i32 = 123;\n///\n/// // let the compiler make a trait object\n/// let object: &dyn Foo = &value;\n///\n/// // look at the raw representation\n/// let raw_object: raw::TraitObject = unsafe { mem::transmute(object) };\n///\n/// // the data pointer is the address of `value`\n/// assert_eq!(raw_object.data as *const i32, &value as *const _);\n///\n/// let other_value: i32 = 456;\n///\n/// // construct a new object, pointing to a different `i32`, being\n/// // careful to use the `i32` vtable from `object`\n/// let synthesized: &dyn Foo = unsafe {\n///      mem::transmute(raw::TraitObject {\n///          data: &other_value as *const _ as *mut (),\n///          vtable: raw_object.vtable,\n///      })\n/// };\n///\n/// // it should work just as if we had constructed a trait object out of\n/// // `other_value` directly\n/// assert_eq!(synthesized.bar(), 457);\n/// ```\n#[repr(C)]\n#[derive(Copy, Clone)]\n#[allow(missing_debug_implementations)]\npub struct TraitObject {\n    pub data: *mut (),\n    pub vtable: *mut (),\n}\n"],[2810,"//! Atomic types\n//!\n//! Atomic types provide primitive shared-memory communication between\n//! threads, and are the building blocks of other concurrent\n//! types.\n//!\n//! This module defines atomic versions of a select number of primitive\n//! types, including [`AtomicBool`], [`AtomicIsize`], [`AtomicUsize`],\n//! [`AtomicI8`], [`AtomicU16`], etc.\n//! Atomic types present operations that, when used correctly, synchronize\n//! updates between threads.\n//!\n//! Each method takes an [`Ordering`] which represents the strength of\n//! the memory barrier for that operation. These orderings are the\n//! same as the [C++20 atomic orderings][1]. For more information see the [nomicon][2].\n//!\n//! [1]: https://en.cppreference.com/w/cpp/atomic/memory_order\n//! [2]: ../../../nomicon/atomics.html\n//!\n//! Atomic variables are safe to share between threads (they implement [`Sync`])\n//! but they do not themselves provide the mechanism for sharing and follow the\n//! [threading model](../../../std/thread/index.html#the-threading-model) of Rust.\n//! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n//! atomically-reference-counted shared pointer).\n//!\n//! [arc]: ../../../std/sync/struct.Arc.html\n//!\n//! Atomic types may be stored in static variables, initialized using\n//! the constant initializers like [`AtomicBool::new`]. Atomic statics\n//! are often used for lazy global initialization.\n//!\n//! # Portability\n//!\n//! All atomic types in this module are guaranteed to be [lock-free] if they're\n//! available. This means they don't internally acquire a global mutex. Atomic\n//! types and operations are not guaranteed to be wait-free. This means that\n//! operations like `fetch_or` may be implemented with a compare-and-swap loop.\n//!\n//! Atomic operations may be implemented at the instruction layer with\n//! larger-size atomics. For example some platforms use 4-byte atomic\n//! instructions to implement `AtomicI8`. Note that this emulation should not\n//! have an impact on correctness of code, it's just something to be aware of.\n//!\n//! The atomic types in this module may not be available on all platforms. The\n//! atomic types here are all widely available, however, and can generally be\n//! relied upon existing. Some notable exceptions are:\n//!\n//! * PowerPC and MIPS platforms with 32-bit pointers do not have `AtomicU64` or\n//!   `AtomicI64` types.\n//! * ARM platforms like `armv5te` that aren't for Linux only provide `load`\n//!   and `store` operations, and do not support Compare and Swap (CAS)\n//!   operations, such as `swap`, `fetch_add`, etc. Additionally on Linux,\n//!   these CAS operations are implemented via [operating system support], which\n//!   may come with a performance penalty.\n//! * ARM targets with `thumbv6m` only provide `load` and `store` operations,\n//!   and do not support Compare and Swap (CAS) operations, such as `swap`,\n//!   `fetch_add`, etc.\n//!\n//! [operating system support]: https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt\n//!\n//! Note that future platforms may be added that also do not have support for\n//! some atomic operations. Maximally portable code will want to be careful\n//! about which atomic types are used. `AtomicUsize` and `AtomicIsize` are\n//! generally the most portable, but even then they're not available everywhere.\n//! For reference, the `std` library requires pointer-sized atomics, although\n//! `core` does not.\n//!\n//! Currently you'll need to use `#[cfg(target_arch)]` primarily to\n//! conditionally compile in code with atomics. There is an unstable\n//! `#[cfg(target_has_atomic)]` as well which may be stabilized in the future.\n//!\n//! [lock-free]: https://en.wikipedia.org/wiki/Non-blocking_algorithm\n//!\n//! # Examples\n//!\n//! A simple spinlock:\n//!\n//! ```\n//! use std::sync::Arc;\n//! use std::sync::atomic::{AtomicUsize, Ordering};\n//! use std::{hint, thread};\n//!\n//! fn main() {\n//!     let spinlock = Arc::new(AtomicUsize::new(1));\n//!\n//!     let spinlock_clone = Arc::clone(&spinlock);\n//!     let thread = thread::spawn(move|| {\n//!         spinlock_clone.store(0, Ordering::SeqCst);\n//!     });\n//!\n//!     // Wait for the other thread to release the lock\n//!     while spinlock.load(Ordering::SeqCst) != 0 {\n//!         hint::spin_loop();\n//!     }\n//!\n//!     if let Err(panic) = thread.join() {\n//!         println!(\"Thread had an error: {:?}\", panic);\n//!     }\n//! }\n//! ```\n//!\n//! Keep a global count of live threads:\n//!\n//! ```\n//! use std::sync::atomic::{AtomicUsize, Ordering};\n//!\n//! static GLOBAL_THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);\n//!\n//! let old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(1, Ordering::SeqCst);\n//! println!(\"live threads: {}\", old_thread_count + 1);\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n\nuse self::Ordering::*;\n\nuse crate::cell::UnsafeCell;\nuse crate::fmt;\nuse crate::intrinsics;\n\nuse crate::hint::spin_loop;\n\n/// A boolean type which can be safely shared between threads.\n///\n/// This type has the same in-memory representation as a [`bool`].\n///\n/// **Note**: This type is only available on platforms that support atomic\n/// loads and stores of `u8`.\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[repr(C, align(1))]\npub struct AtomicBool {\n    v: UnsafeCell<u8>,\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Default for AtomicBool {\n    /// Creates an `AtomicBool` initialized to `false`.\n    #[inline]\n    fn default() -> Self {\n        Self::new(false)\n    }\n}\n\n// Send is implicitly implemented for AtomicBool.\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl Sync for AtomicBool {}\n\n/// A raw pointer type which can be safely shared between threads.\n///\n/// This type has the same in-memory representation as a `*mut T`.\n///\n/// **Note**: This type is only available on platforms that support atomic\n/// loads and stores of pointers. Its size depends on the target pointer's size.\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[cfg_attr(target_pointer_width = \"16\", repr(C, align(2)))]\n#[cfg_attr(target_pointer_width = \"32\", repr(C, align(4)))]\n#[cfg_attr(target_pointer_width = \"64\", repr(C, align(8)))]\npub struct AtomicPtr<T> {\n    p: UnsafeCell<*mut T>,\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for AtomicPtr<T> {\n    /// Creates a null `AtomicPtr<T>`.\n    fn default() -> AtomicPtr<T> {\n        AtomicPtr::new(crate::ptr::null_mut())\n    }\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T> Send for AtomicPtr<T> {}\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T> Sync for AtomicPtr<T> {}\n\n/// Atomic memory orderings\n///\n/// Memory orderings specify the way atomic operations synchronize memory.\n/// In its weakest [`Ordering::Relaxed`], only the memory directly touched by the\n/// operation is synchronized. On the other hand, a store-load pair of [`Ordering::SeqCst`]\n/// operations synchronize other memory while additionally preserving a total order of such\n/// operations across all threads.\n///\n/// Rust's memory orderings are [the same as those of\n/// C++20](https://en.cppreference.com/w/cpp/atomic/memory_order).\n///\n/// For more information see the [nomicon].\n///\n/// [nomicon]: ../../../nomicon/atomics.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n#[non_exhaustive]\npub enum Ordering {\n    /// No ordering constraints, only atomic operations.\n    ///\n    /// Corresponds to [`memory_order_relaxed`] in C++20.\n    ///\n    /// [`memory_order_relaxed`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Relaxed_ordering\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Relaxed,\n    /// When coupled with a store, all previous operations become ordered\n    /// before any load of this value with [`Acquire`] (or stronger) ordering.\n    /// In particular, all previous writes become visible to all threads\n    /// that perform an [`Acquire`] (or stronger) load of this value.\n    ///\n    /// Notice that using this ordering for an operation that combines loads\n    /// and stores leads to a [`Relaxed`] load operation!\n    ///\n    /// This ordering is only applicable for operations that can perform a store.\n    ///\n    /// Corresponds to [`memory_order_release`] in C++20.\n    ///\n    /// [`memory_order_release`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Release,\n    /// When coupled with a load, if the loaded value was written by a store operation with\n    /// [`Release`] (or stronger) ordering, then all subsequent operations\n    /// become ordered after that store. In particular, all subsequent loads will see data\n    /// written before the store.\n    ///\n    /// Notice that using this ordering for an operation that combines loads\n    /// and stores leads to a [`Relaxed`] store operation!\n    ///\n    /// This ordering is only applicable for operations that can perform a load.\n    ///\n    /// Corresponds to [`memory_order_acquire`] in C++20.\n    ///\n    /// [`memory_order_acquire`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Acquire,\n    /// Has the effects of both [`Acquire`] and [`Release`] together:\n    /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n    ///\n    /// Notice that in the case of `compare_and_swap`, it is possible that the operation ends up\n    /// not performing any store and hence it has just [`Acquire`] ordering. However,\n    /// `AcqRel` will never perform [`Relaxed`] accesses.\n    ///\n    /// This ordering is only applicable for operations that combine both loads and stores.\n    ///\n    /// Corresponds to [`memory_order_acq_rel`] in C++20.\n    ///\n    /// [`memory_order_acq_rel`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AcqRel,\n    /// Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n    /// operations, respectively) with the additional guarantee that all threads see all\n    /// sequentially consistent operations in the same order.\n    ///\n    /// Corresponds to [`memory_order_seq_cst`] in C++20.\n    ///\n    /// [`memory_order_seq_cst`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Sequentially-consistent_ordering\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    SeqCst,\n}\n\n/// An [`AtomicBool`] initialized to `false`.\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"1.34.0\",\n    reason = \"the `new` function is now preferred\",\n    suggestion = \"AtomicBool::new(false)\"\n)]\npub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n\n#[cfg(target_has_atomic_load_store = \"8\")]\nimpl AtomicBool {\n    /// Creates a new `AtomicBool`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicBool;\n    ///\n    /// let atomic_true  = AtomicBool::new(true);\n    /// let atomic_false = AtomicBool::new(false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_atomic_new\", since = \"1.24.0\")]\n    pub const fn new(v: bool) -> AtomicBool {\n        AtomicBool { v: UnsafeCell::new(v as u8) }\n    }\n\n    /// Returns a mutable reference to the underlying [`bool`].\n    ///\n    /// This is safe because the mutable reference guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let mut some_bool = AtomicBool::new(true);\n    /// assert_eq!(*some_bool.get_mut(), true);\n    /// *some_bool.get_mut() = false;\n    /// assert_eq!(some_bool.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn get_mut(&mut self) -> &mut bool {\n        // SAFETY: the mutable reference guarantees unique ownership.\n        unsafe { &mut *(self.v.get() as *mut bool) }\n    }\n\n    /// Get atomic access to a `&mut bool`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(atomic_from_mut)]\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let mut some_bool = true;\n    /// let a = AtomicBool::from_mut(&mut some_bool);\n    /// a.store(false, Ordering::Relaxed);\n    /// assert_eq!(some_bool, false);\n    /// ```\n    #[inline]\n    #[cfg(target_has_atomic_equal_alignment = \"8\")]\n    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n    pub fn from_mut(v: &mut bool) -> &Self {\n        // SAFETY: the mutable reference guarantees unique ownership, and\n        // alignment of both `bool` and `Self` is 1.\n        unsafe { &*(v as *mut bool as *mut Self) }\n    }\n\n    /// Consumes the atomic and returns the contained value.\n    ///\n    /// This is safe because passing `self` by value guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicBool;\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    /// assert_eq!(some_bool.into_inner(), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    #[rustc_const_unstable(feature = \"const_cell_into_inner\", issue = \"78729\")]\n    pub const fn into_inner(self) -> bool {\n        self.v.into_inner() != 0\n    }\n\n    /// Loads a value from the bool.\n    ///\n    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Release`] or [`AcqRel`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn load(&self, order: Ordering) -> bool {\n        // SAFETY: any data races are prevented by atomic intrinsics and the raw\n        // pointer passed in is valid because we got it from a reference.\n        unsafe { atomic_load(self.v.get(), order) != 0 }\n    }\n\n    /// Stores a value into the bool.\n    ///\n    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// some_bool.store(false, Ordering::Relaxed);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn store(&self, val: bool, order: Ordering) {\n        // SAFETY: any data races are prevented by atomic intrinsics and the raw\n        // pointer passed in is valid because we got it from a reference.\n        unsafe {\n            atomic_store(self.v.get(), val as u8, order);\n        }\n    }\n\n    /// Stores a value into the bool, returning the previous value.\n    ///\n    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on `u8`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.swap(false, Ordering::Relaxed), true);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn swap(&self, val: bool, order: Ordering) -> bool {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n    }\n\n    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n    ///\n    /// The return value is always the previous value. If it is equal to `current`, then the value\n    /// was updated.\n    ///\n    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n    /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n    /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n    /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n    /// happens, and using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on `u8`.\n    ///\n    /// # Migrating to `compare_exchange` and `compare_exchange_weak`\n    ///\n    /// `compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n    /// memory orderings:\n    ///\n    /// Original | Success | Failure\n    /// -------- | ------- | -------\n    /// Relaxed  | Relaxed | Relaxed\n    /// Acquire  | Acquire | Acquire\n    /// Release  | Release | Relaxed\n    /// AcqRel   | AcqRel  | Acquire\n    /// SeqCst   | SeqCst  | SeqCst\n    ///\n    /// `compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n    /// which allows the compiler to generate better assembly code when the compare and swap\n    /// is used in a loop.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.compare_and_swap(true, false, Ordering::Relaxed), true);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    ///\n    /// assert_eq!(some_bool.compare_and_swap(true, true, Ordering::Relaxed), false);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.50.0\",\n        reason = \"Use `compare_exchange` or `compare_exchange_weak` instead\"\n    )]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n            Ok(x) => x,\n            Err(x) => x,\n        }\n    }\n\n    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n    ///\n    /// The return value is a result indicating whether the new value was written and containing\n    /// the previous value. On success this value is guaranteed to be equal to `current`.\n    ///\n    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. `success` describes the required ordering for the\n    /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n    /// `failure` describes the required ordering for the load operation that takes place when\n    /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n    /// and must be equivalent to or weaker than the success ordering.\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on `u8`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.compare_exchange(true,\n    ///                                       false,\n    ///                                       Ordering::Acquire,\n    ///                                       Ordering::Relaxed),\n    ///            Ok(true));\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    ///\n    /// assert_eq!(some_bool.compare_exchange(true, true,\n    ///                                       Ordering::SeqCst,\n    ///                                       Ordering::Acquire),\n    ///            Err(false));\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    #[doc(alias = \"compare_and_swap\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn compare_exchange(\n        &self,\n        current: bool,\n        new: bool,\n        success: Ordering,\n        failure: Ordering,\n    ) -> Result<bool, bool> {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        match unsafe {\n            atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n        } {\n            Ok(x) => Ok(x != 0),\n            Err(x) => Err(x != 0),\n        }\n    }\n\n    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n    ///\n    /// Unlike [`AtomicBool::compare_exchange`], this function is allowed to spuriously fail even when the\n    /// comparison succeeds, which can result in more efficient code on some platforms. The\n    /// return value is a result indicating whether the new value was written and containing the\n    /// previous value.\n    ///\n    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. `success` describes the required ordering for the\n    /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n    /// `failure` describes the required ordering for the load operation that takes place when\n    /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n    /// and must be equivalent to or weaker than the success ordering.\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on `u8`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let val = AtomicBool::new(false);\n    ///\n    /// let new = true;\n    /// let mut old = val.load(Ordering::Relaxed);\n    /// loop {\n    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n    ///         Ok(_) => break,\n    ///         Err(x) => old = x,\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    #[doc(alias = \"compare_and_swap\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn compare_exchange_weak(\n        &self,\n        current: bool,\n        new: bool,\n        success: Ordering,\n        failure: Ordering,\n    ) -> Result<bool, bool> {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        match unsafe {\n            atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)\n        } {\n            Ok(x) => Ok(x != 0),\n            Err(x) => Err(x != 0),\n        }\n    }\n\n    /// Logical \"and\" with a boolean value.\n    ///\n    /// Performs a logical \"and\" operation on the current value and the argument `val`, and sets\n    /// the new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// `fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on `u8`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_and(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_and(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_and(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n    }\n\n    /// Logical \"nand\" with a boolean value.\n    ///\n    /// Performs a logical \"nand\" operation on the current value and the argument `val`, and sets\n    /// the new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// `fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on `u8`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_nand(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst) as usize, 0);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n        // We can't use atomic_nand here because it can result in a bool with\n        // an invalid value. This happens because the atomic operation is done\n        // with an 8-bit integer internally, which would set the upper 7 bits.\n        // So we just use fetch_xor or swap instead.\n        if val {\n            // !(x & true) == !x\n            // We must invert the bool.\n            self.fetch_xor(true, order)\n        } else {\n            // !(x & false) == true\n            // We must set the bool to true.\n            self.swap(true, order)\n        }\n    }\n\n    /// Logical \"or\" with a boolean value.\n    ///\n    /// Performs a logical \"or\" operation on the current value and the argument `val`, and sets the\n    /// new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// `fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on `u8`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_or(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_or(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_or(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n    }\n\n    /// Logical \"xor\" with a boolean value.\n    ///\n    /// Performs a logical \"xor\" operation on the current value and the argument `val`, and sets\n    /// the new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// `fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on `u8`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_xor(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n    }\n\n    /// Returns a mutable pointer to the underlying [`bool`].\n    ///\n    /// Doing non-atomic reads and writes on the resulting integer can be a data race.\n    /// This method is mostly useful for FFI, where the function signature may use\n    /// `*mut bool` instead of `&AtomicBool`.\n    ///\n    /// Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n    /// atomic types work with interior mutability. All modifications of an atomic change the value\n    /// through a shared reference, and can do so safely as long as they use atomic operations. Any\n    /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n    /// restriction: operations on it must be atomic.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore (extern-declaration)\n    /// # fn main() {\n    /// use std::sync::atomic::AtomicBool;\n    /// extern \"C\" {\n    ///     fn my_atomic_op(arg: *mut bool);\n    /// }\n    ///\n    /// let mut atomic = AtomicBool::new(true);\n    /// unsafe {\n    ///     my_atomic_op(atomic.as_mut_ptr());\n    /// }\n    /// # }\n    /// ```\n    #[inline]\n    #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n    pub fn as_mut_ptr(&self) -> *mut bool {\n        self.v.get() as *mut bool\n    }\n\n    /// Fetches the value, and applies a function to it that returns an optional\n    /// new value. Returns a `Result` of `Ok(previous_value)` if the function\n    /// returned `Some(_)`, else `Err(previous_value)`.\n    ///\n    /// Note: This may call the function multiple times if the value has been\n    /// changed from other threads in the meantime, as long as the function\n    /// returns `Some(_)`, but the function will have been applied only once to\n    /// the stored value.\n    ///\n    /// `fetch_update` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering for\n    /// when the operation finally succeeds while the second describes the\n    /// required ordering for loads. These correspond to the success and failure\n    /// orderings of [`AtomicBool::compare_exchange`] respectively.\n    ///\n    /// Using [`Acquire`] as success ordering makes the store part of this\n    /// operation [`Relaxed`], and using [`Release`] makes the final successful\n    /// load [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`],\n    /// [`Acquire`] or [`Relaxed`] and must be equivalent to or weaker than the\n    /// success ordering.\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on `u8`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let x = AtomicBool::new(false);\n    /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(false));\n    /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(!x)), Ok(false));\n    /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(!x)), Ok(true));\n    /// assert_eq!(x.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_fetch_update\", since = \"1.53.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn fetch_update<F>(\n        &self,\n        set_order: Ordering,\n        fetch_order: Ordering,\n        mut f: F,\n    ) -> Result<bool, bool>\n    where\n        F: FnMut(bool) -> Option<bool>,\n    {\n        let mut prev = self.load(fetch_order);\n        while let Some(next) = f(prev) {\n            match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n                x @ Ok(_) => return x,\n                Err(next_prev) => prev = next_prev,\n            }\n        }\n        Err(prev)\n    }\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\nimpl<T> AtomicPtr<T> {\n    /// Creates a new `AtomicPtr`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicPtr;\n    ///\n    /// let ptr = &mut 5;\n    /// let atomic_ptr  = AtomicPtr::new(ptr);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_atomic_new\", since = \"1.24.0\")]\n    pub const fn new(p: *mut T) -> AtomicPtr<T> {\n        AtomicPtr { p: UnsafeCell::new(p) }\n    }\n\n    /// Returns a mutable reference to the underlying pointer.\n    ///\n    /// This is safe because the mutable reference guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let mut data = 10;\n    /// let mut atomic_ptr = AtomicPtr::new(&mut data);\n    /// let mut other_data = 5;\n    /// *atomic_ptr.get_mut() = &mut other_data;\n    /// assert_eq!(unsafe { *atomic_ptr.load(Ordering::SeqCst) }, 5);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn get_mut(&mut self) -> &mut *mut T {\n        self.p.get_mut()\n    }\n\n    /// Get atomic access to a pointer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(atomic_from_mut)]\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let mut data = 123;\n    /// let mut some_ptr = &mut data as *mut i32;\n    /// let a = AtomicPtr::from_mut(&mut some_ptr);\n    /// let mut other_data = 456;\n    /// a.store(&mut other_data, Ordering::Relaxed);\n    /// assert_eq!(unsafe { *some_ptr }, 456);\n    /// ```\n    #[inline]\n    #[cfg(target_has_atomic_equal_alignment = \"ptr\")]\n    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n    pub fn from_mut(v: &mut *mut T) -> &Self {\n        use crate::mem::align_of;\n        let [] = [(); align_of::<AtomicPtr<()>>() - align_of::<*mut ()>()];\n        // SAFETY:\n        //  - the mutable reference guarantees unique ownership.\n        //  - the alignment of `*mut T` and `Self` is the same on all platforms\n        //    supported by rust, as verified above.\n        unsafe { &*(v as *mut *mut T as *mut Self) }\n    }\n\n    /// Consumes the atomic and returns the contained value.\n    ///\n    /// This is safe because passing `self` by value guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicPtr;\n    ///\n    /// let mut data = 5;\n    /// let atomic_ptr = AtomicPtr::new(&mut data);\n    /// assert_eq!(unsafe { *atomic_ptr.into_inner() }, 5);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    #[rustc_const_unstable(feature = \"const_cell_into_inner\", issue = \"78729\")]\n    pub const fn into_inner(self) -> *mut T {\n        self.p.into_inner()\n    }\n\n    /// Loads a value from the pointer.\n    ///\n    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Release`] or [`AcqRel`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let value = some_ptr.load(Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn load(&self, order: Ordering) -> *mut T {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        unsafe { atomic_load(self.p.get(), order) }\n    }\n\n    /// Stores a value into the pointer.\n    ///\n    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr = &mut 10;\n    ///\n    /// some_ptr.store(other_ptr, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn store(&self, ptr: *mut T, order: Ordering) {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        unsafe {\n            atomic_store(self.p.get(), ptr, order);\n        }\n    }\n\n    /// Stores a value into the pointer, returning the previous value.\n    ///\n    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on pointers.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr = &mut 10;\n    ///\n    /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"ptr\")]\n    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        unsafe { atomic_swap(self.p.get(), ptr, order) }\n    }\n\n    /// Stores a value into the pointer if the current value is the same as the `current` value.\n    ///\n    /// The return value is always the previous value. If it is equal to `current`, then the value\n    /// was updated.\n    ///\n    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n    /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n    /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n    /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n    /// happens, and using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on pointers.\n    ///\n    /// # Migrating to `compare_exchange` and `compare_exchange_weak`\n    ///\n    /// `compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n    /// memory orderings:\n    ///\n    /// Original | Success | Failure\n    /// -------- | ------- | -------\n    /// Relaxed  | Relaxed | Relaxed\n    /// Acquire  | Acquire | Acquire\n    /// Release  | Release | Relaxed\n    /// AcqRel   | AcqRel  | Acquire\n    /// SeqCst   | SeqCst  | SeqCst\n    ///\n    /// `compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n    /// which allows the compiler to generate better assembly code when the compare and swap\n    /// is used in a loop.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr   = &mut 10;\n    ///\n    /// let value = some_ptr.compare_and_swap(ptr, other_ptr, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.50.0\",\n        reason = \"Use `compare_exchange` or `compare_exchange_weak` instead\"\n    )]\n    #[cfg(target_has_atomic = \"ptr\")]\n    pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n        match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n            Ok(x) => x,\n            Err(x) => x,\n        }\n    }\n\n    /// Stores a value into the pointer if the current value is the same as the `current` value.\n    ///\n    /// The return value is a result indicating whether the new value was written and containing\n    /// the previous value. On success this value is guaranteed to be equal to `current`.\n    ///\n    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. `success` describes the required ordering for the\n    /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n    /// `failure` describes the required ordering for the load operation that takes place when\n    /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n    /// and must be equivalent to or weaker than the success ordering.\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on pointers.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr   = &mut 10;\n    ///\n    /// let value = some_ptr.compare_exchange(ptr, other_ptr,\n    ///                                       Ordering::SeqCst, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    #[cfg(target_has_atomic = \"ptr\")]\n    pub fn compare_exchange(\n        &self,\n        current: *mut T,\n        new: *mut T,\n        success: Ordering,\n        failure: Ordering,\n    ) -> Result<*mut T, *mut T> {\n        // SAFETY: data races are prevented by atomic intrinsics.\n        unsafe { atomic_compare_exchange(self.p.get(), current, new, success, failure) }\n    }\n\n    /// Stores a value into the pointer if the current value is the same as the `current` value.\n    ///\n    /// Unlike [`AtomicPtr::compare_exchange`], this function is allowed to spuriously fail even when the\n    /// comparison succeeds, which can result in more efficient code on some platforms. The\n    /// return value is a result indicating whether the new value was written and containing the\n    /// previous value.\n    ///\n    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. `success` describes the required ordering for the\n    /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n    /// `failure` describes the required ordering for the load operation that takes place when\n    /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n    /// and must be equivalent to or weaker than the success ordering.\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on pointers.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let some_ptr = AtomicPtr::new(&mut 5);\n    ///\n    /// let new = &mut 10;\n    /// let mut old = some_ptr.load(Ordering::Relaxed);\n    /// loop {\n    ///     match some_ptr.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n    ///         Ok(_) => break,\n    ///         Err(x) => old = x,\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    #[cfg(target_has_atomic = \"ptr\")]\n    pub fn compare_exchange_weak(\n        &self,\n        current: *mut T,\n        new: *mut T,\n        success: Ordering,\n        failure: Ordering,\n    ) -> Result<*mut T, *mut T> {\n        // SAFETY: This intrinsic is unsafe because it operates on a raw pointer\n        // but we know for sure that the pointer is valid (we just got it from\n        // an `UnsafeCell` that we have by reference) and the atomic operation\n        // itself allows us to safely mutate the `UnsafeCell` contents.\n        unsafe { atomic_compare_exchange_weak(self.p.get(), current, new, success, failure) }\n    }\n\n    /// Fetches the value, and applies a function to it that returns an optional\n    /// new value. Returns a `Result` of `Ok(previous_value)` if the function\n    /// returned `Some(_)`, else `Err(previous_value)`.\n    ///\n    /// Note: This may call the function multiple times if the value has been\n    /// changed from other threads in the meantime, as long as the function\n    /// returns `Some(_)`, but the function will have been applied only once to\n    /// the stored value.\n    ///\n    /// `fetch_update` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering for\n    /// when the operation finally succeeds while the second describes the\n    /// required ordering for loads. These correspond to the success and failure\n    /// orderings of [`AtomicPtr::compare_exchange`] respectively.\n    ///\n    /// Using [`Acquire`] as success ordering makes the store part of this\n    /// operation [`Relaxed`], and using [`Release`] makes the final successful\n    /// load [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`],\n    /// [`Acquire`] or [`Relaxed`] and must be equivalent to or weaker than the\n    /// success ordering.\n    ///\n    /// **Note:** This method is only available on platforms that support atomic\n    /// operations on pointers.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr: *mut _ = &mut 5;\n    /// let some_ptr = AtomicPtr::new(ptr);\n    ///\n    /// let new: *mut _ = &mut 10;\n    /// assert_eq!(some_ptr.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(ptr));\n    /// let result = some_ptr.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| {\n    ///     if x == ptr {\n    ///         Some(new)\n    ///     } else {\n    ///         None\n    ///     }\n    /// });\n    /// assert_eq!(result, Ok(ptr));\n    /// assert_eq!(some_ptr.load(Ordering::SeqCst), new);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_fetch_update\", since = \"1.53.0\")]\n    #[cfg(target_has_atomic = \"ptr\")]\n    pub fn fetch_update<F>(\n        &self,\n        set_order: Ordering,\n        fetch_order: Ordering,\n        mut f: F,\n    ) -> Result<*mut T, *mut T>\n    where\n        F: FnMut(*mut T) -> Option<*mut T>,\n    {\n        let mut prev = self.load(fetch_order);\n        while let Some(next) = f(prev) {\n            match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n                x @ Ok(_) => return x,\n                Err(next_prev) => prev = next_prev,\n            }\n        }\n        Err(prev)\n    }\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\nimpl From<bool> for AtomicBool {\n    /// Converts a `bool` into an `AtomicBool`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicBool;\n    /// let atomic_bool = AtomicBool::from(true);\n    /// assert_eq!(format!(\"{:?}\", atomic_bool), \"true\")\n    /// ```\n    #[inline]\n    fn from(b: bool) -> Self {\n        Self::new(b)\n    }\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"atomic_from\", since = \"1.23.0\")]\nimpl<T> From<*mut T> for AtomicPtr<T> {\n    #[inline]\n    fn from(p: *mut T) -> Self {\n        Self::new(p)\n    }\n}\n\n#[allow(unused_macros)] // This macro ends up being unused on some architectures.\nmacro_rules! if_not_8_bit {\n    (u8, $($tt:tt)*) => { \"\" };\n    (i8, $($tt:tt)*) => { \"\" };\n    ($_:ident, $($tt:tt)*) => { $($tt)* };\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\nmacro_rules! atomic_int {\n    ($cfg_cas:meta,\n     $cfg_align:meta,\n     $stable:meta,\n     $stable_cxchg:meta,\n     $stable_debug:meta,\n     $stable_access:meta,\n     $stable_from:meta,\n     $stable_nand:meta,\n     $const_stable:meta,\n     $stable_init_const:meta,\n     $s_int_type:literal,\n     $extra_feature:expr,\n     $min_fn:ident, $max_fn:ident,\n     $align:expr,\n     $atomic_new:expr,\n     $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n        /// An integer type which can be safely shared between threads.\n        ///\n        /// This type has the same in-memory representation as the underlying\n        /// integer type, [`\n        #[doc = $s_int_type]\n        /// `]. For more about the differences between atomic types and\n        /// non-atomic types as well as information about the portability of\n        /// this type, please see the [module-level documentation].\n        ///\n        /// **Note:** This type is only available on platforms that support\n        /// atomic loads and stores of [`\n        #[doc = $s_int_type]\n        /// `].\n        ///\n        /// [module-level documentation]: crate::sync::atomic\n        #[$stable]\n        #[repr(C, align($align))]\n        pub struct $atomic_type {\n            v: UnsafeCell<$int_type>,\n        }\n\n        /// An atomic integer initialized to `0`.\n        #[$stable_init_const]\n        #[rustc_deprecated(\n            since = \"1.34.0\",\n            reason = \"the `new` function is now preferred\",\n            suggestion = $atomic_new,\n        )]\n        pub const $atomic_init: $atomic_type = $atomic_type::new(0);\n\n        #[$stable]\n        impl Default for $atomic_type {\n            #[inline]\n            fn default() -> Self {\n                Self::new(Default::default())\n            }\n        }\n\n        #[$stable_from]\n        impl From<$int_type> for $atomic_type {\n            #[doc = concat!(\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\")]\n            #[inline]\n            fn from(v: $int_type) -> Self { Self::new(v) }\n        }\n\n        #[$stable_debug]\n        impl fmt::Debug for $atomic_type {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n            }\n        }\n\n        // Send is implicitly implemented.\n        #[$stable]\n        unsafe impl Sync for $atomic_type {}\n\n        impl $atomic_type {\n            /// Creates a new atomic integer.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\")]\n            ///\n            #[doc = concat!(\"let atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\")]\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$const_stable]\n            pub const fn new(v: $int_type) -> Self {\n                Self {v: UnsafeCell::new(v)}\n            }\n\n            /// Returns a mutable reference to the underlying integer.\n            ///\n            /// This is safe because the mutable reference guarantees that no other threads are\n            /// concurrently accessing the atomic data.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let mut some_var = \", stringify!($atomic_type), \"::new(10);\")]\n            /// assert_eq!(*some_var.get_mut(), 10);\n            /// *some_var.get_mut() = 5;\n            /// assert_eq!(some_var.load(Ordering::SeqCst), 5);\n            /// ```\n            #[inline]\n            #[$stable_access]\n            pub fn get_mut(&mut self) -> &mut $int_type {\n                self.v.get_mut()\n            }\n\n            #[doc = concat!(\"Get atomic access to a `&mut \", stringify!($int_type), \"`.\")]\n            ///\n            #[doc = if_not_8_bit! {\n                $int_type,\n                concat!(\n                    \"**Note:** This function is only available on targets where `\",\n                    stringify!($int_type), \"` has an alignment of \", $align, \" bytes.\"\n                )\n            }]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            /// #![feature(atomic_from_mut)]\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            /// let mut some_int = 123;\n            #[doc = concat!(\"let a = \", stringify!($atomic_type), \"::from_mut(&mut some_int);\")]\n            /// a.store(100, Ordering::Relaxed);\n            /// assert_eq!(some_int, 100);\n            /// ```\n            ///\n            #[inline]\n            #[$cfg_align]\n            #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n            pub fn from_mut(v: &mut $int_type) -> &Self {\n                use crate::mem::align_of;\n                let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n                // SAFETY:\n                //  - the mutable reference guarantees unique ownership.\n                //  - the alignment of `$int_type` and `Self` is the\n                //    same, as promised by $cfg_align and verified above.\n                unsafe { &*(v as *mut $int_type as *mut Self) }\n            }\n\n            /// Consumes the atomic and returns the contained value.\n            ///\n            /// This is safe because passing `self` by value guarantees that no other threads are\n            /// concurrently accessing the atomic data.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            /// assert_eq!(some_var.into_inner(), 5);\n            /// ```\n            #[inline]\n            #[$stable_access]\n            #[rustc_const_unstable(feature = \"const_cell_into_inner\", issue = \"78729\")]\n            pub const fn into_inner(self) -> $int_type {\n                self.v.into_inner()\n            }\n\n            /// Loads a value from the atomic integer.\n            ///\n            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n            /// Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n            ///\n            /// # Panics\n            ///\n            /// Panics if `order` is [`Release`] or [`AcqRel`].\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 5);\n            /// ```\n            #[inline]\n            #[$stable]\n            pub fn load(&self, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_load(self.v.get(), order) }\n            }\n\n            /// Stores a value into the atomic integer.\n            ///\n            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n            ///  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n            ///\n            /// # Panics\n            ///\n            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// some_var.store(10, Ordering::Relaxed);\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            pub fn store(&self, val: $int_type, order: Ordering) {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_store(self.v.get(), val, order); }\n            }\n\n            /// Stores a value into the atomic integer, returning the previous value.\n            ///\n            /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_swap(self.v.get(), val, order) }\n            }\n\n            /// Stores a value into the atomic integer if the current value is the same as\n            /// the `current` value.\n            ///\n            /// The return value is always the previous value. If it is equal to `current`, then the\n            /// value was updated.\n            ///\n            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n            /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n            /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n            /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n            /// happens, and using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Migrating to `compare_exchange` and `compare_exchange_weak`\n            ///\n            /// `compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n            /// memory orderings:\n            ///\n            /// Original | Success | Failure\n            /// -------- | ------- | -------\n            /// Relaxed  | Relaxed | Relaxed\n            /// Acquire  | Acquire | Acquire\n            /// Release  | Release | Relaxed\n            /// AcqRel   | AcqRel  | Acquire\n            /// SeqCst   | SeqCst  | SeqCst\n            ///\n            /// `compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n            /// which allows the compiler to generate better assembly code when the compare and swap\n            /// is used in a loop.\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            ///\n            /// assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[rustc_deprecated(\n                since = \"1.50.0\",\n                reason = \"Use `compare_exchange` or `compare_exchange_weak` instead\")\n            ]\n            #[$cfg_cas]\n            pub fn compare_and_swap(&self,\n                                    current: $int_type,\n                                    new: $int_type,\n                                    order: Ordering) -> $int_type {\n                match self.compare_exchange(current,\n                                            new,\n                                            order,\n                                            strongest_failure_ordering(order)) {\n                    Ok(x) => x,\n                    Err(x) => x,\n                }\n            }\n\n            /// Stores a value into the atomic integer if the current value is the same as\n            /// the `current` value.\n            ///\n            /// The return value is a result indicating whether the new value was written and\n            /// containing the previous value. On success this value is guaranteed to be equal to\n            /// `current`.\n            ///\n            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n            /// ordering of this operation. `success` describes the required ordering for the\n            /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n            /// `failure` describes the required ordering for the load operation that takes place when\n            /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n            /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n            /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n            /// and must be equivalent to or weaker than the success ordering.\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n            ///\n            /// assert_eq!(some_var.compare_exchange(5, 10,\n            ///                                      Ordering::Acquire,\n            ///                                      Ordering::Relaxed),\n            ///            Ok(5));\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            ///\n            /// assert_eq!(some_var.compare_exchange(6, 12,\n            ///                                      Ordering::SeqCst,\n            ///                                      Ordering::Acquire),\n            ///            Err(10));\n            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n            /// ```\n            #[inline]\n            #[$stable_cxchg]\n            #[$cfg_cas]\n            pub fn compare_exchange(&self,\n                                    current: $int_type,\n                                    new: $int_type,\n                                    success: Ordering,\n                                    failure: Ordering) -> Result<$int_type, $int_type> {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n            }\n\n            /// Stores a value into the atomic integer if the current value is the same as\n            /// the `current` value.\n            ///\n            #[doc = concat!(\"Unlike [`\", stringify!($atomic_type), \"::compare_exchange`],\")]\n            /// this function is allowed to spuriously fail even\n            /// when the comparison succeeds, which can result in more efficient code on some\n            /// platforms. The return value is a result indicating whether the new value was\n            /// written and containing the previous value.\n            ///\n            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n            /// ordering of this operation. `success` describes the required ordering for the\n            /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n            /// `failure` describes the required ordering for the load operation that takes place when\n            /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n            /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n            /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n            /// and must be equivalent to or weaker than the success ordering.\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let val = \", stringify!($atomic_type), \"::new(4);\")]\n            ///\n            /// let mut old = val.load(Ordering::Relaxed);\n            /// loop {\n            ///     let new = old * 2;\n            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n            ///         Ok(_) => break,\n            ///         Err(x) => old = x,\n            ///     }\n            /// }\n            /// ```\n            #[inline]\n            #[$stable_cxchg]\n            #[$cfg_cas]\n            pub fn compare_exchange_weak(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n                                         success: Ordering,\n                                         failure: Ordering) -> Result<$int_type, $int_type> {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe {\n                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n                }\n            }\n\n            /// Adds to the current value, returning the previous value.\n            ///\n            /// This operation wraps around on overflow.\n            ///\n            /// `fetch_add` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0);\")]\n            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_add(self.v.get(), val, order) }\n            }\n\n            /// Subtracts from the current value, returning the previous value.\n            ///\n            /// This operation wraps around on overflow.\n            ///\n            /// `fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(20);\")]\n            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_sub(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"and\" with the current value.\n            ///\n            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0b101101);\")]\n            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_and(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"nand\" with the current value.\n            ///\n            /// Performs a bitwise \"nand\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0x13);\")]\n            /// assert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\n            /// assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n            /// ```\n            #[inline]\n            #[$stable_nand]\n            #[$cfg_cas]\n            pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_nand(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"or\" with the current value.\n            ///\n            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0b101101);\")]\n            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_or(self.v.get(), val, order) }\n            }\n\n            /// Bitwise \"xor\" with the current value.\n            ///\n            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0b101101);\")]\n            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n            /// ```\n            #[inline]\n            #[$stable]\n            #[$cfg_cas]\n            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { atomic_xor(self.v.get(), val, order) }\n            }\n\n            /// Fetches the value, and applies a function to it that returns an optional\n            /// new value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n            /// `Err(previous_value)`.\n            ///\n            /// Note: This may call the function multiple times if the value has been changed from other threads in\n            /// the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n            /// only once to the stored value.\n            ///\n            /// `fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n            /// The first describes the required ordering for when the operation finally succeeds while the second\n            /// describes the required ordering for loads. These correspond to the success and failure orderings of\n            #[doc = concat!(\"[`\", stringify!($atomic_type), \"::compare_exchange`]\")]\n            /// respectively.\n            ///\n            /// Using [`Acquire`] as success ordering makes the store part\n            /// of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n            /// [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n            /// and must be equivalent to or weaker than the success ordering.\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```rust\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let x = \", stringify!($atomic_type), \"::new(7);\")]\n            /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n            /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n            /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n            /// assert_eq!(x.load(Ordering::SeqCst), 9);\n            /// ```\n            #[inline]\n            #[stable(feature = \"no_more_cas\", since = \"1.45.0\")]\n            #[$cfg_cas]\n            pub fn fetch_update<F>(&self,\n                                   set_order: Ordering,\n                                   fetch_order: Ordering,\n                                   mut f: F) -> Result<$int_type, $int_type>\n            where F: FnMut($int_type) -> Option<$int_type> {\n                let mut prev = self.load(fetch_order);\n                while let Some(next) = f(prev) {\n                    match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n                        x @ Ok(_) => return x,\n                        Err(next_prev) => prev = next_prev\n                    }\n                }\n                Err(prev)\n            }\n\n            /// Maximum with the current value.\n            ///\n            /// Finds the maximum of the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_max` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n            /// assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n            /// assert_eq!(foo.load(Ordering::SeqCst), 42);\n            /// ```\n            ///\n            /// If you want to obtain the maximum value in one step, you can use the following:\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n            /// let bar = 42;\n            /// let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n            /// assert!(max_foo == 42);\n            /// ```\n            #[inline]\n            #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n            #[$cfg_cas]\n            pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { $max_fn(self.v.get(), val, order) }\n            }\n\n            /// Minimum with the current value.\n            ///\n            /// Finds the minimum of the current value and the argument `val`, and\n            /// sets the new value to the result.\n            ///\n            /// Returns the previous value.\n            ///\n            /// `fetch_min` takes an [`Ordering`] argument which describes the memory ordering\n            /// of this operation. All ordering modes are possible. Note that using\n            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n            /// using [`Release`] makes the load part [`Relaxed`].\n            ///\n            /// **Note**: This method is only available on platforms that support atomic operations on\n            #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n            ///\n            /// # Examples\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n            /// assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n            /// assert_eq!(foo.load(Ordering::Relaxed), 23);\n            /// assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n            /// assert_eq!(foo.load(Ordering::Relaxed), 22);\n            /// ```\n            ///\n            /// If you want to obtain the minimum value in one step, you can use the following:\n            ///\n            /// ```\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n            ///\n            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n            /// let bar = 12;\n            /// let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n            /// assert_eq!(min_foo, 12);\n            /// ```\n            #[inline]\n            #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n            #[$cfg_cas]\n            pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                // SAFETY: data races are prevented by atomic intrinsics.\n                unsafe { $min_fn(self.v.get(), val, order) }\n            }\n\n            /// Returns a mutable pointer to the underlying integer.\n            ///\n            /// Doing non-atomic reads and writes on the resulting integer can be a data race.\n            /// This method is mostly useful for FFI, where the function signature may use\n            #[doc = concat!(\"`*mut \", stringify!($int_type), \"` instead of `&\", stringify!($atomic_type), \"`.\")]\n            ///\n            /// Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n            /// atomic types work with interior mutability. All modifications of an atomic change the value\n            /// through a shared reference, and can do so safely as long as they use atomic operations. Any\n            /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n            /// restriction: operations on it must be atomic.\n            ///\n            /// # Examples\n            ///\n            /// ```ignore (extern-declaration)\n            /// # fn main() {\n            #[doc = concat!($extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\")]\n            ///\n            /// extern \"C\" {\n            #[doc = concat!(\"    fn my_atomic_op(arg: *mut \", stringify!($int_type), \");\")]\n            /// }\n            ///\n            #[doc = concat!(\"let mut atomic = \", stringify!($atomic_type), \"::new(1);\")]\n            ///\n            // SAFETY: Safe as long as `my_atomic_op` is atomic.\n            /// unsafe {\n            ///     my_atomic_op(atomic.as_mut_ptr());\n            /// }\n            /// # }\n            /// ```\n            #[inline]\n            #[unstable(feature = \"atomic_mut_ptr\",\n                   reason = \"recently added\",\n                   issue = \"66893\")]\n            pub fn as_mut_ptr(&self) -> *mut $int_type {\n                self.v.get()\n            }\n        }\n    }\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\natomic_int! {\n    cfg(target_has_atomic = \"8\"),\n    cfg(target_has_atomic_equal_alignment = \"8\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i8\",\n    \"\",\n    atomic_min, atomic_max,\n    1,\n    \"AtomicI8::new(0)\",\n    i8 AtomicI8 ATOMIC_I8_INIT\n}\n#[cfg(target_has_atomic_load_store = \"8\")]\natomic_int! {\n    cfg(target_has_atomic = \"8\"),\n    cfg(target_has_atomic_equal_alignment = \"8\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u8\",\n    \"\",\n    atomic_umin, atomic_umax,\n    1,\n    \"AtomicU8::new(0)\",\n    u8 AtomicU8 ATOMIC_U8_INIT\n}\n#[cfg(target_has_atomic_load_store = \"16\")]\natomic_int! {\n    cfg(target_has_atomic = \"16\"),\n    cfg(target_has_atomic_equal_alignment = \"16\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i16\",\n    \"\",\n    atomic_min, atomic_max,\n    2,\n    \"AtomicI16::new(0)\",\n    i16 AtomicI16 ATOMIC_I16_INIT\n}\n#[cfg(target_has_atomic_load_store = \"16\")]\natomic_int! {\n    cfg(target_has_atomic = \"16\"),\n    cfg(target_has_atomic_equal_alignment = \"16\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u16\",\n    \"\",\n    atomic_umin, atomic_umax,\n    2,\n    \"AtomicU16::new(0)\",\n    u16 AtomicU16 ATOMIC_U16_INIT\n}\n#[cfg(target_has_atomic_load_store = \"32\")]\natomic_int! {\n    cfg(target_has_atomic = \"32\"),\n    cfg(target_has_atomic_equal_alignment = \"32\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i32\",\n    \"\",\n    atomic_min, atomic_max,\n    4,\n    \"AtomicI32::new(0)\",\n    i32 AtomicI32 ATOMIC_I32_INIT\n}\n#[cfg(target_has_atomic_load_store = \"32\")]\natomic_int! {\n    cfg(target_has_atomic = \"32\"),\n    cfg(target_has_atomic_equal_alignment = \"32\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u32\",\n    \"\",\n    atomic_umin, atomic_umax,\n    4,\n    \"AtomicU32::new(0)\",\n    u32 AtomicU32 ATOMIC_U32_INIT\n}\n#[cfg(target_has_atomic_load_store = \"64\")]\natomic_int! {\n    cfg(target_has_atomic = \"64\"),\n    cfg(target_has_atomic_equal_alignment = \"64\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i64\",\n    \"\",\n    atomic_min, atomic_max,\n    8,\n    \"AtomicI64::new(0)\",\n    i64 AtomicI64 ATOMIC_I64_INIT\n}\n#[cfg(target_has_atomic_load_store = \"64\")]\natomic_int! {\n    cfg(target_has_atomic = \"64\"),\n    cfg(target_has_atomic_equal_alignment = \"64\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u64\",\n    \"\",\n    atomic_umin, atomic_umax,\n    8,\n    \"AtomicU64::new(0)\",\n    u64 AtomicU64 ATOMIC_U64_INIT\n}\n#[cfg(target_has_atomic_load_store = \"128\")]\natomic_int! {\n    cfg(target_has_atomic = \"128\"),\n    cfg(target_has_atomic_equal_alignment = \"128\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i128\",\n    \"#![feature(integer_atomics)]\\n\\n\",\n    atomic_min, atomic_max,\n    16,\n    \"AtomicI128::new(0)\",\n    i128 AtomicI128 ATOMIC_I128_INIT\n}\n#[cfg(target_has_atomic_load_store = \"128\")]\natomic_int! {\n    cfg(target_has_atomic = \"128\"),\n    cfg(target_has_atomic_equal_alignment = \"128\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u128\",\n    \"#![feature(integer_atomics)]\\n\\n\",\n    atomic_umin, atomic_umax,\n    16,\n    \"AtomicU128::new(0)\",\n    u128 AtomicU128 ATOMIC_U128_INIT\n}\n\nmacro_rules! atomic_int_ptr_sized {\n    ( $($target_pointer_width:literal $align:literal)* ) => { $(\n        #[cfg(target_has_atomic_load_store = \"ptr\")]\n        #[cfg(target_pointer_width = $target_pointer_width)]\n        atomic_int! {\n            cfg(target_has_atomic = \"ptr\"),\n            cfg(target_has_atomic_equal_alignment = \"ptr\"),\n            stable(feature = \"rust1\", since = \"1.0.0\"),\n            stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n            stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n            stable(feature = \"atomic_access\", since = \"1.15.0\"),\n            stable(feature = \"atomic_from\", since = \"1.23.0\"),\n            stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n            rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.24.0\"),\n            stable(feature = \"rust1\", since = \"1.0.0\"),\n            \"isize\",\n            \"\",\n            atomic_min, atomic_max,\n            $align,\n            \"AtomicIsize::new(0)\",\n            isize AtomicIsize ATOMIC_ISIZE_INIT\n        }\n        #[cfg(target_has_atomic_load_store = \"ptr\")]\n        #[cfg(target_pointer_width = $target_pointer_width)]\n        atomic_int! {\n            cfg(target_has_atomic = \"ptr\"),\n            cfg(target_has_atomic_equal_alignment = \"ptr\"),\n            stable(feature = \"rust1\", since = \"1.0.0\"),\n            stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n            stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n            stable(feature = \"atomic_access\", since = \"1.15.0\"),\n            stable(feature = \"atomic_from\", since = \"1.23.0\"),\n            stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n            rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.24.0\"),\n            stable(feature = \"rust1\", since = \"1.0.0\"),\n            \"usize\",\n            \"\",\n            atomic_umin, atomic_umax,\n            $align,\n            \"AtomicUsize::new(0)\",\n            usize AtomicUsize ATOMIC_USIZE_INIT\n        }\n    )* };\n}\n\natomic_int_ptr_sized! {\n    \"16\" 2\n    \"32\" 4\n    \"64\" 8\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nfn strongest_failure_ordering(order: Ordering) -> Ordering {\n    match order {\n        Release => Relaxed,\n        Relaxed => Relaxed,\n        SeqCst => SeqCst,\n        Acquire => Acquire,\n        AcqRel => Acquire,\n    }\n}\n\n#[inline]\nunsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {\n    // SAFETY: the caller must uphold the safety contract for `atomic_store`.\n    unsafe {\n        match order {\n            Release => intrinsics::atomic_store_rel(dst, val),\n            Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_store(dst, val),\n            Acquire => panic!(\"there is no such thing as an acquire store\"),\n            AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n        }\n    }\n}\n\n#[inline]\nunsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_load`.\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_load_acq(dst),\n            Relaxed => intrinsics::atomic_load_relaxed(dst),\n            SeqCst => intrinsics::atomic_load(dst),\n            Release => panic!(\"there is no such thing as a release load\"),\n            AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n        }\n    }\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_xchg_acq(dst, val),\n            Release => intrinsics::atomic_xchg_rel(dst, val),\n            AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_xchg(dst, val),\n        }\n    }\n}\n\n/// Returns the previous value (like __sync_fetch_and_add).\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_xadd_acq(dst, val),\n            Release => intrinsics::atomic_xadd_rel(dst, val),\n            AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_xadd(dst, val),\n        }\n    }\n}\n\n/// Returns the previous value (like __sync_fetch_and_sub).\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_xsub_acq(dst, val),\n            Release => intrinsics::atomic_xsub_rel(dst, val),\n            AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_xsub(dst, val),\n        }\n    }\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_compare_exchange<T: Copy>(\n    dst: *mut T,\n    old: T,\n    new: T,\n    success: Ordering,\n    failure: Ordering,\n) -> Result<T, T> {\n    // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange`.\n    let (val, ok) = unsafe {\n        match (success, failure) {\n            (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n            (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n            (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n            (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n            (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n            (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n            (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n            (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n            (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n            (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n            _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n        }\n    };\n    if ok { Ok(val) } else { Err(val) }\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_compare_exchange_weak<T: Copy>(\n    dst: *mut T,\n    old: T,\n    new: T,\n    success: Ordering,\n    failure: Ordering,\n) -> Result<T, T> {\n    // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange_weak`.\n    let (val, ok) = unsafe {\n        match (success, failure) {\n            (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n            (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n            (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n            (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n            (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n            (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n            (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n            (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n            (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n            (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n            _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n        }\n    };\n    if ok { Ok(val) } else { Err(val) }\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_and`\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_and_acq(dst, val),\n            Release => intrinsics::atomic_and_rel(dst, val),\n            AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_and(dst, val),\n        }\n    }\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_nand_acq(dst, val),\n            Release => intrinsics::atomic_nand_rel(dst, val),\n            AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_nand(dst, val),\n        }\n    }\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_or`\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_or_acq(dst, val),\n            Release => intrinsics::atomic_or_rel(dst, val),\n            AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_or(dst, val),\n        }\n    }\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_xor_acq(dst, val),\n            Release => intrinsics::atomic_xor_rel(dst, val),\n            AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_xor(dst, val),\n        }\n    }\n}\n\n/// returns the max value (signed comparison)\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_max`\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_max_acq(dst, val),\n            Release => intrinsics::atomic_max_rel(dst, val),\n            AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_max(dst, val),\n        }\n    }\n}\n\n/// returns the min value (signed comparison)\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_min`\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_min_acq(dst, val),\n            Release => intrinsics::atomic_min_rel(dst, val),\n            AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_min(dst, val),\n        }\n    }\n}\n\n/// returns the max value (unsigned comparison)\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_umax_acq(dst, val),\n            Release => intrinsics::atomic_umax_rel(dst, val),\n            AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_umax(dst, val),\n        }\n    }\n}\n\n/// returns the min value (unsigned comparison)\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n    // SAFETY: the caller must uphold the safety contract for `atomic_umin`\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_umin_acq(dst, val),\n            Release => intrinsics::atomic_umin_rel(dst, val),\n            AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n            Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n            SeqCst => intrinsics::atomic_umin(dst, val),\n        }\n    }\n}\n\n/// An atomic fence.\n///\n/// Depending on the specified order, a fence prevents the compiler and CPU from\n/// reordering certain types of memory operations around it.\n/// That creates synchronizes-with relationships between it and atomic operations\n/// or fences in other threads.\n///\n/// A fence 'A' which has (at least) [`Release`] ordering semantics, synchronizes\n/// with a fence 'B' with (at least) [`Acquire`] semantics, if and only if there\n/// exist operations X and Y, both operating on some atomic object 'M' such\n/// that A is sequenced before X, Y is synchronized before B and Y observes\n/// the change to M. This provides a happens-before dependence between A and B.\n///\n/// ```text\n///     Thread 1                                          Thread 2\n///\n/// fence(Release);      A --------------\n/// x.store(3, Relaxed); X ---------    |\n///                                |    |\n///                                |    |\n///                                -------------> Y  if x.load(Relaxed) == 3 {\n///                                     |-------> B      fence(Acquire);\n///                                                      ...\n///                                                  }\n/// ```\n///\n/// Atomic operations with [`Release`] or [`Acquire`] semantics can also synchronize\n/// with a fence.\n///\n/// A fence which has [`SeqCst`] ordering, in addition to having both [`Acquire`]\n/// and [`Release`] semantics, participates in the global program order of the\n/// other [`SeqCst`] operations and/or fences.\n///\n/// Accepts [`Acquire`], [`Release`], [`AcqRel`] and [`SeqCst`] orderings.\n///\n/// # Panics\n///\n/// Panics if `order` is [`Relaxed`].\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::atomic::AtomicBool;\n/// use std::sync::atomic::fence;\n/// use std::sync::atomic::Ordering;\n///\n/// // A mutual exclusion primitive based on spinlock.\n/// pub struct Mutex {\n///     flag: AtomicBool,\n/// }\n///\n/// impl Mutex {\n///     pub fn new() -> Mutex {\n///         Mutex {\n///             flag: AtomicBool::new(false),\n///         }\n///     }\n///\n///     pub fn lock(&self) {\n///         // Wait until the old value is `false`.\n///         while self.flag.compare_and_swap(false, true, Ordering::Relaxed) != false {}\n///         // This fence synchronizes-with store in `unlock`.\n///         fence(Ordering::Acquire);\n///     }\n///\n///     pub fn unlock(&self) {\n///         self.flag.store(false, Ordering::Release);\n///     }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn fence(order: Ordering) {\n    // SAFETY: using an atomic fence is safe.\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_fence_acq(),\n            Release => intrinsics::atomic_fence_rel(),\n            AcqRel => intrinsics::atomic_fence_acqrel(),\n            SeqCst => intrinsics::atomic_fence(),\n            Relaxed => panic!(\"there is no such thing as a relaxed fence\"),\n        }\n    }\n}\n\n/// A compiler memory fence.\n///\n/// `compiler_fence` does not emit any machine code, but restricts the kinds\n/// of memory re-ordering the compiler is allowed to do. Specifically, depending on\n/// the given [`Ordering`] semantics, the compiler may be disallowed from moving reads\n/// or writes from before or after the call to the other side of the call to\n/// `compiler_fence`. Note that it does **not** prevent the *hardware*\n/// from doing such re-ordering. This is not a problem in a single-threaded,\n/// execution context, but when other threads may modify memory at the same\n/// time, stronger synchronization primitives such as [`fence`] are required.\n///\n/// The re-ordering prevented by the different ordering semantics are:\n///\n///  - with [`SeqCst`], no re-ordering of reads and writes across this point is allowed.\n///  - with [`Release`], preceding reads and writes cannot be moved past subsequent writes.\n///  - with [`Acquire`], subsequent reads and writes cannot be moved ahead of preceding reads.\n///  - with [`AcqRel`], both of the above rules are enforced.\n///\n/// `compiler_fence` is generally only useful for preventing a thread from\n/// racing *with itself*. That is, if a given thread is executing one piece\n/// of code, and is then interrupted, and starts executing code elsewhere\n/// (while still in the same thread, and conceptually still on the same\n/// core). In traditional programs, this can only occur when a signal\n/// handler is registered. In more low-level code, such situations can also\n/// arise when handling interrupts, when implementing green threads with\n/// pre-emption, etc. Curious readers are encouraged to read the Linux kernel's\n/// discussion of [memory barriers].\n///\n/// # Panics\n///\n/// Panics if `order` is [`Relaxed`].\n///\n/// # Examples\n///\n/// Without `compiler_fence`, the `assert_eq!` in following code\n/// is *not* guaranteed to succeed, despite everything happening in a single thread.\n/// To see why, remember that the compiler is free to swap the stores to\n/// `IMPORTANT_VARIABLE` and `IS_READ` since they are both\n/// `Ordering::Relaxed`. If it does, and the signal handler is invoked right\n/// after `IS_READY` is updated, then the signal handler will see\n/// `IS_READY=1`, but `IMPORTANT_VARIABLE=0`.\n/// Using a `compiler_fence` remedies this situation.\n///\n/// ```\n/// use std::sync::atomic::{AtomicBool, AtomicUsize};\n/// use std::sync::atomic::Ordering;\n/// use std::sync::atomic::compiler_fence;\n///\n/// static IMPORTANT_VARIABLE: AtomicUsize = AtomicUsize::new(0);\n/// static IS_READY: AtomicBool = AtomicBool::new(false);\n///\n/// fn main() {\n///     IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n///     // prevent earlier writes from being moved beyond this point\n///     compiler_fence(Ordering::Release);\n///     IS_READY.store(true, Ordering::Relaxed);\n/// }\n///\n/// fn signal_handler() {\n///     if IS_READY.load(Ordering::Relaxed) {\n///         assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n///     }\n/// }\n/// ```\n///\n/// [memory barriers]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n#[inline]\n#[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\npub fn compiler_fence(order: Ordering) {\n    // SAFETY: using an atomic fence is safe.\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_singlethreadfence_acq(),\n            Release => intrinsics::atomic_singlethreadfence_rel(),\n            AcqRel => intrinsics::atomic_singlethreadfence_acqrel(),\n            SeqCst => intrinsics::atomic_singlethreadfence(),\n            Relaxed => panic!(\"there is no such thing as a relaxed compiler fence\"),\n        }\n    }\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\nimpl fmt::Debug for AtomicBool {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n    }\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\nimpl<T> fmt::Debug for AtomicPtr<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n    }\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"atomic_pointer\", since = \"1.24.0\")]\nimpl<T> fmt::Pointer for AtomicPtr<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Pointer::fmt(&self.load(Ordering::SeqCst), f)\n    }\n}\n\n/// Signals the processor that it is inside a busy-wait spin-loop (\"spin lock\").\n///\n/// This function is deprecated in favor of [`hint::spin_loop`].\n///\n/// [`hint::spin_loop`]: crate::hint::spin_loop\n#[inline]\n#[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n#[rustc_deprecated(since = \"1.51.0\", reason = \"use hint::spin_loop instead\")]\npub fn spin_loop_hint() {\n    spin_loop()\n}\n"],[2811,"//! Synchronization primitives\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\npub mod atomic;\n"],[2812,"//! Compiler intrinsics.\n//!\n//! The corresponding definitions are in `compiler/rustc_codegen_llvm/src/intrinsic.rs`.\n//! The corresponding const implementations are in `compiler/rustc_mir/src/interpret/intrinsics.rs`\n//!\n//! # Const intrinsics\n//!\n//! Note: any changes to the constness of intrinsics should be discussed with the language team.\n//! This includes changes in the stability of the constness.\n//!\n//! In order to make an intrinsic usable at compile-time, one needs to copy the implementation\n//! from <https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs> to\n//! `compiler/rustc_mir/src/interpret/intrinsics.rs` and add a\n//! `#[rustc_const_unstable(feature = \"foo\", issue = \"01234\")]` to the intrinsic.\n//!\n//! If an intrinsic is supposed to be used from a `const fn` with a `rustc_const_stable` attribute,\n//! the intrinsic's attribute must be `rustc_const_stable`, too. Such a change should not be done\n//! without T-lang consultation, because it bakes a feature into the language that cannot be\n//! replicated in user code without compiler support.\n//!\n//! # Volatiles\n//!\n//! The volatile intrinsics provide operations intended to act on I/O\n//! memory, which are guaranteed to not be reordered by the compiler\n//! across other volatile intrinsics. See the LLVM documentation on\n//! [[volatile]].\n//!\n//! [volatile]: https://llvm.org/docs/LangRef.html#volatile-memory-accesses\n//!\n//! # Atomics\n//!\n//! The atomic intrinsics provide common atomic operations on machine\n//! words, with multiple possible memory orderings. They obey the same\n//! semantics as C++11. See the LLVM documentation on [[atomics]].\n//!\n//! [atomics]: https://llvm.org/docs/Atomics.html\n//!\n//! A quick refresher on memory ordering:\n//!\n//! * Acquire - a barrier for acquiring a lock. Subsequent reads and writes\n//!   take place after the barrier.\n//! * Release - a barrier for releasing a lock. Preceding reads and writes\n//!   take place before the barrier.\n//! * Sequentially consistent - sequentially consistent operations are\n//!   guaranteed to happen in order. This is the standard mode for working\n//!   with atomic types and is equivalent to Java's `volatile`.\n\n#![unstable(\n    feature = \"core_intrinsics\",\n    reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n                      they should be used through stabilized interfaces \\\n                      in the rest of the standard library\",\n    issue = \"none\"\n)]\n#![allow(missing_docs)]\n\nuse crate::marker::DiscriminantKind;\nuse crate::mem;\n\n// These imports are used for simplifying intra-doc links\n#[allow(unused_imports)]\n#[cfg(all(target_has_atomic = \"8\", target_has_atomic = \"32\", target_has_atomic = \"ptr\"))]\nuse crate::sync::atomic::{self, AtomicBool, AtomicI32, AtomicIsize, AtomicU32, Ordering};\n\n#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n#[rustc_deprecated(\n    reason = \"no longer an intrinsic - use `ptr::drop_in_place` directly\",\n    since = \"1.52.0\"\n)]\n#[inline]\npub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n    // SAFETY: see `ptr::drop_in_place`\n    unsafe { crate::ptr::drop_in_place(to_drop) }\n}\n\nextern \"rust-intrinsic\" {\n    // N.B., these intrinsics take raw pointers because they mutate aliased\n    // memory, which is not valid for either `&` or `&mut`.\n\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange` method by passing\n    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n    /// For example, [`AtomicBool::compare_exchange`].\n    pub fn atomic_cxchg<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange` method by passing\n    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n    /// For example, [`AtomicBool::compare_exchange`].\n    pub fn atomic_cxchg_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange` method by passing\n    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n    pub fn atomic_cxchg_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange` method by passing\n    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n    pub fn atomic_cxchg_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange` method by passing\n    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n    /// For example, [`AtomicBool::compare_exchange`].\n    pub fn atomic_cxchg_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange` method by passing\n    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n    pub fn atomic_cxchg_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange` method by passing\n    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n    pub fn atomic_cxchg_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange` method by passing\n    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n    pub fn atomic_cxchg_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange` method by passing\n    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n    pub fn atomic_cxchg_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n    /// For example, [`AtomicBool::compare_exchange_weak`].\n    pub fn atomic_cxchgweak<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n    /// For example, [`AtomicBool::compare_exchange_weak`].\n    pub fn atomic_cxchgweak_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n    pub fn atomic_cxchgweak_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n    pub fn atomic_cxchgweak_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n    /// For example, [`AtomicBool::compare_exchange_weak`].\n    pub fn atomic_cxchgweak_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n    pub fn atomic_cxchgweak_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n    pub fn atomic_cxchgweak_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n    pub fn atomic_cxchgweak_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n    pub fn atomic_cxchgweak_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n\n    /// Loads the current value of the pointer.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `load` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::load`].\n    pub fn atomic_load<T: Copy>(src: *const T) -> T;\n    /// Loads the current value of the pointer.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `load` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::load`].\n    pub fn atomic_load_acq<T: Copy>(src: *const T) -> T;\n    /// Loads the current value of the pointer.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `load` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::load`].\n    pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n    pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n\n    /// Stores the value at the specified memory location.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `store` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::store`].\n    pub fn atomic_store<T: Copy>(dst: *mut T, val: T);\n    /// Stores the value at the specified memory location.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `store` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::store`].\n    pub fn atomic_store_rel<T: Copy>(dst: *mut T, val: T);\n    /// Stores the value at the specified memory location.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `store` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::store`].\n    pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n    pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n\n    /// Stores the value at the specified memory location, returning the old value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `swap` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::swap`].\n    pub fn atomic_xchg<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Stores the value at the specified memory location, returning the old value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `swap` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::swap`].\n    pub fn atomic_xchg_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Stores the value at the specified memory location, returning the old value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `swap` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::swap`].\n    pub fn atomic_xchg_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Stores the value at the specified memory location, returning the old value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `swap` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::swap`].\n    pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Stores the value at the specified memory location, returning the old value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `swap` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::swap`].\n    pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Adds to the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_add` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n    pub fn atomic_xadd<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Adds to the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_add` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n    pub fn atomic_xadd_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Adds to the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_add` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n    pub fn atomic_xadd_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Adds to the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_add` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n    pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Adds to the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_add` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n    pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Subtract from the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_sub` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n    pub fn atomic_xsub<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Subtract from the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_sub` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n    pub fn atomic_xsub_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Subtract from the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_sub` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n    pub fn atomic_xsub_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Subtract from the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_sub` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n    pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Subtract from the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_sub` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n    pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Bitwise and with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_and` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_and`].\n    pub fn atomic_and<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise and with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_and` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_and`].\n    pub fn atomic_and_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise and with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_and` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_and`].\n    pub fn atomic_and_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise and with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_and` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_and`].\n    pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise and with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_and` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_and`].\n    pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Bitwise nand with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n    pub fn atomic_nand<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise nand with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n    pub fn atomic_nand_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise nand with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n    pub fn atomic_nand_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise nand with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n    pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise nand with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n    pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Bitwise or with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_or` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_or`].\n    pub fn atomic_or<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise or with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_or` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_or`].\n    pub fn atomic_or_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise or with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_or` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_or`].\n    pub fn atomic_or_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise or with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_or` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_or`].\n    pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise or with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_or` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_or`].\n    pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Bitwise xor with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_xor` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n    pub fn atomic_xor<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise xor with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_xor` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n    pub fn atomic_xor_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise xor with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_xor` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n    pub fn atomic_xor_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise xor with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_xor` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n    pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Bitwise xor with the current value, returning the previous value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] types via the `fetch_xor` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n    pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Maximum with the current value using a signed comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_max`].\n    pub fn atomic_max<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Maximum with the current value using a signed comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_max`].\n    pub fn atomic_max_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Maximum with the current value using a signed comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_max`].\n    pub fn atomic_max_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Maximum with the current value using a signed comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_max`].\n    pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Maximum with the current value.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_max`].\n    pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Minimum with the current value using a signed comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_min`].\n    pub fn atomic_min<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Minimum with the current value using a signed comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_min`].\n    pub fn atomic_min_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Minimum with the current value using a signed comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_min`].\n    pub fn atomic_min_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Minimum with the current value using a signed comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_min`].\n    pub fn atomic_min_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Minimum with the current value using a signed comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_min`].\n    pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Minimum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_min`].\n    pub fn atomic_umin<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Minimum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_min`].\n    pub fn atomic_umin_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Minimum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_min`].\n    pub fn atomic_umin_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Minimum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_min`].\n    pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Minimum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_min`].\n    pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// Maximum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_max`].\n    pub fn atomic_umax<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Maximum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_max`].\n    pub fn atomic_umax_acq<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Maximum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n    /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_max`].\n    pub fn atomic_umax_rel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Maximum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_max`].\n    pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n    /// Maximum with the current value using an unsigned comparison.\n    ///\n    /// The stabilized version of this intrinsic is available on the\n    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_max`].\n    pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n\n    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n    /// if supported; otherwise, it is a no-op.\n    /// Prefetches have no effect on the behavior of the program but can change its performance\n    /// characteristics.\n    ///\n    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n    /// if supported; otherwise, it is a no-op.\n    /// Prefetches have no effect on the behavior of the program but can change its performance\n    /// characteristics.\n    ///\n    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n    /// if supported; otherwise, it is a no-op.\n    /// Prefetches have no effect on the behavior of the program but can change its performance\n    /// characteristics.\n    ///\n    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n    /// if supported; otherwise, it is a no-op.\n    /// Prefetches have no effect on the behavior of the program but can change its performance\n    /// characteristics.\n    ///\n    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n}\n\nextern \"rust-intrinsic\" {\n    /// An atomic fence.\n    ///\n    /// The stabilized version of this intrinsic is available in\n    /// [`atomic::fence`] by passing [`Ordering::SeqCst`]\n    /// as the `order`.\n    pub fn atomic_fence();\n    /// An atomic fence.\n    ///\n    /// The stabilized version of this intrinsic is available in\n    /// [`atomic::fence`] by passing [`Ordering::Acquire`]\n    /// as the `order`.\n    pub fn atomic_fence_acq();\n    /// An atomic fence.\n    ///\n    /// The stabilized version of this intrinsic is available in\n    /// [`atomic::fence`] by passing [`Ordering::Release`]\n    /// as the `order`.\n    pub fn atomic_fence_rel();\n    /// An atomic fence.\n    ///\n    /// The stabilized version of this intrinsic is available in\n    /// [`atomic::fence`] by passing [`Ordering::AcqRel`]\n    /// as the `order`.\n    pub fn atomic_fence_acqrel();\n\n    /// A compiler-only memory barrier.\n    ///\n    /// Memory accesses will never be reordered across this barrier by the\n    /// compiler, but no instructions will be emitted for it. This is\n    /// appropriate for operations on the same thread that may be preempted,\n    /// such as when interacting with signal handlers.\n    ///\n    /// The stabilized version of this intrinsic is available in\n    /// [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`]\n    /// as the `order`.\n    pub fn atomic_singlethreadfence();\n    /// A compiler-only memory barrier.\n    ///\n    /// Memory accesses will never be reordered across this barrier by the\n    /// compiler, but no instructions will be emitted for it. This is\n    /// appropriate for operations on the same thread that may be preempted,\n    /// such as when interacting with signal handlers.\n    ///\n    /// The stabilized version of this intrinsic is available in\n    /// [`atomic::compiler_fence`] by passing [`Ordering::Acquire`]\n    /// as the `order`.\n    pub fn atomic_singlethreadfence_acq();\n    /// A compiler-only memory barrier.\n    ///\n    /// Memory accesses will never be reordered across this barrier by the\n    /// compiler, but no instructions will be emitted for it. This is\n    /// appropriate for operations on the same thread that may be preempted,\n    /// such as when interacting with signal handlers.\n    ///\n    /// The stabilized version of this intrinsic is available in\n    /// [`atomic::compiler_fence`] by passing [`Ordering::Release`]\n    /// as the `order`.\n    pub fn atomic_singlethreadfence_rel();\n    /// A compiler-only memory barrier.\n    ///\n    /// Memory accesses will never be reordered across this barrier by the\n    /// compiler, but no instructions will be emitted for it. This is\n    /// appropriate for operations on the same thread that may be preempted,\n    /// such as when interacting with signal handlers.\n    ///\n    /// The stabilized version of this intrinsic is available in\n    /// [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`]\n    /// as the `order`.\n    pub fn atomic_singlethreadfence_acqrel();\n\n    /// Magic intrinsic that derives its meaning from attributes\n    /// attached to the function.\n    ///\n    /// For example, dataflow uses this to inject static assertions so\n    /// that `rustc_peek(potentially_uninitialized)` would actually\n    /// double-check that dataflow did indeed compute that it is\n    /// uninitialized at that point in the control flow.\n    ///\n    /// This intrinsic should not be used outside of the compiler.\n    pub fn rustc_peek<T>(_: T) -> T;\n\n    /// Aborts the execution of the process.\n    ///\n    /// A more user-friendly and stable version of this operation is\n    /// [`std::process::abort`](../../std/process/fn.abort.html).\n    pub fn abort() -> !;\n\n    /// Informs the optimizer that this point in the code is not reachable,\n    /// enabling further optimizations.\n    ///\n    /// N.B., this is very different from the `unreachable!()` macro: Unlike the\n    /// macro, which panics when it is executed, it is *undefined behavior* to\n    /// reach code marked with this function.\n    ///\n    /// The stabilized version of this intrinsic is [`core::hint::unreachable_unchecked`].\n    #[rustc_const_unstable(feature = \"const_unreachable_unchecked\", issue = \"53188\")]\n    pub fn unreachable() -> !;\n\n    /// Informs the optimizer that a condition is always true.\n    /// If the condition is false, the behavior is undefined.\n    ///\n    /// No code is generated for this intrinsic, but the optimizer will try\n    /// to preserve it (and its condition) between passes, which may interfere\n    /// with optimization of surrounding code and reduce performance. It should\n    /// not be used if the invariant can be discovered by the optimizer on its\n    /// own, or if it does not enable any significant optimizations.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    #[rustc_const_unstable(feature = \"const_assume\", issue = \"76972\")]\n    pub fn assume(b: bool);\n\n    /// Hints to the compiler that branch condition is likely to be true.\n    /// Returns the value passed to it.\n    ///\n    /// Any use other than with `if` statements will probably not have an effect.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n    pub fn likely(b: bool) -> bool;\n\n    /// Hints to the compiler that branch condition is likely to be false.\n    /// Returns the value passed to it.\n    ///\n    /// Any use other than with `if` statements will probably not have an effect.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n    pub fn unlikely(b: bool) -> bool;\n\n    /// Executes a breakpoint trap, for inspection by a debugger.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn breakpoint();\n\n    /// The size of a type in bytes.\n    ///\n    /// More specifically, this is the offset in bytes between successive\n    /// items of the same type, including alignment padding.\n    ///\n    /// The stabilized version of this intrinsic is [`core::mem::size_of`].\n    #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n    pub fn size_of<T>() -> usize;\n\n    /// The minimum alignment of a type.\n    ///\n    /// The stabilized version of this intrinsic is [`core::mem::align_of`].\n    #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n    pub fn min_align_of<T>() -> usize;\n    /// The preferred alignment of a type.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"none\")]\n    pub fn pref_align_of<T>() -> usize;\n\n    /// The size of the referenced value in bytes.\n    ///\n    /// The stabilized version of this intrinsic is [`mem::size_of_val`].\n    #[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\n    pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n    /// The required alignment of the referenced value.\n    ///\n    /// The stabilized version of this intrinsic is [`core::mem::align_of_val`].\n    #[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n    pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n\n    /// Gets a static string slice containing the name of a type.\n    ///\n    /// The stabilized version of this intrinsic is [`core::any::type_name`].\n    #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n    pub fn type_name<T: ?Sized>() -> &'static str;\n\n    /// Gets an identifier which is globally unique to the specified type. This\n    /// function will return the same value for a type regardless of whichever\n    /// crate it is invoked in.\n    ///\n    /// The stabilized version of this intrinsic is [`core::any::TypeId::of`].\n    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n    pub fn type_id<T: ?Sized + 'static>() -> u64;\n\n    /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n    /// This will statically either panic, or do nothing.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    #[rustc_const_unstable(feature = \"const_assert_type\", issue = \"none\")]\n    pub fn assert_inhabited<T>();\n\n    /// A guard for unsafe functions that cannot ever be executed if `T` does not permit\n    /// zero-initialization: This will statically either panic, or do nothing.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn assert_zero_valid<T>();\n\n    /// A guard for unsafe functions that cannot ever be executed if `T` has invalid\n    /// bit patterns: This will statically either panic, or do nothing.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn assert_uninit_valid<T>();\n\n    /// Gets a reference to a static `Location` indicating where it was called.\n    ///\n    /// Consider using [`core::panic::Location::caller`] instead.\n    #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n    pub fn caller_location() -> &'static crate::panic::Location<'static>;\n\n    /// Moves a value out of scope without running drop glue.\n    ///\n    /// This exists solely for [`mem::forget_unsized`]; normal `forget` uses\n    /// `ManuallyDrop` instead.\n    #[rustc_const_unstable(feature = \"const_intrinsic_forget\", issue = \"none\")]\n    pub fn forget<T: ?Sized>(_: T);\n\n    /// Reinterprets the bits of a value of one type as another type.\n    ///\n    /// Both types must have the same size. Neither the original, nor the result,\n    /// may be an [invalid value](../../nomicon/what-unsafe-does.html).\n    ///\n    /// `transmute` is semantically equivalent to a bitwise move of one type\n    /// into another. It copies the bits from the source value into the\n    /// destination value, then forgets the original. It's equivalent to C's\n    /// `memcpy` under the hood, just like `transmute_copy`.\n    ///\n    /// Because `transmute` is a by-value operation, alignment of the *transmuted values\n    /// themselves* is not a concern. As with any other function, the compiler already ensures\n    /// both `T` and `U` are properly aligned. However, when transmuting values that *point\n    /// elsewhere* (such as pointers, references, boxes…), the caller has to ensure proper\n    /// alignment of the pointed-to values.\n    ///\n    /// `transmute` is **incredibly** unsafe. There are a vast number of ways to\n    /// cause [undefined behavior][ub] with this function. `transmute` should be\n    /// the absolute last resort.\n    ///\n    /// The [nomicon](../../nomicon/transmutes.html) has additional\n    /// documentation.\n    ///\n    /// [ub]: ../../reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// There are a few things that `transmute` is really useful for.\n    ///\n    /// Turning a pointer into a function pointer. This is *not* portable to\n    /// machines where function pointers and data pointers have different sizes.\n    ///\n    /// ```\n    /// fn foo() -> i32 {\n    ///     0\n    /// }\n    /// let pointer = foo as *const ();\n    /// let function = unsafe {\n    ///     std::mem::transmute::<*const (), fn() -> i32>(pointer)\n    /// };\n    /// assert_eq!(function(), 0);\n    /// ```\n    ///\n    /// Extending a lifetime, or shortening an invariant lifetime. This is\n    /// advanced, very unsafe Rust!\n    ///\n    /// ```\n    /// struct R<'a>(&'a i32);\n    /// unsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {\n    ///     std::mem::transmute::<R<'b>, R<'static>>(r)\n    /// }\n    ///\n    /// unsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>)\n    ///                                              -> &'b mut R<'c> {\n    ///     std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)\n    /// }\n    /// ```\n    ///\n    /// # Alternatives\n    ///\n    /// Don't despair: many uses of `transmute` can be achieved through other means.\n    /// Below are common applications of `transmute` which can be replaced with safer\n    /// constructs.\n    ///\n    /// Turning raw bytes(`&[u8]`) to `u32`, `f64`, etc.:\n    ///\n    /// ```\n    /// let raw_bytes = [0x78, 0x56, 0x34, 0x12];\n    ///\n    /// let num = unsafe {\n    ///     std::mem::transmute::<[u8; 4], u32>(raw_bytes)\n    /// };\n    ///\n    /// // use `u32::from_ne_bytes` instead\n    /// let num = u32::from_ne_bytes(raw_bytes);\n    /// // or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness\n    /// let num = u32::from_le_bytes(raw_bytes);\n    /// assert_eq!(num, 0x12345678);\n    /// let num = u32::from_be_bytes(raw_bytes);\n    /// assert_eq!(num, 0x78563412);\n    /// ```\n    ///\n    /// Turning a pointer into a `usize`:\n    ///\n    /// ```\n    /// let ptr = &0;\n    /// let ptr_num_transmute = unsafe {\n    ///     std::mem::transmute::<&i32, usize>(ptr)\n    /// };\n    ///\n    /// // Use an `as` cast instead\n    /// let ptr_num_cast = ptr as *const i32 as usize;\n    /// ```\n    ///\n    /// Turning a `*mut T` into an `&mut T`:\n    ///\n    /// ```\n    /// let ptr: *mut i32 = &mut 0;\n    /// let ref_transmuted = unsafe {\n    ///     std::mem::transmute::<*mut i32, &mut i32>(ptr)\n    /// };\n    ///\n    /// // Use a reborrow instead\n    /// let ref_casted = unsafe { &mut *ptr };\n    /// ```\n    ///\n    /// Turning an `&mut T` into an `&mut U`:\n    ///\n    /// ```\n    /// let ptr = &mut 0;\n    /// let val_transmuted = unsafe {\n    ///     std::mem::transmute::<&mut i32, &mut u32>(ptr)\n    /// };\n    ///\n    /// // Now, put together `as` and reborrowing - note the chaining of `as`\n    /// // `as` is not transitive\n    /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n    /// ```\n    ///\n    /// Turning an `&str` into an `&[u8]`:\n    ///\n    /// ```\n    /// // this is not a good way to do this.\n    /// let slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\n    /// assert_eq!(slice, &[82, 117, 115, 116]);\n    ///\n    /// // You could use `str::as_bytes`\n    /// let slice = \"Rust\".as_bytes();\n    /// assert_eq!(slice, &[82, 117, 115, 116]);\n    ///\n    /// // Or, just use a byte string, if you have control over the string\n    /// // literal\n    /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n    /// ```\n    ///\n    /// Turning a `Vec<&T>` into a `Vec<Option<&T>>`.\n    ///\n    /// To transmute the inner type of the contents of a container, you must make sure to not\n    /// violate any of the container's invariants. For `Vec`, this means that both the size\n    /// *and alignment* of the inner types have to match. Other containers might rely on the\n    /// size of the type, alignment, or even the `TypeId`, in which case transmuting wouldn't\n    /// be possible at all without violating the container invariants.\n    ///\n    /// ```\n    /// let store = [0, 1, 2, 3];\n    /// let v_orig = store.iter().collect::<Vec<&i32>>();\n    ///\n    /// // clone the vector as we will reuse them later\n    /// let v_clone = v_orig.clone();\n    ///\n    /// // Using transmute: this relies on the unspecified data layout of `Vec`, which is a\n    /// // bad idea and could cause Undefined Behavior.\n    /// // However, it is no-copy.\n    /// let v_transmuted = unsafe {\n    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(v_clone)\n    /// };\n    ///\n    /// let v_clone = v_orig.clone();\n    ///\n    /// // This is the suggested, safe way.\n    /// // It does copy the entire vector, though, into a new array.\n    /// let v_collected = v_clone.into_iter()\n    ///                          .map(Some)\n    ///                          .collect::<Vec<Option<&i32>>>();\n    ///\n    /// let v_clone = v_orig.clone();\n    ///\n    /// // This is the proper no-copy, unsafe way of \"transmuting\" a `Vec`, without relying on the\n    /// // data layout. Instead of literally calling `transmute`, we perform a pointer cast, but\n    /// // in terms of converting the original inner type (`&i32`) to the new one (`Option<&i32>`),\n    /// // this has all the same caveats. Besides the information provided above, also consult the\n    /// // [`from_raw_parts`] documentation.\n    /// let v_from_raw = unsafe {\n    // FIXME Update this when vec_into_raw_parts is stabilized\n    ///     // Ensure the original vector is not dropped.\n    ///     let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\n    ///     Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,\n    ///                         v_clone.len(),\n    ///                         v_clone.capacity())\n    /// };\n    /// ```\n    ///\n    /// [`from_raw_parts`]: ../../std/vec/struct.Vec.html#method.from_raw_parts\n    ///\n    /// Implementing `split_at_mut`:\n    ///\n    /// ```\n    /// use std::{slice, mem};\n    ///\n    /// // There are multiple ways to do this, and there are multiple problems\n    /// // with the following (transmute) way.\n    /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n    ///                              -> (&mut [T], &mut [T]) {\n    ///     let len = slice.len();\n    ///     assert!(mid <= len);\n    ///     unsafe {\n    ///         let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\n    ///         // first: transmute is not type safe; all it checks is that T and\n    ///         // U are of the same size. Second, right here, you have two\n    ///         // mutable references pointing to the same memory.\n    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n    ///     }\n    /// }\n    ///\n    /// // This gets rid of the type safety problems; `&mut *` will *only* give\n    /// // you an `&mut T` from an `&mut T` or `*mut T`.\n    /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n    ///                          -> (&mut [T], &mut [T]) {\n    ///     let len = slice.len();\n    ///     assert!(mid <= len);\n    ///     unsafe {\n    ///         let slice2 = &mut *(slice as *mut [T]);\n    ///         // however, you still have two mutable references pointing to\n    ///         // the same memory.\n    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n    ///     }\n    /// }\n    ///\n    /// // This is how the standard library does it. This is the best method, if\n    /// // you need to do something like this\n    /// fn split_at_stdlib<T>(slice: &mut [T], mid: usize)\n    ///                       -> (&mut [T], &mut [T]) {\n    ///     let len = slice.len();\n    ///     assert!(mid <= len);\n    ///     unsafe {\n    ///         let ptr = slice.as_mut_ptr();\n    ///         // This now has three mutable references pointing at the same\n    ///         // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.\n    ///         // `slice` is never used after `let ptr = ...`, and so one can\n    ///         // treat it as \"dead\", and therefore, you only have two real\n    ///         // mutable slices.\n    ///         (slice::from_raw_parts_mut(ptr, mid),\n    ///          slice::from_raw_parts_mut(ptr.add(mid), len - mid))\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    // NOTE: While this makes the intrinsic const stable, we have some custom code in const fn\n    // checks that prevent its use within `const fn`.\n    #[rustc_const_stable(feature = \"const_transmute\", since = \"1.46.0\")]\n    #[rustc_diagnostic_item = \"transmute\"]\n    pub fn transmute<T, U>(e: T) -> U;\n\n    /// Returns `true` if the actual type given as `T` requires drop\n    /// glue; returns `false` if the actual type provided for `T`\n    /// implements `Copy`.\n    ///\n    /// If the actual type neither requires drop glue nor implements\n    /// `Copy`, then the return value of this function is unspecified.\n    ///\n    /// The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).\n    #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n    pub fn needs_drop<T>() -> bool;\n\n    /// Calculates the offset from a pointer.\n    ///\n    /// This is implemented as an intrinsic to avoid converting to and from an\n    /// integer, since the conversion would throw away aliasing information.\n    ///\n    /// # Safety\n    ///\n    /// Both the starting and resulting pointer must be either in bounds or one\n    /// byte past the end of an allocated object. If either pointer is out of\n    /// bounds or arithmetic overflow occurs then any further use of the\n    /// returned value will result in undefined behavior.\n    ///\n    /// The stabilized version of this intrinsic is [`pointer::offset`].\n    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n\n    /// Calculates the offset from a pointer, potentially wrapping.\n    ///\n    /// This is implemented as an intrinsic to avoid converting to and from an\n    /// integer, since the conversion inhibits certain optimizations.\n    ///\n    /// # Safety\n    ///\n    /// Unlike the `offset` intrinsic, this intrinsic does not restrict the\n    /// resulting pointer to point into or one byte past the end of an allocated\n    /// object, and it wraps with two's complement arithmetic. The resulting\n    /// value is not necessarily valid to be used to actually access memory.\n    ///\n    /// The stabilized version of this intrinsic is [`pointer::wrapping_offset`].\n    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n    pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n\n    /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n    /// a size of `count` * `size_of::<T>()` and an alignment of\n    /// `min_align_of::<T>()`\n    ///\n    /// The volatile parameter is set to `true`, so it will not be optimized out\n    /// unless size is equal to zero.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n    /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n    /// a size of `count * size_of::<T>()` and an alignment of\n    /// `min_align_of::<T>()`\n    ///\n    /// The volatile parameter is set to `true`, so it will not be optimized out\n    /// unless size is equal to zero.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n    /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n    /// size of `count * size_of::<T>()` and an alignment of\n    /// `min_align_of::<T>()`.\n    ///\n    /// The volatile parameter is set to `true`, so it will not be optimized out\n    /// unless size is equal to zero.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n\n    /// Performs a volatile load from the `src` pointer.\n    ///\n    /// The stabilized version of this intrinsic is [`core::ptr::read_volatile`].\n    pub fn volatile_load<T>(src: *const T) -> T;\n    /// Performs a volatile store to the `dst` pointer.\n    ///\n    /// The stabilized version of this intrinsic is [`core::ptr::write_volatile`].\n    pub fn volatile_store<T>(dst: *mut T, val: T);\n\n    /// Performs a volatile load from the `src` pointer\n    /// The pointer is not required to be aligned.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n    /// Performs a volatile store to the `dst` pointer.\n    /// The pointer is not required to be aligned.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n\n    /// Returns the square root of an `f32`\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::sqrt`](../../std/primitive.f32.html#method.sqrt)\n    pub fn sqrtf32(x: f32) -> f32;\n    /// Returns the square root of an `f64`\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::sqrt`](../../std/primitive.f64.html#method.sqrt)\n    pub fn sqrtf64(x: f64) -> f64;\n\n    /// Raises an `f32` to an integer power.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::powi`](../../std/primitive.f32.html#method.powi)\n    pub fn powif32(a: f32, x: i32) -> f32;\n    /// Raises an `f64` to an integer power.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::powi`](../../std/primitive.f64.html#method.powi)\n    pub fn powif64(a: f64, x: i32) -> f64;\n\n    /// Returns the sine of an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::sin`](../../std/primitive.f32.html#method.sin)\n    pub fn sinf32(x: f32) -> f32;\n    /// Returns the sine of an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::sin`](../../std/primitive.f64.html#method.sin)\n    pub fn sinf64(x: f64) -> f64;\n\n    /// Returns the cosine of an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::cos`](../../std/primitive.f32.html#method.cos)\n    pub fn cosf32(x: f32) -> f32;\n    /// Returns the cosine of an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::cos`](../../std/primitive.f64.html#method.cos)\n    pub fn cosf64(x: f64) -> f64;\n\n    /// Raises an `f32` to an `f32` power.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::powf`](../../std/primitive.f32.html#method.powf)\n    pub fn powf32(a: f32, x: f32) -> f32;\n    /// Raises an `f64` to an `f64` power.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::powf`](../../std/primitive.f64.html#method.powf)\n    pub fn powf64(a: f64, x: f64) -> f64;\n\n    /// Returns the exponential of an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::exp`](../../std/primitive.f32.html#method.exp)\n    pub fn expf32(x: f32) -> f32;\n    /// Returns the exponential of an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::exp`](../../std/primitive.f64.html#method.exp)\n    pub fn expf64(x: f64) -> f64;\n\n    /// Returns 2 raised to the power of an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::exp2`](../../std/primitive.f32.html#method.exp2)\n    pub fn exp2f32(x: f32) -> f32;\n    /// Returns 2 raised to the power of an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::exp2`](../../std/primitive.f64.html#method.exp2)\n    pub fn exp2f64(x: f64) -> f64;\n\n    /// Returns the natural logarithm of an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::ln`](../../std/primitive.f32.html#method.ln)\n    pub fn logf32(x: f32) -> f32;\n    /// Returns the natural logarithm of an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::ln`](../../std/primitive.f64.html#method.ln)\n    pub fn logf64(x: f64) -> f64;\n\n    /// Returns the base 10 logarithm of an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::log10`](../../std/primitive.f32.html#method.log10)\n    pub fn log10f32(x: f32) -> f32;\n    /// Returns the base 10 logarithm of an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::log10`](../../std/primitive.f64.html#method.log10)\n    pub fn log10f64(x: f64) -> f64;\n\n    /// Returns the base 2 logarithm of an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::log2`](../../std/primitive.f32.html#method.log2)\n    pub fn log2f32(x: f32) -> f32;\n    /// Returns the base 2 logarithm of an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::log2`](../../std/primitive.f64.html#method.log2)\n    pub fn log2f64(x: f64) -> f64;\n\n    /// Returns `a * b + c` for `f32` values.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::mul_add`](../../std/primitive.f32.html#method.mul_add)\n    pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n    /// Returns `a * b + c` for `f64` values.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::mul_add`](../../std/primitive.f64.html#method.mul_add)\n    pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;\n\n    /// Returns the absolute value of an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::abs`](../../std/primitive.f32.html#method.abs)\n    pub fn fabsf32(x: f32) -> f32;\n    /// Returns the absolute value of an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::abs`](../../std/primitive.f64.html#method.abs)\n    pub fn fabsf64(x: f64) -> f64;\n\n    /// Returns the minimum of two `f32` values.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::min`]\n    pub fn minnumf32(x: f32, y: f32) -> f32;\n    /// Returns the minimum of two `f64` values.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::min`]\n    pub fn minnumf64(x: f64, y: f64) -> f64;\n    /// Returns the maximum of two `f32` values.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::max`]\n    pub fn maxnumf32(x: f32, y: f32) -> f32;\n    /// Returns the maximum of two `f64` values.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::max`]\n    pub fn maxnumf64(x: f64, y: f64) -> f64;\n\n    /// Copies the sign from `y` to `x` for `f32` values.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::copysign`](../../std/primitive.f32.html#method.copysign)\n    pub fn copysignf32(x: f32, y: f32) -> f32;\n    /// Copies the sign from `y` to `x` for `f64` values.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::copysign`](../../std/primitive.f64.html#method.copysign)\n    pub fn copysignf64(x: f64, y: f64) -> f64;\n\n    /// Returns the largest integer less than or equal to an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::floor`](../../std/primitive.f32.html#method.floor)\n    pub fn floorf32(x: f32) -> f32;\n    /// Returns the largest integer less than or equal to an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::floor`](../../std/primitive.f64.html#method.floor)\n    pub fn floorf64(x: f64) -> f64;\n\n    /// Returns the smallest integer greater than or equal to an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::ceil`](../../std/primitive.f32.html#method.ceil)\n    pub fn ceilf32(x: f32) -> f32;\n    /// Returns the smallest integer greater than or equal to an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::ceil`](../../std/primitive.f64.html#method.ceil)\n    pub fn ceilf64(x: f64) -> f64;\n\n    /// Returns the integer part of an `f32`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::trunc`](../../std/primitive.f32.html#method.trunc)\n    pub fn truncf32(x: f32) -> f32;\n    /// Returns the integer part of an `f64`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::trunc`](../../std/primitive.f64.html#method.trunc)\n    pub fn truncf64(x: f64) -> f64;\n\n    /// Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n    /// if the argument is not an integer.\n    pub fn rintf32(x: f32) -> f32;\n    /// Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\n    /// if the argument is not an integer.\n    pub fn rintf64(x: f64) -> f64;\n\n    /// Returns the nearest integer to an `f32`.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn nearbyintf32(x: f32) -> f32;\n    /// Returns the nearest integer to an `f64`.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn nearbyintf64(x: f64) -> f64;\n\n    /// Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f32::round`](../../std/primitive.f32.html#method.round)\n    pub fn roundf32(x: f32) -> f32;\n    /// Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`f64::round`](../../std/primitive.f64.html#method.round)\n    pub fn roundf64(x: f64) -> f64;\n\n    /// Float addition that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn fadd_fast<T: Copy>(a: T, b: T) -> T;\n\n    /// Float subtraction that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn fsub_fast<T: Copy>(a: T, b: T) -> T;\n\n    /// Float multiplication that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn fmul_fast<T: Copy>(a: T, b: T) -> T;\n\n    /// Float division that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn fdiv_fast<T: Copy>(a: T, b: T) -> T;\n\n    /// Float remainder that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn frem_fast<T: Copy>(a: T, b: T) -> T;\n\n    /// Convert with LLVM’s fptoui/fptosi, which may return undef for values out of range\n    /// (<https://github.com/rust-lang/rust/issues/10184>)\n    ///\n    /// Stabilized as [`f32::to_int_unchecked`] and [`f64::to_int_unchecked`].\n    pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n\n    /// Returns the number of bits set in an integer type `T`\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `count_ones` method. For example,\n    /// [`u32::count_ones`]\n    #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n    pub fn ctpop<T: Copy>(x: T) -> T;\n\n    /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `leading_zeros` method. For example,\n    /// [`u32::leading_zeros`]\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::ctlz;\n    ///\n    /// let x = 0b0001_1100_u8;\n    /// let num_leading = ctlz(x);\n    /// assert_eq!(num_leading, 3);\n    /// ```\n    ///\n    /// An `x` with value `0` will return the bit width of `T`.\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::ctlz;\n    ///\n    /// let x = 0u16;\n    /// let num_leading = ctlz(x);\n    /// assert_eq!(num_leading, 16);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n    pub fn ctlz<T: Copy>(x: T) -> T;\n\n    /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n    /// given an `x` with value `0`.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::ctlz_nonzero;\n    ///\n    /// let x = 0b0001_1100_u8;\n    /// let num_leading = unsafe { ctlz_nonzero(x) };\n    /// assert_eq!(num_leading, 3);\n    /// ```\n    #[rustc_const_stable(feature = \"constctlz\", since = \"1.50.0\")]\n    pub fn ctlz_nonzero<T: Copy>(x: T) -> T;\n\n    /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `trailing_zeros` method. For example,\n    /// [`u32::trailing_zeros`]\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::cttz;\n    ///\n    /// let x = 0b0011_1000_u8;\n    /// let num_trailing = cttz(x);\n    /// assert_eq!(num_trailing, 3);\n    /// ```\n    ///\n    /// An `x` with value `0` will return the bit width of `T`:\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::cttz;\n    ///\n    /// let x = 0u16;\n    /// let num_trailing = cttz(x);\n    /// assert_eq!(num_trailing, 16);\n    /// ```\n    #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n    pub fn cttz<T: Copy>(x: T) -> T;\n\n    /// Like `cttz`, but extra-unsafe as it returns `undef` when\n    /// given an `x` with value `0`.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::cttz_nonzero;\n    ///\n    /// let x = 0b0011_1000_u8;\n    /// let num_trailing = unsafe { cttz_nonzero(x) };\n    /// assert_eq!(num_trailing, 3);\n    /// ```\n    #[rustc_const_stable(feature = \"const_cttz\", since = \"1.53.0\")]\n    pub fn cttz_nonzero<T: Copy>(x: T) -> T;\n\n    /// Reverses the bytes in an integer type `T`.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `swap_bytes` method. For example,\n    /// [`u32::swap_bytes`]\n    #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n    pub fn bswap<T: Copy>(x: T) -> T;\n\n    /// Reverses the bits in an integer type `T`.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `reverse_bits` method. For example,\n    /// [`u32::reverse_bits`]\n    #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n    pub fn bitreverse<T: Copy>(x: T) -> T;\n\n    /// Performs checked integer addition.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `overflowing_add` method. For example,\n    /// [`u32::overflowing_add`]\n    #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n    pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n\n    /// Performs checked integer subtraction\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `overflowing_sub` method. For example,\n    /// [`u32::overflowing_sub`]\n    #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n    pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n\n    /// Performs checked integer multiplication\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `overflowing_mul` method. For example,\n    /// [`u32::overflowing_mul`]\n    #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n    pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n\n    /// Performs an exact division, resulting in undefined behavior where\n    /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n\n    /// Performs an unchecked division, resulting in undefined behavior\n    /// where `y == 0` or `x == T::MIN && y == -1`\n    ///\n    /// Safe wrappers for this intrinsic are available on the integer\n    /// primitives via the `checked_div` method. For example,\n    /// [`u32::checked_div`]\n    #[rustc_const_stable(feature = \"const_int_unchecked_arith\", since = \"1.52.0\")]\n    pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n    /// Returns the remainder of an unchecked division, resulting in\n    /// undefined behavior when `y == 0` or `x == T::MIN && y == -1`\n    ///\n    /// Safe wrappers for this intrinsic are available on the integer\n    /// primitives via the `checked_rem` method. For example,\n    /// [`u32::checked_rem`]\n    #[rustc_const_stable(feature = \"const_int_unchecked_arith\", since = \"1.52.0\")]\n    pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n\n    /// Performs an unchecked left shift, resulting in undefined behavior when\n    /// `y < 0` or `y >= N`, where N is the width of T in bits.\n    ///\n    /// Safe wrappers for this intrinsic are available on the integer\n    /// primitives via the `checked_shl` method. For example,\n    /// [`u32::checked_shl`]\n    #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n    pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n    /// Performs an unchecked right shift, resulting in undefined behavior when\n    /// `y < 0` or `y >= N`, where N is the width of T in bits.\n    ///\n    /// Safe wrappers for this intrinsic are available on the integer\n    /// primitives via the `checked_shr` method. For example,\n    /// [`u32::checked_shr`]\n    #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n    pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n\n    /// Returns the result of an unchecked addition, resulting in\n    /// undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n    pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n\n    /// Returns the result of an unchecked subtraction, resulting in\n    /// undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n    pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n\n    /// Returns the result of an unchecked multiplication, resulting in\n    /// undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.\n    ///\n    /// This intrinsic does not have a stable counterpart.\n    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n    pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n\n    /// Performs rotate left.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `rotate_left` method. For example,\n    /// [`u32::rotate_left`]\n    #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n    pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n\n    /// Performs rotate right.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `rotate_right` method. For example,\n    /// [`u32::rotate_right`]\n    #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n    pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n\n    /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `wrapping_add` method. For example,\n    /// [`u32::wrapping_add`]\n    #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n    pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n    /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `wrapping_sub` method. For example,\n    /// [`u32::wrapping_sub`]\n    #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n    pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n    /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `wrapping_mul` method. For example,\n    /// [`u32::wrapping_mul`]\n    #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n    pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n\n    /// Computes `a + b`, saturating at numeric bounds.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `saturating_add` method. For example,\n    /// [`u32::saturating_add`]\n    #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n    pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n    /// Computes `a - b`, saturating at numeric bounds.\n    ///\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `saturating_sub` method. For example,\n    /// [`u32::saturating_sub`]\n    #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n    pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n\n    /// Returns the value of the discriminant for the variant in 'v';\n    /// if `T` has no discriminant, returns `0`.\n    ///\n    /// The stabilized version of this intrinsic is [`core::mem::discriminant`].\n    #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n    pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n\n    /// Returns the number of variants of the type `T` cast to a `usize`;\n    /// if `T` has no variants, returns `0`. Uninhabited variants will be counted.\n    ///\n    /// The to-be-stabilized version of this intrinsic is [`mem::variant_count`].\n    #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n    pub fn variant_count<T>() -> usize;\n\n    /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n    /// with the data pointer `data`.\n    ///\n    /// The third argument is a function called if a panic occurs. This function\n    /// takes the data pointer and a pointer to the target-specific exception\n    /// object that was caught. For more information see the compiler's\n    /// source as well as std's catch implementation.\n    pub fn r#try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32;\n\n    /// Emits a `!nontemporal` store according to LLVM (see their docs).\n    /// Probably will never become stable.\n    pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n\n    /// See documentation of `<*const T>::offset_from` for details.\n    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n    pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n\n    /// See documentation of `<*const T>::guaranteed_eq` for details.\n    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n    pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool;\n\n    /// See documentation of `<*const T>::guaranteed_ne` for details.\n    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n    pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n\n    /// Allocate at compile time. Should not be called at runtime.\n    #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n    pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n}\n\n// Some functions are defined here because they accidentally got made\n// available in this module on stable. See <https://github.com/rust-lang/rust/issues/15702>.\n// (`transmute` also falls into this category, but it cannot be wrapped due to the\n// check that `T` and `U` have the same size.)\n\n/// Checks whether `ptr` is properly aligned with respect to\n/// `align_of::<T>()`.\npub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n    !ptr.is_null() && ptr as usize % mem::align_of::<T>() == 0\n}\n\n/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n/// and destination must *not* overlap.\n///\n/// For regions of memory which might overlap, use [`copy`] instead.\n///\n/// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n/// with the argument order swapped.\n///\n/// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n///\n/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n///\n/// * Both `src` and `dst` must be properly aligned.\n///\n/// * The region of memory beginning at `src` with a size of `count *\n///   size_of::<T>()` bytes must *not* overlap with the region of memory\n///   beginning at `dst` with the same size.\n///\n/// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n/// in the region beginning at `*src` and the region beginning at `*dst` can\n/// [violate memory safety][read-ownership].\n///\n/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n/// `0`, the pointers must be non-null and properly aligned.\n///\n/// [`read`]: crate::ptr::read\n/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n/// [valid]: crate::ptr#safety\n///\n/// # Examples\n///\n/// Manually implement [`Vec::append`]:\n///\n/// ```\n/// use std::ptr;\n///\n/// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n/// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n///     let src_len = src.len();\n///     let dst_len = dst.len();\n///\n///     // Ensure that `dst` has enough capacity to hold all of `src`.\n///     dst.reserve(src_len);\n///\n///     unsafe {\n///         // The call to offset is always safe because `Vec` will never\n///         // allocate more than `isize::MAX` bytes.\n///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n///         let src_ptr = src.as_ptr();\n///\n///         // Truncate `src` without dropping its contents. We do this first,\n///         // to avoid problems in case something further down panics.\n///         src.set_len(0);\n///\n///         // The two regions cannot overlap because mutable references do\n///         // not alias, and two different vectors cannot own the same\n///         // memory.\n///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n///\n///         // Notify `dst` that it now holds the contents of `src`.\n///         dst.set_len(dst_len + src_len);\n///     }\n/// }\n///\n/// let mut a = vec!['r'];\n/// let mut b = vec!['u', 's', 't'];\n///\n/// append(&mut a, &mut b);\n///\n/// assert_eq!(a, &['r', 'u', 's', 't']);\n/// assert!(b.is_empty());\n/// ```\n///\n/// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n#[doc(alias = \"memcpy\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n#[inline]\npub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n    extern \"rust-intrinsic\" {\n        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n        pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n    }\n\n    // FIXME: Perform these checks only at run time\n    /*if cfg!(debug_assertions)\n        && !(is_aligned_and_not_null(src)\n            && is_aligned_and_not_null(dst)\n            && is_nonoverlapping(src, dst, count))\n    {\n        // Not panicking to keep codegen impact smaller.\n        abort();\n    }*/\n\n    // SAFETY: the safety contract for `copy_nonoverlapping` must be\n    // upheld by the caller.\n    unsafe { copy_nonoverlapping(src, dst, count) }\n}\n\n/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n/// and destination may overlap.\n///\n/// If the source and destination will *never* overlap,\n/// [`copy_nonoverlapping`] can be used instead.\n///\n/// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n/// order swapped. Copying takes place as if the bytes were copied from `src`\n/// to a temporary array and then copied from the array to `dst`.\n///\n/// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n///\n/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n///\n/// * Both `src` and `dst` must be properly aligned.\n///\n/// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n/// in the region beginning at `*src` and the region beginning at `*dst` can\n/// [violate memory safety][read-ownership].\n///\n/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n/// `0`, the pointers must be non-null and properly aligned.\n///\n/// [`read`]: crate::ptr::read\n/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n/// [valid]: crate::ptr#safety\n///\n/// # Examples\n///\n/// Efficiently create a Rust vector from an unsafe buffer:\n///\n/// ```\n/// use std::ptr;\n///\n/// /// # Safety\n/// ///\n/// /// * `ptr` must be correctly aligned for its type and non-zero.\n/// /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n/// /// * Those elements must not be used after calling this function unless `T: Copy`.\n/// # #[allow(dead_code)]\n/// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n///     let mut dst = Vec::with_capacity(elts);\n///\n///     // SAFETY: Our precondition ensures the source is aligned and valid,\n///     // and `Vec::with_capacity` ensures that we have usable space to write them.\n///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n///\n///     // SAFETY: We created it with this much capacity earlier,\n///     // and the previous `copy` has initialized these elements.\n///     dst.set_len(elts);\n///     dst\n/// }\n/// ```\n#[doc(alias = \"memmove\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n#[inline]\npub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n    extern \"rust-intrinsic\" {\n        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n        fn copy<T>(src: *const T, dst: *mut T, count: usize);\n    }\n\n    // FIXME: Perform these checks only at run time\n    /*if cfg!(debug_assertions) && !(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)) {\n        // Not panicking to keep codegen impact smaller.\n        abort();\n    }*/\n\n    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n    unsafe { copy(src, dst, count) }\n}\n\n/// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n/// `val`.\n///\n/// `write_bytes` is similar to C's [`memset`], but sets `count *\n/// size_of::<T>()` bytes to `val`.\n///\n/// [`memset`]: https://en.cppreference.com/w/c/string/byte/memset\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n///\n/// * `dst` must be properly aligned.\n///\n/// Additionally, the caller must ensure that writing `count *\n/// size_of::<T>()` bytes to the given region of memory results in a valid\n/// value of `T`. Using a region of memory typed as a `T` that contains an\n/// invalid value of `T` is undefined behavior.\n///\n/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n/// `0`, the pointer must be non-null and properly aligned.\n///\n/// [valid]: crate::ptr#safety\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut vec = vec![0u32; 4];\n/// unsafe {\n///     let vec_ptr = vec.as_mut_ptr();\n///     ptr::write_bytes(vec_ptr, 0xfe, 2);\n/// }\n/// assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);\n/// ```\n///\n/// Creating an invalid value:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut v = Box::new(0i32);\n///\n/// unsafe {\n///     // Leaks the previously held value by overwriting the `Box<T>` with\n///     // a null pointer.\n///     ptr::write_bytes(&mut v as *mut Box<i32>, 0, 1);\n/// }\n///\n/// // At this point, using or dropping `v` results in undefined behavior.\n/// // drop(v); // ERROR\n///\n/// // Even leaking `v` \"uses\" it, and hence is undefined behavior.\n/// // mem::forget(v); // ERROR\n///\n/// // In fact, `v` is invalid according to basic type layout invariants, so *any*\n/// // operation touching it is undefined behavior.\n/// // let v2 = v; // ERROR\n///\n/// unsafe {\n///     // Let us instead put in a valid value\n///     ptr::write(&mut v as *mut Box<i32>, Box::new(42i32));\n/// }\n///\n/// // Now the box is fine\n/// assert_eq!(*v, 42);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[inline]\npub unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n    extern \"rust-intrinsic\" {\n        fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n    }\n\n    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n\n    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n    unsafe { write_bytes(dst, val, count) }\n}\n"],[2813,"use crate::{convert, ops};\n\n/// Used to tell an operation whether it should exit early or go on as usual.\n///\n/// This is used when exposing things (like graph traversals or visitors) where\n/// you want the user to be able to choose whether to exit early.\n/// Having the enum makes it clearer -- no more wondering \"wait, what did `false`\n/// mean again?\" -- and allows including a value.\n///\n/// # Examples\n///\n/// Early-exiting from [`Iterator::try_for_each`]:\n/// ```\n/// use std::ops::ControlFlow;\n///\n/// let r = (2..100).try_for_each(|x| {\n///     if 403 % x == 0 {\n///         return ControlFlow::Break(x)\n///     }\n///\n///     ControlFlow::Continue(())\n/// });\n/// assert_eq!(r, ControlFlow::Break(13));\n/// ```\n///\n/// A basic tree traversal:\n/// ```no_run\n/// use std::ops::ControlFlow;\n///\n/// pub struct TreeNode<T> {\n///     value: T,\n///     left: Option<Box<TreeNode<T>>>,\n///     right: Option<Box<TreeNode<T>>>,\n/// }\n///\n/// impl<T> TreeNode<T> {\n///     pub fn traverse_inorder<B>(&self, mut f: impl FnMut(&T) -> ControlFlow<B>) -> ControlFlow<B> {\n///         if let Some(left) = &self.left {\n///             left.traverse_inorder(&mut f)?;\n///         }\n///         f(&self.value)?;\n///         if let Some(right) = &self.right {\n///             right.traverse_inorder(&mut f)?;\n///         }\n///         ControlFlow::Continue(())\n///     }\n/// }\n/// ```\n#[stable(feature = \"control_flow_enum_type\", since = \"1.55.0\")]\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ControlFlow<B, C = ()> {\n    /// Move on to the next phase of the operation as normal.\n    #[stable(feature = \"control_flow_enum_type\", since = \"1.55.0\")]\n    #[cfg_attr(not(bootstrap), lang = \"Continue\")]\n    Continue(C),\n    /// Exit the operation without running subsequent phases.\n    #[stable(feature = \"control_flow_enum_type\", since = \"1.55.0\")]\n    #[cfg_attr(not(bootstrap), lang = \"Break\")]\n    Break(B),\n    // Yes, the order of the variants doesn't match the type parameters.\n    // They're in this order so that `ControlFlow<A, B>` <-> `Result<B, A>`\n    // is a no-op conversion in the `Try` implementation.\n}\n\n#[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n#[cfg(bootstrap)]\nimpl<B, C> ops::TryV1 for ControlFlow<B, C> {\n    type Output = C;\n    type Error = B;\n    #[inline]\n    fn into_result(self) -> Result<Self::Output, Self::Error> {\n        match self {\n            ControlFlow::Continue(y) => Ok(y),\n            ControlFlow::Break(x) => Err(x),\n        }\n    }\n    #[inline]\n    fn from_error(v: Self::Error) -> Self {\n        ControlFlow::Break(v)\n    }\n    #[inline]\n    fn from_ok(v: Self::Output) -> Self {\n        ControlFlow::Continue(v)\n    }\n}\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\nimpl<B, C> ops::TryV2 for ControlFlow<B, C> {\n    type Output = C;\n    type Residual = ControlFlow<B, convert::Infallible>;\n\n    #[inline]\n    fn from_output(output: Self::Output) -> Self {\n        ControlFlow::Continue(output)\n    }\n\n    #[inline]\n    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            ControlFlow::Continue(c) => ControlFlow::Continue(c),\n            ControlFlow::Break(b) => ControlFlow::Break(ControlFlow::Break(b)),\n        }\n    }\n}\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\nimpl<B, C> ops::FromResidual for ControlFlow<B, C> {\n    #[inline]\n    fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {\n        match residual {\n            ControlFlow::Break(b) => ControlFlow::Break(b),\n        }\n    }\n}\n\nimpl<B, C> ControlFlow<B, C> {\n    /// Returns `true` if this is a `Break` variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(control_flow_enum)]\n    /// use std::ops::ControlFlow;\n    ///\n    /// assert!(ControlFlow::<i32, String>::Break(3).is_break());\n    /// assert!(!ControlFlow::<String, i32>::Continue(3).is_break());\n    /// ```\n    #[inline]\n    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n    pub fn is_break(&self) -> bool {\n        matches!(*self, ControlFlow::Break(_))\n    }\n\n    /// Returns `true` if this is a `Continue` variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(control_flow_enum)]\n    /// use std::ops::ControlFlow;\n    ///\n    /// assert!(!ControlFlow::<i32, String>::Break(3).is_continue());\n    /// assert!(ControlFlow::<String, i32>::Continue(3).is_continue());\n    /// ```\n    #[inline]\n    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n    pub fn is_continue(&self) -> bool {\n        matches!(*self, ControlFlow::Continue(_))\n    }\n\n    /// Converts the `ControlFlow` into an `Option` which is `Some` if the\n    /// `ControlFlow` was `Break` and `None` otherwise.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(control_flow_enum)]\n    /// use std::ops::ControlFlow;\n    ///\n    /// assert_eq!(ControlFlow::<i32, String>::Break(3).break_value(), Some(3));\n    /// assert_eq!(ControlFlow::<String, i32>::Continue(3).break_value(), None);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n    pub fn break_value(self) -> Option<B> {\n        match self {\n            ControlFlow::Continue(..) => None,\n            ControlFlow::Break(x) => Some(x),\n        }\n    }\n\n    /// Maps `ControlFlow<B, C>` to `ControlFlow<T, C>` by applying a function\n    /// to the break value in case it exists.\n    #[inline]\n    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n    pub fn map_break<T, F>(self, f: F) -> ControlFlow<T, C>\n    where\n        F: FnOnce(B) -> T,\n    {\n        match self {\n            ControlFlow::Continue(x) => ControlFlow::Continue(x),\n            ControlFlow::Break(x) => ControlFlow::Break(f(x)),\n        }\n    }\n}\n\n#[cfg(bootstrap)]\nimpl<R: ops::TryV1> ControlFlow<R, R::Output> {\n    /// Create a `ControlFlow` from any type implementing `Try`.\n    #[inline]\n    pub(crate) fn from_try(r: R) -> Self {\n        match R::into_result(r) {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(v) => ControlFlow::Break(R::from_error(v)),\n        }\n    }\n\n    /// Convert a `ControlFlow` into any type implementing `Try`;\n    #[inline]\n    pub(crate) fn into_try(self) -> R {\n        match self {\n            ControlFlow::Continue(v) => R::from_ok(v),\n            ControlFlow::Break(v) => v,\n        }\n    }\n}\n\n/// These are used only as part of implementing the iterator adapters.\n/// They have mediocre names and non-obvious semantics, so aren't\n/// currently on a path to potential stabilization.\n#[cfg(not(bootstrap))]\nimpl<R: ops::TryV2> ControlFlow<R, R::Output> {\n    /// Create a `ControlFlow` from any type implementing `Try`.\n    #[inline]\n    pub(crate) fn from_try(r: R) -> Self {\n        match R::branch(r) {\n            ControlFlow::Continue(v) => ControlFlow::Continue(v),\n            ControlFlow::Break(v) => ControlFlow::Break(R::from_residual(v)),\n        }\n    }\n\n    /// Convert a `ControlFlow` into any type implementing `Try`;\n    #[inline]\n    pub(crate) fn into_try(self) -> R {\n        match self {\n            ControlFlow::Continue(v) => R::from_output(v),\n            ControlFlow::Break(v) => v,\n        }\n    }\n}\n\nimpl<B> ControlFlow<B, ()> {\n    /// It's frequently the case that there's no value needed with `Continue`,\n    /// so this provides a way to avoid typing `(())`, if you prefer it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(control_flow_enum)]\n    /// use std::ops::ControlFlow;\n    ///\n    /// let mut partial_sum = 0;\n    /// let last_used = (1..10).chain(20..25).try_for_each(|x| {\n    ///     partial_sum += x;\n    ///     if partial_sum > 100 { ControlFlow::Break(x) }\n    ///     else { ControlFlow::CONTINUE }\n    /// });\n    /// assert_eq!(last_used.break_value(), Some(22));\n    /// ```\n    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n    pub const CONTINUE: Self = ControlFlow::Continue(());\n}\n\nimpl<C> ControlFlow<(), C> {\n    /// APIs like `try_for_each` don't need values with `Break`,\n    /// so this provides a way to avoid typing `(())`, if you prefer it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(control_flow_enum)]\n    /// use std::ops::ControlFlow;\n    ///\n    /// let mut partial_sum = 0;\n    /// (1..10).chain(20..25).try_for_each(|x| {\n    ///     if partial_sum > 100 { ControlFlow::BREAK }\n    ///     else { partial_sum += x; ControlFlow::CONTINUE }\n    /// });\n    /// assert_eq!(partial_sum, 108);\n    /// ```\n    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n    pub const BREAK: Self = ControlFlow::Break(());\n}\n"],[2814,"use crate::marker::Unsize;\n\n/// Trait that indicates that this is a pointer or a wrapper for one,\n/// where unsizing can be performed on the pointee.\n///\n/// See the [DST coercion RFC][dst-coerce] and [the nomicon entry on coercion][nomicon-coerce]\n/// for more details.\n///\n/// For builtin pointer types, pointers to `T` will coerce to pointers to `U` if `T: Unsize<U>`\n/// by converting from a thin pointer to a fat pointer.\n///\n/// For custom types, the coercion here works by coercing `Foo<T>` to `Foo<U>`\n/// provided an impl of `CoerceUnsized<Foo<U>> for Foo<T>` exists.\n/// Such an impl can only be written if `Foo<T>` has only a single non-phantomdata\n/// field involving `T`. If the type of that field is `Bar<T>`, an implementation\n/// of `CoerceUnsized<Bar<U>> for Bar<T>` must exist. The coercion will work by\n/// coercing the `Bar<T>` field into `Bar<U>` and filling in the rest of the fields\n/// from `Foo<T>` to create a `Foo<U>`. This will effectively drill down to a pointer\n/// field and coerce that.\n///\n/// Generally, for smart pointers you will implement\n/// `CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized`, with an\n/// optional `?Sized` bound on `T` itself. For wrapper types that directly embed `T`\n/// like `Cell<T>` and `RefCell<T>`, you\n/// can directly implement `CoerceUnsized<Wrap<U>> for Wrap<T> where T: CoerceUnsized<U>`.\n/// This will let coercions of types like `Cell<Box<T>>` work.\n///\n/// [`Unsize`][unsize] is used to mark types which can be coerced to DSTs if behind\n/// pointers. It is implemented automatically by the compiler.\n///\n/// [dst-coerce]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n/// [unsize]: crate::marker::Unsize\n/// [nomicon-coerce]: ../../nomicon/coercions.html\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n#[lang = \"coerce_unsized\"]\npub trait CoerceUnsized<T: ?Sized> {\n    // Empty.\n}\n\n// &mut T -> &mut U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n// &mut T -> &U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n// &mut T -> *mut U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n// &mut T -> *const U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n\n// &T -> &U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n// &T -> *const U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n\n// *mut T -> *mut U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n// *mut T -> *const U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n\n// *const T -> *const U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n\n/// This is used for object safety, to check that a method's receiver type can be dispatched on.\n///\n/// An example implementation of the trait:\n///\n/// ```\n/// # #![feature(dispatch_from_dyn, unsize)]\n/// # use std::{ops::DispatchFromDyn, marker::Unsize};\n/// # struct Rc<T: ?Sized>(std::rc::Rc<T>);\n/// impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T>\n/// where\n///     T: Unsize<U>,\n/// {}\n/// ```\n#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\n#[lang = \"dispatch_from_dyn\"]\npub trait DispatchFromDyn<T> {\n    // Empty.\n}\n\n// &T -> &U\n#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\nimpl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n// &mut T -> &mut U\n#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\nimpl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n// *const T -> *const U\n#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n// *mut T -> *mut U\n#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n"],[2815,"//! Overloadable operators.\n//!\n//! Implementing these traits allows you to overload certain operators.\n//!\n//! Some of these traits are imported by the prelude, so they are available in\n//! every Rust program. Only operators backed by traits can be overloaded. For\n//! example, the addition operator (`+`) can be overloaded through the [`Add`]\n//! trait, but since the assignment operator (`=`) has no backing trait, there\n//! is no way of overloading its semantics. Additionally, this module does not\n//! provide any mechanism to create new operators. If traitless overloading or\n//! custom operators are required, you should look toward macros or compiler\n//! plugins to extend Rust's syntax.\n//!\n//! Implementations of operator traits should be unsurprising in their\n//! respective contexts, keeping in mind their usual meanings and\n//! [operator precedence]. For example, when implementing [`Mul`], the operation\n//! should have some resemblance to multiplication (and share expected\n//! properties like associativity).\n//!\n//! Note that the `&&` and `||` operators short-circuit, i.e., they only\n//! evaluate their second operand if it contributes to the result. Since this\n//! behavior is not enforceable by traits, `&&` and `||` are not supported as\n//! overloadable operators.\n//!\n//! Many of the operators take their operands by value. In non-generic\n//! contexts involving built-in types, this is usually not a problem.\n//! However, using these operators in generic code, requires some\n//! attention if values have to be reused as opposed to letting the operators\n//! consume them. One option is to occasionally use [`clone`].\n//! Another option is to rely on the types involved providing additional\n//! operator implementations for references. For example, for a user-defined\n//! type `T` which is supposed to support addition, it is probably a good\n//! idea to have both `T` and `&T` implement the traits [`Add<T>`][`Add`] and\n//! [`Add<&T>`][`Add`] so that generic code can be written without unnecessary\n//! cloning.\n//!\n//! # Examples\n//!\n//! This example creates a `Point` struct that implements [`Add`] and [`Sub`],\n//! and then demonstrates adding and subtracting two `Point`s.\n//!\n//! ```rust\n//! use std::ops::{Add, Sub};\n//!\n//! #[derive(Debug, Copy, Clone, PartialEq)]\n//! struct Point {\n//!     x: i32,\n//!     y: i32,\n//! }\n//!\n//! impl Add for Point {\n//!     type Output = Self;\n//!\n//!     fn add(self, other: Self) -> Self {\n//!         Self {x: self.x + other.x, y: self.y + other.y}\n//!     }\n//! }\n//!\n//! impl Sub for Point {\n//!     type Output = Self;\n//!\n//!     fn sub(self, other: Self) -> Self {\n//!         Self {x: self.x - other.x, y: self.y - other.y}\n//!     }\n//! }\n//!\n//! assert_eq!(Point {x: 3, y: 3}, Point {x: 1, y: 0} + Point {x: 2, y: 3});\n//! assert_eq!(Point {x: -1, y: -3}, Point {x: 1, y: 0} - Point {x: 2, y: 3});\n//! ```\n//!\n//! See the documentation for each trait for an example implementation.\n//!\n//! The [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\n//! invoked like functions. Note that [`Fn`] takes `&self`, [`FnMut`] takes `&mut\n//! self` and [`FnOnce`] takes `self`. These correspond to the three kinds of\n//! methods that can be invoked on an instance: call-by-reference,\n//! call-by-mutable-reference, and call-by-value. The most common use of these\n//! traits is to act as bounds to higher-level functions that take functions or\n//! closures as arguments.\n//!\n//! Taking a [`Fn`] as a parameter:\n//!\n//! ```rust\n//! fn call_with_one<F>(func: F) -> usize\n//!     where F: Fn(usize) -> usize\n//! {\n//!     func(1)\n//! }\n//!\n//! let double = |x| x * 2;\n//! assert_eq!(call_with_one(double), 2);\n//! ```\n//!\n//! Taking a [`FnMut`] as a parameter:\n//!\n//! ```rust\n//! fn do_twice<F>(mut func: F)\n//!     where F: FnMut()\n//! {\n//!     func();\n//!     func();\n//! }\n//!\n//! let mut x: usize = 1;\n//! {\n//!     let add_two_to_x = || x += 2;\n//!     do_twice(add_two_to_x);\n//! }\n//!\n//! assert_eq!(x, 5);\n//! ```\n//!\n//! Taking a [`FnOnce`] as a parameter:\n//!\n//! ```rust\n//! fn consume_with_relish<F>(func: F)\n//!     where F: FnOnce() -> String\n//! {\n//!     // `func` consumes its captured variables, so it cannot be run more\n//!     // than once\n//!     println!(\"Consumed: {}\", func());\n//!\n//!     println!(\"Delicious!\");\n//!\n//!     // Attempting to invoke `func()` again will throw a `use of moved\n//!     // value` error for `func`\n//! }\n//!\n//! let x = String::from(\"x\");\n//! let consume_and_return_x = move || x;\n//! consume_with_relish(consume_and_return_x);\n//!\n//! // `consume_and_return_x` can no longer be invoked at this point\n//! ```\n//!\n//! [`clone`]: Clone::clone\n//! [operator precedence]: ../../reference/expressions.html#expression-precedence\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nmod arith;\nmod bit;\nmod control_flow;\nmod deref;\nmod drop;\nmod function;\nmod generator;\nmod index;\nmod range;\n#[cfg(bootstrap)]\nmod r#try;\nmod try_trait;\nmod unsize;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::arith::{Add, Div, Mul, Neg, Rem, Sub};\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\npub use self::arith::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::bit::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\npub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::deref::{Deref, DerefMut};\n\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\npub use self::deref::Receiver;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::drop::Drop;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::function::{Fn, FnMut, FnOnce};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::index::{Index, IndexMut};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\npub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\n#[cfg(bootstrap)]\npub use self::r#try::Try;\n\n#[unstable(feature = \"try_trait_transition\", reason = \"for bootstrap\", issue = \"none\")]\n#[cfg(bootstrap)]\npub(crate) use self::r#try::Try as TryV1;\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\npub use self::try_trait::FromResidual;\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n#[cfg(not(bootstrap))]\npub use self::try_trait::Try;\n\n#[unstable(feature = \"try_trait_transition\", reason = \"for bootstrap\", issue = \"none\")]\npub(crate) use self::try_trait::Try as TryV2;\n\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\npub use self::generator::{Generator, GeneratorState};\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\npub use self::unsize::CoerceUnsized;\n\n#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\npub use self::unsize::DispatchFromDyn;\n\n#[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\npub use self::control_flow::ControlFlow;\n"],[2816,"/// Used for indexing operations (`container[index]`) in immutable contexts.\n///\n/// `container[index]` is actually syntactic sugar for `*container.index(index)`,\n/// but only when used as an immutable value. If a mutable value is requested,\n/// [`IndexMut`] is used instead. This allows nice things such as\n/// `let value = v[index]` if the type of `value` implements [`Copy`].\n///\n/// # Examples\n///\n/// The following example implements `Index` on a read-only `NucleotideCount`\n/// container, enabling individual counts to be retrieved with index syntax.\n///\n/// ```\n/// use std::ops::Index;\n///\n/// enum Nucleotide {\n///     A,\n///     C,\n///     G,\n///     T,\n/// }\n///\n/// struct NucleotideCount {\n///     a: usize,\n///     c: usize,\n///     g: usize,\n///     t: usize,\n/// }\n///\n/// impl Index<Nucleotide> for NucleotideCount {\n///     type Output = usize;\n///\n///     fn index(&self, nucleotide: Nucleotide) -> &Self::Output {\n///         match nucleotide {\n///             Nucleotide::A => &self.a,\n///             Nucleotide::C => &self.c,\n///             Nucleotide::G => &self.g,\n///             Nucleotide::T => &self.t,\n///         }\n///     }\n/// }\n///\n/// let nucleotide_count = NucleotideCount {a: 14, c: 9, g: 10, t: 12};\n/// assert_eq!(nucleotide_count[Nucleotide::A], 14);\n/// assert_eq!(nucleotide_count[Nucleotide::C], 9);\n/// assert_eq!(nucleotide_count[Nucleotide::G], 10);\n/// assert_eq!(nucleotide_count[Nucleotide::T], 12);\n/// ```\n#[lang = \"index\"]\n#[rustc_on_unimplemented(\n    message = \"the type `{Self}` cannot be indexed by `{Idx}`\",\n    label = \"`{Self}` cannot be indexed by `{Idx}`\"\n)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \"]\")]\n#[doc(alias = \"[\")]\n#[doc(alias = \"[]\")]\npub trait Index<Idx: ?Sized> {\n    /// The returned type after indexing.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output: ?Sized;\n\n    /// Performs the indexing (`container[index]`) operation.\n    ///\n    /// # Panics\n    ///\n    /// May panic if the index is out of bounds.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[track_caller]\n    fn index(&self, index: Idx) -> &Self::Output;\n}\n\n/// Used for indexing operations (`container[index]`) in mutable contexts.\n///\n/// `container[index]` is actually syntactic sugar for\n/// `*container.index_mut(index)`, but only when used as a mutable value. If\n/// an immutable value is requested, the [`Index`] trait is used instead. This\n/// allows nice things such as `v[index] = value`.\n///\n/// # Examples\n///\n/// A very simple implementation of a `Balance` struct that has two sides, where\n/// each can be indexed mutably and immutably.\n///\n/// ```\n/// use std::ops::{Index, IndexMut};\n///\n/// #[derive(Debug)]\n/// enum Side {\n///     Left,\n///     Right,\n/// }\n///\n/// #[derive(Debug, PartialEq)]\n/// enum Weight {\n///     Kilogram(f32),\n///     Pound(f32),\n/// }\n///\n/// struct Balance {\n///     pub left: Weight,\n///     pub right: Weight,\n/// }\n///\n/// impl Index<Side> for Balance {\n///     type Output = Weight;\n///\n///     fn index(&self, index: Side) -> &Self::Output {\n///         println!(\"Accessing {:?}-side of balance immutably\", index);\n///         match index {\n///             Side::Left => &self.left,\n///             Side::Right => &self.right,\n///         }\n///     }\n/// }\n///\n/// impl IndexMut<Side> for Balance {\n///     fn index_mut(&mut self, index: Side) -> &mut Self::Output {\n///         println!(\"Accessing {:?}-side of balance mutably\", index);\n///         match index {\n///             Side::Left => &mut self.left,\n///             Side::Right => &mut self.right,\n///         }\n///     }\n/// }\n///\n/// let mut balance = Balance {\n///     right: Weight::Kilogram(2.5),\n///     left: Weight::Pound(1.5),\n/// };\n///\n/// // In this case, `balance[Side::Right]` is sugar for\n/// // `*balance.index(Side::Right)`, since we are only *reading*\n/// // `balance[Side::Right]`, not writing it.\n/// assert_eq!(balance[Side::Right], Weight::Kilogram(2.5));\n///\n/// // However, in this case `balance[Side::Left]` is sugar for\n/// // `*balance.index_mut(Side::Left)`, since we are writing\n/// // `balance[Side::Left]`.\n/// balance[Side::Left] = Weight::Kilogram(3.0);\n/// ```\n#[lang = \"index_mut\"]\n#[rustc_on_unimplemented(\n    on(\n        _Self = \"&str\",\n        note = \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n    ),\n    on(\n        _Self = \"str\",\n        note = \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n    ),\n    on(\n        _Self = \"std::string::String\",\n        note = \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n    ),\n    message = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n    label = \"`{Self}` cannot be mutably indexed by `{Idx}`\"\n)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \"[\")]\n#[doc(alias = \"]\")]\n#[doc(alias = \"[]\")]\npub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n    /// Performs the mutable indexing (`container[index]`) operation.\n    ///\n    /// # Panics\n    ///\n    /// May panic if the index is out of bounds.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[track_caller]\n    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n}\n"],[2817,"/// Custom code within the destructor.\n///\n/// When a value is no longer needed, Rust will run a \"destructor\" on that value.\n/// The most common way that a value is no longer needed is when it goes out of\n/// scope. Destructors may still run in other circumstances, but we're going to\n/// focus on scope for the examples here. To learn about some of those other cases,\n/// please see [the reference] section on destructors.\n///\n/// [the reference]: https://doc.rust-lang.org/reference/destructors.html\n///\n/// This destructor consists of two components:\n/// - A call to `Drop::drop` for that value, if this special `Drop` trait is implemented for its type.\n/// - The automatically generated \"drop glue\" which recursively calls the destructors\n///     of the all fields of this value.\n///\n/// As Rust automatically calls the destructors of all contained fields,\n/// you don't have to implement `Drop` in most cases. But there are some cases where\n/// it is useful, for example for types which directly manage a resource.\n/// That resource may be memory, it may be a file descriptor, it may be a network socket.\n/// Once a value of that type is no longer going to be used, it should \"clean up\" its\n/// resource by freeing the memory or closing the file or socket. This is\n/// the job of a destructor, and therefore the job of `Drop::drop`.\n///\n/// ## Examples\n///\n/// To see destructors in action, let's take a look at the following program:\n///\n/// ```rust\n/// struct HasDrop;\n///\n/// impl Drop for HasDrop {\n///     fn drop(&mut self) {\n///         println!(\"Dropping HasDrop!\");\n///     }\n/// }\n///\n/// struct HasTwoDrops {\n///     one: HasDrop,\n///     two: HasDrop,\n/// }\n///\n/// impl Drop for HasTwoDrops {\n///     fn drop(&mut self) {\n///         println!(\"Dropping HasTwoDrops!\");\n///     }\n/// }\n///\n/// fn main() {\n///     let _x = HasTwoDrops { one: HasDrop, two: HasDrop };\n///     println!(\"Running!\");\n/// }\n/// ```\n///\n/// Rust will first call `Drop::drop` for `_x` and then for both `_x.one` and `_x.two`,\n/// meaning that running this will print\n///\n/// ```text\n/// Running!\n/// Dropping HasTwoDrops!\n/// Dropping HasDrop!\n/// Dropping HasDrop!\n/// ```\n///\n/// Even if we remove the implementation of `Drop` for `HasTwoDrop`, the destructors of its fields are still called.\n/// This would result in\n///\n/// ```test\n/// Running!\n/// Dropping HasDrop!\n/// Dropping HasDrop!\n/// ```\n///\n/// ## You cannot call `Drop::drop` yourself\n///\n/// Because `Drop::drop` is used to clean up a value, it may be dangerous to use this value after\n/// the method has been called. As `Drop::drop` does not take ownership of its input,\n/// Rust prevents misuse by not allowing you to call `Drop::drop` directly.\n///\n/// In other words, if you tried to explicitly call `Drop::drop` in the above example, you'd get a compiler error.\n///\n/// If you'd like to explicitly call the destructor of a value, [`mem::drop`] can be used instead.\n///\n/// [`mem::drop`]: drop\n///\n/// ## Drop order\n///\n/// Which of our two `HasDrop` drops first, though? For structs, it's the same\n/// order that they're declared: first `one`, then `two`. If you'd like to try\n/// this yourself, you can modify `HasDrop` above to contain some data, like an\n/// integer, and then use it in the `println!` inside of `Drop`. This behavior is\n/// guaranteed by the language.\n///\n/// Unlike for structs, local variables are dropped in reverse order:\n///\n/// ```rust\n/// struct Foo;\n///\n/// impl Drop for Foo {\n///     fn drop(&mut self) {\n///         println!(\"Dropping Foo!\")\n///     }\n/// }\n///\n/// struct Bar;\n///\n/// impl Drop for Bar {\n///     fn drop(&mut self) {\n///         println!(\"Dropping Bar!\")\n///     }\n/// }\n///\n/// fn main() {\n///     let _foo = Foo;\n///     let _bar = Bar;\n/// }\n/// ```\n///\n/// This will print\n///\n/// ```text\n/// Dropping Bar!\n/// Dropping Foo!\n/// ```\n///\n/// Please see [the reference] for the full rules.\n///\n/// [the reference]: https://doc.rust-lang.org/reference/destructors.html\n///\n/// ## `Copy` and `Drop` are exclusive\n///\n/// You cannot implement both [`Copy`] and `Drop` on the same type. Types that\n/// are `Copy` get implicitly duplicated by the compiler, making it very\n/// hard to predict when, and how often destructors will be executed. As such,\n/// these types cannot have destructors.\n#[lang = \"drop\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Drop {\n    /// Executes the destructor for this type.\n    ///\n    /// This method is called implicitly when the value goes out of scope,\n    /// and cannot be called explicitly (this is compiler error [E0040]).\n    /// However, the [`mem::drop`] function in the prelude can be\n    /// used to call the argument's `Drop` implementation.\n    ///\n    /// When this method has been called, `self` has not yet been deallocated.\n    /// That only happens after the method is over.\n    /// If this wasn't the case, `self` would be a dangling reference.\n    ///\n    /// # Panics\n    ///\n    /// Given that a [`panic!`] will call `drop` as it unwinds, any [`panic!`]\n    /// in a `drop` implementation will likely abort.\n    ///\n    /// Note that even if this panics, the value is considered to be dropped;\n    /// you must not cause `drop` to be called again. This is normally automatically\n    /// handled by the compiler, but when using unsafe code, can sometimes occur\n    /// unintentionally, particularly when using [`ptr::drop_in_place`].\n    ///\n    /// [E0040]: ../../error-index.html#E0040\n    /// [`panic!`]: crate::panic!\n    /// [`mem::drop`]: drop\n    /// [`ptr::drop_in_place`]: crate::ptr::drop_in_place\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn drop(&mut self);\n}\n"],[2818,"/// The version of the call operator that takes an immutable receiver.\n///\n/// Instances of `Fn` can be called repeatedly without mutating state.\n///\n/// *This trait (`Fn`) is not to be confused with [function pointers]\n/// (`fn`).*\n///\n/// `Fn` is implemented automatically by closures which only take immutable\n/// references to captured variables or don't capture anything at all, as well\n/// as (safe) [function pointers] (with some caveats, see their documentation\n/// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n/// implements `Fn`, too.\n///\n/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n/// is expected.\n///\n/// Use `Fn` as a bound when you want to accept a parameter of function-like\n/// type and need to call it repeatedly and without mutating state (e.g., when\n/// calling it concurrently). If you do not need such strict requirements, use\n/// [`FnMut`] or [`FnOnce`] as bounds.\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [function pointers]: fn\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Calling a closure\n///\n/// ```\n/// let square = |x| x * x;\n/// assert_eq!(square(5), 25);\n/// ```\n///\n/// ## Using a `Fn` parameter\n///\n/// ```\n/// fn call_with_one<F>(func: F) -> usize\n///     where F: Fn(usize) -> usize {\n///     func(1)\n/// }\n///\n/// let double = |x| x * 2;\n/// assert_eq!(call_with_one(double), 2);\n/// ```\n#[lang = \"fn\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n    ),\n    message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n    label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `&str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait Fn<Args>: FnMut<Args> {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n}\n\n/// The version of the call operator that takes a mutable receiver.\n///\n/// Instances of `FnMut` can be called repeatedly and may mutate state.\n///\n/// `FnMut` is implemented automatically by closures which take mutable\n/// references to captured variables, as well as all types that implement\n/// [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n/// implements `FnMut`, too.\n///\n/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n///\n/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n/// type and need to call it repeatedly, while allowing it to mutate state.\n/// If you don't want the parameter to mutate state, use [`Fn`] as a\n/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [function pointers]: fn\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Calling a mutably capturing closure\n///\n/// ```\n/// let mut x = 5;\n/// {\n///     let mut square_x = || x *= x;\n///     square_x();\n/// }\n/// assert_eq!(x, 25);\n/// ```\n///\n/// ## Using a `FnMut` parameter\n///\n/// ```\n/// fn do_twice<F>(mut func: F)\n///     where F: FnMut()\n/// {\n///     func();\n///     func();\n/// }\n///\n/// let mut x: usize = 1;\n/// {\n///     let add_two_to_x = || x += 2;\n///     do_twice(add_two_to_x);\n/// }\n///\n/// assert_eq!(x, 5);\n/// ```\n#[lang = \"fn_mut\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n    ),\n    message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n    label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `&str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait FnMut<Args>: FnOnce<Args> {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n}\n\n/// The version of the call operator that takes a by-value receiver.\n///\n/// Instances of `FnOnce` can be called, but might not be callable multiple\n/// times. Because of this, if the only thing known about a type is that it\n/// implements `FnOnce`, it can only be called once.\n///\n/// `FnOnce` is implemented automatically by closures that might consume captured\n/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n/// [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n///\n/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n///\n/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n/// type and only need to call it once. If you need to call the parameter\n/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n/// state, use [`Fn`].\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [function pointers]: fn\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Using a `FnOnce` parameter\n///\n/// ```\n/// fn consume_with_relish<F>(func: F)\n///     where F: FnOnce() -> String\n/// {\n///     // `func` consumes its captured variables, so it cannot be run more\n///     // than once.\n///     println!(\"Consumed: {}\", func());\n///\n///     println!(\"Delicious!\");\n///\n///     // Attempting to invoke `func()` again will throw a `use of moved\n///     // value` error for `func`.\n/// }\n///\n/// let x = String::from(\"x\");\n/// let consume_and_return_x = move || x;\n/// consume_with_relish(consume_and_return_x);\n///\n/// // `consume_and_return_x` can no longer be invoked at this point\n/// ```\n#[lang = \"fn_once\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n    ),\n    message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n    label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `&str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait FnOnce<Args> {\n    /// The returned type after the call operator is used.\n    #[lang = \"fn_once_output\"]\n    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n    type Output;\n\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n}\n\nmod impls {\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> Fn<A> for &F\n    where\n        F: Fn<A>,\n    {\n        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n            (**self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> FnMut<A> for &F\n    where\n        F: Fn<A>,\n    {\n        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n            (**self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> FnOnce<A> for &F\n    where\n        F: Fn<A>,\n    {\n        type Output = F::Output;\n\n        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n            (*self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> FnMut<A> for &mut F\n    where\n        F: FnMut<A>,\n    {\n        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n            (*self).call_mut(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> FnOnce<A> for &mut F\n    where\n        F: FnMut<A>,\n    {\n        type Output = F::Output;\n        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n            (*self).call_mut(args)\n        }\n    }\n}\n"],[2819,"use crate::ops::ControlFlow;\n\n/// The `?` operator and `try {}` blocks.\n///\n/// `try_*` methods typically involve a type implementing this trait.  For\n/// example, the closures passed to [`Iterator::try_fold`] and\n/// [`Iterator::try_for_each`] must return such a type.\n///\n/// `Try` types are typically those containing two or more categories of values,\n/// some subset of which are so commonly handled via early returns that it's\n/// worth providing a terse (but still visible) syntax to make that easy.\n///\n/// This is most often seen for error handling with [`Result`] and [`Option`].\n/// The quintessential implementation of this trait is on [`ControlFlow`].\n///\n/// # Using `Try` in Generic Code\n///\n/// `Iterator::try_fold` was stabilized to call back in Rust 1.27, but\n/// this trait is much newer.  To illustrate the various associated types and\n/// methods, let's implement our own version.\n///\n/// As a reminder, an infallible version of a fold looks something like this:\n/// ```\n/// fn simple_fold<A, T>(\n///     iter: impl Iterator<Item = T>,\n///     mut accum: A,\n///     mut f: impl FnMut(A, T) -> A,\n/// ) -> A {\n///     for x in iter {\n///         accum = f(accum, x);\n///     }\n///     accum\n/// }\n/// ```\n///\n/// So instead of `f` returning just an `A`, we'll need it to return some other\n/// type that produces an `A` in the \"don't short circuit\" path.  Conveniently,\n/// that's also the type we need to return from the function.\n///\n/// Let's add a new generic parameter `R` for that type, and bound it to the\n/// output type that we want:\n/// ```\n/// # #![feature(try_trait_v2)]\n/// # use std::ops::Try;\n/// fn simple_try_fold_1<A, T, R: Try<Output = A>>(\n///     iter: impl Iterator<Item = T>,\n///     mut accum: A,\n///     mut f: impl FnMut(A, T) -> R,\n/// ) -> R {\n///     todo!()\n/// }\n/// ```\n///\n/// If we get through the entire iterator, we need to wrap up the accumulator\n/// into the return type using [`Try::from_output`]:\n/// ```\n/// # #![feature(try_trait_v2)]\n/// # use std::ops::{ControlFlow, Try};\n/// fn simple_try_fold_2<A, T, R: Try<Output = A>>(\n///     iter: impl Iterator<Item = T>,\n///     mut accum: A,\n///     mut f: impl FnMut(A, T) -> R,\n/// ) -> R {\n///     for x in iter {\n///         let cf = f(accum, x).branch();\n///         match cf {\n///             ControlFlow::Continue(a) => accum = a,\n///             ControlFlow::Break(_) => todo!(),\n///         }\n///     }\n///     R::from_output(accum)\n/// }\n/// ```\n///\n/// We'll also need [`FromResidual::from_residual`] to turn the residual back\n/// into the original type.  But because it's a supertrait of `Try`, we don't\n/// need to mention it in the bounds.  All types which implement `Try` can be\n/// recreated from their corresponding residual, so we'll just call it:\n/// ```\n/// # #![feature(try_trait_v2)]\n/// # use std::ops::{ControlFlow, Try};\n/// pub fn simple_try_fold_3<A, T, R: Try<Output = A>>(\n///     iter: impl Iterator<Item = T>,\n///     mut accum: A,\n///     mut f: impl FnMut(A, T) -> R,\n/// ) -> R {\n///     for x in iter {\n///         let cf = f(accum, x).branch();\n///         match cf {\n///             ControlFlow::Continue(a) => accum = a,\n///             ControlFlow::Break(r) => return R::from_residual(r),\n///         }\n///     }\n///     R::from_output(accum)\n/// }\n/// ```\n///\n/// But this \"call `branch`, then `match` on it, and `return` if it was a\n/// `Break`\" is exactly what happens inside the `?` operator.  So rather than\n/// do all this manually, we can just use `?` instead:\n/// ```\n/// # #![feature(try_trait_v2)]\n/// # use std::ops::Try;\n/// fn simple_try_fold<A, T, R: Try<Output = A>>(\n///     iter: impl Iterator<Item = T>,\n///     mut accum: A,\n///     mut f: impl FnMut(A, T) -> R,\n/// ) -> R {\n///     for x in iter {\n///         accum = f(accum, x)?;\n///     }\n///     R::from_output(accum)\n/// }\n/// ```\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n#[rustc_on_unimplemented(\n    on(\n        all(from_method = \"from_output\", from_desugaring = \"TryBlock\"),\n        message = \"a `try` block must return `Result` or `Option` \\\n                    (or another type that implements `{Try}`)\",\n        label = \"could not wrap the final value of the block as `{Self}` doesn't implement `Try`\",\n    ),\n    on(\n        all(from_method = \"branch\", from_desugaring = \"QuestionMark\"),\n        message = \"the `?` operator can only be applied to values \\\n                    that implement `{Try}`\",\n        label = \"the `?` operator cannot be applied to type `{Self}`\"\n    )\n)]\n#[doc(alias = \"?\")]\n#[cfg_attr(not(bootstrap), lang = \"Try\")]\npub trait Try: FromResidual {\n    /// The type of the value produced by `?` when *not* short-circuiting.\n    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n    type Output;\n\n    /// The type of the value passed to [`FromResidual::from_residual`]\n    /// as part of `?` when short-circuiting.\n    ///\n    /// This represents the possible values of the `Self` type which are *not*\n    /// represented by the `Output` type.\n    ///\n    /// # Note to Implementors\n    ///\n    /// The choice of this type is critical to interconversion.\n    /// Unlike the `Output` type, which will often be a raw generic type,\n    /// this type is typically a newtype of some sort to \"color\" the type\n    /// so that it's distinguishable from the residuals of other types.\n    ///\n    /// This is why `Result<T, E>::Residual` is not `E`, but `Result<Infallible, E>`.\n    /// That way it's distinct from `ControlFlow<E>::Residual`, for example,\n    /// and thus `?` on `ControlFlow` cannot be used in a method returning `Result`.\n    ///\n    /// If you're making a generic type `Foo<T>` that implements `Try<Output = T>`,\n    /// then typically you can use `Foo<std::convert::Infallible>` as its `Residual`\n    /// type: that type will have a \"hole\" in the correct place, and will maintain the\n    /// \"foo-ness\" of the residual so other types need to opt-in to interconversion.\n    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n    type Residual;\n\n    /// Constructs the type from its `Output` type.\n    ///\n    /// This should be implemented consistently with the `branch` method\n    /// such that applying the `?` operator will get back the original value:\n    /// `Try::from_output(x).branch() --> ControlFlow::Continue(x)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_trait_v2)]\n    /// use std::ops::Try;\n    ///\n    /// assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n    /// assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n    /// assert_eq!(\n    ///     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n    ///     std::ops::ControlFlow::Continue(5),\n    /// );\n    ///\n    /// # fn make_question_mark_work() -> Option<()> {\n    /// assert_eq!(Option::from_output(4)?, 4);\n    /// # None }\n    /// # make_question_mark_work();\n    ///\n    /// // This is used, for example, on the accumulator in `try_fold`:\n    /// let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n    /// assert_eq!(r, Some(4));\n    /// ```\n    #[cfg_attr(not(bootstrap), lang = \"from_output\")]\n    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n    fn from_output(output: Self::Output) -> Self;\n\n    /// Used in `?` to decide whether the operator should produce a value\n    /// (because this returned [`ControlFlow::Continue`])\n    /// or propagate a value back to the caller\n    /// (because this returned [`ControlFlow::Break`]).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_trait_v2)]\n    /// use std::ops::{ControlFlow, Try};\n    ///\n    /// assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n    /// assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n    ///\n    /// assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n    /// assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n    ///\n    /// assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n    /// assert_eq!(\n    ///     ControlFlow::<_, String>::Break(3).branch(),\n    ///     ControlFlow::Break(ControlFlow::Break(3)),\n    /// );\n    /// ```\n    #[cfg_attr(not(bootstrap), lang = \"branch\")]\n    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n    fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;\n}\n\n/// Used to specify which residuals can be converted into which [`crate::ops::Try`] types.\n///\n/// Every `Try` type needs to be recreatable from its own associated\n/// `Residual` type, but can also have additional `FromResidual` implementations\n/// to support interconversion with other `Try` types.\n#[rustc_on_unimplemented(\n    on(\n        all(\n            from_method = \"from_residual\",\n            from_desugaring = \"QuestionMark\",\n            _Self = \"std::result::Result<T, E>\",\n            R = \"std::option::Option<std::convert::Infallible>\"\n        ),\n        message = \"the `?` operator can only be used on `Result`s, not `Option`s, \\\n            in {ItemContext} that returns `Result`\",\n        label = \"use `.ok_or(...)?` to provide an error compatible with `{Self}`\",\n        enclosing_scope = \"this function returns a `Result`\"\n    ),\n    on(\n        all(\n            from_method = \"from_residual\",\n            from_desugaring = \"QuestionMark\",\n            _Self = \"std::result::Result<T, E>\",\n        ),\n        // There's a special error message in the trait selection code for\n        // `From` in `?`, so this is not shown for result-in-result errors,\n        // and thus it can be phrased more strongly than `ControlFlow`'s.\n        message = \"the `?` operator can only be used on `Result`s \\\n            in {ItemContext} that returns `Result`\",\n        label = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\n        enclosing_scope = \"this function returns a `Result`\"\n    ),\n    on(\n        all(\n            from_method = \"from_residual\",\n            from_desugaring = \"QuestionMark\",\n            _Self = \"std::option::Option<T>\",\n            R = \"std::result::Result<T, E>\",\n        ),\n        message = \"the `?` operator can only be used on `Option`s, not `Result`s, \\\n            in {ItemContext} that returns `Option`\",\n        label = \"use `.ok()?` if you want to discard the `{R}` error information\",\n        enclosing_scope = \"this function returns an `Option`\"\n    ),\n    on(\n        all(\n            from_method = \"from_residual\",\n            from_desugaring = \"QuestionMark\",\n            _Self = \"std::option::Option<T>\",\n        ),\n        // `Option`-in-`Option` always works, as there's only one possible\n        // residual, so this can also be phrased strongly.\n        message = \"the `?` operator can only be used on `Option`s \\\n            in {ItemContext} that returns `Option`\",\n        label = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\n        enclosing_scope = \"this function returns an `Option`\"\n    ),\n    on(\n        all(\n            from_method = \"from_residual\",\n            from_desugaring = \"QuestionMark\",\n            _Self = \"std::ops::ControlFlow<B, C>\",\n            R = \"std::ops::ControlFlow<B, C>\",\n        ),\n        message = \"the `?` operator in {ItemContext} that returns `ControlFlow<B, _>` \\\n            can only be used on other `ControlFlow<B, _>`s (with the same Break type)\",\n        label = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\n        enclosing_scope = \"this function returns a `ControlFlow`\",\n        note = \"unlike `Result`, there's no `From`-conversion performed for `ControlFlow`\"\n    ),\n    on(\n        all(\n            from_method = \"from_residual\",\n            from_desugaring = \"QuestionMark\",\n            _Self = \"std::ops::ControlFlow<B, C>\",\n            // `R` is not a `ControlFlow`, as that case was matched previously\n        ),\n        message = \"the `?` operator can only be used on `ControlFlow`s \\\n            in {ItemContext} that returns `ControlFlow`\",\n        label = \"this `?` produces `{R}`, which is incompatible with `{Self}`\",\n        enclosing_scope = \"this function returns a `ControlFlow`\",\n    ),\n    on(\n        all(\n            from_method = \"from_residual\",\n            from_desugaring = \"QuestionMark\"\n        ),\n        message = \"the `?` operator can only be used in {ItemContext} \\\n                    that returns `Result` or `Option` \\\n                    (or another type that implements `{FromResidual}`)\",\n        label = \"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\n        enclosing_scope = \"this function should return `Result` or `Option` to accept `?`\"\n    ),\n)]\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\npub trait FromResidual<R = <Self as Try>::Residual> {\n    /// Constructs the type from a compatible `Residual` type.\n    ///\n    /// This should be implemented consistently with the `branch` method such\n    /// that applying the `?` operator will get back an equivalent residual:\n    /// `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n    /// (It may not be an *identical* residual when interconversion is involved.)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_trait_v2)]\n    /// use std::ops::{ControlFlow, FromResidual};\n    ///\n    /// assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n    /// assert_eq!(Option::<String>::from_residual(None), None);\n    /// assert_eq!(\n    ///     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n    ///     ControlFlow::Break(5),\n    /// );\n    /// ```\n    #[cfg_attr(not(bootstrap), lang = \"from_residual\")]\n    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n    fn from_residual(residual: R) -> Self;\n}\n"],[2820,"use crate::fmt;\nuse crate::hash::Hash;\n\n/// An unbounded range (`..`).\n///\n/// `RangeFull` is primarily used as a [slicing index], its shorthand is `..`.\n/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n///\n/// # Examples\n///\n/// The `..` syntax is a `RangeFull`:\n///\n/// ```\n/// assert_eq!((..), std::ops::RangeFull);\n/// ```\n///\n/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n/// a `for` loop directly. This won't compile:\n///\n/// ```compile_fail,E0277\n/// for i in .. {\n///     // ...\n/// }\n/// ```\n///\n/// Used as a [slicing index], `RangeFull` produces the full array as a slice.\n///\n/// ```\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]); // This is the `RangeFull`\n/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n/// ```\n///\n/// [slicing index]: crate::slice::SliceIndex\n#[lang = \"RangeFull\"]\n#[doc(alias = \"..\")]\n#[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RangeFull;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for RangeFull {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(fmt, \"..\")\n    }\n}\n\n/// A (half-open) range bounded inclusively below and exclusively above\n/// (`start..end`).\n///\n/// The range `start..end` contains all values with `start <= x < end`.\n/// It is empty if `start >= end`.\n///\n/// # Examples\n///\n/// The `start..end` syntax is a `Range`:\n///\n/// ```\n/// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n/// assert_eq!(3 + 4 + 5, (3..6).sum());\n/// ```\n///\n/// ```\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n/// assert_eq!(arr[1.. 3], [   1, 2      ]); // This is a `Range`\n/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n/// ```\n#[lang = \"Range\"]\n#[doc(alias = \"..\")]\n#[derive(Clone, Default, PartialEq, Eq, Hash)] // not Copy -- see #27186\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Range<Idx> {\n    /// The lower bound of the range (inclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub start: Idx,\n    /// The upper bound of the range (exclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub end: Idx,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.start.fmt(fmt)?;\n        write!(fmt, \"..\")?;\n        self.end.fmt(fmt)?;\n        Ok(())\n    }\n}\n\nimpl<Idx: PartialOrd<Idx>> Range<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!(!(3..5).contains(&2));\n    /// assert!( (3..5).contains(&3));\n    /// assert!( (3..5).contains(&4));\n    /// assert!(!(3..5).contains(&5));\n    ///\n    /// assert!(!(3..3).contains(&3));\n    /// assert!(!(3..2).contains(&3));\n    ///\n    /// assert!( (0.0..1.0).contains(&0.5));\n    /// assert!(!(0.0..1.0).contains(&f32::NAN));\n    /// assert!(!(0.0..f32::NAN).contains(&0.5));\n    /// assert!(!(f32::NAN..1.0).contains(&0.5));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n        <Self as RangeBounds<Idx>>::contains(self, item)\n    }\n\n    /// Returns `true` if the range contains no items.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!(!(3..5).is_empty());\n    /// assert!( (3..3).is_empty());\n    /// assert!( (3..2).is_empty());\n    /// ```\n    ///\n    /// The range is empty if either side is incomparable:\n    ///\n    /// ```\n    /// assert!(!(3.0..5.0).is_empty());\n    /// assert!( (3.0..f32::NAN).is_empty());\n    /// assert!( (f32::NAN..5.0).is_empty());\n    /// ```\n    #[stable(feature = \"range_is_empty\", since = \"1.47.0\")]\n    pub fn is_empty(&self) -> bool {\n        !(self.start < self.end)\n    }\n}\n\n/// A range only bounded inclusively below (`start..`).\n///\n/// The `RangeFrom` `start..` contains all values with `x >= start`.\n///\n/// *Note*: Overflow in the [`Iterator`] implementation (when the contained\n/// data type reaches its numerical limit) is allowed to panic, wrap, or\n/// saturate. This behavior is defined by the implementation of the [`Step`]\n/// trait. For primitive integers, this follows the normal rules, and respects\n/// the overflow checks profile (panic in debug, wrap in release). Note also\n/// that overflow happens earlier than you might assume: the overflow happens\n/// in the call to `next` that yields the maximum value, as the range must be\n/// set to a state to yield the next value.\n///\n/// [`Step`]: crate::iter::Step\n///\n/// # Examples\n///\n/// The `start..` syntax is a `RangeFrom`:\n///\n/// ```\n/// assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n/// assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n/// ```\n///\n/// ```\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]); // This is a `RangeFrom`\n/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n/// ```\n#[lang = \"RangeFrom\"]\n#[doc(alias = \"..\")]\n#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RangeFrom<Idx> {\n    /// The lower bound of the range (inclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub start: Idx,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.start.fmt(fmt)?;\n        write!(fmt, \"..\")?;\n        Ok(())\n    }\n}\n\nimpl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!(!(3..).contains(&2));\n    /// assert!( (3..).contains(&3));\n    /// assert!( (3..).contains(&1_000_000_000));\n    ///\n    /// assert!( (0.0..).contains(&0.5));\n    /// assert!(!(0.0..).contains(&f32::NAN));\n    /// assert!(!(f32::NAN..).contains(&0.5));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n        <Self as RangeBounds<Idx>>::contains(self, item)\n    }\n}\n\n/// A range only bounded exclusively above (`..end`).\n///\n/// The `RangeTo` `..end` contains all values with `x < end`.\n/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n///\n/// # Examples\n///\n/// The `..end` syntax is a `RangeTo`:\n///\n/// ```\n/// assert_eq!((..5), std::ops::RangeTo { end: 5 });\n/// ```\n///\n/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n/// a `for` loop directly. This won't compile:\n///\n/// ```compile_fail,E0277\n/// // error[E0277]: the trait bound `std::ops::RangeTo<{integer}>:\n/// // std::iter::Iterator` is not satisfied\n/// for i in ..5 {\n///     // ...\n/// }\n/// ```\n///\n/// When used as a [slicing index], `RangeTo` produces a slice of all array\n/// elements before the index indicated by `end`.\n///\n/// ```\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n/// assert_eq!(arr[ .. 3], [0, 1, 2      ]); // This is a `RangeTo`\n/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n/// ```\n///\n/// [slicing index]: crate::slice::SliceIndex\n#[lang = \"RangeTo\"]\n#[doc(alias = \"..\")]\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RangeTo<Idx> {\n    /// The upper bound of the range (exclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub end: Idx,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(fmt, \"..\")?;\n        self.end.fmt(fmt)?;\n        Ok(())\n    }\n}\n\nimpl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!( (..5).contains(&-1_000_000_000));\n    /// assert!( (..5).contains(&4));\n    /// assert!(!(..5).contains(&5));\n    ///\n    /// assert!( (..1.0).contains(&0.5));\n    /// assert!(!(..1.0).contains(&f32::NAN));\n    /// assert!(!(..f32::NAN).contains(&0.5));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n        <Self as RangeBounds<Idx>>::contains(self, item)\n    }\n}\n\n/// A range bounded inclusively below and above (`start..=end`).\n///\n/// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n/// and `x <= end`. It is empty unless `start <= end`.\n///\n/// This iterator is [fused], but the specific values of `start` and `end` after\n/// iteration has finished are **unspecified** other than that [`.is_empty()`]\n/// will return `true` once no more values will be produced.\n///\n/// [fused]: crate::iter::FusedIterator\n/// [`.is_empty()`]: RangeInclusive::is_empty\n///\n/// # Examples\n///\n/// The `start..=end` syntax is a `RangeInclusive`:\n///\n/// ```\n/// assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n/// assert_eq!(3 + 4 + 5, (3..=5).sum());\n/// ```\n///\n/// ```\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n/// assert_eq!(arr[1..=3], [   1, 2, 3   ]); // This is a `RangeInclusive`\n/// ```\n#[lang = \"RangeInclusive\"]\n#[doc(alias = \"..=\")]\n#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\npub struct RangeInclusive<Idx> {\n    // Note that the fields here are not public to allow changing the\n    // representation in the future; in particular, while we could plausibly\n    // expose start/end, modifying them without changing (future/current)\n    // private fields may lead to incorrect behavior, so we don't want to\n    // support that mode.\n    pub(crate) start: Idx,\n    pub(crate) end: Idx,\n\n    // This field is:\n    //  - `false` upon construction\n    //  - `false` when iteration has yielded an element and the iterator is not exhausted\n    //  - `true` when iteration has been used to exhaust the iterator\n    //\n    // This is required to support PartialEq and Hash without a PartialOrd bound or specialization.\n    pub(crate) exhausted: bool,\n}\n\nimpl<Idx> RangeInclusive<Idx> {\n    /// Creates a new inclusive range. Equivalent to writing `start..=end`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ops::RangeInclusive;\n    ///\n    /// assert_eq!(3..=5, RangeInclusive::new(3, 5));\n    /// ```\n    #[lang = \"range_inclusive_new\"]\n    #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n    #[inline]\n    #[rustc_promotable]\n    #[rustc_const_stable(feature = \"const_range_new\", since = \"1.32.0\")]\n    pub const fn new(start: Idx, end: Idx) -> Self {\n        Self { start, end, exhausted: false }\n    }\n\n    /// Returns the lower bound of the range (inclusive).\n    ///\n    /// When using an inclusive range for iteration, the values of `start()` and\n    /// [`end()`] are unspecified after the iteration ended. To determine\n    /// whether the inclusive range is empty, use the [`is_empty()`] method\n    /// instead of comparing `start() > end()`.\n    ///\n    /// Note: the value returned by this method is unspecified after the range\n    /// has been iterated to exhaustion.\n    ///\n    /// [`end()`]: RangeInclusive::end\n    /// [`is_empty()`]: RangeInclusive::is_empty\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!((3..=5).start(), &3);\n    /// ```\n    #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n    #[rustc_const_stable(feature = \"const_inclusive_range_methods\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn start(&self) -> &Idx {\n        &self.start\n    }\n\n    /// Returns the upper bound of the range (inclusive).\n    ///\n    /// When using an inclusive range for iteration, the values of [`start()`]\n    /// and `end()` are unspecified after the iteration ended. To determine\n    /// whether the inclusive range is empty, use the [`is_empty()`] method\n    /// instead of comparing `start() > end()`.\n    ///\n    /// Note: the value returned by this method is unspecified after the range\n    /// has been iterated to exhaustion.\n    ///\n    /// [`start()`]: RangeInclusive::start\n    /// [`is_empty()`]: RangeInclusive::is_empty\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!((3..=5).end(), &5);\n    /// ```\n    #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n    #[rustc_const_stable(feature = \"const_inclusive_range_methods\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn end(&self) -> &Idx {\n        &self.end\n    }\n\n    /// Destructures the `RangeInclusive` into (lower bound, upper (inclusive) bound).\n    ///\n    /// Note: the value returned by this method is unspecified after the range\n    /// has been iterated to exhaustion.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!((3..=5).into_inner(), (3, 5));\n    /// ```\n    #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n    #[inline]\n    pub fn into_inner(self) -> (Idx, Idx) {\n        (self.start, self.end)\n    }\n}\n\nimpl RangeInclusive<usize> {\n    /// Converts to an exclusive `Range` for `SliceIndex` implementations.\n    /// The caller is responsible for dealing with `end == usize::MAX`.\n    #[inline]\n    pub(crate) fn into_slice_range(self) -> Range<usize> {\n        // If we're not exhausted, we want to simply slice `start..end + 1`.\n        // If we are exhausted, then slicing with `end + 1..end + 1` gives us an\n        // empty range that is still subject to bounds-checks for that endpoint.\n        let exclusive_end = self.end + 1;\n        let start = if self.exhausted { exclusive_end } else { self.start };\n        start..exclusive_end\n    }\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.start.fmt(fmt)?;\n        write!(fmt, \"..=\")?;\n        self.end.fmt(fmt)?;\n        if self.exhausted {\n            write!(fmt, \" (exhausted)\")?;\n        }\n        Ok(())\n    }\n}\n\nimpl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!(!(3..=5).contains(&2));\n    /// assert!( (3..=5).contains(&3));\n    /// assert!( (3..=5).contains(&4));\n    /// assert!( (3..=5).contains(&5));\n    /// assert!(!(3..=5).contains(&6));\n    ///\n    /// assert!( (3..=3).contains(&3));\n    /// assert!(!(3..=2).contains(&3));\n    ///\n    /// assert!( (0.0..=1.0).contains(&1.0));\n    /// assert!(!(0.0..=1.0).contains(&f32::NAN));\n    /// assert!(!(0.0..=f32::NAN).contains(&0.0));\n    /// assert!(!(f32::NAN..=1.0).contains(&1.0));\n    /// ```\n    ///\n    /// This method always returns `false` after iteration has finished:\n    ///\n    /// ```\n    /// let mut r = 3..=5;\n    /// assert!(r.contains(&3) && r.contains(&5));\n    /// for _ in r.by_ref() {}\n    /// // Precise field values are unspecified here\n    /// assert!(!r.contains(&3) && !r.contains(&5));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n        <Self as RangeBounds<Idx>>::contains(self, item)\n    }\n\n    /// Returns `true` if the range contains no items.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!(!(3..=5).is_empty());\n    /// assert!(!(3..=3).is_empty());\n    /// assert!( (3..=2).is_empty());\n    /// ```\n    ///\n    /// The range is empty if either side is incomparable:\n    ///\n    /// ```\n    /// assert!(!(3.0..=5.0).is_empty());\n    /// assert!( (3.0..=f32::NAN).is_empty());\n    /// assert!( (f32::NAN..=5.0).is_empty());\n    /// ```\n    ///\n    /// This method returns `true` after iteration has finished:\n    ///\n    /// ```\n    /// let mut r = 3..=5;\n    /// for _ in r.by_ref() {}\n    /// // Precise field values are unspecified here\n    /// assert!(r.is_empty());\n    /// ```\n    #[stable(feature = \"range_is_empty\", since = \"1.47.0\")]\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.exhausted || !(self.start <= self.end)\n    }\n}\n\n/// A range only bounded inclusively above (`..=end`).\n///\n/// The `RangeToInclusive` `..=end` contains all values with `x <= end`.\n/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n///\n/// # Examples\n///\n/// The `..=end` syntax is a `RangeToInclusive`:\n///\n/// ```\n/// assert_eq!((..=5), std::ops::RangeToInclusive{ end: 5 });\n/// ```\n///\n/// It does not have an [`IntoIterator`] implementation, so you can't use it in a\n/// `for` loop directly. This won't compile:\n///\n/// ```compile_fail,E0277\n/// // error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:\n/// // std::iter::Iterator` is not satisfied\n/// for i in ..=5 {\n///     // ...\n/// }\n/// ```\n///\n/// When used as a [slicing index], `RangeToInclusive` produces a slice of all\n/// array elements up to and including the index indicated by `end`.\n///\n/// ```\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]); // This is a `RangeToInclusive`\n/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n/// ```\n///\n/// [slicing index]: crate::slice::SliceIndex\n#[lang = \"RangeToInclusive\"]\n#[doc(alias = \"..=\")]\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\npub struct RangeToInclusive<Idx> {\n    /// The upper bound of the range (inclusive)\n    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n    pub end: Idx,\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(fmt, \"..=\")?;\n        self.end.fmt(fmt)?;\n        Ok(())\n    }\n}\n\nimpl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!( (..=5).contains(&-1_000_000_000));\n    /// assert!( (..=5).contains(&5));\n    /// assert!(!(..=5).contains(&6));\n    ///\n    /// assert!( (..=1.0).contains(&1.0));\n    /// assert!(!(..=1.0).contains(&f32::NAN));\n    /// assert!(!(..=f32::NAN).contains(&0.5));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n        <Self as RangeBounds<Idx>>::contains(self, item)\n    }\n}\n\n// RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n// because underflow would be possible with (..0).into()\n\n/// An endpoint of a range of keys.\n///\n/// # Examples\n///\n/// `Bound`s are range endpoints:\n///\n/// ```\n/// use std::ops::Bound::*;\n/// use std::ops::RangeBounds;\n///\n/// assert_eq!((..100).start_bound(), Unbounded);\n/// assert_eq!((1..12).start_bound(), Included(&1));\n/// assert_eq!((1..12).end_bound(), Excluded(&12));\n/// ```\n///\n/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n///\n/// ```\n/// use std::collections::BTreeMap;\n/// use std::ops::Bound::{Excluded, Included, Unbounded};\n///\n/// let mut map = BTreeMap::new();\n/// map.insert(3, \"a\");\n/// map.insert(5, \"b\");\n/// map.insert(8, \"c\");\n///\n/// for (key, value) in map.range((Excluded(3), Included(8))) {\n///     println!(\"{}: {}\", key, value);\n/// }\n///\n/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n/// ```\n///\n/// [`BTreeMap::range`]: ../../std/collections/btree_map/struct.BTreeMap.html#method.range\n#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\npub enum Bound<T> {\n    /// An inclusive bound.\n    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n    Included(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n    /// An exclusive bound.\n    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n    Excluded(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n    /// An infinite endpoint. Indicates that there is no bound in this direction.\n    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n    Unbounded,\n}\n\nimpl<T> Bound<T> {\n    /// Converts from `&Bound<T>` to `Bound<&T>`.\n    #[inline]\n    #[unstable(feature = \"bound_as_ref\", issue = \"80996\")]\n    pub fn as_ref(&self) -> Bound<&T> {\n        match *self {\n            Included(ref x) => Included(x),\n            Excluded(ref x) => Excluded(x),\n            Unbounded => Unbounded,\n        }\n    }\n\n    /// Converts from `&mut Bound<T>` to `Bound<&mut T>`.\n    #[inline]\n    #[unstable(feature = \"bound_as_ref\", issue = \"80996\")]\n    pub fn as_mut(&mut self) -> Bound<&mut T> {\n        match *self {\n            Included(ref mut x) => Included(x),\n            Excluded(ref mut x) => Excluded(x),\n            Unbounded => Unbounded,\n        }\n    }\n\n    /// Maps a `Bound<T>` to a `Bound<U>` by applying a function to the contained value (including\n    /// both `Included` and `Excluded`), returning a `Bound` of the same kind.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(bound_map)]\n    /// use std::ops::Bound::*;\n    ///\n    /// let bound_string = Included(\"Hello, World!\");\n    ///\n    /// assert_eq!(bound_string.map(|s| s.len()), Included(13));\n    /// ```\n    ///\n    /// ```\n    /// #![feature(bound_map)]\n    /// use std::ops::Bound;\n    /// use Bound::*;\n    ///\n    /// let unbounded_string: Bound<String> = Unbounded;\n    ///\n    /// assert_eq!(unbounded_string.map(|s| s.len()), Unbounded);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"bound_map\", issue = \"86026\")]\n    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Bound<U> {\n        match self {\n            Unbounded => Unbounded,\n            Included(x) => Included(f(x)),\n            Excluded(x) => Excluded(f(x)),\n        }\n    }\n}\n\nimpl<T: Clone> Bound<&T> {\n    /// Map a `Bound<&T>` to a `Bound<T>` by cloning the contents of the bound.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(bound_cloned)]\n    /// use std::ops::Bound::*;\n    /// use std::ops::RangeBounds;\n    ///\n    /// assert_eq!((1..12).start_bound(), Included(&1));\n    /// assert_eq!((1..12).start_bound().cloned(), Included(1));\n    /// ```\n    #[unstable(feature = \"bound_cloned\", issue = \"61356\")]\n    pub fn cloned(self) -> Bound<T> {\n        match self {\n            Bound::Unbounded => Bound::Unbounded,\n            Bound::Included(x) => Bound::Included(x.clone()),\n            Bound::Excluded(x) => Bound::Excluded(x.clone()),\n        }\n    }\n}\n\n/// `RangeBounds` is implemented by Rust's built-in range types, produced\n/// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\npub trait RangeBounds<T: ?Sized> {\n    /// Start index bound.\n    ///\n    /// Returns the start value as a `Bound`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// use std::ops::Bound::*;\n    /// use std::ops::RangeBounds;\n    ///\n    /// assert_eq!((..10).start_bound(), Unbounded);\n    /// assert_eq!((3..10).start_bound(), Included(&3));\n    /// # }\n    /// ```\n    #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n    fn start_bound(&self) -> Bound<&T>;\n\n    /// End index bound.\n    ///\n    /// Returns the end value as a `Bound`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// use std::ops::Bound::*;\n    /// use std::ops::RangeBounds;\n    ///\n    /// assert_eq!((3..).end_bound(), Unbounded);\n    /// assert_eq!((3..10).end_bound(), Excluded(&10));\n    /// # }\n    /// ```\n    #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n    fn end_bound(&self) -> Bound<&T>;\n\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!( (3..5).contains(&4));\n    /// assert!(!(3..5).contains(&2));\n    ///\n    /// assert!( (0.0..1.0).contains(&0.5));\n    /// assert!(!(0.0..1.0).contains(&f32::NAN));\n    /// assert!(!(0.0..f32::NAN).contains(&0.5));\n    /// assert!(!(f32::NAN..1.0).contains(&0.5));\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    fn contains<U>(&self, item: &U) -> bool\n    where\n        T: PartialOrd<U>,\n        U: ?Sized + PartialOrd<T>,\n    {\n        (match self.start_bound() {\n            Included(ref start) => *start <= item,\n            Excluded(ref start) => *start < item,\n            Unbounded => true,\n        }) && (match self.end_bound() {\n            Included(ref end) => item <= *end,\n            Excluded(ref end) => item < *end,\n            Unbounded => true,\n        })\n    }\n}\n\nuse self::Bound::{Excluded, Included, Unbounded};\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T: ?Sized> RangeBounds<T> for RangeFull {\n    fn start_bound(&self) -> Bound<&T> {\n        Unbounded\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Unbounded\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeFrom<T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Included(&self.start)\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Unbounded\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeTo<T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Unbounded\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Excluded(&self.end)\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for Range<T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Included(&self.start)\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Excluded(&self.end)\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeInclusive<T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Included(&self.start)\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        if self.exhausted {\n            // When the iterator is exhausted, we usually have start == end,\n            // but we want the range to appear empty, containing nothing.\n            Excluded(&self.end)\n        } else {\n            Included(&self.end)\n        }\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeToInclusive<T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Unbounded\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Included(&self.end)\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n    fn start_bound(&self) -> Bound<&T> {\n        match *self {\n            (Included(ref start), _) => Included(start),\n            (Excluded(ref start), _) => Excluded(start),\n            (Unbounded, _) => Unbounded,\n        }\n    }\n\n    fn end_bound(&self) -> Bound<&T> {\n        match *self {\n            (_, Included(ref end)) => Included(end),\n            (_, Excluded(ref end)) => Excluded(end),\n            (_, Unbounded) => Unbounded,\n        }\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n    fn start_bound(&self) -> Bound<&T> {\n        self.0\n    }\n\n    fn end_bound(&self) -> Bound<&T> {\n        self.1\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeFrom<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Included(self.start)\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Unbounded\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeTo<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Unbounded\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Excluded(self.end)\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for Range<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Included(self.start)\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Excluded(self.end)\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeInclusive<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Included(self.start)\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Included(self.end)\n    }\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeToInclusive<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n        Unbounded\n    }\n    fn end_bound(&self) -> Bound<&T> {\n        Included(self.end)\n    }\n}\n"],[2821,"use crate::marker::Unpin;\nuse crate::pin::Pin;\n\n/// The result of a generator resumption.\n///\n/// This enum is returned from the `Generator::resume` method and indicates the\n/// possible return values of a generator. Currently this corresponds to either\n/// a suspension point (`Yielded`) or a termination point (`Complete`).\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[lang = \"generator_state\"]\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\npub enum GeneratorState<Y, R> {\n    /// The generator suspended with a value.\n    ///\n    /// This state indicates that a generator has been suspended, and typically\n    /// corresponds to a `yield` statement. The value provided in this variant\n    /// corresponds to the expression passed to `yield` and allows generators to\n    /// provide a value each time they yield.\n    Yielded(Y),\n\n    /// The generator completed with a return value.\n    ///\n    /// This state indicates that a generator has finished execution with the\n    /// provided value. Once a generator has returned `Complete` it is\n    /// considered a programmer error to call `resume` again.\n    Complete(R),\n}\n\n/// The trait implemented by builtin generator types.\n///\n/// Generators, also commonly referred to as coroutines, are currently an\n/// experimental language feature in Rust. Added in [RFC 2033] generators are\n/// currently intended to primarily provide a building block for async/await\n/// syntax but will likely extend to also providing an ergonomic definition for\n/// iterators and other primitives.\n///\n/// The syntax and semantics for generators is unstable and will require a\n/// further RFC for stabilization. At this time, though, the syntax is\n/// closure-like:\n///\n/// ```rust\n/// #![feature(generators, generator_trait)]\n///\n/// use std::ops::{Generator, GeneratorState};\n/// use std::pin::Pin;\n///\n/// fn main() {\n///     let mut generator = || {\n///         yield 1;\n///         return \"foo\"\n///     };\n///\n///     match Pin::new(&mut generator).resume(()) {\n///         GeneratorState::Yielded(1) => {}\n///         _ => panic!(\"unexpected return from resume\"),\n///     }\n///     match Pin::new(&mut generator).resume(()) {\n///         GeneratorState::Complete(\"foo\") => {}\n///         _ => panic!(\"unexpected return from resume\"),\n///     }\n/// }\n/// ```\n///\n/// More documentation of generators can be found in the unstable book.\n///\n/// [RFC 2033]: https://github.com/rust-lang/rfcs/pull/2033\n#[lang = \"generator\"]\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n#[fundamental]\npub trait Generator<R = ()> {\n    /// The type of value this generator yields.\n    ///\n    /// This associated type corresponds to the `yield` expression and the\n    /// values which are allowed to be returned each time a generator yields.\n    /// For example an iterator-as-a-generator would likely have this type as\n    /// `T`, the type being iterated over.\n    type Yield;\n\n    /// The type of value this generator returns.\n    ///\n    /// This corresponds to the type returned from a generator either with a\n    /// `return` statement or implicitly as the last expression of a generator\n    /// literal. For example futures would use this as `Result<T, E>` as it\n    /// represents a completed future.\n    type Return;\n\n    /// Resumes the execution of this generator.\n    ///\n    /// This function will resume execution of the generator or start execution\n    /// if it hasn't already. This call will return back into the generator's\n    /// last suspension point, resuming execution from the latest `yield`. The\n    /// generator will continue executing until it either yields or returns, at\n    /// which point this function will return.\n    ///\n    /// # Return value\n    ///\n    /// The `GeneratorState` enum returned from this function indicates what\n    /// state the generator is in upon returning. If the `Yielded` variant is\n    /// returned then the generator has reached a suspension point and a value\n    /// has been yielded out. Generators in this state are available for\n    /// resumption at a later point.\n    ///\n    /// If `Complete` is returned then the generator has completely finished\n    /// with the value provided. It is invalid for the generator to be resumed\n    /// again.\n    ///\n    /// # Panics\n    ///\n    /// This function may panic if it is called after the `Complete` variant has\n    /// been returned previously. While generator literals in the language are\n    /// guaranteed to panic on resuming after `Complete`, this is not guaranteed\n    /// for all implementations of the `Generator` trait.\n    fn resume(self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return>;\n}\n\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\nimpl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<&mut G> {\n    type Yield = G::Yield;\n    type Return = G::Return;\n\n    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n        G::resume((*self).as_mut(), arg)\n    }\n}\n\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\nimpl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for &mut G {\n    type Yield = G::Yield;\n    type Return = G::Return;\n\n    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n        G::resume(Pin::new(&mut *self), arg)\n    }\n}\n"],[2822,"/// The unary logical negation operator `!`.\n///\n/// # Examples\n///\n/// An implementation of `Not` for `Answer`, which enables the use of `!` to\n/// invert its value.\n///\n/// ```\n/// use std::ops::Not;\n///\n/// #[derive(Debug, PartialEq)]\n/// enum Answer {\n///     Yes,\n///     No,\n/// }\n///\n/// impl Not for Answer {\n///     type Output = Self;\n///\n///     fn not(self) -> Self::Output {\n///         match self {\n///             Answer::Yes => Answer::No,\n///             Answer::No => Answer::Yes\n///         }\n///     }\n/// }\n///\n/// assert_eq!(!Answer::Yes, Answer::No);\n/// assert_eq!(!Answer::No, Answer::Yes);\n/// ```\n#[lang = \"not\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Not {\n    /// The resulting type after applying the `!` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the unary `!` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(!true, false);\n    /// assert_eq!(!false, true);\n    /// assert_eq!(!1u8, 254);\n    /// assert_eq!(!0u8, 255);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn not(self) -> Self::Output;\n}\n\nmacro_rules! not_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Not for $t {\n            type Output = $t;\n\n            #[inline]\n            fn not(self) -> $t { !self }\n        }\n\n        forward_ref_unop! { impl Not, not for $t }\n    )*)\n}\n\nnot_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise AND operator `&`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// An implementation of `BitAnd` for a wrapper around `bool`.\n///\n/// ```\n/// use std::ops::BitAnd;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(bool);\n///\n/// impl BitAnd for Scalar {\n///     type Output = Self;\n///\n///     // rhs is the \"right-hand side\" of the expression `a & b`\n///     fn bitand(self, rhs: Self) -> Self::Output {\n///         Self(self.0 & rhs.0)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n/// assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n/// assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n/// assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n/// ```\n///\n/// An implementation of `BitAnd` for a wrapper around `Vec<bool>`.\n///\n/// ```\n/// use std::ops::BitAnd;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct BooleanVector(Vec<bool>);\n///\n/// impl BitAnd for BooleanVector {\n///     type Output = Self;\n///\n///     fn bitand(self, Self(rhs): Self) -> Self::Output {\n///         let Self(lhs) = self;\n///         assert_eq!(lhs.len(), rhs.len());\n///         Self(\n///             lhs.iter()\n///                 .zip(rhs.iter())\n///                 .map(|(x, y)| *x & *y)\n///                 .collect()\n///         )\n///     }\n/// }\n///\n/// let bv1 = BooleanVector(vec![true, true, false, false]);\n/// let bv2 = BooleanVector(vec![true, false, true, false]);\n/// let expected = BooleanVector(vec![true, false, false, false]);\n/// assert_eq!(bv1 & bv2, expected);\n/// ```\n#[lang = \"bitand\"]\n#[doc(alias = \"&\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} & {Rhs}`\",\n    label = \"no implementation for `{Self} & {Rhs}`\"\n)]\npub trait BitAnd<Rhs = Self> {\n    /// The resulting type after applying the `&` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `&` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(true & false, false);\n    /// assert_eq!(true & true, true);\n    /// assert_eq!(5u8 & 1u8, 1);\n    /// assert_eq!(5u8 & 2u8, 0);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bitand(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! bitand_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitAnd for $t {\n            type Output = $t;\n\n            #[inline]\n            fn bitand(self, rhs: $t) -> $t { self & rhs }\n        }\n\n        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n    )*)\n}\n\nbitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise OR operator `|`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// An implementation of `BitOr` for a wrapper around `bool`.\n///\n/// ```\n/// use std::ops::BitOr;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(bool);\n///\n/// impl BitOr for Scalar {\n///     type Output = Self;\n///\n///     // rhs is the \"right-hand side\" of the expression `a | b`\n///     fn bitor(self, rhs: Self) -> Self::Output {\n///         Self(self.0 | rhs.0)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n/// assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n/// assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n/// assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n/// ```\n///\n/// An implementation of `BitOr` for a wrapper around `Vec<bool>`.\n///\n/// ```\n/// use std::ops::BitOr;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct BooleanVector(Vec<bool>);\n///\n/// impl BitOr for BooleanVector {\n///     type Output = Self;\n///\n///     fn bitor(self, Self(rhs): Self) -> Self::Output {\n///         let Self(lhs) = self;\n///         assert_eq!(lhs.len(), rhs.len());\n///         Self(\n///             lhs.iter()\n///                 .zip(rhs.iter())\n///                 .map(|(x, y)| *x | *y)\n///                 .collect()\n///         )\n///     }\n/// }\n///\n/// let bv1 = BooleanVector(vec![true, true, false, false]);\n/// let bv2 = BooleanVector(vec![true, false, true, false]);\n/// let expected = BooleanVector(vec![true, true, true, false]);\n/// assert_eq!(bv1 | bv2, expected);\n/// ```\n#[lang = \"bitor\"]\n#[doc(alias = \"|\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} | {Rhs}`\",\n    label = \"no implementation for `{Self} | {Rhs}`\"\n)]\npub trait BitOr<Rhs = Self> {\n    /// The resulting type after applying the `|` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `|` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(true | false, true);\n    /// assert_eq!(false | false, false);\n    /// assert_eq!(5u8 | 1u8, 5);\n    /// assert_eq!(5u8 | 2u8, 7);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bitor(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! bitor_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitOr for $t {\n            type Output = $t;\n\n            #[inline]\n            fn bitor(self, rhs: $t) -> $t { self | rhs }\n        }\n\n        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n    )*)\n}\n\nbitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise XOR operator `^`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// An implementation of `BitXor` that lifts `^` to a wrapper around `bool`.\n///\n/// ```\n/// use std::ops::BitXor;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(bool);\n///\n/// impl BitXor for Scalar {\n///     type Output = Self;\n///\n///     // rhs is the \"right-hand side\" of the expression `a ^ b`\n///     fn bitxor(self, rhs: Self) -> Self::Output {\n///         Self(self.0 ^ rhs.0)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n/// assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n/// assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n/// assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n/// ```\n///\n/// An implementation of `BitXor` trait for a wrapper around `Vec<bool>`.\n///\n/// ```\n/// use std::ops::BitXor;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct BooleanVector(Vec<bool>);\n///\n/// impl BitXor for BooleanVector {\n///     type Output = Self;\n///\n///     fn bitxor(self, Self(rhs): Self) -> Self::Output {\n///         let Self(lhs) = self;\n///         assert_eq!(lhs.len(), rhs.len());\n///         Self(\n///             lhs.iter()\n///                 .zip(rhs.iter())\n///                 .map(|(x, y)| *x ^ *y)\n///                 .collect()\n///         )\n///     }\n/// }\n///\n/// let bv1 = BooleanVector(vec![true, true, false, false]);\n/// let bv2 = BooleanVector(vec![true, false, true, false]);\n/// let expected = BooleanVector(vec![false, true, true, false]);\n/// assert_eq!(bv1 ^ bv2, expected);\n/// ```\n#[lang = \"bitxor\"]\n#[doc(alias = \"^\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} ^ {Rhs}`\",\n    label = \"no implementation for `{Self} ^ {Rhs}`\"\n)]\npub trait BitXor<Rhs = Self> {\n    /// The resulting type after applying the `^` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `^` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(true ^ false, true);\n    /// assert_eq!(true ^ true, false);\n    /// assert_eq!(5u8 ^ 1u8, 4);\n    /// assert_eq!(5u8 ^ 2u8, 7);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bitxor(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! bitxor_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitXor for $t {\n            type Output = $t;\n\n            #[inline]\n            fn bitxor(self, other: $t) -> $t { self ^ other }\n        }\n\n        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n    )*)\n}\n\nbitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The left shift operator `<<`. Note that because this trait is implemented\n/// for all integer types with multiple right-hand-side types, Rust's type\n/// checker has special handling for `_ << _`, setting the result type for\n/// integer operations to the type of the left-hand-side operand. This means\n/// that though `a << b` and `a.shl(b)` are one and the same from an evaluation\n/// standpoint, they are different when it comes to type inference.\n///\n/// # Examples\n///\n/// An implementation of `Shl` that lifts the `<<` operation on integers to a\n/// wrapper around `usize`.\n///\n/// ```\n/// use std::ops::Shl;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct Scalar(usize);\n///\n/// impl Shl<Scalar> for Scalar {\n///     type Output = Self;\n///\n///     fn shl(self, Self(rhs): Self) -> Self::Output {\n///         let Self(lhs) = self;\n///         Self(lhs << rhs)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n/// ```\n///\n/// An implementation of `Shl` that spins a vector leftward by a given amount.\n///\n/// ```\n/// use std::ops::Shl;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct SpinVector<T: Clone> {\n///     vec: Vec<T>,\n/// }\n///\n/// impl<T: Clone> Shl<usize> for SpinVector<T> {\n///     type Output = Self;\n///\n///     fn shl(self, rhs: usize) -> Self::Output {\n///         // Rotate the vector by `rhs` places.\n///         let (a, b) = self.vec.split_at(rhs);\n///         let mut spun_vector = vec![];\n///         spun_vector.extend_from_slice(b);\n///         spun_vector.extend_from_slice(a);\n///         Self { vec: spun_vector }\n///     }\n/// }\n///\n/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n///            SpinVector { vec: vec![2, 3, 4, 0, 1] });\n/// ```\n#[lang = \"shl\"]\n#[doc(alias = \"<<\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} << {Rhs}`\",\n    label = \"no implementation for `{Self} << {Rhs}`\"\n)]\npub trait Shl<Rhs = Self> {\n    /// The resulting type after applying the `<<` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `<<` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(5u8 << 1, 10);\n    /// assert_eq!(1u8 << 1, 2);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn shl(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! shl_impl {\n    ($t:ty, $f:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shl<$f> for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn shl(self, other: $f) -> $t {\n                self << other\n            }\n        }\n\n        forward_ref_binop! { impl Shl, shl for $t, $f }\n    };\n}\n\nmacro_rules! shl_impl_all {\n    ($($t:ty)*) => ($(\n        shl_impl! { $t, u8 }\n        shl_impl! { $t, u16 }\n        shl_impl! { $t, u32 }\n        shl_impl! { $t, u64 }\n        shl_impl! { $t, u128 }\n        shl_impl! { $t, usize }\n\n        shl_impl! { $t, i8 }\n        shl_impl! { $t, i16 }\n        shl_impl! { $t, i32 }\n        shl_impl! { $t, i64 }\n        shl_impl! { $t, i128 }\n        shl_impl! { $t, isize }\n    )*)\n}\n\nshl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n\n/// The right shift operator `>>`. Note that because this trait is implemented\n/// for all integer types with multiple right-hand-side types, Rust's type\n/// checker has special handling for `_ >> _`, setting the result type for\n/// integer operations to the type of the left-hand-side operand. This means\n/// that though `a >> b` and `a.shr(b)` are one and the same from an evaluation\n/// standpoint, they are different when it comes to type inference.\n///\n/// # Examples\n///\n/// An implementation of `Shr` that lifts the `>>` operation on integers to a\n/// wrapper around `usize`.\n///\n/// ```\n/// use std::ops::Shr;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct Scalar(usize);\n///\n/// impl Shr<Scalar> for Scalar {\n///     type Output = Self;\n///\n///     fn shr(self, Self(rhs): Self) -> Self::Output {\n///         let Self(lhs) = self;\n///         Self(lhs >> rhs)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n/// ```\n///\n/// An implementation of `Shr` that spins a vector rightward by a given amount.\n///\n/// ```\n/// use std::ops::Shr;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct SpinVector<T: Clone> {\n///     vec: Vec<T>,\n/// }\n///\n/// impl<T: Clone> Shr<usize> for SpinVector<T> {\n///     type Output = Self;\n///\n///     fn shr(self, rhs: usize) -> Self::Output {\n///         // Rotate the vector by `rhs` places.\n///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n///         let mut spun_vector = vec![];\n///         spun_vector.extend_from_slice(b);\n///         spun_vector.extend_from_slice(a);\n///         Self { vec: spun_vector }\n///     }\n/// }\n///\n/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n///            SpinVector { vec: vec![3, 4, 0, 1, 2] });\n/// ```\n#[lang = \"shr\"]\n#[doc(alias = \">>\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} >> {Rhs}`\",\n    label = \"no implementation for `{Self} >> {Rhs}`\"\n)]\npub trait Shr<Rhs = Self> {\n    /// The resulting type after applying the `>>` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `>>` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(5u8 >> 1, 2);\n    /// assert_eq!(2u8 >> 1, 1);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn shr(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! shr_impl {\n    ($t:ty, $f:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shr<$f> for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn shr(self, other: $f) -> $t {\n                self >> other\n            }\n        }\n\n        forward_ref_binop! { impl Shr, shr for $t, $f }\n    };\n}\n\nmacro_rules! shr_impl_all {\n    ($($t:ty)*) => ($(\n        shr_impl! { $t, u8 }\n        shr_impl! { $t, u16 }\n        shr_impl! { $t, u32 }\n        shr_impl! { $t, u64 }\n        shr_impl! { $t, u128 }\n        shr_impl! { $t, usize }\n\n        shr_impl! { $t, i8 }\n        shr_impl! { $t, i16 }\n        shr_impl! { $t, i32 }\n        shr_impl! { $t, i64 }\n        shr_impl! { $t, i128 }\n        shr_impl! { $t, isize }\n    )*)\n}\n\nshr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n\n/// The bitwise AND assignment operator `&=`.\n///\n/// # Examples\n///\n/// An implementation of `BitAndAssign` that lifts the `&=` operator to a\n/// wrapper around `bool`.\n///\n/// ```\n/// use std::ops::BitAndAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(bool);\n///\n/// impl BitAndAssign for Scalar {\n///     // rhs is the \"right-hand side\" of the expression `a &= b`\n///     fn bitand_assign(&mut self, rhs: Self) {\n///         *self = Self(self.0 & rhs.0)\n///     }\n/// }\n///\n/// let mut scalar = Scalar(true);\n/// scalar &= Scalar(true);\n/// assert_eq!(scalar, Scalar(true));\n///\n/// let mut scalar = Scalar(true);\n/// scalar &= Scalar(false);\n/// assert_eq!(scalar, Scalar(false));\n///\n/// let mut scalar = Scalar(false);\n/// scalar &= Scalar(true);\n/// assert_eq!(scalar, Scalar(false));\n///\n/// let mut scalar = Scalar(false);\n/// scalar &= Scalar(false);\n/// assert_eq!(scalar, Scalar(false));\n/// ```\n///\n/// Here, the `BitAndAssign` trait is implemented for a wrapper around\n/// `Vec<bool>`.\n///\n/// ```\n/// use std::ops::BitAndAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct BooleanVector(Vec<bool>);\n///\n/// impl BitAndAssign for BooleanVector {\n///     // `rhs` is the \"right-hand side\" of the expression `a &= b`.\n///     fn bitand_assign(&mut self, rhs: Self) {\n///         assert_eq!(self.0.len(), rhs.0.len());\n///         *self = Self(\n///             self.0\n///                 .iter()\n///                 .zip(rhs.0.iter())\n///                 .map(|(x, y)| *x & *y)\n///                 .collect()\n///         );\n///     }\n/// }\n///\n/// let mut bv = BooleanVector(vec![true, true, false, false]);\n/// bv &= BooleanVector(vec![true, false, true, false]);\n/// let expected = BooleanVector(vec![true, false, false, false]);\n/// assert_eq!(bv, expected);\n/// ```\n#[lang = \"bitand_assign\"]\n#[doc(alias = \"&=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} &= {Rhs}`\",\n    label = \"no implementation for `{Self} &= {Rhs}`\"\n)]\npub trait BitAndAssign<Rhs = Self> {\n    /// Performs the `&=` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = true;\n    /// x &= false;\n    /// assert_eq!(x, false);\n    ///\n    /// let mut x = true;\n    /// x &= true;\n    /// assert_eq!(x, true);\n    ///\n    /// let mut x: u8 = 5;\n    /// x &= 1;\n    /// assert_eq!(x, 1);\n    ///\n    /// let mut x: u8 = 5;\n    /// x &= 2;\n    /// assert_eq!(x, 0);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn bitand_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! bitand_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitAndAssign for $t {\n            #[inline]\n            fn bitand_assign(&mut self, other: $t) { *self &= other }\n        }\n\n        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for $t, $t }\n    )+)\n}\n\nbitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise OR assignment operator `|=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::BitOrAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct PersonalPreferences {\n///     likes_cats: bool,\n///     likes_dogs: bool,\n/// }\n///\n/// impl BitOrAssign for PersonalPreferences {\n///     fn bitor_assign(&mut self, rhs: Self) {\n///         self.likes_cats |= rhs.likes_cats;\n///         self.likes_dogs |= rhs.likes_dogs;\n///     }\n/// }\n///\n/// let mut prefs = PersonalPreferences { likes_cats: true, likes_dogs: false };\n/// prefs |= PersonalPreferences { likes_cats: false, likes_dogs: true };\n/// assert_eq!(prefs, PersonalPreferences { likes_cats: true, likes_dogs: true });\n/// ```\n#[lang = \"bitor_assign\"]\n#[doc(alias = \"|=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} |= {Rhs}`\",\n    label = \"no implementation for `{Self} |= {Rhs}`\"\n)]\npub trait BitOrAssign<Rhs = Self> {\n    /// Performs the `|=` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = true;\n    /// x |= false;\n    /// assert_eq!(x, true);\n    ///\n    /// let mut x = false;\n    /// x |= false;\n    /// assert_eq!(x, false);\n    ///\n    /// let mut x: u8 = 5;\n    /// x |= 1;\n    /// assert_eq!(x, 5);\n    ///\n    /// let mut x: u8 = 5;\n    /// x |= 2;\n    /// assert_eq!(x, 7);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn bitor_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! bitor_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitOrAssign for $t {\n            #[inline]\n            fn bitor_assign(&mut self, other: $t) { *self |= other }\n        }\n\n        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for $t, $t }\n    )+)\n}\n\nbitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise XOR assignment operator `^=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::BitXorAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Personality {\n///     has_soul: bool,\n///     likes_knitting: bool,\n/// }\n///\n/// impl BitXorAssign for Personality {\n///     fn bitxor_assign(&mut self, rhs: Self) {\n///         self.has_soul ^= rhs.has_soul;\n///         self.likes_knitting ^= rhs.likes_knitting;\n///     }\n/// }\n///\n/// let mut personality = Personality { has_soul: false, likes_knitting: true };\n/// personality ^= Personality { has_soul: true, likes_knitting: true };\n/// assert_eq!(personality, Personality { has_soul: true, likes_knitting: false});\n/// ```\n#[lang = \"bitxor_assign\"]\n#[doc(alias = \"^=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} ^= {Rhs}`\",\n    label = \"no implementation for `{Self} ^= {Rhs}`\"\n)]\npub trait BitXorAssign<Rhs = Self> {\n    /// Performs the `^=` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = true;\n    /// x ^= false;\n    /// assert_eq!(x, true);\n    ///\n    /// let mut x = true;\n    /// x ^= true;\n    /// assert_eq!(x, false);\n    ///\n    /// let mut x: u8 = 5;\n    /// x ^= 1;\n    /// assert_eq!(x, 4);\n    ///\n    /// let mut x: u8 = 5;\n    /// x ^= 2;\n    /// assert_eq!(x, 7);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn bitxor_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! bitxor_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitXorAssign for $t {\n            #[inline]\n            fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n        }\n\n        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for $t, $t }\n    )+)\n}\n\nbitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The left shift assignment operator `<<=`.\n///\n/// # Examples\n///\n/// An implementation of `ShlAssign` for a wrapper around `usize`.\n///\n/// ```\n/// use std::ops::ShlAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(usize);\n///\n/// impl ShlAssign<usize> for Scalar {\n///     fn shl_assign(&mut self, rhs: usize) {\n///         self.0 <<= rhs;\n///     }\n/// }\n///\n/// let mut scalar = Scalar(4);\n/// scalar <<= 2;\n/// assert_eq!(scalar, Scalar(16));\n/// ```\n#[lang = \"shl_assign\"]\n#[doc(alias = \"<<=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} <<= {Rhs}`\",\n    label = \"no implementation for `{Self} <<= {Rhs}`\"\n)]\npub trait ShlAssign<Rhs = Self> {\n    /// Performs the `<<=` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x: u8 = 5;\n    /// x <<= 1;\n    /// assert_eq!(x, 10);\n    ///\n    /// let mut x: u8 = 1;\n    /// x <<= 1;\n    /// assert_eq!(x, 2);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn shl_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! shl_assign_impl {\n    ($t:ty, $f:ty) => {\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShlAssign<$f> for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn shl_assign(&mut self, other: $f) {\n                *self <<= other\n            }\n        }\n\n        forward_ref_op_assign! { impl ShlAssign, shl_assign for $t, $f }\n    };\n}\n\nmacro_rules! shl_assign_impl_all {\n    ($($t:ty)*) => ($(\n        shl_assign_impl! { $t, u8 }\n        shl_assign_impl! { $t, u16 }\n        shl_assign_impl! { $t, u32 }\n        shl_assign_impl! { $t, u64 }\n        shl_assign_impl! { $t, u128 }\n        shl_assign_impl! { $t, usize }\n\n        shl_assign_impl! { $t, i8 }\n        shl_assign_impl! { $t, i16 }\n        shl_assign_impl! { $t, i32 }\n        shl_assign_impl! { $t, i64 }\n        shl_assign_impl! { $t, i128 }\n        shl_assign_impl! { $t, isize }\n    )*)\n}\n\nshl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n\n/// The right shift assignment operator `>>=`.\n///\n/// # Examples\n///\n/// An implementation of `ShrAssign` for a wrapper around `usize`.\n///\n/// ```\n/// use std::ops::ShrAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(usize);\n///\n/// impl ShrAssign<usize> for Scalar {\n///     fn shr_assign(&mut self, rhs: usize) {\n///         self.0 >>= rhs;\n///     }\n/// }\n///\n/// let mut scalar = Scalar(16);\n/// scalar >>= 2;\n/// assert_eq!(scalar, Scalar(4));\n/// ```\n#[lang = \"shr_assign\"]\n#[doc(alias = \">>=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} >>= {Rhs}`\",\n    label = \"no implementation for `{Self} >>= {Rhs}`\"\n)]\npub trait ShrAssign<Rhs = Self> {\n    /// Performs the `>>=` operation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x: u8 = 5;\n    /// x >>= 1;\n    /// assert_eq!(x, 2);\n    ///\n    /// let mut x: u8 = 2;\n    /// x >>= 1;\n    /// assert_eq!(x, 1);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn shr_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! shr_assign_impl {\n    ($t:ty, $f:ty) => {\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShrAssign<$f> for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn shr_assign(&mut self, other: $f) {\n                *self >>= other\n            }\n        }\n\n        forward_ref_op_assign! { impl ShrAssign, shr_assign for $t, $f }\n    };\n}\n\nmacro_rules! shr_assign_impl_all {\n    ($($t:ty)*) => ($(\n        shr_assign_impl! { $t, u8 }\n        shr_assign_impl! { $t, u16 }\n        shr_assign_impl! { $t, u32 }\n        shr_assign_impl! { $t, u64 }\n        shr_assign_impl! { $t, u128 }\n        shr_assign_impl! { $t, usize }\n\n        shr_assign_impl! { $t, i8 }\n        shr_assign_impl! { $t, i16 }\n        shr_assign_impl! { $t, i32 }\n        shr_assign_impl! { $t, i64 }\n        shr_assign_impl! { $t, i128 }\n        shr_assign_impl! { $t, isize }\n    )*)\n}\n\nshr_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n"],[2823,"/// The addition operator `+`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory. For\n/// example, [`std::time::SystemTime`] implements `Add<Duration>`, which permits\n/// operations of the form `SystemTime = SystemTime + Duration`.\n///\n/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n///\n/// # Examples\n///\n/// ## `Add`able points\n///\n/// ```\n/// use std::ops::Add;\n///\n/// #[derive(Debug, Copy, Clone, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl Add for Point {\n///     type Output = Self;\n///\n///     fn add(self, other: Self) -> Self {\n///         Self {\n///             x: self.x + other.x,\n///             y: self.y + other.y,\n///         }\n///     }\n/// }\n///\n/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n///            Point { x: 3, y: 3 });\n/// ```\n///\n/// ## Implementing `Add` with generics\n///\n/// Here is an example of the same `Point` struct implementing the `Add` trait\n/// using generics.\n///\n/// ```\n/// use std::ops::Add;\n///\n/// #[derive(Debug, Copy, Clone, PartialEq)]\n/// struct Point<T> {\n///     x: T,\n///     y: T,\n/// }\n///\n/// // Notice that the implementation uses the associated type `Output`.\n/// impl<T: Add<Output = T>> Add for Point<T> {\n///     type Output = Self;\n///\n///     fn add(self, other: Self) -> Self::Output {\n///         Self {\n///             x: self.x + other.x,\n///             y: self.y + other.y,\n///         }\n///     }\n/// }\n///\n/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n///            Point { x: 3, y: 3 });\n/// ```\n#[lang = \"add\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    on(all(_Self = \"{integer}\", Rhs = \"{float}\"), message = \"cannot add a float to an integer\",),\n    on(all(_Self = \"{float}\", Rhs = \"{integer}\"), message = \"cannot add an integer to a float\",),\n    message = \"cannot add `{Rhs}` to `{Self}`\",\n    label = \"no implementation for `{Self} + {Rhs}`\"\n)]\n#[doc(alias = \"+\")]\npub trait Add<Rhs = Self> {\n    /// The resulting type after applying the `+` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `+` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// assert_eq!(12 + 1, 13);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn add(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! add_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Add for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn add(self, other: $t) -> $t { self + other }\n        }\n\n        forward_ref_binop! { impl Add, add for $t, $t }\n    )*)\n}\n\nadd_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The subtraction operator `-`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory. For\n/// example, [`std::time::SystemTime`] implements `Sub<Duration>`, which permits\n/// operations of the form `SystemTime = SystemTime - Duration`.\n///\n/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n///\n/// # Examples\n///\n/// ## `Sub`tractable points\n///\n/// ```\n/// use std::ops::Sub;\n///\n/// #[derive(Debug, Copy, Clone, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl Sub for Point {\n///     type Output = Self;\n///\n///     fn sub(self, other: Self) -> Self::Output {\n///         Self {\n///             x: self.x - other.x,\n///             y: self.y - other.y,\n///         }\n///     }\n/// }\n///\n/// assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n///            Point { x: 1, y: 0 });\n/// ```\n///\n/// ## Implementing `Sub` with generics\n///\n/// Here is an example of the same `Point` struct implementing the `Sub` trait\n/// using generics.\n///\n/// ```\n/// use std::ops::Sub;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Point<T> {\n///     x: T,\n///     y: T,\n/// }\n///\n/// // Notice that the implementation uses the associated type `Output`.\n/// impl<T: Sub<Output = T>> Sub for Point<T> {\n///     type Output = Self;\n///\n///     fn sub(self, other: Self) -> Self::Output {\n///         Point {\n///             x: self.x - other.x,\n///             y: self.y - other.y,\n///         }\n///     }\n/// }\n///\n/// assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },\n///            Point { x: 1, y: 3 });\n/// ```\n#[lang = \"sub\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot subtract `{Rhs}` from `{Self}`\",\n    label = \"no implementation for `{Self} - {Rhs}`\"\n)]\n#[doc(alias = \"-\")]\npub trait Sub<Rhs = Self> {\n    /// The resulting type after applying the `-` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `-` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// assert_eq!(12 - 1, 11);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn sub(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! sub_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Sub for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn sub(self, other: $t) -> $t { self - other }\n        }\n\n        forward_ref_binop! { impl Sub, sub for $t, $t }\n    )*)\n}\n\nsub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The multiplication operator `*`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// ## `Mul`tipliable rational numbers\n///\n/// ```\n/// use std::ops::Mul;\n///\n/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n/// // derive `Eq` and `PartialEq`.\n/// #[derive(Debug, Eq, PartialEq)]\n/// struct Rational {\n///     numerator: usize,\n///     denominator: usize,\n/// }\n///\n/// impl Rational {\n///     fn new(numerator: usize, denominator: usize) -> Self {\n///         if denominator == 0 {\n///             panic!(\"Zero is an invalid denominator!\");\n///         }\n///\n///         // Reduce to lowest terms by dividing by the greatest common\n///         // divisor.\n///         let gcd = gcd(numerator, denominator);\n///         Self {\n///             numerator: numerator / gcd,\n///             denominator: denominator / gcd,\n///         }\n///     }\n/// }\n///\n/// impl Mul for Rational {\n///     // The multiplication of rational numbers is a closed operation.\n///     type Output = Self;\n///\n///     fn mul(self, rhs: Self) -> Self {\n///         let numerator = self.numerator * rhs.numerator;\n///         let denominator = self.denominator * rhs.denominator;\n///         Self::new(numerator, denominator)\n///     }\n/// }\n///\n/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n/// // divisor.\n/// fn gcd(x: usize, y: usize) -> usize {\n///     let mut x = x;\n///     let mut y = y;\n///     while y != 0 {\n///         let t = y;\n///         y = x % y;\n///         x = t;\n///     }\n///     x\n/// }\n///\n/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n/// assert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n///            Rational::new(1, 2));\n/// ```\n///\n/// ## Multiplying vectors by scalars as in linear algebra\n///\n/// ```\n/// use std::ops::Mul;\n///\n/// struct Scalar { value: usize }\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Vector { value: Vec<usize> }\n///\n/// impl Mul<Scalar> for Vector {\n///     type Output = Self;\n///\n///     fn mul(self, rhs: Scalar) -> Self::Output {\n///         Self { value: self.value.iter().map(|v| v * rhs.value).collect() }\n///     }\n/// }\n///\n/// let vector = Vector { value: vec![2, 4, 6] };\n/// let scalar = Scalar { value: 3 };\n/// assert_eq!(vector * scalar, Vector { value: vec![6, 12, 18] });\n/// ```\n#[lang = \"mul\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot multiply `{Self}` by `{Rhs}`\",\n    label = \"no implementation for `{Self} * {Rhs}`\"\n)]\n#[doc(alias = \"*\")]\npub trait Mul<Rhs = Self> {\n    /// The resulting type after applying the `*` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `*` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// assert_eq!(12 * 2, 24);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn mul(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! mul_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Mul for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn mul(self, other: $t) -> $t { self * other }\n        }\n\n        forward_ref_binop! { impl Mul, mul for $t, $t }\n    )*)\n}\n\nmul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The division operator `/`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// ## `Div`idable rational numbers\n///\n/// ```\n/// use std::ops::Div;\n///\n/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n/// // derive `Eq` and `PartialEq`.\n/// #[derive(Debug, Eq, PartialEq)]\n/// struct Rational {\n///     numerator: usize,\n///     denominator: usize,\n/// }\n///\n/// impl Rational {\n///     fn new(numerator: usize, denominator: usize) -> Self {\n///         if denominator == 0 {\n///             panic!(\"Zero is an invalid denominator!\");\n///         }\n///\n///         // Reduce to lowest terms by dividing by the greatest common\n///         // divisor.\n///         let gcd = gcd(numerator, denominator);\n///         Self {\n///             numerator: numerator / gcd,\n///             denominator: denominator / gcd,\n///         }\n///     }\n/// }\n///\n/// impl Div for Rational {\n///     // The division of rational numbers is a closed operation.\n///     type Output = Self;\n///\n///     fn div(self, rhs: Self) -> Self::Output {\n///         if rhs.numerator == 0 {\n///             panic!(\"Cannot divide by zero-valued `Rational`!\");\n///         }\n///\n///         let numerator = self.numerator * rhs.denominator;\n///         let denominator = self.denominator * rhs.numerator;\n///         Self::new(numerator, denominator)\n///     }\n/// }\n///\n/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n/// // divisor.\n/// fn gcd(x: usize, y: usize) -> usize {\n///     let mut x = x;\n///     let mut y = y;\n///     while y != 0 {\n///         let t = y;\n///         y = x % y;\n///         x = t;\n///     }\n///     x\n/// }\n///\n/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n/// assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n///            Rational::new(2, 3));\n/// ```\n///\n/// ## Dividing vectors by scalars as in linear algebra\n///\n/// ```\n/// use std::ops::Div;\n///\n/// struct Scalar { value: f32 }\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Vector { value: Vec<f32> }\n///\n/// impl Div<Scalar> for Vector {\n///     type Output = Self;\n///\n///     fn div(self, rhs: Scalar) -> Self::Output {\n///         Self { value: self.value.iter().map(|v| v / rhs.value).collect() }\n///     }\n/// }\n///\n/// let scalar = Scalar { value: 2f32 };\n/// let vector = Vector { value: vec![2f32, 4f32, 6f32] };\n/// assert_eq!(vector / scalar, Vector { value: vec![1f32, 2f32, 3f32] });\n/// ```\n#[lang = \"div\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot divide `{Self}` by `{Rhs}`\",\n    label = \"no implementation for `{Self} / {Rhs}`\"\n)]\n#[doc(alias = \"/\")]\npub trait Div<Rhs = Self> {\n    /// The resulting type after applying the `/` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `/` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// assert_eq!(12 / 2, 6);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn div(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! div_impl_integer {\n    ($(($($t:ty)*) => $panic:expr),*) => ($($(\n        /// This operation rounds towards zero, truncating any\n        /// fractional part of the exact result.\n        ///\n        /// # Panics\n        ///\n        #[doc = $panic]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Div for $t {\n            type Output = $t;\n\n            #[inline]\n            fn div(self, other: $t) -> $t { self / other }\n        }\n\n        forward_ref_binop! { impl Div, div for $t, $t }\n    )*)*)\n}\n\ndiv_impl_integer! {\n    (usize u8 u16 u32 u64 u128) => \"This operation will panic if `other == 0`.\",\n    (isize i8 i16 i32 i64 i128) => \"This operation will panic if `other == 0` or the division results in overflow.\"\n}\n\nmacro_rules! div_impl_float {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Div for $t {\n            type Output = $t;\n\n            #[inline]\n            fn div(self, other: $t) -> $t { self / other }\n        }\n\n        forward_ref_binop! { impl Div, div for $t, $t }\n    )*)\n}\n\ndiv_impl_float! { f32 f64 }\n\n/// The remainder operator `%`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// This example implements `Rem` on a `SplitSlice` object. After `Rem` is\n/// implemented, one can use the `%` operator to find out what the remaining\n/// elements of the slice would be after splitting it into equal slices of a\n/// given length.\n///\n/// ```\n/// use std::ops::Rem;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct SplitSlice<'a, T: 'a> {\n///     slice: &'a [T],\n/// }\n///\n/// impl<'a, T> Rem<usize> for SplitSlice<'a, T> {\n///     type Output = Self;\n///\n///     fn rem(self, modulus: usize) -> Self::Output {\n///         let len = self.slice.len();\n///         let rem = len % modulus;\n///         let start = len - rem;\n///         Self {slice: &self.slice[start..]}\n///     }\n/// }\n///\n/// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n/// // the remainder would be &[6, 7].\n/// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n///            SplitSlice { slice: &[6, 7] });\n/// ```\n#[lang = \"rem\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot mod `{Self}` by `{Rhs}`\",\n    label = \"no implementation for `{Self} % {Rhs}`\"\n)]\n#[doc(alias = \"%\")]\npub trait Rem<Rhs = Self> {\n    /// The resulting type after applying the `%` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `%` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// assert_eq!(12 % 10, 2);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn rem(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! rem_impl_integer {\n    ($(($($t:ty)*) => $panic:expr),*) => ($($(\n        /// This operation satisfies `n % d == n - (n / d) * d`. The\n        /// result has the same sign as the left operand.\n        ///\n        /// # Panics\n        ///\n        #[doc = $panic]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Rem for $t {\n            type Output = $t;\n\n            #[inline]\n            fn rem(self, other: $t) -> $t { self % other }\n        }\n\n        forward_ref_binop! { impl Rem, rem for $t, $t }\n    )*)*)\n}\n\nrem_impl_integer! {\n    (usize u8 u16 u32 u64 u128) => \"This operation will panic if `other == 0`.\",\n    (isize i8 i16 i32 i64 i128) => \"This operation will panic if `other == 0` or if `self / other` results in overflow.\"\n}\n\nmacro_rules! rem_impl_float {\n    ($($t:ty)*) => ($(\n\n        /// The remainder from the division of two floats.\n        ///\n        /// The remainder has the same sign as the dividend and is computed as:\n        /// `x - (x / y).trunc() * y`.\n        ///\n        /// # Examples\n        /// ```\n        /// let x: f32 = 50.50;\n        /// let y: f32 = 8.125;\n        /// let remainder = x - (x / y).trunc() * y;\n        ///\n        /// // The answer to both operations is 1.75\n        /// assert_eq!(x % y, remainder);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Rem for $t {\n            type Output = $t;\n\n            #[inline]\n            fn rem(self, other: $t) -> $t { self % other }\n        }\n\n        forward_ref_binop! { impl Rem, rem for $t, $t }\n    )*)\n}\n\nrem_impl_float! { f32 f64 }\n\n/// The unary negation operator `-`.\n///\n/// # Examples\n///\n/// An implementation of `Neg` for `Sign`, which allows the use of `-` to\n/// negate its value.\n///\n/// ```\n/// use std::ops::Neg;\n///\n/// #[derive(Debug, PartialEq)]\n/// enum Sign {\n///     Negative,\n///     Zero,\n///     Positive,\n/// }\n///\n/// impl Neg for Sign {\n///     type Output = Self;\n///\n///     fn neg(self) -> Self::Output {\n///         match self {\n///             Sign::Negative => Sign::Positive,\n///             Sign::Zero => Sign::Zero,\n///             Sign::Positive => Sign::Negative,\n///         }\n///     }\n/// }\n///\n/// // A negative positive is a negative.\n/// assert_eq!(-Sign::Positive, Sign::Negative);\n/// // A double negative is a positive.\n/// assert_eq!(-Sign::Negative, Sign::Positive);\n/// // Zero is its own negation.\n/// assert_eq!(-Sign::Zero, Sign::Zero);\n/// ```\n#[lang = \"neg\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \"-\")]\npub trait Neg {\n    /// The resulting type after applying the `-` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the unary `-` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let x: i32 = 12;\n    /// assert_eq!(-x, -12);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn neg(self) -> Self::Output;\n}\n\nmacro_rules! neg_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Neg for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn neg(self) -> $t { -self }\n        }\n\n        forward_ref_unop! { impl Neg, neg for $t }\n    )*)\n}\n\nneg_impl! { isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The addition assignment operator `+=`.\n///\n/// # Examples\n///\n/// This example creates a `Point` struct that implements the `AddAssign`\n/// trait, and then demonstrates add-assigning to a mutable `Point`.\n///\n/// ```\n/// use std::ops::AddAssign;\n///\n/// #[derive(Debug, Copy, Clone, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl AddAssign for Point {\n///     fn add_assign(&mut self, other: Self) {\n///         *self = Self {\n///             x: self.x + other.x,\n///             y: self.y + other.y,\n///         };\n///     }\n/// }\n///\n/// let mut point = Point { x: 1, y: 0 };\n/// point += Point { x: 2, y: 3 };\n/// assert_eq!(point, Point { x: 3, y: 3 });\n/// ```\n#[lang = \"add_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot add-assign `{Rhs}` to `{Self}`\",\n    label = \"no implementation for `{Self} += {Rhs}`\"\n)]\n#[doc(alias = \"+\")]\n#[doc(alias = \"+=\")]\npub trait AddAssign<Rhs = Self> {\n    /// Performs the `+=` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let mut x: u32 = 12;\n    /// x += 1;\n    /// assert_eq!(x, 13);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn add_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! add_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl AddAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn add_assign(&mut self, other: $t) { *self += other }\n        }\n\n        forward_ref_op_assign! { impl AddAssign, add_assign for $t, $t }\n    )+)\n}\n\nadd_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The subtraction assignment operator `-=`.\n///\n/// # Examples\n///\n/// This example creates a `Point` struct that implements the `SubAssign`\n/// trait, and then demonstrates sub-assigning to a mutable `Point`.\n///\n/// ```\n/// use std::ops::SubAssign;\n///\n/// #[derive(Debug, Copy, Clone, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl SubAssign for Point {\n///     fn sub_assign(&mut self, other: Self) {\n///         *self = Self {\n///             x: self.x - other.x,\n///             y: self.y - other.y,\n///         };\n///     }\n/// }\n///\n/// let mut point = Point { x: 3, y: 3 };\n/// point -= Point { x: 2, y: 3 };\n/// assert_eq!(point, Point {x: 1, y: 0});\n/// ```\n#[lang = \"sub_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot subtract-assign `{Rhs}` from `{Self}`\",\n    label = \"no implementation for `{Self} -= {Rhs}`\"\n)]\n#[doc(alias = \"-\")]\n#[doc(alias = \"-=\")]\npub trait SubAssign<Rhs = Self> {\n    /// Performs the `-=` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let mut x: u32 = 12;\n    /// x -= 1;\n    /// assert_eq!(x, 11);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn sub_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! sub_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl SubAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn sub_assign(&mut self, other: $t) { *self -= other }\n        }\n\n        forward_ref_op_assign! { impl SubAssign, sub_assign for $t, $t }\n    )+)\n}\n\nsub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The multiplication assignment operator `*=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::MulAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Frequency { hertz: f64 }\n///\n/// impl MulAssign<f64> for Frequency {\n///     fn mul_assign(&mut self, rhs: f64) {\n///         self.hertz *= rhs;\n///     }\n/// }\n///\n/// let mut frequency = Frequency { hertz: 50.0 };\n/// frequency *= 4.0;\n/// assert_eq!(Frequency { hertz: 200.0 }, frequency);\n/// ```\n#[lang = \"mul_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot multiply-assign `{Self}` by `{Rhs}`\",\n    label = \"no implementation for `{Self} *= {Rhs}`\"\n)]\n#[doc(alias = \"*\")]\n#[doc(alias = \"*=\")]\npub trait MulAssign<Rhs = Self> {\n    /// Performs the `*=` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let mut x: u32 = 12;\n    /// x *= 2;\n    /// assert_eq!(x, 24);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn mul_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! mul_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl MulAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn mul_assign(&mut self, other: $t) { *self *= other }\n        }\n\n        forward_ref_op_assign! { impl MulAssign, mul_assign for $t, $t }\n    )+)\n}\n\nmul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The division assignment operator `/=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::DivAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Frequency { hertz: f64 }\n///\n/// impl DivAssign<f64> for Frequency {\n///     fn div_assign(&mut self, rhs: f64) {\n///         self.hertz /= rhs;\n///     }\n/// }\n///\n/// let mut frequency = Frequency { hertz: 200.0 };\n/// frequency /= 4.0;\n/// assert_eq!(Frequency { hertz: 50.0 }, frequency);\n/// ```\n#[lang = \"div_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot divide-assign `{Self}` by `{Rhs}`\",\n    label = \"no implementation for `{Self} /= {Rhs}`\"\n)]\n#[doc(alias = \"/\")]\n#[doc(alias = \"/=\")]\npub trait DivAssign<Rhs = Self> {\n    /// Performs the `/=` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let mut x: u32 = 12;\n    /// x /= 2;\n    /// assert_eq!(x, 6);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn div_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! div_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl DivAssign for $t {\n            #[inline]\n            fn div_assign(&mut self, other: $t) { *self /= other }\n        }\n\n        forward_ref_op_assign! { impl DivAssign, div_assign for $t, $t }\n    )+)\n}\n\ndiv_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The remainder assignment operator `%=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::RemAssign;\n///\n/// struct CookieJar { cookies: u32 }\n///\n/// impl RemAssign<u32> for CookieJar {\n///     fn rem_assign(&mut self, piles: u32) {\n///         self.cookies %= piles;\n///     }\n/// }\n///\n/// let mut jar = CookieJar { cookies: 31 };\n/// let piles = 4;\n///\n/// println!(\"Splitting up {} cookies into {} even piles!\", jar.cookies, piles);\n///\n/// jar %= piles;\n///\n/// println!(\"{} cookies remain in the cookie jar!\", jar.cookies);\n/// ```\n#[lang = \"rem_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot mod-assign `{Self}` by `{Rhs}``\",\n    label = \"no implementation for `{Self} %= {Rhs}`\"\n)]\n#[doc(alias = \"%\")]\n#[doc(alias = \"%=\")]\npub trait RemAssign<Rhs = Self> {\n    /// Performs the `%=` operation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let mut x: u32 = 12;\n    /// x %= 10;\n    /// assert_eq!(x, 2);\n    /// ```\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn rem_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! rem_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl RemAssign for $t {\n            #[inline]\n            fn rem_assign(&mut self, other: $t) { *self %= other }\n        }\n\n        forward_ref_op_assign! { impl RemAssign, rem_assign for $t, $t }\n    )+)\n}\n\nrem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n"],[2824,"/// A trait for customizing the behavior of the `?` operator.\n///\n/// A type implementing `Try` is one that has a canonical way to view it\n/// in terms of a success/failure dichotomy. This trait allows both\n/// extracting those success or failure values from an existing instance and\n/// creating a new instance from a success or failure value.\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\n#[rustc_on_unimplemented(\n    on(\n        all(\n            any(from_method = \"from_error\", from_method = \"from_ok\"),\n            from_desugaring = \"QuestionMark\"\n        ),\n        message = \"the `?` operator can only be used in {ItemContext} \\\n                    that returns `Result` or `Option` \\\n                    (or another type that implements `{Try}`)\",\n        label = \"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\n        enclosing_scope = \"this function should return `Result` or `Option` to accept `?`\"\n    ),\n    on(\n        all(from_method = \"into_result\", from_desugaring = \"QuestionMark\"),\n        message = \"the `?` operator can only be applied to values \\\n                    that implement `{Try}`\",\n        label = \"the `?` operator cannot be applied to type `{Self}`\"\n    )\n)]\n#[doc(alias = \"?\")]\n#[cfg_attr(bootstrap, lang = \"try\")]\npub trait Try {\n    /// The type of this value when viewed as successful.\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    type Output; // This no longer follows its RFC, but is only used in bootstrap.\n    /// The type of this value when viewed as failed.\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    type Error;\n\n    /// Applies the \"?\" operator. A return of `Ok(t)` means that the\n    /// execution should continue normally, and the result of `?` is the\n    /// value `t`. A return of `Err(e)` means that execution should branch\n    /// to the innermost enclosing `catch`, or return from the function.\n    ///\n    /// If an `Err(e)` result is returned, the value `e` will be \"wrapped\"\n    /// in the return type of the enclosing scope (which must itself implement\n    /// `Try`). Specifically, the value `X::from_error(From::from(e))`\n    /// is returned, where `X` is the return type of the enclosing function.\n    #[cfg_attr(bootstrap, lang = \"into_result\")]\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    fn into_result(self) -> Result<Self::Output, Self::Error>;\n\n    /// Wrap an error value to construct the composite result. For example,\n    /// `Result::Err(x)` and `Result::from_error(x)` are equivalent.\n    #[cfg_attr(bootstrap, lang = \"from_error\")]\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    fn from_error(v: Self::Error) -> Self;\n\n    /// Wrap an OK value to construct the composite result. For example,\n    /// `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.\n    #[cfg_attr(bootstrap, lang = \"from_ok\")]\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    fn from_ok(v: Self::Output) -> Self;\n}\n"],[2825,"/// Used for immutable dereferencing operations, like `*v`.\n///\n/// In addition to being used for explicit dereferencing operations with the\n/// (unary) `*` operator in immutable contexts, `Deref` is also used implicitly\n/// by the compiler in many circumstances. This mechanism is called\n/// ['`Deref` coercion'][more]. In mutable contexts, [`DerefMut`] is used.\n///\n/// Implementing `Deref` for smart pointers makes accessing the data behind them\n/// convenient, which is why they implement `Deref`. On the other hand, the\n/// rules regarding `Deref` and [`DerefMut`] were designed specifically to\n/// accommodate smart pointers. Because of this, **`Deref` should only be\n/// implemented for smart pointers** to avoid confusion.\n///\n/// For similar reasons, **this trait should never fail**. Failure during\n/// dereferencing can be extremely confusing when `Deref` is invoked implicitly.\n///\n/// # More on `Deref` coercion\n///\n/// If `T` implements `Deref<Target = U>`, and `x` is a value of type `T`, then:\n///\n/// * In immutable contexts, `*x` (where `T` is neither a reference nor a raw pointer)\n///   is equivalent to `*Deref::deref(&x)`.\n/// * Values of type `&T` are coerced to values of type `&U`\n/// * `T` implicitly implements all the (immutable) methods of the type `U`.\n///\n/// For more details, visit [the chapter in *The Rust Programming Language*][book]\n/// as well as the reference sections on [the dereference operator][ref-deref-op],\n/// [method resolution] and [type coercions].\n///\n/// [book]: ../../book/ch15-02-deref.html\n/// [more]: #more-on-deref-coercion\n/// [ref-deref-op]: ../../reference/expressions/operator-expr.html#the-dereference-operator\n/// [method resolution]: ../../reference/expressions/method-call-expr.html\n/// [type coercions]: ../../reference/type-coercions.html\n///\n/// # Examples\n///\n/// A struct with a single field which is accessible by dereferencing the\n/// struct.\n///\n/// ```\n/// use std::ops::Deref;\n///\n/// struct DerefExample<T> {\n///     value: T\n/// }\n///\n/// impl<T> Deref for DerefExample<T> {\n///     type Target = T;\n///\n///     fn deref(&self) -> &Self::Target {\n///         &self.value\n///     }\n/// }\n///\n/// let x = DerefExample { value: 'a' };\n/// assert_eq!('a', *x);\n/// ```\n#[lang = \"deref\"]\n#[doc(alias = \"*\")]\n#[doc(alias = \"&*\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_diagnostic_item = \"Deref\"]\npub trait Deref {\n    /// The resulting type after dereferencing.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_diagnostic_item = \"deref_target\"]\n    #[lang = \"deref_target\"]\n    type Target: ?Sized;\n\n    /// Dereferences the value.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_diagnostic_item = \"deref_method\"]\n    fn deref(&self) -> &Self::Target;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for &T {\n    type Target = T;\n\n    #[rustc_diagnostic_item = \"noop_method_deref\"]\n    fn deref(&self) -> &T {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !DerefMut for &T {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for &mut T {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        *self\n    }\n}\n\n/// Used for mutable dereferencing operations, like in `*v = 1;`.\n///\n/// In addition to being used for explicit dereferencing operations with the\n/// (unary) `*` operator in mutable contexts, `DerefMut` is also used implicitly\n/// by the compiler in many circumstances. This mechanism is called\n/// ['`Deref` coercion'][more]. In immutable contexts, [`Deref`] is used.\n///\n/// Implementing `DerefMut` for smart pointers makes mutating the data behind\n/// them convenient, which is why they implement `DerefMut`. On the other hand,\n/// the rules regarding [`Deref`] and `DerefMut` were designed specifically to\n/// accommodate smart pointers. Because of this, **`DerefMut` should only be\n/// implemented for smart pointers** to avoid confusion.\n///\n/// For similar reasons, **this trait should never fail**. Failure during\n/// dereferencing can be extremely confusing when `DerefMut` is invoked\n/// implicitly.\n///\n/// # More on `Deref` coercion\n///\n/// If `T` implements `DerefMut<Target = U>`, and `x` is a value of type `T`,\n/// then:\n///\n/// * In mutable contexts, `*x` (where `T` is neither a reference nor a raw pointer)\n///   is equivalent to `*DerefMut::deref_mut(&mut x)`.\n/// * Values of type `&mut T` are coerced to values of type `&mut U`\n/// * `T` implicitly implements all the (mutable) methods of the type `U`.\n///\n/// For more details, visit [the chapter in *The Rust Programming Language*][book]\n/// as well as the reference sections on [the dereference operator][ref-deref-op],\n/// [method resolution] and [type coercions].\n///\n/// [book]: ../../book/ch15-02-deref.html\n/// [more]: #more-on-deref-coercion\n/// [ref-deref-op]: ../../reference/expressions/operator-expr.html#the-dereference-operator\n/// [method resolution]: ../../reference/expressions/method-call-expr.html\n/// [type coercions]: ../../reference/type-coercions.html\n///\n/// # Examples\n///\n/// A struct with a single field which is modifiable by dereferencing the\n/// struct.\n///\n/// ```\n/// use std::ops::{Deref, DerefMut};\n///\n/// struct DerefMutExample<T> {\n///     value: T\n/// }\n///\n/// impl<T> Deref for DerefMutExample<T> {\n///     type Target = T;\n///\n///     fn deref(&self) -> &Self::Target {\n///         &self.value\n///     }\n/// }\n///\n/// impl<T> DerefMut for DerefMutExample<T> {\n///     fn deref_mut(&mut self) -> &mut Self::Target {\n///         &mut self.value\n///     }\n/// }\n///\n/// let mut x = DerefMutExample { value: 'a' };\n/// *x = 'b';\n/// assert_eq!('b', *x);\n/// ```\n#[lang = \"deref_mut\"]\n#[doc(alias = \"*\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait DerefMut: Deref {\n    /// Mutably dereferences the value.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn deref_mut(&mut self) -> &mut Self::Target;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> DerefMut for &mut T {\n    fn deref_mut(&mut self) -> &mut T {\n        *self\n    }\n}\n\n/// Indicates that a struct can be used as a method receiver, without the\n/// `arbitrary_self_types` feature. This is implemented by stdlib pointer types like `Box<T>`,\n/// `Rc<T>`, `&T`, and `Pin<P>`.\n#[lang = \"receiver\"]\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\n#[doc(hidden)]\npub trait Receiver {\n    // Empty.\n}\n\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\nimpl<T: ?Sized> Receiver for &T {}\n\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\nimpl<T: ?Sized> Receiver for &mut T {}\n"],[2826,"//! An implementation of SipHash.\n\n#![allow(deprecated)] // the types in this module are deprecated\n\nuse crate::cmp;\nuse crate::marker::PhantomData;\nuse crate::mem;\nuse crate::ptr;\n\n/// An implementation of SipHash 1-3.\n///\n/// This is currently the default hashing function used by standard library\n/// (e.g., `collections::HashMap` uses it by default).\n///\n/// See: <https://131002.net/siphash>\n#[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n#[rustc_deprecated(\n    since = \"1.13.0\",\n    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n)]\n#[derive(Debug, Clone, Default)]\n#[doc(hidden)]\npub struct SipHasher13 {\n    hasher: Hasher<Sip13Rounds>,\n}\n\n/// An implementation of SipHash 2-4.\n///\n/// See: <https://131002.net/siphash/>\n#[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n#[rustc_deprecated(\n    since = \"1.13.0\",\n    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n)]\n#[derive(Debug, Clone, Default)]\nstruct SipHasher24 {\n    hasher: Hasher<Sip24Rounds>,\n}\n\n/// An implementation of SipHash 2-4.\n///\n/// See: <https://131002.net/siphash/>\n///\n/// SipHash is a general-purpose hashing function: it runs at a good\n/// speed (competitive with Spooky and City) and permits strong _keyed_\n/// hashing. This lets you key your hash tables from a strong RNG, such as\n/// [`rand::os::OsRng`](https://doc.rust-lang.org/rand/rand/os/struct.OsRng.html).\n///\n/// Although the SipHash algorithm is considered to be generally strong,\n/// it is not intended for cryptographic purposes. As such, all\n/// cryptographic uses of this implementation are _strongly discouraged_.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"1.13.0\",\n    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n)]\n#[derive(Debug, Clone, Default)]\npub struct SipHasher(SipHasher24);\n\n#[derive(Debug)]\nstruct Hasher<S: Sip> {\n    k0: u64,\n    k1: u64,\n    length: usize, // how many bytes we've processed\n    state: State,  // hash State\n    tail: u64,     // unprocessed bytes le\n    ntail: usize,  // how many bytes in tail are valid\n    _marker: PhantomData<S>,\n}\n\n#[derive(Debug, Clone, Copy)]\n#[repr(C)]\nstruct State {\n    // v0, v2 and v1, v3 show up in pairs in the algorithm,\n    // and simd implementations of SipHash will use vectors\n    // of v02 and v13. By placing them in this order in the struct,\n    // the compiler can pick up on just a few simd optimizations by itself.\n    v0: u64,\n    v2: u64,\n    v1: u64,\n    v3: u64,\n}\n\nmacro_rules! compress {\n    ($state:expr) => {{ compress!($state.v0, $state.v1, $state.v2, $state.v3) }};\n    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) => {{\n        $v0 = $v0.wrapping_add($v1);\n        $v1 = $v1.rotate_left(13);\n        $v1 ^= $v0;\n        $v0 = $v0.rotate_left(32);\n        $v2 = $v2.wrapping_add($v3);\n        $v3 = $v3.rotate_left(16);\n        $v3 ^= $v2;\n        $v0 = $v0.wrapping_add($v3);\n        $v3 = $v3.rotate_left(21);\n        $v3 ^= $v0;\n        $v2 = $v2.wrapping_add($v1);\n        $v1 = $v1.rotate_left(17);\n        $v1 ^= $v2;\n        $v2 = $v2.rotate_left(32);\n    }};\n}\n\n/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n/// to load it from a possibly unaligned address.\n///\n/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\nmacro_rules! load_int_le {\n    ($buf:expr, $i:expr, $int_ty:ident) => {{\n        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n        let mut data = 0 as $int_ty;\n        ptr::copy_nonoverlapping(\n            $buf.as_ptr().add($i),\n            &mut data as *mut _ as *mut u8,\n            mem::size_of::<$int_ty>(),\n        );\n        data.to_le()\n    }};\n}\n\n/// Loads a u64 using up to 7 bytes of a byte slice. It looks clumsy but the\n/// `copy_nonoverlapping` calls that occur (via `load_int_le!`) all have fixed\n/// sizes and avoid calling `memcpy`, which is good for speed.\n///\n/// Unsafe because: unchecked indexing at start..start+len\n#[inline]\nunsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n    debug_assert!(len < 8);\n    let mut i = 0; // current byte index (from LSB) in the output u64\n    let mut out = 0;\n    if i + 3 < len {\n        // SAFETY: `i` cannot be greater than `len`, and the caller must guarantee\n        // that the index start..start+len is in bounds.\n        out = unsafe { load_int_le!(buf, start + i, u32) } as u64;\n        i += 4;\n    }\n    if i + 1 < len {\n        // SAFETY: same as above.\n        out |= (unsafe { load_int_le!(buf, start + i, u16) } as u64) << (i * 8);\n        i += 2\n    }\n    if i < len {\n        // SAFETY: same as above.\n        out |= (unsafe { *buf.get_unchecked(start + i) } as u64) << (i * 8);\n        i += 1;\n    }\n    debug_assert_eq!(i, len);\n    out\n}\n\nimpl SipHasher {\n    /// Creates a new `SipHasher` with the two initial keys set to 0.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.13.0\",\n        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n    )]\n    pub fn new() -> SipHasher {\n        SipHasher::new_with_keys(0, 0)\n    }\n\n    /// Creates a `SipHasher` that is keyed off the provided keys.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.13.0\",\n        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n    )]\n    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n        SipHasher(SipHasher24 { hasher: Hasher::new_with_keys(key0, key1) })\n    }\n}\n\nimpl SipHasher13 {\n    /// Creates a new `SipHasher13` with the two initial keys set to 0.\n    #[inline]\n    #[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n    #[rustc_deprecated(\n        since = \"1.13.0\",\n        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n    )]\n    pub fn new() -> SipHasher13 {\n        SipHasher13::new_with_keys(0, 0)\n    }\n\n    /// Creates a `SipHasher13` that is keyed off the provided keys.\n    #[inline]\n    #[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n    #[rustc_deprecated(\n        since = \"1.13.0\",\n        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n    )]\n    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n        SipHasher13 { hasher: Hasher::new_with_keys(key0, key1) }\n    }\n}\n\nimpl<S: Sip> Hasher<S> {\n    #[inline]\n    fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n        let mut state = Hasher {\n            k0: key0,\n            k1: key1,\n            length: 0,\n            state: State { v0: 0, v1: 0, v2: 0, v3: 0 },\n            tail: 0,\n            ntail: 0,\n            _marker: PhantomData,\n        };\n        state.reset();\n        state\n    }\n\n    #[inline]\n    fn reset(&mut self) {\n        self.length = 0;\n        self.state.v0 = self.k0 ^ 0x736f6d6570736575;\n        self.state.v1 = self.k1 ^ 0x646f72616e646f6d;\n        self.state.v2 = self.k0 ^ 0x6c7967656e657261;\n        self.state.v3 = self.k1 ^ 0x7465646279746573;\n        self.ntail = 0;\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl super::Hasher for SipHasher {\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n        self.0.hasher.write(msg)\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        self.0.hasher.finish()\n    }\n}\n\n#[unstable(feature = \"hashmap_internals\", issue = \"none\")]\nimpl super::Hasher for SipHasher13 {\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n        self.hasher.write(msg)\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        self.hasher.finish()\n    }\n}\n\nimpl<S: Sip> super::Hasher for Hasher<S> {\n    // Note: no integer hashing methods (`write_u*`, `write_i*`) are defined\n    // for this type. We could add them, copy the `short_write` implementation\n    // in librustc_data_structures/sip128.rs, and add `write_u*`/`write_i*`\n    // methods to `SipHasher`, `SipHasher13`, and `DefaultHasher`. This would\n    // greatly speed up integer hashing by those hashers, at the cost of\n    // slightly slowing down compile speeds on some benchmarks. See #69152 for\n    // details.\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n        let length = msg.len();\n        self.length += length;\n\n        let mut needed = 0;\n\n        if self.ntail != 0 {\n            needed = 8 - self.ntail;\n            // SAFETY: `cmp::min(length, needed)` is guaranteed to not be over `length`\n            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << (8 * self.ntail);\n            if length < needed {\n                self.ntail += length;\n                return;\n            } else {\n                self.state.v3 ^= self.tail;\n                S::c_rounds(&mut self.state);\n                self.state.v0 ^= self.tail;\n                self.ntail = 0;\n            }\n        }\n\n        // Buffered tail is now flushed, process new input.\n        let len = length - needed;\n        let left = len & 0x7; // len % 8\n\n        let mut i = needed;\n        while i < len - left {\n            // SAFETY: because `len - left` is the biggest multiple of 8 under\n            // `len`, and because `i` starts at `needed` where `len` is `length - needed`,\n            // `i + 8` is guaranteed to be less than or equal to `length`.\n            let mi = unsafe { load_int_le!(msg, i, u64) };\n\n            self.state.v3 ^= mi;\n            S::c_rounds(&mut self.state);\n            self.state.v0 ^= mi;\n\n            i += 8;\n        }\n\n        // SAFETY: `i` is now `needed + len.div_euclid(8) * 8`,\n        // so `i + left` = `needed + len` = `length`, which is by\n        // definition equal to `msg.len()`.\n        self.tail = unsafe { u8to64_le(msg, i, left) };\n        self.ntail = left;\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        let mut state = self.state;\n\n        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n\n        state.v3 ^= b;\n        S::c_rounds(&mut state);\n        state.v0 ^= b;\n\n        state.v2 ^= 0xff;\n        S::d_rounds(&mut state);\n\n        state.v0 ^ state.v1 ^ state.v2 ^ state.v3\n    }\n}\n\nimpl<S: Sip> Clone for Hasher<S> {\n    #[inline]\n    fn clone(&self) -> Hasher<S> {\n        Hasher {\n            k0: self.k0,\n            k1: self.k1,\n            length: self.length,\n            state: self.state,\n            tail: self.tail,\n            ntail: self.ntail,\n            _marker: self._marker,\n        }\n    }\n}\n\nimpl<S: Sip> Default for Hasher<S> {\n    /// Creates a `Hasher<S>` with the two initial keys set to 0.\n    #[inline]\n    fn default() -> Hasher<S> {\n        Hasher::new_with_keys(0, 0)\n    }\n}\n\n#[doc(hidden)]\ntrait Sip {\n    fn c_rounds(_: &mut State);\n    fn d_rounds(_: &mut State);\n}\n\n#[derive(Debug, Clone, Default)]\nstruct Sip13Rounds;\n\nimpl Sip for Sip13Rounds {\n    #[inline]\n    fn c_rounds(state: &mut State) {\n        compress!(state);\n    }\n\n    #[inline]\n    fn d_rounds(state: &mut State) {\n        compress!(state);\n        compress!(state);\n        compress!(state);\n    }\n}\n\n#[derive(Debug, Clone, Default)]\nstruct Sip24Rounds;\n\nimpl Sip for Sip24Rounds {\n    #[inline]\n    fn c_rounds(state: &mut State) {\n        compress!(state);\n        compress!(state);\n    }\n\n    #[inline]\n    fn d_rounds(state: &mut State) {\n        compress!(state);\n        compress!(state);\n        compress!(state);\n        compress!(state);\n    }\n}\n"],[2827,"//! Generic hashing support.\n//!\n//! This module provides a generic way to compute the [hash] of a value.\n//! Hashes are most commonly used with [`HashMap`] and [`HashSet`].\n//!\n//! [hash]: https://en.wikipedia.org/wiki/Hash_function\n//! [`HashMap`]: ../../std/collections/struct.HashMap.html\n//! [`HashSet`]: ../../std/collections/struct.HashSet.html\n//!\n//! The simplest way to make a type hashable is to use `#[derive(Hash)]`:\n//!\n//! # Examples\n//!\n//! ```rust\n//! use std::collections::hash_map::DefaultHasher;\n//! use std::hash::{Hash, Hasher};\n//!\n//! #[derive(Hash)]\n//! struct Person {\n//!     id: u32,\n//!     name: String,\n//!     phone: u64,\n//! }\n//!\n//! let person1 = Person {\n//!     id: 5,\n//!     name: \"Janet\".to_string(),\n//!     phone: 555_666_7777,\n//! };\n//! let person2 = Person {\n//!     id: 5,\n//!     name: \"Bob\".to_string(),\n//!     phone: 555_666_7777,\n//! };\n//!\n//! assert!(calculate_hash(&person1) != calculate_hash(&person2));\n//!\n//! fn calculate_hash<T: Hash>(t: &T) -> u64 {\n//!     let mut s = DefaultHasher::new();\n//!     t.hash(&mut s);\n//!     s.finish()\n//! }\n//! ```\n//!\n//! If you need more control over how a value is hashed, you need to implement\n//! the [`Hash`] trait:\n//!\n//! ```rust\n//! use std::collections::hash_map::DefaultHasher;\n//! use std::hash::{Hash, Hasher};\n//!\n//! struct Person {\n//!     id: u32,\n//!     # #[allow(dead_code)]\n//!     name: String,\n//!     phone: u64,\n//! }\n//!\n//! impl Hash for Person {\n//!     fn hash<H: Hasher>(&self, state: &mut H) {\n//!         self.id.hash(state);\n//!         self.phone.hash(state);\n//!     }\n//! }\n//!\n//! let person1 = Person {\n//!     id: 5,\n//!     name: \"Janet\".to_string(),\n//!     phone: 555_666_7777,\n//! };\n//! let person2 = Person {\n//!     id: 5,\n//!     name: \"Bob\".to_string(),\n//!     phone: 555_666_7777,\n//! };\n//!\n//! assert_eq!(calculate_hash(&person1), calculate_hash(&person2));\n//!\n//! fn calculate_hash<T: Hash>(t: &T) -> u64 {\n//!     let mut s = DefaultHasher::new();\n//!     t.hash(&mut s);\n//!     s.finish()\n//! }\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::fmt;\nuse crate::marker;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\npub use self::sip::SipHasher;\n\n#[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n#[allow(deprecated)]\n#[doc(hidden)]\npub use self::sip::SipHasher13;\n\nmod sip;\n\n/// A hashable type.\n///\n/// Types implementing `Hash` are able to be [`hash`]ed with an instance of\n/// [`Hasher`].\n///\n/// ## Implementing `Hash`\n///\n/// You can derive `Hash` with `#[derive(Hash)]` if all fields implement `Hash`.\n/// The resulting hash will be the combination of the values from calling\n/// [`hash`] on each field.\n///\n/// ```\n/// #[derive(Hash)]\n/// struct Rustacean {\n///     name: String,\n///     country: String,\n/// }\n/// ```\n///\n/// If you need more control over how a value is hashed, you can of course\n/// implement the `Hash` trait yourself:\n///\n/// ```\n/// use std::hash::{Hash, Hasher};\n///\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     phone: u64,\n/// }\n///\n/// impl Hash for Person {\n///     fn hash<H: Hasher>(&self, state: &mut H) {\n///         self.id.hash(state);\n///         self.phone.hash(state);\n///     }\n/// }\n/// ```\n///\n/// ## `Hash` and `Eq`\n///\n/// When implementing both `Hash` and [`Eq`], it is important that the following\n/// property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must also be equal.\n/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n///\n/// Thankfully, you won't need to worry about upholding this property when\n/// deriving both [`Eq`] and `Hash` with `#[derive(PartialEq, Eq, Hash)]`.\n///\n/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n/// [`HashSet`]: ../../std/collections/struct.HashSet.html\n/// [`hash`]: Hash::hash\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Hash {\n    /// Feeds this value into the given [`Hasher`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::DefaultHasher;\n    /// use std::hash::{Hash, Hasher};\n    ///\n    /// let mut hasher = DefaultHasher::new();\n    /// 7920.hash(&mut hasher);\n    /// println!(\"Hash is {:x}!\", hasher.finish());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn hash<H: Hasher>(&self, state: &mut H);\n\n    /// Feeds a slice of this type into the given [`Hasher`].\n    ///\n    /// This method is meant as a convenience, but its implementation is\n    /// also explicitly left unspecified. It isn't guaranteed to be\n    /// equivalent to repeated calls of [`hash`] and implementations of\n    /// [`Hash`] should keep that in mind and call [`hash`] themselves\n    /// if the slice isn't treated as a whole unit in the [`PartialEq`]\n    /// implementation.\n    ///\n    /// For example, a [`VecDeque`] implementation might naïvely call\n    /// [`as_slices`] and then [`hash_slice`] on each slice, but this\n    /// is wrong since the two slices can change with a call to\n    /// [`make_contiguous`] without affecting the [`PartialEq`]\n    /// result. Since these slices aren't treated as singular\n    /// units, and instead part of a larger deque, this method cannot\n    /// be used.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::DefaultHasher;\n    /// use std::hash::{Hash, Hasher};\n    ///\n    /// let mut hasher = DefaultHasher::new();\n    /// let numbers = [6, 28, 496, 8128];\n    /// Hash::hash_slice(&numbers, &mut hasher);\n    /// println!(\"Hash is {:x}!\", hasher.finish());\n    /// ```\n    ///\n    /// [`VecDeque`]: ../../std/collections/struct.VecDeque.html\n    /// [`as_slices`]: ../../std/collections/struct.VecDeque.html#method.as_slices\n    /// [`make_contiguous`]: ../../std/collections/struct.VecDeque.html#method.make_contiguous\n    /// [`hash`]: Hash::hash\n    /// [`hash_slice`]: Hash::hash_slice\n    #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n    where\n        Self: Sized,\n    {\n        for piece in data {\n            piece.hash(state);\n        }\n    }\n}\n\n// Separate module to reexport the macro `Hash` from prelude without the trait `Hash`.\npub(crate) mod macros {\n    /// Derive macro generating an impl of the trait `Hash`.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n    #[allow_internal_unstable(core_intrinsics)]\n    pub macro Hash($item:item) {\n        /* compiler built-in */\n    }\n}\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(inline)]\npub use macros::Hash;\n\n/// A trait for hashing an arbitrary stream of bytes.\n///\n/// Instances of `Hasher` usually represent state that is changed while hashing\n/// data.\n///\n/// `Hasher` provides a fairly basic interface for retrieving the generated hash\n/// (with [`finish`]), and writing integers as well as slices of bytes into an\n/// instance (with [`write`] and [`write_u8`] etc.). Most of the time, `Hasher`\n/// instances are used in conjunction with the [`Hash`] trait.\n///\n/// This trait makes no assumptions about how the various `write_*` methods are\n/// defined and implementations of [`Hash`] should not assume that they work one\n/// way or another. You cannot assume, for example, that a [`write_u32`] call is\n/// equivalent to four calls of [`write_u8`].\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::hash_map::DefaultHasher;\n/// use std::hash::Hasher;\n///\n/// let mut hasher = DefaultHasher::new();\n///\n/// hasher.write_u32(1989);\n/// hasher.write_u8(11);\n/// hasher.write_u8(9);\n/// hasher.write(b\"Huh?\");\n///\n/// println!(\"Hash is {:x}!\", hasher.finish());\n/// ```\n///\n/// [`finish`]: Hasher::finish\n/// [`write`]: Hasher::write\n/// [`write_u8`]: Hasher::write_u8\n/// [`write_u32`]: Hasher::write_u32\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Hasher {\n    /// Returns the hash value for the values written so far.\n    ///\n    /// Despite its name, the method does not reset the hasher’s internal\n    /// state. Additional [`write`]s will continue from the current value.\n    /// If you need to start a fresh hash value, you will have to create\n    /// a new hasher.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::DefaultHasher;\n    /// use std::hash::Hasher;\n    ///\n    /// let mut hasher = DefaultHasher::new();\n    /// hasher.write(b\"Cool!\");\n    ///\n    /// println!(\"Hash is {:x}!\", hasher.finish());\n    /// ```\n    ///\n    /// [`write`]: Hasher::write\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn finish(&self) -> u64;\n\n    /// Writes some data into this `Hasher`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::DefaultHasher;\n    /// use std::hash::Hasher;\n    ///\n    /// let mut hasher = DefaultHasher::new();\n    /// let data = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n    ///\n    /// hasher.write(&data);\n    ///\n    /// println!(\"Hash is {:x}!\", hasher.finish());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write(&mut self, bytes: &[u8]);\n\n    /// Writes a single `u8` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_u8(&mut self, i: u8) {\n        self.write(&[i])\n    }\n    /// Writes a single `u16` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_u16(&mut self, i: u16) {\n        self.write(&i.to_ne_bytes())\n    }\n    /// Writes a single `u32` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_u32(&mut self, i: u32) {\n        self.write(&i.to_ne_bytes())\n    }\n    /// Writes a single `u64` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_u64(&mut self, i: u64) {\n        self.write(&i.to_ne_bytes())\n    }\n    /// Writes a single `u128` into this hasher.\n    #[inline]\n    #[stable(feature = \"i128\", since = \"1.26.0\")]\n    fn write_u128(&mut self, i: u128) {\n        self.write(&i.to_ne_bytes())\n    }\n    /// Writes a single `usize` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_usize(&mut self, i: usize) {\n        self.write(&i.to_ne_bytes())\n    }\n\n    /// Writes a single `i8` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_i8(&mut self, i: i8) {\n        self.write_u8(i as u8)\n    }\n    /// Writes a single `i16` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_i16(&mut self, i: i16) {\n        self.write_u16(i as u16)\n    }\n    /// Writes a single `i32` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_i32(&mut self, i: i32) {\n        self.write_u32(i as u32)\n    }\n    /// Writes a single `i64` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_i64(&mut self, i: i64) {\n        self.write_u64(i as u64)\n    }\n    /// Writes a single `i128` into this hasher.\n    #[inline]\n    #[stable(feature = \"i128\", since = \"1.26.0\")]\n    fn write_i128(&mut self, i: i128) {\n        self.write_u128(i as u128)\n    }\n    /// Writes a single `isize` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_isize(&mut self, i: isize) {\n        self.write_usize(i as usize)\n    }\n}\n\n#[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\nimpl<H: Hasher + ?Sized> Hasher for &mut H {\n    fn finish(&self) -> u64 {\n        (**self).finish()\n    }\n    fn write(&mut self, bytes: &[u8]) {\n        (**self).write(bytes)\n    }\n    fn write_u8(&mut self, i: u8) {\n        (**self).write_u8(i)\n    }\n    fn write_u16(&mut self, i: u16) {\n        (**self).write_u16(i)\n    }\n    fn write_u32(&mut self, i: u32) {\n        (**self).write_u32(i)\n    }\n    fn write_u64(&mut self, i: u64) {\n        (**self).write_u64(i)\n    }\n    fn write_u128(&mut self, i: u128) {\n        (**self).write_u128(i)\n    }\n    fn write_usize(&mut self, i: usize) {\n        (**self).write_usize(i)\n    }\n    fn write_i8(&mut self, i: i8) {\n        (**self).write_i8(i)\n    }\n    fn write_i16(&mut self, i: i16) {\n        (**self).write_i16(i)\n    }\n    fn write_i32(&mut self, i: i32) {\n        (**self).write_i32(i)\n    }\n    fn write_i64(&mut self, i: i64) {\n        (**self).write_i64(i)\n    }\n    fn write_i128(&mut self, i: i128) {\n        (**self).write_i128(i)\n    }\n    fn write_isize(&mut self, i: isize) {\n        (**self).write_isize(i)\n    }\n}\n\n/// A trait for creating instances of [`Hasher`].\n///\n/// A `BuildHasher` is typically used (e.g., by [`HashMap`]) to create\n/// [`Hasher`]s for each key such that they are hashed independently of one\n/// another, since [`Hasher`]s contain state.\n///\n/// For each instance of `BuildHasher`, the [`Hasher`]s created by\n/// [`build_hasher`] should be identical. That is, if the same stream of bytes\n/// is fed into each hasher, the same output will also be generated.\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::hash_map::RandomState;\n/// use std::hash::{BuildHasher, Hasher};\n///\n/// let s = RandomState::new();\n/// let mut hasher_1 = s.build_hasher();\n/// let mut hasher_2 = s.build_hasher();\n///\n/// hasher_1.write_u32(8128);\n/// hasher_2.write_u32(8128);\n///\n/// assert_eq!(hasher_1.finish(), hasher_2.finish());\n/// ```\n///\n/// [`build_hasher`]: BuildHasher::build_hasher\n/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\npub trait BuildHasher {\n    /// Type of the hasher that will be created.\n    #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n    type Hasher: Hasher;\n\n    /// Creates a new hasher.\n    ///\n    /// Each call to `build_hasher` on the same instance should produce identical\n    /// [`Hasher`]s.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::RandomState;\n    /// use std::hash::BuildHasher;\n    ///\n    /// let s = RandomState::new();\n    /// let new_s = s.build_hasher();\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n    fn build_hasher(&self) -> Self::Hasher;\n\n    /// Calculates the hash of a single value.\n    ///\n    /// This is intended as a convenience for code which *consumes* hashes, such\n    /// as the implementation of a hash table or in unit tests that check\n    /// whether a custom [`Hash`] implementation behaves as expected.\n    ///\n    /// This must not be used in any code which *creates* hashes, such as in an\n    /// implementation of [`Hash`].  The way to create a combined hash of\n    /// multiple values is to call [`Hash::hash`] multiple times using the same\n    /// [`Hasher`], not to call this method repeatedly and combine the results.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #![feature(build_hasher_simple_hash_one)]\n    ///\n    /// use std::cmp::{max, min};\n    /// use std::hash::{BuildHasher, Hash, Hasher};\n    /// struct OrderAmbivalentPair<T: Ord>(T, T);\n    /// impl<T: Ord + Hash> Hash for OrderAmbivalentPair<T> {\n    ///     fn hash<H: Hasher>(&self, hasher: &mut H) {\n    ///         min(&self.0, &self.1).hash(hasher);\n    ///         max(&self.0, &self.1).hash(hasher);\n    ///     }\n    /// }\n    ///\n    /// // Then later, in a `#[test]` for the type...\n    /// let bh = std::collections::hash_map::RandomState::new();\n    /// assert_eq!(\n    ///     bh.hash_one(OrderAmbivalentPair(1, 2)),\n    ///     bh.hash_one(OrderAmbivalentPair(2, 1))\n    /// );\n    /// assert_eq!(\n    ///     bh.hash_one(OrderAmbivalentPair(10, 2)),\n    ///     bh.hash_one(&OrderAmbivalentPair(2, 10))\n    /// );\n    /// ```\n    #[unstable(feature = \"build_hasher_simple_hash_one\", issue = \"86161\")]\n    fn hash_one<T: Hash>(&self, x: T) -> u64 {\n        let mut hasher = self.build_hasher();\n        x.hash(&mut hasher);\n        hasher.finish()\n    }\n}\n\n/// Used to create a default [`BuildHasher`] instance for types that implement\n/// [`Hasher`] and [`Default`].\n///\n/// `BuildHasherDefault<H>` can be used when a type `H` implements [`Hasher`] and\n/// [`Default`], and you need a corresponding [`BuildHasher`] instance, but none is\n/// defined.\n///\n/// Any `BuildHasherDefault` is [zero-sized]. It can be created with\n/// [`default`][method.default]. When using `BuildHasherDefault` with [`HashMap`] or\n/// [`HashSet`], this doesn't need to be done, since they implement appropriate\n/// [`Default`] instances themselves.\n///\n/// # Examples\n///\n/// Using `BuildHasherDefault` to specify a custom [`BuildHasher`] for\n/// [`HashMap`]:\n///\n/// ```\n/// use std::collections::HashMap;\n/// use std::hash::{BuildHasherDefault, Hasher};\n///\n/// #[derive(Default)]\n/// struct MyHasher;\n///\n/// impl Hasher for MyHasher {\n///     fn write(&mut self, bytes: &[u8]) {\n///         // Your hashing algorithm goes here!\n///        unimplemented!()\n///     }\n///\n///     fn finish(&self) -> u64 {\n///         // Your hashing algorithm goes here!\n///         unimplemented!()\n///     }\n/// }\n///\n/// type MyBuildHasher = BuildHasherDefault<MyHasher>;\n///\n/// let hash_map = HashMap::<u32, u32, MyBuildHasher>::default();\n/// ```\n///\n/// [method.default]: BuildHasherDefault::default\n/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n/// [`HashSet`]: ../../std/collections/struct.HashSet.html\n/// [zero-sized]: https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\npub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n\n#[stable(since = \"1.9.0\", feature = \"core_impl_debug\")]\nimpl<H> fmt::Debug for BuildHasherDefault<H> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"BuildHasherDefault\").finish()\n    }\n}\n\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\nimpl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> {\n    type Hasher = H;\n\n    fn build_hasher(&self) -> H {\n        H::default()\n    }\n}\n\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\nimpl<H> Clone for BuildHasherDefault<H> {\n    fn clone(&self) -> BuildHasherDefault<H> {\n        BuildHasherDefault(marker::PhantomData)\n    }\n}\n\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\nimpl<H> Default for BuildHasherDefault<H> {\n    fn default() -> BuildHasherDefault<H> {\n        BuildHasherDefault(marker::PhantomData)\n    }\n}\n\n#[stable(since = \"1.29.0\", feature = \"build_hasher_eq\")]\nimpl<H> PartialEq for BuildHasherDefault<H> {\n    fn eq(&self, _other: &BuildHasherDefault<H>) -> bool {\n        true\n    }\n}\n\n#[stable(since = \"1.29.0\", feature = \"build_hasher_eq\")]\nimpl<H> Eq for BuildHasherDefault<H> {}\n\nmod impls {\n    use crate::mem;\n    use crate::slice;\n\n    use super::*;\n\n    macro_rules! impl_write {\n        ($(($ty:ident, $meth:ident),)*) => {$(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Hash for $ty {\n                #[inline]\n                fn hash<H: Hasher>(&self, state: &mut H) {\n                    state.$meth(*self)\n                }\n\n                #[inline]\n                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n                    let newlen = data.len() * mem::size_of::<$ty>();\n                    let ptr = data.as_ptr() as *const u8;\n                    // SAFETY: `ptr` is valid and aligned, as this macro is only used\n                    // for numeric primitives which have no padding. The new slice only\n                    // spans across `data` and is never mutated, and its total size is the\n                    // same as the original `data` so it can't be over `isize::MAX`.\n                    state.write(unsafe { slice::from_raw_parts(ptr, newlen) })\n                }\n            }\n        )*}\n    }\n\n    impl_write! {\n        (u8, write_u8),\n        (u16, write_u16),\n        (u32, write_u32),\n        (u64, write_u64),\n        (usize, write_usize),\n        (i8, write_i8),\n        (i16, write_i16),\n        (i32, write_i32),\n        (i64, write_i64),\n        (isize, write_isize),\n        (u128, write_u128),\n        (i128, write_i128),\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Hash for bool {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            state.write_u8(*self as u8)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Hash for char {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            state.write_u32(*self as u32)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Hash for str {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            state.write(self.as_bytes());\n            state.write_u8(0xff)\n        }\n    }\n\n    #[stable(feature = \"never_hash\", since = \"1.29.0\")]\n    impl Hash for ! {\n        #[inline]\n        fn hash<H: Hasher>(&self, _: &mut H) {\n            *self\n        }\n    }\n\n    macro_rules! impl_hash_tuple {\n        () => (\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Hash for () {\n                #[inline]\n                fn hash<H: Hasher>(&self, _state: &mut H) {}\n            }\n        );\n\n        ( $($name:ident)+) => (\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n                #[allow(non_snake_case)]\n                #[inline]\n                fn hash<S: Hasher>(&self, state: &mut S) {\n                    let ($(ref $name,)+) = *self;\n                    $($name.hash(state);)+\n                }\n            }\n        );\n    }\n\n    macro_rules! last_type {\n        ($a:ident,) => { $a };\n        ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n    }\n\n    impl_hash_tuple! {}\n    impl_hash_tuple! { A }\n    impl_hash_tuple! { A B }\n    impl_hash_tuple! { A B C }\n    impl_hash_tuple! { A B C D }\n    impl_hash_tuple! { A B C D E }\n    impl_hash_tuple! { A B C D E F }\n    impl_hash_tuple! { A B C D E F G }\n    impl_hash_tuple! { A B C D E F G H }\n    impl_hash_tuple! { A B C D E F G H I }\n    impl_hash_tuple! { A B C D E F G H I J }\n    impl_hash_tuple! { A B C D E F G H I J K }\n    impl_hash_tuple! { A B C D E F G H I J K L }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: Hash> Hash for [T] {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            self.len().hash(state);\n            Hash::hash_slice(self, state)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized + Hash> Hash for &T {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            (**self).hash(state);\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized + Hash> Hash for &mut T {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            (**self).hash(state);\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Hash for *const T {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            let (address, metadata) = self.to_raw_parts();\n            state.write_usize(address as usize);\n            metadata.hash(state);\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Hash for *mut T {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            let (address, metadata) = self.to_raw_parts();\n            state.write_usize(address as usize);\n            metadata.hash(state);\n        }\n    }\n}\n"],[2828,"//! Types that pin data to its location in memory.\n//!\n//! It is sometimes useful to have objects that are guaranteed not to move,\n//! in the sense that their placement in memory does not change, and can thus be relied upon.\n//! A prime example of such a scenario would be building self-referential structs,\n//! as moving an object with pointers to itself will invalidate them, which could cause undefined\n//! behavior.\n//!\n//! At a high level, a <code>[Pin]\\<P></code> ensures that the pointee of any pointer type\n//! `P` has a stable location in memory, meaning it cannot be moved elsewhere\n//! and its memory cannot be deallocated until it gets dropped. We say that the\n//! pointee is \"pinned\". Things get more subtle when discussing types that\n//! combine pinned with non-pinned data; [see below](#projections-and-structural-pinning)\n//! for more details.\n//!\n//! By default, all types in Rust are movable. Rust allows passing all types by-value,\n//! and common smart-pointer types such as <code>[Box]\\<T></code> and <code>[&mut] T</code> allow\n//! replacing and moving the values they contain: you can move out of a <code>[Box]\\<T></code>,\n//! or you can use [`mem::swap`]. <code>[Pin]\\<P></code> wraps a pointer type `P`, so\n//! <code>[Pin]<[Box]\\<T>></code> functions much like a regular <code>[Box]\\<T></code>:\n//! when a <code>[Pin]<[Box]\\<T>></code> gets dropped, so do its contents, and the memory gets\n//! deallocated. Similarly, <code>[Pin]<[&mut] T></code> is a lot like <code>[&mut] T</code>.\n//! However, <code>[Pin]\\<P></code> does not let clients actually obtain a <code>[Box]\\<T></code>\n//! or <code>[&mut] T</code> to pinned data, which implies that you cannot use operations such\n//! as [`mem::swap`]:\n//!\n//! ```\n//! use std::pin::Pin;\n//! fn swap_pins<T>(x: Pin<&mut T>, y: Pin<&mut T>) {\n//!     // `mem::swap` needs `&mut T`, but we cannot get it.\n//!     // We are stuck, we cannot swap the contents of these references.\n//!     // We could use `Pin::get_unchecked_mut`, but that is unsafe for a reason:\n//!     // we are not allowed to use it for moving things out of the `Pin`.\n//! }\n//! ```\n//!\n//! It is worth reiterating that <code>[Pin]\\<P></code> does *not* change the fact that a Rust\n//! compiler considers all types movable. [`mem::swap`] remains callable for any `T`. Instead,\n//! <code>[Pin]\\<P></code> prevents certain *values* (pointed to by pointers wrapped in\n//! <code>[Pin]\\<P></code>) from being moved by making it impossible to call methods that require\n//! <code>[&mut] T</code> on them (like [`mem::swap`]).\n//!\n//! <code>[Pin]\\<P></code> can be used to wrap any pointer type `P`, and as such it interacts with\n//! [`Deref`] and [`DerefMut`]. A <code>[Pin]\\<P></code> where <code>P: [Deref]</code> should be\n//! considered as a \"`P`-style pointer\" to a pinned <code>P::[Target]</code> – so, a\n//! <code>[Pin]<[Box]\\<T>></code> is an owned pointer to a pinned `T`, and a\n//! <code>[Pin]<[Rc]\\<T>></code> is a reference-counted pointer to a pinned `T`.\n//! For correctness, <code>[Pin]\\<P></code> relies on the implementations of [`Deref`] and\n//! [`DerefMut`] not to move out of their `self` parameter, and only ever to\n//! return a pointer to pinned data when they are called on a pinned pointer.\n//!\n//! # `Unpin`\n//!\n//! Many types are always freely movable, even when pinned, because they do not\n//! rely on having a stable address. This includes all the basic types (like\n//! [`bool`], [`i32`], and references) as well as types consisting solely of these\n//! types. Types that do not care about pinning implement the [`Unpin`]\n//! auto-trait, which cancels the effect of <code>[Pin]\\<P></code>. For <code>T: [Unpin]</code>,\n//! <code>[Pin]<[Box]\\<T>></code> and <code>[Box]\\<T></code> function identically, as do\n//! <code>[Pin]<[&mut] T></code> and <code>[&mut] T</code>.\n//!\n//! Note that pinning and [`Unpin`] only affect the pointed-to type <code>P::[Target]</code>,\n//! not the pointer type `P` itself that got wrapped in <code>[Pin]\\<P></code>. For example,\n//! whether or not <code>[Box]\\<T></code> is [`Unpin`] has no effect on the behavior of\n//! <code>[Pin]<[Box]\\<T>></code> (here, `T` is the pointed-to type).\n//!\n//! # Example: self-referential struct\n//!\n//! Before we go into more details to explain the guarantees and choices\n//! associated with <code>[Pin]\\<P></code>, we discuss some examples for how it might be used.\n//! Feel free to [skip to where the theoretical discussion continues](#drop-guarantee).\n//!\n//! ```rust\n//! use std::pin::Pin;\n//! use std::marker::PhantomPinned;\n//! use std::ptr::NonNull;\n//!\n//! // This is a self-referential struct because the slice field points to the data field.\n//! // We cannot inform the compiler about that with a normal reference,\n//! // as this pattern cannot be described with the usual borrowing rules.\n//! // Instead we use a raw pointer, though one which is known not to be null,\n//! // as we know it's pointing at the string.\n//! struct Unmovable {\n//!     data: String,\n//!     slice: NonNull<String>,\n//!     _pin: PhantomPinned,\n//! }\n//!\n//! impl Unmovable {\n//!     // To ensure the data doesn't move when the function returns,\n//!     // we place it in the heap where it will stay for the lifetime of the object,\n//!     // and the only way to access it would be through a pointer to it.\n//!     fn new(data: String) -> Pin<Box<Self>> {\n//!         let res = Unmovable {\n//!             data,\n//!             // we only create the pointer once the data is in place\n//!             // otherwise it will have already moved before we even started\n//!             slice: NonNull::dangling(),\n//!             _pin: PhantomPinned,\n//!         };\n//!         let mut boxed = Box::pin(res);\n//!\n//!         let slice = NonNull::from(&boxed.data);\n//!         // we know this is safe because modifying a field doesn't move the whole struct\n//!         unsafe {\n//!             let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);\n//!             Pin::get_unchecked_mut(mut_ref).slice = slice;\n//!         }\n//!         boxed\n//!     }\n//! }\n//!\n//! let unmoved = Unmovable::new(\"hello\".to_string());\n//! // The pointer should point to the correct location,\n//! // so long as the struct hasn't moved.\n//! // Meanwhile, we are free to move the pointer around.\n//! # #[allow(unused_mut)]\n//! let mut still_unmoved = unmoved;\n//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n//!\n//! // Since our type doesn't implement Unpin, this will fail to compile:\n//! // let mut new_unmoved = Unmovable::new(\"world\".to_string());\n//! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n//! ```\n//!\n//! # Example: intrusive doubly-linked list\n//!\n//! In an intrusive doubly-linked list, the collection does not actually allocate\n//! the memory for the elements itself. Allocation is controlled by the clients,\n//! and elements can live on a stack frame that lives shorter than the collection does.\n//!\n//! To make this work, every element has pointers to its predecessor and successor in\n//! the list. Elements can only be added when they are pinned, because moving the elements\n//! around would invalidate the pointers. Moreover, the [`Drop`][Drop] implementation of a linked\n//! list element will patch the pointers of its predecessor and successor to remove itself\n//! from the list.\n//!\n//! Crucially, we have to be able to rely on [`drop`] being called. If an element\n//! could be deallocated or otherwise invalidated without calling [`drop`], the pointers into it\n//! from its neighboring elements would become invalid, which would break the data structure.\n//!\n//! Therefore, pinning also comes with a [`drop`]-related guarantee.\n//!\n//! # `Drop` guarantee\n//!\n//! The purpose of pinning is to be able to rely on the placement of some data in memory.\n//! To make this work, not just moving the data is restricted; deallocating, repurposing, or\n//! otherwise invalidating the memory used to store the data is restricted, too.\n//! Concretely, for pinned data you have to maintain the invariant\n//! that *its memory will not get invalidated or repurposed from the moment it gets pinned until\n//! when [`drop`] is called*.  Only once [`drop`] returns or panics, the memory may be reused.\n//!\n//! Memory can be \"invalidated\" by deallocation, but also by\n//! replacing a <code>[Some]\\(v)</code> by [`None`], or calling [`Vec::set_len`] to \"kill\" some\n//! elements off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n//! calling the destructor first. None of this is allowed for pinned data without calling [`drop`].\n//!\n//! This is exactly the kind of guarantee that the intrusive linked list from the previous\n//! section needs to function correctly.\n//!\n//! Notice that this guarantee does *not* mean that memory does not leak! It is still\n//! completely okay not ever to call [`drop`] on a pinned element (e.g., you can still\n//! call [`mem::forget`] on a <code>[Pin]<[Box]\\<T>></code>). In the example of the doubly-linked\n//! list, that element would just stay in the list. However you may not free or reuse the storage\n//! *without calling [`drop`]*.\n//!\n//! # `Drop` implementation\n//!\n//! If your type uses pinning (such as the two examples above), you have to be careful\n//! when implementing [`Drop`][Drop]. The [`drop`] function takes <code>[&mut] self</code>, but this\n//! is called *even if your type was previously pinned*! It is as if the\n//! compiler automatically called [`Pin::get_unchecked_mut`].\n//!\n//! This can never cause a problem in safe code because implementing a type that\n//! relies on pinning requires unsafe code, but be aware that deciding to make\n//! use of pinning in your type (for example by implementing some operation on\n//! <code>[Pin]<[&]Self></code> or <code>[Pin]<[&mut] Self></code>) has consequences for your\n//! [`Drop`][Drop]implementation as well: if an element of your type could have been pinned,\n//! you must treat [`Drop`][Drop] as implicitly taking <code>[Pin]<[&mut] Self></code>.\n//!\n//! For example, you could implement [`Drop`][Drop] as follows:\n//!\n//! ```rust,no_run\n//! # use std::pin::Pin;\n//! # struct Type { }\n//! impl Drop for Type {\n//!     fn drop(&mut self) {\n//!         // `new_unchecked` is okay because we know this value is never used\n//!         // again after being dropped.\n//!         inner_drop(unsafe { Pin::new_unchecked(self)});\n//!         fn inner_drop(this: Pin<&mut Type>) {\n//!             // Actual drop code goes here.\n//!         }\n//!     }\n//! }\n//! ```\n//!\n//! The function `inner_drop` has the type that [`drop`] *should* have, so this makes sure that\n//! you do not accidentally use `self`/`this` in a way that is in conflict with pinning.\n//!\n//! Moreover, if your type is `#[repr(packed)]`, the compiler will automatically\n//! move fields around to be able to drop them. It might even do\n//! that for fields that happen to be sufficiently aligned. As a consequence, you cannot use\n//! pinning with a `#[repr(packed)]` type.\n//!\n//! # Projections and Structural Pinning\n//!\n//! When working with pinned structs, the question arises how one can access the\n//! fields of that struct in a method that takes just <code>[Pin]<[&mut] Struct></code>.\n//! The usual approach is to write helper methods (so called *projections*)\n//! that turn <code>[Pin]<[&mut] Struct></code> into a reference to the field, but what type should\n//! that reference have? Is it <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>?\n//! The same question arises with the fields of an `enum`, and also when considering\n//! container/wrapper types such as <code>[Vec]\\<T></code>, <code>[Box]\\<T></code>,\n//! or <code>[RefCell]\\<T></code>. (This question applies to both mutable and shared references,\n//! we just use the more common case of mutable references here for illustration.)\n//!\n//! It turns out that it is actually up to the author of the data structure to decide whether\n//! the pinned projection for a particular field turns <code>[Pin]<[&mut] Struct></code>\n//! into <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>. There are some\n//! constraints though, and the most important constraint is *consistency*:\n//! every field can be *either* projected to a pinned reference, *or* have\n//! pinning removed as part of the projection. If both are done for the same field,\n//! that will likely be unsound!\n//!\n//! As the author of a data structure you get to decide for each field whether pinning\n//! \"propagates\" to this field or not. Pinning that propagates is also called \"structural\",\n//! because it follows the structure of the type.\n//! In the following subsections, we describe the considerations that have to be made\n//! for either choice.\n//!\n//! ## Pinning *is not* structural for `field`\n//!\n//! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n//! but that is actually the easiest choice: if a <code>[Pin]<[&mut] Field></code> is never created,\n//! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n//! all you have to ensure is that you never create a pinned reference to that field.\n//!\n//! Fields without structural pinning may have a projection method that turns\n//! <code>[Pin]<[&mut] Struct></code> into <code>[&mut] Field</code>:\n//!\n//! ```rust,no_run\n//! # use std::pin::Pin;\n//! # type Field = i32;\n//! # struct Struct { field: Field }\n//! impl Struct {\n//!     fn pin_get_field(self: Pin<&mut Self>) -> &mut Field {\n//!         // This is okay because `field` is never considered pinned.\n//!         unsafe { &mut self.get_unchecked_mut().field }\n//!     }\n//! }\n//! ```\n//!\n//! You may also <code>impl [Unpin] for Struct</code> *even if* the type of `field`\n//! is not [`Unpin`]. What that type thinks about pinning is not relevant\n//! when no <code>[Pin]<[&mut] Field></code> is ever created.\n//!\n//! ## Pinning *is* structural for `field`\n//!\n//! The other option is to decide that pinning is \"structural\" for `field`,\n//! meaning that if the struct is pinned then so is the field.\n//!\n//! This allows writing a projection that creates a <code>[Pin]<[&mut] Field></code>, thus\n//! witnessing that the field is pinned:\n//!\n//! ```rust,no_run\n//! # use std::pin::Pin;\n//! # type Field = i32;\n//! # struct Struct { field: Field }\n//! impl Struct {\n//!     fn pin_get_field(self: Pin<&mut Self>) -> Pin<&mut Field> {\n//!         // This is okay because `field` is pinned when `self` is.\n//!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n//!     }\n//! }\n//! ```\n//!\n//! However, structural pinning comes with a few extra requirements:\n//!\n//! 1.  The struct must only be [`Unpin`] if all the structural fields are\n//!     [`Unpin`]. This is the default, but [`Unpin`] is a safe trait, so as the author of\n//!     the struct it is your responsibility *not* to add something like\n//!     <code>impl\\<T> [Unpin] for Struct\\<T></code>. (Notice that adding a projection operation\n//!     requires unsafe code, so the fact that [`Unpin`] is a safe trait does not break\n//!     the principle that you only have to worry about any of this if you use [`unsafe`].)\n//! 2.  The destructor of the struct must not move structural fields out of its argument. This\n//!     is the exact point that was raised in the [previous section][drop-impl]: [`drop`] takes\n//!     <code>[&mut] self</code>, but the struct (and hence its fields) might have been pinned\n//!     before. You have to guarantee that you do not move a field inside your [`Drop`][Drop]\n//!     implementation. In particular, as explained previously, this means that your struct\n//!     must *not* be `#[repr(packed)]`.\n//!     See that section for how to write [`drop`] in a way that the compiler can help you\n//!     not accidentally break pinning.\n//! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n//!     once your struct is pinned, the memory that contains the\n//!     content is not overwritten or deallocated without calling the content's destructors.\n//!     This can be tricky, as witnessed by <code>[VecDeque]\\<T></code>: the destructor of\n//!     <code>[VecDeque]\\<T></code> can fail to call [`drop`] on all elements if one of the\n//!     destructors panics. This violates the [`Drop`][Drop] guarantee, because it can lead to\n//!     elements being deallocated without their destructor being called.\n//!     (<code>[VecDeque]\\<T></code> has no pinning projections, so this\n//!     does not cause unsoundness.)\n//! 4.  You must not offer any other operations that could lead to data being moved out of\n//!     the structural fields when your type is pinned. For example, if the struct contains an\n//!     <code>[Option]\\<T></code> and there is a [`take`][Option::take]-like operation with type\n//!     <code>fn([Pin]<[&mut] Struct\\<T>>) -> [Option]\\<T></code>,\n//!     that operation can be used to move a `T` out of a pinned `Struct<T>` – which means\n//!     pinning cannot be structural for the field holding this data.\n//!\n//!     For a more complex example of moving data out of a pinned type,\n//!     imagine if <code>[RefCell]\\<T></code> had a method\n//!     <code>fn get_pin_mut(self: [Pin]<[&mut] Self>) -> [Pin]<[&mut] T></code>.\n//!     Then we could do the following:\n//!     ```compile_fail\n//!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>>) {\n//!         { let p = rc.as_mut().get_pin_mut(); } // Here we get pinned access to the `T`.\n//!         let rc_shr: &RefCell<T> = rc.into_ref().get_ref();\n//!         let b = rc_shr.borrow_mut();\n//!         let content = &mut *b; // And here we have `&mut T` to the same data.\n//!     }\n//!     ```\n//!     This is catastrophic, it means we can first pin the content of the\n//!     <code>[RefCell]\\<T></code> (using <code>[RefCell]::get_pin_mut</code>) and then move that\n//!     content using the mutable reference we got later.\n//!\n//! ## Examples\n//!\n//! For a type like <code>[Vec]\\<T></code>, both possibilities (structural pinning or not) make\n//! sense. A <code>[Vec]\\<T></code> with structural pinning could have `get_pin`/`get_pin_mut`\n//! methods to get pinned references to elements. However, it could *not* allow calling\n//! [`pop`][Vec::pop] on a pinned <code>[Vec]\\<T></code> because that would move the (structurally\n//! pinned) contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also\n//! move the contents.\n//!\n//! A <code>[Vec]\\<T></code> without structural pinning could\n//! <code>impl\\<T> [Unpin] for [Vec]\\<T></code>, because the contents are never pinned\n//! and the <code>[Vec]\\<T></code> itself is fine with being moved as well.\n//! At that point pinning just has no effect on the vector at all.\n//!\n//! In the standard library, pointer types generally do not have structural pinning,\n//! and thus they do not offer pinning projections. This is why <code>[Box]\\<T>: [Unpin]</code>\n//! holds for all `T`. It makes sense to do this for pointer types, because moving the\n//! <code>[Box]\\<T></code> does not actually move the `T`: the <code>[Box]\\<T></code> can be freely\n//! movable (aka [`Unpin`]) even if the `T` is not. In fact, even <code>[Pin]<[Box]\\<T>></code> and\n//! <code>[Pin]<[&mut] T></code> are always [`Unpin`] themselves, for the same reason:\n//! their contents (the `T`) are pinned, but the pointers themselves can be moved without moving\n//! the pinned data. For both <code>[Box]\\<T></code> and <code>[Pin]<[Box]\\<T>></code>,\n//! whether the content is pinned is entirely independent of whether the\n//! pointer is pinned, meaning pinning is *not* structural.\n//!\n//! When implementing a [`Future`] combinator, you will usually need structural pinning\n//! for the nested futures, as you need to get pinned references to them to call [`poll`].\n//! But if your combinator contains any other data that does not need to be pinned,\n//! you can make those fields not structural and hence freely access them with a\n//! mutable reference even when you just have <code>[Pin]<[&mut] Self></code> (such as in your own\n//! [`poll`] implementation).\n//!\n//! [Deref]: crate::ops::Deref \"ops::Deref\"\n//! [`Deref`]: crate::ops::Deref \"ops::Deref\"\n//! [Target]: crate::ops::Deref::Target \"ops::Deref::Target\"\n//! [`DerefMut`]: crate::ops::DerefMut \"ops::DerefMut\"\n//! [`mem::swap`]: crate::mem::swap \"mem::swap\"\n//! [`mem::forget`]: crate::mem::forget \"mem::forget\"\n//! [Vec]: ../../std/vec/struct.Vec.html \"Vec\"\n//! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len \"Vec::set_len\"\n//! [Box]: ../../std/boxed/struct.Box.html \"Box\"\n//! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop \"Vec::pop\"\n//! [Vec::push]: ../../std/vec/struct.Vec.html#method.push \"Vec::push\"\n//! [Rc]: ../../std/rc/struct.Rc.html \"rc::Rc\"\n//! [RefCell]: crate::cell::RefCell \"cell::RefCell\"\n//! [`drop`]: Drop::drop \"Drop::drop\"\n//! [VecDeque]: ../../std/collections/struct.VecDeque.html \"collections::VecDeque\"\n//! [`ptr::write`]: crate::ptr::write \"ptr::write\"\n//! [`Future`]: crate::future::Future \"future::Future\"\n//! [drop-impl]: #drop-implementation\n//! [drop-guarantee]: #drop-guarantee\n//! [`poll`]: crate::future::Future::poll \"future::Future::poll\"\n//! [&]: ../../std/primitive.reference.html \"shared reference\"\n//! [&mut]: ../../std/primitive.reference.html \"mutable reference\"\n//! [`unsafe`]: ../../std/keyword.unsafe.html \"keyword unsafe\"\n\n#![stable(feature = \"pin\", since = \"1.33.0\")]\n\nuse crate::cmp::{self, PartialEq, PartialOrd};\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\nuse crate::marker::{Sized, Unpin};\nuse crate::ops::{CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Receiver};\n\n/// A pinned pointer.\n///\n/// This is a wrapper around a kind of pointer which makes that pointer \"pin\" its\n/// value in place, preventing the value referenced by that pointer from being moved\n/// unless it implements [`Unpin`].\n///\n/// *See the [`pin` module] documentation for an explanation of pinning.*\n///\n/// [`pin` module]: self\n//\n// Note: the `Clone` derive below causes unsoundness as it's possible to implement\n// `Clone` for mutable references.\n// See <https://internals.rust-lang.org/t/unsoundness-in-pin/11311> for more details.\n#[stable(feature = \"pin\", since = \"1.33.0\")]\n#[lang = \"pin\"]\n#[fundamental]\n#[repr(transparent)]\n#[derive(Copy, Clone)]\npub struct Pin<P> {\n    pointer: P,\n}\n\n// The following implementations aren't derived in order to avoid soundness\n// issues. `&self.pointer` should not be accessible to untrusted trait\n// implementations.\n//\n// See <https://internals.rust-lang.org/t/unsoundness-in-pin/11311/73> for more details.\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref, Q: Deref> PartialEq<Pin<Q>> for Pin<P>\nwhere\n    P::Target: PartialEq<Q::Target>,\n{\n    fn eq(&self, other: &Pin<Q>) -> bool {\n        P::Target::eq(self, other)\n    }\n\n    fn ne(&self, other: &Pin<Q>) -> bool {\n        P::Target::ne(self, other)\n    }\n}\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref<Target: Eq>> Eq for Pin<P> {}\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref, Q: Deref> PartialOrd<Pin<Q>> for Pin<P>\nwhere\n    P::Target: PartialOrd<Q::Target>,\n{\n    fn partial_cmp(&self, other: &Pin<Q>) -> Option<cmp::Ordering> {\n        P::Target::partial_cmp(self, other)\n    }\n\n    fn lt(&self, other: &Pin<Q>) -> bool {\n        P::Target::lt(self, other)\n    }\n\n    fn le(&self, other: &Pin<Q>) -> bool {\n        P::Target::le(self, other)\n    }\n\n    fn gt(&self, other: &Pin<Q>) -> bool {\n        P::Target::gt(self, other)\n    }\n\n    fn ge(&self, other: &Pin<Q>) -> bool {\n        P::Target::ge(self, other)\n    }\n}\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref<Target: Ord>> Ord for Pin<P> {\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n        P::Target::cmp(self, other)\n    }\n}\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref<Target: Hash>> Hash for Pin<P> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        P::Target::hash(self, state);\n    }\n}\n\nimpl<P: Deref<Target: Unpin>> Pin<P> {\n    /// Construct a new `Pin<P>` around a pointer to some data of a type that\n    /// implements [`Unpin`].\n    ///\n    /// Unlike `Pin::new_unchecked`, this method is safe because the pointer\n    /// `P` dereferences to an [`Unpin`] type, which cancels the pinning guarantees.\n    #[inline(always)]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub const fn new(pointer: P) -> Pin<P> {\n        // SAFETY: the value pointed to is `Unpin`, and so has no requirements\n        // around pinning.\n        unsafe { Pin::new_unchecked(pointer) }\n    }\n\n    /// Unwraps this `Pin<P>` returning the underlying pointer.\n    ///\n    /// This requires that the data inside this `Pin` is [`Unpin`] so that we\n    /// can ignore the pinning invariants when unwrapping it.\n    #[inline(always)]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n    pub const fn into_inner(pin: Pin<P>) -> P {\n        pin.pointer\n    }\n}\n\nimpl<P: Deref> Pin<P> {\n    /// Construct a new `Pin<P>` around a reference to some data of a type that\n    /// may or may not implement `Unpin`.\n    ///\n    /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n    /// instead.\n    ///\n    /// # Safety\n    ///\n    /// This constructor is unsafe because we cannot guarantee that the data\n    /// pointed to by `pointer` is pinned, meaning that the data will not be moved or\n    /// its storage invalidated until it gets dropped. If the constructed `Pin<P>` does\n    /// not guarantee that the data `P` points to is pinned, that is a violation of\n    /// the API contract and may lead to undefined behavior in later (safe) operations.\n    ///\n    /// By using this method, you are making a promise about the `P::Deref` and\n    /// `P::DerefMut` implementations, if they exist. Most importantly, they\n    /// must not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref`\n    /// will call `DerefMut::deref_mut` and `Deref::deref` *on the pinned pointer*\n    /// and expect these methods to uphold the pinning invariants.\n    /// Moreover, by calling this method you promise that the reference `P`\n    /// dereferences to will not be moved out of again; in particular, it\n    /// must not be possible to obtain a `&mut P::Target` and then\n    /// move out of that reference (using, for example [`mem::swap`]).\n    ///\n    /// For example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because\n    /// while you are able to pin it for the given lifetime `'a`, you have no control\n    /// over whether it is kept pinned once `'a` ends:\n    /// ```\n    /// use std::mem;\n    /// use std::pin::Pin;\n    ///\n    /// fn move_pinned_ref<T>(mut a: T, mut b: T) {\n    ///     unsafe {\n    ///         let p: Pin<&mut T> = Pin::new_unchecked(&mut a);\n    ///         // This should mean the pointee `a` can never move again.\n    ///     }\n    ///     mem::swap(&mut a, &mut b);\n    ///     // The address of `a` changed to `b`'s stack slot, so `a` got moved even\n    ///     // though we have previously pinned it! We have violated the pinning API contract.\n    /// }\n    /// ```\n    /// A value, once pinned, must remain pinned forever (unless its type implements `Unpin`).\n    ///\n    /// Similarly, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be\n    /// aliases to the same data that are not subject to the pinning restrictions:\n    /// ```\n    /// use std::rc::Rc;\n    /// use std::pin::Pin;\n    ///\n    /// fn move_pinned_rc<T>(mut x: Rc<T>) {\n    ///     let pinned = unsafe { Pin::new_unchecked(Rc::clone(&x)) };\n    ///     {\n    ///         let p: Pin<&T> = pinned.as_ref();\n    ///         // This should mean the pointee can never move again.\n    ///     }\n    ///     drop(pinned);\n    ///     let content = Rc::get_mut(&mut x).unwrap();\n    ///     // Now, if `x` was the only reference, we have a mutable reference to\n    ///     // data that we pinned above, which we could use to move it as we have\n    ///     // seen in the previous example. We have violated the pinning API contract.\n    ///  }\n    ///  ```\n    ///\n    /// [`mem::swap`]: crate::mem::swap\n    #[lang = \"new_unchecked\"]\n    #[inline(always)]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub const unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n        Pin { pointer }\n    }\n\n    /// Gets a pinned shared reference from this pinned pointer.\n    ///\n    /// This is a generic method to go from `&Pin<Pointer<T>>` to `Pin<&T>`.\n    /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n    /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n    /// \"Malicious\" implementations of `Pointer::Deref` are likewise\n    /// ruled out by the contract of `Pin::new_unchecked`.\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn as_ref(&self) -> Pin<&P::Target> {\n        // SAFETY: see documentation on this function\n        unsafe { Pin::new_unchecked(&*self.pointer) }\n    }\n\n    /// Unwraps this `Pin<P>` returning the underlying pointer.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe. You must guarantee that you will continue to\n    /// treat the pointer `P` as pinned after you call this function, so that\n    /// the invariants on the `Pin` type can be upheld. If the code using the\n    /// resulting `P` does not continue to maintain the pinning invariants that\n    /// is a violation of the API contract and may lead to undefined behavior in\n    /// later (safe) operations.\n    ///\n    /// If the underlying data is [`Unpin`], [`Pin::into_inner`] should be used\n    /// instead.\n    #[inline(always)]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n    pub const unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {\n        pin.pointer\n    }\n}\n\nimpl<P: DerefMut> Pin<P> {\n    /// Gets a pinned mutable reference from this pinned pointer.\n    ///\n    /// This is a generic method to go from `&mut Pin<Pointer<T>>` to `Pin<&mut T>`.\n    /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n    /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n    /// \"Malicious\" implementations of `Pointer::DerefMut` are likewise\n    /// ruled out by the contract of `Pin::new_unchecked`.\n    ///\n    /// This method is useful when doing multiple calls to functions that consume the pinned type.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::pin::Pin;\n    ///\n    /// # struct Type {}\n    /// impl Type {\n    ///     fn method(self: Pin<&mut Self>) {\n    ///         // do something\n    ///     }\n    ///\n    ///     fn call_method_twice(mut self: Pin<&mut Self>) {\n    ///         // `method` consumes `self`, so reborrow the `Pin<&mut Self>` via `as_mut`.\n    ///         self.as_mut().method();\n    ///         self.as_mut().method();\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn as_mut(&mut self) -> Pin<&mut P::Target> {\n        // SAFETY: see documentation on this function\n        unsafe { Pin::new_unchecked(&mut *self.pointer) }\n    }\n\n    /// Assigns a new value to the memory behind the pinned reference.\n    ///\n    /// This overwrites pinned data, but that is okay: its destructor gets\n    /// run before being overwritten, so no pinning guarantee is violated.\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn set(&mut self, value: P::Target)\n    where\n        P::Target: Sized,\n    {\n        *(self.pointer) = value;\n    }\n}\n\nimpl<'a, T: ?Sized> Pin<&'a T> {\n    /// Constructs a new pin by mapping the interior value.\n    ///\n    /// For example, if you  wanted to get a `Pin` of a field of something,\n    /// you could use this to get access to that field in one line of code.\n    /// However, there are several gotchas with these \"pinning projections\";\n    /// see the [`pin` module] documentation for further details on that topic.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe. You must guarantee that the data you return\n    /// will not move so long as the argument value does not move (for example,\n    /// because it is one of the fields of that value), and also that you do\n    /// not move out of the argument you receive to the interior function.\n    ///\n    /// [`pin` module]: self#projections-and-structural-pinning\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U>\n    where\n        U: ?Sized,\n        F: FnOnce(&T) -> &U,\n    {\n        let pointer = &*self.pointer;\n        let new_pointer = func(pointer);\n\n        // SAFETY: the safety contract for `new_unchecked` must be\n        // upheld by the caller.\n        unsafe { Pin::new_unchecked(new_pointer) }\n    }\n\n    /// Gets a shared reference out of a pin.\n    ///\n    /// This is safe because it is not possible to move out of a shared reference.\n    /// It may seem like there is an issue here with interior mutability: in fact,\n    /// it *is* possible to move a `T` out of a `&RefCell<T>`. However, this is\n    /// not a problem as long as there does not also exist a `Pin<&T>` pointing\n    /// to the same data, and `RefCell<T>` does not let you create a pinned reference\n    /// to its contents. See the discussion on [\"pinning projections\"] for further\n    /// details.\n    ///\n    /// Note: `Pin` also implements `Deref` to the target, which can be used\n    /// to access the inner value. However, `Deref` only provides a reference\n    /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n    /// the `Pin` itself. This method allows turning the `Pin` into a reference\n    /// with the same lifetime as the original `Pin`.\n    ///\n    /// [\"pinning projections\"]: self#projections-and-structural-pinning\n    #[inline(always)]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub const fn get_ref(self) -> &'a T {\n        self.pointer\n    }\n}\n\nimpl<'a, T: ?Sized> Pin<&'a mut T> {\n    /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n    #[inline(always)]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub const fn into_ref(self) -> Pin<&'a T> {\n        Pin { pointer: self.pointer }\n    }\n\n    /// Gets a mutable reference to the data inside of this `Pin`.\n    ///\n    /// This requires that the data inside this `Pin` is `Unpin`.\n    ///\n    /// Note: `Pin` also implements `DerefMut` to the data, which can be used\n    /// to access the inner value. However, `DerefMut` only provides a reference\n    /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n    /// the `Pin` itself. This method allows turning the `Pin` into a reference\n    /// with the same lifetime as the original `Pin`.\n    #[inline(always)]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    pub const fn get_mut(self) -> &'a mut T\n    where\n        T: Unpin,\n    {\n        self.pointer\n    }\n\n    /// Gets a mutable reference to the data inside of this `Pin`.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe. You must guarantee that you will never move\n    /// the data out of the mutable reference you receive when you call this\n    /// function, so that the invariants on the `Pin` type can be upheld.\n    ///\n    /// If the underlying data is `Unpin`, `Pin::get_mut` should be used\n    /// instead.\n    #[inline(always)]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    pub const unsafe fn get_unchecked_mut(self) -> &'a mut T {\n        self.pointer\n    }\n\n    /// Construct a new pin by mapping the interior value.\n    ///\n    /// For example, if you  wanted to get a `Pin` of a field of something,\n    /// you could use this to get access to that field in one line of code.\n    /// However, there are several gotchas with these \"pinning projections\";\n    /// see the [`pin` module] documentation for further details on that topic.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe. You must guarantee that the data you return\n    /// will not move so long as the argument value does not move (for example,\n    /// because it is one of the fields of that value), and also that you do\n    /// not move out of the argument you receive to the interior function.\n    ///\n    /// [`pin` module]: self#projections-and-structural-pinning\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U>\n    where\n        U: ?Sized,\n        F: FnOnce(&mut T) -> &mut U,\n    {\n        // SAFETY: the caller is responsible for not moving the\n        // value out of this reference.\n        let pointer = unsafe { Pin::get_unchecked_mut(self) };\n        let new_pointer = func(pointer);\n        // SAFETY: as the value of `this` is guaranteed to not have\n        // been moved out, this call to `new_unchecked` is safe.\n        unsafe { Pin::new_unchecked(new_pointer) }\n    }\n}\n\nimpl<T: ?Sized> Pin<&'static T> {\n    /// Get a pinned reference from a static reference.\n    ///\n    /// This is safe, because `T` is borrowed for the `'static` lifetime, which\n    /// never ends.\n    #[unstable(feature = \"pin_static_ref\", issue = \"78186\")]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    pub const fn static_ref(r: &'static T) -> Pin<&'static T> {\n        // SAFETY: The 'static borrow guarantees the data will not be\n        // moved/invalidated until it gets dropped (which is never).\n        unsafe { Pin::new_unchecked(r) }\n    }\n}\n\nimpl<T: ?Sized> Pin<&'static mut T> {\n    /// Get a pinned mutable reference from a static mutable reference.\n    ///\n    /// This is safe, because `T` is borrowed for the `'static` lifetime, which\n    /// never ends.\n    #[unstable(feature = \"pin_static_ref\", issue = \"78186\")]\n    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n    pub const fn static_mut(r: &'static mut T) -> Pin<&'static mut T> {\n        // SAFETY: The 'static borrow guarantees the data will not be\n        // moved/invalidated until it gets dropped (which is never).\n        unsafe { Pin::new_unchecked(r) }\n    }\n}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<P: Deref> Deref for Pin<P> {\n    type Target = P::Target;\n    fn deref(&self) -> &P::Target {\n        Pin::get_ref(Pin::as_ref(self))\n    }\n}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<P: DerefMut<Target: Unpin>> DerefMut for Pin<P> {\n    fn deref_mut(&mut self) -> &mut P::Target {\n        Pin::get_mut(Pin::as_mut(self))\n    }\n}\n\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\nimpl<P: Receiver> Receiver for Pin<P> {}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<P: fmt::Debug> fmt::Debug for Pin<P> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.pointer, f)\n    }\n}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<P: fmt::Display> fmt::Display for Pin<P> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(&self.pointer, f)\n    }\n}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<P: fmt::Pointer> fmt::Pointer for Pin<P> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Pointer::fmt(&self.pointer, f)\n    }\n}\n\n// Note: this means that any impl of `CoerceUnsized` that allows coercing from\n// a type that impls `Deref<Target=impl !Unpin>` to a type that impls\n// `Deref<Target=Unpin>` is unsound. Any such impl would probably be unsound\n// for other reasons, though, so we just need to take care not to allow such\n// impls to land in std.\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<P, U> CoerceUnsized<Pin<U>> for Pin<P> where P: CoerceUnsized<U> {}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n"],[2829,"//! Functionality for ordering and comparison.\n//!\n//! This module contains various tools for ordering and comparing values. In\n//! summary:\n//!\n//! * [`Eq`] and [`PartialEq`] are traits that allow you to define total and\n//!   partial equality between values, respectively. Implementing them overloads\n//!   the `==` and `!=` operators.\n//! * [`Ord`] and [`PartialOrd`] are traits that allow you to define total and\n//!   partial orderings between values, respectively. Implementing them overloads\n//!   the `<`, `<=`, `>`, and `>=` operators.\n//! * [`Ordering`] is an enum returned by the main functions of [`Ord`] and\n//!   [`PartialOrd`], and describes an ordering.\n//! * [`Reverse`] is a struct that allows you to easily reverse an ordering.\n//! * [`max`] and [`min`] are functions that build off of [`Ord`] and allow you\n//!   to find the maximum or minimum of two values.\n//!\n//! For more details, see the respective documentation of each item in the list.\n//!\n//! [`max`]: Ord::max\n//! [`min`]: Ord::min\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse self::Ordering::*;\n\n/// Trait for equality comparisons which are [partial equivalence\n/// relations](https://en.wikipedia.org/wiki/Partial_equivalence_relation).\n///\n/// `x.eq(y)` can also be written `x == y`, and `x.ne(y)` can be written `x != y`.\n/// We use the easier-to-read infix notation in the remainder of this documentation.\n///\n/// This trait allows for partial equality, for types that do not have a full\n/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n/// so floating point types implement `PartialEq` but not [`trait@Eq`].\n///\n/// Implementations must ensure that `eq` and `ne` are consistent with each other:\n///\n/// - `a != b` if and only if `!(a == b)`\n///   (ensured by the default implementation).\n///\n/// If [`PartialOrd`] or [`Ord`] are also implemented for `Self` and `Rhs`, their methods must also\n/// be consistent with `PartialEq` (see the documentation of those traits for the exact\n/// requirements). It's easy to accidentally make them disagree by deriving some of the traits and\n/// manually implementing others.\n///\n/// The equality relation `==` must satisfy the following conditions\n/// (for all `a`, `b`, `c` of type `A`, `B`, `C`):\n///\n/// - **Symmetric**: if `A: PartialEq<B>` and `B: PartialEq<A>`, then **`a == b`\n///   implies `b == a`**; and\n///\n/// - **Transitive**: if `A: PartialEq<B>` and `B: PartialEq<C>` and `A:\n///   PartialEq<C>`, then **`a == b` and `b == c` implies `a == c`**.\n///\n/// Note that the `B: PartialEq<A>` (symmetric) and `A: PartialEq<C>`\n/// (transitive) impls are not forced to exist, but these requirements apply\n/// whenever they do exist.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, two\n/// instances are equal if all fields are equal, and not equal if any fields\n/// are not equal. When `derive`d on enums, each variant is equal to itself\n/// and not equal to the other variants.\n///\n/// ## How can I implement `PartialEq`?\n///\n/// An example implementation for a domain in which two books are considered\n/// the same book if their ISBN matches, even if the formats differ:\n///\n/// ```\n/// enum BookFormat {\n///     Paperback,\n///     Hardback,\n///     Ebook,\n/// }\n///\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n///\n/// impl PartialEq for Book {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.isbn == other.isbn\n///     }\n/// }\n///\n/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };\n/// let b2 = Book { isbn: 3, format: BookFormat::Ebook };\n/// let b3 = Book { isbn: 10, format: BookFormat::Paperback };\n///\n/// assert!(b1 == b2);\n/// assert!(b1 != b3);\n/// ```\n///\n/// ## How can I compare two different types?\n///\n/// The type you can compare with is controlled by `PartialEq`'s type parameter.\n/// For example, let's tweak our previous code a bit:\n///\n/// ```\n/// // The derive implements <BookFormat> == <BookFormat> comparisons\n/// #[derive(PartialEq)]\n/// enum BookFormat {\n///     Paperback,\n///     Hardback,\n///     Ebook,\n/// }\n///\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n///\n/// // Implement <Book> == <BookFormat> comparisons\n/// impl PartialEq<BookFormat> for Book {\n///     fn eq(&self, other: &BookFormat) -> bool {\n///         self.format == *other\n///     }\n/// }\n///\n/// // Implement <BookFormat> == <Book> comparisons\n/// impl PartialEq<Book> for BookFormat {\n///     fn eq(&self, other: &Book) -> bool {\n///         *self == other.format\n///     }\n/// }\n///\n/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };\n///\n/// assert!(b1 == BookFormat::Paperback);\n/// assert!(BookFormat::Ebook != b1);\n/// ```\n///\n/// By changing `impl PartialEq for Book` to `impl PartialEq<BookFormat> for Book`,\n/// we allow `BookFormat`s to be compared with `Book`s.\n///\n/// A comparison like the one above, which ignores some fields of the struct,\n/// can be dangerous. It can easily lead to an unintended violation of the\n/// requirements for a partial equivalence relation. For example, if we kept\n/// the above implementation of `PartialEq<Book>` for `BookFormat` and added an\n/// implementation of `PartialEq<Book>` for `Book` (either via a `#[derive]` or\n/// via the manual implementation from the first example) then the result would\n/// violate transitivity:\n///\n/// ```should_panic\n/// #[derive(PartialEq)]\n/// enum BookFormat {\n///     Paperback,\n///     Hardback,\n///     Ebook,\n/// }\n///\n/// #[derive(PartialEq)]\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n///\n/// impl PartialEq<BookFormat> for Book {\n///     fn eq(&self, other: &BookFormat) -> bool {\n///         self.format == *other\n///     }\n/// }\n///\n/// impl PartialEq<Book> for BookFormat {\n///     fn eq(&self, other: &Book) -> bool {\n///         *self == other.format\n///     }\n/// }\n///\n/// fn main() {\n///     let b1 = Book { isbn: 1, format: BookFormat::Paperback };\n///     let b2 = Book { isbn: 2, format: BookFormat::Paperback };\n///\n///     assert!(b1 == BookFormat::Paperback);\n///     assert!(BookFormat::Paperback == b2);\n///\n///     // The following should hold by transitivity but doesn't.\n///     assert!(b1 == b2); // <-- PANICS\n/// }\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// let x: u32 = 0;\n/// let y: u32 = 1;\n///\n/// assert_eq!(x == y, false);\n/// assert_eq!(x.eq(&y), false);\n/// ```\n///\n/// [`eq`]: PartialEq::eq\n/// [`ne`]: PartialEq::ne\n#[lang = \"eq\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \"==\")]\n#[doc(alias = \"!=\")]\n#[rustc_on_unimplemented(\n    message = \"can't compare `{Self}` with `{Rhs}`\",\n    label = \"no implementation for `{Self} == {Rhs}`\"\n)]\npub trait PartialEq<Rhs: ?Sized = Self> {\n    /// This method tests for `self` and `other` values to be equal, and is used\n    /// by `==`.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn eq(&self, other: &Rhs) -> bool;\n\n    /// This method tests for `!=`.\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn ne(&self, other: &Rhs) -> bool {\n        !self.eq(other)\n    }\n}\n\n/// Derive macro generating an impl of the trait `PartialEq`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics, structural_match)]\npub macro PartialEq($item:item) {\n    /* compiler built-in */\n}\n\n/// Trait for equality comparisons which are [equivalence relations](\n/// https://en.wikipedia.org/wiki/Equivalence_relation).\n///\n/// This means, that in addition to `a == b` and `a != b` being strict inverses, the equality must\n/// be (for all `a`, `b` and `c`):\n///\n/// - reflexive: `a == a`;\n/// - symmetric: `a == b` implies `b == a`; and\n/// - transitive: `a == b` and `b == c` implies `a == c`.\n///\n/// This property cannot be checked by the compiler, and therefore `Eq` implies\n/// [`PartialEq`], and has no extra methods.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d, because `Eq` has\n/// no extra methods, it is only informing the compiler that this is an\n/// equivalence relation rather than a partial equivalence relation. Note that\n/// the `derive` strategy requires all fields are `Eq`, which isn't\n/// always desired.\n///\n/// ## How can I implement `Eq`?\n///\n/// If you cannot use the `derive` strategy, specify that your type implements\n/// `Eq`, which has no methods:\n///\n/// ```\n/// enum BookFormat { Paperback, Hardback, Ebook }\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n/// impl PartialEq for Book {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.isbn == other.isbn\n///     }\n/// }\n/// impl Eq for Book {}\n/// ```\n#[doc(alias = \"==\")]\n#[doc(alias = \"!=\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Eq: PartialEq<Self> {\n    // this method is used solely by #[deriving] to assert\n    // that every component of a type implements #[deriving]\n    // itself, the current deriving infrastructure means doing this\n    // assertion without using a method on this trait is nearly\n    // impossible.\n    //\n    // This should never be implemented by hand.\n    #[doc(hidden)]\n    #[no_coverage] // rust-lang/rust#84605\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn assert_receiver_is_total_eq(&self) {}\n}\n\n/// Derive macro generating an impl of the trait `Eq`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics, derive_eq, structural_match, no_coverage)]\npub macro Eq($item:item) {\n    /* compiler built-in */\n}\n\n// FIXME: this struct is used solely by #[derive] to\n// assert that every component of a type implements Eq.\n//\n// This struct should never appear in user code.\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"derive_eq\", reason = \"deriving hack, should not be public\", issue = \"none\")]\npub struct AssertParamIsEq<T: Eq + ?Sized> {\n    _field: crate::marker::PhantomData<T>,\n}\n\n/// An `Ordering` is the result of a comparison between two values.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// let result = 1.cmp(&2);\n/// assert_eq!(Ordering::Less, result);\n///\n/// let result = 1.cmp(&1);\n/// assert_eq!(Ordering::Equal, result);\n///\n/// let result = 2.cmp(&1);\n/// assert_eq!(Ordering::Greater, result);\n/// ```\n#[derive(Clone, Copy, PartialEq, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Ordering {\n    /// An ordering where a compared value is less than another.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Less = -1,\n    /// An ordering where a compared value is equal to another.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Equal = 0,\n    /// An ordering where a compared value is greater than another.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Greater = 1,\n}\n\nimpl Ordering {\n    /// Returns `true` if the ordering is the `Equal` variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.is_eq(), false);\n    /// assert_eq!(Ordering::Equal.is_eq(), true);\n    /// assert_eq!(Ordering::Greater.is_eq(), false);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[rustc_const_stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    #[stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    pub const fn is_eq(self) -> bool {\n        matches!(self, Equal)\n    }\n\n    /// Returns `true` if the ordering is not the `Equal` variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.is_ne(), true);\n    /// assert_eq!(Ordering::Equal.is_ne(), false);\n    /// assert_eq!(Ordering::Greater.is_ne(), true);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[rustc_const_stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    #[stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    pub const fn is_ne(self) -> bool {\n        !matches!(self, Equal)\n    }\n\n    /// Returns `true` if the ordering is the `Less` variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.is_lt(), true);\n    /// assert_eq!(Ordering::Equal.is_lt(), false);\n    /// assert_eq!(Ordering::Greater.is_lt(), false);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[rustc_const_stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    #[stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    pub const fn is_lt(self) -> bool {\n        matches!(self, Less)\n    }\n\n    /// Returns `true` if the ordering is the `Greater` variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.is_gt(), false);\n    /// assert_eq!(Ordering::Equal.is_gt(), false);\n    /// assert_eq!(Ordering::Greater.is_gt(), true);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[rustc_const_stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    #[stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    pub const fn is_gt(self) -> bool {\n        matches!(self, Greater)\n    }\n\n    /// Returns `true` if the ordering is either the `Less` or `Equal` variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.is_le(), true);\n    /// assert_eq!(Ordering::Equal.is_le(), true);\n    /// assert_eq!(Ordering::Greater.is_le(), false);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[rustc_const_stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    #[stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    pub const fn is_le(self) -> bool {\n        !matches!(self, Greater)\n    }\n\n    /// Returns `true` if the ordering is either the `Greater` or `Equal` variant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.is_ge(), false);\n    /// assert_eq!(Ordering::Equal.is_ge(), true);\n    /// assert_eq!(Ordering::Greater.is_ge(), true);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[rustc_const_stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    #[stable(feature = \"ordering_helpers\", since = \"1.53.0\")]\n    pub const fn is_ge(self) -> bool {\n        !matches!(self, Less)\n    }\n\n    /// Reverses the `Ordering`.\n    ///\n    /// * `Less` becomes `Greater`.\n    /// * `Greater` becomes `Less`.\n    /// * `Equal` becomes `Equal`.\n    ///\n    /// # Examples\n    ///\n    /// Basic behavior:\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.reverse(), Ordering::Greater);\n    /// assert_eq!(Ordering::Equal.reverse(), Ordering::Equal);\n    /// assert_eq!(Ordering::Greater.reverse(), Ordering::Less);\n    /// ```\n    ///\n    /// This method can be used to reverse a comparison:\n    ///\n    /// ```\n    /// let data: &mut [_] = &mut [2, 10, 5, 8];\n    ///\n    /// // sort the array from largest to smallest.\n    /// data.sort_by(|a, b| a.cmp(b).reverse());\n    ///\n    /// let b: &mut [_] = &mut [10, 8, 5, 2];\n    /// assert!(data == b);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[rustc_const_stable(feature = \"const_ordering\", since = \"1.48.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn reverse(self) -> Ordering {\n        match self {\n            Less => Greater,\n            Equal => Equal,\n            Greater => Less,\n        }\n    }\n\n    /// Chains two orderings.\n    ///\n    /// Returns `self` when it's not `Equal`. Otherwise returns `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = Ordering::Equal.then(Ordering::Less);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then(Ordering::Equal);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then(Ordering::Greater);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Equal.then(Ordering::Equal);\n    /// assert_eq!(result, Ordering::Equal);\n    ///\n    /// let x: (i64, i64, i64) = (1, 2, 7);\n    /// let y: (i64, i64, i64) = (1, 5, 3);\n    /// let result = x.0.cmp(&y.0).then(x.1.cmp(&y.1)).then(x.2.cmp(&y.2));\n    ///\n    /// assert_eq!(result, Ordering::Less);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[rustc_const_stable(feature = \"const_ordering\", since = \"1.48.0\")]\n    #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n    pub const fn then(self, other: Ordering) -> Ordering {\n        match self {\n            Equal => other,\n            _ => self,\n        }\n    }\n\n    /// Chains the ordering with the given function.\n    ///\n    /// Returns `self` when it's not `Equal`. Otherwise calls `f` and returns\n    /// the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = Ordering::Equal.then_with(|| Ordering::Less);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then_with(|| Ordering::Equal);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then_with(|| Ordering::Greater);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Equal.then_with(|| Ordering::Equal);\n    /// assert_eq!(result, Ordering::Equal);\n    ///\n    /// let x: (i64, i64, i64) = (1, 2, 7);\n    /// let y: (i64, i64, i64) = (1, 5, 3);\n    /// let result = x.0.cmp(&y.0).then_with(|| x.1.cmp(&y.1)).then_with(|| x.2.cmp(&y.2));\n    ///\n    /// assert_eq!(result, Ordering::Less);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n    pub fn then_with<F: FnOnce() -> Ordering>(self, f: F) -> Ordering {\n        match self {\n            Equal => f(),\n            _ => self,\n        }\n    }\n}\n\n/// A helper struct for reverse ordering.\n///\n/// This struct is a helper to be used with functions like [`Vec::sort_by_key`] and\n/// can be used to reverse order a part of a key.\n///\n/// [`Vec::sort_by_key`]: ../../std/vec/struct.Vec.html#method.sort_by_key\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp::Reverse;\n///\n/// let mut v = vec![1, 2, 3, 4, 5, 6];\n/// v.sort_by_key(|&num| (num > 3, Reverse(num)));\n/// assert_eq!(v, vec![3, 2, 1, 6, 5, 4]);\n/// ```\n#[derive(PartialEq, Eq, Debug, Copy, Default, Hash)]\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n#[repr(transparent)]\npub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n}\n\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\nimpl<T: Clone> Clone for Reverse<T> {\n    #[inline]\n    fn clone(&self) -> Reverse<T> {\n        Reverse(self.0.clone())\n    }\n\n    #[inline]\n    fn clone_from(&mut self, other: &Self) {\n        self.0.clone_from(&other.0)\n    }\n}\n\n/// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n///\n/// Implementations must be consistent with the [`PartialOrd`] implementation, and ensure\n/// `max`, `min`, and `clamp` are consistent with `cmp`:\n///\n/// - `partial_cmp(a, b) == Some(cmp(a, b))`.\n/// - `max(a, b) == max_by(a, b, cmp)` (ensured by the default implementation).\n/// - `min(a, b) == min_by(a, b, cmp)` (ensured by the default implementation).\n/// - For `a.clamp(min, max)`, see the [method docs](#method.clamp)\n///   (ensured by the default implementation).\n///\n/// It's easy to accidentally make `cmp` and `partial_cmp` disagree by\n/// deriving some of the traits and manually implementing others.\n///\n/// ## Corollaries\n///\n/// From the above and the requirements of `PartialOrd`, it follows that `<` defines a strict total order.\n/// This means that for all `a`, `b` and `c`:\n///\n/// - exactly one of `a < b`, `a == b` or `a > b` is true; and\n/// - `<` is transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n/// [lexicographic](https://en.wikipedia.org/wiki/Lexicographic_order) ordering based on the top-to-bottom declaration order of the struct's members.\n/// When `derive`d on enums, variants are ordered by their top-to-bottom discriminant order.\n///\n/// ## Lexicographical comparison\n///\n/// Lexicographical comparison is an operation with the following properties:\n///  - Two sequences are compared element by element.\n///  - The first mismatching element defines which sequence is lexicographically less or greater than the other.\n///  - If one sequence is a prefix of another, the shorter sequence is lexicographically less than the other.\n///  - If two sequence have equivalent elements and are of the same length, then the sequences are lexicographically equal.\n///  - An empty sequence is lexicographically less than any non-empty sequence.\n///  - Two empty sequences are lexicographically equal.\n///\n/// ## How can I implement `Ord`?\n///\n/// `Ord` requires that the type also be [`PartialOrd`] and [`Eq`] (which requires [`PartialEq`]).\n///\n/// Then you must define an implementation for [`cmp`]. You may find it useful to use\n/// [`cmp`] on your type's fields.\n///\n/// Here's an example where you want to sort people by height only, disregarding `id`\n/// and `name`:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// #[derive(Eq)]\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: u32,\n/// }\n///\n/// impl Ord for Person {\n///     fn cmp(&self, other: &Self) -> Ordering {\n///         self.height.cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n///         Some(self.cmp(other))\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n///\n/// [`cmp`]: Ord::cmp\n#[doc(alias = \"<\")]\n#[doc(alias = \">\")]\n#[doc(alias = \"<=\")]\n#[doc(alias = \">=\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Ord: Eq + PartialOrd<Self> {\n    /// This method returns an [`Ordering`] between `self` and `other`.\n    ///\n    /// By convention, `self.cmp(&other)` returns the ordering matching the expression\n    /// `self <operator> other` if true.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(5.cmp(&10), Ordering::Less);\n    /// assert_eq!(10.cmp(&5), Ordering::Greater);\n    /// assert_eq!(5.cmp(&5), Ordering::Equal);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn cmp(&self, other: &Self) -> Ordering;\n\n    /// Compares and returns the maximum of two values.\n    ///\n    /// Returns the second argument if the comparison determines them to be equal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(2, 1.max(2));\n    /// assert_eq!(2, 2.max(2));\n    /// ```\n    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n    #[inline]\n    #[must_use]\n    fn max(self, other: Self) -> Self\n    where\n        Self: Sized,\n    {\n        max_by(self, other, Ord::cmp)\n    }\n\n    /// Compares and returns the minimum of two values.\n    ///\n    /// Returns the first argument if the comparison determines them to be equal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(1, 1.min(2));\n    /// assert_eq!(2, 2.min(2));\n    /// ```\n    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n    #[inline]\n    #[must_use]\n    fn min(self, other: Self) -> Self\n    where\n        Self: Sized,\n    {\n        min_by(self, other, Ord::cmp)\n    }\n\n    /// Restrict a value to a certain interval.\n    ///\n    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n    /// less than `min`. Otherwise this returns `self`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `min > max`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!((-3).clamp(-2, 1) == -2);\n    /// assert!(0.clamp(-2, 1) == 0);\n    /// assert!(2.clamp(-2, 1) == 1);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"clamp\", since = \"1.50.0\")]\n    fn clamp(self, min: Self, max: Self) -> Self\n    where\n        Self: Sized,\n    {\n        assert!(min <= max);\n        if self < min {\n            min\n        } else if self > max {\n            max\n        } else {\n            self\n        }\n    }\n}\n\n/// Derive macro generating an impl of the trait `Ord`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics)]\npub macro Ord($item:item) {\n    /* compiler built-in */\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for Ordering {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for Ordering {\n    #[inline]\n    fn cmp(&self, other: &Ordering) -> Ordering {\n        (*self as i32).cmp(&(*other as i32))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for Ordering {\n    #[inline]\n    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n        (*self as i32).partial_cmp(&(*other as i32))\n    }\n}\n\n/// Trait for values that can be compared for a sort-order.\n///\n/// The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using\n/// the `<`, `<=`, `>`, and `>=` operators, respectively.\n///\n/// The methods of this trait must be consistent with each other and with those of `PartialEq` in\n/// the following sense:\n///\n/// - `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`.\n/// - `a < b` if and only if `partial_cmp(a, b) == Some(Less)`\n///   (ensured by the default implementation).\n/// - `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`\n///   (ensured by the default implementation).\n/// - `a <= b` if and only if `a < b || a == b`\n///   (ensured by the default implementation).\n/// - `a >= b` if and only if `a > b || a == b`\n///   (ensured by the default implementation).\n/// - `a != b` if and only if `!(a == b)` (already part of `PartialEq`).\n///\n/// If [`Ord`] is also implemented for `Self` and `Rhs`, it must also be consistent with\n/// `partial_cmp` (see the documentation of that trait for the exact requirements). It's\n/// easy to accidentally make them disagree by deriving some of the traits and manually\n/// implementing others.\n///\n/// The comparison must satisfy, for all `a`, `b` and `c`:\n///\n/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n/// - duality: `a < b` if and only if `b > a`.\n///\n/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n/// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n/// PartialOrd<V>`.\n///\n/// ## Corollaries\n///\n/// The following corollaries follow from the above requirements:\n///\n/// - irreflexivity of `<` and `>`: `!(a < a)`, `!(a > a)`\n/// - transitivity of `>`: if `a > b` and `b > c` then `a > c`\n/// - duality of `partial_cmp`: `partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)`\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n/// lexicographic ordering based on the top-to-bottom declaration order of the struct's members.\n/// When `derive`d on enums, variants are ordered by their top-to-bottom discriminant order.\n///\n/// ## How can I implement `PartialOrd`?\n///\n/// `PartialOrd` only requires implementation of the [`partial_cmp`] method, with the others\n/// generated from default implementations.\n///\n/// However it remains possible to implement the others separately for types which do not have a\n/// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n/// false` (cf. IEEE 754-2008 section 5.11).\n///\n/// `PartialOrd` requires your type to be [`PartialEq`].\n///\n/// If your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// #[derive(Eq)]\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: u32,\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n///         Some(self.cmp(other))\n///     }\n/// }\n///\n/// impl Ord for Person {\n///     fn cmp(&self, other: &Self) -> Ordering {\n///         self.height.cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n///\n/// You may also find it useful to use [`partial_cmp`] on your type's fields. Here\n/// is an example of `Person` types who have a floating-point `height` field that\n/// is the only field to be used for sorting:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: f64,\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n///         self.height.partial_cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// let x : u32 = 0;\n/// let y : u32 = 1;\n///\n/// assert_eq!(x < y, true);\n/// assert_eq!(x.lt(&y), true);\n/// ```\n///\n/// [`partial_cmp`]: PartialOrd::partial_cmp\n/// [`cmp`]: Ord::cmp\n#[lang = \"partial_ord\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \">\")]\n#[doc(alias = \"<\")]\n#[doc(alias = \"<=\")]\n#[doc(alias = \">=\")]\n#[rustc_on_unimplemented(\n    message = \"can't compare `{Self}` with `{Rhs}`\",\n    label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\"\n)]\npub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n    /// This method returns an ordering between `self` and `other` values if one exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = 1.0.partial_cmp(&2.0);\n    /// assert_eq!(result, Some(Ordering::Less));\n    ///\n    /// let result = 1.0.partial_cmp(&1.0);\n    /// assert_eq!(result, Some(Ordering::Equal));\n    ///\n    /// let result = 2.0.partial_cmp(&1.0);\n    /// assert_eq!(result, Some(Ordering::Greater));\n    /// ```\n    ///\n    /// When comparison is impossible:\n    ///\n    /// ```\n    /// let result = f64::NAN.partial_cmp(&1.0);\n    /// assert_eq!(result, None);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n\n    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 < 2.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 < 1.0;\n    /// assert_eq!(result, false);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn lt(&self, other: &Rhs) -> bool {\n        matches!(self.partial_cmp(other), Some(Less))\n    }\n\n    /// This method tests less than or equal to (for `self` and `other`) and is used by the `<=`\n    /// operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 <= 2.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 <= 2.0;\n    /// assert_eq!(result, true);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn le(&self, other: &Rhs) -> bool {\n        // Pattern `Some(Less | Eq)` optimizes worse than negating `None | Some(Greater)`.\n        // FIXME: The root cause was fixed upstream in LLVM with:\n        // https://github.com/llvm/llvm-project/commit/9bad7de9a3fb844f1ca2965f35d0c2a3d1e11775\n        // Revert this workaround once support for LLVM 12 gets dropped.\n        !matches!(self.partial_cmp(other), None | Some(Greater))\n    }\n\n    /// This method tests greater than (for `self` and `other`) and is used by the `>` operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 > 2.0;\n    /// assert_eq!(result, false);\n    ///\n    /// let result = 2.0 > 2.0;\n    /// assert_eq!(result, false);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn gt(&self, other: &Rhs) -> bool {\n        matches!(self.partial_cmp(other), Some(Greater))\n    }\n\n    /// This method tests greater than or equal to (for `self` and `other`) and is used by the `>=`\n    /// operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 2.0 >= 1.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 >= 2.0;\n    /// assert_eq!(result, true);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn ge(&self, other: &Rhs) -> bool {\n        matches!(self.partial_cmp(other), Some(Greater | Equal))\n    }\n}\n\n/// Derive macro generating an impl of the trait `PartialOrd`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics)]\npub macro PartialOrd($item:item) {\n    /* compiler built-in */\n}\n\n/// Compares and returns the minimum of two values.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// Internally uses an alias to [`Ord::min`].\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(1, cmp::min(1, 2));\n/// assert_eq!(2, cmp::min(2, 2));\n/// ```\n#[inline]\n#[must_use]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn min<T: Ord>(v1: T, v2: T) -> T {\n    v1.min(v2)\n}\n\n/// Returns the minimum of two values with respect to the specified comparison function.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(cmp::min_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 1);\n/// assert_eq!(cmp::min_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n/// ```\n#[inline]\n#[must_use]\n#[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\npub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n    match compare(&v1, &v2) {\n        Ordering::Less | Ordering::Equal => v1,\n        Ordering::Greater => v2,\n    }\n}\n\n/// Returns the element that gives the minimum value from the specified function.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(cmp::min_by_key(-2, 1, |x: &i32| x.abs()), 1);\n/// assert_eq!(cmp::min_by_key(-2, 2, |x: &i32| x.abs()), -2);\n/// ```\n#[inline]\n#[must_use]\n#[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\npub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n    min_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n}\n\n/// Compares and returns the maximum of two values.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// Internally uses an alias to [`Ord::max`].\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(2, cmp::max(1, 2));\n/// assert_eq!(2, cmp::max(2, 2));\n/// ```\n#[inline]\n#[must_use]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn max<T: Ord>(v1: T, v2: T) -> T {\n    v1.max(v2)\n}\n\n/// Returns the maximum of two values with respect to the specified comparison function.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(cmp::max_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n/// assert_eq!(cmp::max_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 2);\n/// ```\n#[inline]\n#[must_use]\n#[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\npub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n    match compare(&v1, &v2) {\n        Ordering::Less | Ordering::Equal => v2,\n        Ordering::Greater => v1,\n    }\n}\n\n/// Returns the element that gives the maximum value from the specified function.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(cmp::max_by_key(-2, 1, |x: &i32| x.abs()), -2);\n/// assert_eq!(cmp::max_by_key(-2, 2, |x: &i32| x.abs()), 2);\n/// ```\n#[inline]\n#[must_use]\n#[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\npub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n    max_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n}\n\n// Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\nmod impls {\n    use crate::cmp::Ordering::{self, Equal, Greater, Less};\n    use crate::hint::unreachable_unchecked;\n\n    macro_rules! partial_eq_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialEq for $t {\n                #[inline]\n                fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n                #[inline]\n                fn ne(&self, other: &$t) -> bool { (*self) != (*other) }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialEq for () {\n        #[inline]\n        fn eq(&self, _other: &()) -> bool {\n            true\n        }\n        #[inline]\n        fn ne(&self, _other: &()) -> bool {\n            false\n        }\n    }\n\n    partial_eq_impl! {\n        bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64\n    }\n\n    macro_rules! eq_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Eq for $t {}\n        )*)\n    }\n\n    eq_impl! { () bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n    macro_rules! partial_ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                    match (self <= other, self >= other) {\n                        (false, false) => None,\n                        (false, true) => Some(Greater),\n                        (true, false) => Some(Less),\n                        (true, true) => Some(Equal),\n                    }\n                }\n                #[inline]\n                fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n                #[inline]\n                fn le(&self, other: &$t) -> bool { (*self) <= (*other) }\n                #[inline]\n                fn ge(&self, other: &$t) -> bool { (*self) >= (*other) }\n                #[inline]\n                fn gt(&self, other: &$t) -> bool { (*self) > (*other) }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialOrd for () {\n        #[inline]\n        fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n            Some(Equal)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialOrd for bool {\n        #[inline]\n        fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }\n    }\n\n    partial_ord_impl! { f32 f64 }\n\n    macro_rules! ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                    Some(self.cmp(other))\n                }\n                #[inline]\n                fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n                #[inline]\n                fn le(&self, other: &$t) -> bool { (*self) <= (*other) }\n                #[inline]\n                fn ge(&self, other: &$t) -> bool { (*self) >= (*other) }\n                #[inline]\n                fn gt(&self, other: &$t) -> bool { (*self) > (*other) }\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Ord for $t {\n                #[inline]\n                fn cmp(&self, other: &$t) -> Ordering {\n                    // The order here is important to generate more optimal assembly.\n                    // See <https://github.com/rust-lang/rust/issues/63758> for more info.\n                    if *self < *other { Less }\n                    else if *self == *other { Equal }\n                    else { Greater }\n                }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Ord for () {\n        #[inline]\n        fn cmp(&self, _other: &()) -> Ordering {\n            Equal\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Ord for bool {\n        #[inline]\n        fn cmp(&self, other: &bool) -> Ordering {\n            // Casting to i8's and converting the difference to an Ordering generates\n            // more optimal assembly.\n            // See <https://github.com/rust-lang/rust/issues/66780> for more info.\n            match (*self as i8) - (*other as i8) {\n                -1 => Less,\n                0 => Equal,\n                1 => Greater,\n                // SAFETY: bool as i8 returns 0 or 1, so the difference can't be anything else\n                _ => unsafe { unreachable_unchecked() },\n            }\n        }\n    }\n\n    ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl PartialEq for ! {\n        fn eq(&self, _: &!) -> bool {\n            *self\n        }\n    }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl Eq for ! {}\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl PartialOrd for ! {\n        fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n            *self\n        }\n    }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl Ord for ! {\n        fn cmp(&self, _: &!) -> Ordering {\n            *self\n        }\n    }\n\n    // & pointers\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &A\n    where\n        A: PartialEq<B>,\n    {\n        #[inline]\n        fn eq(&self, other: &&B) -> bool {\n            PartialEq::eq(*self, *other)\n        }\n        #[inline]\n        fn ne(&self, other: &&B) -> bool {\n            PartialEq::ne(*self, *other)\n        }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A\n    where\n        A: PartialOrd<B>,\n    {\n        #[inline]\n        fn partial_cmp(&self, other: &&B) -> Option<Ordering> {\n            PartialOrd::partial_cmp(*self, *other)\n        }\n        #[inline]\n        fn lt(&self, other: &&B) -> bool {\n            PartialOrd::lt(*self, *other)\n        }\n        #[inline]\n        fn le(&self, other: &&B) -> bool {\n            PartialOrd::le(*self, *other)\n        }\n        #[inline]\n        fn gt(&self, other: &&B) -> bool {\n            PartialOrd::gt(*self, *other)\n        }\n        #[inline]\n        fn ge(&self, other: &&B) -> bool {\n            PartialOrd::ge(*self, *other)\n        }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized> Ord for &A\n    where\n        A: Ord,\n    {\n        #[inline]\n        fn cmp(&self, other: &Self) -> Ordering {\n            Ord::cmp(*self, *other)\n        }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized> Eq for &A where A: Eq {}\n\n    // &mut pointers\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &mut A\n    where\n        A: PartialEq<B>,\n    {\n        #[inline]\n        fn eq(&self, other: &&mut B) -> bool {\n            PartialEq::eq(*self, *other)\n        }\n        #[inline]\n        fn ne(&self, other: &&mut B) -> bool {\n            PartialEq::ne(*self, *other)\n        }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized, B: ?Sized> PartialOrd<&mut B> for &mut A\n    where\n        A: PartialOrd<B>,\n    {\n        #[inline]\n        fn partial_cmp(&self, other: &&mut B) -> Option<Ordering> {\n            PartialOrd::partial_cmp(*self, *other)\n        }\n        #[inline]\n        fn lt(&self, other: &&mut B) -> bool {\n            PartialOrd::lt(*self, *other)\n        }\n        #[inline]\n        fn le(&self, other: &&mut B) -> bool {\n            PartialOrd::le(*self, *other)\n        }\n        #[inline]\n        fn gt(&self, other: &&mut B) -> bool {\n            PartialOrd::gt(*self, *other)\n        }\n        #[inline]\n        fn ge(&self, other: &&mut B) -> bool {\n            PartialOrd::ge(*self, *other)\n        }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized> Ord for &mut A\n    where\n        A: Ord,\n    {\n        #[inline]\n        fn cmp(&self, other: &Self) -> Ordering {\n            Ord::cmp(*self, *other)\n        }\n    }\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized> Eq for &mut A where A: Eq {}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized, B: ?Sized> PartialEq<&mut B> for &A\n    where\n        A: PartialEq<B>,\n    {\n        #[inline]\n        fn eq(&self, other: &&mut B) -> bool {\n            PartialEq::eq(*self, *other)\n        }\n        #[inline]\n        fn ne(&self, other: &&mut B) -> bool {\n            PartialEq::ne(*self, *other)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &mut A\n    where\n        A: PartialEq<B>,\n    {\n        #[inline]\n        fn eq(&self, other: &&B) -> bool {\n            PartialEq::eq(*self, *other)\n        }\n        #[inline]\n        fn ne(&self, other: &&B) -> bool {\n            PartialEq::ne(*self, *other)\n        }\n    }\n}\n"],[2830,"// implements the unary operator \"op &T\"\n// based on \"op T\" where T is expected to be `Copy`able\nmacro_rules! forward_ref_unop {\n    (impl $imp:ident, $method:ident for $t:ty) => {\n        forward_ref_unop!(impl $imp, $method for $t,\n                #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n    };\n    (impl $imp:ident, $method:ident for $t:ty, #[$attr:meta]) => {\n        #[$attr]\n        impl $imp for &$t {\n            type Output = <$t as $imp>::Output;\n\n            #[inline]\n            fn $method(self) -> <$t as $imp>::Output {\n                $imp::$method(*self)\n            }\n        }\n    }\n}\n\n// implements binary operators \"&T op U\", \"T op &U\", \"&T op &U\"\n// based on \"T op U\" where T and U are expected to be `Copy`able\nmacro_rules! forward_ref_binop {\n    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n        forward_ref_binop!(impl $imp, $method for $t, $u,\n                #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n    };\n    (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n        #[$attr]\n        impl<'a> $imp<$u> for &'a $t {\n            type Output = <$t as $imp<$u>>::Output;\n\n            #[inline]\n            fn $method(self, other: $u) -> <$t as $imp<$u>>::Output {\n                $imp::$method(*self, other)\n            }\n        }\n\n        #[$attr]\n        impl $imp<&$u> for $t {\n            type Output = <$t as $imp<$u>>::Output;\n\n            #[inline]\n            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n                $imp::$method(self, *other)\n            }\n        }\n\n        #[$attr]\n        impl $imp<&$u> for &$t {\n            type Output = <$t as $imp<$u>>::Output;\n\n            #[inline]\n            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n                $imp::$method(*self, *other)\n            }\n        }\n    }\n}\n\n// implements \"T op= &U\", based on \"T op= U\"\n// where U is expected to be `Copy`able\nmacro_rules! forward_ref_op_assign {\n    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n        forward_ref_op_assign!(impl $imp, $method for $t, $u,\n                #[stable(feature = \"op_assign_builtins_by_ref\", since = \"1.22.0\")]);\n    };\n    (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n        #[$attr]\n        impl $imp<&$u> for $t {\n            #[inline]\n            fn $method(&mut self, other: &$u) {\n                $imp::$method(self, *other);\n            }\n        }\n    }\n}\n\n/// Create a zero-size type similar to a closure type, but named.\n#[unstable(feature = \"std_internals\", issue = \"none\")]\nmacro_rules! impl_fn_for_zst {\n    ($(\n        $( #[$attr: meta] )*\n        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n            $body: block;\n    )+) => {\n        $(\n            $( #[$attr] )*\n            struct $Name;\n\n            impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n                #[inline]\n                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n                    $body\n                }\n            }\n\n            impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n                #[inline]\n                extern \"rust-call\" fn call_mut(\n                    &mut self,\n                    ($( $arg, )*): ($( $ArgTy, )*)\n                ) -> $ReturnTy {\n                    Fn::call(&*self, ($( $arg, )*))\n                }\n            }\n\n            impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n                type Output = $ReturnTy;\n\n                #[inline]\n                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n                    Fn::call(&self, ($( $arg, )*))\n                }\n            }\n        )+\n    }\n}\n"],[2831,"//! Operations on ASCII strings and characters.\n//!\n//! Most string operations in Rust act on UTF-8 strings. However, at times it\n//! makes more sense to only consider the ASCII character set for a specific\n//! operation.\n//!\n//! The [`escape_default`] function provides an iterator over the bytes of an\n//! escaped version of the character given.\n\n#![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n\nuse crate::fmt;\nuse crate::iter::FusedIterator;\nuse crate::ops::Range;\nuse crate::str::from_utf8_unchecked;\n\n/// An iterator over the escaped version of a byte.\n///\n/// This `struct` is created by the [`escape_default`] function. See its\n/// documentation for more.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct EscapeDefault {\n    range: Range<usize>,\n    data: [u8; 4],\n}\n\n/// Returns an iterator that produces an escaped version of a `u8`.\n///\n/// The default is chosen with a bias toward producing literals that are\n/// legal in a variety of languages, including C++11 and similar C-family\n/// languages. The exact rules are:\n///\n/// * Tab is escaped as `\\t`.\n/// * Carriage return is escaped as `\\r`.\n/// * Line feed is escaped as `\\n`.\n/// * Single quote is escaped as `\\'`.\n/// * Double quote is escaped as `\\\"`.\n/// * Backslash is escaped as `\\\\`.\n/// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n///   inclusive is not escaped.\n/// * Any other chars are given hex escapes of the form '\\xNN'.\n/// * Unicode escapes are never generated by this function.\n///\n/// # Examples\n///\n/// ```\n/// use std::ascii;\n///\n/// let escaped = ascii::escape_default(b'0').next().unwrap();\n/// assert_eq!(b'0', escaped);\n///\n/// let mut escaped = ascii::escape_default(b'\\t');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b't', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\r');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'r', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\n');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'n', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\'');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'\\'', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\"');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'\"', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\\\');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\x9d');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'x', escaped.next().unwrap());\n/// assert_eq!(b'9', escaped.next().unwrap());\n/// assert_eq!(b'd', escaped.next().unwrap());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn escape_default(c: u8) -> EscapeDefault {\n    let (data, len) = match c {\n        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n        b'\\x20'..=b'\\x7e' => ([c, 0, 0, 0], 1),\n        _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n    };\n\n    return EscapeDefault { range: 0..len, data };\n\n    fn hexify(b: u8) -> u8 {\n        match b {\n            0..=9 => b'0' + b,\n            _ => b'a' + b - 10,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for EscapeDefault {\n    type Item = u8;\n    fn next(&mut self) -> Option<u8> {\n        self.range.next().map(|i| self.data[i])\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.range.size_hint()\n    }\n    fn last(mut self) -> Option<u8> {\n        self.next_back()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl DoubleEndedIterator for EscapeDefault {\n    fn next_back(&mut self) -> Option<u8> {\n        self.range.next_back().map(|i| self.data[i])\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ExactSizeIterator for EscapeDefault {}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for EscapeDefault {}\n\n#[stable(feature = \"ascii_escape_display\", since = \"1.39.0\")]\nimpl fmt::Display for EscapeDefault {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // SAFETY: ok because `escape_default` created only valid utf-8 data\n        f.write_str(unsafe { from_utf8_unchecked(&self.data[self.range.clone()]) })\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for EscapeDefault {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"EscapeDefault\").finish_non_exhaustive()\n    }\n}\n"],[2832,"//! Panic support for libcore\n//!\n//! The core library cannot define panicking, but it does *declare* panicking. This\n//! means that the functions inside of libcore are allowed to panic, but to be\n//! useful an upstream crate must define panicking for libcore to use. The current\n//! interface for panicking is:\n//!\n//! ```\n//! fn panic_impl(pi: &core::panic::PanicInfo<'_>) -> !\n//! # { loop {} }\n//! ```\n//!\n//! This definition allows for panicking with any general message, but it does not\n//! allow for failing with a `Box<Any>` value. (`PanicInfo` just contains a `&(dyn Any + Send)`,\n//! for which we fill in a dummy value in `PanicInfo::internal_constructor`.)\n//! The reason for this is that libcore is not allowed to allocate.\n//!\n//! This module contains a few other panicking functions, but these are just the\n//! necessary lang items for the compiler. All panics are funneled through this\n//! one function. The actual symbol is declared through the `#[panic_handler]` attribute.\n\n#![allow(dead_code, missing_docs)]\n#![unstable(\n    feature = \"core_panic\",\n    reason = \"internal details of the implementation of the `panic!` and related macros\",\n    issue = \"none\"\n)]\n\nuse crate::fmt;\nuse crate::panic::{Location, PanicInfo};\n\n/// The underlying implementation of libcore's `panic!` macro when no formatting is used.\n#[cold]\n// never inline unless panic_immediate_abort to avoid code\n// bloat at the call sites as much as possible\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[track_caller]\n#[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\npub fn panic(expr: &'static str) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n    // reduce size overhead. The format_args! macro uses str's Display trait to\n    // write expr, which calls Formatter::pad, which must accommodate string\n    // truncation and padding (even though none is used here). Using\n    // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n    // output binary, saving up to a few kilobytes.\n    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n}\n\n#[inline]\n#[track_caller]\n#[lang = \"panic_str\"] // needed for const-evaluated panics\npub fn panic_str(expr: &str) -> ! {\n    panic_fmt(format_args!(\"{}\", expr));\n}\n\n#[cold]\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[track_caller]\n#[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\nfn panic_bounds_check(index: usize, len: usize) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    panic!(\"index out of bounds: the len is {} but the index is {}\", len, index)\n}\n\n/// The underlying implementation of libcore's `panic!` macro when formatting is used.\n#[cold]\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n#[track_caller]\npub fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n    // that gets resolved to the `#[panic_handler]` function.\n    extern \"Rust\" {\n        #[lang = \"panic_impl\"]\n        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n    }\n\n    let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller());\n\n    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n    unsafe { panic_impl(&pi) }\n}\n\n#[derive(Debug)]\n#[doc(hidden)]\npub enum AssertKind {\n    Eq,\n    Ne,\n    Match,\n}\n\n/// Internal function for `assert_eq!` and `assert_ne!` macros\n#[cold]\n#[track_caller]\n#[doc(hidden)]\npub fn assert_failed<T, U>(\n    kind: AssertKind,\n    left: &T,\n    right: &U,\n    args: Option<fmt::Arguments<'_>>,\n) -> !\nwhere\n    T: fmt::Debug + ?Sized,\n    U: fmt::Debug + ?Sized,\n{\n    assert_failed_inner(kind, &left, &right, args)\n}\n\n/// Internal function for `assert_match!`\n#[cold]\n#[track_caller]\n#[doc(hidden)]\npub fn assert_matches_failed<T: fmt::Debug + ?Sized>(\n    left: &T,\n    right: &str,\n    args: Option<fmt::Arguments<'_>>,\n) -> ! {\n    // Use the Display implementation to display the pattern.\n    struct Pattern<'a>(&'a str);\n    impl fmt::Debug for Pattern<'_> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            fmt::Display::fmt(self.0, f)\n        }\n    }\n    assert_failed_inner(AssertKind::Match, &left, &Pattern(right), args);\n}\n\n/// Non-generic version of the above functions, to avoid code bloat.\n#[track_caller]\nfn assert_failed_inner(\n    kind: AssertKind,\n    left: &dyn fmt::Debug,\n    right: &dyn fmt::Debug,\n    args: Option<fmt::Arguments<'_>>,\n) -> ! {\n    let op = match kind {\n        AssertKind::Eq => \"==\",\n        AssertKind::Ne => \"!=\",\n        AssertKind::Match => \"matches\",\n    };\n\n    match args {\n        Some(args) => panic!(\n            r#\"assertion failed: `(left {} right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#,\n            op, left, right, args\n        ),\n        None => panic!(\n            r#\"assertion failed: `(left {} right)`\n  left: `{:?}`,\n right: `{:?}`\"#,\n            op, left, right,\n        ),\n    }\n}\n"],[2833,"//! Optional values.\n//!\n//! Type [`Option`] represents an optional value: every [`Option`]\n//! is either [`Some`] and contains a value, or [`None`], and\n//! does not. [`Option`] types are very common in Rust code, as\n//! they have a number of uses:\n//!\n//! * Initial values\n//! * Return values for functions that are not defined\n//!   over their entire input range (partial functions)\n//! * Return value for otherwise reporting simple errors, where [`None`] is\n//!   returned on error\n//! * Optional struct fields\n//! * Struct fields that can be loaned or \"taken\"\n//! * Optional function arguments\n//! * Nullable pointers\n//! * Swapping things out of difficult situations\n//!\n//! [`Option`]s are commonly paired with pattern matching to query the presence\n//! of a value and take action, always accounting for the [`None`] case.\n//!\n//! ```\n//! fn divide(numerator: f64, denominator: f64) -> Option<f64> {\n//!     if denominator == 0.0 {\n//!         None\n//!     } else {\n//!         Some(numerator / denominator)\n//!     }\n//! }\n//!\n//! // The return value of the function is an option\n//! let result = divide(2.0, 3.0);\n//!\n//! // Pattern match to retrieve the value\n//! match result {\n//!     // The division was valid\n//!     Some(x) => println!(\"Result: {}\", x),\n//!     // The division was invalid\n//!     None    => println!(\"Cannot divide by 0\"),\n//! }\n//! ```\n//!\n//\n// FIXME: Show how `Option` is used in practice, with lots of methods\n//\n//! # Options and pointers (\"nullable\" pointers)\n//!\n//! Rust's pointer types must always point to a valid location; there are\n//! no \"null\" references. Instead, Rust has *optional* pointers, like\n//! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n//!\n//! The following example uses [`Option`] to create an optional box of\n//! [`i32`]. Notice that in order to use the inner [`i32`] value, the\n//! `check_optional` function first needs to use pattern matching to\n//! determine whether the box has a value (i.e., it is [`Some(...)`][`Some`]) or\n//! not ([`None`]).\n//!\n//! ```\n//! let optional = None;\n//! check_optional(optional);\n//!\n//! let optional = Some(Box::new(9000));\n//! check_optional(optional);\n//!\n//! fn check_optional(optional: Option<Box<i32>>) {\n//!     match optional {\n//!         Some(p) => println!(\"has value {}\", p),\n//!         None => println!(\"has no value\"),\n//!     }\n//! }\n//! ```\n//!\n//! # Representation\n//!\n//! Rust guarantees to optimize the following types `T` such that\n//! [`Option<T>`] has the same size as `T`:\n//!\n//! * [`Box<U>`]\n//! * `&U`\n//! * `&mut U`\n//! * `fn`, `extern \"C\" fn`\n//! * [`num::NonZero*`]\n//! * [`ptr::NonNull<U>`]\n//! * `#[repr(transparent)]` struct around one of the types in this list.\n//!\n//! This is called the \"null pointer optimization\" or NPO.\n//!\n//! It is further guaranteed that, for the cases above, one can\n//! [`mem::transmute`] from all valid values of `T` to `Option<T>` and\n//! from `Some::<T>(_)` to `T` (but transmuting `None::<T>` to `T`\n//! is undefined behaviour).\n//!\n//! # Examples\n//!\n//! Basic pattern matching on [`Option`]:\n//!\n//! ```\n//! let msg = Some(\"howdy\");\n//!\n//! // Take a reference to the contained string\n//! if let Some(m) = &msg {\n//!     println!(\"{}\", *m);\n//! }\n//!\n//! // Remove the contained string, destroying the Option\n//! let unwrapped_msg = msg.unwrap_or(\"default message\");\n//! ```\n//!\n//! Initialize a result to [`None`] before a loop:\n//!\n//! ```\n//! enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n//!\n//! // A list of data to search through.\n//! let all_the_big_things = [\n//!     Kingdom::Plant(250, \"redwood\"),\n//!     Kingdom::Plant(230, \"noble fir\"),\n//!     Kingdom::Plant(229, \"sugar pine\"),\n//!     Kingdom::Animal(25, \"blue whale\"),\n//!     Kingdom::Animal(19, \"fin whale\"),\n//!     Kingdom::Animal(15, \"north pacific right whale\"),\n//! ];\n//!\n//! // We're going to search for the name of the biggest animal,\n//! // but to start with we've just got `None`.\n//! let mut name_of_biggest_animal = None;\n//! let mut size_of_biggest_animal = 0;\n//! for big_thing in &all_the_big_things {\n//!     match *big_thing {\n//!         Kingdom::Animal(size, name) if size > size_of_biggest_animal => {\n//!             // Now we've found the name of some big animal\n//!             size_of_biggest_animal = size;\n//!             name_of_biggest_animal = Some(name);\n//!         }\n//!         Kingdom::Animal(..) | Kingdom::Plant(..) => ()\n//!     }\n//! }\n//!\n//! match name_of_biggest_animal {\n//!     Some(name) => println!(\"the biggest animal is {}\", name),\n//!     None => println!(\"there are no animals :(\"),\n//! }\n//! ```\n//!\n//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n//! [`Box<U>`]: ../../std/boxed/struct.Box.html\n//! [`num::NonZero*`]: crate::num\n//! [`ptr::NonNull<U>`]: crate::ptr::NonNull\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::iter::{FromIterator, FusedIterator, TrustedLen};\nuse crate::pin::Pin;\nuse crate::{\n    convert, hint, mem,\n    ops::{self, ControlFlow, Deref, DerefMut},\n};\n\n/// The `Option` type. See [the module level documentation](self) for more.\n#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[rustc_diagnostic_item = \"option_type\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Option<T> {\n    /// No value\n    #[lang = \"None\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    None,\n    /// Some value `T`\n    #[lang = \"Some\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Type implementation\n/////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Option<T> {\n    /////////////////////////////////////////////////////////////////////////\n    // Querying the contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `true` if the option is a [`Some`] value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.is_some(), true);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.is_some(), false);\n    /// ```\n    #[must_use = \"if you intended to assert that this has a value, consider `.unwrap()` instead\"]\n    #[inline]\n    #[rustc_const_stable(feature = \"const_option\", since = \"1.48.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn is_some(&self) -> bool {\n        matches!(*self, Some(_))\n    }\n\n    /// Returns `true` if the option is a [`None`] value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.is_none(), false);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.is_none(), true);\n    /// ```\n    #[must_use = \"if you intended to assert that this doesn't have a value, consider \\\n                  `.and_then(|_| panic!(\\\"`Option` had a value when expected `None`\\\"))` instead\"]\n    #[inline]\n    #[rustc_const_stable(feature = \"const_option\", since = \"1.48.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn is_none(&self) -> bool {\n        !self.is_some()\n    }\n\n    /// Returns `true` if the option is a [`Some`] value containing the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_result_contains)]\n    ///\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.contains(&2), true);\n    ///\n    /// let x: Option<u32> = Some(3);\n    /// assert_eq!(x.contains(&2), false);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.contains(&2), false);\n    /// ```\n    #[must_use]\n    #[inline]\n    #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n    pub fn contains<U>(&self, x: &U) -> bool\n    where\n        U: PartialEq<T>,\n    {\n        match self {\n            Some(y) => x == y,\n            None => false,\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for working with references\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `&Option<T>` to `Option<&T>`.\n    ///\n    /// # Examples\n    ///\n    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n    /// The [`map`] method takes the `self` argument by value, consuming the original,\n    /// so this technique uses `as_ref` to first take an `Option` to a reference\n    /// to the value inside the original.\n    ///\n    /// [`map`]: Option::map\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// ```\n    /// let text: Option<String> = Some(\"Hello, world!\".to_string());\n    /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n    /// // then consume *that* with `map`, leaving `text` on the stack.\n    /// let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n    /// println!(\"still can print text: {:?}\", text);\n    /// ```\n    #[inline]\n    #[rustc_const_stable(feature = \"const_option\", since = \"1.48.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn as_ref(&self) -> Option<&T> {\n        match *self {\n            Some(ref x) => Some(x),\n            None => None,\n        }\n    }\n\n    /// Converts from `&mut Option<T>` to `Option<&mut T>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// match x.as_mut() {\n    ///     Some(v) => *v = 42,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Some(42));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_mut(&mut self) -> Option<&mut T> {\n        match *self {\n            Some(ref mut x) => Some(x),\n            None => None,\n        }\n    }\n\n    /// Converts from [`Pin`]`<&Option<T>>` to `Option<`[`Pin`]`<&T>>`.\n    #[inline]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n        // SAFETY: `x` is guaranteed to be pinned because it comes from `self`\n        // which is pinned.\n        unsafe { Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x)) }\n    }\n\n    /// Converts from [`Pin`]`<&mut Option<T>>` to `Option<`[`Pin`]`<&mut T>>`.\n    #[inline]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n        // SAFETY: `get_unchecked_mut` is never used to move the `Option` inside `self`.\n        // `x` is guaranteed to be pinned because it comes from `self` which is pinned.\n        unsafe { Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x)) }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Getting to contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns the contained [`Some`] value, consuming the `self` value.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is a [`None`] with a custom panic message provided by\n    /// `msg`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"value\");\n    /// assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n    /// ```\n    ///\n    /// ```should_panic\n    /// let x: Option<&str> = None;\n    /// x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn expect(self, msg: &str) -> T {\n        match self {\n            Some(val) => val,\n            None => expect_failed(msg),\n        }\n    }\n\n    /// Returns the contained [`Some`] value, consuming the `self` value.\n    ///\n    /// Because this function may panic, its use is generally discouraged.\n    /// Instead, prefer to use pattern matching and handle the [`None`]\n    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n    /// [`unwrap_or_default`].\n    ///\n    /// [`unwrap_or`]: Option::unwrap_or\n    /// [`unwrap_or_else`]: Option::unwrap_or_else\n    /// [`unwrap_or_default`]: Option::unwrap_or_default\n    ///\n    /// # Panics\n    ///\n    /// Panics if the self value equals [`None`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"air\");\n    /// assert_eq!(x.unwrap(), \"air\");\n    /// ```\n    ///\n    /// ```should_panic\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.unwrap(), \"air\"); // fails\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n    pub const fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n\n    /// Returns the contained [`Some`] value or a provided default.\n    ///\n    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n    /// which is lazily evaluated.\n    ///\n    /// [`unwrap_or_else`]: Option::unwrap_or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n    /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or(self, default: T) -> T {\n        match self {\n            Some(x) => x,\n            None => default,\n        }\n    }\n\n    /// Returns the contained [`Some`] value or computes it from a closure.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let k = 10;\n    /// assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n    /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n\n    /// Returns the contained [`Some`] value, consuming the `self` value,\n    /// without checking that the value is not [`None`].\n    ///\n    /// # Safety\n    ///\n    /// Calling this method on [`None`] is *[undefined behavior]*.\n    ///\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_result_unwrap_unchecked)]\n    /// let x = Some(\"air\");\n    /// assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\");\n    /// ```\n    ///\n    /// ```no_run\n    /// #![feature(option_result_unwrap_unchecked)]\n    /// let x: Option<&str> = None;\n    /// assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\"); // Undefined behavior!\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[unstable(feature = \"option_result_unwrap_unchecked\", reason = \"newly added\", issue = \"81383\")]\n    pub unsafe fn unwrap_unchecked(self) -> T {\n        debug_assert!(self.is_some());\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Transforming contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n    ///\n    /// # Examples\n    ///\n    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    /// ```\n    /// let maybe_some_string = Some(String::from(\"Hello, World!\"));\n    /// // `Option::map` takes self *by value*, consuming `maybe_some_string`\n    /// let maybe_some_len = maybe_some_string.map(|s| s.len());\n    ///\n    /// assert_eq!(maybe_some_len, Some(13));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }\n\n    /// Returns the provided default result (if none),\n    /// or applies a function to the contained value (if any).\n    ///\n    /// Arguments passed to `map_or` are eagerly evaluated; if you are passing\n    /// the result of a function call, it is recommended to use [`map_or_else`],\n    /// which is lazily evaluated.\n    ///\n    /// [`map_or_else`]: Option::map_or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.map_or(42, |v| v.len()), 3);\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n        match self {\n            Some(t) => f(t),\n            None => default,\n        }\n    }\n\n    /// Computes a default function result (if none), or\n    /// applies a different function to the contained value (if any).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let k = 21;\n    ///\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {\n        match self {\n            Some(t) => f(t),\n            None => default(),\n        }\n    }\n\n    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n    /// [`Ok(v)`] and [`None`] to [`Err(err)`].\n    ///\n    /// Arguments passed to `ok_or` are eagerly evaluated; if you are passing the\n    /// result of a function call, it is recommended to use [`ok_or_else`], which is\n    /// lazily evaluated.\n    ///\n    /// [`Ok(v)`]: Ok\n    /// [`Err(err)`]: Err\n    /// [`Some(v)`]: Some\n    /// [`ok_or_else`]: Option::ok_or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.ok_or(0), Ok(\"foo\"));\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.ok_or(0), Err(0));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n        match self {\n            Some(v) => Ok(v),\n            None => Err(err),\n        }\n    }\n\n    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n    /// [`Ok(v)`] and [`None`] to [`Err(err())`].\n    ///\n    /// [`Ok(v)`]: Ok\n    /// [`Err(err())`]: Err\n    /// [`Some(v)`]: Some\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.ok_or_else(|| 0), Err(0));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n        match self {\n            Some(v) => Ok(v),\n            None => Err(err()),\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Iterator constructors\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns an iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(4);\n    /// assert_eq!(x.iter().next(), Some(&4));\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.iter().next(), None);\n    /// ```\n    #[inline]\n    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn iter(&self) -> Iter<'_, T> {\n        Iter { inner: Item { opt: self.as_ref() } }\n    }\n\n    /// Returns a mutable iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(4);\n    /// match x.iter_mut().next() {\n    ///     Some(v) => *v = 42,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Some(42));\n    ///\n    /// let mut x: Option<u32> = None;\n    /// assert_eq!(x.iter_mut().next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n        IterMut { inner: Item { opt: self.as_mut() } }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Boolean operations on the values, eager and lazy\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns [`None`] if the option is [`None`], otherwise returns `optb`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y: Option<&str> = None;\n    /// assert_eq!(x.and(y), None);\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = Some(\"foo\");\n    /// assert_eq!(x.and(y), None);\n    ///\n    /// let x = Some(2);\n    /// let y = Some(\"foo\");\n    /// assert_eq!(x.and(y), Some(\"foo\"));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y: Option<&str> = None;\n    /// assert_eq!(x.and(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n        match self {\n            Some(_) => optb,\n            None => None,\n        }\n    }\n\n    /// Returns [`None`] if the option is [`None`], otherwise calls `f` with the\n    /// wrapped value and returns the result.\n    ///\n    /// Some languages call this operation flatmap.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Option<u32> { Some(x * x) }\n    /// fn nope(_: u32) -> Option<u32> { None }\n    ///\n    /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n    /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n    /// assert_eq!(Some(2).and_then(nope).and_then(sq), None);\n    /// assert_eq!(None.and_then(sq).and_then(sq), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n        match self {\n            Some(x) => f(x),\n            None => None,\n        }\n    }\n\n    /// Returns [`None`] if the option is [`None`], otherwise calls `predicate`\n    /// with the wrapped value and returns:\n    ///\n    /// - [`Some(t)`] if `predicate` returns `true` (where `t` is the wrapped\n    ///   value), and\n    /// - [`None`] if `predicate` returns `false`.\n    ///\n    /// This function works similar to [`Iterator::filter()`]. You can imagine\n    /// the `Option<T>` being an iterator over one or zero elements. `filter()`\n    /// lets you decide which elements to keep.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// fn is_even(n: &i32) -> bool {\n    ///     n % 2 == 0\n    /// }\n    ///\n    /// assert_eq!(None.filter(is_even), None);\n    /// assert_eq!(Some(3).filter(is_even), None);\n    /// assert_eq!(Some(4).filter(is_even), Some(4));\n    /// ```\n    ///\n    /// [`Some(t)`]: Some\n    #[inline]\n    #[stable(feature = \"option_filter\", since = \"1.27.0\")]\n    pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n        if let Some(x) = self {\n            if predicate(&x) {\n                return Some(x);\n            }\n        }\n        None\n    }\n\n    /// Returns the option if it contains a value, otherwise returns `optb`.\n    ///\n    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n    /// result of a function call, it is recommended to use [`or_else`], which is\n    /// lazily evaluated.\n    ///\n    /// [`or_else`]: Option::or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y = None;\n    /// assert_eq!(x.or(y), Some(2));\n    ///\n    /// let x = None;\n    /// let y = Some(100);\n    /// assert_eq!(x.or(y), Some(100));\n    ///\n    /// let x = Some(2);\n    /// let y = Some(100);\n    /// assert_eq!(x.or(y), Some(2));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = None;\n    /// assert_eq!(x.or(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or(self, optb: Option<T>) -> Option<T> {\n        match self {\n            Some(_) => self,\n            None => optb,\n        }\n    }\n\n    /// Returns the option if it contains a value, otherwise calls `f` and\n    /// returns the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// fn nobody() -> Option<&'static str> { None }\n    /// fn vikings() -> Option<&'static str> { Some(\"vikings\") }\n    ///\n    /// assert_eq!(Some(\"barbarians\").or_else(vikings), Some(\"barbarians\"));\n    /// assert_eq!(None.or_else(vikings), Some(\"vikings\"));\n    /// assert_eq!(None.or_else(nobody), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n        match self {\n            Some(_) => self,\n            None => f(),\n        }\n    }\n\n    /// Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns [`None`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y: Option<u32> = None;\n    /// assert_eq!(x.xor(y), Some(2));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = Some(2);\n    /// assert_eq!(x.xor(y), Some(2));\n    ///\n    /// let x = Some(2);\n    /// let y = Some(2);\n    /// assert_eq!(x.xor(y), None);\n    ///\n    /// let x: Option<u32> = None;\n    /// let y: Option<u32> = None;\n    /// assert_eq!(x.xor(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_xor\", since = \"1.37.0\")]\n    pub fn xor(self, optb: Option<T>) -> Option<T> {\n        match (self, optb) {\n            (Some(a), None) => Some(a),\n            (None, Some(b)) => Some(b),\n            _ => None,\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Entry-like operations to insert a value and return a reference\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Inserts `value` into the option then returns a mutable reference to it.\n    ///\n    /// If the option already contains a value, the old value is dropped.\n    ///\n    /// See also [`Option::get_or_insert`], which doesn't update the value if\n    /// the option already contains [`Some`].\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let mut opt = None;\n    /// let val = opt.insert(1);\n    /// assert_eq!(*val, 1);\n    /// assert_eq!(opt.unwrap(), 1);\n    /// let val = opt.insert(2);\n    /// assert_eq!(*val, 2);\n    /// *val = 3;\n    /// assert_eq!(opt.unwrap(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_insert\", since = \"1.53.0\")]\n    pub fn insert(&mut self, value: T) -> &mut T {\n        *self = Some(value);\n\n        match self {\n            Some(v) => v,\n            // SAFETY: the code above just filled the option\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }\n\n    /// Inserts `value` into the option if it is [`None`], then\n    /// returns a mutable reference to the contained value.\n    ///\n    /// See also [`Option::insert`], which updates the value even if\n    /// the option already contains [`Some`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = None;\n    ///\n    /// {\n    ///     let y: &mut u32 = x.get_or_insert(5);\n    ///     assert_eq!(y, &5);\n    ///\n    ///     *y = 7;\n    /// }\n    ///\n    /// assert_eq!(x, Some(7));\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n    pub fn get_or_insert(&mut self, value: T) -> &mut T {\n        self.get_or_insert_with(|| value)\n    }\n\n    /// Inserts the default value into the option if it is [`None`], then\n    /// returns a mutable reference to the contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_get_or_insert_default)]\n    ///\n    /// let mut x = None;\n    ///\n    /// {\n    ///     let y: &mut u32 = x.get_or_insert_default();\n    ///     assert_eq!(y, &0);\n    ///\n    ///     *y = 7;\n    /// }\n    ///\n    /// assert_eq!(x, Some(7));\n    /// ```\n    #[inline]\n    #[unstable(feature = \"option_get_or_insert_default\", issue = \"82901\")]\n    pub fn get_or_insert_default(&mut self) -> &mut T\n    where\n        T: Default,\n    {\n        self.get_or_insert_with(Default::default)\n    }\n\n    /// Inserts a value computed from `f` into the option if it is [`None`],\n    /// then returns a mutable reference to the contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = None;\n    ///\n    /// {\n    ///     let y: &mut u32 = x.get_or_insert_with(|| 5);\n    ///     assert_eq!(y, &5);\n    ///\n    ///     *y = 7;\n    /// }\n    ///\n    /// assert_eq!(x, Some(7));\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n    pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n        if let None = *self {\n            *self = Some(f());\n        }\n\n        match self {\n            Some(v) => v,\n            // SAFETY: a `None` variant for `self` would have been replaced by a `Some`\n            // variant in the code above.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // Misc\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Takes the value out of the option, leaving a [`None`] in its place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// let y = x.take();\n    /// assert_eq!(x, None);\n    /// assert_eq!(y, Some(2));\n    ///\n    /// let mut x: Option<u32> = None;\n    /// let y = x.take();\n    /// assert_eq!(x, None);\n    /// assert_eq!(y, None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn take(&mut self) -> Option<T> {\n        mem::take(self)\n    }\n\n    /// Replaces the actual value in the option by the value given in parameter,\n    /// returning the old value if present,\n    /// leaving a [`Some`] in its place without deinitializing either one.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// let old = x.replace(5);\n    /// assert_eq!(x, Some(5));\n    /// assert_eq!(old, Some(2));\n    ///\n    /// let mut x = None;\n    /// let old = x.replace(3);\n    /// assert_eq!(x, Some(3));\n    /// assert_eq!(old, None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_replace\", since = \"1.31.0\")]\n    pub fn replace(&mut self, value: T) -> Option<T> {\n        mem::replace(self, Some(value))\n    }\n\n    /// Zips `self` with another `Option`.\n    ///\n    /// If `self` is `Some(s)` and `other` is `Some(o)`, this method returns `Some((s, o))`.\n    /// Otherwise, `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(1);\n    /// let y = Some(\"hi\");\n    /// let z = None::<u8>;\n    ///\n    /// assert_eq!(x.zip(y), Some((1, \"hi\")));\n    /// assert_eq!(x.zip(z), None);\n    /// ```\n    #[stable(feature = \"option_zip_option\", since = \"1.46.0\")]\n    pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)> {\n        match (self, other) {\n            (Some(a), Some(b)) => Some((a, b)),\n            _ => None,\n        }\n    }\n\n    /// Zips `self` and another `Option` with function `f`.\n    ///\n    /// If `self` is `Some(s)` and `other` is `Some(o)`, this method returns `Some(f(s, o))`.\n    /// Otherwise, `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_zip)]\n    ///\n    /// #[derive(Debug, PartialEq)]\n    /// struct Point {\n    ///     x: f64,\n    ///     y: f64,\n    /// }\n    ///\n    /// impl Point {\n    ///     fn new(x: f64, y: f64) -> Self {\n    ///         Self { x, y }\n    ///     }\n    /// }\n    ///\n    /// let x = Some(17.5);\n    /// let y = Some(42.7);\n    ///\n    /// assert_eq!(x.zip_with(y, Point::new), Some(Point { x: 17.5, y: 42.7 }));\n    /// assert_eq!(x.zip_with(None, Point::new), None);\n    /// ```\n    #[unstable(feature = \"option_zip\", issue = \"70086\")]\n    pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>\n    where\n        F: FnOnce(T, U) -> R,\n    {\n        Some(f(self?, other?))\n    }\n}\n\nimpl<T: Copy> Option<&T> {\n    /// Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 12;\n    /// let opt_x = Some(&x);\n    /// assert_eq!(opt_x, Some(&12));\n    /// let copied = opt_x.copied();\n    /// assert_eq!(copied, Some(12));\n    /// ```\n    #[stable(feature = \"copied\", since = \"1.35.0\")]\n    pub fn copied(self) -> Option<T> {\n        self.map(|&t| t)\n    }\n}\n\nimpl<T: Copy> Option<&mut T> {\n    /// Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = 12;\n    /// let opt_x = Some(&mut x);\n    /// assert_eq!(opt_x, Some(&mut 12));\n    /// let copied = opt_x.copied();\n    /// assert_eq!(copied, Some(12));\n    /// ```\n    #[stable(feature = \"copied\", since = \"1.35.0\")]\n    pub fn copied(self) -> Option<T> {\n        self.map(|&mut t| t)\n    }\n}\n\nimpl<T: Clone> Option<&T> {\n    /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 12;\n    /// let opt_x = Some(&x);\n    /// assert_eq!(opt_x, Some(&12));\n    /// let cloned = opt_x.cloned();\n    /// assert_eq!(cloned, Some(12));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn cloned(self) -> Option<T> {\n        self.map(|t| t.clone())\n    }\n}\n\nimpl<T: Clone> Option<&mut T> {\n    /// Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = 12;\n    /// let opt_x = Some(&mut x);\n    /// assert_eq!(opt_x, Some(&mut 12));\n    /// let cloned = opt_x.cloned();\n    /// assert_eq!(cloned, Some(12));\n    /// ```\n    #[stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")]\n    pub fn cloned(self) -> Option<T> {\n        self.map(|t| t.clone())\n    }\n}\n\nimpl<T: Default> Option<T> {\n    /// Returns the contained [`Some`] value or a default\n    ///\n    /// Consumes the `self` argument then, if [`Some`], returns the contained\n    /// value, otherwise if [`None`], returns the [default value] for that\n    /// type.\n    ///\n    /// # Examples\n    ///\n    /// Converts a string to an integer, turning poorly-formed strings\n    /// into 0 (the default value for integers). [`parse`] converts\n    /// a string to any other type that implements [`FromStr`], returning\n    /// [`None`] on error.\n    ///\n    /// ```\n    /// let good_year_from_input = \"1909\";\n    /// let bad_year_from_input = \"190blarg\";\n    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n    ///\n    /// assert_eq!(1909, good_year);\n    /// assert_eq!(0, bad_year);\n    /// ```\n    ///\n    /// [default value]: Default::default\n    /// [`parse`]: str::parse\n    /// [`FromStr`]: crate::str::FromStr\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_default(self) -> T {\n        match self {\n            Some(x) => x,\n            None => Default::default(),\n        }\n    }\n}\n\nimpl<T: Deref> Option<T> {\n    /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.\n    ///\n    /// Leaves the original Option in-place, creating a new one with a reference\n    /// to the original one, additionally coercing the contents via [`Deref`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<String> = Some(\"hey\".to_owned());\n    /// assert_eq!(x.as_deref(), Some(\"hey\"));\n    ///\n    /// let x: Option<String> = None;\n    /// assert_eq!(x.as_deref(), None);\n    /// ```\n    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n    pub fn as_deref(&self) -> Option<&T::Target> {\n        self.as_ref().map(|t| t.deref())\n    }\n}\n\nimpl<T: DerefMut> Option<T> {\n    /// Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.\n    ///\n    /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n    /// the inner type's `Deref::Target` type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x: Option<String> = Some(\"hey\".to_owned());\n    /// assert_eq!(x.as_deref_mut().map(|x| {\n    ///     x.make_ascii_uppercase();\n    ///     x\n    /// }), Some(\"HEY\".to_owned().as_mut_str()));\n    /// ```\n    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n    pub fn as_deref_mut(&mut self) -> Option<&mut T::Target> {\n        self.as_mut().map(|t| t.deref_mut())\n    }\n}\n\nimpl<T, E> Option<Result<T, E>> {\n    /// Transposes an `Option` of a [`Result`] into a [`Result`] of an `Option`.\n    ///\n    /// [`None`] will be mapped to [`Ok`]`(`[`None`]`)`.\n    /// [`Some`]`(`[`Ok`]`(_))` and [`Some`]`(`[`Err`]`(_))` will be mapped to\n    /// [`Ok`]`(`[`Some`]`(_))` and [`Err`]`(_)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #[derive(Debug, Eq, PartialEq)]\n    /// struct SomeErr;\n    ///\n    /// let x: Result<Option<i32>, SomeErr> = Ok(Some(5));\n    /// let y: Option<Result<i32, SomeErr>> = Some(Ok(5));\n    /// assert_eq!(x, y.transpose());\n    /// ```\n    #[inline]\n    #[stable(feature = \"transpose_result\", since = \"1.33.0\")]\n    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n    pub const fn transpose(self) -> Result<Option<T>, E> {\n        match self {\n            Some(Ok(x)) => Ok(Some(x)),\n            Some(Err(e)) => Err(e),\n            None => Ok(None),\n        }\n    }\n}\n\n// This is a separate function to reduce the code size of .expect() itself.\n#[inline(never)]\n#[cold]\n#[track_caller]\nfn expect_failed(msg: &str) -> ! {\n    panic!(\"{}\", msg)\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Trait implementations\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for Option<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        match self {\n            Some(x) => Some(x.clone()),\n            None => None,\n        }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, source: &Self) {\n        match (self, source) {\n            (Some(to), Some(from)) => to.clone_from(from),\n            (to, from) => *to = from.clone(),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Option<T> {\n    /// Returns [`None`][Option::None].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let opt: Option<u32> = Option::default();\n    /// assert!(opt.is_none());\n    /// ```\n    #[inline]\n    fn default() -> Option<T> {\n        None\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for Option<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Returns a consuming iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"string\");\n    /// let v: Vec<&str> = x.into_iter().collect();\n    /// assert_eq!(v, [\"string\"]);\n    ///\n    /// let x = None;\n    /// let v: Vec<&str> = x.into_iter().collect();\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter { inner: Item { opt: self } }\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"option_iter\")]\nimpl<'a, T> IntoIterator for &'a Option<T> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(since = \"1.4.0\", feature = \"option_iter\")]\nimpl<'a, T> IntoIterator for &'a mut Option<T> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n#[stable(since = \"1.12.0\", feature = \"option_from\")]\nimpl<T> From<T> for Option<T> {\n    /// Copies `val` into a new `Some`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let o: Option<u8> = Option::from(67);\n    ///\n    /// assert_eq!(Some(67), o);\n    /// ```\n    fn from(val: T) -> Option<T> {\n        Some(val)\n    }\n}\n\n#[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\nimpl<'a, T> From<&'a Option<T>> for Option<&'a T> {\n    /// Converts from `&Option<T>` to `Option<&T>`.\n    ///\n    /// # Examples\n    ///\n    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n    /// The [`map`] method takes the `self` argument by value, consuming the original,\n    /// so this technique uses `from` to first take an `Option` to a reference\n    /// to the value inside the original.\n    ///\n    /// [`map`]: Option::map\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// ```\n    /// let s: Option<String> = Some(String::from(\"Hello, Rustaceans!\"));\n    /// let o: Option<usize> = Option::from(&s).map(|ss: &String| ss.len());\n    ///\n    /// println!(\"Can still print s: {:?}\", s);\n    ///\n    /// assert_eq!(o, Some(18));\n    /// ```\n    fn from(o: &'a Option<T>) -> Option<&'a T> {\n        o.as_ref()\n    }\n}\n\n#[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\nimpl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {\n    /// Converts from `&mut Option<T>` to `Option<&mut T>`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut s = Some(String::from(\"Hello\"));\n    /// let o: Option<&mut String> = Option::from(&mut s);\n    ///\n    /// match o {\n    ///     Some(t) => *t = String::from(\"Hello, Rustaceans!\"),\n    ///     None => (),\n    /// }\n    ///\n    /// assert_eq!(s, Some(String::from(\"Hello, Rustaceans!\")));\n    /// ```\n    fn from(o: &'a mut Option<T>) -> Option<&'a mut T> {\n        o.as_mut()\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The Option Iterators\n/////////////////////////////////////////////////////////////////////////////\n\n#[derive(Clone, Debug)]\nstruct Item<A> {\n    opt: Option<A>,\n}\n\nimpl<A> Iterator for Item<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        self.opt.take()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self.opt {\n            Some(_) => (1, Some(1)),\n            None => (0, Some(0)),\n        }\n    }\n}\n\nimpl<A> DoubleEndedIterator for Item<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n        self.opt.take()\n    }\n}\n\nimpl<A> ExactSizeIterator for Item<A> {}\nimpl<A> FusedIterator for Item<A> {}\nunsafe impl<A> TrustedLen for Item<A> {}\n\n/// An iterator over a reference to the [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::iter`] function.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Iter<'a, A: 'a> {\n    inner: Item<&'a A>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> Iterator for Iter<'a, A> {\n    type Item = &'a A;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a A> {\n        self.inner.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a A> {\n        self.inner.next_back()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> ExactSizeIterator for Iter<'_, A> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<A> FusedIterator for Iter<'_, A> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A> TrustedLen for Iter<'_, A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> Clone for Iter<'_, A> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Iter { inner: self.inner.clone() }\n    }\n}\n\n/// An iterator over a mutable reference to the [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::iter_mut`] function.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct IterMut<'a, A: 'a> {\n    inner: Item<&'a mut A>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> Iterator for IterMut<'a, A> {\n    type Item = &'a mut A;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut A> {\n        self.inner.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut A> {\n        self.inner.next_back()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> ExactSizeIterator for IterMut<'_, A> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<A> FusedIterator for IterMut<'_, A> {}\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A> TrustedLen for IterMut<'_, A> {}\n\n/// An iterator over the value in [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::into_iter`] function.\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<A> {\n    inner: Item<A>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> Iterator for IntoIter<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        self.inner.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> DoubleEndedIterator for IntoIter<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n        self.inner.next_back()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> ExactSizeIterator for IntoIter<A> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<A> FusedIterator for IntoIter<A> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A> TrustedLen for IntoIter<A> {}\n\n/////////////////////////////////////////////////////////////////////////////\n// FromIterator\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n    /// Takes each element in the [`Iterator`]: if it is [`None`][Option::None],\n    /// no further elements are taken, and the [`None`][Option::None] is\n    /// returned. Should no [`None`][Option::None] occur, a container with the\n    /// values of each [`Option`] is returned.\n    ///\n    /// # Examples\n    ///\n    /// Here is an example which increments every integer in a vector.\n    /// We use the checked variant of `add` that returns `None` when the\n    /// calculation would result in an overflow.\n    ///\n    /// ```\n    /// let items = vec![0_u16, 1, 2];\n    ///\n    /// let res: Option<Vec<u16>> = items\n    ///     .iter()\n    ///     .map(|x| x.checked_add(1))\n    ///     .collect();\n    ///\n    /// assert_eq!(res, Some(vec![1, 2, 3]));\n    /// ```\n    ///\n    /// As you can see, this will return the expected, valid items.\n    ///\n    /// Here is another example that tries to subtract one from another list\n    /// of integers, this time checking for underflow:\n    ///\n    /// ```\n    /// let items = vec![2_u16, 1, 0];\n    ///\n    /// let res: Option<Vec<u16>> = items\n    ///     .iter()\n    ///     .map(|x| x.checked_sub(1))\n    ///     .collect();\n    ///\n    /// assert_eq!(res, None);\n    /// ```\n    ///\n    /// Since the last element is zero, it would underflow. Thus, the resulting\n    /// value is `None`.\n    ///\n    /// Here is a variation on the previous example, showing that no\n    /// further elements are taken from `iter` after the first `None`.\n    ///\n    /// ```\n    /// let items = vec![3_u16, 2, 1, 10];\n    ///\n    /// let mut shared = 0;\n    ///\n    /// let res: Option<Vec<u16>> = items\n    ///     .iter()\n    ///     .map(|x| { shared += x; x.checked_sub(2) })\n    ///     .collect();\n    ///\n    /// assert_eq!(res, None);\n    /// assert_eq!(shared, 6);\n    /// ```\n    ///\n    /// Since the third element caused an underflow, no further elements were taken,\n    /// so the final value of `shared` is 6 (= `3 + 2 + 1`), not 16.\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = Option<A>>>(iter: I) -> Option<V> {\n        // FIXME(#11084): This could be replaced with Iterator::scan when this\n        // performance bug is closed.\n\n        iter.into_iter().map(|x| x.ok_or(())).collect::<Result<_, _>>().ok()\n    }\n}\n\n/// The error type that results from applying the try operator (`?`) to a `None` value. If you wish\n/// to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can\n/// implement `impl From<NoneError>` for `YourErrorType`. In that case, `x?` within a function that\n/// returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result.\n#[rustc_diagnostic_item = \"none_error\"]\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[cfg(bootstrap)]\npub struct NoneError;\n\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\n#[cfg(bootstrap)]\nimpl<T> ops::TryV1 for Option<T> {\n    type Output = T;\n    type Error = NoneError;\n\n    #[inline]\n    fn into_result(self) -> Result<T, NoneError> {\n        self.ok_or(NoneError)\n    }\n\n    #[inline]\n    fn from_ok(v: T) -> Self {\n        Some(v)\n    }\n\n    #[inline]\n    fn from_error(_: NoneError) -> Self {\n        None\n    }\n}\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\nimpl<T> ops::TryV2 for Option<T> {\n    type Output = T;\n    type Residual = Option<convert::Infallible>;\n\n    #[inline]\n    fn from_output(output: Self::Output) -> Self {\n        Some(output)\n    }\n\n    #[inline]\n    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Some(v) => ControlFlow::Continue(v),\n            None => ControlFlow::Break(None),\n        }\n    }\n}\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\nimpl<T> ops::FromResidual for Option<T> {\n    #[inline]\n    fn from_residual(residual: Option<convert::Infallible>) -> Self {\n        match residual {\n            None => None,\n        }\n    }\n}\n\nimpl<T> Option<Option<T>> {\n    /// Converts from `Option<Option<T>>` to `Option<T>`\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Option<Option<u32>> = Some(Some(6));\n    /// assert_eq!(Some(6), x.flatten());\n    ///\n    /// let x: Option<Option<u32>> = Some(None);\n    /// assert_eq!(None, x.flatten());\n    ///\n    /// let x: Option<Option<u32>> = None;\n    /// assert_eq!(None, x.flatten());\n    /// ```\n    ///\n    /// Flattening only removes one level of nesting at a time:\n    ///\n    /// ```\n    /// let x: Option<Option<Option<u32>>> = Some(Some(Some(6)));\n    /// assert_eq!(Some(Some(6)), x.flatten());\n    /// assert_eq!(Some(6), x.flatten().flatten());\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_flattening\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n    pub const fn flatten(self) -> Option<T> {\n        match self {\n            Some(inner) => inner,\n            None => None,\n        }\n    }\n}\n"],[2834,"//! This is an internal module used by the ifmt! runtime. These structures are\n//! emitted to static arrays to precompile format strings ahead of time.\n//!\n//! These definitions are similar to their `ct` equivalents, but differ in that\n//! these can be statically allocated and are slightly optimized for the runtime\n#![allow(missing_debug_implementations)]\n\n#[derive(Copy, Clone)]\npub struct Argument {\n    pub position: usize,\n    pub format: FormatSpec,\n}\n\n#[derive(Copy, Clone)]\npub struct FormatSpec {\n    pub fill: char,\n    pub align: Alignment,\n    pub flags: u32,\n    pub precision: Count,\n    pub width: Count,\n}\n\n/// Possible alignments that can be requested as part of a formatting directive.\n#[derive(Copy, Clone, PartialEq, Eq)]\npub enum Alignment {\n    /// Indication that contents should be left-aligned.\n    Left,\n    /// Indication that contents should be right-aligned.\n    Right,\n    /// Indication that contents should be center-aligned.\n    Center,\n    /// No alignment was requested.\n    Unknown,\n}\n\n/// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n#[derive(Copy, Clone)]\npub enum Count {\n    /// Specified with a literal number, stores the value\n    Is(usize),\n    /// Specified using `$` and `*` syntaxes, stores the index into `args`\n    Param(usize),\n    /// Not specified\n    Implied,\n}\n"],[2835,"use crate::fmt::{Debug, Display, Formatter, LowerExp, Result, UpperExp};\nuse crate::mem::MaybeUninit;\nuse crate::num::flt2dec;\n\n// Don't inline this so callers don't use the stack space this function\n// requires unless they have to.\n#[inline(never)]\nfn float_to_decimal_common_exact<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    precision: usize,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n    let mut buf: [MaybeUninit<u8>; 1024] = MaybeUninit::uninit_array(); // enough for f32 and f64\n    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 4] = MaybeUninit::uninit_array();\n    let formatted = flt2dec::to_exact_fixed_str(\n        flt2dec::strategy::grisu::format_exact,\n        *num,\n        sign,\n        precision,\n        &mut buf,\n        &mut parts,\n    );\n    fmt.pad_formatted_parts(&formatted)\n}\n\n// Don't inline this so callers that call both this and the above won't wind\n// up using the combined stack space of both functions in some cases.\n#[inline(never)]\nfn float_to_decimal_common_shortest<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    precision: usize,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n    // enough for f32 and f64\n    let mut buf: [MaybeUninit<u8>; flt2dec::MAX_SIG_DIGITS] = MaybeUninit::uninit_array();\n    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 4] = MaybeUninit::uninit_array();\n    let formatted = flt2dec::to_shortest_str(\n        flt2dec::strategy::grisu::format_shortest,\n        *num,\n        sign,\n        precision,\n        &mut buf,\n        &mut parts,\n    );\n    fmt.pad_formatted_parts(&formatted)\n}\n\n// Common code of floating point Debug and Display.\nfn float_to_decimal_common<T>(fmt: &mut Formatter<'_>, num: &T, min_precision: usize) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n    let force_sign = fmt.sign_plus();\n    let sign = match force_sign {\n        false => flt2dec::Sign::Minus,\n        true => flt2dec::Sign::MinusPlus,\n    };\n\n    if let Some(precision) = fmt.precision {\n        float_to_decimal_common_exact(fmt, num, sign, precision)\n    } else {\n        float_to_decimal_common_shortest(fmt, num, sign, min_precision)\n    }\n}\n\n// Don't inline this so callers don't use the stack space this function\n// requires unless they have to.\n#[inline(never)]\nfn float_to_exponential_common_exact<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    precision: usize,\n    upper: bool,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n    let mut buf: [MaybeUninit<u8>; 1024] = MaybeUninit::uninit_array(); // enough for f32 and f64\n    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 6] = MaybeUninit::uninit_array();\n    let formatted = flt2dec::to_exact_exp_str(\n        flt2dec::strategy::grisu::format_exact,\n        *num,\n        sign,\n        precision,\n        upper,\n        &mut buf,\n        &mut parts,\n    );\n    fmt.pad_formatted_parts(&formatted)\n}\n\n// Don't inline this so callers that call both this and the above won't wind\n// up using the combined stack space of both functions in some cases.\n#[inline(never)]\nfn float_to_exponential_common_shortest<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    upper: bool,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n    // enough for f32 and f64\n    let mut buf: [MaybeUninit<u8>; flt2dec::MAX_SIG_DIGITS] = MaybeUninit::uninit_array();\n    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 6] = MaybeUninit::uninit_array();\n    let formatted = flt2dec::to_shortest_exp_str(\n        flt2dec::strategy::grisu::format_shortest,\n        *num,\n        sign,\n        (0, 0),\n        upper,\n        &mut buf,\n        &mut parts,\n    );\n    fmt.pad_formatted_parts(&formatted)\n}\n\n// Common code of floating point LowerExp and UpperExp.\nfn float_to_exponential_common<T>(fmt: &mut Formatter<'_>, num: &T, upper: bool) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n    let force_sign = fmt.sign_plus();\n    let sign = match force_sign {\n        false => flt2dec::Sign::Minus,\n        true => flt2dec::Sign::MinusPlus,\n    };\n\n    if let Some(precision) = fmt.precision {\n        // 1 integral digit + `precision` fractional digits = `precision + 1` total digits\n        float_to_exponential_common_exact(fmt, num, sign, precision + 1, upper)\n    } else {\n        float_to_exponential_common_shortest(fmt, num, sign, upper)\n    }\n}\n\nmacro_rules! floating {\n    ($ty:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Debug for $ty {\n            fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n                float_to_decimal_common(fmt, self, 1)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Display for $ty {\n            fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n                float_to_decimal_common(fmt, self, 0)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl LowerExp for $ty {\n            fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n                float_to_exponential_common(fmt, self, false)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl UpperExp for $ty {\n            fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n                float_to_exponential_common(fmt, self, true)\n            }\n        }\n    };\n}\n\nfloating! { f32 }\nfloating! { f64 }\n"],[2836,"#![allow(unused_imports)]\n\nuse crate::fmt::{self, Debug, Formatter};\n\nstruct PadAdapter<'buf, 'state> {\n    buf: &'buf mut (dyn fmt::Write + 'buf),\n    state: &'state mut PadAdapterState,\n}\n\nstruct PadAdapterState {\n    on_newline: bool,\n}\n\nimpl Default for PadAdapterState {\n    fn default() -> Self {\n        PadAdapterState { on_newline: true }\n    }\n}\n\nimpl<'buf, 'state> PadAdapter<'buf, 'state> {\n    fn wrap<'slot, 'fmt: 'buf + 'slot>(\n        fmt: &'fmt mut fmt::Formatter<'_>,\n        slot: &'slot mut Option<Self>,\n        state: &'state mut PadAdapterState,\n    ) -> fmt::Formatter<'slot> {\n        fmt.wrap_buf(move |buf| {\n            *slot = Some(PadAdapter { buf, state });\n            slot.as_mut().unwrap()\n        })\n    }\n}\n\nimpl fmt::Write for PadAdapter<'_, '_> {\n    fn write_str(&mut self, mut s: &str) -> fmt::Result {\n        while !s.is_empty() {\n            if self.state.on_newline {\n                self.buf.write_str(\"    \")?;\n            }\n\n            let split = match s.find('\\n') {\n                Some(pos) => {\n                    self.state.on_newline = true;\n                    pos + 1\n                }\n                None => {\n                    self.state.on_newline = false;\n                    s.len()\n                }\n            };\n            self.buf.write_str(&s[..split])?;\n            s = &s[split..];\n        }\n\n        Ok(())\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](Debug) implementations.\n///\n/// This is useful when you wish to output a formatted struct as a part of your\n/// [`Debug::fmt`] implementation.\n///\n/// This can be constructed by the [`Formatter::debug_struct`] method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo {\n///     bar: i32,\n///     baz: String,\n/// }\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_struct(\"Foo\")\n///            .field(\"bar\", &self.bar)\n///            .field(\"baz\", &self.baz)\n///            .finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() }),\n///     \"Foo { bar: 10, baz: \\\"Hello World\\\" }\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugStruct<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    has_fields: bool,\n}\n\npub(super) fn debug_struct_new<'a, 'b>(\n    fmt: &'a mut fmt::Formatter<'b>,\n    name: &str,\n) -> DebugStruct<'a, 'b> {\n    let result = fmt.write_str(name);\n    DebugStruct { fmt, result, has_fields: false }\n}\n\nimpl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n    /// Adds a new field to the generated struct output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Bar {\n    ///     bar: i32,\n    ///     another: String,\n    /// }\n    ///\n    /// impl fmt::Debug for Bar {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_struct(\"Bar\")\n    ///            .field(\"bar\", &self.bar) // We add `bar` field.\n    ///            .field(\"another\", &self.another) // We add `another` field.\n    ///            // We even add a field which doesn't exist (because why not?).\n    ///            .field(\"not_existing_field\", &1)\n    ///            .finish() // We're good to go!\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n    ///     \"Bar { bar: 10, another: \\\"Hello World\\\", not_existing_field: 1 }\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn field(&mut self, name: &str, value: &dyn fmt::Debug) -> &mut Self {\n        self.result = self.result.and_then(|_| {\n            if self.is_pretty() {\n                if !self.has_fields {\n                    self.fmt.write_str(\" {\\n\")?;\n                }\n                let mut slot = None;\n                let mut state = Default::default();\n                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                writer.write_str(name)?;\n                writer.write_str(\": \")?;\n                value.fmt(&mut writer)?;\n                writer.write_str(\",\\n\")\n            } else {\n                let prefix = if self.has_fields { \", \" } else { \" { \" };\n                self.fmt.write_str(prefix)?;\n                self.fmt.write_str(name)?;\n                self.fmt.write_str(\": \")?;\n                value.fmt(self.fmt)\n            }\n        });\n\n        self.has_fields = true;\n        self\n    }\n\n    /// Marks the struct as non-exhaustive, indicating to the reader that there are some other\n    /// fields that are not shown in the debug representation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Bar {\n    ///     bar: i32,\n    ///     hidden: f32,\n    /// }\n    ///\n    /// impl fmt::Debug for Bar {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_struct(\"Bar\")\n    ///            .field(\"bar\", &self.bar)\n    ///            .finish_non_exhaustive() // Show that some other field(s) exist.\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Bar { bar: 10, hidden: 1.0 }),\n    ///     \"Bar { bar: 10, .. }\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_non_exhaustive\", since = \"1.53.0\")]\n    pub fn finish_non_exhaustive(&mut self) -> fmt::Result {\n        self.result = self.result.and_then(|_| {\n            if self.has_fields {\n                if self.is_pretty() {\n                    let mut slot = None;\n                    let mut state = Default::default();\n                    let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                    writer.write_str(\"..\\n\")?;\n                    self.fmt.write_str(\"}\")\n                } else {\n                    self.fmt.write_str(\", .. }\")\n                }\n            } else {\n                self.fmt.write_str(\" { .. }\")\n            }\n        });\n        self.result\n    }\n\n    /// Finishes output and returns any error encountered.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Bar {\n    ///     bar: i32,\n    ///     baz: String,\n    /// }\n    ///\n    /// impl fmt::Debug for Bar {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_struct(\"Bar\")\n    ///            .field(\"bar\", &self.bar)\n    ///            .field(\"baz\", &self.baz)\n    ///            .finish() // You need to call it to \"finish\" the\n    ///                      // struct formatting.\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Bar { bar: 10, baz: \"Hello World\".to_string() }),\n    ///     \"Bar { bar: 10, baz: \\\"Hello World\\\" }\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        if self.has_fields {\n            self.result = self.result.and_then(|_| {\n                if self.is_pretty() { self.fmt.write_str(\"}\") } else { self.fmt.write_str(\" }\") }\n            });\n        }\n        self.result\n    }\n\n    fn is_pretty(&self) -> bool {\n        self.fmt.alternate()\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](Debug) implementations.\n///\n/// This is useful when you wish to output a formatted tuple as a part of your\n/// [`Debug::fmt`] implementation.\n///\n/// This can be constructed by the [`Formatter::debug_tuple`] method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(i32, String);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_tuple(\"Foo\")\n///            .field(&self.0)\n///            .field(&self.1)\n///            .finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo(10, \"Hello World\".to_string())),\n///     \"Foo(10, \\\"Hello World\\\")\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugTuple<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    fields: usize,\n    empty_name: bool,\n}\n\npub(super) fn debug_tuple_new<'a, 'b>(\n    fmt: &'a mut fmt::Formatter<'b>,\n    name: &str,\n) -> DebugTuple<'a, 'b> {\n    let result = fmt.write_str(name);\n    DebugTuple { fmt, result, fields: 0, empty_name: name.is_empty() }\n}\n\nimpl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n    /// Adds a new field to the generated tuple struct output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32, String);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///            .field(&self.0) // We add the first field.\n    ///            .field(&self.1) // We add the second field.\n    ///            .finish() // We're good to go!\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(10, \"Hello World\".to_string())),\n    ///     \"Foo(10, \\\"Hello World\\\")\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn field(&mut self, value: &dyn fmt::Debug) -> &mut Self {\n        self.result = self.result.and_then(|_| {\n            if self.is_pretty() {\n                if self.fields == 0 {\n                    self.fmt.write_str(\"(\\n\")?;\n                }\n                let mut slot = None;\n                let mut state = Default::default();\n                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                value.fmt(&mut writer)?;\n                writer.write_str(\",\\n\")\n            } else {\n                let prefix = if self.fields == 0 { \"(\" } else { \", \" };\n                self.fmt.write_str(prefix)?;\n                value.fmt(self.fmt)\n            }\n        });\n\n        self.fields += 1;\n        self\n    }\n\n    /// Finishes output and returns any error encountered.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32, String);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///            .field(&self.0)\n    ///            .field(&self.1)\n    ///            .finish() // You need to call it to \"finish\" the\n    ///                      // tuple formatting.\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(10, \"Hello World\".to_string())),\n    ///     \"Foo(10, \\\"Hello World\\\")\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        if self.fields > 0 {\n            self.result = self.result.and_then(|_| {\n                if self.fields == 1 && self.empty_name && !self.is_pretty() {\n                    self.fmt.write_str(\",\")?;\n                }\n                self.fmt.write_str(\")\")\n            });\n        }\n        self.result\n    }\n\n    fn is_pretty(&self) -> bool {\n        self.fmt.alternate()\n    }\n}\n\nstruct DebugInner<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    has_fields: bool,\n}\n\nimpl<'a, 'b: 'a> DebugInner<'a, 'b> {\n    fn entry(&mut self, entry: &dyn fmt::Debug) {\n        self.result = self.result.and_then(|_| {\n            if self.is_pretty() {\n                if !self.has_fields {\n                    self.fmt.write_str(\"\\n\")?;\n                }\n                let mut slot = None;\n                let mut state = Default::default();\n                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                entry.fmt(&mut writer)?;\n                writer.write_str(\",\\n\")\n            } else {\n                if self.has_fields {\n                    self.fmt.write_str(\", \")?\n                }\n                entry.fmt(self.fmt)\n            }\n        });\n\n        self.has_fields = true;\n    }\n\n    fn is_pretty(&self) -> bool {\n        self.fmt.alternate()\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](Debug) implementations.\n///\n/// This is useful when you wish to output a formatted set of items as a part\n/// of your [`Debug::fmt`] implementation.\n///\n/// This can be constructed by the [`Formatter::debug_set`] method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(Vec<i32>);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_set().entries(self.0.iter()).finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo(vec![10, 11])),\n///     \"{10, 11}\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugSet<'a, 'b: 'a> {\n    inner: DebugInner<'a, 'b>,\n}\n\npub(super) fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> {\n    let result = fmt.write_str(\"{\");\n    DebugSet { inner: DebugInner { fmt, result, has_fields: false } }\n}\n\nimpl<'a, 'b: 'a> DebugSet<'a, 'b> {\n    /// Adds a new entry to the set output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>, Vec<u32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_set()\n    ///            .entry(&self.0) // Adds the first \"entry\".\n    ///            .entry(&self.1) // Adds the second \"entry\".\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![10, 11], vec![12, 13])),\n    ///     \"{[10, 11], [12, 13]}\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entry(&mut self, entry: &dyn fmt::Debug) -> &mut Self {\n        self.inner.entry(entry);\n        self\n    }\n\n    /// Adds the contents of an iterator of entries to the set output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>, Vec<u32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_set()\n    ///            .entries(self.0.iter()) // Adds the first \"entry\".\n    ///            .entries(self.1.iter()) // Adds the second \"entry\".\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![10, 11], vec![12, 13])),\n    ///     \"{10, 11, 12, 13}\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entries<D, I>(&mut self, entries: I) -> &mut Self\n    where\n        D: fmt::Debug,\n        I: IntoIterator<Item = D>,\n    {\n        for entry in entries {\n            self.entry(&entry);\n        }\n        self\n    }\n\n    /// Finishes output and returns any error encountered.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_set()\n    ///            .entries(self.0.iter())\n    ///            .finish() // Ends the struct formatting.\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![10, 11])),\n    ///     \"{10, 11}\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        self.inner.result.and_then(|_| self.inner.fmt.write_str(\"}\"))\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](Debug) implementations.\n///\n/// This is useful when you wish to output a formatted list of items as a part\n/// of your [`Debug::fmt`] implementation.\n///\n/// This can be constructed by the [`Formatter::debug_list`] method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(Vec<i32>);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_list().entries(self.0.iter()).finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo(vec![10, 11])),\n///     \"[10, 11]\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugList<'a, 'b: 'a> {\n    inner: DebugInner<'a, 'b>,\n}\n\npub(super) fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> {\n    let result = fmt.write_str(\"[\");\n    DebugList { inner: DebugInner { fmt, result, has_fields: false } }\n}\n\nimpl<'a, 'b: 'a> DebugList<'a, 'b> {\n    /// Adds a new entry to the list output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>, Vec<u32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_list()\n    ///            .entry(&self.0) // We add the first \"entry\".\n    ///            .entry(&self.1) // We add the second \"entry\".\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![10, 11], vec![12, 13])),\n    ///     \"[[10, 11], [12, 13]]\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entry(&mut self, entry: &dyn fmt::Debug) -> &mut Self {\n        self.inner.entry(entry);\n        self\n    }\n\n    /// Adds the contents of an iterator of entries to the list output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>, Vec<u32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_list()\n    ///            .entries(self.0.iter())\n    ///            .entries(self.1.iter())\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![10, 11], vec![12, 13])),\n    ///     \"[10, 11, 12, 13]\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entries<D, I>(&mut self, entries: I) -> &mut Self\n    where\n        D: fmt::Debug,\n        I: IntoIterator<Item = D>,\n    {\n        for entry in entries {\n            self.entry(&entry);\n        }\n        self\n    }\n\n    /// Finishes output and returns any error encountered.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_list()\n    ///            .entries(self.0.iter())\n    ///            .finish() // Ends the struct formatting.\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![10, 11])),\n    ///     \"[10, 11]\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        self.inner.result.and_then(|_| self.inner.fmt.write_str(\"]\"))\n    }\n}\n\n/// A struct to help with [`fmt::Debug`](Debug) implementations.\n///\n/// This is useful when you wish to output a formatted map as a part of your\n/// [`Debug::fmt`] implementation.\n///\n/// This can be constructed by the [`Formatter::debug_map`] method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(Vec<(String, i32)>);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n///     \"{\\\"A\\\": 10, \\\"B\\\": 11}\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugMap<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    has_fields: bool,\n    has_key: bool,\n    // The state of newlines is tracked between keys and values\n    state: PadAdapterState,\n}\n\npub(super) fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n    let result = fmt.write_str(\"{\");\n    DebugMap { fmt, result, has_fields: false, has_key: false, state: Default::default() }\n}\n\nimpl<'a, 'b: 'a> DebugMap<'a, 'b> {\n    /// Adds a new entry to the map output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<(String, i32)>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_map()\n    ///            .entry(&\"whole\", &self.0) // We add the \"whole\" entry.\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n    ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entry(&mut self, key: &dyn fmt::Debug, value: &dyn fmt::Debug) -> &mut Self {\n        self.key(key).value(value)\n    }\n\n    /// Adds the key part of a new entry to the map output.\n    ///\n    /// This method, together with `value`, is an alternative to `entry` that\n    /// can be used when the complete entry isn't known upfront. Prefer the `entry`\n    /// method when it's possible to use.\n    ///\n    /// # Panics\n    ///\n    /// `key` must be called before `value` and each call to `key` must be followed\n    /// by a corresponding call to `value`. Otherwise this method will panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<(String, i32)>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_map()\n    ///            .key(&\"whole\").value(&self.0) // We add the \"whole\" entry.\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n    ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_map_key_value\", since = \"1.42.0\")]\n    pub fn key(&mut self, key: &dyn fmt::Debug) -> &mut Self {\n        self.result = self.result.and_then(|_| {\n            assert!(\n                !self.has_key,\n                \"attempted to begin a new map entry \\\n                                    without completing the previous one\"\n            );\n\n            if self.is_pretty() {\n                if !self.has_fields {\n                    self.fmt.write_str(\"\\n\")?;\n                }\n                let mut slot = None;\n                self.state = Default::default();\n                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n                key.fmt(&mut writer)?;\n                writer.write_str(\": \")?;\n            } else {\n                if self.has_fields {\n                    self.fmt.write_str(\", \")?\n                }\n                key.fmt(self.fmt)?;\n                self.fmt.write_str(\": \")?;\n            }\n\n            self.has_key = true;\n            Ok(())\n        });\n\n        self\n    }\n\n    /// Adds the value part of a new entry to the map output.\n    ///\n    /// This method, together with `key`, is an alternative to `entry` that\n    /// can be used when the complete entry isn't known upfront. Prefer the `entry`\n    /// method when it's possible to use.\n    ///\n    /// # Panics\n    ///\n    /// `key` must be called before `value` and each call to `key` must be followed\n    /// by a corresponding call to `value`. Otherwise this method will panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<(String, i32)>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_map()\n    ///            .key(&\"whole\").value(&self.0) // We add the \"whole\" entry.\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n    ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_map_key_value\", since = \"1.42.0\")]\n    pub fn value(&mut self, value: &dyn fmt::Debug) -> &mut Self {\n        self.result = self.result.and_then(|_| {\n            assert!(self.has_key, \"attempted to format a map value before its key\");\n\n            if self.is_pretty() {\n                let mut slot = None;\n                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n                value.fmt(&mut writer)?;\n                writer.write_str(\",\\n\")?;\n            } else {\n                value.fmt(self.fmt)?;\n            }\n\n            self.has_key = false;\n            Ok(())\n        });\n\n        self.has_fields = true;\n        self\n    }\n\n    /// Adds the contents of an iterator of entries to the map output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<(String, i32)>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_map()\n    ///            // We map our vec so each entries' first field will become\n    ///            // the \"key\".\n    ///            .entries(self.0.iter().map(|&(ref k, ref v)| (k, v)))\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n    ///     \"{\\\"A\\\": 10, \\\"B\\\": 11}\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entries<K, V, I>(&mut self, entries: I) -> &mut Self\n    where\n        K: fmt::Debug,\n        V: fmt::Debug,\n        I: IntoIterator<Item = (K, V)>,\n    {\n        for (k, v) in entries {\n            self.entry(&k, &v);\n        }\n        self\n    }\n\n    /// Finishes output and returns any error encountered.\n    ///\n    /// # Panics\n    ///\n    /// `key` must be called before `value` and each call to `key` must be followed\n    /// by a corresponding call to `value`. Otherwise this method will panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<(String, i32)>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_map()\n    ///            .entries(self.0.iter().map(|&(ref k, ref v)| (k, v)))\n    ///            .finish() // Ends the struct formatting.\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n    ///     \"{\\\"A\\\": 10, \\\"B\\\": 11}\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n        self.result.and_then(|_| {\n            assert!(!self.has_key, \"attempted to finish a map with a partial entry\");\n\n            self.fmt.write_str(\"}\")\n        })\n    }\n\n    fn is_pretty(&self) -> bool {\n        self.fmt.alternate()\n    }\n}\n"],[2837,"//! Utilities for formatting and printing strings.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\nuse crate::char::EscapeDebugExtArgs;\nuse crate::iter;\nuse crate::marker::PhantomData;\nuse crate::mem;\nuse crate::num::flt2dec;\nuse crate::ops::Deref;\nuse crate::result;\nuse crate::str;\n\nmod builders;\nmod float;\nmod num;\n\n#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n/// Possible alignments returned by `Formatter::align`\n#[derive(Debug)]\npub enum Alignment {\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be left-aligned.\n    Left,\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be right-aligned.\n    Right,\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be center-aligned.\n    Center,\n}\n\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n#[doc(hidden)]\npub mod rt {\n    pub mod v1;\n}\n\n/// The type returned by formatter methods.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// #[derive(Debug)]\n/// struct Triangle {\n///     a: f32,\n///     b: f32,\n///     c: f32\n/// }\n///\n/// impl fmt::Display for Triangle {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         write!(f, \"({}, {}, {})\", self.a, self.b, self.c)\n///     }\n/// }\n///\n/// let pythagorean_triple = Triangle { a: 3.0, b: 4.0, c: 5.0 };\n///\n/// assert_eq!(format!(\"{}\", pythagorean_triple), \"(3, 4, 5)\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result = result::Result<(), Error>;\n\n/// The error type which is returned from formatting a message into a stream.\n///\n/// This type does not support transmission of an error other than that an error\n/// occurred. Any extra information must be arranged to be transmitted through\n/// some other means.\n///\n/// An important thing to remember is that the type `fmt::Error` should not be\n/// confused with [`std::io::Error`] or [`std::error::Error`], which you may also\n/// have in scope.\n///\n/// [`std::io::Error`]: ../../std/io/struct.Error.html\n/// [`std::error::Error`]: ../../std/error/trait.Error.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::fmt::{self, write};\n///\n/// let mut output = String::new();\n/// if let Err(fmt::Error) = write(&mut output, format_args!(\"Hello {}!\", \"world\")) {\n///     panic!(\"An error occurred\");\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct Error;\n\n/// A trait for writing or formatting into Unicode-accepting buffers or streams.\n///\n/// This trait only accepts UTF-8–encoded data and is not [flushable]. If you only\n/// want to accept Unicode and you don't need flushing, you should implement this trait;\n/// otherwise you should implement [`std::io::Write`].\n///\n/// [`std::io::Write`]: ../../std/io/trait.Write.html\n/// [flushable]: ../../std/io/trait.Write.html#tymethod.flush\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Write {\n    /// Writes a string slice into this writer, returning whether the write\n    /// succeeded.\n    ///\n    /// This method can only succeed if the entire string slice was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_str(s)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"hola\").unwrap();\n    /// assert_eq!(&buf, \"hola\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_str(&mut self, s: &str) -> Result;\n\n    /// Writes a [`char`] into this writer, returning whether the write succeeded.\n    ///\n    /// A single [`char`] may be encoded as more than one byte.\n    /// This method can only succeed if the entire byte sequence was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n    ///     f.write_char(c)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, 'a').unwrap();\n    /// writer(&mut buf, 'b').unwrap();\n    /// assert_eq!(&buf, \"ab\");\n    /// ```\n    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n    fn write_char(&mut self, c: char) -> Result {\n        self.write_str(c.encode_utf8(&mut [0; 4]))\n    }\n\n    /// Glue for usage of the [`write!`] macro with implementors of this trait.\n    ///\n    /// This method should generally not be invoked manually, but rather through\n    /// the [`write!`] macro itself.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_fmt(format_args!(\"{}\", s))\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"world\").unwrap();\n    /// assert_eq!(&buf, \"world\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(mut self: &mut Self, args: Arguments<'_>) -> Result {\n        write(&mut self, args)\n    }\n}\n\n#[stable(feature = \"fmt_write_blanket_impl\", since = \"1.4.0\")]\nimpl<W: Write + ?Sized> Write for &mut W {\n    fn write_str(&mut self, s: &str) -> Result {\n        (**self).write_str(s)\n    }\n\n    fn write_char(&mut self, c: char) -> Result {\n        (**self).write_char(c)\n    }\n\n    fn write_fmt(&mut self, args: Arguments<'_>) -> Result {\n        (**self).write_fmt(args)\n    }\n}\n\n/// Configuration for formatting.\n///\n/// A `Formatter` represents various options related to formatting. Users do not\n/// construct `Formatter`s directly; a mutable reference to one is passed to\n/// the `fmt` method of all formatting traits, like [`Debug`] and [`Display`].\n///\n/// To interact with a `Formatter`, you'll call various methods to change the\n/// various options related to formatting. For examples, please see the\n/// documentation of the methods defined on `Formatter` below.\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Formatter<'a> {\n    flags: u32,\n    fill: char,\n    align: rt::v1::Alignment,\n    width: Option<usize>,\n    precision: Option<usize>,\n\n    buf: &'a mut (dyn Write + 'a),\n}\n\nimpl<'a> Formatter<'a> {\n    /// Creates a new formatter with default settings.\n    ///\n    /// This can be used as a micro-optimization in cases where a full `Arguments`\n    /// structure (as created by `format_args!`) is not necessary; `Arguments`\n    /// is a little more expensive to use in simple formatting scenarios.\n    ///\n    /// Currently not intended for use outside of the standard library.\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to standard library\", issue = \"none\")]\n    #[doc(hidden)]\n    pub fn new(buf: &'a mut (dyn Write + 'a)) -> Formatter<'a> {\n        Formatter {\n            flags: 0,\n            fill: ' ',\n            align: rt::v1::Alignment::Unknown,\n            width: None,\n            precision: None,\n            buf,\n        }\n    }\n}\n\n// NB. Argument is essentially an optimized partially applied formatting function,\n// equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n\nextern \"C\" {\n    type Opaque;\n}\n\n/// This struct represents the generic \"argument\" which is taken by the Xprintf\n/// family of functions. It contains a function to format the given value. At\n/// compile time it is ensured that the function and the value have the correct\n/// types, and then this struct is used to canonicalize arguments to one type.\n#[derive(Copy, Clone)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n#[doc(hidden)]\npub struct ArgumentV1<'a> {\n    value: &'a Opaque,\n    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n}\n\n// This guarantees a single stable value for the function pointer associated with\n// indices/counts in the formatting infrastructure.\n//\n// Note that a function defined as such would not be correct as functions are\n// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n// address is not considered important to LLVM and as such the as_usize cast\n// could have been miscompiled. In practice, we never call as_usize on non-usize\n// containing data (as a matter of static generation of the formatting\n// arguments), so this is merely an additional check.\n//\n// We primarily want to ensure that the function pointer at `USIZE_MARKER` has\n// an address corresponding *only* to functions that also take `&usize` as their\n// first argument. The read_volatile here ensures that we can safely ready out a\n// usize from the passed reference and that this address does not point at a\n// non-usize taking function.\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\nstatic USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |ptr, _| {\n    // SAFETY: ptr is a reference\n    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n    loop {}\n};\n\nimpl<'a> ArgumentV1<'a> {\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n        // SAFETY: `mem::transmute(x)` is safe because\n        //     1. `&'b T` keeps the lifetime it originated with `'b`\n        //              (so as to not have an unbounded lifetime)\n        //     2. `&'b T` and `&'b Opaque` have the same memory layout\n        //              (when `T` is `Sized`, as it is here)\n        // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`\n        // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the same ABI\n        // (as long as `T` is `Sized`)\n        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n    }\n\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n        ArgumentV1::new(x, USIZE_MARKER)\n    }\n\n    fn as_usize(&self) -> Option<usize> {\n        if self.formatter as usize == USIZE_MARKER as usize {\n            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n            // the value is a usize, so this is safe\n            Some(unsafe { *(self.value as *const _ as *const usize) })\n        } else {\n            None\n        }\n    }\n}\n\n// flags available in the v1 format of format_args\n#[derive(Copy, Clone)]\nenum FlagV1 {\n    SignPlus,\n    SignMinus,\n    Alternate,\n    SignAwareZeroPad,\n    DebugLowerHex,\n    DebugUpperHex,\n}\n\nimpl<'a> Arguments<'a> {\n    /// When using the format_args!() macro, this function is used to generate the\n    /// Arguments structure.\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n        Arguments { pieces, fmt: None, args }\n    }\n\n    /// This function is used to specify nonstandard formatting parameters.\n    /// The `pieces` array must be at least as long as `fmt` to construct\n    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n    /// created with `argumentusize`. However, failing to do so doesn't cause\n    /// unsafety, but will ignore invalid .\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new_v1_formatted(\n        pieces: &'a [&'static str],\n        args: &'a [ArgumentV1<'a>],\n        fmt: &'a [rt::v1::Argument],\n    ) -> Arguments<'a> {\n        Arguments { pieces, fmt: Some(fmt), args }\n    }\n\n    /// Estimates the length of the formatted text.\n    ///\n    /// This is intended to be used for setting initial `String` capacity\n    /// when using `format!`. Note: this is neither the lower nor upper bound.\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn estimated_capacity(&self) -> usize {\n        let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();\n\n        if self.args.is_empty() {\n            pieces_length\n        } else if self.pieces[0] == \"\" && pieces_length < 16 {\n            // If the format string starts with an argument,\n            // don't preallocate anything, unless length\n            // of pieces is significant.\n            0\n        } else {\n            // There are some arguments, so any additional push\n            // will reallocate the string. To avoid that,\n            // we're \"pre-doubling\" the capacity here.\n            pieces_length.checked_mul(2).unwrap_or(0)\n        }\n    }\n}\n\n/// This structure represents a safely precompiled version of a format string\n/// and its arguments. This cannot be generated at runtime because it cannot\n/// safely be done, so no constructors are given and the fields are private\n/// to prevent modification.\n///\n/// The [`format_args!`] macro will safely create an instance of this structure.\n/// The macro validates the format string at compile-time so usage of the\n/// [`write()`] and [`format()`] functions can be safely performed.\n///\n/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n/// and `Display` contexts as seen below. The example also shows that `Debug`\n/// and `Display` format to the same thing: the interpolated format string\n/// in `format_args!`.\n///\n/// ```rust\n/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n/// assert_eq!(\"1 foo 2\", display);\n/// assert_eq!(display, debug);\n/// ```\n///\n/// [`format()`]: ../../std/fmt/fn.format.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone)]\npub struct Arguments<'a> {\n    // Format string pieces to print.\n    pieces: &'a [&'static str],\n\n    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n    fmt: Option<&'a [rt::v1::Argument]>,\n\n    // Dynamic arguments for interpolation, to be interleaved with string\n    // pieces. (Every argument is preceded by a string piece.)\n    args: &'a [ArgumentV1<'a>],\n}\n\nimpl<'a> Arguments<'a> {\n    /// Get the formatted string, if it has no arguments to be formatted.\n    ///\n    /// This can be used to avoid allocations in the most trivial case.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt::Arguments;\n    ///\n    /// fn write_str(_: &str) { /* ... */ }\n    ///\n    /// fn write_fmt(args: &Arguments) {\n    ///     if let Some(s) = args.as_str() {\n    ///         write_str(s)\n    ///     } else {\n    ///         write_str(&args.to_string());\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// ```rust\n    /// assert_eq!(format_args!(\"hello\").as_str(), Some(\"hello\"));\n    /// assert_eq!(format_args!(\"\").as_str(), Some(\"\"));\n    /// assert_eq!(format_args!(\"{}\", 1).as_str(), None);\n    /// ```\n    #[stable(feature = \"fmt_as_str\", since = \"1.52.0\")]\n    #[rustc_const_unstable(feature = \"const_arguments_as_str\", issue = \"none\")]\n    #[inline]\n    pub const fn as_str(&self) -> Option<&'static str> {\n        match (self.pieces, self.args) {\n            ([], []) => Some(\"\"),\n            ([s], []) => Some(s),\n            _ => None,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for Arguments<'_> {\n    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n        Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Arguments<'_> {\n    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n        write(fmt.buf, *self)\n    }\n}\n\n/// `?` formatting.\n///\n/// `Debug` should format the output in a programmer-facing, debugging context.\n///\n/// Generally speaking, you should just `derive` a `Debug` implementation.\n///\n/// When used with the alternate format specifier `#?`, the output is pretty-printed.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// This trait can be used with `#[derive]` if all fields implement `Debug`. When\n/// `derive`d for structs, it will use the name of the `struct`, then `{`, then a\n/// comma-separated list of each field's name and `Debug` value, then `}`. For\n/// `enum`s, it will use the name of the variant and, if applicable, `(`, then the\n/// `Debug` values of the fields, then `)`.\n///\n/// # Stability\n///\n/// Derived `Debug` formats are not stable, and so may change with future Rust\n/// versions. Additionally, `Debug` implementations of types provided by the\n/// standard library (`libstd`, `libcore`, `liballoc`, etc.) are not stable, and\n/// may also change with future Rust versions.\n///\n/// # Examples\n///\n/// Deriving an implementation:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin is: Point { x: 0, y: 0 }\");\n/// ```\n///\n/// Manually implementing:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Debug for Point {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         f.debug_struct(\"Point\")\n///          .field(\"x\", &self.x)\n///          .field(\"y\", &self.y)\n///          .finish()\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin is: Point { x: 0, y: 0 }\");\n/// ```\n///\n/// There are a number of helper methods on the [`Formatter`] struct to help you with manual\n/// implementations, such as [`debug_struct`].\n///\n/// `Debug` implementations using either `derive` or the debug builder API\n/// on [`Formatter`] support pretty-printing using the alternate flag: `{:#?}`.\n///\n/// [`debug_struct`]: Formatter::debug_struct\n///\n/// Pretty-printing with `#?`:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:#?}\", origin),\n/// \"The origin is: Point {\n///     x: 0,\n///     y: 0,\n/// }\");\n/// ```\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    on(\n        crate_local,\n        label = \"`{Self}` cannot be formatted using `{{:?}}`\",\n        note = \"add `#[derive(Debug)]` to `{Self}` or manually `impl {Debug} for {Self}`\"\n    ),\n    message = \"`{Self}` doesn't implement `{Debug}`\",\n    label = \"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\"\n)]\n#[doc(alias = \"{:?}\")]\n#[rustc_diagnostic_item = \"debug_trait\"]\npub trait Debug {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Debug for Position {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         f.debug_tuple(\"\")\n    ///          .field(&self.longitude)\n    ///          .field(&self.latitude)\n    ///          .finish()\n    ///     }\n    /// }\n    ///\n    /// let position = Position { longitude: 1.987, latitude: 2.983 };\n    /// assert_eq!(format!(\"{:?}\", position), \"(1.987, 2.983)\");\n    ///\n    /// assert_eq!(format!(\"{:#?}\", position), \"(\n    ///     1.987,\n    ///     2.983,\n    /// )\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n// Separate module to reexport the macro `Debug` from prelude without the trait `Debug`.\npub(crate) mod macros {\n    /// Derive macro generating an impl of the trait `Debug`.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n    #[allow_internal_unstable(core_intrinsics)]\n    pub macro Debug($item:item) {\n        /* compiler built-in */\n    }\n}\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(inline)]\npub use macros::Debug;\n\n/// Format trait for an empty format, `{}`.\n///\n/// `Display` is similar to [`Debug`], but `Display` is for user-facing\n/// output, and so cannot be derived.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Implementing `Display` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Display for Point {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         write!(f, \"({}, {})\", self.x, self.y)\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {}\", origin), \"The origin is: (0, 0)\");\n/// ```\n#[rustc_on_unimplemented(\n    on(\n        _Self = \"std::path::Path\",\n        label = \"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n        note = \"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n                as they may contain non-Unicode data\"\n    ),\n    message = \"`{Self}` doesn't implement `{Display}`\",\n    label = \"`{Self}` cannot be formatted with the default formatter\",\n    note = \"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\"\n)]\n#[doc(alias = \"{}\")]\n#[rustc_diagnostic_item = \"display_trait\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Display {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Display for Position {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"({}, {})\", self.longitude, self.latitude)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\"(1.987, 2.983)\",\n    ///            format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `o` formatting.\n///\n/// The `Octal` trait should format its output as a number in base-8.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0o` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '52' in octal\n///\n/// assert_eq!(format!(\"{:o}\", x), \"52\");\n/// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n///\n/// assert_eq!(format!(\"{:o}\", -16), \"37777777760\");\n/// ```\n///\n/// Implementing `Octal` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Octal for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = self.0;\n///\n///         fmt::Octal::fmt(&val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// assert_eq!(format!(\"l as octal is: {:o}\", l), \"l as octal is: 11\");\n///\n/// assert_eq!(format!(\"l as octal is: {:#06o}\", l), \"l as octal is: 0o0011\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Octal {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `b` formatting.\n///\n/// The `Binary` trait should format its output as a number in binary.\n///\n/// For primitive signed integers ([`i8`] to [`i128`], and [`isize`]),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0b` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with [`i32`]:\n///\n/// ```\n/// let x = 42; // 42 is '101010' in binary\n///\n/// assert_eq!(format!(\"{:b}\", x), \"101010\");\n/// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n///\n/// assert_eq!(format!(\"{:b}\", -16), \"11111111111111111111111111110000\");\n/// ```\n///\n/// Implementing `Binary` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Binary for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = self.0;\n///\n///         fmt::Binary::fmt(&val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(107);\n///\n/// assert_eq!(format!(\"l as binary is: {:b}\", l), \"l as binary is: 1101011\");\n///\n/// assert_eq!(\n///     format!(\"l as binary is: {:#032b}\", l),\n///     \"l as binary is: 0b000000000000000000000001101011\"\n/// );\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Binary {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `x` formatting.\n///\n/// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n/// in lower case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2a' in hex\n///\n/// assert_eq!(format!(\"{:x}\", x), \"2a\");\n/// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n///\n/// assert_eq!(format!(\"{:x}\", -16), \"fffffff0\");\n/// ```\n///\n/// Implementing `LowerHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerHex for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = self.0;\n///\n///         fmt::LowerHex::fmt(&val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// assert_eq!(format!(\"l as hex is: {:x}\", l), \"l as hex is: 9\");\n///\n/// assert_eq!(format!(\"l as hex is: {:#010x}\", l), \"l as hex is: 0x00000009\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `X` formatting.\n///\n/// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n/// in upper case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2A' in hex\n///\n/// assert_eq!(format!(\"{:X}\", x), \"2A\");\n/// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n///\n/// assert_eq!(format!(\"{:X}\", -16), \"FFFFFFF0\");\n/// ```\n///\n/// Implementing `UpperHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperHex for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = self.0;\n///\n///         fmt::UpperHex::fmt(&val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(i32::MAX);\n///\n/// assert_eq!(format!(\"l as hex is: {:X}\", l), \"l as hex is: 7FFFFFFF\");\n///\n/// assert_eq!(format!(\"l as hex is: {:#010X}\", l), \"l as hex is: 0x7FFFFFFF\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `p` formatting.\n///\n/// The `Pointer` trait should format its output as a memory location. This is commonly presented\n/// as hexadecimal.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `&i32`:\n///\n/// ```\n/// let x = &42;\n///\n/// let address = format!(\"{:p}\", x); // this produces something like '0x7f06092ac6d0'\n/// ```\n///\n/// Implementing `Pointer` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Pointer for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         // use `as` to convert to a `*const T`, which implements Pointer, which we can use\n///\n///         let ptr = self as *const Self;\n///         fmt::Pointer::fmt(&ptr, f)\n///     }\n/// }\n///\n/// let l = Length(42);\n///\n/// println!(\"l is in memory here: {:p}\", l);\n///\n/// let l_ptr = format!(\"{:018p}\", l);\n/// assert_eq!(l_ptr.len(), 18);\n/// assert_eq!(&l_ptr[..2], \"0x\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_diagnostic_item = \"pointer_trait\"]\npub trait Pointer {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_diagnostic_item = \"pointer_trait_fmt\"]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `e` formatting.\n///\n/// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f64`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n///\n/// assert_eq!(format!(\"{:e}\", x), \"4.2e1\");\n/// ```\n///\n/// Implementing `LowerExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerExp for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = f64::from(self.0);\n///         fmt::LowerExp::fmt(&val, f) // delegate to f64's implementation\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:e}\", l),\n///     \"l in scientific notation is: 1e2\"\n/// );\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:05e}\", l),\n///     \"l in scientific notation is: 001e2\"\n/// );\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `E` formatting.\n///\n/// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f64`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2E1' in scientific notation\n///\n/// assert_eq!(format!(\"{:E}\", x), \"4.2E1\");\n/// ```\n///\n/// Implementing `UpperExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperExp for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = f64::from(self.0);\n///         fmt::UpperExp::fmt(&val, f) // delegate to f64's implementation\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:E}\", l),\n///     \"l in scientific notation is: 1E2\"\n/// );\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:05E}\", l),\n///     \"l in scientific notation is: 001E2\"\n/// );\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// The `write` function takes an output stream, and an `Arguments` struct\n/// that can be precompiled with the `format_args!` macro.\n///\n/// The arguments will be formatted according to the specified format string\n/// into the output stream provided.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::fmt;\n///\n/// let mut output = String::new();\n/// fmt::write(&mut output, format_args!(\"Hello {}!\", \"world\"))\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// Please note that using [`write!`] might be preferable. Example:\n///\n/// ```\n/// use std::fmt::Write;\n///\n/// let mut output = String::new();\n/// write!(&mut output, \"Hello {}!\", \"world\")\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// [`write!`]: crate::write!\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n    let mut formatter = Formatter::new(output);\n    let mut idx = 0;\n\n    match args.fmt {\n        None => {\n            // We can use default formatting parameters for all arguments.\n            for (arg, piece) in iter::zip(args.args, args.pieces) {\n                if !piece.is_empty() {\n                    formatter.buf.write_str(*piece)?;\n                }\n                (arg.formatter)(arg.value, &mut formatter)?;\n                idx += 1;\n            }\n        }\n        Some(fmt) => {\n            // Every spec has a corresponding argument that is preceded by\n            // a string piece.\n            for (arg, piece) in iter::zip(fmt, args.pieces) {\n                if !piece.is_empty() {\n                    formatter.buf.write_str(*piece)?;\n                }\n                // SAFETY: arg and args.args come from the same Arguments,\n                // which guarantees the indexes are always within bounds.\n                unsafe { run(&mut formatter, arg, &args.args) }?;\n                idx += 1;\n            }\n        }\n    }\n\n    // There can be only one trailing string piece left.\n    if let Some(piece) = args.pieces.get(idx) {\n        formatter.buf.write_str(*piece)?;\n    }\n\n    Ok(())\n}\n\nunsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::v1::Argument, args: &[ArgumentV1<'_>]) -> Result {\n    fmt.fill = arg.format.fill;\n    fmt.align = arg.format.align;\n    fmt.flags = arg.format.flags;\n    // SAFETY: arg and args come from the same Arguments,\n    // which guarantees the indexes are always within bounds.\n    unsafe {\n        fmt.width = getcount(args, &arg.format.width);\n        fmt.precision = getcount(args, &arg.format.precision);\n    }\n\n    // Extract the correct argument\n    debug_assert!(arg.position < args.len());\n    // SAFETY: arg and args come from the same Arguments,\n    // which guarantees its index is always within bounds.\n    let value = unsafe { args.get_unchecked(arg.position) };\n\n    // Then actually do some printing\n    (value.formatter)(value.value, fmt)\n}\n\nunsafe fn getcount(args: &[ArgumentV1<'_>], cnt: &rt::v1::Count) -> Option<usize> {\n    match *cnt {\n        rt::v1::Count::Is(n) => Some(n),\n        rt::v1::Count::Implied => None,\n        rt::v1::Count::Param(i) => {\n            debug_assert!(i < args.len());\n            // SAFETY: cnt and args come from the same Arguments,\n            // which guarantees this index is always within bounds.\n            unsafe { args.get_unchecked(i).as_usize() }\n        }\n    }\n}\n\n/// Padding after the end of something. Returned by `Formatter::padding`.\n#[must_use = \"don't forget to write the post padding\"]\nstruct PostPadding {\n    fill: char,\n    padding: usize,\n}\n\nimpl PostPadding {\n    fn new(fill: char, padding: usize) -> PostPadding {\n        PostPadding { fill, padding }\n    }\n\n    /// Write this post padding.\n    fn write(self, buf: &mut dyn Write) -> Result {\n        for _ in 0..self.padding {\n            buf.write_char(self.fill)?;\n        }\n        Ok(())\n    }\n}\n\nimpl<'a> Formatter<'a> {\n    fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n    where\n        'b: 'c,\n        F: FnOnce(&'b mut (dyn Write + 'b)) -> &'c mut (dyn Write + 'c),\n    {\n        Formatter {\n            // We want to change this\n            buf: wrap(self.buf),\n\n            // And preserve these\n            flags: self.flags,\n            fill: self.fill,\n            align: self.align,\n            width: self.width,\n            precision: self.precision,\n        }\n    }\n\n    // Helper methods used for padding and processing formatting arguments that\n    // all formatting traits can use.\n\n    /// Performs the correct padding for an integer which has already been\n    /// emitted into a str. The str should *not* contain the sign for the\n    /// integer, that will be added by this method.\n    ///\n    /// # Arguments\n    ///\n    /// * is_nonnegative - whether the original integer was either positive or zero.\n    /// * prefix - if the '#' character (Alternate) is provided, this\n    ///   is the prefix to put in front of the number.\n    /// * buf - the byte array that the number has been formatted into\n    ///\n    /// This function will correctly account for the flags provided as well as\n    /// the minimum width. It will not take precision into account.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo { nb: i32 }\n    ///\n    /// impl Foo {\n    ///     fn new(nb: i32) -> Foo {\n    ///         Foo {\n    ///             nb,\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         // We need to remove \"-\" from the number output.\n    ///         let tmp = self.nb.abs().to_string();\n    ///\n    ///         formatter.pad_integral(self.nb >= 0, \"Foo \", &tmp)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{}\", Foo::new(2)), \"2\");\n    /// assert_eq!(&format!(\"{}\", Foo::new(-1)), \"-1\");\n    /// assert_eq!(&format!(\"{}\", Foo::new(0)), \"0\");\n    /// assert_eq!(&format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n    /// assert_eq!(&format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result {\n        let mut width = buf.len();\n\n        let mut sign = None;\n        if !is_nonnegative {\n            sign = Some('-');\n            width += 1;\n        } else if self.sign_plus() {\n            sign = Some('+');\n            width += 1;\n        }\n\n        let prefix = if self.alternate() {\n            width += prefix.chars().count();\n            Some(prefix)\n        } else {\n            None\n        };\n\n        // Writes the sign if it exists, and then the prefix if it was requested\n        #[inline(never)]\n        fn write_prefix(f: &mut Formatter<'_>, sign: Option<char>, prefix: Option<&str>) -> Result {\n            if let Some(c) = sign {\n                f.buf.write_char(c)?;\n            }\n            if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }\n        }\n\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If there's no minimum length requirements then we can just\n            // write the bytes.\n            None => {\n                write_prefix(self, sign, prefix)?;\n                self.buf.write_str(buf)\n            }\n            // Check if we're over the minimum width, if so then we can also\n            // just write the bytes.\n            Some(min) if width >= min => {\n                write_prefix(self, sign, prefix)?;\n                self.buf.write_str(buf)\n            }\n            // The sign and prefix goes before the padding if the fill character\n            // is zero\n            Some(min) if self.sign_aware_zero_pad() => {\n                let old_fill = crate::mem::replace(&mut self.fill, '0');\n                let old_align = crate::mem::replace(&mut self.align, rt::v1::Alignment::Right);\n                write_prefix(self, sign, prefix)?;\n                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                self.buf.write_str(buf)?;\n                post_padding.write(self.buf)?;\n                self.fill = old_fill;\n                self.align = old_align;\n                Ok(())\n            }\n            // Otherwise, the sign and prefix goes after the padding\n            Some(min) => {\n                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                write_prefix(self, sign, prefix)?;\n                self.buf.write_str(buf)?;\n                post_padding.write(self.buf)\n            }\n        }\n    }\n\n    /// This function takes a string slice and emits it to the internal buffer\n    /// after applying the relevant formatting flags specified. The flags\n    /// recognized for generic strings are:\n    ///\n    /// * width - the minimum width of what to emit\n    /// * fill/align - what to emit and where to emit it if the string\n    ///                provided needs to be padded\n    /// * precision - the maximum length to emit, the string is truncated if it\n    ///               is longer than this length\n    ///\n    /// Notably this function ignores the `flag` parameters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         formatter.pad(\"Foo\")\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:<4}\", Foo), \"Foo \");\n    /// assert_eq!(&format!(\"{:0>4}\", Foo), \"0Foo\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad(&mut self, s: &str) -> Result {\n        // Make sure there's a fast path up front\n        if self.width.is_none() && self.precision.is_none() {\n            return self.buf.write_str(s);\n        }\n        // The `precision` field can be interpreted as a `max-width` for the\n        // string being formatted.\n        let s = if let Some(max) = self.precision {\n            // If our string is longer that the precision, then we must have\n            // truncation. However other flags like `fill`, `width` and `align`\n            // must act as always.\n            if let Some((i, _)) = s.char_indices().nth(max) {\n                // LLVM here can't prove that `..i` won't panic `&s[..i]`, but\n                // we know that it can't panic. Use `get` + `unwrap_or` to avoid\n                // `unsafe` and otherwise don't emit any panic-related code\n                // here.\n                s.get(..i).unwrap_or(&s)\n            } else {\n                &s\n            }\n        } else {\n            &s\n        };\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If we're under the maximum length, and there's no minimum length\n            // requirements, then we can just emit the string\n            None => self.buf.write_str(s),\n            // If we're under the maximum width, check if we're over the minimum\n            // width, if so it's as easy as just emitting the string.\n            Some(width) if s.chars().count() >= width => self.buf.write_str(s),\n            // If we're under both the maximum and the minimum width, then fill\n            // up the minimum width with the specified string + some alignment.\n            Some(width) => {\n                let align = rt::v1::Alignment::Left;\n                let post_padding = self.padding(width - s.chars().count(), align)?;\n                self.buf.write_str(s)?;\n                post_padding.write(self.buf)\n            }\n        }\n    }\n\n    /// Write the pre-padding and return the unwritten post-padding. Callers are\n    /// responsible for ensuring post-padding is written after the thing that is\n    /// being padded.\n    fn padding(\n        &mut self,\n        padding: usize,\n        default: rt::v1::Alignment,\n    ) -> result::Result<PostPadding, Error> {\n        let align = match self.align {\n            rt::v1::Alignment::Unknown => default,\n            _ => self.align,\n        };\n\n        let (pre_pad, post_pad) = match align {\n            rt::v1::Alignment::Left => (0, padding),\n            rt::v1::Alignment::Right | rt::v1::Alignment::Unknown => (padding, 0),\n            rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n        };\n\n        for _ in 0..pre_pad {\n            self.buf.write_char(self.fill)?;\n        }\n\n        Ok(PostPadding::new(self.fill, post_pad))\n    }\n\n    /// Takes the formatted parts and applies the padding.\n    /// Assumes that the caller already has rendered the parts with required precision,\n    /// so that `self.precision` can be ignored.\n    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted<'_>) -> Result {\n        if let Some(mut width) = self.width {\n            // for the sign-aware zero padding, we render the sign first and\n            // behave as if we had no sign from the beginning.\n            let mut formatted = formatted.clone();\n            let old_fill = self.fill;\n            let old_align = self.align;\n            let mut align = old_align;\n            if self.sign_aware_zero_pad() {\n                // a sign always goes first\n                let sign = formatted.sign;\n                self.buf.write_str(sign)?;\n\n                // remove the sign from the formatted parts\n                formatted.sign = \"\";\n                width = width.saturating_sub(sign.len());\n                align = rt::v1::Alignment::Right;\n                self.fill = '0';\n                self.align = rt::v1::Alignment::Right;\n            }\n\n            // remaining parts go through the ordinary padding process.\n            let len = formatted.len();\n            let ret = if width <= len {\n                // no padding\n                self.write_formatted_parts(&formatted)\n            } else {\n                let post_padding = self.padding(width - len, align)?;\n                self.write_formatted_parts(&formatted)?;\n                post_padding.write(self.buf)\n            };\n            self.fill = old_fill;\n            self.align = old_align;\n            ret\n        } else {\n            // this is the common case and we take a shortcut\n            self.write_formatted_parts(formatted)\n        }\n    }\n\n    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted<'_>) -> Result {\n        fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n            // SAFETY: This is used for `flt2dec::Part::Num` and `flt2dec::Part::Copy`.\n            // It's safe to use for `flt2dec::Part::Num` since every char `c` is between\n            // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n            // It's also probably safe in practice to use for `flt2dec::Part::Copy(buf)`\n            // since `buf` should be plain ASCII, but it's possible for someone to pass\n            // in a bad value for `buf` into `flt2dec::to_shortest_str` since it is a\n            // public function.\n            // FIXME: Determine whether this could result in UB.\n            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n        }\n\n        if !formatted.sign.is_empty() {\n            self.buf.write_str(formatted.sign)?;\n        }\n        for part in formatted.parts {\n            match *part {\n                flt2dec::Part::Zero(mut nzeroes) => {\n                    const ZEROES: &str = // 64 zeroes\n                        \"0000000000000000000000000000000000000000000000000000000000000000\";\n                    while nzeroes > ZEROES.len() {\n                        self.buf.write_str(ZEROES)?;\n                        nzeroes -= ZEROES.len();\n                    }\n                    if nzeroes > 0 {\n                        self.buf.write_str(&ZEROES[..nzeroes])?;\n                    }\n                }\n                flt2dec::Part::Num(mut v) => {\n                    let mut s = [0; 5];\n                    let len = part.len();\n                    for c in s[..len].iter_mut().rev() {\n                        *c = b'0' + (v % 10) as u8;\n                        v /= 10;\n                    }\n                    write_bytes(self.buf, &s[..len])?;\n                }\n                flt2dec::Part::Copy(buf) => {\n                    write_bytes(self.buf, buf)?;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes some data to the underlying buffer contained within this\n    /// formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         formatter.write_str(\"Foo\")\n    ///         // This is equivalent to:\n    ///         // write!(formatter, \"Foo\")\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{}\", Foo), \"Foo\");\n    /// assert_eq!(&format!(\"{:0>8}\", Foo), \"Foo\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_str(&mut self, data: &str) -> Result {\n        self.buf.write_str(data)\n    }\n\n    /// Writes some formatted information into this instance.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{}\", Foo(-1)), \"Foo -1\");\n    /// assert_eq!(&format!(\"{:0>8}\", Foo(2)), \"Foo 2\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result {\n        write(self.buf, fmt)\n    }\n\n    /// Flags for formatting\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.24.0\",\n        reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n                  or `sign_aware_zero_pad` methods instead\"\n    )]\n    pub fn flags(&self) -> u32 {\n        self.flags\n    }\n\n    /// Character used as 'fill' whenever there is alignment.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         let c = formatter.fill();\n    ///         if let Some(width) = formatter.width() {\n    ///             for _ in 0..width {\n    ///                 write!(formatter, \"{}\", c)?;\n    ///             }\n    ///             Ok(())\n    ///         } else {\n    ///             write!(formatter, \"{}\", c)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// // We set alignment to the right with \">\".\n    /// assert_eq!(&format!(\"{:G>3}\", Foo), \"GGG\");\n    /// assert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn fill(&self) -> char {\n        self.fill\n    }\n\n    /// Flag indicating what form of alignment was requested.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// extern crate core;\n    ///\n    /// use std::fmt::{self, Alignment};\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         let s = if let Some(s) = formatter.align() {\n    ///             match s {\n    ///                 Alignment::Left    => \"left\",\n    ///                 Alignment::Right   => \"right\",\n    ///                 Alignment::Center  => \"center\",\n    ///             }\n    ///         } else {\n    ///             \"into the void\"\n    ///         };\n    ///         write!(formatter, \"{}\", s)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n    /// assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n    /// assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n    /// assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n    /// ```\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    pub fn align(&self) -> Option<Alignment> {\n        match self.align {\n            rt::v1::Alignment::Left => Some(Alignment::Left),\n            rt::v1::Alignment::Right => Some(Alignment::Right),\n            rt::v1::Alignment::Center => Some(Alignment::Center),\n            rt::v1::Alignment::Unknown => None,\n        }\n    }\n\n    /// Optionally specified integer width that the output should be.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if let Some(width) = formatter.width() {\n    ///             // If we received a width, we use it\n    ///             write!(formatter, \"{:width$}\", &format!(\"Foo({})\", self.0), width = width)\n    ///         } else {\n    ///             // Otherwise we do nothing special\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn width(&self) -> Option<usize> {\n        self.width\n    }\n\n    /// Optionally specified precision for numeric types. Alternatively, the\n    /// maximum width for string types.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(f32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if let Some(precision) = formatter.precision() {\n    ///             // If we received a precision, we use it.\n    ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n    ///         } else {\n    ///             // Otherwise we default to 2.\n    ///             write!(formatter, \"Foo({:.2})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n    /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn precision(&self) -> Option<usize> {\n        self.precision\n    }\n\n    /// Determines if the `+` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if formatter.sign_plus() {\n    ///             write!(formatter,\n    ///                    \"Foo({}{})\",\n    ///                    if self.0 < 0 { '-' } else { '+' },\n    ///                    self.0)\n    ///         } else {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_plus(&self) -> bool {\n        self.flags & (1 << FlagV1::SignPlus as u32) != 0\n    }\n\n    /// Determines if the `-` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if formatter.sign_minus() {\n    ///             // You want a minus sign? Have one!\n    ///             write!(formatter, \"-Foo({})\", self.0)\n    ///         } else {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_minus(&self) -> bool {\n        self.flags & (1 << FlagV1::SignMinus as u32) != 0\n    }\n\n    /// Determines if the `#` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if formatter.alternate() {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         } else {\n    ///             write!(formatter, \"{}\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n    /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn alternate(&self) -> bool {\n        self.flags & (1 << FlagV1::Alternate as u32) != 0\n    }\n\n    /// Determines if the `0` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         assert!(formatter.sign_aware_zero_pad());\n    ///         assert_eq!(formatter.width(), Some(4));\n    ///         // We ignore the formatter's options.\n    ///         write!(formatter, \"{}\", self.0)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:04}\", Foo(23)), \"23\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_aware_zero_pad(&self) -> bool {\n        self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n    }\n\n    // FIXME: Decide what public API we want for these two flags.\n    // https://github.com/rust-lang/rust/issues/48584\n    fn debug_lower_hex(&self) -> bool {\n        self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0\n    }\n\n    fn debug_upper_hex(&self) -> bool {\n        self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0\n    }\n\n    /// Creates a [`DebugStruct`] builder designed to assist with creation of\n    /// [`fmt::Debug`] implementations for structs.\n    ///\n    /// [`fmt::Debug`]: self::Debug\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    /// use std::net::Ipv4Addr;\n    ///\n    /// struct Foo {\n    ///     bar: i32,\n    ///     baz: String,\n    ///     addr: Ipv4Addr,\n    /// }\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_struct(\"Foo\")\n    ///             .field(\"bar\", &self.bar)\n    ///             .field(\"baz\", &self.baz)\n    ///             .field(\"addr\", &format_args!(\"{}\", self.addr))\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n    ///     format!(\"{:?}\", Foo {\n    ///         bar: 10,\n    ///         baz: \"Hello World\".to_string(),\n    ///         addr: Ipv4Addr::new(127, 0, 0, 1),\n    ///     })\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n        builders::debug_struct_new(self, name)\n    }\n\n    /// Creates a `DebugTuple` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for tuple structs.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    /// use std::marker::PhantomData;\n    ///\n    /// struct Foo<T>(i32, String, PhantomData<T>);\n    ///\n    /// impl<T> fmt::Debug for Foo<T> {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///             .field(&self.0)\n    ///             .field(&self.1)\n    ///             .field(&format_args!(\"_\"))\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     \"Foo(10, \\\"Hello\\\", _)\",\n    ///     format!(\"{:?}\", Foo(10, \"Hello\".to_string(), PhantomData::<u8>))\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n        builders::debug_tuple_new(self, name)\n    }\n\n    /// Creates a `DebugList` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for list-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_list().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"[10, 11]\");\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_list<'b>(&'b mut self) -> DebugList<'b, 'a> {\n        builders::debug_list_new(self)\n    }\n\n    /// Creates a `DebugSet` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for set-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_set().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"{10, 11}\");\n    /// ```\n    ///\n    /// [`format_args!`]: crate::format_args\n    ///\n    /// In this more complex example, we use [`format_args!`] and `.debug_set()`\n    /// to build a list of match arms:\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Arm<'a, L: 'a, R: 'a>(&'a (L, R));\n    /// struct Table<'a, K: 'a, V: 'a>(&'a [(K, V)], V);\n    ///\n    /// impl<'a, L, R> fmt::Debug for Arm<'a, L, R>\n    /// where\n    ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n    /// {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         L::fmt(&(self.0).0, fmt)?;\n    ///         fmt.write_str(\" => \")?;\n    ///         R::fmt(&(self.0).1, fmt)\n    ///     }\n    /// }\n    ///\n    /// impl<'a, K, V> fmt::Debug for Table<'a, K, V>\n    /// where\n    ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n    /// {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_set()\n    ///         .entries(self.0.iter().map(Arm))\n    ///         .entry(&Arm(&(format_args!(\"_\"), &self.1)))\n    ///         .finish()\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n        builders::debug_set_new(self)\n    }\n\n    /// Creates a `DebugMap` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for map-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<(String, i32)>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\",  Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n    ///     r#\"{\"A\": 10, \"B\": 11}\"#\n    ///  );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_map<'b>(&'b mut self) -> DebugMap<'b, 'a> {\n        builders::debug_map_new(self)\n    }\n}\n\n#[stable(since = \"1.2.0\", feature = \"formatter_write\")]\nimpl Write for Formatter<'_> {\n    fn write_str(&mut self, s: &str) -> Result {\n        self.buf.write_str(s)\n    }\n\n    fn write_char(&mut self, c: char) -> Result {\n        self.buf.write_char(c)\n    }\n\n    fn write_fmt(&mut self, args: Arguments<'_>) -> Result {\n        write(self.buf, args)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Error {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Display::fmt(\"an error occurred when formatting an argument\", f)\n    }\n}\n\n// Implementations of the core formatting traits\n\nmacro_rules! fmt_refs {\n    ($($tr:ident),*) => {\n        $(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized + $tr> $tr for &T {\n            fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }\n        }\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized + $tr> $tr for &mut T {\n            fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }\n        }\n        )*\n    }\n}\n\nfmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Debug for ! {\n    fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n        *self\n    }\n}\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Display for ! {\n    fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for bool {\n    #[inline]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Display::fmt(self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for bool {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for str {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.write_char('\"')?;\n        let mut from = 0;\n        for (i, c) in self.char_indices() {\n            let esc = c.escape_debug_ext(EscapeDebugExtArgs {\n                escape_grapheme_extended: true,\n                escape_single_quote: false,\n                escape_double_quote: true,\n            });\n            // If char needs escaping, flush backlog so far and write, else skip\n            if esc.len() != 1 {\n                f.write_str(&self[from..i])?;\n                for c in esc {\n                    f.write_char(c)?;\n                }\n                from = i + c.len_utf8();\n            }\n        }\n        f.write_str(&self[from..])?;\n        f.write_char('\"')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for str {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.pad(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for char {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.write_char('\\'')?;\n        for c in self.escape_debug_ext(EscapeDebugExtArgs {\n            escape_grapheme_extended: true,\n            escape_single_quote: true,\n            escape_double_quote: false,\n        }) {\n            f.write_char(c)?\n        }\n        f.write_char('\\'')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for char {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        if f.width.is_none() && f.precision.is_none() {\n            f.write_char(*self)\n        } else {\n            f.pad(self.encode_utf8(&mut [0; 4]))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for *const T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        let old_width = f.width;\n        let old_flags = f.flags;\n\n        // The alternate flag is already treated by LowerHex as being special-\n        // it denotes whether to prefix with 0x. We use it to work out whether\n        // or not to zero extend, and then unconditionally set it to get the\n        // prefix.\n        if f.alternate() {\n            f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n\n            if f.width.is_none() {\n                f.width = Some((usize::BITS / 4) as usize + 2);\n            }\n        }\n        f.flags |= 1 << (FlagV1::Alternate as u32);\n\n        let ret = LowerHex::fmt(&(*self as *const () as usize), f);\n\n        f.width = old_width;\n        f.flags = old_flags;\n\n        ret\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for *mut T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Pointer::fmt(&(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for &T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Pointer::fmt(&(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for &mut T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Pointer::fmt(&(&**self as *const T), f)\n    }\n}\n\n// Implementation of Display/Debug for various core types\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for *const T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Pointer::fmt(self, f)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for *mut T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Pointer::fmt(self, f)\n    }\n}\n\nmacro_rules! peel {\n    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n}\n\nmacro_rules! tuple {\n    () => ();\n    ( $($name:ident,)+ ) => (\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<$($name:Debug),+> Debug for ($($name,)+) where last_type!($($name,)+): ?Sized {\n            #[allow(non_snake_case, unused_assignments)]\n            fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n                let mut builder = f.debug_tuple(\"\");\n                let ($(ref $name,)+) = *self;\n                $(\n                    builder.field(&$name);\n                )+\n\n                builder.finish()\n            }\n        }\n        peel! { $($name,)+ }\n    )\n}\n\nmacro_rules! last_type {\n    ($a:ident,) => { $a };\n    ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n}\n\ntuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Debug> Debug for [T] {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for () {\n    #[inline]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.pad(\"()\")\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for PhantomData<T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.debug_struct(\"PhantomData\").finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Copy + Debug> Debug for Cell<T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.debug_struct(\"Cell\").field(\"value\", &self.get()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Debug> Debug for RefCell<T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        match self.try_borrow() {\n            Ok(borrow) => f.debug_struct(\"RefCell\").field(\"value\", &borrow).finish(),\n            Err(_) => {\n                // The RefCell is mutably borrowed so we can't look at its value\n                // here. Show a placeholder instead.\n                struct BorrowedPlaceholder;\n\n                impl Debug for BorrowedPlaceholder {\n                    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n                        f.write_str(\"<borrowed>\")\n                    }\n                }\n\n                f.debug_struct(\"RefCell\").field(\"value\", &BorrowedPlaceholder).finish()\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Debug> Debug for Ref<'_, T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Debug> Debug for RefMut<'_, T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        Debug::fmt(&*(self.deref()), f)\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: ?Sized> Debug for UnsafeCell<T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.debug_struct(\"UnsafeCell\").finish_non_exhaustive()\n    }\n}\n\n// If you expected tests to be here, look instead at the core/tests/fmt.rs file,\n// it's a lot easier than creating all of the rt::Piece structures here.\n// There are also tests in the alloc crate, for those that need allocations.\n"],[2838,"//! Integer and floating-point number formatting\n\nuse crate::fmt;\nuse crate::mem::MaybeUninit;\nuse crate::num::flt2dec;\nuse crate::ops::{Div, Rem, Sub};\nuse crate::ptr;\nuse crate::slice;\nuse crate::str;\n\n#[doc(hidden)]\ntrait DisplayInt:\n    PartialEq + PartialOrd + Div<Output = Self> + Rem<Output = Self> + Sub<Output = Self> + Copy\n{\n    fn zero() -> Self;\n    fn from_u8(u: u8) -> Self;\n    fn to_u8(&self) -> u8;\n    fn to_u16(&self) -> u16;\n    fn to_u32(&self) -> u32;\n    fn to_u64(&self) -> u64;\n    fn to_u128(&self) -> u128;\n}\n\nmacro_rules! impl_int {\n    ($($t:ident)*) => (\n      $(impl DisplayInt for $t {\n          fn zero() -> Self { 0 }\n          fn from_u8(u: u8) -> Self { u as Self }\n          fn to_u8(&self) -> u8 { *self as u8 }\n          fn to_u16(&self) -> u16 { *self as u16 }\n          fn to_u32(&self) -> u32 { *self as u32 }\n          fn to_u64(&self) -> u64 { *self as u64 }\n          fn to_u128(&self) -> u128 { *self as u128 }\n      })*\n    )\n}\nmacro_rules! impl_uint {\n    ($($t:ident)*) => (\n      $(impl DisplayInt for $t {\n          fn zero() -> Self { 0 }\n          fn from_u8(u: u8) -> Self { u as Self }\n          fn to_u8(&self) -> u8 { *self as u8 }\n          fn to_u16(&self) -> u16 { *self as u16 }\n          fn to_u32(&self) -> u32 { *self as u32 }\n          fn to_u64(&self) -> u64 { *self as u64 }\n          fn to_u128(&self) -> u128 { *self as u128 }\n      })*\n    )\n}\n\nimpl_int! { i8 i16 i32 i64 i128 isize }\nimpl_uint! { u8 u16 u32 u64 u128 usize }\n\n/// A type that represents a specific radix\n#[doc(hidden)]\ntrait GenericRadix: Sized {\n    /// The number of digits.\n    const BASE: u8;\n\n    /// A radix-specific prefix string.\n    const PREFIX: &'static str;\n\n    /// Converts an integer to corresponding radix digit.\n    fn digit(x: u8) -> u8;\n\n    /// Format an integer using the radix using a formatter.\n    fn fmt_int<T: DisplayInt>(&self, mut x: T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // The radix can be as low as 2, so we need a buffer of at least 128\n        // characters for a base 2 number.\n        let zero = T::zero();\n        let is_nonnegative = x >= zero;\n        let mut buf = [MaybeUninit::<u8>::uninit(); 128];\n        let mut curr = buf.len();\n        let base = T::from_u8(Self::BASE);\n        if is_nonnegative {\n            // Accumulate each digit of the number from the least significant\n            // to the most significant figure.\n            for byte in buf.iter_mut().rev() {\n                let n = x % base; // Get the current place value.\n                x = x / base; // Deaccumulate the number.\n                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break;\n                };\n            }\n        } else {\n            // Do the same as above, but accounting for two's complement.\n            for byte in buf.iter_mut().rev() {\n                let n = zero - (x % base); // Get the current place value.\n                x = x / base; // Deaccumulate the number.\n                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break;\n                };\n            }\n        }\n        let buf = &buf[curr..];\n        // SAFETY: The only chars in `buf` are created by `Self::digit` which are assumed to be\n        // valid UTF-8\n        let buf = unsafe {\n            str::from_utf8_unchecked(slice::from_raw_parts(\n                MaybeUninit::slice_as_ptr(buf),\n                buf.len(),\n            ))\n        };\n        f.pad_integral(is_nonnegative, Self::PREFIX, buf)\n    }\n}\n\n/// A binary (base 2) radix\n#[derive(Clone, PartialEq)]\nstruct Binary;\n\n/// An octal (base 8) radix\n#[derive(Clone, PartialEq)]\nstruct Octal;\n\n/// A hexadecimal (base 16) radix, formatted with lower-case characters\n#[derive(Clone, PartialEq)]\nstruct LowerHex;\n\n/// A hexadecimal (base 16) radix, formatted with upper-case characters\n#[derive(Clone, PartialEq)]\nstruct UpperHex;\n\nmacro_rules! radix {\n    ($T:ident, $base:expr, $prefix:expr, $($x:pat => $conv:expr),+) => {\n        impl GenericRadix for $T {\n            const BASE: u8 = $base;\n            const PREFIX: &'static str = $prefix;\n            fn digit(x: u8) -> u8 {\n                match x {\n                    $($x => $conv,)+\n                    x => panic!(\"number not in the range 0..={}: {}\", Self::BASE - 1, x),\n                }\n            }\n        }\n    }\n}\n\nradix! { Binary,    2, \"0b\", x @  0 ..=  1 => b'0' + x }\nradix! { Octal,     8, \"0o\", x @  0 ..=  7 => b'0' + x }\nradix! { LowerHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x, x @ 10 ..= 15 => b'a' + (x - 10) }\nradix! { UpperHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x, x @ 10 ..= 15 => b'A' + (x - 10) }\n\nmacro_rules! int_base {\n    (fmt::$Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::$Trait for $T {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                $Radix.fmt_int(*self as $U, f)\n            }\n        }\n    };\n}\n\nmacro_rules! integer {\n    ($Int:ident, $Uint:ident) => {\n        int_base! { fmt::Binary   for $Int as $Uint  -> Binary }\n        int_base! { fmt::Octal    for $Int as $Uint  -> Octal }\n        int_base! { fmt::LowerHex for $Int as $Uint  -> LowerHex }\n        int_base! { fmt::UpperHex for $Int as $Uint  -> UpperHex }\n\n        int_base! { fmt::Binary   for $Uint as $Uint -> Binary }\n        int_base! { fmt::Octal    for $Uint as $Uint -> Octal }\n        int_base! { fmt::LowerHex for $Uint as $Uint -> LowerHex }\n        int_base! { fmt::UpperHex for $Uint as $Uint -> UpperHex }\n    };\n}\ninteger! { isize, usize }\ninteger! { i8, u8 }\ninteger! { i16, u16 }\ninteger! { i32, u32 }\ninteger! { i64, u64 }\ninteger! { i128, u128 }\nmacro_rules! debug {\n    ($($T:ident)*) => {$(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Debug for $T {\n            #[inline]\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                if f.debug_lower_hex() {\n                    fmt::LowerHex::fmt(self, f)\n                } else if f.debug_upper_hex() {\n                    fmt::UpperHex::fmt(self, f)\n                } else {\n                    fmt::Display::fmt(self, f)\n                }\n            }\n        }\n    )*};\n}\ndebug! {\n  i8 i16 i32 i64 i128 isize\n  u8 u16 u32 u64 u128 usize\n}\n\n// 2 digit decimal look up table\nstatic DEC_DIGITS_LUT: &[u8; 200] = b\"0001020304050607080910111213141516171819\\\n      2021222324252627282930313233343536373839\\\n      4041424344454647484950515253545556575859\\\n      6061626364656667686970717273747576777879\\\n      8081828384858687888990919293949596979899\";\n\nmacro_rules! impl_Display {\n    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n        fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n            let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n            let mut curr = buf.len() as isize;\n            let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n            // SAFETY: Since `d1` and `d2` are always less than or equal to `198`, we\n            // can copy from `lut_ptr[d1..d1 + 1]` and `lut_ptr[d2..d2 + 1]`. To show\n            // that it's OK to copy into `buf_ptr`, notice that at the beginning\n            // `curr == buf.len() == 39 > log(n)` since `n < 2^128 < 10^39`, and at\n            // each step this is kept the same as `n` is divided. Since `n` is always\n            // non-negative, this means that `curr > 0` so `buf_ptr[curr..curr + 1]`\n            // is safe to access.\n            unsafe {\n                // need at least 16 bits for the 4-characters-at-a-time to work.\n                assert!(crate::mem::size_of::<$u>() >= 2);\n\n                // eagerly decode 4 characters at a time\n                while n >= 10000 {\n                    let rem = (n % 10000) as isize;\n                    n /= 10000;\n\n                    let d1 = (rem / 100) << 1;\n                    let d2 = (rem % 100) << 1;\n                    curr -= 4;\n\n                    // We are allowed to copy to `buf_ptr[curr..curr + 3]` here since\n                    // otherwise `curr < 0`. But then `n` was originally at least `10000^10`\n                    // which is `10^40 > 2^128 > n`.\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                }\n\n                // if we reach here numbers are <= 9999, so at most 4 chars long\n                let mut n = n as isize; // possibly reduce 64bit math\n\n                // decode 2 more chars, if > 2 chars\n                if n >= 100 {\n                    let d1 = (n % 100) << 1;\n                    n /= 100;\n                    curr -= 2;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n\n                // decode last 1 or 2 chars\n                if n < 10 {\n                    curr -= 1;\n                    *buf_ptr.offset(curr) = (n as u8) + b'0';\n                } else {\n                    let d1 = n << 1;\n                    curr -= 2;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n            }\n\n            // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid\n            // UTF-8 since `DEC_DIGITS_LUT` is\n            let buf_slice = unsafe {\n                str::from_utf8_unchecked(\n                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n            };\n            f.pad_integral(is_nonnegative, \"\", buf_slice)\n        }\n\n        $(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Display for $t {\n            #[allow(unused_comparisons)]\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                let is_nonnegative = *self >= 0;\n                let n = if is_nonnegative {\n                    self.$conv_fn()\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!self.$conv_fn()).wrapping_add(1)\n                };\n                $name(n, is_nonnegative, f)\n            }\n        })*\n    };\n}\n\nmacro_rules! impl_Exp {\n    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n        fn $name(\n            mut n: $u,\n            is_nonnegative: bool,\n            upper: bool,\n            f: &mut fmt::Formatter<'_>\n        ) -> fmt::Result {\n            let (mut n, mut exponent, trailing_zeros, added_precision) = {\n                let mut exponent = 0;\n                // count and remove trailing decimal zeroes\n                while n % 10 == 0 && n >= 10 {\n                    n /= 10;\n                    exponent += 1;\n                }\n                let trailing_zeros = exponent;\n\n                let (added_precision, subtracted_precision) = match f.precision() {\n                    Some(fmt_prec) => {\n                        // number of decimal digits minus 1\n                        let mut tmp = n;\n                        let mut prec = 0;\n                        while tmp >= 10 {\n                            tmp /= 10;\n                            prec += 1;\n                        }\n                        (fmt_prec.saturating_sub(prec), prec.saturating_sub(fmt_prec))\n                    }\n                    None => (0,0)\n                };\n                for _ in 1..subtracted_precision {\n                    n/=10;\n                    exponent += 1;\n                }\n                if subtracted_precision != 0 {\n                    let rem = n % 10;\n                    n /= 10;\n                    exponent += 1;\n                    // round up last digit\n                    if rem >= 5 {\n                        n += 1;\n                    }\n                }\n                (n, exponent, trailing_zeros, added_precision)\n            };\n\n            // 39 digits (worst case u128) + . = 40\n            // Since `curr` always decreases by the number of digits copied, this means\n            // that `curr >= 0`.\n            let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n            let mut curr = buf.len() as isize; //index for buf\n            let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n            // decode 2 chars at a time\n            while n >= 100 {\n                let d1 = ((n % 100) as isize) << 1;\n                curr -= 2;\n                // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n                // `DEC_DIGITS_LUT` has a length of 200.\n                unsafe {\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n                n /= 100;\n                exponent += 2;\n            }\n            // n is <= 99, so at most 2 chars long\n            let mut n = n as isize; // possibly reduce 64bit math\n            // decode second-to-last character\n            if n >= 10 {\n                curr -= 1;\n                // SAFETY: Safe since `40 > curr >= 0` (see comment)\n                unsafe {\n                    *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n                }\n                n /= 10;\n                exponent += 1;\n            }\n            // add decimal point iff >1 mantissa digit will be printed\n            if exponent != trailing_zeros || added_precision != 0 {\n                curr -= 1;\n                // SAFETY: Safe since `40 > curr >= 0`\n                unsafe {\n                    *buf_ptr.offset(curr) = b'.';\n                }\n            }\n\n            // SAFETY: Safe since `40 > curr >= 0`\n            let buf_slice = unsafe {\n                // decode last character\n                curr -= 1;\n                *buf_ptr.offset(curr) = (n as u8) + b'0';\n\n                let len = buf.len() - curr as usize;\n                slice::from_raw_parts(buf_ptr.offset(curr), len)\n            };\n\n            // stores 'e' (or 'E') and the up to 2-digit exponent\n            let mut exp_buf = [MaybeUninit::<u8>::uninit(); 3];\n            let exp_ptr = MaybeUninit::slice_as_mut_ptr(&mut exp_buf);\n            // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n            // is contained within `exp_buf` since `len <= 3`.\n            let exp_slice = unsafe {\n                *exp_ptr.offset(0) = if upper {b'E'} else {b'e'};\n                let len = if exponent < 10 {\n                    *exp_ptr.offset(1) = (exponent as u8) + b'0';\n                    2\n                } else {\n                    let off = exponent << 1;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(off), exp_ptr.offset(1), 2);\n                    3\n                };\n                slice::from_raw_parts(exp_ptr, len)\n            };\n\n            let parts = &[\n                flt2dec::Part::Copy(buf_slice),\n                flt2dec::Part::Zero(added_precision),\n                flt2dec::Part::Copy(exp_slice)\n            ];\n            let sign = if !is_nonnegative {\n                \"-\"\n            } else if f.sign_plus() {\n                \"+\"\n            } else {\n                \"\"\n            };\n            let formatted = flt2dec::Formatted{sign, parts};\n            f.pad_formatted_parts(&formatted)\n        }\n\n        $(\n            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n            impl fmt::LowerExp for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    let is_nonnegative = *self >= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to it's 2 complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, false, f)\n                }\n            })*\n        $(\n            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n            impl fmt::UpperExp for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    let is_nonnegative = *self >= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to it's 2 complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, true, f)\n                }\n            })*\n    };\n}\n\n// Include wasm32 in here since it doesn't reflect the native pointer size, and\n// often cares strongly about getting a smaller code size.\n#[cfg(any(target_pointer_width = \"64\", target_arch = \"wasm32\"))]\nmod imp {\n    use super::*;\n    impl_Display!(\n        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n            as u64 via to_u64 named fmt_u64\n    );\n    impl_Exp!(\n        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n            as u64 via to_u64 named exp_u64\n    );\n}\n\n#[cfg(not(any(target_pointer_width = \"64\", target_arch = \"wasm32\")))]\nmod imp {\n    use super::*;\n    impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n    impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n    impl_Exp!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named exp_u32);\n    impl_Exp!(i64, u64 as u64 via to_u64 named exp_u64);\n}\nimpl_Exp!(i128, u128 as u128 via to_u128 named exp_u128);\n\n/// Helper function for writing a u64 into `buf` going from last to first, with `curr`.\nfn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], curr: &mut isize) {\n    let buf_ptr = MaybeUninit::slice_as_mut_ptr(buf);\n    let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n    assert!(*curr > 19);\n\n    // SAFETY:\n    // Writes at most 19 characters into the buffer. Guaranteed that any ptr into LUT is at most\n    // 198, so will never OOB. There is a check above that there are at least 19 characters\n    // remaining.\n    unsafe {\n        if n >= 1e16 as u64 {\n            let to_parse = n % 1e16 as u64;\n            n /= 1e16 as u64;\n\n            // Some of these are nops but it looks more elegant this way.\n            let d1 = ((to_parse / 1e14 as u64) % 100) << 1;\n            let d2 = ((to_parse / 1e12 as u64) % 100) << 1;\n            let d3 = ((to_parse / 1e10 as u64) % 100) << 1;\n            let d4 = ((to_parse / 1e8 as u64) % 100) << 1;\n            let d5 = ((to_parse / 1e6 as u64) % 100) << 1;\n            let d6 = ((to_parse / 1e4 as u64) % 100) << 1;\n            let d7 = ((to_parse / 1e2 as u64) % 100) << 1;\n            let d8 = ((to_parse / 1e0 as u64) % 100) << 1;\n\n            *curr -= 16;\n\n            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d5 as isize), buf_ptr.offset(*curr + 8), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d6 as isize), buf_ptr.offset(*curr + 10), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d7 as isize), buf_ptr.offset(*curr + 12), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d8 as isize), buf_ptr.offset(*curr + 14), 2);\n        }\n        if n >= 1e8 as u64 {\n            let to_parse = n % 1e8 as u64;\n            n /= 1e8 as u64;\n\n            // Some of these are nops but it looks more elegant this way.\n            let d1 = ((to_parse / 1e6 as u64) % 100) << 1;\n            let d2 = ((to_parse / 1e4 as u64) % 100) << 1;\n            let d3 = ((to_parse / 1e2 as u64) % 100) << 1;\n            let d4 = ((to_parse / 1e0 as u64) % 100) << 1;\n            *curr -= 8;\n\n            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n        }\n        // `n` < 1e8 < (1 << 32)\n        let mut n = n as u32;\n        if n >= 1e4 as u32 {\n            let to_parse = n % 1e4 as u32;\n            n /= 1e4 as u32;\n\n            let d1 = (to_parse / 100) << 1;\n            let d2 = (to_parse % 100) << 1;\n            *curr -= 4;\n\n            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n        }\n\n        // `n` < 1e4 < (1 << 16)\n        let mut n = n as u16;\n        if n >= 100 {\n            let d1 = (n % 100) << 1;\n            n /= 100;\n            *curr -= 2;\n            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n        }\n\n        // decode last 1 or 2 chars\n        if n < 10 {\n            *curr -= 1;\n            *buf_ptr.offset(*curr) = (n as u8) + b'0';\n        } else {\n            let d1 = n << 1;\n            *curr -= 2;\n            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for u128 {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt_u128(*self, true, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for i128 {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let is_nonnegative = *self >= 0;\n        let n = if is_nonnegative {\n            self.to_u128()\n        } else {\n            // convert the negative num to positive by summing 1 to it's 2 complement\n            (!self.to_u128()).wrapping_add(1)\n        };\n        fmt_u128(n, is_nonnegative, f)\n    }\n}\n\n/// Specialized optimization for u128. Instead of taking two items at a time, it splits\n/// into at most 2 u64s, and then chunks by 10e16, 10e8, 10e4, 10e2, and then 10e1.\n/// It also has to handle 1 last item, as 10^40 > 2^128 > 10^39, whereas\n/// 10^20 > 2^64 > 10^19.\nfn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n    let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n    let mut curr = buf.len() as isize;\n\n    let (n, rem) = udiv_1e19(n);\n    parse_u64_into(rem, &mut buf, &mut curr);\n\n    if n != 0 {\n        // 0 pad up to point\n        let target = (buf.len() - 19) as isize;\n        // SAFETY: Guaranteed that we wrote at most 19 bytes, and there must be space\n        // remaining since it has length 39\n        unsafe {\n            ptr::write_bytes(\n                MaybeUninit::slice_as_mut_ptr(&mut buf).offset(target),\n                b'0',\n                (curr - target) as usize,\n            );\n        }\n        curr = target;\n\n        let (n, rem) = udiv_1e19(n);\n        parse_u64_into(rem, &mut buf, &mut curr);\n        // Should this following branch be annotated with unlikely?\n        if n != 0 {\n            let target = (buf.len() - 38) as isize;\n            // The raw `buf_ptr` pointer is only valid until `buf` is used the next time,\n            // buf `buf` is not used in this scope so we are good.\n            let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n            // SAFETY: At this point we wrote at most 38 bytes, pad up to that point,\n            // There can only be at most 1 digit remaining.\n            unsafe {\n                ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n                curr = target - 1;\n                *buf_ptr.offset(curr) = (n as u8) + b'0';\n            }\n        }\n    }\n\n    // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid\n    // UTF-8 since `DEC_DIGITS_LUT` is\n    let buf_slice = unsafe {\n        str::from_utf8_unchecked(slice::from_raw_parts(\n            MaybeUninit::slice_as_mut_ptr(&mut buf).offset(curr),\n            buf.len() - curr as usize,\n        ))\n    };\n    f.pad_integral(is_nonnegative, \"\", buf_slice)\n}\n\n/// Partition of `n` into n > 1e19 and rem <= 1e19\n///\n/// Integer division algorithm is based on the following paper:\n///\n///   T. Granlund and P. Montgomery, “Division by Invariant Integers Using Multiplication”\n///   in Proc. of the SIGPLAN94 Conference on Programming Language Design and\n///   Implementation, 1994, pp. 61–72\n///\nfn udiv_1e19(n: u128) -> (u128, u64) {\n    const DIV: u64 = 1e19 as u64;\n    const FACTOR: u128 = 156927543384667019095894735580191660403;\n\n    let quot = if n < 1 << 83 {\n        ((n >> 19) as u64 / (DIV >> 19)) as u128\n    } else {\n        u128_mulhi(n, FACTOR) >> 62\n    };\n\n    let rem = (n - quot * DIV as u128) as u64;\n    (quot, rem)\n}\n\n/// Multiply unsigned 128 bit integers, return upper 128 bits of the result\n#[inline]\nfn u128_mulhi(x: u128, y: u128) -> u128 {\n    let x_lo = x as u64;\n    let x_hi = (x >> 64) as u64;\n    let y_lo = y as u64;\n    let y_hi = (y >> 64) as u64;\n\n    // handle possibility of overflow\n    let carry = (x_lo as u128 * y_lo as u128) >> 64;\n    let m = x_lo as u128 * y_hi as u128 + carry;\n    let high1 = m >> 64;\n\n    let m_lo = m as u64;\n    let high2 = (x_hi as u128 * y_lo as u128 + m_lo as u128) >> 64;\n\n    x_hi as u128 * y_hi as u128 + high1 + high2\n}\n"],[2839,"use crate::any::type_name;\nuse crate::fmt;\nuse crate::intrinsics;\nuse crate::mem::ManuallyDrop;\nuse crate::ptr;\n\n/// A wrapper type to construct uninitialized instances of `T`.\n///\n/// # Initialization invariant\n///\n/// The compiler, in general, assumes that a variable is properly initialized\n/// according to the requirements of the variable's type. For example, a variable of\n/// reference type must be aligned and non-null. This is an invariant that must\n/// *always* be upheld, even in unsafe code. As a consequence, zero-initializing a\n/// variable of reference type causes instantaneous [undefined behavior][ub],\n/// no matter whether that reference ever gets used to access memory:\n///\n/// ```rust,no_run\n/// # #![allow(invalid_value)]\n/// use std::mem::{self, MaybeUninit};\n///\n/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior! ⚠️\n/// // The equivalent code with `MaybeUninit<&i32>`:\n/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior! ⚠️\n/// ```\n///\n/// This is exploited by the compiler for various optimizations, such as eliding\n/// run-time checks and optimizing `enum` layout.\n///\n/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n///\n/// ```rust,no_run\n/// # #![allow(invalid_value)]\n/// use std::mem::{self, MaybeUninit};\n///\n/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️\n/// // The equivalent code with `MaybeUninit<bool>`:\n/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! ⚠️\n/// ```\n///\n/// Moreover, uninitialized memory is special in that it does not have a fixed value (\"fixed\"\n/// meaning \"it won't change without being written to\"). Reading the same uninitialized byte\n/// multiple times can give different results. This makes it undefined behavior to have\n/// uninitialized data in a variable even if that variable has an integer type, which otherwise can\n/// hold any *fixed* bit pattern:\n///\n/// ```rust,no_run\n/// # #![allow(invalid_value)]\n/// use std::mem::{self, MaybeUninit};\n///\n/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️\n/// // The equivalent code with `MaybeUninit<i32>`:\n/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! ⚠️\n/// ```\n/// (Notice that the rules around uninitialized integers are not finalized yet, but\n/// until they are, it is advisable to avoid them.)\n///\n/// On top of that, remember that most types have additional invariants beyond merely\n/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n/// is considered initialized (under the current implementation; this does not constitute\n/// a stable guarantee) because the only requirement the compiler knows about it\n/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n/// *immediate* undefined behavior, but will cause undefined behavior with most\n/// safe operations (including dropping it).\n///\n/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n///\n/// # Examples\n///\n/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n/// It is a signal to the compiler indicating that the data here might *not*\n/// be initialized:\n///\n/// ```rust\n/// use std::mem::MaybeUninit;\n///\n/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n/// let mut x = MaybeUninit::<&i32>::uninit();\n/// // Set it to a valid value.\n/// unsafe { x.as_mut_ptr().write(&0); }\n/// // Extract the initialized data -- this is only allowed *after* properly\n/// // initializing `x`!\n/// let x = unsafe { x.assume_init() };\n/// ```\n///\n/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n///\n/// You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n/// any of the run-time tracking and without any of the safety checks.\n///\n/// ## out-pointers\n///\n/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n/// from a function, pass it a pointer to some (uninitialized) memory to put the\n/// result into. This can be useful when it is important for the caller to control\n/// how the memory the result is stored in gets allocated, and you want to avoid\n/// unnecessary moves.\n///\n/// ```\n/// use std::mem::MaybeUninit;\n///\n/// unsafe fn make_vec(out: *mut Vec<i32>) {\n///     // `write` does not drop the old contents, which is important.\n///     out.write(vec![1, 2, 3]);\n/// }\n///\n/// let mut v = MaybeUninit::uninit();\n/// unsafe { make_vec(v.as_mut_ptr()); }\n/// // Now we know `v` is initialized! This also makes sure the vector gets\n/// // properly dropped.\n/// let v = unsafe { v.assume_init() };\n/// assert_eq!(&v, &[1, 2, 3]);\n/// ```\n///\n/// ## Initializing an array element-by-element\n///\n/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n///\n/// ```\n/// use std::mem::{self, MaybeUninit};\n///\n/// let data = {\n///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n///     // safe because the type we are claiming to have initialized here is a\n///     // bunch of `MaybeUninit`s, which do not require initialization.\n///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n///         MaybeUninit::uninit().assume_init()\n///     };\n///\n///     // Dropping a `MaybeUninit` does nothing. Thus using raw pointer\n///     // assignment instead of `ptr::write` does not cause the old\n///     // uninitialized value to be dropped. Also if there is a panic during\n///     // this loop, we have a memory leak, but there is no memory safety\n///     // issue.\n///     for elem in &mut data[..] {\n///         *elem = MaybeUninit::new(vec![42]);\n///     }\n///\n///     // Everything is initialized. Transmute the array to the\n///     // initialized type.\n///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n/// };\n///\n/// assert_eq!(&data[0], &[42]);\n/// ```\n///\n/// You can also work with partially initialized arrays, which could\n/// be found in low-level datastructures.\n///\n/// ```\n/// use std::mem::MaybeUninit;\n/// use std::ptr;\n///\n/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n/// // safe because the type we are claiming to have initialized here is a\n/// // bunch of `MaybeUninit`s, which do not require initialization.\n/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n/// // Count the number of elements we have assigned.\n/// let mut data_len: usize = 0;\n///\n/// for elem in &mut data[0..500] {\n///     *elem = MaybeUninit::new(String::from(\"hello\"));\n///     data_len += 1;\n/// }\n///\n/// // For each item in the array, drop if we allocated it.\n/// for elem in &mut data[0..data_len] {\n///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n/// }\n/// ```\n///\n/// ## Initializing a struct field-by-field\n///\n/// You can use `MaybeUninit<T>`, and the [`std::ptr::addr_of_mut`] macro, to initialize structs field by field:\n///\n/// ```rust\n/// use std::mem::MaybeUninit;\n/// use std::ptr::addr_of_mut;\n///\n/// #[derive(Debug, PartialEq)]\n/// pub struct Foo {\n///     name: String,\n///     list: Vec<u8>,\n/// }\n///\n/// let foo = {\n///     let mut uninit: MaybeUninit<Foo> = MaybeUninit::uninit();\n///     let ptr = uninit.as_mut_ptr();\n///\n///     // Initializing the `name` field\n///     // Using `write` instead of assignment via `=` to not call `drop` on the\n///     // old, uninitialized value.\n///     unsafe { addr_of_mut!((*ptr).name).write(\"Bob\".to_string()); }\n///\n///     // Initializing the `list` field\n///     // If there is a panic here, then the `String` in the `name` field leaks.\n///     unsafe { addr_of_mut!((*ptr).list).write(vec![0, 1, 2]); }\n///\n///     // All the fields are initialized, so we call `assume_init` to get an initialized Foo.\n///     unsafe { uninit.assume_init() }\n/// };\n///\n/// assert_eq!(\n///     foo,\n///     Foo {\n///         name: \"Bob\".to_string(),\n///         list: vec![0, 1, 2]\n///     }\n/// );\n/// ```\n/// [`std::ptr::addr_of_mut`]: crate::ptr::addr_of_mut\n/// [ub]: ../../reference/behavior-considered-undefined.html\n///\n/// # Layout\n///\n/// `MaybeUninit<T>` is guaranteed to have the same size, alignment, and ABI as `T`:\n///\n/// ```rust\n/// use std::mem::{MaybeUninit, size_of, align_of};\n/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n/// ```\n///\n/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n/// optimizations, potentially resulting in a larger size:\n///\n/// ```rust\n/// # use std::mem::{MaybeUninit, size_of};\n/// assert_eq!(size_of::<Option<bool>>(), 1);\n/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n/// ```\n///\n/// If `T` is FFI-safe, then so is `MaybeUninit<T>`.\n///\n/// While `MaybeUninit` is `#[repr(transparent)]` (indicating it guarantees the same size,\n/// alignment, and ABI as `T`), this does *not* change any of the previous caveats. `Option<T>` and\n/// `Option<MaybeUninit<T>>` may still have different sizes, and types containing a field of type\n/// `T` may be laid out (and sized) differently than if that field were `MaybeUninit<T>`.\n/// `MaybeUninit` is a union type, and `#[repr(transparent)]` on unions is unstable (see [the\n/// tracking issue](https://github.com/rust-lang/rust/issues/60405)). Over time, the exact\n/// guarantees of `#[repr(transparent)]` on unions may evolve, and `MaybeUninit` may or may not\n/// remain `#[repr(transparent)]`. That said, `MaybeUninit<T>` will *always* guarantee that it has\n/// the same size, alignment, and ABI as `T`; it's just that the way `MaybeUninit` implements that\n/// guarantee may evolve.\n#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n// Lang item so we can wrap other types in it. This is useful for generators.\n#[lang = \"maybe_uninit\"]\n#[derive(Copy)]\n#[repr(transparent)]\npub union MaybeUninit<T> {\n    uninit: (),\n    value: ManuallyDrop<T>,\n}\n\n#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\nimpl<T: Copy> Clone for MaybeUninit<T> {\n    #[inline(always)]\n    fn clone(&self) -> Self {\n        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n        *self\n    }\n}\n\n#[stable(feature = \"maybe_uninit_debug\", since = \"1.41.0\")]\nimpl<T> fmt::Debug for MaybeUninit<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.pad(type_name::<Self>())\n    }\n}\n\nimpl<T> MaybeUninit<T> {\n    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n    /// It is safe to call [`assume_init`] on the return value of this function.\n    ///\n    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n    /// ```\n    ///\n    /// [`assume_init`]: MaybeUninit::assume_init\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[rustc_const_stable(feature = \"const_maybe_uninit\", since = \"1.36.0\")]\n    #[inline(always)]\n    pub const fn new(val: T) -> MaybeUninit<T> {\n        MaybeUninit { value: ManuallyDrop::new(val) }\n    }\n\n    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n    ///\n    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n    ///\n    /// See the [type-level documentation][MaybeUninit] for some examples.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let v: MaybeUninit<String> = MaybeUninit::uninit();\n    /// ```\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[rustc_const_stable(feature = \"const_maybe_uninit\", since = \"1.36.0\")]\n    #[inline(always)]\n    #[rustc_diagnostic_item = \"maybe_uninit_uninit\"]\n    pub const fn uninit() -> MaybeUninit<T> {\n        MaybeUninit { uninit: () }\n    }\n\n    /// Create a new array of `MaybeUninit<T>` items, in an uninitialized state.\n    ///\n    /// Note: in a future Rust version this method may become unnecessary\n    /// when Rust allows\n    /// [inline const expressions](https://github.com/rust-lang/rust/issues/76001).\n    /// The example below could then use `let mut buf = [const { MaybeUninit::<u8>::uninit() }; 32];`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// #![feature(maybe_uninit_uninit_array, maybe_uninit_extra, maybe_uninit_slice)]\n    ///\n    /// use std::mem::MaybeUninit;\n    ///\n    /// extern \"C\" {\n    ///     fn read_into_buffer(ptr: *mut u8, max_len: usize) -> usize;\n    /// }\n    ///\n    /// /// Returns a (possibly smaller) slice of data that was actually read\n    /// fn read(buf: &mut [MaybeUninit<u8>]) -> &[u8] {\n    ///     unsafe {\n    ///         let len = read_into_buffer(buf.as_mut_ptr() as *mut u8, buf.len());\n    ///         MaybeUninit::slice_assume_init_ref(&buf[..len])\n    ///     }\n    /// }\n    ///\n    /// let mut buf: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\n    /// let data = read(&mut buf);\n    /// ```\n    #[unstable(feature = \"maybe_uninit_uninit_array\", issue = \"none\")]\n    #[rustc_const_unstable(feature = \"maybe_uninit_uninit_array\", issue = \"none\")]\n    #[inline(always)]\n    pub const fn uninit_array<const LEN: usize>() -> [Self; LEN] {\n        // SAFETY: An uninitialized `[MaybeUninit<_>; LEN]` is valid.\n        unsafe { MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init() }\n    }\n\n    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n    /// filled with `0` bytes. It depends on `T` whether that already makes for\n    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n    /// be null.\n    ///\n    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n    ///\n    /// # Example\n    ///\n    /// Correct usage of this function: initializing a struct with zero, where all\n    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n    /// let x = unsafe { x.assume_init() };\n    /// assert_eq!(x, (0, false));\n    /// ```\n    ///\n    /// *Incorrect* usage of this function: calling `x.zeroed().assume_init()`\n    /// when `0` is not a valid bit-pattern for the type:\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// enum NotZero { One = 1, Two = 2 }\n    ///\n    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n    /// let x = unsafe { x.assume_init() };\n    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n    /// // This is undefined behavior. ⚠️\n    /// ```\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[inline]\n    #[rustc_diagnostic_item = \"maybe_uninit_zeroed\"]\n    pub fn zeroed() -> MaybeUninit<T> {\n        let mut u = MaybeUninit::<T>::uninit();\n        // SAFETY: `u.as_mut_ptr()` points to allocated memory.\n        unsafe {\n            u.as_mut_ptr().write_bytes(0u8, 1);\n        }\n        u\n    }\n\n    /// Sets the value of the `MaybeUninit<T>`.\n    ///\n    /// This overwrites any previous value without dropping it, so be careful\n    /// not to use this twice unless you want to skip running the destructor.\n    /// For your convenience, this also returns a mutable reference to the\n    /// (now safely initialized) contents of `self`.\n    ///\n    /// As the content is stored inside a `MaybeUninit`, the destructor is not\n    /// ran for the inner data if the MaybeUninit leaves scope without a call to\n    /// [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n    /// the mutable reference returned by this function needs to keep this in\n    /// mind. The safety model of Rust regards leaks as safe, but they are\n    /// usually still undesirable. This being said, the mutable reference\n    /// behaves like any other mutable reference would, so assigning a new value\n    /// to it will drop the old content.\n    ///\n    /// [`assume_init`]: Self::assume_init\n    /// [`assume_init_drop`]: Self::assume_init_drop\n    ///\n    /// # Examples\n    ///\n    /// Correct usage of this method:\n    ///\n    /// ```rust\n    /// #![feature(maybe_uninit_extra)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Vec<u8>>::uninit();\n    ///\n    /// {\n    ///     let hello = x.write((&b\"Hello, world!\").to_vec());\n    ///     // Setting hello does not leak prior allocations, but drops them\n    ///     *hello = (&b\"Hello\").to_vec();\n    ///     hello[0] = 'h' as u8;\n    /// }\n    /// // x is initialized now:\n    /// let s = unsafe { x.assume_init() };\n    /// assert_eq!(b\"hello\", s.as_slice());\n    /// ```\n    ///\n    /// This usage of the method causes a leak:\n    ///\n    /// ```rust\n    /// #![feature(maybe_uninit_extra)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<String>::uninit();\n    ///\n    /// x.write(\"Hello\".to_string());\n    /// // This leaks the contained string:\n    /// x.write(\"hello\".to_string());\n    /// // x is initialized now:\n    /// let s = unsafe { x.assume_init() };\n    /// ```\n    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n    #[rustc_const_unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n    #[inline(always)]\n    pub const fn write(&mut self, val: T) -> &mut T {\n        *self = MaybeUninit::new(val);\n        // SAFETY: We just initialized this value.\n        unsafe { self.assume_init_mut() }\n    }\n\n    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n    /// (except inside an `UnsafeCell<T>`).\n    ///\n    /// # Examples\n    ///\n    /// Correct usage of this method:\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n    /// unsafe { x.as_mut_ptr().write(vec![0, 1, 2]); }\n    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n    /// let x_vec = unsafe { &*x.as_ptr() };\n    /// assert_eq!(x_vec.len(), 3);\n    /// ```\n    ///\n    /// *Incorrect* usage of this method:\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n    /// let x_vec = unsafe { &*x.as_ptr() };\n    /// // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n    /// ```\n    ///\n    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n    /// until they are, it is advisable to avoid them.)\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[rustc_const_unstable(feature = \"const_maybe_uninit_as_ptr\", issue = \"75251\")]\n    #[inline(always)]\n    pub const fn as_ptr(&self) -> *const T {\n        // `MaybeUninit` and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.\n        self as *const _ as *const T\n    }\n\n    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n    ///\n    /// # Examples\n    ///\n    /// Correct usage of this method:\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n    /// unsafe { x.as_mut_ptr().write(vec![0, 1, 2]); }\n    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n    /// // This is okay because we initialized it.\n    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n    /// x_vec.push(3);\n    /// assert_eq!(x_vec.len(), 4);\n    /// ```\n    ///\n    /// *Incorrect* usage of this method:\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n    /// // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n    /// ```\n    ///\n    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n    /// until they are, it is advisable to avoid them.)\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[rustc_const_unstable(feature = \"const_maybe_uninit_as_ptr\", issue = \"75251\")]\n    #[inline(always)]\n    pub const fn as_mut_ptr(&mut self) -> *mut T {\n        // `MaybeUninit` and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.\n        self as *mut _ as *mut T\n    }\n\n    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n    /// to ensure that the data will get dropped, because the resulting `T` is\n    /// subject to the usual drop handling.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n    /// behavior. The [type-level documentation][inv] contains more information about\n    /// this initialization invariant.\n    ///\n    /// [inv]: #initialization-invariant\n    ///\n    /// On top of that, remember that most types have additional invariants beyond merely\n    /// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n    /// is considered initialized (under the current implementation; this does not constitute\n    /// a stable guarantee) because the only requirement the compiler knows about it\n    /// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n    /// *immediate* undefined behavior, but will cause undefined behavior with most\n    /// safe operations (including dropping it).\n    ///\n    /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n    ///\n    /// # Examples\n    ///\n    /// Correct usage of this method:\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<bool>::uninit();\n    /// unsafe { x.as_mut_ptr().write(true); }\n    /// let x_init = unsafe { x.assume_init() };\n    /// assert_eq!(x_init, true);\n    /// ```\n    ///\n    /// *Incorrect* usage of this method:\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n    /// let x_init = unsafe { x.assume_init() };\n    /// // `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️\n    /// ```\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[rustc_const_unstable(feature = \"const_maybe_uninit_assume_init\", issue = \"none\")]\n    #[inline(always)]\n    #[rustc_diagnostic_item = \"assume_init\"]\n    pub const unsafe fn assume_init(self) -> T {\n        // SAFETY: the caller must guarantee that `self` is initialized.\n        // This also means that `self` must be a `value` variant.\n        unsafe {\n            intrinsics::assert_inhabited::<T>();\n            ManuallyDrop::into_inner(self.value)\n        }\n    }\n\n    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n    /// to the usual drop handling.\n    ///\n    /// Whenever possible, it is preferable to use [`assume_init`] instead, which\n    /// prevents duplicating the content of the `MaybeUninit<T>`.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n    /// state. Calling this when the content is not yet fully initialized causes undefined\n    /// behavior. The [type-level documentation][inv] contains more information about\n    /// this initialization invariant.\n    ///\n    /// Moreover, similar to the [`ptr::read`] function, this function creates a\n    /// bitwise copy of the contents, regardless whether the contained type\n    /// implements the [`Copy`] trait or not. When using multiple copies of the\n    /// data (by calling `assume_init_read` multiple times, or first calling\n    /// `assume_init_read` and then [`assume_init`]), it is your responsibility\n    /// to ensure that that data may indeed be duplicated.\n    ///\n    /// [inv]: #initialization-invariant\n    /// [`assume_init`]: MaybeUninit::assume_init\n    ///\n    /// # Examples\n    ///\n    /// Correct usage of this method:\n    ///\n    /// ```rust\n    /// #![feature(maybe_uninit_extra)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<u32>::uninit();\n    /// x.write(13);\n    /// let x1 = unsafe { x.assume_init_read() };\n    /// // `u32` is `Copy`, so we may read multiple times.\n    /// let x2 = unsafe { x.assume_init_read() };\n    /// assert_eq!(x1, x2);\n    ///\n    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n    /// x.write(None);\n    /// let x1 = unsafe { x.assume_init_read() };\n    /// // Duplicating a `None` value is okay, so we may read multiple times.\n    /// let x2 = unsafe { x.assume_init_read() };\n    /// assert_eq!(x1, x2);\n    /// ```\n    ///\n    /// *Incorrect* usage of this method:\n    ///\n    /// ```rust,no_run\n    /// #![feature(maybe_uninit_extra)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n    /// x.write(Some(vec![0, 1, 2]));\n    /// let x1 = unsafe { x.assume_init_read() };\n    /// let x2 = unsafe { x.assume_init_read() };\n    /// // We now created two copies of the same vector, leading to a double-free ⚠️ when\n    /// // they both get dropped!\n    /// ```\n    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n    #[rustc_const_unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n    #[inline(always)]\n    pub const unsafe fn assume_init_read(&self) -> T {\n        // SAFETY: the caller must guarantee that `self` is initialized.\n        // Reading from `self.as_ptr()` is safe since `self` should be initialized.\n        unsafe {\n            intrinsics::assert_inhabited::<T>();\n            self.as_ptr().read()\n        }\n    }\n\n    /// Drops the contained value in place.\n    ///\n    /// If you have ownership of the `MaybeUninit`, you can also use\n    /// [`assume_init`] as an alternative.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is\n    /// in an initialized state. Calling this when the content is not yet fully\n    /// initialized causes undefined behavior.\n    ///\n    /// On top of that, all additional invariants of the type `T` must be\n    /// satisfied, as the `Drop` implementation of `T` (or its members) may\n    /// rely on this. For example, setting a [`Vec<T>`] to an invalid but\n    /// non-null address makes it initialized (under the current implementation;\n    /// this does not constitute a stable guarantee), because the only\n    /// requirement the compiler knows about it is that the data pointer must be\n    /// non-null. Dropping such a `Vec<T>` however will cause undefined\n    /// behaviour.\n    ///\n    /// [`assume_init`]: MaybeUninit::assume_init\n    /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n    pub unsafe fn assume_init_drop(&mut self) {\n        // SAFETY: the caller must guarantee that `self` is initialized and\n        // satisfies all invariants of `T`.\n        // Dropping the value in place is safe if that is the case.\n        unsafe { ptr::drop_in_place(self.as_mut_ptr()) }\n    }\n\n    /// Gets a shared reference to the contained value.\n    ///\n    /// This can be useful when we want to access a `MaybeUninit` that has been\n    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n    /// of `.assume_init()`).\n    ///\n    /// # Safety\n    ///\n    /// Calling this when the content is not yet fully initialized causes undefined\n    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n    /// is in an initialized state.\n    ///\n    /// # Examples\n    ///\n    /// ### Correct usage of this method:\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n    /// // Initialize `x`:\n    /// unsafe { x.as_mut_ptr().write(vec![1, 2, 3]); }\n    /// // Now that our `MaybeUninit<_>` is known to be initialized, it is okay to\n    /// // create a shared reference to it:\n    /// let x: &Vec<u32> = unsafe {\n    ///     // SAFETY: `x` has been initialized.\n    ///     x.assume_init_ref()\n    /// };\n    /// assert_eq!(x, &vec![1, 2, 3]);\n    /// ```\n    ///\n    /// ### *Incorrect* usages of this method:\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n    /// let x_vec: &Vec<u32> = unsafe { x.assume_init_ref() };\n    /// // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n    /// ```\n    ///\n    /// ```rust,no_run\n    /// use std::{cell::Cell, mem::MaybeUninit};\n    ///\n    /// let b = MaybeUninit::<Cell<bool>>::uninit();\n    /// // Initialize the `MaybeUninit` using `Cell::set`:\n    /// unsafe {\n    ///     b.assume_init_ref().set(true);\n    ///    // ^^^^^^^^^^^^^^^\n    ///    // Reference to an uninitialized `Cell<bool>`: UB!\n    /// }\n    /// ```\n    #[stable(feature = \"maybe_uninit_ref\", since = \"1.55.0\")]\n    #[rustc_const_unstable(feature = \"const_maybe_uninit_assume_init\", issue = \"none\")]\n    #[inline(always)]\n    pub const unsafe fn assume_init_ref(&self) -> &T {\n        // SAFETY: the caller must guarantee that `self` is initialized.\n        // This also means that `self` must be a `value` variant.\n        unsafe {\n            intrinsics::assert_inhabited::<T>();\n            &*self.as_ptr()\n        }\n    }\n\n    /// Gets a mutable (unique) reference to the contained value.\n    ///\n    /// This can be useful when we want to access a `MaybeUninit` that has been\n    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n    /// of `.assume_init()`).\n    ///\n    /// # Safety\n    ///\n    /// Calling this when the content is not yet fully initialized causes undefined\n    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n    /// is in an initialized state. For instance, `.assume_init_mut()` cannot be used to\n    /// initialize a `MaybeUninit`.\n    ///\n    /// # Examples\n    ///\n    /// ### Correct usage of this method:\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// # unsafe extern \"C\" fn initialize_buffer(buf: *mut [u8; 1024]) { *buf = [0; 1024] }\n    /// # #[cfg(FALSE)]\n    /// extern \"C\" {\n    ///     /// Initializes *all* the bytes of the input buffer.\n    ///     fn initialize_buffer(buf: *mut [u8; 1024]);\n    /// }\n    ///\n    /// let mut buf = MaybeUninit::<[u8; 1024]>::uninit();\n    ///\n    /// // Initialize `buf`:\n    /// unsafe { initialize_buffer(buf.as_mut_ptr()); }\n    /// // Now we know that `buf` has been initialized, so we could `.assume_init()` it.\n    /// // However, using `.assume_init()` may trigger a `memcpy` of the 1024 bytes.\n    /// // To assert our buffer has been initialized without copying it, we upgrade\n    /// // the `&mut MaybeUninit<[u8; 1024]>` to a `&mut [u8; 1024]`:\n    /// let buf: &mut [u8; 1024] = unsafe {\n    ///     // SAFETY: `buf` has been initialized.\n    ///     buf.assume_init_mut()\n    /// };\n    ///\n    /// // Now we can use `buf` as a normal slice:\n    /// buf.sort_unstable();\n    /// assert!(\n    ///     buf.windows(2).all(|pair| pair[0] <= pair[1]),\n    ///     \"buffer is sorted\",\n    /// );\n    /// ```\n    ///\n    /// ### *Incorrect* usages of this method:\n    ///\n    /// You cannot use `.assume_init_mut()` to initialize a value:\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut b = MaybeUninit::<bool>::uninit();\n    /// unsafe {\n    ///     *b.assume_init_mut() = true;\n    ///     // We have created a (mutable) reference to an uninitialized `bool`!\n    ///     // This is undefined behavior. ⚠️\n    /// }\n    /// ```\n    ///\n    /// For instance, you cannot [`Read`] into an uninitialized buffer:\n    ///\n    /// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n    ///\n    /// ```rust,no_run\n    /// use std::{io, mem::MaybeUninit};\n    ///\n    /// fn read_chunk (reader: &'_ mut dyn io::Read) -> io::Result<[u8; 64]>\n    /// {\n    ///     let mut buffer = MaybeUninit::<[u8; 64]>::uninit();\n    ///     reader.read_exact(unsafe { buffer.assume_init_mut() })?;\n    ///                             // ^^^^^^^^^^^^^^^^^^^^^^^^\n    ///                             // (mutable) reference to uninitialized memory!\n    ///                             // This is undefined behavior.\n    ///     Ok(unsafe { buffer.assume_init() })\n    /// }\n    /// ```\n    ///\n    /// Nor can you use direct field access to do field-by-field gradual initialization:\n    ///\n    /// ```rust,no_run\n    /// use std::{mem::MaybeUninit, ptr};\n    ///\n    /// struct Foo {\n    ///     a: u32,\n    ///     b: u8,\n    /// }\n    ///\n    /// let foo: Foo = unsafe {\n    ///     let mut foo = MaybeUninit::<Foo>::uninit();\n    ///     ptr::write(&mut foo.assume_init_mut().a as *mut u32, 1337);\n    ///                  // ^^^^^^^^^^^^^^^^^^^^^\n    ///                  // (mutable) reference to uninitialized memory!\n    ///                  // This is undefined behavior.\n    ///     ptr::write(&mut foo.assume_init_mut().b as *mut u8, 42);\n    ///                  // ^^^^^^^^^^^^^^^^^^^^^\n    ///                  // (mutable) reference to uninitialized memory!\n    ///                  // This is undefined behavior.\n    ///     foo.assume_init()\n    /// };\n    /// ```\n    #[stable(feature = \"maybe_uninit_ref\", since = \"1.55.0\")]\n    #[rustc_const_unstable(feature = \"const_maybe_uninit_assume_init\", issue = \"none\")]\n    #[inline(always)]\n    pub const unsafe fn assume_init_mut(&mut self) -> &mut T {\n        // SAFETY: the caller must guarantee that `self` is initialized.\n        // This also means that `self` must be a `value` variant.\n        unsafe {\n            intrinsics::assert_inhabited::<T>();\n            &mut *self.as_mut_ptr()\n        }\n    }\n\n    /// Extracts the values from an array of `MaybeUninit` containers.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that all elements of the array are\n    /// in an initialized state.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(maybe_uninit_uninit_array)]\n    /// #![feature(maybe_uninit_array_assume_init)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut array: [MaybeUninit<i32>; 3] = MaybeUninit::uninit_array();\n    /// array[0] = MaybeUninit::new(0);\n    /// array[1] = MaybeUninit::new(1);\n    /// array[2] = MaybeUninit::new(2);\n    ///\n    /// // SAFETY: Now safe as we initialised all elements\n    /// let array = unsafe {\n    ///     MaybeUninit::array_assume_init(array)\n    /// };\n    ///\n    /// assert_eq!(array, [0, 1, 2]);\n    /// ```\n    #[unstable(feature = \"maybe_uninit_array_assume_init\", issue = \"80908\")]\n    #[inline(always)]\n    pub unsafe fn array_assume_init<const N: usize>(array: [Self; N]) -> [T; N] {\n        // SAFETY:\n        // * The caller guarantees that all elements of the array are initialized\n        // * `MaybeUninit<T>` and T are guaranteed to have the same layout\n        // * `MaybeUninit` does not drop, so there are no double-frees\n        // And thus the conversion is safe\n        unsafe {\n            intrinsics::assert_inhabited::<[T; N]>();\n            (&array as *const _ as *const [T; N]).read()\n        }\n    }\n\n    /// Assuming all the elements are initialized, get a slice to them.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n    /// really are in an initialized state.\n    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n    ///\n    /// See [`assume_init_ref`] for more details and examples.\n    ///\n    /// [`assume_init_ref`]: MaybeUninit::assume_init_ref\n    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n    #[rustc_const_unstable(feature = \"const_maybe_uninit_assume_init\", issue = \"none\")]\n    #[inline(always)]\n    pub const unsafe fn slice_assume_init_ref(slice: &[Self]) -> &[T] {\n        // SAFETY: casting slice to a `*const [T]` is safe since the caller guarantees that\n        // `slice` is initialized, and`MaybeUninit` is guaranteed to have the same layout as `T`.\n        // The pointer obtained is valid since it refers to memory owned by `slice` which is a\n        // reference and thus guaranteed to be valid for reads.\n        unsafe { &*(slice as *const [Self] as *const [T]) }\n    }\n\n    /// Assuming all the elements are initialized, get a mutable slice to them.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n    /// really are in an initialized state.\n    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n    ///\n    /// See [`assume_init_mut`] for more details and examples.\n    ///\n    /// [`assume_init_mut`]: MaybeUninit::assume_init_mut\n    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n    #[rustc_const_unstable(feature = \"const_maybe_uninit_assume_init\", issue = \"none\")]\n    #[inline(always)]\n    pub const unsafe fn slice_assume_init_mut(slice: &mut [Self]) -> &mut [T] {\n        // SAFETY: similar to safety notes for `slice_get_ref`, but we have a\n        // mutable reference which is also guaranteed to be valid for writes.\n        unsafe { &mut *(slice as *mut [Self] as *mut [T]) }\n    }\n\n    /// Gets a pointer to the first element of the array.\n    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n    #[rustc_const_unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n    #[inline(always)]\n    pub const fn slice_as_ptr(this: &[MaybeUninit<T>]) -> *const T {\n        this.as_ptr() as *const T\n    }\n\n    /// Gets a mutable pointer to the first element of the array.\n    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n    #[rustc_const_unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n    #[inline(always)]\n    pub const fn slice_as_mut_ptr(this: &mut [MaybeUninit<T>]) -> *mut T {\n        this.as_mut_ptr() as *mut T\n    }\n\n    /// Copies the elements from `src` to `this`, returning a mutable reference to the now initialized contents of `this`.\n    ///\n    /// If `T` does not implement `Copy`, use [`write_slice_cloned`]\n    ///\n    /// This is similar to [`slice::copy_from_slice`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(maybe_uninit_write_slice)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut dst = [MaybeUninit::uninit(); 32];\n    /// let src = [0; 32];\n    ///\n    /// let init = MaybeUninit::write_slice(&mut dst, &src);\n    ///\n    /// assert_eq!(init, src);\n    /// ```\n    ///\n    /// ```\n    /// #![feature(maybe_uninit_write_slice, vec_spare_capacity)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut vec = Vec::with_capacity(32);\n    /// let src = [0; 16];\n    ///\n    /// MaybeUninit::write_slice(&mut vec.spare_capacity_mut()[..src.len()], &src);\n    ///\n    /// // SAFETY: we have just copied all the elements of len into the spare capacity\n    /// // the first src.len() elements of the vec are valid now.\n    /// unsafe {\n    ///     vec.set_len(src.len());\n    /// }\n    ///\n    /// assert_eq!(vec, src);\n    /// ```\n    ///\n    /// [`write_slice_cloned`]: MaybeUninit::write_slice_cloned\n    #[unstable(feature = \"maybe_uninit_write_slice\", issue = \"79995\")]\n    pub fn write_slice<'a>(this: &'a mut [MaybeUninit<T>], src: &[T]) -> &'a mut [T]\n    where\n        T: Copy,\n    {\n        // SAFETY: &[T] and &[MaybeUninit<T>] have the same layout\n        let uninit_src: &[MaybeUninit<T>] = unsafe { super::transmute(src) };\n\n        this.copy_from_slice(uninit_src);\n\n        // SAFETY: Valid elements have just been copied into `this` so it is initialized\n        unsafe { MaybeUninit::slice_assume_init_mut(this) }\n    }\n\n    /// Clones the elements from `src` to `this`, returning a mutable reference to the now initialized contents of `this`.\n    /// Any already initialized elements will not be dropped.\n    ///\n    /// If `T` implements `Copy`, use [`write_slice`]\n    ///\n    /// This is similar to [`slice::clone_from_slice`] but does not drop existing elements.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths, or if the implementation of `Clone` panics.\n    ///\n    /// If there is a panic, the already cloned elements will be dropped.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(maybe_uninit_write_slice)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut dst = [MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit()];\n    /// let src = [\"wibbly\".to_string(), \"wobbly\".to_string(), \"timey\".to_string(), \"wimey\".to_string(), \"stuff\".to_string()];\n    ///\n    /// let init = MaybeUninit::write_slice_cloned(&mut dst, &src);\n    ///\n    /// assert_eq!(init, src);\n    /// ```\n    ///\n    /// ```\n    /// #![feature(maybe_uninit_write_slice, vec_spare_capacity)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut vec = Vec::with_capacity(32);\n    /// let src = [\"rust\", \"is\", \"a\", \"pretty\", \"cool\", \"language\"];\n    ///\n    /// MaybeUninit::write_slice_cloned(&mut vec.spare_capacity_mut()[..src.len()], &src);\n    ///\n    /// // SAFETY: we have just cloned all the elements of len into the spare capacity\n    /// // the first src.len() elements of the vec are valid now.\n    /// unsafe {\n    ///     vec.set_len(src.len());\n    /// }\n    ///\n    /// assert_eq!(vec, src);\n    /// ```\n    ///\n    /// [`write_slice`]: MaybeUninit::write_slice\n    #[unstable(feature = \"maybe_uninit_write_slice\", issue = \"79995\")]\n    pub fn write_slice_cloned<'a>(this: &'a mut [MaybeUninit<T>], src: &[T]) -> &'a mut [T]\n    where\n        T: Clone,\n    {\n        // unlike copy_from_slice this does not call clone_from_slice on the slice\n        // this is because `MaybeUninit<T: Clone>` does not implement Clone.\n\n        struct Guard<'a, T> {\n            slice: &'a mut [MaybeUninit<T>],\n            initialized: usize,\n        }\n\n        impl<'a, T> Drop for Guard<'a, T> {\n            fn drop(&mut self) {\n                let initialized_part = &mut self.slice[..self.initialized];\n                // SAFETY: this raw slice will contain only initialized objects\n                // that's why, it is allowed to drop it.\n                unsafe {\n                    crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(initialized_part));\n                }\n            }\n        }\n\n        assert_eq!(this.len(), src.len(), \"destination and source slices have different lengths\");\n        // NOTE: We need to explicitly slice them to the same length\n        // for bounds checking to be elided, and the optimizer will\n        // generate memcpy for simple cases (for example T = u8).\n        let len = this.len();\n        let src = &src[..len];\n\n        // guard is needed b/c panic might happen during a clone\n        let mut guard = Guard { slice: this, initialized: 0 };\n\n        for i in 0..len {\n            guard.slice[i].write(src[i].clone());\n            guard.initialized += 1;\n        }\n\n        super::forget(guard);\n\n        // SAFETY: Valid elements have just been written into `this` so it is initialized\n        unsafe { MaybeUninit::slice_assume_init_mut(this) }\n    }\n}\n"],[2840,"//! Basic functions for dealing with memory.\n//!\n//! This module contains functions for querying the size and alignment of\n//! types, initializing and manipulating memory.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::clone;\nuse crate::cmp;\nuse crate::fmt;\nuse crate::hash;\nuse crate::intrinsics;\nuse crate::marker::{Copy, DiscriminantKind, Sized};\nuse crate::ptr;\n\nmod manually_drop;\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\npub use manually_drop::ManuallyDrop;\n\nmod maybe_uninit;\n#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\npub use maybe_uninit::MaybeUninit;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(inline)]\npub use crate::intrinsics::transmute;\n\n/// Takes ownership and \"forgets\" about the value **without running its destructor**.\n///\n/// Any resources the value manages, such as heap memory or a file handle, will linger\n/// forever in an unreachable state. However, it does not guarantee that pointers\n/// to this memory will remain valid.\n///\n/// * If you want to leak memory, see [`Box::leak`].\n/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`].\n/// * If you want to dispose of a value properly, running its destructor, see\n/// [`mem::drop`].\n///\n/// # Safety\n///\n/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n/// do not include a guarantee that destructors will always run. For example,\n/// a program can create a reference cycle using [`Rc`][rc], or call\n/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n/// `mem::forget` from safe code does not fundamentally change Rust's safety\n/// guarantees.\n///\n/// That said, leaking resources such as memory or I/O objects is usually undesirable.\n/// The need comes up in some specialized use cases for FFI or unsafe code, but even\n/// then, [`ManuallyDrop`] is typically preferred.\n///\n/// Because forgetting a value is allowed, any `unsafe` code you write must\n/// allow for this possibility. You cannot return a value and expect that the\n/// caller will necessarily run the value's destructor.\n///\n/// [rc]: ../../std/rc/struct.Rc.html\n/// [exit]: ../../std/process/fn.exit.html\n///\n/// # Examples\n///\n/// The canonical safe use of `mem::forget` is to circumvent a value's destructor\n/// implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n/// the space taken by the variable but never close the underlying system resource:\n///\n/// ```no_run\n/// use std::mem;\n/// use std::fs::File;\n///\n/// let file = File::open(\"foo.txt\").unwrap();\n/// mem::forget(file);\n/// ```\n///\n/// This is useful when the ownership of the underlying resource was previously\n/// transferred to code outside of Rust, for example by transmitting the raw\n/// file descriptor to C code.\n///\n/// # Relationship with `ManuallyDrop`\n///\n/// While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.\n/// [`ManuallyDrop`] should be used instead. Consider, for example, this code:\n///\n/// ```\n/// use std::mem;\n///\n/// let mut v = vec![65, 122];\n/// // Build a `String` using the contents of `v`\n/// let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n/// // leak `v` because its memory is now managed by `s`\n/// mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n/// assert_eq!(s, \"Az\");\n/// // `s` is implicitly dropped and its memory deallocated.\n/// ```\n///\n/// There are two issues with the above example:\n///\n/// * If more code were added between the construction of `String` and the invocation of\n///   `mem::forget()`, a panic within it would cause a double free because the same memory\n///   is handled by both `v` and `s`.\n/// * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n///   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't\n///   inspect it), some types have strict requirements on their values that\n///   make them invalid when dangling or no longer owned. Using invalid values in any\n///   way, including passing them to or returning them from functions, constitutes\n///   undefined behavior and may break the assumptions made by the compiler.\n///\n/// Switching to `ManuallyDrop` avoids both issues:\n///\n/// ```\n/// use std::mem::ManuallyDrop;\n///\n/// let v = vec![65, 122];\n/// // Before we disassemble `v` into its raw parts, make sure it\n/// // does not get dropped!\n/// let mut v = ManuallyDrop::new(v);\n/// // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n/// let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n/// // Finally, build a `String`.\n/// let s = unsafe { String::from_raw_parts(ptr, len, cap) };\n/// assert_eq!(s, \"Az\");\n/// // `s` is implicitly dropped and its memory deallocated.\n/// ```\n///\n/// `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n/// before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n/// argument, forcing us to call it only after extracting anything we need from `v`. Even\n/// if a panic were introduced between construction of `ManuallyDrop` and building the\n/// string (which cannot happen in the code as shown), it would result in a leak and not a\n/// double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n/// erring on the side of (double-)dropping.\n///\n/// Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n/// ownership to `s` — the final step of interacting with `v` to dispose of it without\n/// running its destructor is entirely avoided.\n///\n/// [`Box`]: ../../std/boxed/struct.Box.html\n/// [`Box::leak`]: ../../std/boxed/struct.Box.html#method.leak\n/// [`Box::into_raw`]: ../../std/boxed/struct.Box.html#method.into_raw\n/// [`mem::drop`]: drop\n/// [ub]: ../../reference/behavior-considered-undefined.html\n#[inline]\n#[rustc_const_stable(feature = \"const_forget\", since = \"1.46.0\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const fn forget<T>(t: T) {\n    let _ = ManuallyDrop::new(t);\n}\n\n/// Like [`forget`], but also accepts unsized values.\n///\n/// This function is just a shim intended to be removed when the `unsized_locals` feature gets\n/// stabilized.\n#[inline]\n#[unstable(feature = \"forget_unsized\", issue = \"none\")]\npub fn forget_unsized<T: ?Sized>(t: T) {\n    intrinsics::forget(t)\n}\n\n/// Returns the size of a type in bytes.\n///\n/// More specifically, this is the offset in bytes between successive elements\n/// in an array with that item type including alignment padding. Thus, for any\n/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n///\n/// In general, the size of a type is not stable across compilations, but\n/// specific types such as primitives are.\n///\n/// The following table gives the size for primitives.\n///\n/// Type | size_of::\\<Type>()\n/// ---- | ---------------\n/// () | 0\n/// bool | 1\n/// u8 | 1\n/// u16 | 2\n/// u32 | 4\n/// u64 | 8\n/// u128 | 16\n/// i8 | 1\n/// i16 | 2\n/// i32 | 4\n/// i64 | 8\n/// i128 | 16\n/// f32 | 4\n/// f64 | 8\n/// char | 4\n///\n/// Furthermore, `usize` and `isize` have the same size.\n///\n/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n///\n/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n/// have the same size. Likewise for `*const T` and `*mut T`.\n///\n/// # Size of `#[repr(C)]` items\n///\n/// The `C` representation for items has a defined layout. With this layout,\n/// the size of items is also stable as long as all fields have a stable size.\n///\n/// ## Size of Structs\n///\n/// For `structs`, the size is determined by the following algorithm.\n///\n/// For each field in the struct ordered by declaration order:\n///\n/// 1. Add the size of the field.\n/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n///\n/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n/// The alignment of the struct is usually the largest alignment of all its\n/// fields; this can be changed with the use of `repr(align(N))`.\n///\n/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n///\n/// ## Size of Enums\n///\n/// Enums that carry no data other than the discriminant have the same size as C enums\n/// on the platform they are compiled for.\n///\n/// ## Size of Unions\n///\n/// The size of a union is the size of its largest field.\n///\n/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// // Some primitives\n/// assert_eq!(4, mem::size_of::<i32>());\n/// assert_eq!(8, mem::size_of::<f64>());\n/// assert_eq!(0, mem::size_of::<()>());\n///\n/// // Some arrays\n/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n///\n///\n/// // Pointer size equality\n/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n/// ```\n///\n/// Using `#[repr(C)]`.\n///\n/// ```\n/// use std::mem;\n///\n/// #[repr(C)]\n/// struct FieldStruct {\n///     first: u8,\n///     second: u16,\n///     third: u8\n/// }\n///\n/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n/// // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n/// // fields is 2), so add 1 to the size for padding. Size is 6.\n/// assert_eq!(6, mem::size_of::<FieldStruct>());\n///\n/// #[repr(C)]\n/// struct TupleStruct(u8, u16, u8);\n///\n/// // Tuple structs follow the same rules.\n/// assert_eq!(6, mem::size_of::<TupleStruct>());\n///\n/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n/// // by putting `third` before `second`.\n/// #[repr(C)]\n/// struct FieldStructOptimized {\n///     first: u8,\n///     third: u8,\n///     second: u16\n/// }\n///\n/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n///\n/// // Union size is the size of the largest field.\n/// #[repr(C)]\n/// union ExampleUnion {\n///     smaller: u8,\n///     larger: u16\n/// }\n///\n/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n/// ```\n///\n/// [alignment]: align_of\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_size_of\", since = \"1.24.0\")]\npub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}\n\n/// Returns the size of the pointed-to value in bytes.\n///\n/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n/// then `size_of_val` can be used to get the dynamically-known size.\n///\n/// [trait object]: ../../book/ch17-02-trait-objects.html\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::size_of_val(&5i32));\n///\n/// let x: [u8; 13] = [0; 13];\n/// let y: &[u8] = &x;\n/// assert_eq!(13, mem::size_of_val(y));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\npub const fn size_of_val<T: ?Sized>(val: &T) -> usize {\n    // SAFETY: `val` is a reference, so it's a valid raw pointer\n    unsafe { intrinsics::size_of_val(val) }\n}\n\n/// Returns the size of the pointed-to value in bytes.\n///\n/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n/// then `size_of_val_raw` can be used to get the dynamically-known size.\n///\n/// # Safety\n///\n/// This function is only safe to call if the following conditions hold:\n///\n/// - If `T` is `Sized`, this function is always safe to call.\n/// - If the unsized tail of `T` is:\n///     - a [slice], then the length of the slice tail must be an initialized\n///       integer, and the size of the *entire value*\n///       (dynamic tail length + statically sized prefix) must fit in `isize`.\n///     - a [trait object], then the vtable part of the pointer must point\n///       to a valid vtable acquired by an unsizing coercion, and the size\n///       of the *entire value* (dynamic tail length + statically sized prefix)\n///       must fit in `isize`.\n///     - an (unstable) [extern type], then this function is always safe to\n///       call, but may panic or otherwise return the wrong value, as the\n///       extern type's layout is not known. This is the same behavior as\n///       [`size_of_val`] on a reference to a type with an extern type tail.\n///     - otherwise, it is conservatively not allowed to call this function.\n///\n/// [trait object]: ../../book/ch17-02-trait-objects.html\n/// [extern type]: ../../unstable-book/language-features/extern-types.html\n///\n/// # Examples\n///\n/// ```\n/// #![feature(layout_for_ptr)]\n/// use std::mem;\n///\n/// assert_eq!(4, mem::size_of_val(&5i32));\n///\n/// let x: [u8; 13] = [0; 13];\n/// let y: &[u8] = &x;\n/// assert_eq!(13, unsafe { mem::size_of_val_raw(y) });\n/// ```\n#[inline]\n#[unstable(feature = \"layout_for_ptr\", issue = \"69835\")]\n#[rustc_const_unstable(feature = \"const_size_of_val_raw\", issue = \"46571\")]\npub const unsafe fn size_of_val_raw<T: ?Sized>(val: *const T) -> usize {\n    // SAFETY: the caller must provide a valid raw pointer\n    unsafe { intrinsics::size_of_val(val) }\n}\n\n/// Returns the [ABI]-required minimum alignment of a type.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(deprecated)]\n/// use std::mem;\n///\n/// assert_eq!(4, mem::min_align_of::<i32>());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\npub fn min_align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}\n\n/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(deprecated)]\n/// use std::mem;\n///\n/// assert_eq!(4, mem::min_align_of_val(&5i32));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\npub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n    // SAFETY: val is a reference, so it's a valid raw pointer\n    unsafe { intrinsics::min_align_of_val(val) }\n}\n\n/// Returns the [ABI]-required minimum alignment of a type.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::align_of::<i32>());\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_align_of\", since = \"1.24.0\")]\npub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}\n\n/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::align_of_val(&5i32));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n#[allow(deprecated)]\npub const fn align_of_val<T: ?Sized>(val: &T) -> usize {\n    // SAFETY: val is a reference, so it's a valid raw pointer\n    unsafe { intrinsics::min_align_of_val(val) }\n}\n\n/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Safety\n///\n/// This function is only safe to call if the following conditions hold:\n///\n/// - If `T` is `Sized`, this function is always safe to call.\n/// - If the unsized tail of `T` is:\n///     - a [slice], then the length of the slice tail must be an initialized\n///       integer, and the size of the *entire value*\n///       (dynamic tail length + statically sized prefix) must fit in `isize`.\n///     - a [trait object], then the vtable part of the pointer must point\n///       to a valid vtable acquired by an unsizing coercion, and the size\n///       of the *entire value* (dynamic tail length + statically sized prefix)\n///       must fit in `isize`.\n///     - an (unstable) [extern type], then this function is always safe to\n///       call, but may panic or otherwise return the wrong value, as the\n///       extern type's layout is not known. This is the same behavior as\n///       [`align_of_val`] on a reference to a type with an extern type tail.\n///     - otherwise, it is conservatively not allowed to call this function.\n///\n/// [trait object]: ../../book/ch17-02-trait-objects.html\n/// [extern type]: ../../unstable-book/language-features/extern-types.html\n///\n/// # Examples\n///\n/// ```\n/// #![feature(layout_for_ptr)]\n/// use std::mem;\n///\n/// assert_eq!(4, unsafe { mem::align_of_val_raw(&5i32) });\n/// ```\n#[inline]\n#[unstable(feature = \"layout_for_ptr\", issue = \"69835\")]\n#[rustc_const_unstable(feature = \"const_align_of_val_raw\", issue = \"46571\")]\npub const unsafe fn align_of_val_raw<T: ?Sized>(val: *const T) -> usize {\n    // SAFETY: the caller must provide a valid raw pointer\n    unsafe { intrinsics::min_align_of_val(val) }\n}\n\n/// Returns `true` if dropping values of type `T` matters.\n///\n/// This is purely an optimization hint, and may be implemented conservatively:\n/// it may return `true` for types that don't actually need to be dropped.\n/// As such always returning `true` would be a valid implementation of\n/// this function. However if this function actually returns `false`, then you\n/// can be certain dropping `T` has no side effect.\n///\n/// Low level implementations of things like collections, which need to manually\n/// drop their data, should use this function to avoid unnecessarily\n/// trying to drop all their contents when they are destroyed. This might not\n/// make a difference in release builds (where a loop that has no side-effects\n/// is easily detected and eliminated), but is often a big win for debug builds.\n///\n/// Note that [`drop_in_place`] already performs this check, so if your workload\n/// can be reduced to some small number of [`drop_in_place`] calls, using this is\n/// unnecessary. In particular note that you can [`drop_in_place`] a slice, and that\n/// will do a single needs_drop check for all the values.\n///\n/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n/// `needs_drop` explicitly. Types like [`HashMap`], on the other hand, have to drop\n/// values one at a time and should use this API.\n///\n/// [`drop_in_place`]: crate::ptr::drop_in_place\n/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n///\n/// # Examples\n///\n/// Here's an example of how a collection might make use of `needs_drop`:\n///\n/// ```\n/// use std::{mem, ptr};\n///\n/// pub struct MyCollection<T> {\n/// #   data: [T; 1],\n///     /* ... */\n/// }\n/// # impl<T> MyCollection<T> {\n/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n/// #   fn free_buffer(&mut self) {}\n/// # }\n///\n/// impl<T> Drop for MyCollection<T> {\n///     fn drop(&mut self) {\n///         unsafe {\n///             // drop the data\n///             if mem::needs_drop::<T>() {\n///                 for x in self.iter_mut() {\n///                     ptr::drop_in_place(x);\n///                 }\n///             }\n///             self.free_buffer();\n///         }\n///     }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n#[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.36.0\")]\n#[rustc_diagnostic_item = \"needs_drop\"]\npub const fn needs_drop<T>() -> bool {\n    intrinsics::needs_drop::<T>()\n}\n\n/// Returns the value of type `T` represented by the all-zero byte-pattern.\n///\n/// This means that, for example, the padding byte in `(u8, u16)` is not\n/// necessarily zeroed.\n///\n/// There is no guarantee that an all-zero byte-pattern represents a valid value\n/// of some type `T`. For example, the all-zero byte-pattern is not a valid value\n/// for reference types (`&T`, `&mut T`) and functions pointers. Using `zeroed`\n/// on such types causes immediate [undefined behavior][ub] because [the Rust\n/// compiler assumes][inv] that there always is a valid value in a variable it\n/// considers initialized.\n///\n/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n/// It is useful for FFI sometimes, but should generally be avoided.\n///\n/// [zeroed]: MaybeUninit::zeroed\n/// [ub]: ../../reference/behavior-considered-undefined.html\n/// [inv]: MaybeUninit#initialization-invariant\n///\n/// # Examples\n///\n/// Correct usage of this function: initializing an integer with zero.\n///\n/// ```\n/// use std::mem;\n///\n/// let x: i32 = unsafe { mem::zeroed() };\n/// assert_eq!(0, x);\n/// ```\n///\n/// *Incorrect* usage of this function: initializing a reference with zero.\n///\n/// ```rust,no_run\n/// # #![allow(invalid_value)]\n/// use std::mem;\n///\n/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n/// let _y: fn() = unsafe { mem::zeroed() }; // And again!\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated_in_future)]\n#[allow(deprecated)]\n#[rustc_diagnostic_item = \"mem_zeroed\"]\npub unsafe fn zeroed<T>() -> T {\n    // SAFETY: the caller must guarantee that an all-zero value is valid for `T`.\n    unsafe {\n        intrinsics::assert_zero_valid::<T>();\n        MaybeUninit::zeroed().assume_init()\n    }\n}\n\n/// Bypasses Rust's normal memory-initialization checks by pretending to\n/// produce a value of type `T`, while doing nothing at all.\n///\n/// **This function is deprecated.** Use [`MaybeUninit<T>`] instead.\n///\n/// The reason for deprecation is that the function basically cannot be used\n/// correctly: it has the same effect as [`MaybeUninit::uninit().assume_init()`][uninit].\n/// As the [`assume_init` documentation][assume_init] explains,\n/// [the Rust compiler assumes][inv] that values are properly initialized.\n/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n/// undefined behavior for returning a `bool` that is not definitely either `true`\n/// or `false`. Worse, truly uninitialized memory like what gets returned here\n/// is special in that the compiler knows that it does not have a fixed value.\n/// This makes it undefined behavior to have uninitialized data in a variable even\n/// if that variable has an integer type.\n/// (Notice that the rules around uninitialized integers are not finalized yet, but\n/// until they are, it is advisable to avoid them.)\n///\n/// [uninit]: MaybeUninit::uninit\n/// [assume_init]: MaybeUninit::assume_init\n/// [inv]: MaybeUninit#initialization-invariant\n#[inline(always)]\n#[rustc_deprecated(since = \"1.39.0\", reason = \"use `mem::MaybeUninit` instead\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated_in_future)]\n#[allow(deprecated)]\n#[rustc_diagnostic_item = \"mem_uninitialized\"]\npub unsafe fn uninitialized<T>() -> T {\n    // SAFETY: the caller must guarantee that an unitialized value is valid for `T`.\n    unsafe {\n        intrinsics::assert_uninit_valid::<T>();\n        MaybeUninit::uninit().assume_init()\n    }\n}\n\n/// Swaps the values at two mutable locations, without deinitializing either one.\n///\n/// * If you want to swap with a default or dummy value, see [`take`].\n/// * If you want to swap with a passed value, returning the old value, see [`replace`].\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// let mut x = 5;\n/// let mut y = 42;\n///\n/// mem::swap(&mut x, &mut y);\n///\n/// assert_eq!(42, x);\n/// assert_eq!(5, y);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\npub const fn swap<T>(x: &mut T, y: &mut T) {\n    // SAFETY: the raw pointers have been created from safe mutable references satisfying all the\n    // constraints on `ptr::swap_nonoverlapping_one`\n    unsafe {\n        ptr::swap_nonoverlapping_one(x, y);\n    }\n}\n\n/// Replaces `dest` with the default value of `T`, returning the previous `dest` value.\n///\n/// * If you want to replace the values of two variables, see [`swap`].\n/// * If you want to replace with a passed value instead of the default value, see [`replace`].\n///\n/// # Examples\n///\n/// A simple example:\n///\n/// ```\n/// use std::mem;\n///\n/// let mut v: Vec<i32> = vec![1, 2];\n///\n/// let old_v = mem::take(&mut v);\n/// assert_eq!(vec![1, 2], old_v);\n/// assert!(v.is_empty());\n/// ```\n///\n/// `take` allows taking ownership of a struct field by replacing it with an \"empty\" value.\n/// Without `take` you can run into issues like these:\n///\n/// ```compile_fail,E0507\n/// struct Buffer<T> { buf: Vec<T> }\n///\n/// impl<T> Buffer<T> {\n///     fn get_and_reset(&mut self) -> Vec<T> {\n///         // error: cannot move out of dereference of `&mut`-pointer\n///         let buf = self.buf;\n///         self.buf = Vec::new();\n///         buf\n///     }\n/// }\n/// ```\n///\n/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n/// `self.buf`. But `take` can be used to disassociate the original value of `self.buf` from\n/// `self`, allowing it to be returned:\n///\n/// ```\n/// use std::mem;\n///\n/// # struct Buffer<T> { buf: Vec<T> }\n/// impl<T> Buffer<T> {\n///     fn get_and_reset(&mut self) -> Vec<T> {\n///         mem::take(&mut self.buf)\n///     }\n/// }\n///\n/// let mut buffer = Buffer { buf: vec![0, 1] };\n/// assert_eq!(buffer.buf.len(), 2);\n///\n/// assert_eq!(buffer.get_and_reset(), vec![0, 1]);\n/// assert_eq!(buffer.buf.len(), 0);\n/// ```\n#[inline]\n#[stable(feature = \"mem_take\", since = \"1.40.0\")]\npub fn take<T: Default>(dest: &mut T) -> T {\n    replace(dest, T::default())\n}\n\n/// Moves `src` into the referenced `dest`, returning the previous `dest` value.\n///\n/// Neither value is dropped.\n///\n/// * If you want to replace the values of two variables, see [`swap`].\n/// * If you want to replace with a default value, see [`take`].\n///\n/// # Examples\n///\n/// A simple example:\n///\n/// ```\n/// use std::mem;\n///\n/// let mut v: Vec<i32> = vec![1, 2];\n///\n/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n/// assert_eq!(vec![1, 2], old_v);\n/// assert_eq!(vec![3, 4, 5], v);\n/// ```\n///\n/// `replace` allows consumption of a struct field by replacing it with another value.\n/// Without `replace` you can run into issues like these:\n///\n/// ```compile_fail,E0507\n/// struct Buffer<T> { buf: Vec<T> }\n///\n/// impl<T> Buffer<T> {\n///     fn replace_index(&mut self, i: usize, v: T) -> T {\n///         // error: cannot move out of dereference of `&mut`-pointer\n///         let t = self.buf[i];\n///         self.buf[i] = v;\n///         t\n///     }\n/// }\n/// ```\n///\n/// Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to\n/// avoid the move. But `replace` can be used to disassociate the original value at that index from\n/// `self`, allowing it to be returned:\n///\n/// ```\n/// # #![allow(dead_code)]\n/// use std::mem;\n///\n/// # struct Buffer<T> { buf: Vec<T> }\n/// impl<T> Buffer<T> {\n///     fn replace_index(&mut self, i: usize, v: T) -> T {\n///         mem::replace(&mut self.buf[i], v)\n///     }\n/// }\n///\n/// let mut buffer = Buffer { buf: vec![0, 1] };\n/// assert_eq!(buffer.buf[0], 0);\n///\n/// assert_eq!(buffer.replace_index(0, 2), 0);\n/// assert_eq!(buffer.buf[0], 2);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[must_use = \"if you don't need the old value, you can just assign the new value directly\"]\n#[rustc_const_unstable(feature = \"const_replace\", issue = \"83164\")]\npub const fn replace<T>(dest: &mut T, src: T) -> T {\n    // SAFETY: We read from `dest` but directly write `src` into it afterwards,\n    // such that the old value is not duplicated. Nothing is dropped and\n    // nothing here can panic.\n    unsafe {\n        let result = ptr::read(dest);\n        ptr::write(dest, src);\n        result\n    }\n}\n\n/// Disposes of a value.\n///\n/// This does so by calling the argument's implementation of [`Drop`][drop].\n///\n/// This effectively does nothing for types which implement `Copy`, e.g.\n/// integers. Such values are copied and _then_ moved into the function, so the\n/// value persists after this function call.\n///\n/// This function is not magic; it is literally defined as\n///\n/// ```\n/// pub fn drop<T>(_x: T) { }\n/// ```\n///\n/// Because `_x` is moved into the function, it is automatically dropped before\n/// the function returns.\n///\n/// [drop]: Drop\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let v = vec![1, 2, 3];\n///\n/// drop(v); // explicitly drop the vector\n/// ```\n///\n/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n/// release a [`RefCell`] borrow:\n///\n/// ```\n/// use std::cell::RefCell;\n///\n/// let x = RefCell::new(1);\n///\n/// let mut mutable_borrow = x.borrow_mut();\n/// *mutable_borrow = 1;\n///\n/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n///\n/// let borrow = x.borrow();\n/// println!(\"{}\", *borrow);\n/// ```\n///\n/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n///\n/// ```\n/// #[derive(Copy, Clone)]\n/// struct Foo(u8);\n///\n/// let x = 1;\n/// let y = Foo(2);\n/// drop(x); // a copy of `x` is moved and dropped\n/// drop(y); // a copy of `y` is moved and dropped\n///\n/// println!(\"x: {}, y: {}\", x, y.0); // still available\n/// ```\n///\n/// [`RefCell`]: crate::cell::RefCell\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn drop<T>(_x: T) {}\n\n/// Interprets `src` as having type `&U`, and then reads `src` without moving\n/// the contained value.\n///\n/// This function will unsafely assume the pointer `src` is valid for [`size_of::<U>`][size_of]\n/// bytes by transmuting `&T` to `&U` and then reading the `&U` (except that this is done in a way\n/// that is correct even when `&U` makes stricter alignment requirements than `&T`). It will also\n/// unsafely create a copy of the contained value instead of moving out of `src`.\n///\n/// It is not a compile-time error if `T` and `U` have different sizes, but it\n/// is highly encouraged to only invoke this function where `T` and `U` have the\n/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n/// `T`.\n///\n/// [ub]: ../../reference/behavior-considered-undefined.html\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// #[repr(packed)]\n/// struct Foo {\n///     bar: u8,\n/// }\n///\n/// let foo_array = [10u8];\n///\n/// unsafe {\n///     // Copy the data from 'foo_array' and treat it as a 'Foo'\n///     let mut foo_struct: Foo = mem::transmute_copy(&foo_array);\n///     assert_eq!(foo_struct.bar, 10);\n///\n///     // Modify the copied data\n///     foo_struct.bar = 20;\n///     assert_eq!(foo_struct.bar, 20);\n/// }\n///\n/// // The contents of 'foo_array' should not have changed\n/// assert_eq!(foo_array, [10]);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_transmute_copy\", issue = \"83165\")]\npub const unsafe fn transmute_copy<T, U>(src: &T) -> U {\n    // If U has a higher alignment requirement, src may not be suitably aligned.\n    if align_of::<U>() > align_of::<T>() {\n        // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n        // The caller must guarantee that the actual transmutation is safe.\n        unsafe { ptr::read_unaligned(src as *const T as *const U) }\n    } else {\n        // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n        // We just checked that `src as *const U` was properly aligned.\n        // The caller must guarantee that the actual transmutation is safe.\n        unsafe { ptr::read(src as *const T as *const U) }\n    }\n}\n\n/// Opaque type representing the discriminant of an enum.\n///\n/// See the [`discriminant`] function in this module for more information.\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\npub struct Discriminant<T>(<T as DiscriminantKind>::Discriminant);\n\n// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> Copy for Discriminant<T> {}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> clone::Clone for Discriminant<T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> cmp::PartialEq for Discriminant<T> {\n    fn eq(&self, rhs: &Self) -> bool {\n        self.0 == rhs.0\n    }\n}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> cmp::Eq for Discriminant<T> {}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> hash::Hash for Discriminant<T> {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        self.0.hash(state);\n    }\n}\n\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\nimpl<T> fmt::Debug for Discriminant<T> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_tuple(\"Discriminant\").field(&self.0).finish()\n    }\n}\n\n/// Returns a value uniquely identifying the enum variant in `v`.\n///\n/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n/// return value is unspecified.\n///\n/// # Stability\n///\n/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n/// of some variant will not change between compilations with the same compiler.\n///\n/// # Examples\n///\n/// This can be used to compare enums that carry data, while disregarding\n/// the actual data:\n///\n/// ```\n/// use std::mem;\n///\n/// enum Foo { A(&'static str), B(i32), C(i32) }\n///\n/// assert_eq!(mem::discriminant(&Foo::A(\"bar\")), mem::discriminant(&Foo::A(\"baz\")));\n/// assert_eq!(mem::discriminant(&Foo::B(1)), mem::discriminant(&Foo::B(2)));\n/// assert_ne!(mem::discriminant(&Foo::B(3)), mem::discriminant(&Foo::C(3)));\n/// ```\n#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n#[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\npub const fn discriminant<T>(v: &T) -> Discriminant<T> {\n    Discriminant(intrinsics::discriminant_value(v))\n}\n\n/// Returns the number of variants in the enum type `T`.\n///\n/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n/// return value is unspecified. Equally, if `T` is an enum with more variants than `usize::MAX`\n/// the return value is unspecified. Uninhabited variants will be counted.\n///\n/// # Examples\n///\n/// ```\n/// # #![feature(never_type)]\n/// # #![feature(variant_count)]\n///\n/// use std::mem;\n///\n/// enum Void {}\n/// enum Foo { A(&'static str), B(i32), C(i32) }\n///\n/// assert_eq!(mem::variant_count::<Void>(), 0);\n/// assert_eq!(mem::variant_count::<Foo>(), 3);\n///\n/// assert_eq!(mem::variant_count::<Option<!>>(), 2);\n/// assert_eq!(mem::variant_count::<Result<!, !>>(), 2);\n/// ```\n#[inline(always)]\n#[unstable(feature = \"variant_count\", issue = \"73662\")]\n#[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\npub const fn variant_count<T>() -> usize {\n    intrinsics::variant_count::<T>()\n}\n"],[2841,"use crate::ops::{Deref, DerefMut};\nuse crate::ptr;\n\n/// A wrapper to inhibit compiler from automatically calling `T`’s destructor.\n/// This wrapper is 0-cost.\n///\n/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n/// about its contents. For example, initializing a `ManuallyDrop<&mut T>`\n/// with [`mem::zeroed`] is undefined behavior.\n/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n///\n/// Note that accessing the value inside a `ManuallyDrop<T>` is safe.\n/// This means that a `ManuallyDrop<T>` whose content has been dropped must not\n/// be exposed through a public safe API.\n/// Correspondingly, `ManuallyDrop::drop` is unsafe.\n///\n/// # `ManuallyDrop` and drop order.\n///\n/// Rust has a well-defined [drop order] of values. To make sure that fields or\n/// locals are dropped in a specific order, reorder the declarations such that\n/// the implicit drop order is the correct one.\n///\n/// It is possible to use `ManuallyDrop` to control the drop order, but this\n/// requires unsafe code and is hard to do correctly in the presence of\n/// unwinding.\n///\n/// For example, if you want to make sure that a specific field is dropped after\n/// the others, make it the last field of a struct:\n///\n/// ```\n/// struct Context;\n///\n/// struct Widget {\n///     children: Vec<Widget>,\n///     // `context` will be dropped after `children`.\n///     // Rust guarantees that fields are dropped in the order of declaration.\n///     context: Context,\n/// }\n/// ```\n///\n/// [drop order]: https://doc.rust-lang.org/reference/destructors.html\n/// [`mem::zeroed`]: crate::mem::zeroed\n/// [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n#[lang = \"manually_drop\"]\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[repr(transparent)]\npub struct ManuallyDrop<T: ?Sized> {\n    value: T,\n}\n\nimpl<T> ManuallyDrop<T> {\n    /// Wrap a value to be manually dropped.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::mem::ManuallyDrop;\n    /// let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n    /// x.truncate(5); // You can still safely operate on the value\n    /// assert_eq!(*x, \"Hello\");\n    /// // But `Drop` will not be run here\n    /// ```\n    #[must_use = \"if you don't need the wrapper, you can use `mem::forget` instead\"]\n    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n    #[rustc_const_stable(feature = \"const_manually_drop\", since = \"1.36.0\")]\n    #[inline(always)]\n    pub const fn new(value: T) -> ManuallyDrop<T> {\n        ManuallyDrop { value }\n    }\n\n    /// Extracts the value from the `ManuallyDrop` container.\n    ///\n    /// This allows the value to be dropped again.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::mem::ManuallyDrop;\n    /// let x = ManuallyDrop::new(Box::new(()));\n    /// let _: Box<()> = ManuallyDrop::into_inner(x); // This drops the `Box`.\n    /// ```\n    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n    #[rustc_const_stable(feature = \"const_manually_drop\", since = \"1.36.0\")]\n    #[inline(always)]\n    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {\n        slot.value\n    }\n\n    /// Takes the value from the `ManuallyDrop<T>` container out.\n    ///\n    /// This method is primarily intended for moving out values in drop.\n    /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n    /// you can use this method to take the value and use it however desired.\n    ///\n    /// Whenever possible, it is preferable to use [`into_inner`][`ManuallyDrop::into_inner`]\n    /// instead, which prevents duplicating the content of the `ManuallyDrop<T>`.\n    ///\n    /// # Safety\n    ///\n    /// This function semantically moves out the contained value without preventing further usage,\n    /// leaving the state of this container unchanged.\n    /// It is your responsibility to ensure that this `ManuallyDrop` is not used again.\n    ///\n    #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n    #[stable(feature = \"manually_drop_take\", since = \"1.42.0\")]\n    #[inline]\n    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n        // SAFETY: we are reading from a reference, which is guaranteed\n        // to be valid for reads.\n        unsafe { ptr::read(&slot.value) }\n    }\n}\n\nimpl<T: ?Sized> ManuallyDrop<T> {\n    /// Manually drops the contained value. This is exactly equivalent to calling\n    /// [`ptr::drop_in_place`] with a pointer to the contained value. As such, unless\n    /// the contained value is a packed struct, the destructor will be called in-place\n    /// without moving the value, and thus can be used to safely drop [pinned] data.\n    ///\n    /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n    ///\n    /// # Safety\n    ///\n    /// This function runs the destructor of the contained value. Other than changes made by\n    /// the destructor itself, the memory is left unchanged, and so as far as the compiler is\n    /// concerned still holds a bit-pattern which is valid for the type `T`.\n    ///\n    /// However, this \"zombie\" value should not be exposed to safe code, and this function\n    /// should not be called more than once. To use a value after it's been dropped, or drop\n    /// a value multiple times, can cause Undefined Behavior (depending on what `drop` does).\n    /// This is normally prevented by the type system, but users of `ManuallyDrop` must\n    /// uphold those guarantees without assistance from the compiler.\n    ///\n    /// [pinned]: crate::pin\n    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n    #[inline]\n    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n        // SAFETY: we are dropping the value pointed to by a mutable reference\n        // which is guaranteed to be valid for writes.\n        // It is up to the caller to make sure that `slot` isn't dropped again.\n        unsafe { ptr::drop_in_place(&mut slot.value) }\n    }\n}\n\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\nimpl<T: ?Sized> Deref for ManuallyDrop<T> {\n    type Target = T;\n    #[inline(always)]\n    fn deref(&self) -> &T {\n        &self.value\n    }\n}\n\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\nimpl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n    #[inline(always)]\n    fn deref_mut(&mut self) -> &mut T {\n        &mut self.value\n    }\n}\n"],[2842,"//! Panic support in the standard library.\n\n#![stable(feature = \"core_panic_info\", since = \"1.41.0\")]\n\nuse crate::any::Any;\nuse crate::fmt;\n\n#[doc(hidden)]\n#[unstable(feature = \"edition_panic\", issue = \"none\", reason = \"use panic!() instead\")]\n#[allow_internal_unstable(core_panic)]\n#[rustc_diagnostic_item = \"core_panic_2015_macro\"]\n#[rustc_macro_transparency = \"semitransparent\"]\npub macro panic_2015 {\n    () => (\n        $crate::panicking::panic(\"explicit panic\")\n    ),\n    ($msg:literal $(,)?) => (\n        $crate::panicking::panic($msg)\n    ),\n    ($msg:expr $(,)?) => (\n        $crate::panicking::panic_str($msg)\n    ),\n    ($fmt:expr, $($arg:tt)+) => (\n        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+))\n    ),\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"edition_panic\", issue = \"none\", reason = \"use panic!() instead\")]\n#[allow_internal_unstable(core_panic)]\n#[rustc_diagnostic_item = \"core_panic_2021_macro\"]\n#[rustc_macro_transparency = \"semitransparent\"]\npub macro panic_2021 {\n    () => (\n        $crate::panicking::panic(\"explicit panic\")\n    ),\n    ($($t:tt)+) => (\n        $crate::panicking::panic_fmt($crate::format_args!($($t)+))\n    ),\n}\n\n/// A struct providing information about a panic.\n///\n/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n/// function.\n///\n/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|panic_info| {\n///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n///         println!(\"panic occurred: {:?}\", s);\n///     } else {\n///         println!(\"panic occurred\");\n///     }\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[lang = \"panic_info\"]\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n#[derive(Debug)]\npub struct PanicInfo<'a> {\n    payload: &'a (dyn Any + Send),\n    message: Option<&'a fmt::Arguments<'a>>,\n    location: &'a Location<'a>,\n}\n\nimpl<'a> PanicInfo<'a> {\n    #[unstable(\n        feature = \"panic_internals\",\n        reason = \"internal details of the implementation of the `panic!` and related macros\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    #[inline]\n    pub fn internal_constructor(\n        message: Option<&'a fmt::Arguments<'a>>,\n        location: &'a Location<'a>,\n    ) -> Self {\n        struct NoPayload;\n        PanicInfo { location, message, payload: &NoPayload }\n    }\n\n    #[unstable(\n        feature = \"panic_internals\",\n        reason = \"internal details of the implementation of the `panic!` and related macros\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    #[inline]\n    pub fn set_payload(&mut self, info: &'a (dyn Any + Send)) {\n        self.payload = info;\n    }\n\n    /// Returns the payload associated with the panic.\n    ///\n    /// This will commonly, but not always, be a `&'static str` or [`String`].\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n    ///         println!(\"panic occurred: {:?}\", s);\n    ///     } else {\n    ///         println!(\"panic occurred\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn payload(&self) -> &(dyn Any + Send) {\n        self.payload\n    }\n\n    /// If the `panic!` macro from the `core` crate (not from `std`)\n    /// was used with a formatting string and some additional arguments,\n    /// returns that message ready to be used for example with [`fmt::write`]\n    #[unstable(feature = \"panic_info_message\", issue = \"66745\")]\n    pub fn message(&self) -> Option<&fmt::Arguments<'_>> {\n        self.message\n    }\n\n    /// Returns information about the location from which the panic originated,\n    /// if available.\n    ///\n    /// This method will currently always return [`Some`], but this may change\n    /// in future versions.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred in file '{}' at line {}\",\n    ///             location.file(),\n    ///             location.line(),\n    ///         );\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn location(&self) -> Option<&Location<'_>> {\n        // NOTE: If this is changed to sometimes return None,\n        // deal with that case in std::panicking::default_hook and std::panicking::begin_panic_fmt.\n        Some(&self.location)\n    }\n}\n\n#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\nimpl fmt::Display for PanicInfo<'_> {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        formatter.write_str(\"panicked at \")?;\n        if let Some(message) = self.message {\n            write!(formatter, \"'{}', \", message)?\n        } else if let Some(payload) = self.payload.downcast_ref::<&'static str>() {\n            write!(formatter, \"'{}', \", payload)?\n        }\n        // NOTE: we cannot use downcast_ref::<String>() here\n        // since String is not available in libcore!\n        // The payload is a String when `std::panic!` is called with multiple arguments,\n        // but in that case the message is also available.\n\n        self.location.fmt(formatter)\n    }\n}\n\n/// A struct containing information about the location of a panic.\n///\n/// This structure is created by [`PanicInfo::location()`].\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|panic_info| {\n///     if let Some(location) = panic_info.location() {\n///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n///     } else {\n///         println!(\"panic occurred but can't get location information...\");\n///     }\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n///\n/// # Comparisons\n///\n/// Comparisons for equality and ordering are made in file, line, then column priority.\n/// Files are compared as strings, not `Path`, which could be unexpected.\n/// See [`Location::file`]'s documentation for more discussion.\n#[lang = \"panic_location\"]\n#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub struct Location<'a> {\n    file: &'a str,\n    line: u32,\n    col: u32,\n}\n\nimpl<'a> Location<'a> {\n    /// Returns the source location of the caller of this function. If that function's caller is\n    /// annotated then its call location will be returned, and so on up the stack to the first call\n    /// within a non-tracked function body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::panic::Location;\n    ///\n    /// /// Returns the [`Location`] at which it is called.\n    /// #[track_caller]\n    /// fn get_caller_location() -> &'static Location<'static> {\n    ///     Location::caller()\n    /// }\n    ///\n    /// /// Returns a [`Location`] from within this function's definition.\n    /// fn get_just_one_location() -> &'static Location<'static> {\n    ///     get_caller_location()\n    /// }\n    ///\n    /// let fixed_location = get_just_one_location();\n    /// assert_eq!(fixed_location.file(), file!());\n    /// assert_eq!(fixed_location.line(), 14);\n    /// assert_eq!(fixed_location.column(), 5);\n    ///\n    /// // running the same untracked function in a different location gives us the same result\n    /// let second_fixed_location = get_just_one_location();\n    /// assert_eq!(fixed_location.file(), second_fixed_location.file());\n    /// assert_eq!(fixed_location.line(), second_fixed_location.line());\n    /// assert_eq!(fixed_location.column(), second_fixed_location.column());\n    ///\n    /// let this_location = get_caller_location();\n    /// assert_eq!(this_location.file(), file!());\n    /// assert_eq!(this_location.line(), 28);\n    /// assert_eq!(this_location.column(), 21);\n    ///\n    /// // running the tracked function in a different location produces a different value\n    /// let another_location = get_caller_location();\n    /// assert_eq!(this_location.file(), another_location.file());\n    /// assert_ne!(this_location.line(), another_location.line());\n    /// assert_ne!(this_location.column(), another_location.column());\n    /// ```\n    #[stable(feature = \"track_caller\", since = \"1.46.0\")]\n    #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n    #[track_caller]\n    pub const fn caller() -> &'static Location<'static> {\n        crate::intrinsics::caller_location()\n    }\n}\n\nimpl<'a> Location<'a> {\n    #![unstable(\n        feature = \"panic_internals\",\n        reason = \"internal details of the implementation of the `panic!` and related macros\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    pub const fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n        Location { file, line, col }\n    }\n\n    /// Returns the name of the source file from which the panic originated.\n    ///\n    /// # `&str`, not `&Path`\n    ///\n    /// The returned name refers to a source path on the compiling system, but it isn't valid to\n    /// represent this directly as a `&Path`. The compiled code may run on a different system with\n    /// a different `Path` implementation than the system providing the contents and this library\n    /// does not currently have a different \"host path\" type.\n    ///\n    /// The most surprising behavior occurs when \"the same\" file is reachable via multiple paths in\n    /// the module system (usually using the `#[path = \"...\"]` attribute or similar), which can\n    /// cause what appears to be identical code to return differing values from this function.\n    ///\n    /// # Cross-compilation\n    ///\n    /// This value is not suitable for passing to `Path::new` or similar constructors when the host\n    /// platform and target platform differ.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred in file '{}'\", location.file());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn file(&self) -> &str {\n        self.file\n    }\n\n    /// Returns the line number from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred at line {}\", location.line());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn line(&self) -> u32 {\n        self.line\n    }\n\n    /// Returns the column from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred at column {}\", location.column());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_col\", since = \"1.25.0\")]\n    pub fn column(&self) -> u32 {\n        self.col\n    }\n}\n\n#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\nimpl fmt::Display for Location<'_> {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(formatter, \"{}:{}:{}\", self.file, self.line, self.col)\n    }\n}\n\n/// An internal trait used by libstd to pass data from libstd to `panic_unwind`\n/// and other panic runtimes. Not intended to be stabilized any time soon, do\n/// not use.\n#[unstable(feature = \"std_internals\", issue = \"none\")]\n#[doc(hidden)]\npub unsafe trait BoxMeUp {\n    /// Take full ownership of the contents.\n    /// The return type is actually `Box<dyn Any + Send>`, but we cannot use `Box` in libcore.\n    ///\n    /// After this method got called, only some dummy default value is left in `self`.\n    /// Calling this method twice, or calling `get` after calling this method, is an error.\n    ///\n    /// The argument is borrowed because the panic runtime (`__rust_start_panic`) only\n    /// gets a borrowed `dyn BoxMeUp`.\n    fn take_box(&mut self) -> *mut (dyn Any + Send);\n\n    /// Just borrow the contents.\n    fn get(&mut self) -> &(dyn Any + Send);\n}\n"],[2843,"// See src/libstd/primitive_docs.rs for documentation.\n\nuse crate::cmp::Ordering::*;\nuse crate::cmp::*;\n\n// macro for implementing n-ary tuple functions and operations\nmacro_rules! tuple_impls {\n    ($(\n        $Tuple:ident {\n            $(($idx:tt) -> $T:ident)+\n        }\n    )+) => {\n        $(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:PartialEq),+> PartialEq for ($($T,)+) where last_type!($($T,)+): ?Sized {\n                #[inline]\n                fn eq(&self, other: &($($T,)+)) -> bool {\n                    $(self.$idx == other.$idx)&&+\n                }\n                #[inline]\n                fn ne(&self, other: &($($T,)+)) -> bool {\n                    $(self.$idx != other.$idx)||+\n                }\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:Eq),+> Eq for ($($T,)+) where last_type!($($T,)+): ?Sized {}\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n                    where last_type!($($T,)+): ?Sized {\n                #[inline]\n                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n                    lexical_partial_cmp!($(self.$idx, other.$idx),+)\n                }\n                #[inline]\n                fn lt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(lt, $(self.$idx, other.$idx),+)\n                }\n                #[inline]\n                fn le(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(le, $(self.$idx, other.$idx),+)\n                }\n                #[inline]\n                fn ge(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(ge, $(self.$idx, other.$idx),+)\n                }\n                #[inline]\n                fn gt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(gt, $(self.$idx, other.$idx),+)\n                }\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:Ord),+> Ord for ($($T,)+) where last_type!($($T,)+): ?Sized {\n                #[inline]\n                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                    lexical_cmp!($(self.$idx, other.$idx),+)\n                }\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:Default),+> Default for ($($T,)+) {\n                #[inline]\n                fn default() -> ($($T,)+) {\n                    ($({ let x: $T = Default::default(); x},)+)\n                }\n            }\n        )+\n    }\n}\n\n// Constructs an expression that performs a lexical ordering using method $rel.\n// The values are interleaved, so the macro invocation for\n// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_ord!(lt, a1, b1, a2, b2,\n// a3, b3)` (and similarly for `lexical_cmp`)\nmacro_rules! lexical_ord {\n    ($rel: ident, $a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n        if $a != $b { lexical_ord!($rel, $a, $b) }\n        else { lexical_ord!($rel, $($rest_a, $rest_b),+) }\n    };\n    ($rel: ident, $a:expr, $b:expr) => { ($a) . $rel (& $b) };\n}\n\nmacro_rules! lexical_partial_cmp {\n    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n        match ($a).partial_cmp(&$b) {\n            Some(Equal) => lexical_partial_cmp!($($rest_a, $rest_b),+),\n            ordering   => ordering\n        }\n    };\n    ($a:expr, $b:expr) => { ($a).partial_cmp(&$b) };\n}\n\nmacro_rules! lexical_cmp {\n    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n        match ($a).cmp(&$b) {\n            Equal => lexical_cmp!($($rest_a, $rest_b),+),\n            ordering   => ordering\n        }\n    };\n    ($a:expr, $b:expr) => { ($a).cmp(&$b) };\n}\n\nmacro_rules! last_type {\n    ($a:ident,) => { $a };\n    ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n}\n\ntuple_impls! {\n    Tuple1 {\n        (0) -> A\n    }\n    Tuple2 {\n        (0) -> A\n        (1) -> B\n    }\n    Tuple3 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n    }\n    Tuple4 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n    }\n    Tuple5 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n    }\n    Tuple6 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n    }\n    Tuple7 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n    }\n    Tuple8 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n    }\n    Tuple9 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n        (8) -> I\n    }\n    Tuple10 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n        (8) -> I\n        (9) -> J\n    }\n    Tuple11 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n        (8) -> I\n        (9) -> J\n        (10) -> K\n    }\n    Tuple12 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n        (8) -> I\n        (9) -> J\n        (10) -> K\n        (11) -> L\n    }\n}\n"],[2844,"use super::{From, TryFrom};\nuse crate::num::TryFromIntError;\n\nmod private {\n    /// This trait being unreachable from outside the crate\n    /// prevents other implementations of the `FloatToInt` trait,\n    /// which allows potentially adding more trait methods after the trait is `#[stable]`.\n    #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n    pub trait Sealed {}\n}\n\n/// Supporting trait for inherent methods of `f32` and `f64` such as `to_int_unchecked`.\n/// Typically doesn’t need to be used directly.\n#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\npub trait FloatToInt<Int>: private::Sealed + Sized {\n    #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n    #[doc(hidden)]\n    unsafe fn to_int_unchecked(self) -> Int;\n}\n\nmacro_rules! impl_float_to_int {\n    ( $Float: ident => $( $Int: ident )+ ) => {\n        #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n        impl private::Sealed for $Float {}\n        $(\n            #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n            impl FloatToInt<$Int> for $Float {\n                #[doc(hidden)]\n                #[inline]\n                unsafe fn to_int_unchecked(self) -> $Int {\n                    // SAFETY: the safety contract must be upheld by the caller.\n                    unsafe { crate::intrinsics::float_to_int_unchecked(self) }\n                }\n            }\n        )+\n    }\n}\n\nimpl_float_to_int!(f32 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\nimpl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n\n// Conversion traits for primitive integer and float types\n// Conversions T -> T are covered by a blanket impl and therefore excluded\n// Some conversions from and to usize/isize are not implemented due to portability concerns\nmacro_rules! impl_from {\n    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n        #[$attr]\n        impl From<$Small> for $Large {\n            // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n            // Rustdocs on functions do not.\n            #[doc = $doc]\n            #[inline]\n            fn from(small: $Small) -> Self {\n                small as Self\n            }\n        }\n    };\n    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n        impl_from!($Small,\n                   $Large,\n                   #[$attr],\n                   concat!(\"Converts `\",\n                           stringify!($Small),\n                           \"` to `\",\n                           stringify!($Large),\n                           \"` losslessly.\"));\n    }\n}\n\nmacro_rules! impl_from_bool {\n    ($target: ty, #[$attr:meta]) => {\n        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\nvalues.\n\n# Examples\n\n```\nassert_eq!(\", stringify!($target), \"::from(true), 1);\nassert_eq!(\", stringify!($target), \"::from(false), 0);\n```\"));\n    };\n}\n\n// Bool -> Any\nimpl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n\n// Unsigned -> Unsigned\nimpl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n\n// Signed -> Signed\nimpl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n\n// Unsigned -> Signed\nimpl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n\n// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n// which imply that pointer-sized integers must be at least 16 bits:\n// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\nimpl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\nimpl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\nimpl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n\n// RISC-V defines the possibility of a 128-bit address space (RV128).\n\n// CHERI proposes 256-bit “capabilities”. Unclear if this would be relevant to usize/isize.\n// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n// https://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n\n// Note: integers can only be represented with full precision in a float if\n// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n// Lossy float conversions are not implemented at this time.\n\n// Signed -> Float\nimpl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// Unsigned -> Float\nimpl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// Float -> Float\nimpl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// no possible bounds violation\nmacro_rules! try_from_unbounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            /// Try to create the target number type from a source\n            /// number type. This returns an error if the source value\n            /// is outside of the range of the target type.\n            #[inline]\n            fn try_from(value: $source) -> Result<Self, Self::Error> {\n                Ok(value as Self)\n            }\n        }\n    )*}\n}\n\n// only negative bounds\nmacro_rules! try_from_lower_bounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            /// Try to create the target number type from a source\n            /// number type. This returns an error if the source value\n            /// is outside of the range of the target type.\n            #[inline]\n            fn try_from(u: $source) -> Result<Self, Self::Error> {\n                if u >= 0 {\n                    Ok(u as Self)\n                } else {\n                    Err(TryFromIntError(()))\n                }\n            }\n        }\n    )*}\n}\n\n// unsigned to signed (only positive bound)\nmacro_rules! try_from_upper_bounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            /// Try to create the target number type from a source\n            /// number type. This returns an error if the source value\n            /// is outside of the range of the target type.\n            #[inline]\n            fn try_from(u: $source) -> Result<Self, Self::Error> {\n                if u > (Self::MAX as $source) {\n                    Err(TryFromIntError(()))\n                } else {\n                    Ok(u as Self)\n                }\n            }\n        }\n    )*}\n}\n\n// all other cases\nmacro_rules! try_from_both_bounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            /// Try to create the target number type from a source\n            /// number type. This returns an error if the source value\n            /// is outside of the range of the target type.\n            #[inline]\n            fn try_from(u: $source) -> Result<Self, Self::Error> {\n                let min = Self::MIN as $source;\n                let max = Self::MAX as $source;\n                if u < min || u > max {\n                    Err(TryFromIntError(()))\n                } else {\n                    Ok(u as Self)\n                }\n            }\n        }\n    )*}\n}\n\nmacro_rules! rev {\n    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n        $mac!($target, $source);\n    )*}\n}\n\n// intra-sign conversions\ntry_from_upper_bounded!(u16, u8);\ntry_from_upper_bounded!(u32, u16, u8);\ntry_from_upper_bounded!(u64, u32, u16, u8);\ntry_from_upper_bounded!(u128, u64, u32, u16, u8);\n\ntry_from_both_bounded!(i16, i8);\ntry_from_both_bounded!(i32, i16, i8);\ntry_from_both_bounded!(i64, i32, i16, i8);\ntry_from_both_bounded!(i128, i64, i32, i16, i8);\n\n// unsigned-to-signed\ntry_from_upper_bounded!(u8, i8);\ntry_from_upper_bounded!(u16, i8, i16);\ntry_from_upper_bounded!(u32, i8, i16, i32);\ntry_from_upper_bounded!(u64, i8, i16, i32, i64);\ntry_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n\n// signed-to-unsigned\ntry_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\ntry_from_lower_bounded!(i16, u16, u32, u64, u128);\ntry_from_lower_bounded!(i32, u32, u64, u128);\ntry_from_lower_bounded!(i64, u64, u128);\ntry_from_lower_bounded!(i128, u128);\ntry_from_both_bounded!(i16, u8);\ntry_from_both_bounded!(i32, u16, u8);\ntry_from_both_bounded!(i64, u32, u16, u8);\ntry_from_both_bounded!(i128, u64, u32, u16, u8);\n\n// usize/isize\ntry_from_upper_bounded!(usize, isize);\ntry_from_lower_bounded!(isize, usize);\n\n#[cfg(target_pointer_width = \"16\")]\nmod ptr_try_from_impls {\n    use super::TryFromIntError;\n    use crate::convert::TryFrom;\n\n    try_from_upper_bounded!(usize, u8);\n    try_from_unbounded!(usize, u16, u32, u64, u128);\n    try_from_upper_bounded!(usize, i8, i16);\n    try_from_unbounded!(usize, i32, i64, i128);\n\n    try_from_both_bounded!(isize, u8);\n    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n    try_from_both_bounded!(isize, i8);\n    try_from_unbounded!(isize, i16, i32, i64, i128);\n\n    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n    rev!(try_from_lower_bounded, usize, i8, i16);\n    rev!(try_from_both_bounded, usize, i32, i64, i128);\n\n    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n    rev!(try_from_both_bounded, isize, i32, i64, i128);\n}\n\n#[cfg(target_pointer_width = \"32\")]\nmod ptr_try_from_impls {\n    use super::TryFromIntError;\n    use crate::convert::TryFrom;\n\n    try_from_upper_bounded!(usize, u8, u16);\n    try_from_unbounded!(usize, u32, u64, u128);\n    try_from_upper_bounded!(usize, i8, i16, i32);\n    try_from_unbounded!(usize, i64, i128);\n\n    try_from_both_bounded!(isize, u8, u16);\n    try_from_lower_bounded!(isize, u32, u64, u128);\n    try_from_both_bounded!(isize, i8, i16);\n    try_from_unbounded!(isize, i32, i64, i128);\n\n    rev!(try_from_unbounded, usize, u32);\n    rev!(try_from_upper_bounded, usize, u64, u128);\n    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n    rev!(try_from_both_bounded, usize, i64, i128);\n\n    rev!(try_from_unbounded, isize, u16);\n    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n    rev!(try_from_unbounded, isize, i32);\n    rev!(try_from_both_bounded, isize, i64, i128);\n}\n\n#[cfg(target_pointer_width = \"64\")]\nmod ptr_try_from_impls {\n    use super::TryFromIntError;\n    use crate::convert::TryFrom;\n\n    try_from_upper_bounded!(usize, u8, u16, u32);\n    try_from_unbounded!(usize, u64, u128);\n    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n    try_from_unbounded!(usize, i128);\n\n    try_from_both_bounded!(isize, u8, u16, u32);\n    try_from_lower_bounded!(isize, u64, u128);\n    try_from_both_bounded!(isize, i8, i16, i32);\n    try_from_unbounded!(isize, i64, i128);\n\n    rev!(try_from_unbounded, usize, u32, u64);\n    rev!(try_from_upper_bounded, usize, u128);\n    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n    rev!(try_from_both_bounded, usize, i128);\n\n    rev!(try_from_unbounded, isize, u16, u32);\n    rev!(try_from_upper_bounded, isize, u64, u128);\n    rev!(try_from_unbounded, isize, i32, i64);\n    rev!(try_from_both_bounded, isize, i128);\n}\n\n// Conversion traits for non-zero integer types\nuse crate::num::NonZeroI128;\nuse crate::num::NonZeroI16;\nuse crate::num::NonZeroI32;\nuse crate::num::NonZeroI64;\nuse crate::num::NonZeroI8;\nuse crate::num::NonZeroIsize;\nuse crate::num::NonZeroU128;\nuse crate::num::NonZeroU16;\nuse crate::num::NonZeroU32;\nuse crate::num::NonZeroU64;\nuse crate::num::NonZeroU8;\nuse crate::num::NonZeroUsize;\n\nmacro_rules! nzint_impl_from {\n    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n        #[$attr]\n        impl From<$Small> for $Large {\n            // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n            // Rustdocs on functions do not.\n            #[doc = $doc]\n            #[inline]\n            fn from(small: $Small) -> Self {\n                // SAFETY: input type guarantees the value is non-zero\n                unsafe {\n                    Self::new_unchecked(small.get().into())\n                }\n            }\n        }\n    };\n    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n        nzint_impl_from!($Small,\n                   $Large,\n                   #[$attr],\n                   concat!(\"Converts `\",\n                           stringify!($Small),\n                           \"` to `\",\n                           stringify!($Large),\n                           \"` losslessly.\"));\n    }\n}\n\n// Non-zero Unsigned -> Non-zero Unsigned\nnzint_impl_from! { NonZeroU8, NonZeroU16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroU32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroUsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroU32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroUsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU32, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU32, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU64, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n\n// Non-zero Signed -> Non-zero Signed\nnzint_impl_from! { NonZeroI8, NonZeroI16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI8, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI8, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI8, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI8, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI16, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI16, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI16, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI16, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI32, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI32, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI64, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n\n// NonZero UnSigned -> Non-zero Signed\nnzint_impl_from! { NonZeroU8, NonZeroI16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU32, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU32, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU64, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n\nmacro_rules! nzint_impl_try_from_int {\n    ($Int: ty, $NonZeroInt: ty, #[$attr:meta], $doc: expr) => {\n        #[$attr]\n        impl TryFrom<$Int> for $NonZeroInt {\n            type Error = TryFromIntError;\n\n            // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n            // Rustdocs on functions do not.\n            #[doc = $doc]\n            #[inline]\n            fn try_from(value: $Int) -> Result<Self, Self::Error> {\n                Self::new(value).ok_or(TryFromIntError(()))\n            }\n        }\n    };\n    ($Int: ty, $NonZeroInt: ty, #[$attr:meta]) => {\n        nzint_impl_try_from_int!($Int,\n                                 $NonZeroInt,\n                                 #[$attr],\n                                 concat!(\"Attempts to convert `\",\n                                         stringify!($Int),\n                                         \"` to `\",\n                                         stringify!($NonZeroInt),\n                                         \"`.\"));\n    }\n}\n\n// Int -> Non-zero Int\nnzint_impl_try_from_int! { u8, NonZeroU8, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { u16, NonZeroU16, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { u32, NonZeroU32, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { u64, NonZeroU64, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { u128, NonZeroU128, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { usize, NonZeroUsize, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { i8, NonZeroI8, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { i16, NonZeroI16, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { i32, NonZeroI32, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { i64, NonZeroI64, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { i128, NonZeroI128, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\nnzint_impl_try_from_int! { isize, NonZeroIsize, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\n\nmacro_rules! nzint_impl_try_from_nzint {\n    ($From:ty => $To:ty, $doc: expr) => {\n        #[stable(feature = \"nzint_try_from_nzint_conv\", since = \"1.49.0\")]\n        impl TryFrom<$From> for $To {\n            type Error = TryFromIntError;\n\n            // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n            // Rustdocs on functions do not.\n            #[doc = $doc]\n            #[inline]\n            fn try_from(value: $From) -> Result<Self, Self::Error> {\n                TryFrom::try_from(value.get()).map(|v| {\n                    // SAFETY: $From is a NonZero type, so v is not zero.\n                    unsafe { Self::new_unchecked(v) }\n                })\n            }\n        }\n    };\n    ($To:ty: $($From: ty),*) => {$(\n        nzint_impl_try_from_nzint!(\n            $From => $To,\n            concat!(\n                \"Attempts to convert `\",\n                stringify!($From),\n                \"` to `\",\n                stringify!($To),\n                \"`.\",\n            )\n        );\n    )*};\n}\n\n// Non-zero int -> non-zero unsigned int\nnzint_impl_try_from_nzint! { NonZeroU8: NonZeroI8, NonZeroU16, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroU16: NonZeroI8, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroU32: NonZeroI8, NonZeroI16, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroU64: NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroU128: NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroUsize: NonZeroI8, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroIsize }\n\n// Non-zero int -> non-zero signed int\nnzint_impl_try_from_nzint! { NonZeroI8: NonZeroU8, NonZeroU16, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroI16: NonZeroU16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroI32: NonZeroU32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroI64: NonZeroU64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroI128: NonZeroU128, NonZeroUsize, NonZeroIsize }\nnzint_impl_try_from_nzint! { NonZeroIsize: NonZeroU16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize }\n"],[2845,"//! Traits for conversions between types.\n//!\n//! The traits in this module provide a way to convert from one type to another type.\n//! Each trait serves a different purpose:\n//!\n//! - Implement the [`AsRef`] trait for cheap reference-to-reference conversions\n//! - Implement the [`AsMut`] trait for cheap mutable-to-mutable conversions\n//! - Implement the [`From`] trait for consuming value-to-value conversions\n//! - Implement the [`Into`] trait for consuming value-to-value conversions to types\n//!   outside the current crate\n//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`],\n//!   but should be implemented when the conversion can fail.\n//!\n//! The traits in this module are often used as trait bounds for generic functions such that to\n//! arguments of multiple types are supported. See the documentation of each trait for examples.\n//!\n//! As a library author, you should always prefer implementing [`From<T>`][`From`] or\n//! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n//! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n//! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n//! blanket implementation in the standard library. When targeting a version prior to Rust 1.41, it\n//! may be necessary to implement [`Into`] or [`TryInto`] directly when converting to a type\n//! outside the current crate.\n//!\n//! # Generic Implementations\n//!\n//! - [`AsRef`] and [`AsMut`] auto-dereference if the inner type is a reference\n//! - [`From`]`<U> for T` implies [`Into`]`<T> for U`\n//! - [`TryFrom`]`<U> for T` implies [`TryInto`]`<T> for U`\n//! - [`From`] and [`Into`] are reflexive, which means that all types can\n//!   `into` themselves and `from` themselves\n//!\n//! See each trait for usage examples.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\n\nmod num;\n\n#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\npub use num::FloatToInt;\n\n/// The identity function.\n///\n/// Two things are important to note about this function:\n///\n/// - It is not always equivalent to a closure like `|x| x`, since the\n///   closure may coerce `x` into a different type.\n///\n/// - It moves the input `x` passed to the function.\n///\n/// While it might seem strange to have a function that just returns back the\n/// input, there are some interesting uses.\n///\n/// # Examples\n///\n/// Using `identity` to do nothing in a sequence of other, interesting,\n/// functions:\n///\n/// ```rust\n/// use std::convert::identity;\n///\n/// fn manipulation(x: u32) -> u32 {\n///     // Let's pretend that adding one is an interesting function.\n///     x + 1\n/// }\n///\n/// let _arr = &[identity, manipulation];\n/// ```\n///\n/// Using `identity` as a \"do nothing\" base case in a conditional:\n///\n/// ```rust\n/// use std::convert::identity;\n///\n/// # let condition = true;\n/// #\n/// # fn manipulation(x: u32) -> u32 { x + 1 }\n/// #\n/// let do_stuff = if condition { manipulation } else { identity };\n///\n/// // Do more interesting stuff...\n///\n/// let _results = do_stuff(42);\n/// ```\n///\n/// Using `identity` to keep the `Some` variants of an iterator of `Option<T>`:\n///\n/// ```rust\n/// use std::convert::identity;\n///\n/// let iter = vec![Some(1), None, Some(3)].into_iter();\n/// let filtered = iter.filter_map(identity).collect::<Vec<_>>();\n/// assert_eq!(vec![1, 3], filtered);\n/// ```\n#[stable(feature = \"convert_id\", since = \"1.33.0\")]\n#[rustc_const_stable(feature = \"const_identity\", since = \"1.33.0\")]\n#[inline]\npub const fn identity<T>(x: T) -> T {\n    x\n}\n\n/// Used to do a cheap reference-to-reference conversion.\n///\n/// This trait is similar to [`AsMut`] which is used for converting between mutable references.\n/// If you need to do a costly conversion it is better to implement [`From`] with type\n/// `&T` or write a custom function.\n///\n/// `AsRef` has the same signature as [`Borrow`], but [`Borrow`] is different in few aspects:\n///\n/// - Unlike `AsRef`, [`Borrow`] has a blanket impl for any `T`, and can be used to accept either\n///   a reference or a value.\n/// - [`Borrow`] also requires that [`Hash`], [`Eq`] and [`Ord`] for borrowed value are\n///   equivalent to those of the owned value. For this reason, if you want to\n///   borrow only a single field of a struct you can implement `AsRef`, but not [`Borrow`].\n///\n/// **Note: This trait must not fail**. If the conversion can fail, use a\n/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n///\n/// # Generic Implementations\n///\n/// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n///   `&mut Foo` or `&&mut Foo`)\n///\n/// # Examples\n///\n/// By using trait bounds we can accept arguments of different types as long as they can be\n/// converted to the specified type `T`.\n///\n/// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n/// want to accept all references that can be converted to [`&str`] as an argument.\n/// Since both [`String`] and [`&str`] implement `AsRef<str>` we can accept both as input argument.\n///\n/// [`&str`]: primitive@str\n/// [`Borrow`]: crate::borrow::Borrow\n/// [`Eq`]: crate::cmp::Eq\n/// [`Ord`]: crate::cmp::Ord\n/// [`String`]: ../../std/string/struct.String.html\n///\n/// ```\n/// fn is_hello<T: AsRef<str>>(s: T) {\n///    assert_eq!(\"hello\", s.as_ref());\n/// }\n///\n/// let s = \"hello\";\n/// is_hello(s);\n///\n/// let s = \"hello\".to_string();\n/// is_hello(s);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait AsRef<T: ?Sized> {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn as_ref(&self) -> &T;\n}\n\n/// Used to do a cheap mutable-to-mutable reference conversion.\n///\n/// This trait is similar to [`AsRef`] but used for converting between mutable\n/// references. If you need to do a costly conversion it is better to\n/// implement [`From`] with type `&mut T` or write a custom function.\n///\n/// **Note: This trait must not fail**. If the conversion can fail, use a\n/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n///\n/// # Generic Implementations\n///\n/// - `AsMut` auto-dereferences if the inner type is a mutable reference\n///   (e.g.: `foo.as_mut()` will work the same if `foo` has type `&mut Foo`\n///   or `&mut &mut Foo`)\n///\n/// # Examples\n///\n/// Using `AsMut` as trait bound for a generic function we can accept all mutable references\n/// that can be converted to type `&mut T`. Because [`Box<T>`] implements `AsMut<T>` we can\n/// write a function `add_one` that takes all arguments that can be converted to `&mut u64`.\n/// Because [`Box<T>`] implements `AsMut<T>`, `add_one` accepts arguments of type\n/// `&mut Box<u64>` as well:\n///\n/// ```\n/// fn add_one<T: AsMut<u64>>(num: &mut T) {\n///     *num.as_mut() += 1;\n/// }\n///\n/// let mut boxed_num = Box::new(0);\n/// add_one(&mut boxed_num);\n/// assert_eq!(*boxed_num, 1);\n/// ```\n///\n/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait AsMut<T: ?Sized> {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn as_mut(&mut self) -> &mut T;\n}\n\n/// A value-to-value conversion that consumes the input value. The\n/// opposite of [`From`].\n///\n/// One should avoid implementing [`Into`] and implement [`From`] instead.\n/// Implementing [`From`] automatically provides one with an implementation of [`Into`]\n/// thanks to the blanket implementation in the standard library.\n///\n/// Prefer using [`Into`] over [`From`] when specifying trait bounds on a generic function\n/// to ensure that types that only implement [`Into`] can be used as well.\n///\n/// **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n///\n/// # Generic Implementations\n///\n/// - [`From`]`<T> for U` implies `Into<U> for T`\n/// - [`Into`] is reflexive, which means that `Into<T> for T` is implemented\n///\n/// # Implementing [`Into`] for conversions to external types in old versions of Rust\n///\n/// Prior to Rust 1.41, if the destination type was not part of the current crate\n/// then you couldn't implement [`From`] directly.\n/// For example, take this code:\n///\n/// ```\n/// struct Wrapper<T>(Vec<T>);\n/// impl<T> From<Wrapper<T>> for Vec<T> {\n///     fn from(w: Wrapper<T>) -> Vec<T> {\n///         w.0\n///     }\n/// }\n/// ```\n/// This will fail to compile in older versions of the language because Rust's orphaning rules\n/// used to be a little bit more strict. To bypass this, you could implement [`Into`] directly:\n///\n/// ```\n/// struct Wrapper<T>(Vec<T>);\n/// impl<T> Into<Vec<T>> for Wrapper<T> {\n///     fn into(self) -> Vec<T> {\n///         self.0\n///     }\n/// }\n/// ```\n///\n/// It is important to understand that [`Into`] does not provide a [`From`] implementation\n/// (as [`From`] does with [`Into`]). Therefore, you should always try to implement [`From`]\n/// and then fall back to [`Into`] if [`From`] can't be implemented.\n///\n/// # Examples\n///\n/// [`String`] implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>`:\n///\n/// In order to express that we want a generic function to take all arguments that can be\n/// converted to a specified type `T`, we can use a trait bound of [`Into`]`<T>`.\n/// For example: The function `is_hello` takes all arguments that can be converted into a\n/// [`Vec`]`<`[`u8`]`>`.\n///\n/// ```\n/// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n///    let bytes = b\"hello\".to_vec();\n///    assert_eq!(bytes, s.into());\n/// }\n///\n/// let s = \"hello\".to_string();\n/// is_hello(s);\n/// ```\n///\n/// [`String`]: ../../std/string/struct.String.html\n/// [`Vec`]: ../../std/vec/struct.Vec.html\n#[rustc_diagnostic_item = \"into_trait\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Into<T>: Sized {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn into(self) -> T;\n}\n\n/// Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n/// [`Into`].\n///\n/// One should always prefer implementing `From` over [`Into`]\n/// because implementing `From` automatically provides one with an implementation of [`Into`]\n/// thanks to the blanket implementation in the standard library.\n///\n/// Only implement [`Into`] when targeting a version prior to Rust 1.41 and converting to a type\n/// outside the current crate.\n/// `From` was not able to do these types of conversions in earlier versions because of Rust's\n/// orphaning rules.\n/// See [`Into`] for more details.\n///\n/// Prefer using [`Into`] over using `From` when specifying trait bounds on a generic function.\n/// This way, types that directly implement [`Into`] can be used as arguments as well.\n///\n/// The `From` is also very useful when performing error handling. When constructing a function\n/// that is capable of failing, the return type will generally be of the form `Result<T, E>`.\n/// The `From` trait simplifies error handling by allowing a function to return a single error type\n/// that encapsulate multiple error types. See the \"Examples\" section and [the book][book] for more\n/// details.\n///\n/// **Note: This trait must not fail**. If the conversion can fail, use [`TryFrom`].\n///\n/// # Generic Implementations\n///\n/// - `From<T> for U` implies [`Into`]`<U> for T`\n/// - `From` is reflexive, which means that `From<T> for T` is implemented\n///\n/// # Examples\n///\n/// [`String`] implements `From<&str>`:\n///\n/// An explicit conversion from a `&str` to a String is done as follows:\n///\n/// ```\n/// let string = \"hello\".to_string();\n/// let other_string = String::from(\"hello\");\n///\n/// assert_eq!(string, other_string);\n/// ```\n///\n/// While performing error handling it is often useful to implement `From` for your own error type.\n/// By converting underlying error types to our own custom error type that encapsulates the\n/// underlying error type, we can return a single error type without losing information on the\n/// underlying cause. The '?' operator automatically converts the underlying error type to our\n/// custom error type by calling `Into<CliError>::into` which is automatically provided when\n/// implementing `From`. The compiler then infers which implementation of `Into` should be used.\n///\n/// ```\n/// use std::fs;\n/// use std::io;\n/// use std::num;\n///\n/// enum CliError {\n///     IoError(io::Error),\n///     ParseError(num::ParseIntError),\n/// }\n///\n/// impl From<io::Error> for CliError {\n///     fn from(error: io::Error) -> Self {\n///         CliError::IoError(error)\n///     }\n/// }\n///\n/// impl From<num::ParseIntError> for CliError {\n///     fn from(error: num::ParseIntError) -> Self {\n///         CliError::ParseError(error)\n///     }\n/// }\n///\n/// fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {\n///     let mut contents = fs::read_to_string(&file_name)?;\n///     let num: i32 = contents.trim().parse()?;\n///     Ok(num)\n/// }\n/// ```\n///\n/// [`String`]: ../../std/string/struct.String.html\n/// [`from`]: From::from\n/// [book]: ../../book/ch09-00-error-handling.html\n#[rustc_diagnostic_item = \"from_trait\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(on(\n    all(_Self = \"&str\", T = \"std::string::String\"),\n    note = \"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n))]\npub trait From<T>: Sized {\n    /// Performs the conversion.\n    #[lang = \"from\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn from(_: T) -> Self;\n}\n\n/// An attempted conversion that consumes `self`, which may or may not be\n/// expensive.\n///\n/// Library authors should usually not directly implement this trait,\n/// but should prefer implementing the [`TryFrom`] trait, which offers\n/// greater flexibility and provides an equivalent `TryInto`\n/// implementation for free, thanks to a blanket implementation in the\n/// standard library. For more information on this, see the\n/// documentation for [`Into`].\n///\n/// # Implementing `TryInto`\n///\n/// This suffers the same restrictions and reasoning as implementing\n/// [`Into`], see there for details.\n#[rustc_diagnostic_item = \"try_into_trait\"]\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\npub trait TryInto<T>: Sized {\n    /// The type returned in the event of a conversion error.\n    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n    type Error;\n\n    /// Performs the conversion.\n    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n    fn try_into(self) -> Result<T, Self::Error>;\n}\n\n/// Simple and safe type conversions that may fail in a controlled\n/// way under some circumstances. It is the reciprocal of [`TryInto`].\n///\n/// This is useful when you are doing a type conversion that may\n/// trivially succeed but may also need special handling.\n/// For example, there is no way to convert an [`i64`] into an [`i32`]\n/// using the [`From`] trait, because an [`i64`] may contain a value\n/// that an [`i32`] cannot represent and so the conversion would lose data.\n/// This might be handled by truncating the [`i64`] to an [`i32`] (essentially\n/// giving the [`i64`]'s value modulo [`i32::MAX`]) or by simply returning\n/// [`i32::MAX`], or by some other method.  The [`From`] trait is intended\n/// for perfect conversions, so the `TryFrom` trait informs the\n/// programmer when a type conversion could go bad and lets them\n/// decide how to handle it.\n///\n/// # Generic Implementations\n///\n/// - `TryFrom<T> for U` implies [`TryInto`]`<U> for T`\n/// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n/// is implemented and cannot fail -- the associated `Error` type for\n/// calling `T::try_from()` on a value of type `T` is [`Infallible`].\n/// When the [`!`] type is stabilized [`Infallible`] and [`!`] will be\n/// equivalent.\n///\n/// `TryFrom<T>` can be implemented as follows:\n///\n/// ```\n/// use std::convert::TryFrom;\n///\n/// struct GreaterThanZero(i32);\n///\n/// impl TryFrom<i32> for GreaterThanZero {\n///     type Error = &'static str;\n///\n///     fn try_from(value: i32) -> Result<Self, Self::Error> {\n///         if value <= 0 {\n///             Err(\"GreaterThanZero only accepts value superior than zero!\")\n///         } else {\n///             Ok(GreaterThanZero(value))\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Examples\n///\n/// As described, [`i32`] implements `TryFrom<`[`i64`]`>`:\n///\n/// ```\n/// use std::convert::TryFrom;\n///\n/// let big_number = 1_000_000_000_000i64;\n/// // Silently truncates `big_number`, requires detecting\n/// // and handling the truncation after the fact.\n/// let smaller_number = big_number as i32;\n/// assert_eq!(smaller_number, -727379968);\n///\n/// // Returns an error because `big_number` is too big to\n/// // fit in an `i32`.\n/// let try_smaller_number = i32::try_from(big_number);\n/// assert!(try_smaller_number.is_err());\n///\n/// // Returns `Ok(3)`.\n/// let try_successful_smaller_number = i32::try_from(3);\n/// assert!(try_successful_smaller_number.is_ok());\n/// ```\n///\n/// [`try_from`]: TryFrom::try_from\n#[rustc_diagnostic_item = \"try_from_trait\"]\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\npub trait TryFrom<T>: Sized {\n    /// The type returned in the event of a conversion error.\n    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n    type Error;\n\n    /// Performs the conversion.\n    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n    fn try_from(value: T) -> Result<Self, Self::Error>;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// GENERIC IMPLS\n////////////////////////////////////////////////////////////////////////////////\n\n// As lifts over &\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized, U: ?Sized> AsRef<U> for &T\nwhere\n    T: AsRef<U>,\n{\n    fn as_ref(&self) -> &U {\n        <T as AsRef<U>>::as_ref(*self)\n    }\n}\n\n// As lifts over &mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T\nwhere\n    T: AsRef<U>,\n{\n    fn as_ref(&self) -> &U {\n        <T as AsRef<U>>::as_ref(*self)\n    }\n}\n\n// FIXME (#45742): replace the above impls for &/&mut with the following more general one:\n// // As lifts over Deref\n// impl<D: ?Sized + Deref<Target: AsRef<U>>, U: ?Sized> AsRef<U> for D {\n//     fn as_ref(&self) -> &U {\n//         self.deref().as_ref()\n//     }\n// }\n\n// AsMut lifts over &mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T\nwhere\n    T: AsMut<U>,\n{\n    fn as_mut(&mut self) -> &mut U {\n        (*self).as_mut()\n    }\n}\n\n// FIXME (#45742): replace the above impl for &mut with the following more general one:\n// // AsMut lifts over DerefMut\n// impl<D: ?Sized + Deref<Target: AsMut<U>>, U: ?Sized> AsMut<U> for D {\n//     fn as_mut(&mut self) -> &mut U {\n//         self.deref_mut().as_mut()\n//     }\n// }\n\n// From implies Into\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, U> Into<U> for T\nwhere\n    U: From<T>,\n{\n    fn into(self) -> U {\n        U::from(self)\n    }\n}\n\n// From (and thus Into) is reflexive\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> From<T> for T {\n    fn from(t: T) -> T {\n        t\n    }\n}\n\n/// **Stability note:** This impl does not yet exist, but we are\n/// \"reserving space\" to add it in the future. See\n/// [rust-lang/rust#64715][#64715] for details.\n///\n/// [#64715]: https://github.com/rust-lang/rust/issues/64715\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n#[allow(unused_attributes)] // FIXME(#58633): do a principled fix instead.\n#[rustc_reservation_impl = \"permitting this impl would forbid us from adding \\\n                            `impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\nimpl<T> From<!> for T {\n    fn from(t: !) -> T {\n        t\n    }\n}\n\n// TryFrom implies TryInto\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<T, U> TryInto<U> for T\nwhere\n    U: TryFrom<T>,\n{\n    type Error = U::Error;\n\n    fn try_into(self) -> Result<U, U::Error> {\n        U::try_from(self)\n    }\n}\n\n// Infallible conversions are semantically equivalent to fallible conversions\n// with an uninhabited error type.\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<T, U> TryFrom<U> for T\nwhere\n    U: Into<T>,\n{\n    type Error = Infallible;\n\n    fn try_from(value: U) -> Result<Self, Self::Error> {\n        Ok(U::into(value))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// CONCRETE IMPLS\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<[T]> for [T] {\n    fn as_ref(&self) -> &[T] {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsMut<[T]> for [T] {\n    fn as_mut(&mut self) -> &mut [T] {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<str> for str {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self\n    }\n}\n\n#[stable(feature = \"as_mut_str_for_str\", since = \"1.51.0\")]\nimpl AsMut<str> for str {\n    #[inline]\n    fn as_mut(&mut self) -> &mut str {\n        self\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// THE NO-ERROR ERROR TYPE\n////////////////////////////////////////////////////////////////////////////////\n\n/// The error type for errors that can never happen.\n///\n/// Since this enum has no variant, a value of this type can never actually exist.\n/// This can be useful for generic APIs that use [`Result`] and parameterize the error type,\n/// to indicate that the result is always [`Ok`].\n///\n/// For example, the [`TryFrom`] trait (conversion that returns a [`Result`])\n/// has a blanket implementation for all types where a reverse [`Into`] implementation exists.\n///\n/// ```ignore (illustrates std code, duplicating the impl in a doctest would be an error)\n/// impl<T, U> TryFrom<U> for T where U: Into<T> {\n///     type Error = Infallible;\n///\n///     fn try_from(value: U) -> Result<Self, Infallible> {\n///         Ok(U::into(value))  // Never returns `Err`\n///     }\n/// }\n/// ```\n///\n/// # Future compatibility\n///\n/// This enum has the same role as [the `!` “never” type][never],\n/// which is unstable in this version of Rust.\n/// When `!` is stabilized, we plan to make `Infallible` a type alias to it:\n///\n/// ```ignore (illustrates future std change)\n/// pub type Infallible = !;\n/// ```\n///\n/// … and eventually deprecate `Infallible`.\n///\n/// However there is one case where `!` syntax can be used\n/// before `!` is stabilized as a full-fledged type: in the position of a function’s return type.\n/// Specifically, it is possible implementations for two different function pointer types:\n///\n/// ```\n/// trait MyTrait {}\n/// impl MyTrait for fn() -> ! {}\n/// impl MyTrait for fn() -> std::convert::Infallible {}\n/// ```\n///\n/// With `Infallible` being an enum, this code is valid.\n/// However when `Infallible` becomes an alias for the never type,\n/// the two `impl`s will start to overlap\n/// and therefore will be disallowed by the language’s trait coherence rules.\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n#[derive(Copy)]\npub enum Infallible {}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl Clone for Infallible {\n    fn clone(&self) -> Infallible {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl fmt::Debug for Infallible {\n    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl fmt::Display for Infallible {\n    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl PartialEq for Infallible {\n    fn eq(&self, _: &Infallible) -> bool {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl Eq for Infallible {}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl PartialOrd for Infallible {\n    fn partial_cmp(&self, _other: &Self) -> Option<crate::cmp::Ordering> {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl Ord for Infallible {\n    fn cmp(&self, _other: &Self) -> crate::cmp::Ordering {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl From<!> for Infallible {\n    fn from(x: !) -> Self {\n        x\n    }\n}\n\n#[stable(feature = \"convert_infallible_hash\", since = \"1.44.0\")]\nimpl Hash for Infallible {\n    fn hash<H: Hasher>(&self, _: &mut H) {\n        match *self {}\n    }\n}\n"],[2846,"//! Lazy values and one-time initialization of static data.\n\nuse crate::cell::{Cell, UnsafeCell};\nuse crate::fmt;\nuse crate::mem;\nuse crate::ops::Deref;\n\n/// A cell which can be written to only once.\n///\n/// Unlike `RefCell`, a `OnceCell` only provides shared `&T` references to its value.\n/// Unlike `Cell`, a `OnceCell` doesn't require copying or replacing the value to access it.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(once_cell)]\n///\n/// use std::lazy::OnceCell;\n///\n/// let cell = OnceCell::new();\n/// assert!(cell.get().is_none());\n///\n/// let value: &String = cell.get_or_init(|| {\n///     \"Hello, World!\".to_string()\n/// });\n/// assert_eq!(value, \"Hello, World!\");\n/// assert!(cell.get().is_some());\n/// ```\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\npub struct OnceCell<T> {\n    // Invariant: written to at most once.\n    inner: UnsafeCell<Option<T>>,\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T> Default for OnceCell<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.get() {\n            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n            None => f.write_str(\"OnceCell(Uninit)\"),\n        }\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: Clone> Clone for OnceCell<T> {\n    fn clone(&self) -> OnceCell<T> {\n        let res = OnceCell::new();\n        if let Some(value) = self.get() {\n            match res.set(value.clone()) {\n                Ok(()) => (),\n                Err(_) => unreachable!(),\n            }\n        }\n        res\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: PartialEq> PartialEq for OnceCell<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.get() == other.get()\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: Eq> Eq for OnceCell<T> {}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T> From<T> for OnceCell<T> {\n    fn from(value: T) -> Self {\n        OnceCell { inner: UnsafeCell::new(Some(value)) }\n    }\n}\n\nimpl<T> OnceCell<T> {\n    /// Creates a new empty cell.\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub const fn new() -> OnceCell<T> {\n        OnceCell { inner: UnsafeCell::new(None) }\n    }\n\n    /// Gets the reference to the underlying value.\n    ///\n    /// Returns `None` if the cell is empty.\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn get(&self) -> Option<&T> {\n        // SAFETY: Safe due to `inner`'s invariant\n        unsafe { &*self.inner.get() }.as_ref()\n    }\n\n    /// Gets the mutable reference to the underlying value.\n    ///\n    /// Returns `None` if the cell is empty.\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn get_mut(&mut self) -> Option<&mut T> {\n        // SAFETY: Safe because we have unique access\n        unsafe { &mut *self.inner.get() }.as_mut()\n    }\n\n    /// Sets the contents of the cell to `value`.\n    ///\n    /// # Errors\n    ///\n    /// This method returns `Ok(())` if the cell was empty and `Err(value)` if\n    /// it was full.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::OnceCell;\n    ///\n    /// let cell = OnceCell::new();\n    /// assert!(cell.get().is_none());\n    ///\n    /// assert_eq!(cell.set(92), Ok(()));\n    /// assert_eq!(cell.set(62), Err(62));\n    ///\n    /// assert!(cell.get().is_some());\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn set(&self, value: T) -> Result<(), T> {\n        // SAFETY: Safe because we cannot have overlapping mutable borrows\n        let slot = unsafe { &*self.inner.get() };\n        if slot.is_some() {\n            return Err(value);\n        }\n\n        // SAFETY: This is the only place where we set the slot, no races\n        // due to reentrancy/concurrency are possible, and we've\n        // checked that slot is currently `None`, so this write\n        // maintains the `inner`'s invariant.\n        let slot = unsafe { &mut *self.inner.get() };\n        *slot = Some(value);\n        Ok(())\n    }\n\n    /// Gets the contents of the cell, initializing it with `f`\n    /// if the cell was empty.\n    ///\n    /// # Panics\n    ///\n    /// If `f` panics, the panic is propagated to the caller, and the cell\n    /// remains uninitialized.\n    ///\n    /// It is an error to reentrantly initialize the cell from `f`. Doing\n    /// so results in a panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::OnceCell;\n    ///\n    /// let cell = OnceCell::new();\n    /// let value = cell.get_or_init(|| 92);\n    /// assert_eq!(value, &92);\n    /// let value = cell.get_or_init(|| unreachable!());\n    /// assert_eq!(value, &92);\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn get_or_init<F>(&self, f: F) -> &T\n    where\n        F: FnOnce() -> T,\n    {\n        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n            Ok(val) => val,\n        }\n    }\n\n    /// Gets the contents of the cell, initializing it with `f` if\n    /// the cell was empty. If the cell was empty and `f` failed, an\n    /// error is returned.\n    ///\n    /// # Panics\n    ///\n    /// If `f` panics, the panic is propagated to the caller, and the cell\n    /// remains uninitialized.\n    ///\n    /// It is an error to reentrantly initialize the cell from `f`. Doing\n    /// so results in a panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::OnceCell;\n    ///\n    /// let cell = OnceCell::new();\n    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n    /// assert!(cell.get().is_none());\n    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n    ///     Ok(92)\n    /// });\n    /// assert_eq!(value, Ok(&92));\n    /// assert_eq!(cell.get(), Some(&92))\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n    where\n        F: FnOnce() -> Result<T, E>,\n    {\n        if let Some(val) = self.get() {\n            return Ok(val);\n        }\n        let val = f()?;\n        // Note that *some* forms of reentrant initialization might lead to\n        // UB (see `reentrant_init` test). I believe that just removing this\n        // `assert`, while keeping `set/get` would be sound, but it seems\n        // better to panic, rather than to silently use an old value.\n        assert!(self.set(val).is_ok(), \"reentrant init\");\n        Ok(self.get().unwrap())\n    }\n\n    /// Consumes the cell, returning the wrapped value.\n    ///\n    /// Returns `None` if the cell was empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::OnceCell;\n    ///\n    /// let cell: OnceCell<String> = OnceCell::new();\n    /// assert_eq!(cell.into_inner(), None);\n    ///\n    /// let cell = OnceCell::new();\n    /// cell.set(\"hello\".to_string()).unwrap();\n    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn into_inner(self) -> Option<T> {\n        // Because `into_inner` takes `self` by value, the compiler statically verifies\n        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n        self.inner.into_inner()\n    }\n\n    /// Takes the value out of this `OnceCell`, moving it back to an uninitialized state.\n    ///\n    /// Has no effect and returns `None` if the `OnceCell` hasn't been initialized.\n    ///\n    /// Safety is guaranteed by requiring a mutable reference.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::OnceCell;\n    ///\n    /// let mut cell: OnceCell<String> = OnceCell::new();\n    /// assert_eq!(cell.take(), None);\n    ///\n    /// let mut cell = OnceCell::new();\n    /// cell.set(\"hello\".to_string()).unwrap();\n    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n    /// assert_eq!(cell.get(), None);\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn take(&mut self) -> Option<T> {\n        mem::take(self).into_inner()\n    }\n}\n\n/// A value which is initialized on the first access.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(once_cell)]\n///\n/// use std::lazy::Lazy;\n///\n/// let lazy: Lazy<i32> = Lazy::new(|| {\n///     println!(\"initializing\");\n///     92\n/// });\n/// println!(\"ready\");\n/// println!(\"{}\", *lazy);\n/// println!(\"{}\", *lazy);\n///\n/// // Prints:\n/// //   ready\n/// //   initializing\n/// //   92\n/// //   92\n/// ```\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\npub struct Lazy<T, F = fn() -> T> {\n    cell: OnceCell<T>,\n    init: Cell<Option<F>>,\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: fmt::Debug, F> fmt::Debug for Lazy<T, F> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n    }\n}\n\nimpl<T, F> Lazy<T, F> {\n    /// Creates a new lazy value with the given initializing function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// # fn main() {\n    /// use std::lazy::Lazy;\n    ///\n    /// let hello = \"Hello, World!\".to_string();\n    ///\n    /// let lazy = Lazy::new(|| hello.to_uppercase());\n    ///\n    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n    /// # }\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub const fn new(init: F) -> Lazy<T, F> {\n        Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n    }\n}\n\nimpl<T, F: FnOnce() -> T> Lazy<T, F> {\n    /// Forces the evaluation of this lazy value and returns a reference to\n    /// the result.\n    ///\n    /// This is equivalent to the `Deref` impl, but is explicit.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::Lazy;\n    ///\n    /// let lazy = Lazy::new(|| 92);\n    ///\n    /// assert_eq!(Lazy::force(&lazy), &92);\n    /// assert_eq!(&*lazy, &92);\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn force(this: &Lazy<T, F>) -> &T {\n        this.cell.get_or_init(|| match this.init.take() {\n            Some(f) => f(),\n            None => panic!(\"`Lazy` instance has previously been poisoned\"),\n        })\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n    type Target = T;\n    fn deref(&self) -> &T {\n        Lazy::force(self)\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: Default> Default for Lazy<T> {\n    /// Creates a new lazy value using `Default` as the initializing function.\n    fn default() -> Lazy<T> {\n        Lazy::new(T::default)\n    }\n}\n"],[2847,"//! This module reexports the primitive types to allow usage that is not\n//! possibly shadowed by other declared types.\n//!\n//! This is normally only useful in macro generated code.\n//!\n//! An example of this is when generating a new struct and an impl for it:\n//!\n//! ```rust,compile_fail\n//! pub struct bool;\n//!\n//! impl QueryId for bool {\n//!     const SOME_PROPERTY: bool = true;\n//! }\n//!\n//! # trait QueryId { const SOME_PROPERTY: core::primitive::bool; }\n//! ```\n//!\n//! Note that the `SOME_PROPERTY` associated constant would not compile, as its\n//! type `bool` refers to the struct, rather than to the primitive bool type.\n//!\n//! A correct implementation could look like:\n//!\n//! ```rust\n//! # #[allow(non_camel_case_types)]\n//! pub struct bool;\n//!\n//! impl QueryId for bool {\n//!     const SOME_PROPERTY: core::primitive::bool = true;\n//! }\n//!\n//! # trait QueryId { const SOME_PROPERTY: core::primitive::bool; }\n//! ```\n\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use bool;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use char;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use f32;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use f64;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use i128;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use i16;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use i32;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use i64;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use i8;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use isize;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use str;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use u128;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use u16;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use u32;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use u64;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use u8;\n#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\npub use usize;\n"],[2848,"// ignore-tidy-undocumented-unsafe\n\nuse crate::cmp;\nuse crate::mem::{self, MaybeUninit};\nuse crate::ptr;\n\n/// Rotates the range `[mid-left, mid+right)` such that the element at `mid` becomes the first\n/// element. Equivalently, rotates the range `left` elements to the left or `right` elements to the\n/// right.\n///\n/// # Safety\n///\n/// The specified range must be valid for reading and writing.\n///\n/// # Algorithm\n///\n/// Algorithm 1 is used for small values of `left + right` or for large `T`. The elements are moved\n/// into their final positions one at a time starting at `mid - left` and advancing by `right` steps\n/// modulo `left + right`, such that only one temporary is needed. Eventually, we arrive back at\n/// `mid - left`. However, if `gcd(left + right, right)` is not 1, the above steps skipped over\n/// elements. For example:\n/// ```text\n/// left = 10, right = 6\n/// the `^` indicates an element in its final place\n/// 6 7 8 9 10 11 12 13 14 15 . 0 1 2 3 4 5\n/// after using one step of the above algorithm (The X will be overwritten at the end of the round,\n/// and 12 is stored in a temporary):\n/// X 7 8 9 10 11 6 13 14 15 . 0 1 2 3 4 5\n///               ^\n/// after using another step (now 2 is in the temporary):\n/// X 7 8 9 10 11 6 13 14 15 . 0 1 12 3 4 5\n///               ^                 ^\n/// after the third step (the steps wrap around, and 8 is in the temporary):\n/// X 7 2 9 10 11 6 13 14 15 . 0 1 12 3 4 5\n///     ^         ^                 ^\n/// after 7 more steps, the round ends with the temporary 0 getting put in the X:\n/// 0 7 2 9 4 11 6 13 8 15 . 10 1 12 3 14 5\n/// ^   ^   ^    ^    ^       ^    ^    ^\n/// ```\n/// Fortunately, the number of skipped over elements between finalized elements is always equal, so\n/// we can just offset our starting position and do more rounds (the total number of rounds is the\n/// `gcd(left + right, right)` value). The end result is that all elements are finalized once and\n/// only once.\n///\n/// Algorithm 2 is used if `left + right` is large but `min(left, right)` is small enough to\n/// fit onto a stack buffer. The `min(left, right)` elements are copied onto the buffer, `memmove`\n/// is applied to the others, and the ones on the buffer are moved back into the hole on the\n/// opposite side of where they originated.\n///\n/// Algorithms that can be vectorized outperform the above once `left + right` becomes large enough.\n/// Algorithm 1 can be vectorized by chunking and performing many rounds at once, but there are too\n/// few rounds on average until `left + right` is enormous, and the worst case of a single\n/// round is always there. Instead, algorithm 3 utilizes repeated swapping of\n/// `min(left, right)` elements until a smaller rotate problem is left.\n///\n/// ```text\n/// left = 11, right = 4\n/// [4 5 6 7 8 9 10 11 12 13 14 . 0 1 2 3]\n///                  ^  ^  ^  ^   ^ ^ ^ ^ swapping the right most elements with elements to the left\n/// [4 5 6 7 8 9 10 . 0 1 2 3] 11 12 13 14\n///        ^ ^ ^  ^   ^ ^ ^ ^ swapping these\n/// [4 5 6 . 0 1 2 3] 7 8 9 10 11 12 13 14\n/// we cannot swap any more, but a smaller rotation problem is left to solve\n/// ```\n/// when `left < right` the swapping happens from the left instead.\npub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize) {\n    type BufType = [usize; 32];\n    if mem::size_of::<T>() == 0 {\n        return;\n    }\n    loop {\n        // N.B. the below algorithms can fail if these cases are not checked\n        if (right == 0) || (left == 0) {\n            return;\n        }\n        if (left + right < 24) || (mem::size_of::<T>() > mem::size_of::<[usize; 4]>()) {\n            // Algorithm 1\n            // Microbenchmarks indicate that the average performance for random shifts is better all\n            // the way until about `left + right == 32`, but the worst case performance breaks even\n            // around 16. 24 was chosen as middle ground. If the size of `T` is larger than 4\n            // `usize`s, this algorithm also outperforms other algorithms.\n            let x = unsafe { mid.sub(left) };\n            // beginning of first round\n            let mut tmp: T = unsafe { x.read() };\n            let mut i = right;\n            // `gcd` can be found before hand by calculating `gcd(left + right, right)`,\n            // but it is faster to do one loop which calculates the gcd as a side effect, then\n            // doing the rest of the chunk\n            let mut gcd = right;\n            // benchmarks reveal that it is faster to swap temporaries all the way through instead\n            // of reading one temporary once, copying backwards, and then writing that temporary at\n            // the very end. This is possibly due to the fact that swapping or replacing temporaries\n            // uses only one memory address in the loop instead of needing to manage two.\n            loop {\n                tmp = unsafe { x.add(i).replace(tmp) };\n                // instead of incrementing `i` and then checking if it is outside the bounds, we\n                // check if `i` will go outside the bounds on the next increment. This prevents\n                // any wrapping of pointers or `usize`.\n                if i >= left {\n                    i -= left;\n                    if i == 0 {\n                        // end of first round\n                        unsafe { x.write(tmp) };\n                        break;\n                    }\n                    // this conditional must be here if `left + right >= 15`\n                    if i < gcd {\n                        gcd = i;\n                    }\n                } else {\n                    i += right;\n                }\n            }\n            // finish the chunk with more rounds\n            for start in 1..gcd {\n                tmp = unsafe { x.add(start).read() };\n                i = start + right;\n                loop {\n                    tmp = unsafe { x.add(i).replace(tmp) };\n                    if i >= left {\n                        i -= left;\n                        if i == start {\n                            unsafe { x.add(start).write(tmp) };\n                            break;\n                        }\n                    } else {\n                        i += right;\n                    }\n                }\n            }\n            return;\n        // `T` is not a zero-sized type, so it's okay to divide by its size.\n        } else if cmp::min(left, right) <= mem::size_of::<BufType>() / mem::size_of::<T>() {\n            // Algorithm 2\n            // The `[T; 0]` here is to ensure this is appropriately aligned for T\n            let mut rawarray = MaybeUninit::<(BufType, [T; 0])>::uninit();\n            let buf = rawarray.as_mut_ptr() as *mut T;\n            let dim = unsafe { mid.sub(left).add(right) };\n            if left <= right {\n                unsafe {\n                    ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n                    ptr::copy(mid, mid.sub(left), right);\n                    ptr::copy_nonoverlapping(buf, dim, left);\n                }\n            } else {\n                unsafe {\n                    ptr::copy_nonoverlapping(mid, buf, right);\n                    ptr::copy(mid.sub(left), dim, left);\n                    ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n                }\n            }\n            return;\n        } else if left >= right {\n            // Algorithm 3\n            // There is an alternate way of swapping that involves finding where the last swap\n            // of this algorithm would be, and swapping using that last chunk instead of swapping\n            // adjacent chunks like this algorithm is doing, but this way is still faster.\n            loop {\n                unsafe {\n                    ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n                    mid = mid.sub(right);\n                }\n                left -= right;\n                if left < right {\n                    break;\n                }\n            }\n        } else {\n            // Algorithm 3, `left < right`\n            loop {\n                unsafe {\n                    ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n                    mid = mid.add(left);\n                }\n                right -= left;\n                if right < left {\n                    break;\n                }\n            }\n        }\n    }\n}\n"],[2849,"//! Macros used by iterators of slice.\n\n// Inlining is_empty and len makes a huge performance difference\nmacro_rules! is_empty {\n    // The way we encode the length of a ZST iterator, this works both for ZST\n    // and non-ZST.\n    ($self: ident) => {\n        $self.ptr.as_ptr() as *const T == $self.end\n    };\n}\n\n// To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n// unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\nmacro_rules! len {\n    ($self: ident) => {{\n        #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n\n        let start = $self.ptr;\n        let size = size_from_ptr(start.as_ptr());\n        if size == 0 {\n            // This _cannot_ use `unchecked_sub` because we depend on wrapping\n            // to represent the length of long ZST slice iterators.\n            ($self.end as usize).wrapping_sub(start.as_ptr() as usize)\n        } else {\n            // We know that `start <= end`, so can do better than `offset_from`,\n            // which needs to deal in signed.  By setting appropriate flags here\n            // we can tell LLVM this, which helps it remove bounds checks.\n            // SAFETY: By the type invariant, `start <= end`\n            let diff = unsafe { unchecked_sub($self.end as usize, start.as_ptr() as usize) };\n            // By also telling LLVM that the pointers are apart by an exact\n            // multiple of the type size, it can optimize `len() == 0` down to\n            // `start == end` instead of `(end - start) < size`.\n            // SAFETY: By the type invariant, the pointers are aligned so the\n            //         distance between them must be a multiple of pointee size\n            unsafe { exact_div(diff, size) }\n        }\n    }};\n}\n\n// The shared definition of the `Iter` and `IterMut` iterators\nmacro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        {$($extra:tt)*}\n    ) => {\n        // Returns the first element and moves the start of the iterator forwards by 1.\n        // Greatly improves performance compared to an inlined function. The iterator\n        // must not be empty.\n        macro_rules! next_unchecked {\n            ($self: ident) => {& $( $mut_ )? *$self.post_inc_start(1)}\n        }\n\n        // Returns the last element and moves the end of the iterator backwards by 1.\n        // Greatly improves performance compared to an inlined function. The iterator\n        // must not be empty.\n        macro_rules! next_back_unchecked {\n            ($self: ident) => {& $( $mut_ )? *$self.pre_dec_end(1)}\n        }\n\n        // Shrinks the iterator when T is a ZST, by moving the end of the iterator\n        // backwards by `n`. `n` must not exceed `self.len()`.\n        macro_rules! zst_shrink {\n            ($self: ident, $n: ident) => {\n                $self.end = ($self.end as * $raw_mut u8).wrapping_offset(-$n) as * $raw_mut T;\n            }\n        }\n\n        impl<'a, T> $name<'a, T> {\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n                if mem::size_of::<T>() == 0 {\n                    zst_shrink!(self, offset);\n                    self.ptr.as_ptr()\n                } else {\n                    let old = self.ptr.as_ptr();\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().offset(offset)) };\n                    old\n                }\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n                if mem::size_of::<T>() == 0 {\n                    zst_shrink!(self, offset);\n                    self.ptr.as_ptr()\n                } else {\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    self.end = unsafe { self.end.offset(-offset) };\n                    self.end\n                }\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: `assume` calls are safe since a slice's start pointer\n                // must be non-null, and slices over non-ZSTs must also have a\n                // non-null end pointer. The call to `next_unchecked!` is safe\n                // since we check if the iterator is empty first.\n                unsafe {\n                    assume(!self.ptr.as_ptr().is_null());\n                    if mem::size_of::<T>() != 0 {\n                        assume(!self.end.is_null());\n                    }\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(next_unchecked!(self))\n                    }\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if mem::size_of::<T>() == 0 {\n                        // We have to do it this way as `ptr` may never be 0, but `end`\n                        // could be (due to wrapping).\n                        self.end = self.ptr.as_ptr();\n                    } else {\n                        // SAFETY: end can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n                        unsafe {\n                            self.ptr = NonNull::new_unchecked(self.end as *mut T);\n                        }\n                    }\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n as isize);\n                    Some(next_unchecked!(self))\n                }\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assume(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assume(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[doc(hidden)]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: `assume` calls are safe since a slice's start pointer must be non-null,\n                // and slices over non-ZSTs must also have a non-null end pointer.\n                // The call to `next_back_unchecked!` is safe since we check if the iterator is\n                // empty first.\n                unsafe {\n                    assume(!self.ptr.as_ptr().is_null());\n                    if mem::size_of::<T>() != 0 {\n                        assume(!self.end.is_null());\n                    }\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(next_back_unchecked!(self))\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    self.end = self.ptr.as_ptr();\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n as isize);\n                    Some(next_back_unchecked!(self))\n                }\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n    }\n}\n\nmacro_rules! forward_iterator {\n    ($name:ident: $elem:ident, $iter_of:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, $elem, P> Iterator for $name<'a, $elem, P>\n        where\n            P: FnMut(&T) -> bool,\n        {\n            type Item = $iter_of;\n\n            #[inline]\n            fn next(&mut self) -> Option<$iter_of> {\n                self.inner.next()\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.inner.size_hint()\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<'a, $elem, P> FusedIterator for $name<'a, $elem, P> where P: FnMut(&T) -> bool {}\n    };\n}\n"],[2850,"// ignore-tidy-filelength\n//! Definitions of a bunch of iterators for `[T]`.\n\n#[macro_use] // import iterator! and forward_iterator!\nmod macros;\n\nuse crate::cmp;\nuse crate::cmp::Ordering;\nuse crate::fmt;\nuse crate::intrinsics::{assume, exact_div, unchecked_sub};\nuse crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess};\nuse crate::marker::{PhantomData, Send, Sized, Sync};\nuse crate::mem;\nuse crate::num::NonZeroUsize;\nuse crate::ptr::NonNull;\n\nuse super::{from_raw_parts, from_raw_parts_mut};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a [T] {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a mut [T] {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n// Macro helper functions\n#[inline(always)]\nfn size_from_ptr<T>(_: *const T) -> usize {\n    mem::size_of::<T>()\n}\n\n/// Immutable slice iterator\n///\n/// This struct is created by the [`iter`] method on [slices].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // First, we declare a type which has `iter` method to get the `Iter` struct (`&[usize]` here):\n/// let slice = &[1, 2, 3];\n///\n/// // Then, we iterate over it:\n/// for element in slice.iter() {\n///     println!(\"{}\", element);\n/// }\n/// ```\n///\n/// [`iter`]: slice::iter\n/// [slices]: slice\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    ptr: NonNull<T>,\n    end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n    // ptr == end is a quick test for the Iterator being empty, that works\n    // for both ZST and non-ZST.\n    _marker: PhantomData<&'a T>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Iter\").field(&self.as_slice()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for Iter<'_, T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Send for Iter<'_, T> {}\n\nimpl<'a, T> Iter<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T]) -> Self {\n        let ptr = slice.as_ptr();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            assume(!ptr.is_null());\n\n            let end = if mem::size_of::<T>() == 0 {\n                (ptr as *const u8).wrapping_add(slice.len()) as *const T\n            } else {\n                ptr.add(slice.len())\n            };\n\n            Self { ptr: NonNull::new_unchecked(ptr as *mut T), end, _marker: PhantomData }\n        }\n    }\n\n    /// Views the underlying data as a subslice of the original data.\n    ///\n    /// This has the same lifetime as the original slice, and so the\n    /// iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // First, we declare a type which has the `iter` method to get the `Iter`\n    /// // struct (`&[usize]` here):\n    /// let slice = &[1, 2, 3];\n    ///\n    /// // Then, we get the iterator:\n    /// let mut iter = slice.iter();\n    /// // So if we print what `as_slice` method returns here, we have \"[1, 2, 3]\":\n    /// println!(\"{:?}\", iter.as_slice());\n    ///\n    /// // Next, we move to the second element of the slice:\n    /// iter.next();\n    /// // Now `as_slice` returns \"[2, 3]\":\n    /// println!(\"{:?}\", iter.as_slice());\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    pub fn as_slice(&self) -> &'a [T] {\n        self.make_slice()\n    }\n}\n\niterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>,\n    {\n        self.as_slice().windows(2).all(|w| {\n            compare(&&w[0], &&w[1]).map(|o| o != Ordering::Greater).unwrap_or(false)\n        })\n    }\n}}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Iter<'_, T> {\n    fn clone(&self) -> Self {\n        Iter { ptr: self.ptr, end: self.end, _marker: self._marker }\n    }\n}\n\n#[stable(feature = \"slice_iter_as_ref\", since = \"1.13.0\")]\nimpl<T> AsRef<[T]> for Iter<'_, T> {\n    fn as_ref(&self) -> &[T] {\n        self.as_slice()\n    }\n}\n\n/// Mutable slice iterator.\n///\n/// This struct is created by the [`iter_mut`] method on [slices].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n/// // struct (`&[usize]` here):\n/// let mut slice = &mut [1, 2, 3];\n///\n/// // Then, we iterate over it and increment each element value:\n/// for element in slice.iter_mut() {\n///     *element += 1;\n/// }\n///\n/// // We now have \"[2, 3, 4]\":\n/// println!(\"{:?}\", slice);\n/// ```\n///\n/// [`iter_mut`]: slice::iter_mut\n/// [slices]: slice\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, T: 'a> {\n    ptr: NonNull<T>,\n    end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n    // ptr == end is a quick test for the Iterator being empty, that works\n    // for both ZST and non-ZST.\n    _marker: PhantomData<&'a mut T>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"IterMut\").field(&self.make_slice()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for IterMut<'_, T> {}\n\nimpl<'a, T> IterMut<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a mut [T]) -> Self {\n        let ptr = slice.as_mut_ptr();\n        // SAFETY: There are several things here:\n        //\n        // `ptr` has been obtained by `slice.as_ptr()` where `slice` is a valid\n        // reference thus it is non-NUL and safe to use and pass to\n        // `NonNull::new_unchecked` .\n        //\n        // Adding `slice.len()` to the starting pointer gives a pointer\n        // at the end of `slice`. `end` will never be dereferenced, only checked\n        // for direct pointer equality with `ptr` to check if the iterator is\n        // done.\n        //\n        // In the case of a ZST, the end pointer is just the start pointer plus\n        // the length, to also allows for the fast `ptr == end` check.\n        //\n        // See the `next_unchecked!` and `is_empty!` macros as well as the\n        // `post_inc_start` method for more informations.\n        unsafe {\n            assume(!ptr.is_null());\n\n            let end = if mem::size_of::<T>() == 0 {\n                (ptr as *mut u8).wrapping_add(slice.len()) as *mut T\n            } else {\n                ptr.add(slice.len())\n            };\n\n            Self { ptr: NonNull::new_unchecked(ptr), end, _marker: PhantomData }\n        }\n    }\n\n    /// Views the underlying data as a subslice of the original data.\n    ///\n    /// To avoid creating `&mut` references that alias, this is forced\n    /// to consume the iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n    /// // struct (`&[usize]` here):\n    /// let mut slice = &mut [1, 2, 3];\n    ///\n    /// {\n    ///     // Then, we get the iterator:\n    ///     let mut iter = slice.iter_mut();\n    ///     // We move to next element:\n    ///     iter.next();\n    ///     // So if we print what `into_slice` method returns here, we have \"[2, 3]\":\n    ///     println!(\"{:?}\", iter.into_slice());\n    /// }\n    ///\n    /// // Now let's modify a value of the slice:\n    /// {\n    ///     // First we get back the iterator:\n    ///     let mut iter = slice.iter_mut();\n    ///     // We change the value of the first element of the slice returned by the `next` method:\n    ///     *iter.next().unwrap() += 1;\n    /// }\n    /// // Now slice is \"[2, 2, 3]\":\n    /// println!(\"{:?}\", slice);\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    pub fn into_slice(self) -> &'a mut [T] {\n        // SAFETY: the iterator was created from a mutable slice with pointer\n        // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites\n        // for `from_raw_parts_mut` are fulfilled.\n        unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }\n    }\n\n    /// Views the underlying data as a subslice of the original data.\n    ///\n    /// To avoid creating `&mut [T]` references that alias, the returned slice\n    /// borrows its lifetime from the iterator the method is applied on.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut slice: &mut [usize] = &mut [1, 2, 3];\n    ///\n    /// // First, we get the iterator:\n    /// let mut iter = slice.iter_mut();\n    /// // So if we check what the `as_slice` method returns here, we have \"[1, 2, 3]\":\n    /// assert_eq!(iter.as_slice(), &[1, 2, 3]);\n    ///\n    /// // Next, we move to the second element of the slice:\n    /// iter.next();\n    /// // Now `as_slice` returns \"[2, 3]\":\n    /// assert_eq!(iter.as_slice(), &[2, 3]);\n    /// ```\n    #[stable(feature = \"slice_iter_mut_as_slice\", since = \"1.53.0\")]\n    pub fn as_slice(&self) -> &[T] {\n        self.make_slice()\n    }\n}\n\n#[stable(feature = \"slice_iter_mut_as_slice\", since = \"1.53.0\")]\nimpl<T> AsRef<[T]> for IterMut<'_, T> {\n    fn as_ref(&self) -> &[T] {\n        self.as_slice()\n    }\n}\n\niterator! {struct IterMut -> *mut T, &'a mut T, mut, {mut}, {}}\n\n/// An internal abstraction over the splitting iterators, so that\n/// splitn, splitn_mut etc can be implemented once.\n#[doc(hidden)]\npub(super) trait SplitIter: DoubleEndedIterator {\n    /// Marks the underlying iterator as complete, extracting the remaining\n    /// portion of the slice.\n    fn finish(&mut self) -> Option<Self::Item>;\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function.\n///\n/// This struct is created by the [`split`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = [10, 40, 33, 20];\n/// let mut iter = slice.split(|num| num % 3 == 0);\n/// ```\n///\n/// [`split`]: slice::split\n/// [slices]: slice\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Split<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    // Used for `SplitWhitespace` and `SplitAsciiWhitespace` `as_str` methods\n    pub(crate) v: &'a [T],\n    pred: P,\n    // Used for `SplitAsciiWhitespace` `as_str` method\n    pub(crate) finished: bool,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> Split<'a, T, P> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n        Self { v: slice, pred, finished: false }\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for Split<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Split\").field(\"v\", &self.v).field(\"finished\", &self.finished).finish()\n    }\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, P> Clone for Split<'_, T, P>\nwhere\n    P: Clone + FnMut(&T) -> bool,\n{\n    fn clone(&self) -> Self {\n        Split { v: self.v, pred: self.pred.clone(), finished: self.finished }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Iterator for Split<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.finished {\n            return None;\n        }\n\n        match self.v.iter().position(|x| (self.pred)(x)) {\n            None => self.finish(),\n            Some(idx) => {\n                let ret = Some(&self.v[..idx]);\n                self.v = &self.v[idx + 1..];\n                ret\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.finished { (0, Some(0)) } else { (1, Some(self.v.len() + 1)) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> DoubleEndedIterator for Split<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.finished {\n            return None;\n        }\n\n        match self.v.iter().rposition(|x| (self.pred)(x)) {\n            None => self.finish(),\n            Some(idx) => {\n                let ret = Some(&self.v[idx + 1..]);\n                self.v = &self.v[..idx];\n                ret\n            }\n        }\n    }\n}\n\nimpl<'a, T, P> SplitIter for Split<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn finish(&mut self) -> Option<&'a [T]> {\n        if self.finished {\n            None\n        } else {\n            self.finished = true;\n            Some(self.v)\n        }\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, P> FusedIterator for Split<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function. Unlike `Split`, it contains the matched part as a terminator\n/// of the subslice.\n///\n/// This struct is created by the [`split_inclusive`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = [10, 40, 33, 20];\n/// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n/// ```\n///\n/// [`split_inclusive`]: slice::split_inclusive\n/// [slices]: slice\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\npub struct SplitInclusive<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    v: &'a [T],\n    pred: P,\n    finished: bool,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusive<'a, T, P> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n        Self { v: slice, pred, finished: false }\n    }\n}\n\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for SplitInclusive<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SplitInclusive\")\n            .field(\"v\", &self.v)\n            .field(\"finished\", &self.finished)\n            .finish()\n    }\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\nimpl<T, P> Clone for SplitInclusive<'_, T, P>\nwhere\n    P: Clone + FnMut(&T) -> bool,\n{\n    fn clone(&self) -> Self {\n        SplitInclusive { v: self.v, pred: self.pred.clone(), finished: self.finished }\n    }\n}\n\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\nimpl<'a, T, P> Iterator for SplitInclusive<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.finished {\n            return None;\n        }\n\n        let idx =\n            self.v.iter().position(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(self.v.len());\n        if idx == self.v.len() {\n            self.finished = true;\n        }\n        let ret = Some(&self.v[..idx]);\n        self.v = &self.v[idx..];\n        ret\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.finished { (0, Some(0)) } else { (1, Some(self.v.len() + 1)) }\n    }\n}\n\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\nimpl<'a, T, P> DoubleEndedIterator for SplitInclusive<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.finished {\n            return None;\n        }\n\n        // The last index of self.v is already checked and found to match\n        // by the last iteration, so we start searching a new match\n        // one index to the left.\n        let remainder = if self.v.is_empty() { &[] } else { &self.v[..(self.v.len() - 1)] };\n        let idx = remainder.iter().rposition(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(0);\n        if idx == 0 {\n            self.finished = true;\n        }\n        let ret = Some(&self.v[idx..]);\n        self.v = &self.v[..idx];\n        ret\n    }\n}\n\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\nimpl<T, P> FusedIterator for SplitInclusive<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over the mutable subslices of the vector which are separated\n/// by elements that match `pred`.\n///\n/// This struct is created by the [`split_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let mut v = [10, 40, 30, 20, 60, 50];\n/// let iter = v.split_mut(|num| *num % 3 == 0);\n/// ```\n///\n/// [`split_mut`]: slice::split_mut\n/// [slices]: slice\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitMut<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    v: &'a mut [T],\n    pred: P,\n    finished: bool,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> SplitMut<'a, T, P> {\n    #[inline]\n    pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n        Self { v: slice, pred, finished: false }\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for SplitMut<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SplitMut\").field(\"v\", &self.v).field(\"finished\", &self.finished).finish()\n    }\n}\n\nimpl<'a, T, P> SplitIter for SplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn finish(&mut self) -> Option<&'a mut [T]> {\n        if self.finished {\n            None\n        } else {\n            self.finished = true;\n            Some(mem::replace(&mut self.v, &mut []))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Iterator for SplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.finished {\n            return None;\n        }\n\n        let idx_opt = {\n            // work around borrowck limitations\n            let pred = &mut self.pred;\n            self.v.iter().position(|x| (*pred)(x))\n        };\n        match idx_opt {\n            None => self.finish(),\n            Some(idx) => {\n                let tmp = mem::replace(&mut self.v, &mut []);\n                let (head, tail) = tmp.split_at_mut(idx);\n                self.v = &mut tail[1..];\n                Some(head)\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.finished {\n            (0, Some(0))\n        } else {\n            // if the predicate doesn't match anything, we yield one slice\n            // if it matches every element, we yield len+1 empty slices.\n            (1, Some(self.v.len() + 1))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.finished {\n            return None;\n        }\n\n        let idx_opt = {\n            // work around borrowck limitations\n            let pred = &mut self.pred;\n            self.v.iter().rposition(|x| (*pred)(x))\n        };\n        match idx_opt {\n            None => self.finish(),\n            Some(idx) => {\n                let tmp = mem::replace(&mut self.v, &mut []);\n                let (head, tail) = tmp.split_at_mut(idx);\n                self.v = head;\n                Some(&mut tail[1..])\n            }\n        }\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, P> FusedIterator for SplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over the mutable subslices of the vector which are separated\n/// by elements that match `pred`. Unlike `SplitMut`, it contains the matched\n/// parts in the ends of the subslices.\n///\n/// This struct is created by the [`split_inclusive_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let mut v = [10, 40, 30, 20, 60, 50];\n/// let iter = v.split_inclusive_mut(|num| *num % 3 == 0);\n/// ```\n///\n/// [`split_inclusive_mut`]: slice::split_inclusive_mut\n/// [slices]: slice\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\npub struct SplitInclusiveMut<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    v: &'a mut [T],\n    pred: P,\n    finished: bool,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusiveMut<'a, T, P> {\n    #[inline]\n    pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n        Self { v: slice, pred, finished: false }\n    }\n}\n\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for SplitInclusiveMut<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SplitInclusiveMut\")\n            .field(\"v\", &self.v)\n            .field(\"finished\", &self.finished)\n            .finish()\n    }\n}\n\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\nimpl<'a, T, P> Iterator for SplitInclusiveMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.finished {\n            return None;\n        }\n\n        let idx_opt = {\n            // work around borrowck limitations\n            let pred = &mut self.pred;\n            self.v.iter().position(|x| (*pred)(x))\n        };\n        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(self.v.len());\n        if idx == self.v.len() {\n            self.finished = true;\n        }\n        let tmp = mem::replace(&mut self.v, &mut []);\n        let (head, tail) = tmp.split_at_mut(idx);\n        self.v = tail;\n        Some(head)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.finished {\n            (0, Some(0))\n        } else {\n            // if the predicate doesn't match anything, we yield one slice\n            // if it matches every element, we yield len+1 empty slices.\n            (1, Some(self.v.len() + 1))\n        }\n    }\n}\n\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\nimpl<'a, T, P> DoubleEndedIterator for SplitInclusiveMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.finished {\n            return None;\n        }\n\n        let idx_opt = if self.v.is_empty() {\n            None\n        } else {\n            // work around borrowck limitations\n            let pred = &mut self.pred;\n\n            // The last index of self.v is already checked and found to match\n            // by the last iteration, so we start searching a new match\n            // one index to the left.\n            let remainder = &self.v[..(self.v.len() - 1)];\n            remainder.iter().rposition(|x| (*pred)(x))\n        };\n        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(0);\n        if idx == 0 {\n            self.finished = true;\n        }\n        let tmp = mem::replace(&mut self.v, &mut []);\n        let (head, tail) = tmp.split_at_mut(idx);\n        self.v = head;\n        Some(tail)\n    }\n}\n\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\nimpl<T, P> FusedIterator for SplitInclusiveMut<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, starting from the end of the slice.\n///\n/// This struct is created by the [`rsplit`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = [11, 22, 33, 0, 44, 55];\n/// let iter = slice.rsplit(|num| *num == 0);\n/// ```\n///\n/// [`rsplit`]: slice::rsplit\n/// [slices]: slice\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n#[derive(Clone)] // Is this correct, or does it incorrectly require `T: Clone`?\npub struct RSplit<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: Split<'a, T, P>,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> RSplit<'a, T, P> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n        Self { inner: Split::new(slice, pred) }\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for RSplit<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RSplit\")\n            .field(\"v\", &self.inner.v)\n            .field(\"finished\", &self.inner.finished)\n            .finish()\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> Iterator for RSplit<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        self.inner.next_back()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> DoubleEndedIterator for RSplit<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        self.inner.next()\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> SplitIter for RSplit<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn finish(&mut self) -> Option<&'a [T]> {\n        self.inner.finish()\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<T, P> FusedIterator for RSplit<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over the subslices of the vector which are separated\n/// by elements that match `pred`, starting from the end of the slice.\n///\n/// This struct is created by the [`rsplit_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let mut slice = [11, 22, 33, 0, 44, 55];\n/// let iter = slice.rsplit_mut(|num| *num == 0);\n/// ```\n///\n/// [`rsplit_mut`]: slice::rsplit_mut\n/// [slices]: slice\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\npub struct RSplitMut<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: SplitMut<'a, T, P>,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitMut<'a, T, P> {\n    #[inline]\n    pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n        Self { inner: SplitMut::new(slice, pred) }\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for RSplitMut<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RSplitMut\")\n            .field(\"v\", &self.inner.v)\n            .field(\"finished\", &self.inner.finished)\n            .finish()\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> SplitIter for RSplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn finish(&mut self) -> Option<&'a mut [T]> {\n        self.inner.finish()\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> Iterator for RSplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        self.inner.next_back()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        self.inner.next()\n    }\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<T, P> FusedIterator for RSplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An private iterator over subslices separated by elements that\n/// match a predicate function, splitting at most a fixed number of\n/// times.\n#[derive(Debug)]\nstruct GenericSplitN<I> {\n    iter: I,\n    count: usize,\n}\n\nimpl<T, I: SplitIter<Item = T>> Iterator for GenericSplitN<I> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        match self.count {\n            0 => None,\n            1 => {\n                self.count -= 1;\n                self.iter.finish()\n            }\n            _ => {\n                self.count -= 1;\n                self.iter.next()\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, upper_opt) = self.iter.size_hint();\n        (lower, upper_opt.map(|upper| cmp::min(self.count, upper)))\n    }\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, limited to a given number of splits.\n///\n/// This struct is created by the [`splitn`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = [10, 40, 30, 20, 60, 50];\n/// let iter = slice.splitn(2, |num| *num % 3 == 0);\n/// ```\n///\n/// [`splitn`]: slice::splitn\n/// [slices]: slice\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitN<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: GenericSplitN<Split<'a, T, P>>,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> SplitN<'a, T, P> {\n    #[inline]\n    pub(super) fn new(s: Split<'a, T, P>, n: usize) -> Self {\n        Self { inner: GenericSplitN { iter: s, count: n } }\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for SplitN<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SplitN\").field(\"inner\", &self.inner).finish()\n    }\n}\n\n/// An iterator over subslices separated by elements that match a\n/// predicate function, limited to a given number of splits, starting\n/// from the end of the slice.\n///\n/// This struct is created by the [`rsplitn`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = [10, 40, 30, 20, 60, 50];\n/// let iter = slice.rsplitn(2, |num| *num % 3 == 0);\n/// ```\n///\n/// [`rsplitn`]: slice::rsplitn\n/// [slices]: slice\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RSplitN<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: GenericSplitN<RSplit<'a, T, P>>,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitN<'a, T, P> {\n    #[inline]\n    pub(super) fn new(s: RSplit<'a, T, P>, n: usize) -> Self {\n        Self { inner: GenericSplitN { iter: s, count: n } }\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for RSplitN<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RSplitN\").field(\"inner\", &self.inner).finish()\n    }\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, limited to a given number of splits.\n///\n/// This struct is created by the [`splitn_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let mut slice = [10, 40, 30, 20, 60, 50];\n/// let iter = slice.splitn_mut(2, |num| *num % 3 == 0);\n/// ```\n///\n/// [`splitn_mut`]: slice::splitn_mut\n/// [slices]: slice\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitNMut<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: GenericSplitN<SplitMut<'a, T, P>>,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> SplitNMut<'a, T, P> {\n    #[inline]\n    pub(super) fn new(s: SplitMut<'a, T, P>, n: usize) -> Self {\n        Self { inner: GenericSplitN { iter: s, count: n } }\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for SplitNMut<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SplitNMut\").field(\"inner\", &self.inner).finish()\n    }\n}\n\n/// An iterator over subslices separated by elements that match a\n/// predicate function, limited to a given number of splits, starting\n/// from the end of the slice.\n///\n/// This struct is created by the [`rsplitn_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let mut slice = [10, 40, 30, 20, 60, 50];\n/// let iter = slice.rsplitn_mut(2, |num| *num % 3 == 0);\n/// ```\n///\n/// [`rsplitn_mut`]: slice::rsplitn_mut\n/// [slices]: slice\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RSplitNMut<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: GenericSplitN<RSplitMut<'a, T, P>>,\n}\n\nimpl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitNMut<'a, T, P> {\n    #[inline]\n    pub(super) fn new(s: RSplitMut<'a, T, P>, n: usize) -> Self {\n        Self { inner: GenericSplitN { iter: s, count: n } }\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for RSplitNMut<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RSplitNMut\").field(\"inner\", &self.inner).finish()\n    }\n}\n\nforward_iterator! { SplitN: T, &'a [T] }\nforward_iterator! { RSplitN: T, &'a [T] }\nforward_iterator! { SplitNMut: T, &'a mut [T] }\nforward_iterator! { RSplitNMut: T, &'a mut [T] }\n\n/// An iterator over overlapping subslices of length `size`.\n///\n/// This struct is created by the [`windows`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = ['r', 'u', 's', 't'];\n/// let iter = slice.windows(2);\n/// ```\n///\n/// [`windows`]: slice::windows\n/// [slices]: slice\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Windows<'a, T: 'a> {\n    v: &'a [T],\n    size: NonZeroUsize,\n}\n\nimpl<'a, T: 'a> Windows<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T], size: NonZeroUsize) -> Self {\n        Self { v: slice, size }\n    }\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Windows<'_, T> {\n    fn clone(&self) -> Self {\n        Windows { v: self.v, size: self.size }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Windows<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.size.get() > self.v.len() {\n            None\n        } else {\n            let ret = Some(&self.v[..self.size.get()]);\n            self.v = &self.v[1..];\n            ret\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.size.get() > self.v.len() {\n            (0, Some(0))\n        } else {\n            let size = self.v.len() - self.size.get() + 1;\n            (size, Some(size))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (end, overflow) = self.size.get().overflowing_add(n);\n        if end > self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let nth = &self.v[n..end];\n            self.v = &self.v[n + 1..];\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.size.get() > self.v.len() {\n            None\n        } else {\n            let start = self.v.len() - self.size.get();\n            Some(&self.v[start..])\n        }\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        // SAFETY: since the caller guarantees that `i` is in bounds,\n        // which means that `i` cannot overflow an `isize`, and the\n        // slice created by `from_raw_parts` is a subslice of `self.v`\n        // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.\n        unsafe { from_raw_parts(self.v.as_ptr().add(idx), self.size.get()) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.size.get() > self.v.len() {\n            None\n        } else {\n            let ret = Some(&self.v[self.v.len() - self.size.get()..]);\n            self.v = &self.v[..self.v.len() - 1];\n            ret\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let (end, overflow) = self.v.len().overflowing_sub(n);\n        if end < self.size.get() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let ret = &self.v[end - self.size.get()..end];\n            self.v = &self.v[..end - 1];\n            Some(ret)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for Windows<'_, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for Windows<'_, T> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for Windows<'_, T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n/// time), starting at the beginning of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last slice\n/// of the iteration will be the remainder.\n///\n/// This struct is created by the [`chunks`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.chunks(2);\n/// ```\n///\n/// [`chunks`]: slice::chunks\n/// [slices]: slice\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chunks<'a, T: 'a> {\n    v: &'a [T],\n    chunk_size: usize,\n}\n\nimpl<'a, T: 'a> Chunks<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n        Self { v: slice, chunk_size: size }\n    }\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Chunks<'_, T> {\n    fn clone(&self) -> Self {\n        Chunks { v: self.v, chunk_size: self.chunk_size }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Chunks<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n            let (fst, snd) = self.v.split_at(chunksz);\n            self.v = snd;\n            Some(fst)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.v.is_empty() {\n            (0, Some(0))\n        } else {\n            let n = self.v.len() / self.chunk_size;\n            let rem = self.v.len() % self.chunk_size;\n            let n = if rem > 0 { n + 1 } else { n };\n            (n, Some(n))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n        if start >= self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let end = match start.checked_add(self.chunk_size) {\n                Some(sum) => cmp::min(self.v.len(), sum),\n                None => self.v.len(),\n            };\n            let nth = &self.v[start..end];\n            self.v = &self.v[end..];\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n            Some(&self.v[start..])\n        }\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        let start = idx * self.chunk_size;\n        let end = match start.checked_add(self.chunk_size) {\n            None => self.v.len(),\n            Some(end) => cmp::min(end, self.v.len()),\n        };\n        // SAFETY: the caller guarantees that `i` is in bounds,\n        // which means that `start` must be in bounds of the\n        // underlying `self.v` slice, and we made sure that `end`\n        // is also in bounds of `self.v`. Thus, `start` cannot overflow\n        // an `isize`, and the slice constructed by `from_raw_parts`\n        // is a subslice of `self.v` which is guaranteed to be valid\n        // for the lifetime `'a` of `self.v`.\n        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let remainder = self.v.len() % self.chunk_size;\n            let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n            self.v = fst;\n            Some(snd)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let len = self.len();\n        if n >= len {\n            self.v = &[];\n            None\n        } else {\n            let start = (len - 1 - n) * self.chunk_size;\n            let end = match start.checked_add(self.chunk_size) {\n                Some(res) => cmp::min(res, self.v.len()),\n                None => self.v.len(),\n            };\n            let nth_back = &self.v[start..end];\n            self.v = &self.v[..start];\n            Some(nth_back)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for Chunks<'_, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for Chunks<'_, T> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for Chunks<'_, T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n/// elements at a time), starting at the beginning of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last slice\n/// of the iteration will be the remainder.\n///\n/// This struct is created by the [`chunks_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let mut slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.chunks_mut(2);\n/// ```\n///\n/// [`chunks_mut`]: slice::chunks_mut\n/// [slices]: slice\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ChunksMut<'a, T: 'a> {\n    v: &'a mut [T],\n    chunk_size: usize,\n}\n\nimpl<'a, T: 'a> ChunksMut<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n        Self { v: slice, chunk_size: size }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for ChunksMut<'a, T> {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let sz = cmp::min(self.v.len(), self.chunk_size);\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(sz);\n            self.v = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.v.is_empty() {\n            (0, Some(0))\n        } else {\n            let n = self.v.len() / self.chunk_size;\n            let rem = self.v.len() % self.chunk_size;\n            let n = if rem > 0 { n + 1 } else { n };\n            (n, Some(n))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n        if start >= self.v.len() || overflow {\n            self.v = &mut [];\n            None\n        } else {\n            let end = match start.checked_add(self.chunk_size) {\n                Some(sum) => cmp::min(self.v.len(), sum),\n                None => self.v.len(),\n            };\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(end);\n            let (_, nth) = head.split_at_mut(start);\n            self.v = tail;\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n            Some(&mut self.v[start..])\n        }\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        let start = idx * self.chunk_size;\n        let end = match start.checked_add(self.chunk_size) {\n            None => self.v.len(),\n            Some(end) => cmp::min(end, self.v.len()),\n        };\n        // SAFETY: see comments for `Chunks::__iterator_get_unchecked`.\n        //\n        // Also note that the caller also guarantees that we're never called\n        // with the same index again, and that no other methods that will\n        // access this subslice are called, so it is valid for the returned\n        // slice to be mutable.\n        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let remainder = self.v.len() % self.chunk_size;\n            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n            self.v = head;\n            Some(tail)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let len = self.len();\n        if n >= len {\n            self.v = &mut [];\n            None\n        } else {\n            let start = (len - 1 - n) * self.chunk_size;\n            let end = match start.checked_add(self.chunk_size) {\n                Some(res) => cmp::min(res, self.v.len()),\n                None => self.v.len(),\n            };\n            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n            let (head, nth_back) = temp.split_at_mut(start);\n            self.v = head;\n            Some(nth_back)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for ChunksMut<'_, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for ChunksMut<'_, T> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for ChunksMut<'_, T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n/// time), starting at the beginning of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last\n/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n/// the [`remainder`] function from the iterator.\n///\n/// This struct is created by the [`chunks_exact`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.chunks_exact(2);\n/// ```\n///\n/// [`chunks_exact`]: slice::chunks_exact\n/// [`remainder`]: ChunksExact::remainder\n/// [slices]: slice\n#[derive(Debug)]\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\npub struct ChunksExact<'a, T: 'a> {\n    v: &'a [T],\n    rem: &'a [T],\n    chunk_size: usize,\n}\n\nimpl<'a, T> ChunksExact<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {\n        let rem = slice.len() % chunk_size;\n        let fst_len = slice.len() - rem;\n        // SAFETY: 0 <= fst_len <= slice.len() by construction above\n        let (fst, snd) = unsafe { slice.split_at_unchecked(fst_len) };\n        Self { v: fst, rem: snd, chunk_size }\n    }\n\n    /// Returns the remainder of the original slice that is not going to be\n    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n    /// elements.\n    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n    pub fn remainder(&self) -> &'a [T] {\n        self.rem\n    }\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\nimpl<T> Clone for ChunksExact<'_, T> {\n    fn clone(&self) -> Self {\n        ChunksExact { v: self.v, rem: self.rem, chunk_size: self.chunk_size }\n    }\n}\n\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\nimpl<'a, T> Iterator for ChunksExact<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.chunk_size);\n            self.v = snd;\n            Some(fst)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.v.len() / self.chunk_size;\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n        if start >= self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let (_, snd) = self.v.split_at(start);\n            self.v = snd;\n            self.next()\n        }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        let start = idx * self.chunk_size;\n        // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.\n        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n    }\n}\n\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\nimpl<'a, T> DoubleEndedIterator for ChunksExact<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);\n            self.v = fst;\n            Some(snd)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let len = self.len();\n        if n >= len {\n            self.v = &[];\n            None\n        } else {\n            let start = (len - 1 - n) * self.chunk_size;\n            let end = start + self.chunk_size;\n            let nth_back = &self.v[start..end];\n            self.v = &self.v[..start];\n            Some(nth_back)\n        }\n    }\n}\n\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\nimpl<T> ExactSizeIterator for ChunksExact<'_, T> {\n    fn is_empty(&self) -> bool {\n        self.v.is_empty()\n    }\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for ChunksExact<'_, T> {}\n\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\nimpl<T> FusedIterator for ChunksExact<'_, T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n/// elements at a time), starting at the beginning of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last up to\n/// `chunk_size-1` elements will be omitted but can be retrieved from the\n/// [`into_remainder`] function from the iterator.\n///\n/// This struct is created by the [`chunks_exact_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let mut slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.chunks_exact_mut(2);\n/// ```\n///\n/// [`chunks_exact_mut`]: slice::chunks_exact_mut\n/// [`into_remainder`]: ChunksExactMut::into_remainder\n/// [slices]: slice\n#[derive(Debug)]\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\npub struct ChunksExactMut<'a, T: 'a> {\n    v: &'a mut [T],\n    rem: &'a mut [T],\n    chunk_size: usize,\n}\n\nimpl<'a, T> ChunksExactMut<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {\n        let rem = slice.len() % chunk_size;\n        let fst_len = slice.len() - rem;\n        // SAFETY: 0 <= fst_len <= slice.len() by construction above\n        let (fst, snd) = unsafe { slice.split_at_mut_unchecked(fst_len) };\n        Self { v: fst, rem: snd, chunk_size }\n    }\n\n    /// Returns the remainder of the original slice that is not going to be\n    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n    /// elements.\n    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n    pub fn into_remainder(self) -> &'a mut [T] {\n        self.rem\n    }\n}\n\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\nimpl<'a, T> Iterator for ChunksExactMut<'a, T> {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n            self.v = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.v.len() / self.chunk_size;\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n        if start >= self.v.len() || overflow {\n            self.v = &mut [];\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (_, snd) = tmp.split_at_mut(start);\n            self.v = snd;\n            self.next()\n        }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        let start = idx * self.chunk_size;\n        // SAFETY: see comments for `ChunksMut::__iterator_get_unchecked`.\n        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n    }\n}\n\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\nimpl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n            self.v = head;\n            Some(tail)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let len = self.len();\n        if n >= len {\n            self.v = &mut [];\n            None\n        } else {\n            let start = (len - 1 - n) * self.chunk_size;\n            let end = start + self.chunk_size;\n            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n            let (head, nth_back) = temp.split_at_mut(start);\n            self.v = head;\n            Some(nth_back)\n        }\n    }\n}\n\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\nimpl<T> ExactSizeIterator for ChunksExactMut<'_, T> {\n    fn is_empty(&self) -> bool {\n        self.v.is_empty()\n    }\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for ChunksExactMut<'_, T> {}\n\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\nimpl<T> FusedIterator for ChunksExactMut<'_, T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// A windowed iterator over a slice in overlapping chunks (`N` elements at a\n/// time), starting at the beginning of the slice\n///\n/// This struct is created by the [`array_windows`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// #![feature(array_windows)]\n///\n/// let slice = [0, 1, 2, 3];\n/// let iter = slice.array_windows::<2>();\n/// ```\n///\n/// [`array_windows`]: slice::array_windows\n/// [slices]: slice\n#[derive(Debug, Clone, Copy)]\n#[unstable(feature = \"array_windows\", issue = \"75027\")]\npub struct ArrayWindows<'a, T: 'a, const N: usize> {\n    slice_head: *const T,\n    num: usize,\n    marker: PhantomData<&'a [T; N]>,\n}\n\nimpl<'a, T: 'a, const N: usize> ArrayWindows<'a, T, N> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T]) -> Self {\n        let num_windows = slice.len().saturating_sub(N - 1);\n        Self { slice_head: slice.as_ptr(), num: num_windows, marker: PhantomData }\n    }\n}\n\n#[unstable(feature = \"array_windows\", issue = \"75027\")]\nimpl<'a, T, const N: usize> Iterator for ArrayWindows<'a, T, N> {\n    type Item = &'a [T; N];\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.num == 0 {\n            return None;\n        }\n        // SAFETY:\n        // This is safe because it's indexing into a slice guaranteed to be length > N.\n        let ret = unsafe { &*self.slice_head.cast::<[T; N]>() };\n        // SAFETY: Guaranteed that there are at least 1 item remaining otherwise\n        // earlier branch would've been hit\n        self.slice_head = unsafe { self.slice_head.add(1) };\n\n        self.num -= 1;\n        Some(ret)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.num, Some(self.num))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.num\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        if self.num <= n {\n            self.num = 0;\n            return None;\n        }\n        // SAFETY:\n        // This is safe because it's indexing into a slice guaranteed to be length > N.\n        let ret = unsafe { &*self.slice_head.add(n).cast::<[T; N]>() };\n        // SAFETY: Guaranteed that there are at least n items remaining\n        self.slice_head = unsafe { self.slice_head.add(n + 1) };\n\n        self.num -= n + 1;\n        Some(ret)\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.nth(self.num.checked_sub(1)?)\n    }\n}\n\n#[unstable(feature = \"array_windows\", issue = \"75027\")]\nimpl<'a, T, const N: usize> DoubleEndedIterator for ArrayWindows<'a, T, N> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T; N]> {\n        if self.num == 0 {\n            return None;\n        }\n        // SAFETY: Guaranteed that there are n items remaining, n-1 for 0-indexing.\n        let ret = unsafe { &*self.slice_head.add(self.num - 1).cast::<[T; N]>() };\n        self.num -= 1;\n        Some(ret)\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<&'a [T; N]> {\n        if self.num <= n {\n            self.num = 0;\n            return None;\n        }\n        // SAFETY: Guaranteed that there are n items remaining, n-1 for 0-indexing.\n        let ret = unsafe { &*self.slice_head.add(self.num - (n + 1)).cast::<[T; N]>() };\n        self.num -= n + 1;\n        Some(ret)\n    }\n}\n\n#[unstable(feature = \"array_windows\", issue = \"75027\")]\nimpl<T, const N: usize> ExactSizeIterator for ArrayWindows<'_, T, N> {\n    fn is_empty(&self) -> bool {\n        self.num == 0\n    }\n}\n\n/// An iterator over a slice in (non-overlapping) chunks (`N` elements at a\n/// time), starting at the beginning of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last\n/// up to `N-1` elements will be omitted but can be retrieved from\n/// the [`remainder`] function from the iterator.\n///\n/// This struct is created by the [`array_chunks`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// #![feature(array_chunks)]\n///\n/// let slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.array_chunks::<2>();\n/// ```\n///\n/// [`array_chunks`]: slice::array_chunks\n/// [`remainder`]: ArrayChunks::remainder\n/// [slices]: slice\n#[derive(Debug)]\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\npub struct ArrayChunks<'a, T: 'a, const N: usize> {\n    iter: Iter<'a, [T; N]>,\n    rem: &'a [T],\n}\n\nimpl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T]) -> Self {\n        let (array_slice, rem) = slice.as_chunks();\n        Self { iter: array_slice.iter(), rem }\n    }\n\n    /// Returns the remainder of the original slice that is not going to be\n    /// returned by the iterator. The returned slice has at most `N-1`\n    /// elements.\n    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n    pub fn remainder(&self) -> &'a [T] {\n        self.rem\n    }\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nimpl<T, const N: usize> Clone for ArrayChunks<'_, T, N> {\n    fn clone(&self) -> Self {\n        ArrayChunks { iter: self.iter.clone(), rem: self.rem }\n    }\n}\n\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nimpl<'a, T, const N: usize> Iterator for ArrayChunks<'a, T, N> {\n    type Item = &'a [T; N];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T; N]> {\n        self.iter.next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        self.iter.nth(n)\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        self.iter.last()\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n        // SAFETY: The safety guarantees of `__iterator_get_unchecked` are\n        // transferred to the caller.\n        unsafe { self.iter.__iterator_get_unchecked(i) }\n    }\n}\n\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nimpl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunks<'a, T, N> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T; N]> {\n        self.iter.next_back()\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        self.iter.nth_back(n)\n    }\n}\n\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nimpl<T, const N: usize> ExactSizeIterator for ArrayChunks<'_, T, N> {\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T, const N: usize> TrustedLen for ArrayChunks<'_, T, N> {}\n\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nimpl<T, const N: usize> FusedIterator for ArrayChunks<'_, T, N> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nunsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over a slice in (non-overlapping) mutable chunks (`N` elements\n/// at a time), starting at the beginning of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last\n/// up to `N-1` elements will be omitted but can be retrieved from\n/// the [`into_remainder`] function from the iterator.\n///\n/// This struct is created by the [`array_chunks_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// #![feature(array_chunks)]\n///\n/// let mut slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.array_chunks_mut::<2>();\n/// ```\n///\n/// [`array_chunks_mut`]: slice::array_chunks_mut\n/// [`into_remainder`]: ../../std/slice/struct.ArrayChunksMut.html#method.into_remainder\n/// [slices]: slice\n#[derive(Debug)]\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\npub struct ArrayChunksMut<'a, T: 'a, const N: usize> {\n    iter: IterMut<'a, [T; N]>,\n    rem: &'a mut [T],\n}\n\nimpl<'a, T, const N: usize> ArrayChunksMut<'a, T, N> {\n    #[inline]\n    pub(super) fn new(slice: &'a mut [T]) -> Self {\n        let (array_slice, rem) = slice.as_chunks_mut();\n        Self { iter: array_slice.iter_mut(), rem }\n    }\n\n    /// Returns the remainder of the original slice that is not going to be\n    /// returned by the iterator. The returned slice has at most `N-1`\n    /// elements.\n    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n    pub fn into_remainder(self) -> &'a mut [T] {\n        self.rem\n    }\n}\n\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nimpl<'a, T, const N: usize> Iterator for ArrayChunksMut<'a, T, N> {\n    type Item = &'a mut [T; N];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T; N]> {\n        self.iter.next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.iter.count()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        self.iter.nth(n)\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        self.iter.last()\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> &'a mut [T; N] {\n        // SAFETY: The safety guarantees of `__iterator_get_unchecked` are transferred to\n        // the caller.\n        unsafe { self.iter.__iterator_get_unchecked(i) }\n    }\n}\n\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nimpl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunksMut<'a, T, N> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T; N]> {\n        self.iter.next_back()\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        self.iter.nth_back(n)\n    }\n}\n\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nimpl<T, const N: usize> ExactSizeIterator for ArrayChunksMut<'_, T, N> {\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T, const N: usize> TrustedLen for ArrayChunksMut<'_, T, N> {}\n\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nimpl<T, const N: usize> FusedIterator for ArrayChunksMut<'_, T, N> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\nunsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunksMut<'a, T, N> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n/// time), starting at the end of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last slice\n/// of the iteration will be the remainder.\n///\n/// This struct is created by the [`rchunks`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.rchunks(2);\n/// ```\n///\n/// [`rchunks`]: slice::rchunks\n/// [slices]: slice\n#[derive(Debug)]\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\npub struct RChunks<'a, T: 'a> {\n    v: &'a [T],\n    chunk_size: usize,\n}\n\nimpl<'a, T: 'a> RChunks<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n        Self { v: slice, chunk_size: size }\n    }\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<T> Clone for RChunks<'_, T> {\n    fn clone(&self) -> Self {\n        RChunks { v: self.v, chunk_size: self.chunk_size }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> Iterator for RChunks<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n            let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n            self.v = fst;\n            Some(snd)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.v.is_empty() {\n            (0, Some(0))\n        } else {\n            let n = self.v.len() / self.chunk_size;\n            let rem = self.v.len() % self.chunk_size;\n            let n = if rem > 0 { n + 1 } else { n };\n            (n, Some(n))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n        if end >= self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            // Can't underflow because of the check above\n            let end = self.v.len() - end;\n            let start = match end.checked_sub(self.chunk_size) {\n                Some(sum) => sum,\n                None => 0,\n            };\n            let nth = &self.v[start..end];\n            self.v = &self.v[0..start];\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let rem = self.v.len() % self.chunk_size;\n            let end = if rem == 0 { self.chunk_size } else { rem };\n            Some(&self.v[0..end])\n        }\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        let end = self.v.len() - idx * self.chunk_size;\n        let start = match end.checked_sub(self.chunk_size) {\n            None => 0,\n            Some(start) => start,\n        };\n        // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.\n        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> DoubleEndedIterator for RChunks<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let remainder = self.v.len() % self.chunk_size;\n            let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n            let (fst, snd) = self.v.split_at(chunksz);\n            self.v = snd;\n            Some(fst)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let len = self.len();\n        if n >= len {\n            self.v = &[];\n            None\n        } else {\n            // can't underflow because `n < len`\n            let offset_from_end = (len - 1 - n) * self.chunk_size;\n            let end = self.v.len() - offset_from_end;\n            let start = end.saturating_sub(self.chunk_size);\n            let nth_back = &self.v[start..end];\n            self.v = &self.v[end..];\n            Some(nth_back)\n        }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<T> ExactSizeIterator for RChunks<'_, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for RChunks<'_, T> {}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<T> FusedIterator for RChunks<'_, T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n/// elements at a time), starting at the end of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last slice\n/// of the iteration will be the remainder.\n///\n/// This struct is created by the [`rchunks_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let mut slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.rchunks_mut(2);\n/// ```\n///\n/// [`rchunks_mut`]: slice::rchunks_mut\n/// [slices]: slice\n#[derive(Debug)]\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\npub struct RChunksMut<'a, T: 'a> {\n    v: &'a mut [T],\n    chunk_size: usize,\n}\n\nimpl<'a, T: 'a> RChunksMut<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n        Self { v: slice, chunk_size: size }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> Iterator for RChunksMut<'a, T> {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let sz = cmp::min(self.v.len(), self.chunk_size);\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n            self.v = head;\n            Some(tail)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.v.is_empty() {\n            (0, Some(0))\n        } else {\n            let n = self.v.len() / self.chunk_size;\n            let rem = self.v.len() % self.chunk_size;\n            let n = if rem > 0 { n + 1 } else { n };\n            (n, Some(n))\n        }\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n        if end >= self.v.len() || overflow {\n            self.v = &mut [];\n            None\n        } else {\n            // Can't underflow because of the check above\n            let end = self.v.len() - end;\n            let start = match end.checked_sub(self.chunk_size) {\n                Some(sum) => sum,\n                None => 0,\n            };\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(start);\n            let (nth, _) = tail.split_at_mut(end - start);\n            self.v = head;\n            Some(nth)\n        }\n    }\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let rem = self.v.len() % self.chunk_size;\n            let end = if rem == 0 { self.chunk_size } else { rem };\n            Some(&mut self.v[0..end])\n        }\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        let end = self.v.len() - idx * self.chunk_size;\n        let start = match end.checked_sub(self.chunk_size) {\n            None => 0,\n            Some(start) => start,\n        };\n        // SAFETY: see comments for `RChunks::__iterator_get_unchecked` and\n        // `ChunksMut::__iterator_get_unchecked`\n        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let remainder = self.v.len() % self.chunk_size;\n            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(sz);\n            self.v = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let len = self.len();\n        if n >= len {\n            self.v = &mut [];\n            None\n        } else {\n            // can't underflow because `n < len`\n            let offset_from_end = (len - 1 - n) * self.chunk_size;\n            let end = self.v.len() - offset_from_end;\n            let start = end.saturating_sub(self.chunk_size);\n            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n            let (_, nth_back) = tmp.split_at_mut(start);\n            self.v = tail;\n            Some(nth_back)\n        }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<T> ExactSizeIterator for RChunksMut<'_, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for RChunksMut<'_, T> {}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<T> FusedIterator for RChunksMut<'_, T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n/// time), starting at the end of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last\n/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n/// the [`remainder`] function from the iterator.\n///\n/// This struct is created by the [`rchunks_exact`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.rchunks_exact(2);\n/// ```\n///\n/// [`rchunks_exact`]: slice::rchunks_exact\n/// [`remainder`]: ChunksExact::remainder\n/// [slices]: slice\n#[derive(Debug)]\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\npub struct RChunksExact<'a, T: 'a> {\n    v: &'a [T],\n    rem: &'a [T],\n    chunk_size: usize,\n}\n\nimpl<'a, T> RChunksExact<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {\n        let rem = slice.len() % chunk_size;\n        // SAFETY: 0 <= rem <= slice.len() by construction above\n        let (fst, snd) = unsafe { slice.split_at_unchecked(rem) };\n        Self { v: snd, rem: fst, chunk_size }\n    }\n\n    /// Returns the remainder of the original slice that is not going to be\n    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n    /// elements.\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    pub fn remainder(&self) -> &'a [T] {\n        self.rem\n    }\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> Clone for RChunksExact<'a, T> {\n    fn clone(&self) -> RChunksExact<'a, T> {\n        RChunksExact { v: self.v, rem: self.rem, chunk_size: self.chunk_size }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> Iterator for RChunksExact<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);\n            self.v = fst;\n            Some(snd)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.v.len() / self.chunk_size;\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n        if end >= self.v.len() || overflow {\n            self.v = &[];\n            None\n        } else {\n            let (fst, _) = self.v.split_at(self.v.len() - end);\n            self.v = fst;\n            self.next()\n        }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        let end = self.v.len() - idx * self.chunk_size;\n        let start = end - self.chunk_size;\n        // SAFETY:\n        // SAFETY: mostmy identical to `Chunks::__iterator_get_unchecked`.\n        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> DoubleEndedIterator for RChunksExact<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let (fst, snd) = self.v.split_at(self.chunk_size);\n            self.v = snd;\n            Some(fst)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let len = self.len();\n        if n >= len {\n            self.v = &[];\n            None\n        } else {\n            // now that we know that `n` corresponds to a chunk,\n            // none of these operations can underflow/overflow\n            let offset = (len - n) * self.chunk_size;\n            let start = self.v.len() - offset;\n            let end = start + self.chunk_size;\n            let nth_back = &self.v[start..end];\n            self.v = &self.v[end..];\n            Some(nth_back)\n        }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> ExactSizeIterator for RChunksExact<'a, T> {\n    fn is_empty(&self) -> bool {\n        self.v.is_empty()\n    }\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for RChunksExact<'_, T> {}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<T> FusedIterator for RChunksExact<'_, T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n/// elements at a time), starting at the end of the slice.\n///\n/// When the slice len is not evenly divided by the chunk size, the last up to\n/// `chunk_size-1` elements will be omitted but can be retrieved from the\n/// [`into_remainder`] function from the iterator.\n///\n/// This struct is created by the [`rchunks_exact_mut`] method on [slices].\n///\n/// # Example\n///\n/// ```\n/// let mut slice = ['l', 'o', 'r', 'e', 'm'];\n/// let iter = slice.rchunks_exact_mut(2);\n/// ```\n///\n/// [`rchunks_exact_mut`]: slice::rchunks_exact_mut\n/// [`into_remainder`]: ChunksExactMut::into_remainder\n/// [slices]: slice\n#[derive(Debug)]\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\npub struct RChunksExactMut<'a, T: 'a> {\n    v: &'a mut [T],\n    rem: &'a mut [T],\n    chunk_size: usize,\n}\n\nimpl<'a, T> RChunksExactMut<'a, T> {\n    #[inline]\n    pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {\n        let rem = slice.len() % chunk_size;\n        // SAFETY: 0 <= rem <= slice.len() by construction above\n        let (fst, snd) = unsafe { slice.split_at_mut_unchecked(rem) };\n        Self { v: snd, rem: fst, chunk_size }\n    }\n\n    /// Returns the remainder of the original slice that is not going to be\n    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n    /// elements.\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    pub fn into_remainder(self) -> &'a mut [T] {\n        self.rem\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> Iterator for RChunksExactMut<'a, T> {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n            self.v = head;\n            Some(tail)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.v.len() / self.chunk_size;\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n        if end >= self.v.len() || overflow {\n            self.v = &mut [];\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let tmp_len = tmp.len();\n            let (fst, _) = tmp.split_at_mut(tmp_len - end);\n            self.v = fst;\n            self.next()\n        }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        let end = self.v.len() - idx * self.chunk_size;\n        let start = end - self.chunk_size;\n        // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked`.\n        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let tmp = mem::replace(&mut self.v, &mut []);\n            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n            self.v = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let len = self.len();\n        if n >= len {\n            self.v = &mut [];\n            None\n        } else {\n            // now that we know that `n` corresponds to a chunk,\n            // none of these operations can underflow/overflow\n            let offset = (len - n) * self.chunk_size;\n            let start = self.v.len() - offset;\n            let end = start + self.chunk_size;\n            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n            let (_, nth_back) = tmp.split_at_mut(start);\n            self.v = tail;\n            Some(nth_back)\n        }\n    }\n}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<T> ExactSizeIterator for RChunksExactMut<'_, T> {\n    fn is_empty(&self) -> bool {\n        self.v.is_empty()\n    }\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for RChunksExactMut<'_, T> {}\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\nimpl<T> FusedIterator for RChunksExactMut<'_, T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\nunsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n/// An iterator over slice in (non-overlapping) chunks separated by a predicate.\n///\n/// This struct is created by the [`group_by`] method on [slices].\n///\n/// [`group_by`]: slice::group_by\n/// [slices]: slice\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\npub struct GroupBy<'a, T: 'a, P> {\n    slice: &'a [T],\n    predicate: P,\n}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a, P> GroupBy<'a, T, P> {\n    pub(super) fn new(slice: &'a [T], predicate: P) -> Self {\n        GroupBy { slice, predicate }\n    }\n}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a, P> Iterator for GroupBy<'a, T, P>\nwhere\n    P: FnMut(&T, &T) -> bool,\n{\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.slice.is_empty() {\n            None\n        } else {\n            let mut len = 1;\n            let mut iter = self.slice.windows(2);\n            while let Some([l, r]) = iter.next() {\n                if (self.predicate)(l, r) { len += 1 } else { break }\n            }\n            let (head, tail) = self.slice.split_at(len);\n            self.slice = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.slice.is_empty() { (0, Some(0)) } else { (1, Some(self.slice.len())) }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a, P> DoubleEndedIterator for GroupBy<'a, T, P>\nwhere\n    P: FnMut(&T, &T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.slice.is_empty() {\n            None\n        } else {\n            let mut len = 1;\n            let mut iter = self.slice.windows(2);\n            while let Some([l, r]) = iter.next_back() {\n                if (self.predicate)(l, r) { len += 1 } else { break }\n            }\n            let (head, tail) = self.slice.split_at(self.slice.len() - len);\n            self.slice = head;\n            Some(tail)\n        }\n    }\n}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a, P> FusedIterator for GroupBy<'a, T, P> where P: FnMut(&T, &T) -> bool {}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for GroupBy<'a, T, P> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"GroupBy\").field(\"slice\", &self.slice).finish()\n    }\n}\n\n/// An iterator over slice in (non-overlapping) mutable chunks separated\n/// by a predicate.\n///\n/// This struct is created by the [`group_by_mut`] method on [slices].\n///\n/// [`group_by_mut`]: slice::group_by_mut\n/// [slices]: slice\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\npub struct GroupByMut<'a, T: 'a, P> {\n    slice: &'a mut [T],\n    predicate: P,\n}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a, P> GroupByMut<'a, T, P> {\n    pub(super) fn new(slice: &'a mut [T], predicate: P) -> Self {\n        GroupByMut { slice, predicate }\n    }\n}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a, P> Iterator for GroupByMut<'a, T, P>\nwhere\n    P: FnMut(&T, &T) -> bool,\n{\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.slice.is_empty() {\n            None\n        } else {\n            let mut len = 1;\n            let mut iter = self.slice.windows(2);\n            while let Some([l, r]) = iter.next() {\n                if (self.predicate)(l, r) { len += 1 } else { break }\n            }\n            let slice = mem::take(&mut self.slice);\n            let (head, tail) = slice.split_at_mut(len);\n            self.slice = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.slice.is_empty() { (0, Some(0)) } else { (1, Some(self.slice.len())) }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a, P> DoubleEndedIterator for GroupByMut<'a, T, P>\nwhere\n    P: FnMut(&T, &T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.slice.is_empty() {\n            None\n        } else {\n            let mut len = 1;\n            let mut iter = self.slice.windows(2);\n            while let Some([l, r]) = iter.next_back() {\n                if (self.predicate)(l, r) { len += 1 } else { break }\n            }\n            let slice = mem::take(&mut self.slice);\n            let (head, tail) = slice.split_at_mut(slice.len() - len);\n            self.slice = head;\n            Some(tail)\n        }\n    }\n}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a, P> FusedIterator for GroupByMut<'a, T, P> where P: FnMut(&T, &T) -> bool {}\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\nimpl<'a, T: 'a + fmt::Debug, P> fmt::Debug for GroupByMut<'a, T, P> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"GroupByMut\").field(\"slice\", &self.slice).finish()\n    }\n}\n"],[2851,"//! Free functions to create `&[T]` and `&mut [T]`.\n\nuse crate::array;\nuse crate::intrinsics::is_aligned_and_not_null;\nuse crate::mem;\nuse crate::ptr;\n\n/// Forms a slice from a pointer and a length.\n///\n/// The `len` argument is the number of **elements**, not the number of bytes.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `data` must be [valid] for reads for `len * mem::size_of::<T>()` many bytes,\n///   and it must be properly aligned. This means in particular:\n///\n///     * The entire memory range of this slice must be contained within a single allocated object!\n///       Slices can never span across multiple allocated objects. See [below](#incorrect-usage)\n///       for an example incorrectly not taking this into account.\n///     * `data` must be non-null and aligned even for zero-length slices. One\n///       reason for this is that enum layout optimizations may rely on references\n///       (including slices of any length) being aligned and non-null to distinguish\n///       them from other data. You can obtain a pointer that is usable as `data`\n///       for zero-length slices using [`NonNull::dangling()`].\n///\n/// * `data` must point to `len` consecutive properly initialized values of type `T`.\n///\n/// * The memory referenced by the returned slice must not be mutated for the duration\n///   of lifetime `'a`, except inside an `UnsafeCell`.\n///\n/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n///   See the safety documentation of [`pointer::offset`].\n///\n/// # Caveat\n///\n/// The lifetime for the returned slice is inferred from its usage. To\n/// prevent accidental misuse, it's suggested to tie the lifetime to whichever\n/// source lifetime is safe in the context, such as by providing a helper\n/// function taking the lifetime of a host value for the slice, or by explicit\n/// annotation.\n///\n/// # Examples\n///\n/// ```\n/// use std::slice;\n///\n/// // manifest a slice for a single element\n/// let x = 42;\n/// let ptr = &x as *const _;\n/// let slice = unsafe { slice::from_raw_parts(ptr, 1) };\n/// assert_eq!(slice[0], 42);\n/// ```\n///\n/// ### Incorrect usage\n///\n/// The following `join_slices` function is **unsound** ⚠️\n///\n/// ```rust,no_run\n/// use std::slice;\n///\n/// fn join_slices<'a, T>(fst: &'a [T], snd: &'a [T]) -> &'a [T] {\n///     let fst_end = fst.as_ptr().wrapping_add(fst.len());\n///     let snd_start = snd.as_ptr();\n///     assert_eq!(fst_end, snd_start, \"Slices must be contiguous!\");\n///     unsafe {\n///         // The assertion above ensures `fst` and `snd` are contiguous, but they might\n///         // still be contained within _different allocated objects_, in which case\n///         // creating this slice is undefined behavior.\n///         slice::from_raw_parts(fst.as_ptr(), fst.len() + snd.len())\n///     }\n/// }\n///\n/// fn main() {\n///     // `a` and `b` are different allocated objects...\n///     let a = 42;\n///     let b = 27;\n///     // ... which may nevertheless be laid out contiguously in memory: | a | b |\n///     let _ = join_slices(slice::from_ref(&a), slice::from_ref(&b)); // UB\n/// }\n/// ```\n///\n/// [valid]: ptr#safety\n/// [`NonNull::dangling()`]: ptr::NonNull::dangling\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n    debug_assert!(\n        mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n        \"attempt to create slice covering at least half the address space\"\n    );\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe { &*ptr::slice_from_raw_parts(data, len) }\n}\n\n/// Performs the same functionality as [`from_raw_parts`], except that a\n/// mutable slice is returned.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `data` must be [valid] for both reads and writes for `len * mem::size_of::<T>()` many bytes,\n///   and it must be properly aligned. This means in particular:\n///\n///     * The entire memory range of this slice must be contained within a single allocated object!\n///       Slices can never span across multiple allocated objects.\n///     * `data` must be non-null and aligned even for zero-length slices. One\n///       reason for this is that enum layout optimizations may rely on references\n///       (including slices of any length) being aligned and non-null to distinguish\n///       them from other data. You can obtain a pointer that is usable as `data`\n///       for zero-length slices using [`NonNull::dangling()`].\n///\n/// * `data` must point to `len` consecutive properly initialized values of type `T`.\n///\n/// * The memory referenced by the returned slice must not be accessed through any other pointer\n///   (not derived from the return value) for the duration of lifetime `'a`.\n///   Both read and write accesses are forbidden.\n///\n/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n///   See the safety documentation of [`pointer::offset`].\n///\n/// [valid]: ptr#safety\n/// [`NonNull::dangling()`]: ptr::NonNull::dangling\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n    debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n    debug_assert!(\n        mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n        \"attempt to create slice covering at least half the address space\"\n    );\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n    unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n}\n\n/// Converts a reference to T into a slice of length 1 (without copying).\n#[stable(feature = \"from_ref\", since = \"1.28.0\")]\npub fn from_ref<T>(s: &T) -> &[T] {\n    array::from_ref(s)\n}\n\n/// Converts a reference to T into a slice of length 1 (without copying).\n#[stable(feature = \"from_ref\", since = \"1.28.0\")]\npub fn from_mut<T>(s: &mut T) -> &mut [T] {\n    array::from_mut(s)\n}\n"],[2852,"use crate::mem::{size_of, transmute_copy};\nuse crate::ptr::write_bytes;\n\npub(super) trait SpecFill<T> {\n    fn spec_fill(&mut self, value: T);\n}\n\nimpl<T: Clone> SpecFill<T> for [T] {\n    default fn spec_fill(&mut self, value: T) {\n        if let Some((last, elems)) = self.split_last_mut() {\n            for el in elems {\n                el.clone_from(&value);\n            }\n\n            *last = value\n        }\n    }\n}\n\nimpl<T: Copy> SpecFill<T> for [T] {\n    fn spec_fill(&mut self, value: T) {\n        if size_of::<T>() == 1 {\n            // SAFETY: The size_of check above ensures that values are 1 byte wide, as required\n            // for the transmute and write_bytes\n            unsafe {\n                let value: u8 = transmute_copy(&value);\n                write_bytes(self.as_mut_ptr(), value, self.len());\n            }\n        } else {\n            for item in self.iter_mut() {\n                *item = value;\n            }\n        }\n    }\n}\n"],[2853,"//! Slice sorting\n//!\n//! This module contains a sorting algorithm based on Orson Peters' pattern-defeating quicksort,\n//! published at: <https://github.com/orlp/pdqsort>\n//!\n//! Unstable sorting is compatible with libcore because it doesn't allocate memory, unlike our\n//! stable sorting implementation.\n\n// ignore-tidy-undocumented-unsafe\n\nuse crate::cmp;\nuse crate::mem::{self, MaybeUninit};\nuse crate::ptr;\n\n/// When dropped, copies from `src` into `dest`.\nstruct CopyOnDrop<T> {\n    src: *mut T,\n    dest: *mut T,\n}\n\nimpl<T> Drop for CopyOnDrop<T> {\n    fn drop(&mut self) {\n        // SAFETY:  This is a helper class.\n        //          Please refer to its usage for correctness.\n        //          Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n        unsafe {\n            ptr::copy_nonoverlapping(self.src, self.dest, 1);\n        }\n    }\n}\n\n/// Shifts the first element to the right until it encounters a greater or equal element.\nfn shift_head<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    let len = v.len();\n    // SAFETY: The unsafe operations below involves indexing without a bound check (`get_unchecked` and `get_unchecked_mut`)\n    // and copying memory (`ptr::copy_nonoverlapping`).\n    //\n    // a. Indexing:\n    //  1. We checked the size of the array to >=2.\n    //  2. All the indexing that we will do is always between {0 <= index < len} at most.\n    //\n    // b. Memory copying\n    //  1. We are obtaining pointers to references which are guaranteed to be valid.\n    //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n    //     Namely, `i` and `i-1`.\n    //  3. If the slice is properly aligned, the elements are properly aligned.\n    //     It is the caller's responsibility to make sure the slice is properly aligned.\n    //\n    // See comments below for further detail.\n    unsafe {\n        // If the first two elements are out-of-order...\n        if len >= 2 && is_less(v.get_unchecked(1), v.get_unchecked(0)) {\n            // Read the first element into a stack-allocated variable. If a following comparison\n            // operation panics, `hole` will get dropped and automatically write the element back\n            // into the slice.\n            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.get_unchecked_mut(1) };\n            ptr::copy_nonoverlapping(v.get_unchecked(1), v.get_unchecked_mut(0), 1);\n\n            for i in 2..len {\n                if !is_less(v.get_unchecked(i), &*tmp) {\n                    break;\n                }\n\n                // Move `i`-th element one place to the left, thus shifting the hole to the right.\n                ptr::copy_nonoverlapping(v.get_unchecked(i), v.get_unchecked_mut(i - 1), 1);\n                hole.dest = v.get_unchecked_mut(i);\n            }\n            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n        }\n    }\n}\n\n/// Shifts the last element to the left until it encounters a smaller or equal element.\nfn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    let len = v.len();\n    // SAFETY: The unsafe operations below involves indexing without a bound check (`get_unchecked` and `get_unchecked_mut`)\n    // and copying memory (`ptr::copy_nonoverlapping`).\n    //\n    // a. Indexing:\n    //  1. We checked the size of the array to >= 2.\n    //  2. All the indexing that we will do is always between `0 <= index < len-1` at most.\n    //\n    // b. Memory copying\n    //  1. We are obtaining pointers to references which are guaranteed to be valid.\n    //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n    //     Namely, `i` and `i+1`.\n    //  3. If the slice is properly aligned, the elements are properly aligned.\n    //     It is the caller's responsibility to make sure the slice is properly aligned.\n    //\n    // See comments below for further detail.\n    unsafe {\n        // If the last two elements are out-of-order...\n        if len >= 2 && is_less(v.get_unchecked(len - 1), v.get_unchecked(len - 2)) {\n            // Read the last element into a stack-allocated variable. If a following comparison\n            // operation panics, `hole` will get dropped and automatically write the element back\n            // into the slice.\n            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.get_unchecked_mut(len - 2) };\n            ptr::copy_nonoverlapping(v.get_unchecked(len - 2), v.get_unchecked_mut(len - 1), 1);\n\n            for i in (0..len - 2).rev() {\n                if !is_less(&*tmp, v.get_unchecked(i)) {\n                    break;\n                }\n\n                // Move `i`-th element one place to the right, thus shifting the hole to the left.\n                ptr::copy_nonoverlapping(v.get_unchecked(i), v.get_unchecked_mut(i + 1), 1);\n                hole.dest = v.get_unchecked_mut(i);\n            }\n            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n        }\n    }\n}\n\n/// Partially sorts a slice by shifting several out-of-order elements around.\n///\n/// Returns `true` if the slice is sorted at the end. This function is *O*(*n*) worst-case.\n#[cold]\nfn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    // Maximum number of adjacent out-of-order pairs that will get shifted.\n    const MAX_STEPS: usize = 5;\n    // If the slice is shorter than this, don't shift any elements.\n    const SHORTEST_SHIFTING: usize = 50;\n\n    let len = v.len();\n    let mut i = 1;\n\n    for _ in 0..MAX_STEPS {\n        // SAFETY: We already explicitly did the bound checking with `i < len`.\n        // All our subsequent indexing is only in the range `0 <= index < len`\n        unsafe {\n            // Find the next pair of adjacent out-of-order elements.\n            while i < len && !is_less(v.get_unchecked(i), v.get_unchecked(i - 1)) {\n                i += 1;\n            }\n        }\n\n        // Are we done?\n        if i == len {\n            return true;\n        }\n\n        // Don't shift elements on short arrays, that has a performance cost.\n        if len < SHORTEST_SHIFTING {\n            return false;\n        }\n\n        // Swap the found pair of elements. This puts them in correct order.\n        v.swap(i - 1, i);\n\n        // Shift the smaller element to the left.\n        shift_tail(&mut v[..i], is_less);\n        // Shift the greater element to the right.\n        shift_head(&mut v[i..], is_less);\n    }\n\n    // Didn't manage to sort the slice in the limited number of steps.\n    false\n}\n\n/// Sorts a slice using insertion sort, which is *O*(*n*^2) worst-case.\nfn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    for i in 1..v.len() {\n        shift_tail(&mut v[..i + 1], is_less);\n    }\n}\n\n/// Sorts `v` using heapsort, which guarantees *O*(*n* \\* log(*n*)) worst-case.\n#[cold]\n#[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"none\")]\npub fn heapsort<T, F>(v: &mut [T], mut is_less: F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    // This binary heap respects the invariant `parent >= child`.\n    let mut sift_down = |v: &mut [T], mut node| {\n        loop {\n            // Children of `node`:\n            let left = 2 * node + 1;\n            let right = 2 * node + 2;\n\n            // Choose the greater child.\n            let greater =\n                if right < v.len() && is_less(&v[left], &v[right]) { right } else { left };\n\n            // Stop if the invariant holds at `node`.\n            if greater >= v.len() || !is_less(&v[node], &v[greater]) {\n                break;\n            }\n\n            // Swap `node` with the greater child, move one step down, and continue sifting.\n            v.swap(node, greater);\n            node = greater;\n        }\n    };\n\n    // Build the heap in linear time.\n    for i in (0..v.len() / 2).rev() {\n        sift_down(v, i);\n    }\n\n    // Pop maximal elements from the heap.\n    for i in (1..v.len()).rev() {\n        v.swap(0, i);\n        sift_down(&mut v[..i], 0);\n    }\n}\n\n/// Partitions `v` into elements smaller than `pivot`, followed by elements greater than or equal\n/// to `pivot`.\n///\n/// Returns the number of elements smaller than `pivot`.\n///\n/// Partitioning is performed block-by-block in order to minimize the cost of branching operations.\n/// This idea is presented in the [BlockQuicksort][pdf] paper.\n///\n/// [pdf]: https://drops.dagstuhl.de/opus/volltexte/2016/6389/pdf/LIPIcs-ESA-2016-38.pdf\nfn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    // Number of elements in a typical block.\n    const BLOCK: usize = 128;\n\n    // The partitioning algorithm repeats the following steps until completion:\n    //\n    // 1. Trace a block from the left side to identify elements greater than or equal to the pivot.\n    // 2. Trace a block from the right side to identify elements smaller than the pivot.\n    // 3. Exchange the identified elements between the left and right side.\n    //\n    // We keep the following variables for a block of elements:\n    //\n    // 1. `block` - Number of elements in the block.\n    // 2. `start` - Start pointer into the `offsets` array.\n    // 3. `end` - End pointer into the `offsets` array.\n    // 4. `offsets - Indices of out-of-order elements within the block.\n\n    // The current block on the left side (from `l` to `l.add(block_l)`).\n    let mut l = v.as_mut_ptr();\n    let mut block_l = BLOCK;\n    let mut start_l = ptr::null_mut();\n    let mut end_l = ptr::null_mut();\n    let mut offsets_l = [MaybeUninit::<u8>::uninit(); BLOCK];\n\n    // The current block on the right side (from `r.sub(block_r)` to `r`).\n    // SAFETY: The documentation for .add() specifically mention that `vec.as_ptr().add(vec.len())` is always safe`\n    let mut r = unsafe { l.add(v.len()) };\n    let mut block_r = BLOCK;\n    let mut start_r = ptr::null_mut();\n    let mut end_r = ptr::null_mut();\n    let mut offsets_r = [MaybeUninit::<u8>::uninit(); BLOCK];\n\n    // FIXME: When we get VLAs, try creating one array of length `min(v.len(), 2 * BLOCK)` rather\n    // than two fixed-size arrays of length `BLOCK`. VLAs might be more cache-efficient.\n\n    // Returns the number of elements between pointers `l` (inclusive) and `r` (exclusive).\n    fn width<T>(l: *mut T, r: *mut T) -> usize {\n        assert!(mem::size_of::<T>() > 0);\n        (r as usize - l as usize) / mem::size_of::<T>()\n    }\n\n    loop {\n        // We are done with partitioning block-by-block when `l` and `r` get very close. Then we do\n        // some patch-up work in order to partition the remaining elements in between.\n        let is_done = width(l, r) <= 2 * BLOCK;\n\n        if is_done {\n            // Number of remaining elements (still not compared to the pivot).\n            let mut rem = width(l, r);\n            if start_l < end_l || start_r < end_r {\n                rem -= BLOCK;\n            }\n\n            // Adjust block sizes so that the left and right block don't overlap, but get perfectly\n            // aligned to cover the whole remaining gap.\n            if start_l < end_l {\n                block_r = rem;\n            } else if start_r < end_r {\n                block_l = rem;\n            } else {\n                block_l = rem / 2;\n                block_r = rem - block_l;\n            }\n            debug_assert!(block_l <= BLOCK && block_r <= BLOCK);\n            debug_assert!(width(l, r) == block_l + block_r);\n        }\n\n        if start_l == end_l {\n            // Trace `block_l` elements from the left side.\n            start_l = MaybeUninit::slice_as_mut_ptr(&mut offsets_l);\n            end_l = MaybeUninit::slice_as_mut_ptr(&mut offsets_l);\n            let mut elem = l;\n\n            for i in 0..block_l {\n                // SAFETY: The unsafety operations below involve the usage of the `offset`.\n                //         According to the conditions required by the function, we satisfy them because:\n                //         1. `offsets_l` is stack-allocated, and thus considered separate allocated object.\n                //         2. The function `is_less` returns a `bool`.\n                //            Casting a `bool` will never overflow `isize`.\n                //         3. We have guaranteed that `block_l` will be `<= BLOCK`.\n                //            Plus, `end_l` was initially set to the begin pointer of `offsets_` which was declared on the stack.\n                //            Thus, we know that even in the worst case (all invocations of `is_less` returns false) we will only be at most 1 byte pass the end.\n                //        Another unsafety operation here is dereferencing `elem`.\n                //        However, `elem` was initially the begin pointer to the slice which is always valid.\n                unsafe {\n                    // Branchless comparison.\n                    *end_l = i as u8;\n                    end_l = end_l.offset(!is_less(&*elem, pivot) as isize);\n                    elem = elem.offset(1);\n                }\n            }\n        }\n\n        if start_r == end_r {\n            // Trace `block_r` elements from the right side.\n            start_r = MaybeUninit::slice_as_mut_ptr(&mut offsets_r);\n            end_r = MaybeUninit::slice_as_mut_ptr(&mut offsets_r);\n            let mut elem = r;\n\n            for i in 0..block_r {\n                // SAFETY: The unsafety operations below involve the usage of the `offset`.\n                //         According to the conditions required by the function, we satisfy them because:\n                //         1. `offsets_r` is stack-allocated, and thus considered separate allocated object.\n                //         2. The function `is_less` returns a `bool`.\n                //            Casting a `bool` will never overflow `isize`.\n                //         3. We have guaranteed that `block_r` will be `<= BLOCK`.\n                //            Plus, `end_r` was initially set to the begin pointer of `offsets_` which was declared on the stack.\n                //            Thus, we know that even in the worst case (all invocations of `is_less` returns true) we will only be at most 1 byte pass the end.\n                //        Another unsafety operation here is dereferencing `elem`.\n                //        However, `elem` was initially `1 * sizeof(T)` past the end and we decrement it by `1 * sizeof(T)` before accessing it.\n                //        Plus, `block_r` was asserted to be less than `BLOCK` and `elem` will therefore at most be pointing to the beginning of the slice.\n                unsafe {\n                    // Branchless comparison.\n                    elem = elem.offset(-1);\n                    *end_r = i as u8;\n                    end_r = end_r.offset(is_less(&*elem, pivot) as isize);\n                }\n            }\n        }\n\n        // Number of out-of-order elements to swap between the left and right side.\n        let count = cmp::min(width(start_l, end_l), width(start_r, end_r));\n\n        if count > 0 {\n            macro_rules! left {\n                () => {\n                    l.offset(*start_l as isize)\n                };\n            }\n            macro_rules! right {\n                () => {\n                    r.offset(-(*start_r as isize) - 1)\n                };\n            }\n\n            // Instead of swapping one pair at the time, it is more efficient to perform a cyclic\n            // permutation. This is not strictly equivalent to swapping, but produces a similar\n            // result using fewer memory operations.\n            unsafe {\n                let tmp = ptr::read(left!());\n                ptr::copy_nonoverlapping(right!(), left!(), 1);\n\n                for _ in 1..count {\n                    start_l = start_l.offset(1);\n                    ptr::copy_nonoverlapping(left!(), right!(), 1);\n                    start_r = start_r.offset(1);\n                    ptr::copy_nonoverlapping(right!(), left!(), 1);\n                }\n\n                ptr::copy_nonoverlapping(&tmp, right!(), 1);\n                mem::forget(tmp);\n                start_l = start_l.offset(1);\n                start_r = start_r.offset(1);\n            }\n        }\n\n        if start_l == end_l {\n            // All out-of-order elements in the left block were moved. Move to the next block.\n            l = unsafe { l.offset(block_l as isize) };\n        }\n\n        if start_r == end_r {\n            // All out-of-order elements in the right block were moved. Move to the previous block.\n            r = unsafe { r.offset(-(block_r as isize)) };\n        }\n\n        if is_done {\n            break;\n        }\n    }\n\n    // All that remains now is at most one block (either the left or the right) with out-of-order\n    // elements that need to be moved. Such remaining elements can be simply shifted to the end\n    // within their block.\n\n    if start_l < end_l {\n        // The left block remains.\n        // Move its remaining out-of-order elements to the far right.\n        debug_assert_eq!(width(l, r), block_l);\n        while start_l < end_l {\n            unsafe {\n                end_l = end_l.offset(-1);\n                ptr::swap(l.offset(*end_l as isize), r.offset(-1));\n                r = r.offset(-1);\n            }\n        }\n        width(v.as_mut_ptr(), r)\n    } else if start_r < end_r {\n        // The right block remains.\n        // Move its remaining out-of-order elements to the far left.\n        debug_assert_eq!(width(l, r), block_r);\n        while start_r < end_r {\n            unsafe {\n                end_r = end_r.offset(-1);\n                ptr::swap(l, r.offset(-(*end_r as isize) - 1));\n                l = l.offset(1);\n            }\n        }\n        width(v.as_mut_ptr(), l)\n    } else {\n        // Nothing else to do, we're done.\n        width(v.as_mut_ptr(), l)\n    }\n}\n\n/// Partitions `v` into elements smaller than `v[pivot]`, followed by elements greater than or\n/// equal to `v[pivot]`.\n///\n/// Returns a tuple of:\n///\n/// 1. Number of elements smaller than `v[pivot]`.\n/// 2. True if `v` was already partitioned.\nfn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    let (mid, was_partitioned) = {\n        // Place the pivot at the beginning of slice.\n        v.swap(0, pivot);\n        let (pivot, v) = v.split_at_mut(1);\n        let pivot = &mut pivot[0];\n\n        // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n        // operation panics, the pivot will be automatically written back into the slice.\n        let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n        let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n        let pivot = &*tmp;\n\n        // Find the first pair of out-of-order elements.\n        let mut l = 0;\n        let mut r = v.len();\n\n        // SAFETY: The unsafety below involves indexing an array.\n        // For the first one: We already do the bounds checking here with `l < r`.\n        // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.\n        //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.\n        unsafe {\n            // Find the first element greater than or equal to the pivot.\n            while l < r && is_less(v.get_unchecked(l), pivot) {\n                l += 1;\n            }\n\n            // Find the last element smaller that the pivot.\n            while l < r && !is_less(v.get_unchecked(r - 1), pivot) {\n                r -= 1;\n            }\n        }\n\n        (l + partition_in_blocks(&mut v[l..r], pivot, is_less), l >= r)\n\n        // `_pivot_guard` goes out of scope and writes the pivot (which is a stack-allocated\n        // variable) back into the slice where it originally was. This step is critical in ensuring\n        // safety!\n    };\n\n    // Place the pivot between the two partitions.\n    v.swap(0, mid);\n\n    (mid, was_partitioned)\n}\n\n/// Partitions `v` into elements equal to `v[pivot]` followed by elements greater than `v[pivot]`.\n///\n/// Returns the number of elements equal to the pivot. It is assumed that `v` does not contain\n/// elements smaller than the pivot.\nfn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    // Place the pivot at the beginning of slice.\n    v.swap(0, pivot);\n    let (pivot, v) = v.split_at_mut(1);\n    let pivot = &mut pivot[0];\n\n    // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n    // operation panics, the pivot will be automatically written back into the slice.\n    // SAFETY: The pointer here is valid because it is obtained from a reference to a slice.\n    let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n    let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n    let pivot = &*tmp;\n\n    // Now partition the slice.\n    let mut l = 0;\n    let mut r = v.len();\n    loop {\n        // SAFETY: The unsafety below involves indexing an array.\n        // For the first one: We already do the bounds checking here with `l < r`.\n        // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.\n        //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.\n        unsafe {\n            // Find the first element greater than the pivot.\n            while l < r && !is_less(pivot, v.get_unchecked(l)) {\n                l += 1;\n            }\n\n            // Find the last element equal to the pivot.\n            while l < r && is_less(pivot, v.get_unchecked(r - 1)) {\n                r -= 1;\n            }\n\n            // Are we done?\n            if l >= r {\n                break;\n            }\n\n            // Swap the found pair of out-of-order elements.\n            r -= 1;\n            ptr::swap(v.get_unchecked_mut(l), v.get_unchecked_mut(r));\n            l += 1;\n        }\n    }\n\n    // We found `l` elements equal to the pivot. Add 1 to account for the pivot itself.\n    l + 1\n\n    // `_pivot_guard` goes out of scope and writes the pivot (which is a stack-allocated variable)\n    // back into the slice where it originally was. This step is critical in ensuring safety!\n}\n\n/// Scatters some elements around in an attempt to break patterns that might cause imbalanced\n/// partitions in quicksort.\n#[cold]\nfn break_patterns<T>(v: &mut [T]) {\n    let len = v.len();\n    if len >= 8 {\n        // Pseudorandom number generator from the \"Xorshift RNGs\" paper by George Marsaglia.\n        let mut random = len as u32;\n        let mut gen_u32 = || {\n            random ^= random << 13;\n            random ^= random >> 17;\n            random ^= random << 5;\n            random\n        };\n        let mut gen_usize = || {\n            if usize::BITS <= 32 {\n                gen_u32() as usize\n            } else {\n                (((gen_u32() as u64) << 32) | (gen_u32() as u64)) as usize\n            }\n        };\n\n        // Take random numbers modulo this number.\n        // The number fits into `usize` because `len` is not greater than `isize::MAX`.\n        let modulus = len.next_power_of_two();\n\n        // Some pivot candidates will be in the nearby of this index. Let's randomize them.\n        let pos = len / 4 * 2;\n\n        for i in 0..3 {\n            // Generate a random number modulo `len`. However, in order to avoid costly operations\n            // we first take it modulo a power of two, and then decrease by `len` until it fits\n            // into the range `[0, len - 1]`.\n            let mut other = gen_usize() & (modulus - 1);\n\n            // `other` is guaranteed to be less than `2 * len`.\n            if other >= len {\n                other -= len;\n            }\n\n            v.swap(pos - 1 + i, other);\n        }\n    }\n}\n\n/// Chooses a pivot in `v` and returns the index and `true` if the slice is likely already sorted.\n///\n/// Elements in `v` might be reordered in the process.\nfn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    // Minimum length to choose the median-of-medians method.\n    // Shorter slices use the simple median-of-three method.\n    const SHORTEST_MEDIAN_OF_MEDIANS: usize = 50;\n    // Maximum number of swaps that can be performed in this function.\n    const MAX_SWAPS: usize = 4 * 3;\n\n    let len = v.len();\n\n    // Three indices near which we are going to choose a pivot.\n    let mut a = len / 4 * 1;\n    let mut b = len / 4 * 2;\n    let mut c = len / 4 * 3;\n\n    // Counts the total number of swaps we are about to perform while sorting indices.\n    let mut swaps = 0;\n\n    if len >= 8 {\n        // Swaps indices so that `v[a] <= v[b]`.\n        let mut sort2 = |a: &mut usize, b: &mut usize| unsafe {\n            if is_less(v.get_unchecked(*b), v.get_unchecked(*a)) {\n                ptr::swap(a, b);\n                swaps += 1;\n            }\n        };\n\n        // Swaps indices so that `v[a] <= v[b] <= v[c]`.\n        let mut sort3 = |a: &mut usize, b: &mut usize, c: &mut usize| {\n            sort2(a, b);\n            sort2(b, c);\n            sort2(a, b);\n        };\n\n        if len >= SHORTEST_MEDIAN_OF_MEDIANS {\n            // Finds the median of `v[a - 1], v[a], v[a + 1]` and stores the index into `a`.\n            let mut sort_adjacent = |a: &mut usize| {\n                let tmp = *a;\n                sort3(&mut (tmp - 1), a, &mut (tmp + 1));\n            };\n\n            // Find medians in the neighborhoods of `a`, `b`, and `c`.\n            sort_adjacent(&mut a);\n            sort_adjacent(&mut b);\n            sort_adjacent(&mut c);\n        }\n\n        // Find the median among `a`, `b`, and `c`.\n        sort3(&mut a, &mut b, &mut c);\n    }\n\n    if swaps < MAX_SWAPS {\n        (b, swaps == 0)\n    } else {\n        // The maximum number of swaps was performed. Chances are the slice is descending or mostly\n        // descending, so reversing will probably help sort it faster.\n        v.reverse();\n        (len - 1 - b, true)\n    }\n}\n\n/// Sorts `v` recursively.\n///\n/// If the slice had a predecessor in the original array, it is specified as `pred`.\n///\n/// `limit` is the number of allowed imbalanced partitions before switching to `heapsort`. If zero,\n/// this function will immediately switch to heapsort.\nfn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: u32)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    // Slices of up to this length get sorted using insertion sort.\n    const MAX_INSERTION: usize = 20;\n\n    // True if the last partitioning was reasonably balanced.\n    let mut was_balanced = true;\n    // True if the last partitioning didn't shuffle elements (the slice was already partitioned).\n    let mut was_partitioned = true;\n\n    loop {\n        let len = v.len();\n\n        // Very short slices get sorted using insertion sort.\n        if len <= MAX_INSERTION {\n            insertion_sort(v, is_less);\n            return;\n        }\n\n        // If too many bad pivot choices were made, simply fall back to heapsort in order to\n        // guarantee `O(n * log(n))` worst-case.\n        if limit == 0 {\n            heapsort(v, is_less);\n            return;\n        }\n\n        // If the last partitioning was imbalanced, try breaking patterns in the slice by shuffling\n        // some elements around. Hopefully we'll choose a better pivot this time.\n        if !was_balanced {\n            break_patterns(v);\n            limit -= 1;\n        }\n\n        // Choose a pivot and try guessing whether the slice is already sorted.\n        let (pivot, likely_sorted) = choose_pivot(v, is_less);\n\n        // If the last partitioning was decently balanced and didn't shuffle elements, and if pivot\n        // selection predicts the slice is likely already sorted...\n        if was_balanced && was_partitioned && likely_sorted {\n            // Try identifying several out-of-order elements and shifting them to correct\n            // positions. If the slice ends up being completely sorted, we're done.\n            if partial_insertion_sort(v, is_less) {\n                return;\n            }\n        }\n\n        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n        // This case is usually hit when the slice contains many duplicate elements.\n        if let Some(p) = pred {\n            if !is_less(p, &v[pivot]) {\n                let mid = partition_equal(v, pivot, is_less);\n\n                // Continue sorting elements greater than the pivot.\n                v = &mut { v }[mid..];\n                continue;\n            }\n        }\n\n        // Partition the slice.\n        let (mid, was_p) = partition(v, pivot, is_less);\n        was_balanced = cmp::min(mid, len - mid) >= len / 8;\n        was_partitioned = was_p;\n\n        // Split the slice into `left`, `pivot`, and `right`.\n        let (left, right) = { v }.split_at_mut(mid);\n        let (pivot, right) = right.split_at_mut(1);\n        let pivot = &pivot[0];\n\n        // Recurse into the shorter side only in order to minimize the total number of recursive\n        // calls and consume less stack space. Then just continue with the longer side (this is\n        // akin to tail recursion).\n        if left.len() < right.len() {\n            recurse(left, is_less, pred, limit);\n            v = right;\n            pred = Some(pivot);\n        } else {\n            recurse(right, is_less, Some(pivot), limit);\n            v = left;\n        }\n    }\n}\n\n/// Sorts `v` using pattern-defeating quicksort, which is *O*(*n* \\* log(*n*)) worst-case.\npub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    // Sorting has no meaningful behavior on zero-sized types.\n    if mem::size_of::<T>() == 0 {\n        return;\n    }\n\n    // Limit the number of imbalanced partitions to `floor(log2(len)) + 1`.\n    let limit = usize::BITS - v.len().leading_zeros();\n\n    recurse(v, &mut is_less, None, limit);\n}\n\nfn partition_at_index_loop<'a, T, F>(\n    mut v: &'a mut [T],\n    mut index: usize,\n    is_less: &mut F,\n    mut pred: Option<&'a T>,\n) where\n    F: FnMut(&T, &T) -> bool,\n{\n    loop {\n        // For slices of up to this length it's probably faster to simply sort them.\n        const MAX_INSERTION: usize = 10;\n        if v.len() <= MAX_INSERTION {\n            insertion_sort(v, is_less);\n            return;\n        }\n\n        // Choose a pivot\n        let (pivot, _) = choose_pivot(v, is_less);\n\n        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n        // This case is usually hit when the slice contains many duplicate elements.\n        if let Some(p) = pred {\n            if !is_less(p, &v[pivot]) {\n                let mid = partition_equal(v, pivot, is_less);\n\n                // If we've passed our index, then we're good.\n                if mid > index {\n                    return;\n                }\n\n                // Otherwise, continue sorting elements greater than the pivot.\n                v = &mut v[mid..];\n                index = index - mid;\n                pred = None;\n                continue;\n            }\n        }\n\n        let (mid, _) = partition(v, pivot, is_less);\n\n        // Split the slice into `left`, `pivot`, and `right`.\n        let (left, right) = { v }.split_at_mut(mid);\n        let (pivot, right) = right.split_at_mut(1);\n        let pivot = &pivot[0];\n\n        if mid < index {\n            v = right;\n            index = index - mid - 1;\n            pred = Some(pivot);\n        } else if mid > index {\n            v = left;\n        } else {\n            // If mid == index, then we're done, since partition() guaranteed that all elements\n            // after mid are greater than or equal to mid.\n            return;\n        }\n    }\n}\n\npub fn partition_at_index<T, F>(\n    v: &mut [T],\n    index: usize,\n    mut is_less: F,\n) -> (&mut [T], &mut T, &mut [T])\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    use cmp::Ordering::Greater;\n    use cmp::Ordering::Less;\n\n    if index >= v.len() {\n        panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n    }\n\n    if mem::size_of::<T>() == 0 {\n        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n    } else if index == v.len() - 1 {\n        // Find max element and place it in the last position of the array. We're free to use\n        // `unwrap()` here because we know v must not be empty.\n        let (max_index, _) = v\n            .iter()\n            .enumerate()\n            .max_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n            .unwrap();\n        v.swap(max_index, index);\n    } else if index == 0 {\n        // Find min element and place it in the first position of the array. We're free to use\n        // `unwrap()` here because we know v must not be empty.\n        let (min_index, _) = v\n            .iter()\n            .enumerate()\n            .min_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n            .unwrap();\n        v.swap(min_index, index);\n    } else {\n        partition_at_index_loop(v, index, &mut is_less, None);\n    }\n\n    let (left, right) = v.split_at_mut(index);\n    let (pivot, right) = right.split_at_mut(1);\n    let pivot = &mut pivot[0];\n    (left, pivot, right)\n}\n"],[2854,"// ignore-tidy-filelength\n\n//! Slice management and manipulation.\n//!\n//! For more details see [`std::slice`].\n//!\n//! [`std::slice`]: ../../std/slice/index.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cmp::Ordering::{self, Greater, Less};\nuse crate::marker::Copy;\nuse crate::mem;\nuse crate::num::NonZeroUsize;\nuse crate::ops::{FnMut, Range, RangeBounds};\nuse crate::option::Option;\nuse crate::option::Option::{None, Some};\nuse crate::ptr;\nuse crate::result::Result;\nuse crate::result::Result::{Err, Ok};\nuse crate::slice;\n\n#[unstable(\n    feature = \"slice_internals\",\n    issue = \"none\",\n    reason = \"exposed from core to be reused in std; use the memchr crate\"\n)]\n/// Pure rust memchr implementation, taken from rust-memchr\npub mod memchr;\n\nmod ascii;\nmod cmp;\nmod index;\nmod iter;\nmod raw;\nmod rotate;\nmod sort;\nmod specialize;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use iter::{Chunks, ChunksMut, Windows};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use iter::{Iter, IterMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use iter::{RSplitN, RSplitNMut, Split, SplitMut, SplitN, SplitNMut};\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\npub use iter::{RSplit, RSplitMut};\n\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\npub use iter::{ChunksExact, ChunksExactMut};\n\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\npub use iter::{RChunks, RChunksExact, RChunksExactMut, RChunksMut};\n\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\npub use iter::{ArrayChunks, ArrayChunksMut};\n\n#[unstable(feature = \"array_windows\", issue = \"75027\")]\npub use iter::ArrayWindows;\n\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\npub use iter::{GroupBy, GroupByMut};\n\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\npub use iter::{SplitInclusive, SplitInclusiveMut};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use raw::{from_raw_parts, from_raw_parts_mut};\n\n#[stable(feature = \"from_ref\", since = \"1.28.0\")]\npub use raw::{from_mut, from_ref};\n\n// This function is public only because there is no other way to unit test heapsort.\n#[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"none\")]\npub use sort::heapsort;\n\n#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\npub use index::SliceIndex;\n\n#[unstable(feature = \"slice_range\", issue = \"76393\")]\npub use index::range;\n\n#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\npub use ascii::EscapeAscii;\n\n#[lang = \"slice\"]\n#[cfg(not(test))]\nimpl<T> [T] {\n    /// Returns the number of elements in the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[doc(alias = \"length\")]\n    #[cfg_attr(not(bootstrap), lang = \"slice_len_fn\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_slice_len\", since = \"1.39.0\")]\n    #[inline]\n    // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n    #[rustc_allow_const_fn_unstable(const_fn_union)]\n    pub const fn len(&self) -> usize {\n        // FIXME: Replace with `crate::ptr::metadata(self)` when that is const-stable.\n        // As of this writing this causes a \"Const-stable functions can only call other\n        // const-stable functions\" error.\n\n        // SAFETY: Accessing the value from the `PtrRepr` union is safe since *const T\n        // and PtrComponents<T> have the same memory layouts. Only std can make this\n        // guarantee.\n        unsafe { crate::ptr::PtrRepr { const_ptr: self }.components.metadata }\n    }\n\n    /// Returns `true` if the slice has a length of 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert!(!a.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_slice_is_empty\", since = \"1.39.0\")]\n    #[inline]\n    pub const fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns the first element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&10), v.first());\n    ///\n    /// let w: &[i32] = &[];\n    /// assert_eq!(None, w.first());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n    #[inline]\n    pub const fn first(&self) -> Option<&T> {\n        if let [first, ..] = self { Some(first) } else { None }\n    }\n\n    /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(first) = x.first_mut() {\n    ///     *first = 5;\n    /// }\n    /// assert_eq!(x, &[5, 1, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n    #[inline]\n    pub const fn first_mut(&mut self) -> Option<&mut T> {\n        if let [first, ..] = self { Some(first) } else { None }\n    }\n\n    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[0, 1, 2];\n    ///\n    /// if let Some((first, elements)) = x.split_first() {\n    ///     assert_eq!(first, &0);\n    ///     assert_eq!(elements, &[1, 2]);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n    #[inline]\n    pub const fn split_first(&self) -> Option<(&T, &[T])> {\n        if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n    }\n\n    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some((first, elements)) = x.split_first_mut() {\n    ///     *first = 3;\n    ///     elements[0] = 4;\n    ///     elements[1] = 5;\n    /// }\n    /// assert_eq!(x, &[3, 4, 5]);\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n    #[inline]\n    pub const fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n    }\n\n    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[0, 1, 2];\n    ///\n    /// if let Some((last, elements)) = x.split_last() {\n    ///     assert_eq!(last, &2);\n    ///     assert_eq!(elements, &[0, 1]);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n    #[inline]\n    pub const fn split_last(&self) -> Option<(&T, &[T])> {\n        if let [init @ .., last] = self { Some((last, init)) } else { None }\n    }\n\n    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some((last, elements)) = x.split_last_mut() {\n    ///     *last = 3;\n    ///     elements[0] = 4;\n    ///     elements[1] = 5;\n    /// }\n    /// assert_eq!(x, &[4, 5, 3]);\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n    #[inline]\n    pub const fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n        if let [init @ .., last] = self { Some((last, init)) } else { None }\n    }\n\n    /// Returns the last element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&30), v.last());\n    ///\n    /// let w: &[i32] = &[];\n    /// assert_eq!(None, w.last());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n    #[inline]\n    pub const fn last(&self) -> Option<&T> {\n        if let [.., last] = self { Some(last) } else { None }\n    }\n\n    /// Returns a mutable pointer to the last item in the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(last) = x.last_mut() {\n    ///     *last = 10;\n    /// }\n    /// assert_eq!(x, &[0, 1, 10]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_slice_first_last\", issue = \"83570\")]\n    #[inline]\n    pub const fn last_mut(&mut self) -> Option<&mut T> {\n        if let [.., last] = self { Some(last) } else { None }\n    }\n\n    /// Returns a reference to an element or subslice depending on the type of\n    /// index.\n    ///\n    /// - If given a position, returns a reference to the element at that\n    ///   position or `None` if out of bounds.\n    /// - If given a range, returns the subslice corresponding to that range,\n    ///   or `None` if out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&40), v.get(1));\n    /// assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n    /// assert_eq!(None, v.get(3));\n    /// assert_eq!(None, v.get(0..4));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    where\n        I: SliceIndex<Self>,\n    {\n        index.get(self)\n    }\n\n    /// Returns a mutable reference to an element or subslice depending on the\n    /// type of index (see [`get`]) or `None` if the index is out of bounds.\n    ///\n    /// [`get`]: slice::get\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(elem) = x.get_mut(1) {\n    ///     *elem = 42;\n    /// }\n    /// assert_eq!(x, &[0, 42, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n    where\n        I: SliceIndex<Self>,\n    {\n        index.get_mut(self)\n    }\n\n    /// Returns a reference to an element or subslice, without doing bounds\n    /// checking.\n    ///\n    /// For a safe alternative see [`get`].\n    ///\n    /// # Safety\n    ///\n    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n    /// even if the resulting reference is not used.\n    ///\n    /// [`get`]: slice::get\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    ///\n    /// unsafe {\n    ///     assert_eq!(x.get_unchecked(1), &2);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n    where\n        I: SliceIndex<Self>,\n    {\n        // SAFETY: the caller must uphold most of the safety requirements for `get_unchecked`;\n        // the slice is dereferencable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*index.get_unchecked(self) }\n    }\n\n    /// Returns a mutable reference to an element or subslice, without doing\n    /// bounds checking.\n    ///\n    /// For a safe alternative see [`get_mut`].\n    ///\n    /// # Safety\n    ///\n    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n    /// even if the resulting reference is not used.\n    ///\n    /// [`get_mut`]: slice::get_mut\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    ///\n    /// unsafe {\n    ///     let elem = x.get_unchecked_mut(1);\n    ///     *elem = 13;\n    /// }\n    /// assert_eq!(x, &[1, 13, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n    where\n        I: SliceIndex<Self>,\n    {\n        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`;\n        // the slice is dereferencable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &mut *index.get_unchecked_mut(self) }\n    }\n\n    /// Returns a raw pointer to the slice's buffer.\n    ///\n    /// The caller must ensure that the slice outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// The caller must also ensure that the memory the pointer (non-transitively) points to\n    /// is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n    /// derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n    ///\n    /// Modifying the container referenced by this slice may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    /// let x_ptr = x.as_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`as_mut_ptr`]: slice::as_mut_ptr\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_slice_as_ptr\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }\n\n    /// Returns an unsafe mutable pointer to the slice's buffer.\n    ///\n    /// The caller must ensure that the slice outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this slice may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    /// let x_ptr = x.as_mut_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         *x_ptr.add(i) += 2;\n    ///     }\n    /// }\n    /// assert_eq!(x, &[3, 4, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n    #[inline]\n    pub const fn as_mut_ptr(&mut self) -> *mut T {\n        self as *mut [T] as *mut T\n    }\n\n    /// Returns the two raw pointers spanning the slice.\n    ///\n    /// The returned range is half-open, which means that the end pointer\n    /// points *one past* the last element of the slice. This way, an empty\n    /// slice is represented by two equal pointers, and the difference between\n    /// the two pointers represents the size of the slice.\n    ///\n    /// See [`as_ptr`] for warnings on using these pointers. The end pointer\n    /// requires extra caution, as it does not point to a valid element in the\n    /// slice.\n    ///\n    /// This function is useful for interacting with foreign interfaces which\n    /// use two pointers to refer to a range of elements in memory, as is\n    /// common in C++.\n    ///\n    /// It can also be useful to check if a pointer to an element refers to an\n    /// element of this slice:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// let x = &a[1] as *const _;\n    /// let y = &5 as *const _;\n    ///\n    /// assert!(a.as_ptr_range().contains(&x));\n    /// assert!(!a.as_ptr_range().contains(&y));\n    /// ```\n    ///\n    /// [`as_ptr`]: slice::as_ptr\n    #[stable(feature = \"slice_ptr_range\", since = \"1.48.0\")]\n    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n    #[inline]\n    pub const fn as_ptr_range(&self) -> Range<*const T> {\n        let start = self.as_ptr();\n        // SAFETY: The `add` here is safe, because:\n        //\n        //   - Both pointers are part of the same object, as pointing directly\n        //     past the object also counts.\n        //\n        //   - The size of the slice is never larger than isize::MAX bytes, as\n        //     noted here:\n        //       - https://github.com/rust-lang/unsafe-code-guidelines/issues/102#issuecomment-473340447\n        //       - https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n        //       - https://doc.rust-lang.org/core/slice/fn.from_raw_parts.html#safety\n        //     (This doesn't seem normative yet, but the very same assumption is\n        //     made in many places, including the Index implementation of slices.)\n        //\n        //   - There is no wrapping around involved, as slices do not wrap past\n        //     the end of the address space.\n        //\n        // See the documentation of pointer::add.\n        let end = unsafe { start.add(self.len()) };\n        start..end\n    }\n\n    /// Returns the two unsafe mutable pointers spanning the slice.\n    ///\n    /// The returned range is half-open, which means that the end pointer\n    /// points *one past* the last element of the slice. This way, an empty\n    /// slice is represented by two equal pointers, and the difference between\n    /// the two pointers represents the size of the slice.\n    ///\n    /// See [`as_mut_ptr`] for warnings on using these pointers. The end\n    /// pointer requires extra caution, as it does not point to a valid element\n    /// in the slice.\n    ///\n    /// This function is useful for interacting with foreign interfaces which\n    /// use two pointers to refer to a range of elements in memory, as is\n    /// common in C++.\n    ///\n    /// [`as_mut_ptr`]: slice::as_mut_ptr\n    #[stable(feature = \"slice_ptr_range\", since = \"1.48.0\")]\n    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n    #[inline]\n    pub const fn as_mut_ptr_range(&mut self) -> Range<*mut T> {\n        let start = self.as_mut_ptr();\n        // SAFETY: See as_ptr_range() above for why `add` here is safe.\n        let end = unsafe { start.add(self.len()) };\n        start..end\n    }\n\n    /// Swaps two elements in the slice.\n    ///\n    /// # Arguments\n    ///\n    /// * a - The index of the first element\n    /// * b - The index of the second element\n    ///\n    /// # Panics\n    ///\n    /// Panics if `a` or `b` are out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n    /// v.swap(1, 3);\n    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn swap(&mut self, a: usize, b: usize) {\n        // Can't take two mutable loans from one vector, so instead use raw pointers.\n        let pa = ptr::addr_of_mut!(self[a]);\n        let pb = ptr::addr_of_mut!(self[b]);\n        // SAFETY: `pa` and `pb` have been created from safe mutable references and refer\n        // to elements in the slice and therefore are guaranteed to be valid and aligned.\n        // Note that accessing the elements behind `a` and `b` is checked and will\n        // panic when out of bounds.\n        unsafe {\n            ptr::swap(pa, pb);\n        }\n    }\n\n    /// Reverses the order of elements in the slice, in place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [1, 2, 3];\n    /// v.reverse();\n    /// assert!(v == [3, 2, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn reverse(&mut self) {\n        let mut i: usize = 0;\n        let ln = self.len();\n\n        // For very small types, all the individual reads in the normal\n        // path perform poorly.  We can do better, given efficient unaligned\n        // load/store, by loading a larger chunk and reversing a register.\n\n        // Ideally LLVM would do this for us, as it knows better than we do\n        // whether unaligned reads are efficient (since that changes between\n        // different ARM versions, for example) and what the best chunk size\n        // would be.  Unfortunately, as of LLVM 4.0 (2017-05) it only unrolls\n        // the loop, so we need to do this ourselves.  (Hypothesis: reverse\n        // is troublesome because the sides can be aligned differently --\n        // will be, when the length is odd -- so there's no way of emitting\n        // pre- and postludes to use fully-aligned SIMD in the middle.)\n\n        let fast_unaligned = cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\"));\n\n        if fast_unaligned && mem::size_of::<T>() == 1 {\n            // Use the llvm.bswap intrinsic to reverse u8s in a usize\n            let chunk = mem::size_of::<usize>();\n            while i + chunk - 1 < ln / 2 {\n                // SAFETY: There are several things to check here:\n                //\n                // - Note that `chunk` is either 4 or 8 due to the cfg check\n                //   above. So `chunk - 1` is positive.\n                // - Indexing with index `i` is fine as the loop check guarantees\n                //   `i + chunk - 1 < ln / 2`\n                //   <=> `i < ln / 2 - (chunk - 1) < ln / 2 < ln`.\n                // - Indexing with index `ln - i - chunk = ln - (i + chunk)` is fine:\n                //   - `i + chunk > 0` is trivially true.\n                //   - The loop check guarantees:\n                //     `i + chunk - 1 < ln / 2`\n                //     <=> `i + chunk ≤ ln / 2 ≤ ln`, thus subtraction does not underflow.\n                // - The `read_unaligned` and `write_unaligned` calls are fine:\n                //   - `pa` points to index `i` where `i < ln / 2 - (chunk - 1)`\n                //     (see above) and `pb` points to index `ln - i - chunk`, so\n                //     both are at least `chunk`\n                //     many bytes away from the end of `self`.\n                //   - Any initialized memory is valid `usize`.\n                unsafe {\n                    let ptr = self.as_mut_ptr();\n                    let pa = ptr.add(i);\n                    let pb = ptr.add(ln - i - chunk);\n                    let va = ptr::read_unaligned(pa as *mut usize);\n                    let vb = ptr::read_unaligned(pb as *mut usize);\n                    ptr::write_unaligned(pa as *mut usize, vb.swap_bytes());\n                    ptr::write_unaligned(pb as *mut usize, va.swap_bytes());\n                }\n                i += chunk;\n            }\n        }\n\n        if fast_unaligned && mem::size_of::<T>() == 2 {\n            // Use rotate-by-16 to reverse u16s in a u32\n            let chunk = mem::size_of::<u32>() / 2;\n            while i + chunk - 1 < ln / 2 {\n                // SAFETY: An unaligned u32 can be read from `i` if `i + 1 < ln`\n                // (and obviously `i < ln`), because each element is 2 bytes and\n                // we're reading 4.\n                //\n                // `i + chunk - 1 < ln / 2` # while condition\n                // `i + 2 - 1 < ln / 2`\n                // `i + 1 < ln / 2`\n                //\n                // Since it's less than the length divided by 2, then it must be\n                // in bounds.\n                //\n                // This also means that the condition `0 < i + chunk <= ln` is\n                // always respected, ensuring the `pb` pointer can be used\n                // safely.\n                unsafe {\n                    let ptr = self.as_mut_ptr();\n                    let pa = ptr.add(i);\n                    let pb = ptr.add(ln - i - chunk);\n                    let va = ptr::read_unaligned(pa as *mut u32);\n                    let vb = ptr::read_unaligned(pb as *mut u32);\n                    ptr::write_unaligned(pa as *mut u32, vb.rotate_left(16));\n                    ptr::write_unaligned(pb as *mut u32, va.rotate_left(16));\n                }\n                i += chunk;\n            }\n        }\n\n        while i < ln / 2 {\n            // SAFETY: `i` is inferior to half the length of the slice so\n            // accessing `i` and `ln - i - 1` is safe (`i` starts at 0 and\n            // will not go further than `ln / 2 - 1`).\n            // The resulting pointers `pa` and `pb` are therefore valid and\n            // aligned, and can be read from and written to.\n            unsafe {\n                // Unsafe swap to avoid the bounds check in safe swap.\n                let ptr = self.as_mut_ptr();\n                let pa = ptr.add(i);\n                let pb = ptr.add(ln - i - 1);\n                ptr::swap(pa, pb);\n            }\n            i += 1;\n        }\n    }\n\n    /// Returns an iterator over the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    /// let mut iterator = x.iter();\n    ///\n    /// assert_eq!(iterator.next(), Some(&1));\n    /// assert_eq!(iterator.next(), Some(&2));\n    /// assert_eq!(iterator.next(), Some(&4));\n    /// assert_eq!(iterator.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }\n\n    /// Returns an iterator that allows modifying each value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    /// for elem in x.iter_mut() {\n    ///     *elem += 2;\n    /// }\n    /// assert_eq!(x, &[3, 4, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n        IterMut::new(self)\n    }\n\n    /// Returns an iterator over all contiguous windows of length\n    /// `size`. The windows overlap. If the slice is shorter than\n    /// `size`, the iterator returns no values.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['r', 'u', 's', 't'];\n    /// let mut iter = slice.windows(2);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'u']);\n    /// assert_eq!(iter.next().unwrap(), &['u', 's']);\n    /// assert_eq!(iter.next().unwrap(), &['s', 't']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If the slice is shorter than `size`:\n    ///\n    /// ```\n    /// let slice = ['f', 'o', 'o'];\n    /// let mut iter = slice.windows(4);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn windows(&self, size: usize) -> Windows<'_, T> {\n        let size = NonZeroUsize::new(size).expect(\"size is zero\");\n        Windows::new(self, size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n    /// slice, then the last chunk will not have length `chunk_size`.\n    ///\n    /// See [`chunks_exact`] for a variant of this iterator that returns chunks of always exactly\n    /// `chunk_size` elements, and [`rchunks`] for the same iterator but starting at the end of the\n    /// slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.chunks(2);\n    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n    /// assert_eq!(iter.next().unwrap(), &['m']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// [`chunks_exact`]: slice::chunks_exact\n    /// [`rchunks`]: slice::rchunks\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n        assert_ne!(chunk_size, 0);\n        Chunks::new(self, chunk_size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n    /// length of the slice, then the last chunk will not have length `chunk_size`.\n    ///\n    /// See [`chunks_exact_mut`] for a variant of this iterator that returns chunks of always\n    /// exactly `chunk_size` elements, and [`rchunks_mut`] for the same iterator but starting at\n    /// the end of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.chunks_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n    /// ```\n    ///\n    /// [`chunks_exact_mut`]: slice::chunks_exact_mut\n    /// [`rchunks_mut`]: slice::rchunks_mut\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<'_, T> {\n        assert_ne!(chunk_size, 0);\n        ChunksMut::new(self, chunk_size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n    /// slice, then the last up to `chunk_size-1` elements will be omitted and can be retrieved\n    /// from the `remainder` function of the iterator.\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n    /// resulting code better than in the case of [`chunks`].\n    ///\n    /// See [`chunks`] for a variant of this iterator that also returns the remainder as a smaller\n    /// chunk, and [`rchunks_exact`] for the same iterator but starting at the end of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.chunks_exact(2);\n    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n    /// assert!(iter.next().is_none());\n    /// assert_eq!(iter.remainder(), &['m']);\n    /// ```\n    ///\n    /// [`chunks`]: slice::chunks\n    /// [`rchunks_exact`]: slice::rchunks_exact\n    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n    #[inline]\n    pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {\n        assert_ne!(chunk_size, 0);\n        ChunksExact::new(self, chunk_size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n    /// length of the slice, then the last up to `chunk_size-1` elements will be omitted and can be\n    /// retrieved from the `into_remainder` function of the iterator.\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n    /// resulting code better than in the case of [`chunks_mut`].\n    ///\n    /// See [`chunks_mut`] for a variant of this iterator that also returns the remainder as a\n    /// smaller chunk, and [`rchunks_exact_mut`] for the same iterator but starting at the end of\n    /// the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.chunks_exact_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n    /// ```\n    ///\n    /// [`chunks_mut`]: slice::chunks_mut\n    /// [`rchunks_exact_mut`]: slice::rchunks_exact_mut\n    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n    #[inline]\n    pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<'_, T> {\n        assert_ne!(chunk_size, 0);\n        ChunksExactMut::new(self, chunk_size)\n    }\n\n    /// Splits the slice into a slice of `N`-element arrays,\n    /// assuming that there's no remainder.\n    ///\n    /// # Safety\n    ///\n    /// This may only be called when\n    /// - The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`).\n    /// - `N != 0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_as_chunks)]\n    /// let slice: &[char] = &['l', 'o', 'r', 'e', 'm', '!'];\n    /// let chunks: &[[char; 1]] =\n    ///     // SAFETY: 1-element chunks never have remainder\n    ///     unsafe { slice.as_chunks_unchecked() };\n    /// assert_eq!(chunks, &[['l'], ['o'], ['r'], ['e'], ['m'], ['!']]);\n    /// let chunks: &[[char; 3]] =\n    ///     // SAFETY: The slice length (6) is a multiple of 3\n    ///     unsafe { slice.as_chunks_unchecked() };\n    /// assert_eq!(chunks, &[['l', 'o', 'r'], ['e', 'm', '!']]);\n    ///\n    /// // These would be unsound:\n    /// // let chunks: &[[_; 5]] = slice.as_chunks_unchecked() // The slice length is not a multiple of 5\n    /// // let chunks: &[[_; 0]] = slice.as_chunks_unchecked() // Zero-length chunks are never allowed\n    /// ```\n    #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n    #[inline]\n    pub unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n        debug_assert_ne!(N, 0);\n        debug_assert_eq!(self.len() % N, 0);\n        let new_len =\n            // SAFETY: Our precondition is exactly what's needed to call this\n            unsafe { crate::intrinsics::exact_div(self.len(), N) };\n        // SAFETY: We cast a slice of `new_len * N` elements into\n        // a slice of `new_len` many `N` elements chunks.\n        unsafe { from_raw_parts(self.as_ptr().cast(), new_len) }\n    }\n\n    /// Splits the slice into a slice of `N`-element arrays,\n    /// starting at the beginning of the slice,\n    /// and a remainder slice with length strictly less than `N`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n    /// error before this method gets stabilized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_as_chunks)]\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let (chunks, remainder) = slice.as_chunks();\n    /// assert_eq!(chunks, &[['l', 'o'], ['r', 'e']]);\n    /// assert_eq!(remainder, &['m']);\n    /// ```\n    #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n    #[inline]\n    pub fn as_chunks<const N: usize>(&self) -> (&[[T; N]], &[T]) {\n        assert_ne!(N, 0);\n        let len = self.len() / N;\n        let (multiple_of_n, remainder) = self.split_at(len * N);\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked() };\n        (array_slice, remainder)\n    }\n\n    /// Splits the slice into a slice of `N`-element arrays,\n    /// starting at the end of the slice,\n    /// and a remainder slice with length strictly less than `N`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n    /// error before this method gets stabilized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_as_chunks)]\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let (remainder, chunks) = slice.as_rchunks();\n    /// assert_eq!(remainder, &['l']);\n    /// assert_eq!(chunks, &[['o', 'r'], ['e', 'm']]);\n    /// ```\n    #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n    #[inline]\n    pub fn as_rchunks<const N: usize>(&self) -> (&[T], &[[T; N]]) {\n        assert_ne!(N, 0);\n        let len = self.len() / N;\n        let (remainder, multiple_of_n) = self.split_at(self.len() - len * N);\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked() };\n        (remainder, array_slice)\n    }\n\n    /// Returns an iterator over `N` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are array references and do not overlap. If `N` does not divide the\n    /// length of the slice, then the last up to `N-1` elements will be omitted and can be\n    /// retrieved from the `remainder` function of the iterator.\n    ///\n    /// This method is the const generic equivalent of [`chunks_exact`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n    /// error before this method gets stabilized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(array_chunks)]\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.array_chunks();\n    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n    /// assert!(iter.next().is_none());\n    /// assert_eq!(iter.remainder(), &['m']);\n    /// ```\n    ///\n    /// [`chunks_exact`]: slice::chunks_exact\n    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n    #[inline]\n    pub fn array_chunks<const N: usize>(&self) -> ArrayChunks<'_, T, N> {\n        assert_ne!(N, 0);\n        ArrayChunks::new(self)\n    }\n\n    /// Splits the slice into a slice of `N`-element arrays,\n    /// assuming that there's no remainder.\n    ///\n    /// # Safety\n    ///\n    /// This may only be called when\n    /// - The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`).\n    /// - `N != 0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_as_chunks)]\n    /// let slice: &mut [char] = &mut ['l', 'o', 'r', 'e', 'm', '!'];\n    /// let chunks: &mut [[char; 1]] =\n    ///     // SAFETY: 1-element chunks never have remainder\n    ///     unsafe { slice.as_chunks_unchecked_mut() };\n    /// chunks[0] = ['L'];\n    /// assert_eq!(chunks, &[['L'], ['o'], ['r'], ['e'], ['m'], ['!']]);\n    /// let chunks: &mut [[char; 3]] =\n    ///     // SAFETY: The slice length (6) is a multiple of 3\n    ///     unsafe { slice.as_chunks_unchecked_mut() };\n    /// chunks[1] = ['a', 'x', '?'];\n    /// assert_eq!(slice, &['L', 'o', 'r', 'a', 'x', '?']);\n    ///\n    /// // These would be unsound:\n    /// // let chunks: &[[_; 5]] = slice.as_chunks_unchecked_mut() // The slice length is not a multiple of 5\n    /// // let chunks: &[[_; 0]] = slice.as_chunks_unchecked_mut() // Zero-length chunks are never allowed\n    /// ```\n    #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n    #[inline]\n    pub unsafe fn as_chunks_unchecked_mut<const N: usize>(&mut self) -> &mut [[T; N]] {\n        debug_assert_ne!(N, 0);\n        debug_assert_eq!(self.len() % N, 0);\n        let new_len =\n            // SAFETY: Our precondition is exactly what's needed to call this\n            unsafe { crate::intrinsics::exact_div(self.len(), N) };\n        // SAFETY: We cast a slice of `new_len * N` elements into\n        // a slice of `new_len` many `N` elements chunks.\n        unsafe { from_raw_parts_mut(self.as_mut_ptr().cast(), new_len) }\n    }\n\n    /// Splits the slice into a slice of `N`-element arrays,\n    /// starting at the beginning of the slice,\n    /// and a remainder slice with length strictly less than `N`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n    /// error before this method gets stabilized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_as_chunks)]\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// let (chunks, remainder) = v.as_chunks_mut();\n    /// remainder[0] = 9;\n    /// for chunk in chunks {\n    ///     *chunk = [count; 2];\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[1, 1, 2, 2, 9]);\n    /// ```\n    #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n    #[inline]\n    pub fn as_chunks_mut<const N: usize>(&mut self) -> (&mut [[T; N]], &mut [T]) {\n        assert_ne!(N, 0);\n        let len = self.len() / N;\n        let (multiple_of_n, remainder) = self.split_at_mut(len * N);\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked_mut() };\n        (array_slice, remainder)\n    }\n\n    /// Splits the slice into a slice of `N`-element arrays,\n    /// starting at the end of the slice,\n    /// and a remainder slice with length strictly less than `N`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n    /// error before this method gets stabilized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_as_chunks)]\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// let (remainder, chunks) = v.as_rchunks_mut();\n    /// remainder[0] = 9;\n    /// for chunk in chunks {\n    ///     *chunk = [count; 2];\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[9, 1, 1, 2, 2]);\n    /// ```\n    #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n    #[inline]\n    pub fn as_rchunks_mut<const N: usize>(&mut self) -> (&mut [T], &mut [[T; N]]) {\n        assert_ne!(N, 0);\n        let len = self.len() / N;\n        let (remainder, multiple_of_n) = self.split_at_mut(self.len() - len * N);\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked_mut() };\n        (remainder, array_slice)\n    }\n\n    /// Returns an iterator over `N` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are mutable array references and do not overlap. If `N` does not divide\n    /// the length of the slice, then the last up to `N-1` elements will be omitted and\n    /// can be retrieved from the `into_remainder` function of the iterator.\n    ///\n    /// This method is the const generic equivalent of [`chunks_exact_mut`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n    /// error before this method gets stabilized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(array_chunks)]\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.array_chunks_mut() {\n    ///     *chunk = [count; 2];\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n    /// ```\n    ///\n    /// [`chunks_exact_mut`]: slice::chunks_exact_mut\n    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n    #[inline]\n    pub fn array_chunks_mut<const N: usize>(&mut self) -> ArrayChunksMut<'_, T, N> {\n        assert_ne!(N, 0);\n        ArrayChunksMut::new(self)\n    }\n\n    /// Returns an iterator over overlapping windows of `N` elements of  a slice,\n    /// starting at the beginning of the slice.\n    ///\n    /// This is the const generic equivalent of [`windows`].\n    ///\n    /// If `N` is greater than the size of the slice, it will return no windows.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n    /// error before this method gets stabilized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(array_windows)]\n    /// let slice = [0, 1, 2, 3];\n    /// let mut iter = slice.array_windows();\n    /// assert_eq!(iter.next().unwrap(), &[0, 1]);\n    /// assert_eq!(iter.next().unwrap(), &[1, 2]);\n    /// assert_eq!(iter.next().unwrap(), &[2, 3]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// [`windows`]: slice::windows\n    #[unstable(feature = \"array_windows\", issue = \"75027\")]\n    #[inline]\n    pub fn array_windows<const N: usize>(&self) -> ArrayWindows<'_, T, N> {\n        assert_ne!(N, 0);\n        ArrayWindows::new(self)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n    /// of the slice.\n    ///\n    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n    /// slice, then the last chunk will not have length `chunk_size`.\n    ///\n    /// See [`rchunks_exact`] for a variant of this iterator that returns chunks of always exactly\n    /// `chunk_size` elements, and [`chunks`] for the same iterator but starting at the beginning\n    /// of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.rchunks(2);\n    /// assert_eq!(iter.next().unwrap(), &['e', 'm']);\n    /// assert_eq!(iter.next().unwrap(), &['o', 'r']);\n    /// assert_eq!(iter.next().unwrap(), &['l']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// [`rchunks_exact`]: slice::rchunks_exact\n    /// [`chunks`]: slice::chunks\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    #[inline]\n    pub fn rchunks(&self, chunk_size: usize) -> RChunks<'_, T> {\n        assert!(chunk_size != 0);\n        RChunks::new(self, chunk_size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n    /// of the slice.\n    ///\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n    /// length of the slice, then the last chunk will not have length `chunk_size`.\n    ///\n    /// See [`rchunks_exact_mut`] for a variant of this iterator that returns chunks of always\n    /// exactly `chunk_size` elements, and [`chunks_mut`] for the same iterator but starting at the\n    /// beginning of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.rchunks_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[3, 2, 2, 1, 1]);\n    /// ```\n    ///\n    /// [`rchunks_exact_mut`]: slice::rchunks_exact_mut\n    /// [`chunks_mut`]: slice::chunks_mut\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    #[inline]\n    pub fn rchunks_mut(&mut self, chunk_size: usize) -> RChunksMut<'_, T> {\n        assert!(chunk_size != 0);\n        RChunksMut::new(self, chunk_size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// end of the slice.\n    ///\n    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n    /// slice, then the last up to `chunk_size-1` elements will be omitted and can be retrieved\n    /// from the `remainder` function of the iterator.\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n    /// resulting code better than in the case of [`chunks`].\n    ///\n    /// See [`rchunks`] for a variant of this iterator that also returns the remainder as a smaller\n    /// chunk, and [`chunks_exact`] for the same iterator but starting at the beginning of the\n    /// slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.rchunks_exact(2);\n    /// assert_eq!(iter.next().unwrap(), &['e', 'm']);\n    /// assert_eq!(iter.next().unwrap(), &['o', 'r']);\n    /// assert!(iter.next().is_none());\n    /// assert_eq!(iter.remainder(), &['l']);\n    /// ```\n    ///\n    /// [`chunks`]: slice::chunks\n    /// [`rchunks`]: slice::rchunks\n    /// [`chunks_exact`]: slice::chunks_exact\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    #[inline]\n    pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<'_, T> {\n        assert!(chunk_size != 0);\n        RChunksExact::new(self, chunk_size)\n    }\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n    /// of the slice.\n    ///\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n    /// length of the slice, then the last up to `chunk_size-1` elements will be omitted and can be\n    /// retrieved from the `into_remainder` function of the iterator.\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n    /// resulting code better than in the case of [`chunks_mut`].\n    ///\n    /// See [`rchunks_mut`] for a variant of this iterator that also returns the remainder as a\n    /// smaller chunk, and [`chunks_exact_mut`] for the same iterator but starting at the beginning\n    /// of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.rchunks_exact_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[0, 2, 2, 1, 1]);\n    /// ```\n    ///\n    /// [`chunks_mut`]: slice::chunks_mut\n    /// [`rchunks_mut`]: slice::rchunks_mut\n    /// [`chunks_exact_mut`]: slice::chunks_exact_mut\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    #[inline]\n    pub fn rchunks_exact_mut(&mut self, chunk_size: usize) -> RChunksExactMut<'_, T> {\n        assert!(chunk_size != 0);\n        RChunksExactMut::new(self, chunk_size)\n    }\n\n    /// Returns an iterator over the slice producing non-overlapping runs\n    /// of elements using the predicate to separate them.\n    ///\n    /// The predicate is called on two elements following themselves,\n    /// it means the predicate is called on `slice[0]` and `slice[1]`\n    /// then on `slice[1]` and `slice[2]` and so on.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_group_by)]\n    ///\n    /// let slice = &[1, 1, 1, 3, 3, 2, 2, 2];\n    ///\n    /// let mut iter = slice.group_by(|a, b| a == b);\n    ///\n    /// assert_eq!(iter.next(), Some(&[1, 1, 1][..]));\n    /// assert_eq!(iter.next(), Some(&[3, 3][..]));\n    /// assert_eq!(iter.next(), Some(&[2, 2, 2][..]));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// This method can be used to extract the sorted subslices:\n    ///\n    /// ```\n    /// #![feature(slice_group_by)]\n    ///\n    /// let slice = &[1, 1, 2, 3, 2, 3, 2, 3, 4];\n    ///\n    /// let mut iter = slice.group_by(|a, b| a <= b);\n    ///\n    /// assert_eq!(iter.next(), Some(&[1, 1, 2, 3][..]));\n    /// assert_eq!(iter.next(), Some(&[2, 3][..]));\n    /// assert_eq!(iter.next(), Some(&[2, 3, 4][..]));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n    #[inline]\n    pub fn group_by<F>(&self, pred: F) -> GroupBy<'_, T, F>\n    where\n        F: FnMut(&T, &T) -> bool,\n    {\n        GroupBy::new(self, pred)\n    }\n\n    /// Returns an iterator over the slice producing non-overlapping mutable\n    /// runs of elements using the predicate to separate them.\n    ///\n    /// The predicate is called on two elements following themselves,\n    /// it means the predicate is called on `slice[0]` and `slice[1]`\n    /// then on `slice[1]` and `slice[2]` and so on.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_group_by)]\n    ///\n    /// let slice = &mut [1, 1, 1, 3, 3, 2, 2, 2];\n    ///\n    /// let mut iter = slice.group_by_mut(|a, b| a == b);\n    ///\n    /// assert_eq!(iter.next(), Some(&mut [1, 1, 1][..]));\n    /// assert_eq!(iter.next(), Some(&mut [3, 3][..]));\n    /// assert_eq!(iter.next(), Some(&mut [2, 2, 2][..]));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// This method can be used to extract the sorted subslices:\n    ///\n    /// ```\n    /// #![feature(slice_group_by)]\n    ///\n    /// let slice = &mut [1, 1, 2, 3, 2, 3, 2, 3, 4];\n    ///\n    /// let mut iter = slice.group_by_mut(|a, b| a <= b);\n    ///\n    /// assert_eq!(iter.next(), Some(&mut [1, 1, 2, 3][..]));\n    /// assert_eq!(iter.next(), Some(&mut [2, 3][..]));\n    /// assert_eq!(iter.next(), Some(&mut [2, 3, 4][..]));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n    #[inline]\n    pub fn group_by_mut<F>(&mut self, pred: F) -> GroupByMut<'_, T, F>\n    where\n        F: FnMut(&T, &T) -> bool,\n    {\n        GroupByMut::new(self, pred)\n    }\n\n    /// Divides one slice into two at an index.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [1, 2, 3, 4, 5, 6];\n    ///\n    /// {\n    ///    let (left, right) = v.split_at(0);\n    ///    assert_eq!(left, []);\n    ///    assert_eq!(right, [1, 2, 3, 4, 5, 6]);\n    /// }\n    ///\n    /// {\n    ///     let (left, right) = v.split_at(2);\n    ///     assert_eq!(left, [1, 2]);\n    ///     assert_eq!(right, [3, 4, 5, 6]);\n    /// }\n    ///\n    /// {\n    ///     let (left, right) = v.split_at(6);\n    ///     assert_eq!(left, [1, 2, 3, 4, 5, 6]);\n    ///     assert_eq!(right, []);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        assert!(mid <= self.len());\n        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n        // fulfills the requirements of `from_raw_parts_mut`.\n        unsafe { self.split_at_unchecked(mid) }\n    }\n\n    /// Divides one mutable slice into two at an index.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [1, 0, 3, 0, 5, 6];\n    /// let (left, right) = v.split_at_mut(2);\n    /// assert_eq!(left, [1, 0]);\n    /// assert_eq!(right, [3, 0, 5, 6]);\n    /// left[1] = 2;\n    /// right[1] = 4;\n    /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n        assert!(mid <= self.len());\n        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n        // fulfills the requirements of `from_raw_parts_mut`.\n        unsafe { self.split_at_mut_unchecked(mid) }\n    }\n\n    /// Divides one slice into two at an index, without doing bounds checking.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// For a safe alternative see [`split_at`].\n    ///\n    /// # Safety\n    ///\n    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n    /// even if the resulting reference is not used. The caller has to ensure that\n    /// `0 <= mid <= self.len()`.\n    ///\n    /// [`split_at`]: slice::split_at\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```compile_fail\n    /// #![feature(slice_split_at_unchecked)]\n    ///\n    /// let v = [1, 2, 3, 4, 5, 6];\n    ///\n    /// unsafe {\n    ///    let (left, right) = v.split_at_unchecked(0);\n    ///    assert_eq!(left, []);\n    ///    assert_eq!(right, [1, 2, 3, 4, 5, 6]);\n    /// }\n    ///\n    /// unsafe {\n    ///     let (left, right) = v.split_at_unchecked(2);\n    ///     assert_eq!(left, [1, 2]);\n    ///     assert_eq!(right, [3, 4, 5, 6]);\n    /// }\n    ///\n    /// unsafe {\n    ///     let (left, right) = v.split_at_unchecked(6);\n    ///     assert_eq!(left, [1, 2, 3, 4, 5, 6]);\n    ///     assert_eq!(right, []);\n    /// }\n    /// ```\n    #[unstable(feature = \"slice_split_at_unchecked\", reason = \"new API\", issue = \"76014\")]\n    #[inline]\n    unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (self.get_unchecked(..mid), self.get_unchecked(mid..)) }\n    }\n\n    /// Divides one mutable slice into two at an index, without doing bounds checking.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// For a safe alternative see [`split_at_mut`].\n    ///\n    /// # Safety\n    ///\n    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n    /// even if the resulting reference is not used. The caller has to ensure that\n    /// `0 <= mid <= self.len()`.\n    ///\n    /// [`split_at_mut`]: slice::split_at_mut\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```compile_fail\n    /// #![feature(slice_split_at_unchecked)]\n    ///\n    /// let mut v = [1, 0, 3, 0, 5, 6];\n    /// // scoped to restrict the lifetime of the borrows\n    /// unsafe {\n    ///     let (left, right) = v.split_at_mut_unchecked(2);\n    ///     assert_eq!(left, [1, 0]);\n    ///     assert_eq!(right, [3, 0, 5, 6]);\n    ///     left[1] = 2;\n    ///     right[1] = 4;\n    /// }\n    /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n    /// ```\n    #[unstable(feature = \"slice_split_at_unchecked\", reason = \"new API\", issue = \"76014\")]\n    #[inline]\n    unsafe fn split_at_mut_unchecked(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n        let len = self.len();\n        let ptr = self.as_mut_ptr();\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`.\n        //\n        // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n        // is fine.\n        unsafe { (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid)) }\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = [10, 40, 33, 20];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n    /// assert_eq!(iter.next().unwrap(), &[20]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If the first element is matched, an empty slice will be the first item\n    /// returned by the iterator. Similarly, if the last element in the slice\n    /// is matched, an empty slice will be the last item returned by the\n    /// iterator:\n    ///\n    /// ```\n    /// let slice = [10, 40, 33];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n    /// assert_eq!(iter.next().unwrap(), &[]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If two matched elements are directly adjacent, an empty slice will be\n    /// present between them:\n    ///\n    /// ```\n    /// let slice = [10, 6, 33, 20];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10]);\n    /// assert_eq!(iter.next().unwrap(), &[]);\n    /// assert_eq!(iter.next().unwrap(), &[20]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split<F>(&self, pred: F) -> Split<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        Split::new(self, pred)\n    }\n\n    /// Returns an iterator over mutable subslices separated by elements that\n    /// match `pred`. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.split_mut(|num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(v, [1, 40, 30, 1, 60, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        SplitMut::new(self, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`. The matched element is contained in the end of the previous\n    /// subslice as a terminator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = [10, 40, 33, 20];\n    /// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10, 40, 33]);\n    /// assert_eq!(iter.next().unwrap(), &[20]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If the last element of the slice is matched,\n    /// that element will be considered the terminator of the preceding slice.\n    /// That slice will be the last item returned by the iterator.\n    ///\n    /// ```\n    /// let slice = [3, 10, 40, 33];\n    /// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[3]);\n    /// assert_eq!(iter.next().unwrap(), &[10, 40, 33]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\n    #[inline]\n    pub fn split_inclusive<F>(&self, pred: F) -> SplitInclusive<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        SplitInclusive::new(self, pred)\n    }\n\n    /// Returns an iterator over mutable subslices separated by elements that\n    /// match `pred`. The matched element is contained in the previous\n    /// subslice as a terminator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.split_inclusive_mut(|num| *num % 3 == 0) {\n    ///     let terminator_idx = group.len()-1;\n    ///     group[terminator_idx] = 1;\n    /// }\n    /// assert_eq!(v, [10, 40, 1, 20, 1, 1]);\n    /// ```\n    #[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\n    #[inline]\n    pub fn split_inclusive_mut<F>(&mut self, pred: F) -> SplitInclusiveMut<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        SplitInclusiveMut::new(self, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, starting at the end of the slice and working backwards.\n    /// The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = [11, 22, 33, 0, 44, 55];\n    /// let mut iter = slice.rsplit(|num| *num == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// As with `split()`, if the first or last element is matched, an empty\n    /// slice will be the first (or last) item returned by the iterator.\n    ///\n    /// ```\n    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n    /// assert_eq!(it.next().unwrap(), &[]);\n    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n    /// assert_eq!(it.next().unwrap(), &[]);\n    /// assert_eq!(it.next(), None);\n    /// ```\n    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n    #[inline]\n    pub fn rsplit<F>(&self, pred: F) -> RSplit<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        RSplit::new(self, pred)\n    }\n\n    /// Returns an iterator over mutable subslices separated by elements that\n    /// match `pred`, starting at the end of the slice and working\n    /// backwards. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [100, 400, 300, 200, 600, 500];\n    ///\n    /// let mut count = 0;\n    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n    ///     count += 1;\n    ///     group[0] = count;\n    /// }\n    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n    /// ```\n    ///\n    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n    #[inline]\n    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        RSplitMut::new(self, pred)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, limited to returning at most `n` items. The matched element is\n    /// not contained in the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// Print the slice split once by numbers divisible by 3 (i.e., `[10, 40]`,\n    /// `[20, 60, 50]`):\n    ///\n    /// ```\n    /// let v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n    ///     println!(\"{:?}\", group);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        SplitN::new(self.split(pred), n)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, limited to returning at most `n` items. The matched element is\n    /// not contained in the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.splitn_mut(2, |num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(v, [1, 40, 30, 1, 60, 50]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        SplitNMut::new(self.split_mut(pred), n)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred` limited to returning at most `n` items. This starts at the end of\n    /// the slice and works backwards. The matched element is not contained in\n    /// the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// Print the slice split once, starting from the end, by numbers divisible\n    /// by 3 (i.e., `[50]`, `[10, 40, 30, 20]`):\n    ///\n    /// ```\n    /// let v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n    ///     println!(\"{:?}\", group);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        RSplitN::new(self.rsplit(pred), n)\n    }\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred` limited to returning at most `n` items. This starts at the end of\n    /// the slice and works backwards. The matched element is not contained in\n    /// the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut s = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(s, [1, 40, 30, 20, 60, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        RSplitNMut::new(self.rsplit_mut(pred), n)\n    }\n\n    /// Returns `true` if the slice contains an element with the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.contains(&30));\n    /// assert!(!v.contains(&50));\n    /// ```\n    ///\n    /// If you do not have a `&T`, but some other value that you can compare\n    /// with one (for example, `String` implements `PartialEq<str>`), you can\n    /// use `iter().any`:\n    ///\n    /// ```\n    /// let v = [String::from(\"hello\"), String::from(\"world\")]; // slice of `String`\n    /// assert!(v.iter().any(|e| e == \"hello\")); // search with `&str`\n    /// assert!(!v.iter().any(|e| e == \"hi\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn contains(&self, x: &T) -> bool\n    where\n        T: PartialEq,\n    {\n        cmp::SliceContains::slice_contains(x, self)\n    }\n\n    /// Returns `true` if `needle` is a prefix of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.starts_with(&[10]));\n    /// assert!(v.starts_with(&[10, 40]));\n    /// assert!(!v.starts_with(&[50]));\n    /// assert!(!v.starts_with(&[10, 50]));\n    /// ```\n    ///\n    /// Always returns `true` if `needle` is an empty slice:\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert!(v.starts_with(&[]));\n    /// let v: &[u8] = &[];\n    /// assert!(v.starts_with(&[]));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn starts_with(&self, needle: &[T]) -> bool\n    where\n        T: PartialEq,\n    {\n        let n = needle.len();\n        self.len() >= n && needle == &self[..n]\n    }\n\n    /// Returns `true` if `needle` is a suffix of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.ends_with(&[30]));\n    /// assert!(v.ends_with(&[40, 30]));\n    /// assert!(!v.ends_with(&[50]));\n    /// assert!(!v.ends_with(&[50, 30]));\n    /// ```\n    ///\n    /// Always returns `true` if `needle` is an empty slice:\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert!(v.ends_with(&[]));\n    /// let v: &[u8] = &[];\n    /// assert!(v.ends_with(&[]));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ends_with(&self, needle: &[T]) -> bool\n    where\n        T: PartialEq,\n    {\n        let (m, n) = (self.len(), needle.len());\n        m >= n && needle == &self[m - n..]\n    }\n\n    /// Returns a subslice with the prefix removed.\n    ///\n    /// If the slice starts with `prefix`, returns the subslice after the prefix, wrapped in `Some`.\n    /// If `prefix` is empty, simply returns the original slice.\n    ///\n    /// If the slice does not start with `prefix`, returns `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert_eq!(v.strip_prefix(&[10]), Some(&[40, 30][..]));\n    /// assert_eq!(v.strip_prefix(&[10, 40]), Some(&[30][..]));\n    /// assert_eq!(v.strip_prefix(&[50]), None);\n    /// assert_eq!(v.strip_prefix(&[10, 50]), None);\n    ///\n    /// let prefix : &str = \"he\";\n    /// assert_eq!(b\"hello\".strip_prefix(prefix.as_bytes()),\n    ///            Some(b\"llo\".as_ref()));\n    /// ```\n    #[must_use = \"returns the subslice without modifying the original\"]\n    #[stable(feature = \"slice_strip\", since = \"1.51.0\")]\n    pub fn strip_prefix<P: SlicePattern<Item = T> + ?Sized>(&self, prefix: &P) -> Option<&[T]>\n    where\n        T: PartialEq,\n    {\n        // This function will need rewriting if and when SlicePattern becomes more sophisticated.\n        let prefix = prefix.as_slice();\n        let n = prefix.len();\n        if n <= self.len() {\n            let (head, tail) = self.split_at(n);\n            if head == prefix {\n                return Some(tail);\n            }\n        }\n        None\n    }\n\n    /// Returns a subslice with the suffix removed.\n    ///\n    /// If the slice ends with `suffix`, returns the subslice before the suffix, wrapped in `Some`.\n    /// If `suffix` is empty, simply returns the original slice.\n    ///\n    /// If the slice does not end with `suffix`, returns `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert_eq!(v.strip_suffix(&[30]), Some(&[10, 40][..]));\n    /// assert_eq!(v.strip_suffix(&[40, 30]), Some(&[10][..]));\n    /// assert_eq!(v.strip_suffix(&[50]), None);\n    /// assert_eq!(v.strip_suffix(&[50, 30]), None);\n    /// ```\n    #[must_use = \"returns the subslice without modifying the original\"]\n    #[stable(feature = \"slice_strip\", since = \"1.51.0\")]\n    pub fn strip_suffix<P: SlicePattern<Item = T> + ?Sized>(&self, suffix: &P) -> Option<&[T]>\n    where\n        T: PartialEq,\n    {\n        // This function will need rewriting if and when SlicePattern becomes more sophisticated.\n        let suffix = suffix.as_slice();\n        let (len, n) = (self.len(), suffix.len());\n        if n <= len {\n            let (head, tail) = self.split_at(len - n);\n            if tail == suffix {\n                return Some(head);\n            }\n        }\n        None\n    }\n\n    /// Binary searches this sorted slice for a given element.\n    ///\n    /// If the value is found then [`Result::Ok`] is returned, containing the\n    /// index of the matching element. If there are multiple matches, then any\n    /// one of the matches could be returned. The index is chosen\n    /// deterministically, but is subject to change in future versions of Rust.\n    /// If the value is not found then [`Result::Err`] is returned, containing\n    /// the index where a matching element could be inserted while maintaining\n    /// sorted order.\n    ///\n    /// See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n    ///\n    /// [`binary_search_by`]: slice::binary_search_by\n    /// [`binary_search_by_key`]: slice::binary_search_by_key\n    /// [`partition_point`]: slice::partition_point\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements. The first is found, with a\n    /// uniquely determined position; the second and third are not\n    /// found; the fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    ///\n    /// assert_eq!(s.binary_search(&13),  Ok(9));\n    /// assert_eq!(s.binary_search(&4),   Err(7));\n    /// assert_eq!(s.binary_search(&100), Err(13));\n    /// let r = s.binary_search(&1);\n    /// assert!(match r { Ok(1..=4) => true, _ => false, });\n    /// ```\n    ///\n    /// If you want to insert an item to a sorted vector, while maintaining\n    /// sort order:\n    ///\n    /// ```\n    /// let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    /// let num = 42;\n    /// let idx = s.binary_search(&num).unwrap_or_else(|x| x);\n    /// s.insert(idx, num);\n    /// assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n    where\n        T: Ord,\n    {\n        self.binary_search_by(|p| p.cmp(x))\n    }\n\n    /// Binary searches this sorted slice with a comparator function.\n    ///\n    /// The comparator function should implement an order consistent\n    /// with the sort order of the underlying slice, returning an\n    /// order code that indicates whether its argument is `Less`,\n    /// `Equal` or `Greater` the desired target.\n    ///\n    /// If the value is found then [`Result::Ok`] is returned, containing the\n    /// index of the matching element. If there are multiple matches, then any\n    /// one of the matches could be returned. The index is chosen\n    /// deterministically, but is subject to change in future versions of Rust.\n    /// If the value is not found then [`Result::Err`] is returned, containing\n    /// the index where a matching element could be inserted while maintaining\n    /// sorted order.\n    ///\n    /// See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n    ///\n    /// [`binary_search`]: slice::binary_search\n    /// [`binary_search_by_key`]: slice::binary_search_by_key\n    /// [`partition_point`]: slice::partition_point\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements. The first is found, with a\n    /// uniquely determined position; the second and third are not\n    /// found; the fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    ///\n    /// let seek = 13;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n    /// let seek = 4;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n    /// let seek = 100;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n    /// let seek = 1;\n    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n    /// assert!(match r { Ok(1..=4) => true, _ => false, });\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,\n    {\n        let mut size = self.len();\n        let mut left = 0;\n        let mut right = size;\n        while left < right {\n            let mid = left + size / 2;\n\n            // SAFETY: the call is made safe by the following invariants:\n            // - `mid >= 0`\n            // - `mid < size`: `mid` is limited by `[left; right)` bound.\n            let cmp = f(unsafe { self.get_unchecked(mid) });\n\n            // The reason why we use if/else control flow rather than match\n            // is because match reorders comparison operations, which is perf sensitive.\n            // This is x86 asm for u8: https://rust.godbolt.org/z/8Y8Pra.\n            if cmp == Less {\n                left = mid + 1;\n            } else if cmp == Greater {\n                right = mid;\n            } else {\n                // SAFETY: same as the `get_unchecked` above\n                unsafe { crate::intrinsics::assume(mid < self.len()) };\n                return Ok(mid);\n            }\n\n            size = right - left;\n        }\n        Err(left)\n    }\n\n    /// Binary searches this sorted slice with a key extraction function.\n    ///\n    /// Assumes that the slice is sorted by the key, for instance with\n    /// [`sort_by_key`] using the same key extraction function.\n    ///\n    /// If the value is found then [`Result::Ok`] is returned, containing the\n    /// index of the matching element. If there are multiple matches, then any\n    /// one of the matches could be returned. The index is chosen\n    /// deterministically, but is subject to change in future versions of Rust.\n    /// If the value is not found then [`Result::Err`] is returned, containing\n    /// the index where a matching element could be inserted while maintaining\n    /// sorted order.\n    ///\n    /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n    ///\n    /// [`sort_by_key`]: slice::sort_by_key\n    /// [`binary_search`]: slice::binary_search\n    /// [`binary_search_by`]: slice::binary_search_by\n    /// [`partition_point`]: slice::partition_point\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements in a slice of pairs sorted by\n    /// their second elements. The first is found, with a uniquely\n    /// determined position; the second and third are not found; the\n    /// fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n    ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n    ///          (1, 21), (2, 34), (4, 55)];\n    ///\n    /// assert_eq!(s.binary_search_by_key(&13, |&(a, b)| b),  Ok(9));\n    /// assert_eq!(s.binary_search_by_key(&4, |&(a, b)| b),   Err(7));\n    /// assert_eq!(s.binary_search_by_key(&100, |&(a, b)| b), Err(13));\n    /// let r = s.binary_search_by_key(&1, |&(a, b)| b);\n    /// assert!(match r { Ok(1..=4) => true, _ => false, });\n    /// ```\n    // Lint rustdoc::broken_intra_doc_links is allowed as `slice::sort_by_key` is\n    // in crate `alloc`, and as such doesn't exists yet when building `core`.\n    // links to downstream crate: #74481. Since primitives are only documented in\n    // libstd (#73423), this never leads to broken links in practice.\n    #[allow(rustdoc::broken_intra_doc_links)]\n    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n    #[inline]\n    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> B,\n        B: Ord,\n    {\n        self.binary_search_by(|k| f(k).cmp(b))\n    }\n\n    /// Sorts the slice, but may not preserve the order of equal elements.\n    ///\n    /// This sort is unstable (i.e., may reorder equal elements), in-place\n    /// (i.e., does not allocate), and *O*(*n* \\* log(*n*)) worst-case.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// It is typically faster than stable sorting, except in a few special cases, e.g., when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5, 4, 1, -3, 2];\n    ///\n    /// v.sort_unstable();\n    /// assert!(v == [-5, -3, 1, 2, 4]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable(&mut self)\n    where\n        T: Ord,\n    {\n        sort::quicksort(self, |a, b| a.lt(b));\n    }\n\n    /// Sorts the slice with a comparator function, but may not preserve the order of equal\n    /// elements.\n    ///\n    /// This sort is unstable (i.e., may reorder equal elements), in-place\n    /// (i.e., does not allocate), and *O*(*n* \\* log(*n*)) worst-case.\n    ///\n    /// The comparator function must define a total ordering for the elements in the slice. If\n    /// the ordering is not total, the order of the elements is unspecified. An order is a\n    /// total order if it is (for all `a`, `b` and `c`):\n    ///\n    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n    ///\n    /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n    /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`.\n    ///\n    /// ```\n    /// let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];\n    /// floats.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());\n    /// assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);\n    /// ```\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// It is typically faster than stable sorting, except in a few special cases, e.g., when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [5, 4, 1, 3, 2];\n    /// v.sort_unstable_by(|a, b| a.cmp(b));\n    /// assert!(v == [1, 2, 3, 4, 5]);\n    ///\n    /// // reverse sorting\n    /// v.sort_unstable_by(|a, b| b.cmp(a));\n    /// assert!(v == [5, 4, 3, 2, 1]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        sort::quicksort(self, |a, b| compare(a, b) == Ordering::Less);\n    }\n\n    /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n    /// elements.\n    ///\n    /// This sort is unstable (i.e., may reorder equal elements), in-place\n    /// (i.e., does not allocate), and *O*(m \\* *n* \\* log(*n*)) worst-case, where the key function is\n    /// *O*(*m*).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// Due to its key calling strategy, [`sort_unstable_by_key`](#method.sort_unstable_by_key)\n    /// is likely to be slower than [`sort_by_cached_key`](#method.sort_by_cached_key) in\n    /// cases where the key function is expensive.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// v.sort_unstable_by_key(|k| k.abs());\n    /// assert!(v == [1, 2, -3, 4, -5]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable_by_key<K, F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n        sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n    }\n\n    /// Reorder the slice such that the element at `index` is at its final sorted position.\n    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n    #[rustc_deprecated(since = \"1.49.0\", reason = \"use the select_nth_unstable() instead\")]\n    #[inline]\n    pub fn partition_at_index(&mut self, index: usize) -> (&mut [T], &mut T, &mut [T])\n    where\n        T: Ord,\n    {\n        self.select_nth_unstable(index)\n    }\n\n    /// Reorder the slice with a comparator function such that the element at `index` is at its\n    /// final sorted position.\n    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n    #[rustc_deprecated(since = \"1.49.0\", reason = \"use select_nth_unstable_by() instead\")]\n    #[inline]\n    pub fn partition_at_index_by<F>(\n        &mut self,\n        index: usize,\n        compare: F,\n    ) -> (&mut [T], &mut T, &mut [T])\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        self.select_nth_unstable_by(index, compare)\n    }\n\n    /// Reorder the slice with a key extraction function such that the element at `index` is at its\n    /// final sorted position.\n    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n    #[rustc_deprecated(since = \"1.49.0\", reason = \"use the select_nth_unstable_by_key() instead\")]\n    #[inline]\n    pub fn partition_at_index_by_key<K, F>(\n        &mut self,\n        index: usize,\n        f: F,\n    ) -> (&mut [T], &mut T, &mut [T])\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n        self.select_nth_unstable_by_key(index, f)\n    }\n\n    /// Reorder the slice such that the element at `index` is at its final sorted position.\n    ///\n    /// This reordering has the additional property that any value at position `i < index` will be\n    /// less than or equal to any value at a position `j > index`. Additionally, this reordering is\n    /// unstable (i.e. any number of equal elements may end up at position `index`), in-place\n    /// (i.e. does not allocate), and *O*(*n*) worst-case. This function is also/ known as \"kth\n    /// element\" in other libraries. It returns a triplet of the following values: all elements less\n    /// than the one at the given index, the value at the given index, and all elements greater than\n    /// the one at the given index.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n    /// used for [`sort_unstable`].\n    ///\n    /// [`sort_unstable`]: slice::sort_unstable\n    ///\n    /// # Panics\n    ///\n    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// // Find the median\n    /// v.select_nth_unstable(2);\n    ///\n    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n    /// // about the specified index.\n    /// assert!(v == [-3, -5, 1, 2, 4] ||\n    ///         v == [-5, -3, 1, 2, 4] ||\n    ///         v == [-3, -5, 1, 4, 2] ||\n    ///         v == [-5, -3, 1, 4, 2]);\n    /// ```\n    #[stable(feature = \"slice_select_nth_unstable\", since = \"1.49.0\")]\n    #[inline]\n    pub fn select_nth_unstable(&mut self, index: usize) -> (&mut [T], &mut T, &mut [T])\n    where\n        T: Ord,\n    {\n        let mut f = |a: &T, b: &T| a.lt(b);\n        sort::partition_at_index(self, index, &mut f)\n    }\n\n    /// Reorder the slice with a comparator function such that the element at `index` is at its\n    /// final sorted position.\n    ///\n    /// This reordering has the additional property that any value at position `i < index` will be\n    /// less than or equal to any value at a position `j > index` using the comparator function.\n    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n    /// position `index`), in-place (i.e. does not allocate), and *O*(*n*) worst-case. This function\n    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n    /// values: all elements less than the one at the given index, the value at the given index,\n    /// and all elements greater than the one at the given index, using the provided comparator\n    /// function.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n    /// used for [`sort_unstable`].\n    ///\n    /// [`sort_unstable`]: slice::sort_unstable\n    ///\n    /// # Panics\n    ///\n    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// // Find the median as if the slice were sorted in descending order.\n    /// v.select_nth_unstable_by(2, |a, b| b.cmp(a));\n    ///\n    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n    /// // about the specified index.\n    /// assert!(v == [2, 4, 1, -5, -3] ||\n    ///         v == [2, 4, 1, -3, -5] ||\n    ///         v == [4, 2, 1, -5, -3] ||\n    ///         v == [4, 2, 1, -3, -5]);\n    /// ```\n    #[stable(feature = \"slice_select_nth_unstable\", since = \"1.49.0\")]\n    #[inline]\n    pub fn select_nth_unstable_by<F>(\n        &mut self,\n        index: usize,\n        mut compare: F,\n    ) -> (&mut [T], &mut T, &mut [T])\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        let mut f = |a: &T, b: &T| compare(a, b) == Less;\n        sort::partition_at_index(self, index, &mut f)\n    }\n\n    /// Reorder the slice with a key extraction function such that the element at `index` is at its\n    /// final sorted position.\n    ///\n    /// This reordering has the additional property that any value at position `i < index` will be\n    /// less than or equal to any value at a position `j > index` using the key extraction function.\n    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n    /// position `index`), in-place (i.e. does not allocate), and *O*(*n*) worst-case. This function\n    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n    /// values: all elements less than the one at the given index, the value at the given index, and\n    /// all elements greater than the one at the given index, using the provided key extraction\n    /// function.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n    /// used for [`sort_unstable`].\n    ///\n    /// [`sort_unstable`]: slice::sort_unstable\n    ///\n    /// # Panics\n    ///\n    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// // Return the median as if the array were sorted according to absolute value.\n    /// v.select_nth_unstable_by_key(2, |a| a.abs());\n    ///\n    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n    /// // about the specified index.\n    /// assert!(v == [1, 2, -3, 4, -5] ||\n    ///         v == [1, 2, -3, -5, 4] ||\n    ///         v == [2, 1, -3, 4, -5] ||\n    ///         v == [2, 1, -3, -5, 4]);\n    /// ```\n    #[stable(feature = \"slice_select_nth_unstable\", since = \"1.49.0\")]\n    #[inline]\n    pub fn select_nth_unstable_by_key<K, F>(\n        &mut self,\n        index: usize,\n        mut f: F,\n    ) -> (&mut [T], &mut T, &mut [T])\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n        let mut g = |a: &T, b: &T| f(a).lt(&f(b));\n        sort::partition_at_index(self, index, &mut g)\n    }\n\n    /// Moves all consecutive repeated elements to the end of the slice according to the\n    /// [`PartialEq`] trait implementation.\n    ///\n    /// Returns two slices. The first contains no consecutive repeated elements.\n    /// The second contains all the duplicates in no specified order.\n    ///\n    /// If the slice is sorted, the first returned slice contains no duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_partition_dedup)]\n    ///\n    /// let mut slice = [1, 2, 2, 3, 3, 2, 1, 1];\n    ///\n    /// let (dedup, duplicates) = slice.partition_dedup();\n    ///\n    /// assert_eq!(dedup, [1, 2, 3, 2, 1]);\n    /// assert_eq!(duplicates, [2, 3, 1]);\n    /// ```\n    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n    #[inline]\n    pub fn partition_dedup(&mut self) -> (&mut [T], &mut [T])\n    where\n        T: PartialEq,\n    {\n        self.partition_dedup_by(|a, b| a == b)\n    }\n\n    /// Moves all but the first of consecutive elements to the end of the slice satisfying\n    /// a given equality relation.\n    ///\n    /// Returns two slices. The first contains no consecutive repeated elements.\n    /// The second contains all the duplicates in no specified order.\n    ///\n    /// The `same_bucket` function is passed references to two elements from the slice and\n    /// must determine if the elements compare equal. The elements are passed in opposite order\n    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is moved\n    /// at the end of the slice.\n    ///\n    /// If the slice is sorted, the first returned slice contains no duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_partition_dedup)]\n    ///\n    /// let mut slice = [\"foo\", \"Foo\", \"BAZ\", \"Bar\", \"bar\", \"baz\", \"BAZ\"];\n    ///\n    /// let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n    ///\n    /// assert_eq!(dedup, [\"foo\", \"BAZ\", \"Bar\", \"baz\"]);\n    /// assert_eq!(duplicates, [\"bar\", \"Foo\", \"BAZ\"]);\n    /// ```\n    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n    #[inline]\n    pub fn partition_dedup_by<F>(&mut self, mut same_bucket: F) -> (&mut [T], &mut [T])\n    where\n        F: FnMut(&mut T, &mut T) -> bool,\n    {\n        // Although we have a mutable reference to `self`, we cannot make\n        // *arbitrary* changes. The `same_bucket` calls could panic, so we\n        // must ensure that the slice is in a valid state at all times.\n        //\n        // The way that we handle this is by using swaps; we iterate\n        // over all the elements, swapping as we go so that at the end\n        // the elements we wish to keep are in the front, and those we\n        // wish to reject are at the back. We can then split the slice.\n        // This operation is still `O(n)`.\n        //\n        // Example: We start in this state, where `r` represents \"next\n        // read\" and `w` represents \"next_write`.\n        //\n        //           r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //           w\n        //\n        // Comparing self[r] against self[w-1], this is not a duplicate, so\n        // we swap self[r] and self[w] (no effect as r==w) and then increment both\n        // r and w, leaving us with:\n        //\n        //               r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //               w\n        //\n        // Comparing self[r] against self[w-1], this value is a duplicate,\n        // so we increment `r` but leave everything else unchanged:\n        //\n        //                   r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //               w\n        //\n        // Comparing self[r] against self[w-1], this is not a duplicate,\n        // so swap self[r] and self[w] and advance r and w:\n        //\n        //                       r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 2 | 1 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //                   w\n        //\n        // Not a duplicate, repeat:\n        //\n        //                           r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 2 | 3 | 1 | 3 |\n        //     +---+---+---+---+---+---+\n        //                       w\n        //\n        // Duplicate, advance r. End of slice. Split at w.\n\n        let len = self.len();\n        if len <= 1 {\n            return (self, &mut []);\n        }\n\n        let ptr = self.as_mut_ptr();\n        let mut next_read: usize = 1;\n        let mut next_write: usize = 1;\n\n        // SAFETY: the `while` condition guarantees `next_read` and `next_write`\n        // are less than `len`, thus are inside `self`. `prev_ptr_write` points to\n        // one element before `ptr_write`, but `next_write` starts at 1, so\n        // `prev_ptr_write` is never less than 0 and is inside the slice.\n        // This fulfils the requirements for dereferencing `ptr_read`, `prev_ptr_write`\n        // and `ptr_write`, and for using `ptr.add(next_read)`, `ptr.add(next_write - 1)`\n        // and `prev_ptr_write.offset(1)`.\n        //\n        // `next_write` is also incremented at most once per loop at most meaning\n        // no element is skipped when it may need to be swapped.\n        //\n        // `ptr_read` and `prev_ptr_write` never point to the same element. This\n        // is required for `&mut *ptr_read`, `&mut *prev_ptr_write` to be safe.\n        // The explanation is simply that `next_read >= next_write` is always true,\n        // thus `next_read > next_write - 1` is too.\n        unsafe {\n            // Avoid bounds checks by using raw pointers.\n            while next_read < len {\n                let ptr_read = ptr.add(next_read);\n                let prev_ptr_write = ptr.add(next_write - 1);\n                if !same_bucket(&mut *ptr_read, &mut *prev_ptr_write) {\n                    if next_read != next_write {\n                        let ptr_write = prev_ptr_write.offset(1);\n                        mem::swap(&mut *ptr_read, &mut *ptr_write);\n                    }\n                    next_write += 1;\n                }\n                next_read += 1;\n            }\n        }\n\n        self.split_at_mut(next_write)\n    }\n\n    /// Moves all but the first of consecutive elements to the end of the slice that resolve\n    /// to the same key.\n    ///\n    /// Returns two slices. The first contains no consecutive repeated elements.\n    /// The second contains all the duplicates in no specified order.\n    ///\n    /// If the slice is sorted, the first returned slice contains no duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_partition_dedup)]\n    ///\n    /// let mut slice = [10, 20, 21, 30, 30, 20, 11, 13];\n    ///\n    /// let (dedup, duplicates) = slice.partition_dedup_by_key(|i| *i / 10);\n    ///\n    /// assert_eq!(dedup, [10, 20, 30, 20, 11]);\n    /// assert_eq!(duplicates, [21, 30, 13]);\n    /// ```\n    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n    #[inline]\n    pub fn partition_dedup_by_key<K, F>(&mut self, mut key: F) -> (&mut [T], &mut [T])\n    where\n        F: FnMut(&mut T) -> K,\n        K: PartialEq,\n    {\n        self.partition_dedup_by(|a, b| key(a) == key(b))\n    }\n\n    /// Rotates the slice in-place such that the first `mid` elements of the\n    /// slice move to the end while the last `self.len() - mid` elements move to\n    /// the front. After calling `rotate_left`, the element previously at index\n    /// `mid` will become the first element in the slice.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `mid` is greater than the length of the\n    /// slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n    /// rotation.\n    ///\n    /// # Complexity\n    ///\n    /// Takes linear (in `self.len()`) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a.rotate_left(2);\n    /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n    /// ```\n    ///\n    /// Rotating a subslice:\n    ///\n    /// ```\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a[1..5].rotate_left(1);\n    /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n    /// ```\n    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n    pub fn rotate_left(&mut self, mid: usize) {\n        assert!(mid <= self.len());\n        let k = self.len() - mid;\n        let p = self.as_mut_ptr();\n\n        // SAFETY: The range `[p.add(mid) - mid, p.add(mid) + k)` is trivially\n        // valid for reading and writing, as required by `ptr_rotate`.\n        unsafe {\n            rotate::ptr_rotate(mid, p.add(mid), k);\n        }\n    }\n\n    /// Rotates the slice in-place such that the first `self.len() - k`\n    /// elements of the slice move to the end while the last `k` elements move\n    /// to the front. After calling `rotate_right`, the element previously at\n    /// index `self.len() - k` will become the first element in the slice.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `k` is greater than the length of the\n    /// slice. Note that `k == self.len()` does _not_ panic and is a no-op\n    /// rotation.\n    ///\n    /// # Complexity\n    ///\n    /// Takes linear (in `self.len()`) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a.rotate_right(2);\n    /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n    /// ```\n    ///\n    /// Rotate a subslice:\n    ///\n    /// ```\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a[1..5].rotate_right(1);\n    /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n    /// ```\n    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n    pub fn rotate_right(&mut self, k: usize) {\n        assert!(k <= self.len());\n        let mid = self.len() - k;\n        let p = self.as_mut_ptr();\n\n        // SAFETY: The range `[p.add(mid) - mid, p.add(mid) + k)` is trivially\n        // valid for reading and writing, as required by `ptr_rotate`.\n        unsafe {\n            rotate::ptr_rotate(mid, p.add(mid), k);\n        }\n    }\n\n    /// Fills `self` with elements by cloning `value`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut buf = vec![0; 10];\n    /// buf.fill(1);\n    /// assert_eq!(buf, vec![1; 10]);\n    /// ```\n    #[doc(alias = \"memset\")]\n    #[stable(feature = \"slice_fill\", since = \"1.50.0\")]\n    pub fn fill(&mut self, value: T)\n    where\n        T: Clone,\n    {\n        specialize::SpecFill::spec_fill(self, value);\n    }\n\n    /// Fills `self` with elements returned by calling a closure repeatedly.\n    ///\n    /// This method uses a closure to create new values. If you'd rather\n    /// [`Clone`] a given value, use [`fill`]. If you want to use the [`Default`]\n    /// trait to generate values, you can pass [`Default::default`] as the\n    /// argument.\n    ///\n    /// [`fill`]: slice::fill\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut buf = vec![1; 10];\n    /// buf.fill_with(Default::default);\n    /// assert_eq!(buf, vec![0; 10]);\n    /// ```\n    #[doc(alias = \"memset\")]\n    #[stable(feature = \"slice_fill_with\", since = \"1.51.0\")]\n    pub fn fill_with<F>(&mut self, mut f: F)\n    where\n        F: FnMut() -> T,\n    {\n        for el in self {\n            *el = f();\n        }\n    }\n\n    /// Copies the elements from `src` into `self`.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// If `T` implements `Copy`, it can be more performant to use\n    /// [`copy_from_slice`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    ///\n    /// Cloning two elements from a slice into another:\n    ///\n    /// ```\n    /// let src = [1, 2, 3, 4];\n    /// let mut dst = [0, 0];\n    ///\n    /// // Because the slices have to be the same length,\n    /// // we slice the source slice from four elements\n    /// // to two. It will panic if we don't do this.\n    /// dst.clone_from_slice(&src[2..]);\n    ///\n    /// assert_eq!(src, [1, 2, 3, 4]);\n    /// assert_eq!(dst, [3, 4]);\n    /// ```\n    ///\n    /// Rust enforces that there can only be one mutable reference with no\n    /// immutable references to a particular piece of data in a particular\n    /// scope. Because of this, attempting to use `clone_from_slice` on a\n    /// single slice will result in a compile failure:\n    ///\n    /// ```compile_fail\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// slice[..2].clone_from_slice(&slice[3..]); // compile fail!\n    /// ```\n    ///\n    /// To work around this, we can use [`split_at_mut`] to create two distinct\n    /// sub-slices from a slice:\n    ///\n    /// ```\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// {\n    ///     let (left, right) = slice.split_at_mut(2);\n    ///     left.clone_from_slice(&right[1..]);\n    /// }\n    ///\n    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n    /// ```\n    ///\n    /// [`copy_from_slice`]: slice::copy_from_slice\n    /// [`split_at_mut`]: slice::split_at_mut\n    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n    pub fn clone_from_slice(&mut self, src: &[T])\n    where\n        T: Clone,\n    {\n        self.spec_clone_from(src);\n    }\n\n    /// Copies all elements from `src` into `self`, using a memcpy.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// If `T` does not implement `Copy`, use [`clone_from_slice`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    ///\n    /// Copying two elements from a slice into another:\n    ///\n    /// ```\n    /// let src = [1, 2, 3, 4];\n    /// let mut dst = [0, 0];\n    ///\n    /// // Because the slices have to be the same length,\n    /// // we slice the source slice from four elements\n    /// // to two. It will panic if we don't do this.\n    /// dst.copy_from_slice(&src[2..]);\n    ///\n    /// assert_eq!(src, [1, 2, 3, 4]);\n    /// assert_eq!(dst, [3, 4]);\n    /// ```\n    ///\n    /// Rust enforces that there can only be one mutable reference with no\n    /// immutable references to a particular piece of data in a particular\n    /// scope. Because of this, attempting to use `copy_from_slice` on a\n    /// single slice will result in a compile failure:\n    ///\n    /// ```compile_fail\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n    /// ```\n    ///\n    /// To work around this, we can use [`split_at_mut`] to create two distinct\n    /// sub-slices from a slice:\n    ///\n    /// ```\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// {\n    ///     let (left, right) = slice.split_at_mut(2);\n    ///     left.copy_from_slice(&right[1..]);\n    /// }\n    ///\n    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n    /// ```\n    ///\n    /// [`clone_from_slice`]: slice::clone_from_slice\n    /// [`split_at_mut`]: slice::split_at_mut\n    #[doc(alias = \"memcpy\")]\n    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n    pub fn copy_from_slice(&mut self, src: &[T])\n    where\n        T: Copy,\n    {\n        // The panic code path was put into a cold function to not bloat the\n        // call site.\n        #[inline(never)]\n        #[cold]\n        #[track_caller]\n        fn len_mismatch_fail(dst_len: usize, src_len: usize) -> ! {\n            panic!(\n                \"source slice length ({}) does not match destination slice length ({})\",\n                src_len, dst_len,\n            );\n        }\n\n        if self.len() != src.len() {\n            len_mismatch_fail(self.len(), src.len());\n        }\n\n        // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n        // checked to have the same length. The slices cannot overlap because\n        // mutable references are exclusive.\n        unsafe {\n            ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());\n        }\n    }\n\n    /// Copies elements from one part of the slice to another part of itself,\n    /// using a memmove.\n    ///\n    /// `src` is the range within `self` to copy from. `dest` is the starting\n    /// index of the range within `self` to copy to, which will have the same\n    /// length as `src`. The two ranges may overlap. The ends of the two ranges\n    /// must be less than or equal to `self.len()`.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if either range exceeds the end of the slice,\n    /// or if the end of `src` is before the start.\n    ///\n    /// # Examples\n    ///\n    /// Copying four bytes within a slice:\n    ///\n    /// ```\n    /// let mut bytes = *b\"Hello, World!\";\n    ///\n    /// bytes.copy_within(1..5, 8);\n    ///\n    /// assert_eq!(&bytes, b\"Hello, Wello!\");\n    /// ```\n    #[stable(feature = \"copy_within\", since = \"1.37.0\")]\n    #[track_caller]\n    pub fn copy_within<R: RangeBounds<usize>>(&mut self, src: R, dest: usize)\n    where\n        T: Copy,\n    {\n        let Range { start: src_start, end: src_end } = slice::range(src, ..self.len());\n        let count = src_end - src_start;\n        assert!(dest <= self.len() - count, \"dest is out of bounds\");\n        // SAFETY: the conditions for `ptr::copy` have all been checked above,\n        // as have those for `ptr::add`.\n        unsafe {\n            // Derive both `src_ptr` and `dest_ptr` from the same loan\n            let ptr = self.as_mut_ptr();\n            let src_ptr = ptr.add(src_start);\n            let dest_ptr = ptr.add(dest);\n            ptr::copy(src_ptr, dest_ptr, count);\n        }\n    }\n\n    /// Swaps all elements in `self` with those in `other`.\n    ///\n    /// The length of `other` must be the same as `self`.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Example\n    ///\n    /// Swapping two elements across slices:\n    ///\n    /// ```\n    /// let mut slice1 = [0, 0];\n    /// let mut slice2 = [1, 2, 3, 4];\n    ///\n    /// slice1.swap_with_slice(&mut slice2[2..]);\n    ///\n    /// assert_eq!(slice1, [3, 4]);\n    /// assert_eq!(slice2, [1, 2, 0, 0]);\n    /// ```\n    ///\n    /// Rust enforces that there can only be one mutable reference to a\n    /// particular piece of data in a particular scope. Because of this,\n    /// attempting to use `swap_with_slice` on a single slice will result in\n    /// a compile failure:\n    ///\n    /// ```compile_fail\n    /// let mut slice = [1, 2, 3, 4, 5];\n    /// slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n    /// ```\n    ///\n    /// To work around this, we can use [`split_at_mut`] to create two distinct\n    /// mutable sub-slices from a slice:\n    ///\n    /// ```\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// {\n    ///     let (left, right) = slice.split_at_mut(2);\n    ///     left.swap_with_slice(&mut right[1..]);\n    /// }\n    ///\n    /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n    /// ```\n    ///\n    /// [`split_at_mut`]: slice::split_at_mut\n    #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n    pub fn swap_with_slice(&mut self, other: &mut [T]) {\n        assert!(self.len() == other.len(), \"destination and source slices have different lengths\");\n        // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n        // checked to have the same length. The slices cannot overlap because\n        // mutable references are exclusive.\n        unsafe {\n            ptr::swap_nonoverlapping(self.as_mut_ptr(), other.as_mut_ptr(), self.len());\n        }\n    }\n\n    /// Function to calculate lengths of the middle and trailing slice for `align_to{,_mut}`.\n    fn align_to_offsets<U>(&self) -> (usize, usize) {\n        // What we gonna do about `rest` is figure out what multiple of `U`s we can put in a\n        // lowest number of `T`s. And how many `T`s we need for each such \"multiple\".\n        //\n        // Consider for example T=u8 U=u16. Then we can put 1 U in 2 Ts. Simple. Now, consider\n        // for example a case where size_of::<T> = 16, size_of::<U> = 24. We can put 2 Us in\n        // place of every 3 Ts in the `rest` slice. A bit more complicated.\n        //\n        // Formula to calculate this is:\n        //\n        // Us = lcm(size_of::<T>, size_of::<U>) / size_of::<U>\n        // Ts = lcm(size_of::<T>, size_of::<U>) / size_of::<T>\n        //\n        // Expanded and simplified:\n        //\n        // Us = size_of::<T> / gcd(size_of::<T>, size_of::<U>)\n        // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n        //\n        // Luckily since all this is constant-evaluated... performance here matters not!\n        #[inline]\n        fn gcd(a: usize, b: usize) -> usize {\n            use crate::intrinsics;\n            // iterative stein’s algorithm\n            // We should still make this `const fn` (and revert to recursive algorithm if we do)\n            // because relying on llvm to consteval all this is… well, it makes me uncomfortable.\n\n            // SAFETY: `a` and `b` are checked to be non-zero values.\n            let (ctz_a, mut ctz_b) = unsafe {\n                if a == 0 {\n                    return b;\n                }\n                if b == 0 {\n                    return a;\n                }\n                (intrinsics::cttz_nonzero(a), intrinsics::cttz_nonzero(b))\n            };\n            let k = ctz_a.min(ctz_b);\n            let mut a = a >> ctz_a;\n            let mut b = b;\n            loop {\n                // remove all factors of 2 from b\n                b >>= ctz_b;\n                if a > b {\n                    mem::swap(&mut a, &mut b);\n                }\n                b = b - a;\n                // SAFETY: `b` is checked to be non-zero.\n                unsafe {\n                    if b == 0 {\n                        break;\n                    }\n                    ctz_b = intrinsics::cttz_nonzero(b);\n                }\n            }\n            a << k\n        }\n        let gcd: usize = gcd(mem::size_of::<T>(), mem::size_of::<U>());\n        let ts: usize = mem::size_of::<U>() / gcd;\n        let us: usize = mem::size_of::<T>() / gcd;\n\n        // Armed with this knowledge, we can find how many `U`s we can fit!\n        let us_len = self.len() / ts * us;\n        // And how many `T`s will be in the trailing slice!\n        let ts_len = self.len() % ts;\n        (us_len, ts_len)\n    }\n\n    /// Transmute the slice to a slice of another type, ensuring alignment of the types is\n    /// maintained.\n    ///\n    /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n    /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest\n    /// length possible for a given type and input slice, but only your algorithm's performance\n    /// should depend on that, not its correctness. It is permissible for all of the input data to\n    /// be returned as the prefix or suffix slice.\n    ///\n    /// This method has no purpose when either input element `T` or output element `U` are\n    /// zero-sized and will return the original slice without splitting anything.\n    ///\n    /// # Safety\n    ///\n    /// This method is essentially a `transmute` with respect to the elements in the returned\n    /// middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// unsafe {\n    ///     let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n    ///     let (prefix, shorts, suffix) = bytes.align_to::<u16>();\n    ///     // less_efficient_algorithm_for_bytes(prefix);\n    ///     // more_efficient_algorithm_for_aligned_shorts(shorts);\n    ///     // less_efficient_algorithm_for_bytes(suffix);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_align_to\", since = \"1.30.0\")]\n    pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n        // Note that most of this function will be constant-evaluated,\n        if mem::size_of::<U>() == 0 || mem::size_of::<T>() == 0 {\n            // handle ZSTs specially, which is – don't handle them at all.\n            return (self, &[], &[]);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n        let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n        if offset > self.len() {\n            (self, &[], &[])\n        } else {\n            let (left, rest) = self.split_at(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n            // since the caller guarantees that we can transmute `T` to `U` safely.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n                )\n            }\n        }\n    }\n\n    /// Transmute the slice to a slice of another type, ensuring alignment of the types is\n    /// maintained.\n    ///\n    /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n    /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest\n    /// length possible for a given type and input slice, but only your algorithm's performance\n    /// should depend on that, not its correctness. It is permissible for all of the input data to\n    /// be returned as the prefix or suffix slice.\n    ///\n    /// This method has no purpose when either input element `T` or output element `U` are\n    /// zero-sized and will return the original slice without splitting anything.\n    ///\n    /// # Safety\n    ///\n    /// This method is essentially a `transmute` with respect to the elements in the returned\n    /// middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// unsafe {\n    ///     let mut bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n    ///     let (prefix, shorts, suffix) = bytes.align_to_mut::<u16>();\n    ///     // less_efficient_algorithm_for_bytes(prefix);\n    ///     // more_efficient_algorithm_for_aligned_shorts(shorts);\n    ///     // less_efficient_algorithm_for_bytes(suffix);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_align_to\", since = \"1.30.0\")]\n    pub unsafe fn align_to_mut<U>(&mut self) -> (&mut [T], &mut [U], &mut [T]) {\n        // Note that most of this function will be constant-evaluated,\n        if mem::size_of::<U>() == 0 || mem::size_of::<T>() == 0 {\n            // handle ZSTs specially, which is – don't handle them at all.\n            return (self, &mut [], &mut []);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: Here we are ensuring we will use aligned pointers for U for the\n        // rest of the method. This is done by passing a pointer to &[T] with an\n        // alignment targeted for U.\n        // `crate::ptr::align_offset` is called with a correctly aligned and\n        // valid pointer `ptr` (it comes from a reference to `self`) and with\n        // a size that is a power of two (since it comes from the alignement for U),\n        // satisfying its safety constraints.\n        let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n        if offset > self.len() {\n            (self, &mut [], &mut [])\n        } else {\n            let (left, rest) = self.split_at_mut(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            let rest_len = rest.len();\n            let mut_ptr = rest.as_mut_ptr();\n            // We can't use `rest` again after this, that would invalidate its alias `mut_ptr`!\n            // SAFETY: see comments for `align_to`.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts_mut(mut_ptr as *mut U, us_len),\n                    from_raw_parts_mut(mut_ptr.add(rest_len - ts_len), ts_len),\n                )\n            }\n        }\n    }\n\n    /// Checks if the elements of this slice are sorted.\n    ///\n    /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n    /// slice yields exactly zero or one element, `true` is returned.\n    ///\n    /// Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition\n    /// implies that this function returns `false` if any two consecutive items are not\n    /// comparable.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(is_sorted)]\n    /// let empty: [i32; 0] = [];\n    ///\n    /// assert!([1, 2, 2, 9].is_sorted());\n    /// assert!(![1, 3, 2, 4].is_sorted());\n    /// assert!([0].is_sorted());\n    /// assert!(empty.is_sorted());\n    /// assert!(![0.0, 1.0, f32::NAN].is_sorted());\n    /// ```\n    #[inline]\n    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n    pub fn is_sorted(&self) -> bool\n    where\n        T: PartialOrd,\n    {\n        self.is_sorted_by(|a, b| a.partial_cmp(b))\n    }\n\n    /// Checks if the elements of this slice are sorted using the given comparator function.\n    ///\n    /// Instead of using `PartialOrd::partial_cmp`, this function uses the given `compare`\n    /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n    /// [`is_sorted`]; see its documentation for more information.\n    ///\n    /// [`is_sorted`]: slice::is_sorted\n    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n    pub fn is_sorted_by<F>(&self, mut compare: F) -> bool\n    where\n        F: FnMut(&T, &T) -> Option<Ordering>,\n    {\n        self.iter().is_sorted_by(|a, b| compare(*a, *b))\n    }\n\n    /// Checks if the elements of this slice are sorted using the given key extraction function.\n    ///\n    /// Instead of comparing the slice's elements directly, this function compares the keys of the\n    /// elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see its\n    /// documentation for more information.\n    ///\n    /// [`is_sorted`]: slice::is_sorted\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(is_sorted)]\n    ///\n    /// assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n    /// assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n    /// ```\n    #[inline]\n    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n    pub fn is_sorted_by_key<F, K>(&self, f: F) -> bool\n    where\n        F: FnMut(&T) -> K,\n        K: PartialOrd,\n    {\n        self.iter().is_sorted_by_key(f)\n    }\n\n    /// Returns the index of the partition point according to the given predicate\n    /// (the index of the first element of the second partition).\n    ///\n    /// The slice is assumed to be partitioned according to the given predicate.\n    /// This means that all elements for which the predicate returns true are at the start of the slice\n    /// and all elements for which the predicate returns false are at the end.\n    /// For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0\n    /// (all odd numbers are at the start, all even at the end).\n    ///\n    /// If this slice is not partitioned, the returned result is unspecified and meaningless,\n    /// as this method performs a kind of binary search.\n    ///\n    /// See also [`binary_search`], [`binary_search_by`], and [`binary_search_by_key`].\n    ///\n    /// [`binary_search`]: slice::binary_search\n    /// [`binary_search_by`]: slice::binary_search_by\n    /// [`binary_search_by_key`]: slice::binary_search_by_key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [1, 2, 3, 3, 5, 6, 7];\n    /// let i = v.partition_point(|&x| x < 5);\n    ///\n    /// assert_eq!(i, 4);\n    /// assert!(v[..i].iter().all(|&x| x < 5));\n    /// assert!(v[i..].iter().all(|&x| !(x < 5)));\n    /// ```\n    #[stable(feature = \"partition_point\", since = \"1.52.0\")]\n    pub fn partition_point<P>(&self, mut pred: P) -> usize\n    where\n        P: FnMut(&T) -> bool,\n    {\n        self.binary_search_by(|x| if pred(x) { Less } else { Greater }).unwrap_or_else(|i| i)\n    }\n}\n\ntrait CloneFromSpec<T> {\n    fn spec_clone_from(&mut self, src: &[T]);\n}\n\nimpl<T> CloneFromSpec<T> for [T]\nwhere\n    T: Clone,\n{\n    default fn spec_clone_from(&mut self, src: &[T]) {\n        assert!(self.len() == src.len(), \"destination and source slices have different lengths\");\n        // NOTE: We need to explicitly slice them to the same length\n        // to make it easier for the optimizer to elide bounds checking.\n        // But since it can't be relied on we also have an explicit specialization for T: Copy.\n        let len = self.len();\n        let src = &src[..len];\n        for i in 0..len {\n            self[i].clone_from(&src[i]);\n        }\n    }\n}\n\nimpl<T> CloneFromSpec<T> for [T]\nwhere\n    T: Copy,\n{\n    fn spec_clone_from(&mut self, src: &[T]) {\n        self.copy_from_slice(src);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for &[T] {\n    /// Creates an empty slice.\n    fn default() -> Self {\n        &[]\n    }\n}\n\n#[stable(feature = \"mut_slice_default\", since = \"1.5.0\")]\nimpl<T> Default for &mut [T] {\n    /// Creates a mutable empty slice.\n    fn default() -> Self {\n        &mut []\n    }\n}\n\n#[unstable(feature = \"slice_pattern\", reason = \"stopgap trait for slice patterns\", issue = \"56345\")]\n/// Patterns in slices - currently, only used by `strip_prefix` and `strip_suffix`.  At a future\n/// point, we hope to generalise `core::str::Pattern` (which at the time of writing is limited to\n/// `str`) to slices, and then this trait will be replaced or abolished.\npub trait SlicePattern {\n    /// The element type of the slice being matched on.\n    type Item;\n\n    /// Currently, the consumers of `SlicePattern` need a slice.\n    fn as_slice(&self) -> &[Self::Item];\n}\n\n#[stable(feature = \"slice_strip\", since = \"1.51.0\")]\nimpl<T> SlicePattern for [T] {\n    type Item = T;\n\n    #[inline]\n    fn as_slice(&self) -> &[Self::Item] {\n        self\n    }\n}\n\n#[stable(feature = \"slice_strip\", since = \"1.51.0\")]\nimpl<T, const N: usize> SlicePattern for [T; N] {\n    type Item = T;\n\n    #[inline]\n    fn as_slice(&self) -> &[Self::Item] {\n        self\n    }\n}\n"],[2855,"//! Operations on ASCII `[u8]`.\n\nuse crate::ascii;\nuse crate::fmt::{self, Write};\nuse crate::iter;\nuse crate::mem;\nuse crate::ops;\n\n#[lang = \"slice_u8\"]\n#[cfg(not(test))]\nimpl [u8] {\n    /// Checks if all bytes in this slice are within the ASCII range.\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n        is_ascii(self)\n    }\n\n    /// Checks that two slices are an ASCII case-insensitive match.\n    ///\n    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n    /// but without allocating and copying temporaries.\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n        self.len() == other.len() && iter::zip(self, other).all(|(a, b)| a.eq_ignore_ascii_case(b))\n    }\n\n    /// Converts this slice to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`to_ascii_uppercase`].\n    ///\n    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        for byte in self {\n            byte.make_ascii_uppercase();\n        }\n    }\n\n    /// Converts this slice to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`to_ascii_lowercase`].\n    ///\n    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        for byte in self {\n            byte.make_ascii_lowercase();\n        }\n    }\n\n    /// Returns an iterator that produces an escaped version of this slice,\n    /// treating it as an ASCII string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(inherent_ascii_escape)]\n    ///\n    /// let s = b\"0\\t\\r\\n'\\\"\\\\\\x9d\";\n    /// let escaped = s.escape_ascii().to_string();\n    /// assert_eq!(escaped, \"0\\\\t\\\\r\\\\n\\\\'\\\\\\\"\\\\\\\\\\\\x9d\");\n    /// ```\n    #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n    pub fn escape_ascii(&self) -> EscapeAscii<'_> {\n        EscapeAscii { inner: self.iter().flat_map(EscapeByte) }\n    }\n}\n\nimpl_fn_for_zst! {\n    #[derive(Clone)]\n    struct EscapeByte impl Fn = |byte: &u8| -> ascii::EscapeDefault {\n        ascii::escape_default(*byte)\n    };\n}\n\n/// An iterator over the escaped version of a byte slice.\n///\n/// This `struct` is created by the [`slice::escape_ascii`] method. See its\n/// documentation for more information.\n#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n#[derive(Clone)]\npub struct EscapeAscii<'a> {\n    inner: iter::FlatMap<super::Iter<'a, u8>, ascii::EscapeDefault, EscapeByte>,\n}\n\n#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\nimpl<'a> iter::Iterator for EscapeAscii<'a> {\n    type Item = u8;\n    #[inline]\n    fn next(&mut self) -> Option<u8> {\n        self.inner.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[inline]\n    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n    where\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: ops::Try<Output = Acc>,\n    {\n        self.inner.try_fold(init, fold)\n    }\n    #[inline]\n    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.inner.fold(init, fold)\n    }\n    #[inline]\n    fn last(mut self) -> Option<u8> {\n        self.next_back()\n    }\n}\n\n#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\nimpl<'a> iter::DoubleEndedIterator for EscapeAscii<'a> {\n    fn next_back(&mut self) -> Option<u8> {\n        self.inner.next_back()\n    }\n}\n#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\nimpl<'a> iter::ExactSizeIterator for EscapeAscii<'a> {}\n#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\nimpl<'a> iter::FusedIterator for EscapeAscii<'a> {}\n#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\nimpl<'a> fmt::Display for EscapeAscii<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.clone().try_for_each(|b| f.write_char(b as char))\n    }\n}\n#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\nimpl<'a> fmt::Debug for EscapeAscii<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"EscapeAscii\").finish_non_exhaustive()\n    }\n}\n\n/// Returns `true` if any byte in the word `v` is nonascii (>= 128). Snarfed\n/// from `../str/mod.rs`, which does something similar for utf8 validation.\n#[inline]\nfn contains_nonascii(v: usize) -> bool {\n    const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n    (NONASCII_MASK & v) != 0\n}\n\n/// Optimized ASCII test that will use usize-at-a-time operations instead of\n/// byte-at-a-time operations (when possible).\n///\n/// The algorithm we use here is pretty simple. If `s` is too short, we just\n/// check each byte and be done with it. Otherwise:\n///\n/// - Read the first word with an unaligned load.\n/// - Align the pointer, read subsequent words until end with aligned loads.\n/// - Read the last `usize` from `s` with an unaligned load.\n///\n/// If any of these loads produces something for which `contains_nonascii`\n/// (above) returns true, then we know the answer is false.\n#[inline]\nfn is_ascii(s: &[u8]) -> bool {\n    const USIZE_SIZE: usize = mem::size_of::<usize>();\n\n    let len = s.len();\n    let align_offset = s.as_ptr().align_offset(USIZE_SIZE);\n\n    // If we wouldn't gain anything from the word-at-a-time implementation, fall\n    // back to a scalar loop.\n    //\n    // We also do this for architectures where `size_of::<usize>()` isn't\n    // sufficient alignment for `usize`, because it's a weird edge case.\n    if len < USIZE_SIZE || len < align_offset || USIZE_SIZE < mem::align_of::<usize>() {\n        return s.iter().all(|b| b.is_ascii());\n    }\n\n    // We always read the first word unaligned, which means `align_offset` is\n    // 0, we'd read the same value again for the aligned read.\n    let offset_to_aligned = if align_offset == 0 { USIZE_SIZE } else { align_offset };\n\n    let start = s.as_ptr();\n    // SAFETY: We verify `len < USIZE_SIZE` above.\n    let first_word = unsafe { (start as *const usize).read_unaligned() };\n\n    if contains_nonascii(first_word) {\n        return false;\n    }\n    // We checked this above, somewhat implicitly. Note that `offset_to_aligned`\n    // is either `align_offset` or `USIZE_SIZE`, both of are explicitly checked\n    // above.\n    debug_assert!(offset_to_aligned <= len);\n\n    // SAFETY: word_ptr is the (properly aligned) usize ptr we use to read the\n    // middle chunk of the slice.\n    let mut word_ptr = unsafe { start.add(offset_to_aligned) as *const usize };\n\n    // `byte_pos` is the byte index of `word_ptr`, used for loop end checks.\n    let mut byte_pos = offset_to_aligned;\n\n    // Paranoia check about alignment, since we're about to do a bunch of\n    // unaligned loads. In practice this should be impossible barring a bug in\n    // `align_offset` though.\n    debug_assert_eq!((word_ptr as usize) % mem::align_of::<usize>(), 0);\n\n    // Read subsequent words until the last aligned word, excluding the last\n    // aligned word by itself to be done in tail check later, to ensure that\n    // tail is always one `usize` at most to extra branch `byte_pos == len`.\n    while byte_pos < len - USIZE_SIZE {\n        debug_assert!(\n            // Sanity check that the read is in bounds\n            (word_ptr as usize + USIZE_SIZE) <= (start.wrapping_add(len) as usize) &&\n            // And that our assumptions about `byte_pos` hold.\n            (word_ptr as usize) - (start as usize) == byte_pos\n        );\n\n        // SAFETY: We know `word_ptr` is properly aligned (because of\n        // `align_offset`), and we know that we have enough bytes between `word_ptr` and the end\n        let word = unsafe { word_ptr.read() };\n        if contains_nonascii(word) {\n            return false;\n        }\n\n        byte_pos += USIZE_SIZE;\n        // SAFETY: We know that `byte_pos <= len - USIZE_SIZE`, which means that\n        // after this `add`, `word_ptr` will be at most one-past-the-end.\n        word_ptr = unsafe { word_ptr.add(1) };\n    }\n\n    // Sanity check to ensure there really is only one `usize` left. This should\n    // be guaranteed by our loop condition.\n    debug_assert!(byte_pos <= len && len - byte_pos <= USIZE_SIZE);\n\n    // SAFETY: This relies on `len >= USIZE_SIZE`, which we check at the start.\n    let last_word = unsafe { (start.add(len - USIZE_SIZE) as *const usize).read_unaligned() };\n\n    !contains_nonascii(last_word)\n}\n"],[2856,"// Original implementation taken from rust-memchr.\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\nuse crate::cmp;\nuse crate::mem;\n\nconst LO_U64: u64 = 0x0101010101010101;\nconst HI_U64: u64 = 0x8080808080808080;\n\n// Use truncation.\nconst LO_USIZE: usize = LO_U64 as usize;\nconst HI_USIZE: usize = HI_U64 as usize;\nconst USIZE_BYTES: usize = mem::size_of::<usize>();\n\n/// Returns `true` if `x` contains any zero byte.\n///\n/// From *Matters Computational*, J. Arndt:\n///\n/// \"The idea is to subtract one from each of the bytes and then look for\n/// bytes where the borrow propagated all the way to the most significant\n/// bit.\"\n#[inline]\nfn contains_zero_byte(x: usize) -> bool {\n    x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[inline]\nfn repeat_byte(b: u8) -> usize {\n    (b as usize) << 8 | b as usize\n}\n\n#[cfg(not(target_pointer_width = \"16\"))]\n#[inline]\nfn repeat_byte(b: u8) -> usize {\n    (b as usize) * (usize::MAX / 255)\n}\n\n/// Returns the first index matching the byte `x` in `text`.\n#[inline]\npub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n    // Fast path for small slices\n    if text.len() < 2 * USIZE_BYTES {\n        return text.iter().position(|elt| *elt == x);\n    }\n\n    memchr_general_case(x, text)\n}\n\nfn memchr_general_case(x: u8, text: &[u8]) -> Option<usize> {\n    // Scan for a single byte value by reading two `usize` words at a time.\n    //\n    // Split `text` in three parts\n    // - unaligned initial part, before the first word aligned address in text\n    // - body, scan by 2 words at a time\n    // - the last remaining part, < 2 word size\n\n    // search up to an aligned boundary\n    let len = text.len();\n    let ptr = text.as_ptr();\n    let mut offset = ptr.align_offset(USIZE_BYTES);\n\n    if offset > 0 {\n        offset = cmp::min(offset, len);\n        if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n            return Some(index);\n        }\n    }\n\n    // search the body of the text\n    let repeated_x = repeat_byte(x);\n    while offset <= len - 2 * USIZE_BYTES {\n        // SAFETY: the while's predicate guarantees a distance of at least 2 * usize_bytes\n        // between the offset and the end of the slice.\n        unsafe {\n            let u = *(ptr.add(offset) as *const usize);\n            let v = *(ptr.add(offset + USIZE_BYTES) as *const usize);\n\n            // break if there is a matching byte\n            let zu = contains_zero_byte(u ^ repeated_x);\n            let zv = contains_zero_byte(v ^ repeated_x);\n            if zu || zv {\n                break;\n            }\n        }\n        offset += USIZE_BYTES * 2;\n    }\n\n    // Find the byte after the point the body loop stopped.\n    text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n}\n\n/// Returns the last index matching the byte `x` in `text`.\npub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n    // Scan for a single byte value by reading two `usize` words at a time.\n    //\n    // Split `text` in three parts:\n    // - unaligned tail, after the last word aligned address in text,\n    // - body, scanned by 2 words at a time,\n    // - the first remaining bytes, < 2 word size.\n    let len = text.len();\n    let ptr = text.as_ptr();\n    type Chunk = usize;\n\n    let (min_aligned_offset, max_aligned_offset) = {\n        // We call this just to obtain the length of the prefix and suffix.\n        // In the middle we always process two chunks at once.\n        // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size differences\n        // which are handled by `align_to`.\n        let (prefix, _, suffix) = unsafe { text.align_to::<(Chunk, Chunk)>() };\n        (prefix.len(), len - suffix.len())\n    };\n\n    let mut offset = max_aligned_offset;\n    if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n        return Some(offset + index);\n    }\n\n    // Search the body of the text, make sure we don't cross min_aligned_offset.\n    // offset is always aligned, so just testing `>` is sufficient and avoids possible\n    // overflow.\n    let repeated_x = repeat_byte(x);\n    let chunk_bytes = mem::size_of::<Chunk>();\n\n    while offset > min_aligned_offset {\n        // SAFETY: offset starts at len - suffix.len(), as long as it is greater than\n        // min_aligned_offset (prefix.len()) the remaining distance is at least 2 * chunk_bytes.\n        unsafe {\n            let u = *(ptr.offset(offset as isize - 2 * chunk_bytes as isize) as *const Chunk);\n            let v = *(ptr.offset(offset as isize - chunk_bytes as isize) as *const Chunk);\n\n            // Break if there is a matching byte.\n            let zu = contains_zero_byte(u ^ repeated_x);\n            let zv = contains_zero_byte(v ^ repeated_x);\n            if zu || zv {\n                break;\n            }\n        }\n        offset -= 2 * chunk_bytes;\n    }\n\n    // Find the byte before the point the body loop stopped.\n    text[..offset].iter().rposition(|elt| *elt == x)\n}\n"],[2857,"//! Indexing implementations for `[T]`.\n\nuse crate::ops;\nuse crate::ptr;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, I> ops::Index<I> for [T]\nwhere\n    I: SliceIndex<[T]>,\n{\n    type Output = I::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &I::Output {\n        index.index(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, I> ops::IndexMut<I> for [T]\nwhere\n    I: SliceIndex<[T]>,\n{\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut I::Output {\n        index.index_mut(self)\n    }\n}\n\n#[inline(never)]\n#[cold]\n#[track_caller]\nfn slice_start_index_len_fail(index: usize, len: usize) -> ! {\n    panic!(\"range start index {} out of range for slice of length {}\", index, len);\n}\n\n#[inline(never)]\n#[cold]\n#[track_caller]\nfn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n    panic!(\"range end index {} out of range for slice of length {}\", index, len);\n}\n\n#[inline(never)]\n#[cold]\n#[track_caller]\nfn slice_index_order_fail(index: usize, end: usize) -> ! {\n    panic!(\"slice index starts at {} but ends at {}\", index, end);\n}\n\n#[inline(never)]\n#[cold]\n#[track_caller]\nfn slice_start_index_overflow_fail() -> ! {\n    panic!(\"attempted to index slice from after maximum usize\");\n}\n\n#[inline(never)]\n#[cold]\n#[track_caller]\nfn slice_end_index_overflow_fail() -> ! {\n    panic!(\"attempted to index slice up to maximum usize\");\n}\n\nmod private_slice_index {\n    use super::ops;\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    pub trait Sealed {}\n\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for usize {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::Range<usize> {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeTo<usize> {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeFrom<usize> {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeFull {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeInclusive<usize> {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeToInclusive<usize> {}\n    #[stable(feature = \"slice_index_with_ops_bound_pair\", since = \"1.53.0\")]\n    impl Sealed for (ops::Bound<usize>, ops::Bound<usize>) {}\n}\n\n/// A helper trait used for indexing operations.\n///\n/// Implementations of this trait have to promise that if the argument\n/// to `get_(mut_)unchecked` is a safe reference, then so is the result.\n#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n#[rustc_on_unimplemented(\n    on(T = \"str\", label = \"string indices are ranges of `usize`\",),\n    on(\n        all(any(T = \"str\", T = \"&str\", T = \"std::string::String\"), _Self = \"{integer}\"),\n        note = \"you can use `.chars().nth()` or `.bytes().nth()`\\n\\\n                for more information, see chapter 8 in The Book: \\\n                <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n    ),\n    message = \"the type `{T}` cannot be indexed by `{Self}`\",\n    label = \"slice indices are of type `usize` or ranges of `usize`\"\n)]\npub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n    /// The output type returned by methods.\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    type Output: ?Sized;\n\n    /// Returns a shared reference to the output at this location, if in\n    /// bounds.\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    fn get(self, slice: &T) -> Option<&Self::Output>;\n\n    /// Returns a mutable reference to the output at this location, if in\n    /// bounds.\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    fn get_mut(self, slice: &mut T) -> Option<&mut Self::Output>;\n\n    /// Returns a shared reference to the output at this location, without\n    /// performing any bounds checking.\n    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n    /// is *[undefined behavior]* even if the resulting reference is not used.\n    ///\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n\n    /// Returns a mutable reference to the output at this location, without\n    /// performing any bounds checking.\n    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n    /// is *[undefined behavior]* even if the resulting reference is not used.\n    ///\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    unsafe fn get_unchecked_mut(self, slice: *mut T) -> *mut Self::Output;\n\n    /// Returns a shared reference to the output at this location, panicking\n    /// if out of bounds.\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    #[track_caller]\n    fn index(self, slice: &T) -> &Self::Output;\n\n    /// Returns a mutable reference to the output at this location, panicking\n    /// if out of bounds.\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    #[track_caller]\n    fn index_mut(self, slice: &mut T) -> &mut Self::Output;\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nunsafe impl<T> SliceIndex<[T]> for usize {\n    type Output = T;\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&T> {\n        // SAFETY: `self` is checked to be in bounds.\n        if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n        // SAFETY: `self` is checked to be in bounds.\n        if self < slice.len() { unsafe { Some(&mut *self.get_unchecked_mut(slice)) } } else { None }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n        // cannot be longer than `isize::MAX`. They also guarantee that\n        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n        // so the call to `add` is safe.\n        unsafe { slice.as_ptr().add(self) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {\n        // SAFETY: see comments for `get_unchecked` above.\n        unsafe { slice.as_mut_ptr().add(self) }\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &T {\n        // N.B., use intrinsic indexing\n        &(*slice)[self]\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut T {\n        // N.B., use intrinsic indexing\n        &mut (*slice)[self]\n    }\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nunsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        if self.start > self.end || self.end > slice.len() {\n            None\n        } else {\n            // SAFETY: `self` is checked to be valid and in bounds above.\n            unsafe { Some(&*self.get_unchecked(slice)) }\n        }\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        if self.start > self.end || self.end > slice.len() {\n            None\n        } else {\n            // SAFETY: `self` is checked to be valid and in bounds above.\n            unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n        }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n        // cannot be longer than `isize::MAX`. They also guarantee that\n        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n        // so the call to `add` is safe.\n        unsafe { ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n        // SAFETY: see comments for `get_unchecked` above.\n        unsafe {\n            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n        }\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        if self.start > self.end {\n            slice_index_order_fail(self.start, self.end);\n        } else if self.end > slice.len() {\n            slice_end_index_len_fail(self.end, slice.len());\n        }\n        // SAFETY: `self` is checked to be valid and in bounds above.\n        unsafe { &*self.get_unchecked(slice) }\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        if self.start > self.end {\n            slice_index_order_fail(self.start, self.end);\n        } else if self.end > slice.len() {\n            slice_end_index_len_fail(self.end, slice.len());\n        }\n        // SAFETY: `self` is checked to be valid and in bounds above.\n        unsafe { &mut *self.get_unchecked_mut(slice) }\n    }\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nunsafe impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        (0..self.end).get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        (0..self.end).get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { (0..self.end).get_unchecked(slice) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n        unsafe { (0..self.end).get_unchecked_mut(slice) }\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        (0..self.end).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0..self.end).index_mut(slice)\n    }\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nunsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        (self.start..slice.len()).get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        (self.start..slice.len()).get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { (self.start..slice.len()).get_unchecked(slice) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n        unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        if self.start > slice.len() {\n            slice_start_index_len_fail(self.start, slice.len());\n        }\n        // SAFETY: `self` is checked to be valid and in bounds above.\n        unsafe { &*self.get_unchecked(slice) }\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        if self.start > slice.len() {\n            slice_start_index_len_fail(self.start, slice.len());\n        }\n        // SAFETY: `self` is checked to be valid and in bounds above.\n        unsafe { &mut *self.get_unchecked_mut(slice) }\n    }\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nunsafe impl<T> SliceIndex<[T]> for ops::RangeFull {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        Some(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        Some(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n        slice\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n        slice\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        slice\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        slice\n    }\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nunsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        if *self.end() == usize::MAX { None } else { self.into_slice_range().get(slice) }\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        if *self.end() == usize::MAX { None } else { self.into_slice_range().get_mut(slice) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { self.into_slice_range().get_unchecked(slice) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n        unsafe { self.into_slice_range().get_unchecked_mut(slice) }\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        if *self.end() == usize::MAX {\n            slice_end_index_overflow_fail();\n        }\n        self.into_slice_range().index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        if *self.end() == usize::MAX {\n            slice_end_index_overflow_fail();\n        }\n        self.into_slice_range().index_mut(slice)\n    }\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nunsafe impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n        (0..=self.end).get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n        (0..=self.end).get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { (0..=self.end).get_unchecked(slice) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n        unsafe { (0..=self.end).get_unchecked_mut(slice) }\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n        (0..=self.end).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n        (0..=self.end).index_mut(slice)\n    }\n}\n\n/// Performs bounds-checking of a range.\n///\n/// This method is similar to [`Index::index`] for slices, but it returns a\n/// [`Range`] equivalent to `range`. You can use this method to turn any range\n/// into `start` and `end` values.\n///\n/// `bounds` is the range of the slice to use for bounds-checking. It should\n/// be a [`RangeTo`] range that ends at the length of the slice.\n///\n/// The returned [`Range`] is safe to pass to [`slice::get_unchecked`] and\n/// [`slice::get_unchecked_mut`] for slices with the given range.\n///\n/// [`Range`]: ops::Range\n/// [`RangeTo`]: ops::RangeTo\n/// [`slice::get_unchecked`]: slice::get_unchecked\n/// [`slice::get_unchecked_mut`]: slice::get_unchecked_mut\n///\n/// # Panics\n///\n/// Panics if `range` would be out of bounds.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(slice_range)]\n///\n/// use std::slice;\n///\n/// let v = [10, 40, 30];\n/// assert_eq!(1..2, slice::range(1..2, ..v.len()));\n/// assert_eq!(0..2, slice::range(..2, ..v.len()));\n/// assert_eq!(1..3, slice::range(1.., ..v.len()));\n/// ```\n///\n/// Panics when [`Index::index`] would panic:\n///\n/// ```should_panic\n/// #![feature(slice_range)]\n///\n/// use std::slice;\n///\n/// slice::range(2..1, ..3);\n/// ```\n///\n/// ```should_panic\n/// #![feature(slice_range)]\n///\n/// use std::slice;\n///\n/// slice::range(1..4, ..3);\n/// ```\n///\n/// ```should_panic\n/// #![feature(slice_range)]\n///\n/// use std::slice;\n///\n/// slice::range(1..=usize::MAX, ..3);\n/// ```\n///\n/// [`Index::index`]: ops::Index::index\n#[track_caller]\n#[unstable(feature = \"slice_range\", issue = \"76393\")]\npub fn range<R>(range: R, bounds: ops::RangeTo<usize>) -> ops::Range<usize>\nwhere\n    R: ops::RangeBounds<usize>,\n{\n    let len = bounds.end;\n\n    let start: ops::Bound<&usize> = range.start_bound();\n    let start = match start {\n        ops::Bound::Included(&start) => start,\n        ops::Bound::Excluded(start) => {\n            start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n        }\n        ops::Bound::Unbounded => 0,\n    };\n\n    let end: ops::Bound<&usize> = range.end_bound();\n    let end = match end {\n        ops::Bound::Included(end) => {\n            end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n        }\n        ops::Bound::Excluded(&end) => end,\n        ops::Bound::Unbounded => len,\n    };\n\n    if start > end {\n        slice_index_order_fail(start, end);\n    }\n    if end > len {\n        slice_end_index_len_fail(end, len);\n    }\n\n    ops::Range { start, end }\n}\n\n/// Convert pair of `ops::Bound`s into `ops::Range` without performing any bounds checking and (in debug) overflow checking\nfn into_range_unchecked(\n    len: usize,\n    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n) -> ops::Range<usize> {\n    use ops::Bound;\n    let start = match start {\n        Bound::Included(i) => i,\n        Bound::Excluded(i) => i + 1,\n        Bound::Unbounded => 0,\n    };\n    let end = match end {\n        Bound::Included(i) => i + 1,\n        Bound::Excluded(i) => i,\n        Bound::Unbounded => len,\n    };\n    start..end\n}\n\n/// Convert pair of `ops::Bound`s into `ops::Range`.\n/// Returns `None` on overflowing indices.\nfn into_range(\n    len: usize,\n    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n) -> Option<ops::Range<usize>> {\n    use ops::Bound;\n    let start = match start {\n        Bound::Included(start) => start,\n        Bound::Excluded(start) => start.checked_add(1)?,\n        Bound::Unbounded => 0,\n    };\n\n    let end = match end {\n        Bound::Included(end) => end.checked_add(1)?,\n        Bound::Excluded(end) => end,\n        Bound::Unbounded => len,\n    };\n\n    // Don't bother with checking `start < end` and `end <= len`\n    // since these checks are handled by `Range` impls\n\n    Some(start..end)\n}\n\n/// Convert pair of `ops::Bound`s into `ops::Range`.\n/// Panics on overflowing indices.\nfn into_slice_range(\n    len: usize,\n    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n) -> ops::Range<usize> {\n    use ops::Bound;\n    let start = match start {\n        Bound::Included(start) => start,\n        Bound::Excluded(start) => {\n            start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n        }\n        Bound::Unbounded => 0,\n    };\n\n    let end = match end {\n        Bound::Included(end) => {\n            end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n        }\n        Bound::Excluded(end) => end,\n        Bound::Unbounded => len,\n    };\n\n    // Don't bother with checking `start < end` and `end <= len`\n    // since these checks are handled by `Range` impls\n\n    start..end\n}\n\n#[stable(feature = \"slice_index_with_ops_bound_pair\", since = \"1.53.0\")]\nunsafe impl<T> SliceIndex<[T]> for (ops::Bound<usize>, ops::Bound<usize>) {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&Self::Output> {\n        into_range(slice.len(), self)?.get(slice)\n    }\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut Self::Output> {\n        into_range(slice.len(), self)?.get_mut(slice)\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const Self::Output {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { into_range_unchecked(slice.len(), self).get_unchecked(slice) }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut Self::Output {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n        unsafe { into_range_unchecked(slice.len(), self).get_unchecked_mut(slice) }\n    }\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &Self::Output {\n        into_slice_range(slice.len(), self).index(slice)\n    }\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut Self::Output {\n        into_slice_range(slice.len(), self).index_mut(slice)\n    }\n}\n"],[2858,"//! Comparison traits for `[T]`.\n\nuse crate::cmp;\nuse crate::cmp::Ordering::{self, Greater, Less};\nuse crate::mem;\n\nuse super::from_raw_parts;\nuse super::memchr;\n\nextern \"C\" {\n    /// Calls implementation provided memcmp.\n    ///\n    /// Interprets the data as u8.\n    ///\n    /// Returns 0 for equal, < 0 for less than and > 0 for greater\n    /// than.\n    // FIXME(#32610): Return type should be c_int\n    fn memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> PartialEq<[B]> for [A]\nwhere\n    A: PartialEq<B>,\n{\n    fn eq(&self, other: &[B]) -> bool {\n        SlicePartialEq::equal(self, other)\n    }\n\n    fn ne(&self, other: &[B]) -> bool {\n        SlicePartialEq::not_equal(self, other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq> Eq for [T] {}\n\n/// Implements comparison of vectors [lexicographically](Ord#lexicographical-comparison).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Ord for [T] {\n    fn cmp(&self, other: &[T]) -> Ordering {\n        SliceOrd::compare(self, other)\n    }\n}\n\n/// Implements comparison of vectors [lexicographically](Ord#lexicographical-comparison).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd> PartialOrd for [T] {\n    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n        SlicePartialOrd::partial_compare(self, other)\n    }\n}\n\n#[doc(hidden)]\n// intermediate trait for specialization of slice's PartialEq\ntrait SlicePartialEq<B> {\n    fn equal(&self, other: &[B]) -> bool;\n\n    fn not_equal(&self, other: &[B]) -> bool {\n        !self.equal(other)\n    }\n}\n\n// Generic slice equality\nimpl<A, B> SlicePartialEq<B> for [A]\nwhere\n    A: PartialEq<B>,\n{\n    default fn equal(&self, other: &[B]) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n    }\n}\n\n// Use memcmp for bytewise equality when the types allow\nimpl<A, B> SlicePartialEq<B> for [A]\nwhere\n    A: BytewiseEquality<B>,\n{\n    fn equal(&self, other: &[B]) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.\n        // The two slices have been checked to have the same size above.\n        unsafe {\n            let size = mem::size_of_val(self);\n            memcmp(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0\n        }\n    }\n}\n\n#[doc(hidden)]\n// intermediate trait for specialization of slice's PartialOrd\ntrait SlicePartialOrd: Sized {\n    fn partial_compare(left: &[Self], right: &[Self]) -> Option<Ordering>;\n}\n\nimpl<A: PartialOrd> SlicePartialOrd for A {\n    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n        let l = cmp::min(left.len(), right.len());\n\n        // Slice to the loop iteration range to enable bound check\n        // elimination in the compiler\n        let lhs = &left[..l];\n        let rhs = &right[..l];\n\n        for i in 0..l {\n            match lhs[i].partial_cmp(&rhs[i]) {\n                Some(Ordering::Equal) => (),\n                non_eq => return non_eq,\n            }\n        }\n\n        left.len().partial_cmp(&right.len())\n    }\n}\n\n// This is the impl that we would like to have. Unfortunately it's not sound.\n// See `partial_ord_slice.rs`.\n/*\nimpl<A> SlicePartialOrd for A\nwhere\n    A: Ord,\n{\n    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n        Some(SliceOrd::compare(left, right))\n    }\n}\n*/\n\nimpl<A: AlwaysApplicableOrd> SlicePartialOrd for A {\n    fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n        Some(SliceOrd::compare(left, right))\n    }\n}\n\n#[rustc_specialization_trait]\ntrait AlwaysApplicableOrd: SliceOrd + Ord {}\n\nmacro_rules! always_applicable_ord {\n    ($([$($p:tt)*] $t:ty,)*) => {\n        $(impl<$($p)*> AlwaysApplicableOrd for $t {})*\n    }\n}\n\nalways_applicable_ord! {\n    [] u8, [] u16, [] u32, [] u64, [] u128, [] usize,\n    [] i8, [] i16, [] i32, [] i64, [] i128, [] isize,\n    [] bool, [] char,\n    [T: ?Sized] *const T, [T: ?Sized] *mut T,\n    [T: AlwaysApplicableOrd] &T,\n    [T: AlwaysApplicableOrd] &mut T,\n    [T: AlwaysApplicableOrd] Option<T>,\n}\n\n#[doc(hidden)]\n// intermediate trait for specialization of slice's Ord\ntrait SliceOrd: Sized {\n    fn compare(left: &[Self], right: &[Self]) -> Ordering;\n}\n\nimpl<A: Ord> SliceOrd for A {\n    default fn compare(left: &[Self], right: &[Self]) -> Ordering {\n        let l = cmp::min(left.len(), right.len());\n\n        // Slice to the loop iteration range to enable bound check\n        // elimination in the compiler\n        let lhs = &left[..l];\n        let rhs = &right[..l];\n\n        for i in 0..l {\n            match lhs[i].cmp(&rhs[i]) {\n                Ordering::Equal => (),\n                non_eq => return non_eq,\n            }\n        }\n\n        left.len().cmp(&right.len())\n    }\n}\n\n// memcmp compares a sequence of unsigned bytes lexicographically.\n// this matches the order we want for [u8], but no others (not even [i8]).\nimpl SliceOrd for u8 {\n    #[inline]\n    fn compare(left: &[Self], right: &[Self]) -> Ordering {\n        let order =\n            // SAFETY: `left` and `right` are references and are thus guaranteed to be valid.\n            // We use the minimum of both lengths which guarantees that both regions are\n            // valid for reads in that interval.\n            unsafe { memcmp(left.as_ptr(), right.as_ptr(), cmp::min(left.len(), right.len())) };\n        if order == 0 {\n            left.len().cmp(&right.len())\n        } else if order < 0 {\n            Less\n        } else {\n            Greater\n        }\n    }\n}\n\n// Hack to allow specializing on `Eq` even though `Eq` has a method.\n#[rustc_unsafe_specialization_marker]\ntrait MarkerEq<T>: PartialEq<T> {}\n\nimpl<T: Eq> MarkerEq<T> for T {}\n\n#[doc(hidden)]\n/// Trait implemented for types that can be compared for equality using\n/// their bytewise representation\n#[rustc_specialization_trait]\ntrait BytewiseEquality<T>: MarkerEq<T> + Copy {}\n\nmacro_rules! impl_marker_for {\n    ($traitname:ident, $($ty:ty)*) => {\n        $(\n            impl $traitname<$ty> for $ty { }\n        )*\n    }\n}\n\nimpl_marker_for!(BytewiseEquality,\n                 u8 i8 u16 i16 u32 i32 u64 i64 u128 i128 usize isize char bool);\n\npub(super) trait SliceContains: Sized {\n    fn slice_contains(&self, x: &[Self]) -> bool;\n}\n\nimpl<T> SliceContains for T\nwhere\n    T: PartialEq,\n{\n    default fn slice_contains(&self, x: &[Self]) -> bool {\n        x.iter().any(|y| *y == *self)\n    }\n}\n\nimpl SliceContains for u8 {\n    #[inline]\n    fn slice_contains(&self, x: &[Self]) -> bool {\n        memchr::memchr(*self, x).is_some()\n    }\n}\n\nimpl SliceContains for i8 {\n    #[inline]\n    fn slice_contains(&self, x: &[Self]) -> bool {\n        let byte = *self as u8;\n        // SAFETY: `i8` and `u8` have the same memory layout, thus casting `x.as_ptr()`\n        // as `*const u8` is safe. The `x.as_ptr()` comes from a reference and is thus guaranteed\n        // to be valid for reads for the length of the slice `x.len()`, which cannot be larger\n        // than `isize::MAX`. The returned slice is never mutated.\n        let bytes: &[u8] = unsafe { from_raw_parts(x.as_ptr() as *const u8, x.len()) };\n        memchr::memchr(byte, bytes).is_some()\n    }\n}\n"],[2859,"use crate::ops::DerefMut;\nuse crate::pin::Pin;\nuse crate::task::{Context, Poll};\n\n/// An interface for dealing with asynchronous iterators.\n///\n/// This is the main stream trait. For more about the concept of streams\n/// generally, please see the [module-level documentation]. In particular, you\n/// may want to know how to [implement `Stream`][impl].\n///\n/// [module-level documentation]: index.html\n/// [impl]: index.html#implementing-stream\n#[unstable(feature = \"async_stream\", issue = \"79024\")]\n#[must_use = \"streams do nothing unless polled\"]\npub trait Stream {\n    /// The type of items yielded by the stream.\n    type Item;\n\n    /// Attempt to pull out the next value of this stream, registering the\n    /// current task for wakeup if the value is not yet available, and returning\n    /// `None` if the stream is exhausted.\n    ///\n    /// # Return value\n    ///\n    /// There are several possible return values, each indicating a distinct\n    /// stream state:\n    ///\n    /// - `Poll::Pending` means that this stream's next value is not ready\n    /// yet. Implementations will ensure that the current task will be notified\n    /// when the next value may be ready.\n    ///\n    /// - `Poll::Ready(Some(val))` means that the stream has successfully\n    /// produced a value, `val`, and may produce further values on subsequent\n    /// `poll_next` calls.\n    ///\n    /// - `Poll::Ready(None)` means that the stream has terminated, and\n    /// `poll_next` should not be invoked again.\n    ///\n    /// # Panics\n    ///\n    /// Once a stream has finished (returned `Ready(None)` from `poll_next`), calling its\n    /// `poll_next` method again may panic, block forever, or cause other kinds of\n    /// problems; the `Stream` trait places no requirements on the effects of\n    /// such a call. However, as the `poll_next` method is not marked `unsafe`,\n    /// Rust's usual rules apply: calls must never cause undefined behavior\n    /// (memory corruption, incorrect use of `unsafe` functions, or the like),\n    /// regardless of the stream's state.\n    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n\n    /// Returns the bounds on the remaining length of the stream.\n    ///\n    /// Specifically, `size_hint()` returns a tuple where the first element\n    /// is the lower bound, and the second element is the upper bound.\n    ///\n    /// The second half of the tuple that is returned is an [`Option`]`<`[`usize`]`>`.\n    /// A [`None`] here means that either there is no known upper bound, or the\n    /// upper bound is larger than [`usize`].\n    ///\n    /// # Implementation notes\n    ///\n    /// It is not enforced that a stream implementation yields the declared\n    /// number of elements. A buggy stream may yield less than the lower bound\n    /// or more than the upper bound of elements.\n    ///\n    /// `size_hint()` is primarily intended to be used for optimizations such as\n    /// reserving space for the elements of the stream, but must not be\n    /// trusted to e.g., omit bounds checks in unsafe code. An incorrect\n    /// implementation of `size_hint()` should not lead to memory safety\n    /// violations.\n    ///\n    /// That said, the implementation should provide a correct estimation,\n    /// because otherwise it would be a violation of the trait's protocol.\n    ///\n    /// The default implementation returns `(0, `[`None`]`)` which is correct for any\n    /// stream.\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, None)\n    }\n}\n\n#[unstable(feature = \"async_stream\", issue = \"79024\")]\nimpl<S: ?Sized + Stream + Unpin> Stream for &mut S {\n    type Item = S::Item;\n\n    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n        S::poll_next(Pin::new(&mut **self), cx)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (**self).size_hint()\n    }\n}\n\n#[unstable(feature = \"async_stream\", issue = \"79024\")]\nimpl<P> Stream for Pin<P>\nwhere\n    P: DerefMut + Unpin,\n    P::Target: Stream,\n{\n    type Item = <P::Target as Stream>::Item;\n\n    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n        self.get_mut().as_mut().poll_next(cx)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (**self).size_hint()\n    }\n}\n"],[2860,"//! Composable asynchronous iteration.\n//!\n//! If futures are asynchronous values, then streams are asynchronous\n//! iterators. If you've found yourself with an asynchronous collection of some kind,\n//! and needed to perform an operation on the elements of said collection,\n//! you'll quickly run into 'streams'. Streams are heavily used in idiomatic\n//! asynchronous Rust code, so it's worth becoming familiar with them.\n//!\n//! Before explaining more, let's talk about how this module is structured:\n//!\n//! # Organization\n//!\n//! This module is largely organized by type:\n//!\n//! * [Traits] are the core portion: these traits define what kind of streams\n//!   exist and what you can do with them. The methods of these traits are worth\n//!   putting some extra study time into.\n//! * Functions provide some helpful ways to create some basic streams.\n//! * Structs are often the return types of the various methods on this\n//!   module's traits. You'll usually want to look at the method that creates\n//!   the `struct`, rather than the `struct` itself. For more detail about why,\n//!   see '[Implementing Stream](#implementing-stream)'.\n//!\n//! [Traits]: #traits\n//!\n//! That's it! Let's dig into streams.\n//!\n//! # Stream\n//!\n//! The heart and soul of this module is the [`Stream`] trait. The core of\n//! [`Stream`] looks like this:\n//!\n//! ```\n//! # use core::task::{Context, Poll};\n//! # use core::pin::Pin;\n//! trait Stream {\n//!     type Item;\n//!     fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n//! }\n//! ```\n//!\n//! Unlike `Iterator`, `Stream` makes a distinction between the [`poll_next`]\n//! method which is used when implementing a `Stream`, and a (to-be-implemented)\n//! `next` method which is used when consuming a stream. Consumers of `Stream`\n//! only need to consider `next`, which when called, returns a future which\n//! yields `Option<Stream::Item>`.\n//!\n//! The future returned by `next` will yield `Some(Item)` as long as there are\n//! elements, and once they've all been exhausted, will yield `None` to indicate\n//! that iteration is finished. If we're waiting on something asynchronous to\n//! resolve, the future will wait until the stream is ready to yield again.\n//!\n//! Individual streams may choose to resume iteration, and so calling `next`\n//! again may or may not eventually yield `Some(Item)` again at some point.\n//!\n//! [`Stream`]'s full definition includes a number of other methods as well,\n//! but they are default methods, built on top of [`poll_next`], and so you get\n//! them for free.\n//!\n//! [`Poll`]: super::task::Poll\n//! [`poll_next`]: Stream::poll_next\n//!\n//! # Implementing Stream\n//!\n//! Creating a stream of your own involves two steps: creating a `struct` to\n//! hold the stream's state, and then implementing [`Stream`] for that\n//! `struct`.\n//!\n//! Let's make a stream named `Counter` which counts from `1` to `5`:\n//!\n//! ```no_run\n//! #![feature(async_stream)]\n//! # use core::stream::Stream;\n//! # use core::task::{Context, Poll};\n//! # use core::pin::Pin;\n//!\n//! // First, the struct:\n//!\n//! /// A stream which counts from one to five\n//! struct Counter {\n//!     count: usize,\n//! }\n//!\n//! // we want our count to start at one, so let's add a new() method to help.\n//! // This isn't strictly necessary, but is convenient. Note that we start\n//! // `count` at zero, we'll see why in `poll_next()`'s implementation below.\n//! impl Counter {\n//!     fn new() -> Counter {\n//!         Counter { count: 0 }\n//!     }\n//! }\n//!\n//! // Then, we implement `Stream` for our `Counter`:\n//!\n//! impl Stream for Counter {\n//!     // we will be counting with usize\n//!     type Item = usize;\n//!\n//!     // poll_next() is the only required method\n//!     fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n//!         // Increment our count. This is why we started at zero.\n//!         self.count += 1;\n//!\n//!         // Check to see if we've finished counting or not.\n//!         if self.count < 6 {\n//!             Poll::Ready(Some(self.count))\n//!         } else {\n//!             Poll::Ready(None)\n//!         }\n//!     }\n//! }\n//! ```\n//!\n//! # Laziness\n//!\n//! Streams are *lazy*. This means that just creating a stream doesn't _do_ a\n//! whole lot. Nothing really happens until you call `next`. This is sometimes a\n//! source of confusion when creating a stream solely for its side effects. The\n//! compiler will warn us about this kind of behavior:\n//!\n//! ```text\n//! warning: unused result that must be used: streams do nothing unless polled\n//! ```\n\nmod stream;\n\npub use stream::Stream;\n"],[2861,"//! Definitions of integer that is known not to equal zero.\n\nuse crate::fmt;\nuse crate::ops::{BitOr, BitOrAssign, Div, Rem};\nuse crate::str::FromStr;\n\nuse super::from_str_radix;\nuse super::{IntErrorKind, ParseIntError};\nuse crate::intrinsics;\n\nmacro_rules! impl_nonzero_fmt {\n    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n        $(\n            #[$stability]\n            impl fmt::$Trait for $Ty {\n                #[inline]\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    self.get().fmt(f)\n                }\n            }\n        )+\n    }\n}\n\nmacro_rules! nonzero_integers {\n    ( $( #[$stability: meta] #[$const_new_unchecked_stability: meta] $Ty: ident($Int: ty); )+ ) => {\n        $(\n            /// An integer that is known not to equal zero.\n            ///\n            /// This enables some memory layout optimization.\n            #[doc = concat!(\"For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\")]\n            ///\n            /// ```rust\n            /// use std::mem::size_of;\n            #[doc = concat!(\"assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int), \">());\")]\n            /// ```\n            #[$stability]\n            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n            #[repr(transparent)]\n            #[rustc_layout_scalar_valid_range_start(1)]\n            #[rustc_nonnull_optimization_guaranteed]\n            pub struct $Ty($Int);\n\n            impl $Ty {\n                /// Creates a non-zero without checking whether the value is non-zero.\n                /// This results in undefined behaviour if the value is zero.\n                ///\n                /// # Safety\n                ///\n                /// The value must not be zero.\n                #[$stability]\n                #[$const_new_unchecked_stability]\n                #[inline]\n                pub const unsafe fn new_unchecked(n: $Int) -> Self {\n                    // SAFETY: this is guaranteed to be safe by the caller.\n                    unsafe { Self(n) }\n                }\n\n                /// Creates a non-zero if the given value is not zero.\n                #[$stability]\n                #[rustc_const_stable(feature = \"const_nonzero_int_methods\", since = \"1.47.0\")]\n                #[inline]\n                pub const fn new(n: $Int) -> Option<Self> {\n                    if n != 0 {\n                        // SAFETY: we just checked that there's no `0`\n                        Some(unsafe { Self(n) })\n                    } else {\n                        None\n                    }\n                }\n\n                /// Returns the value as a primitive type.\n                #[$stability]\n                #[inline]\n                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n                pub const fn get(self) -> $Int {\n                    self.0\n                }\n\n            }\n\n            #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n            impl From<$Ty> for $Int {\n                #[doc = concat!(\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\")]\n                #[inline]\n                fn from(nonzero: $Ty) -> Self {\n                    nonzero.0\n                }\n            }\n\n            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n            impl BitOr for $Ty {\n                type Output = Self;\n                #[inline]\n                fn bitor(self, rhs: Self) -> Self::Output {\n                    // SAFETY: since `self` and `rhs` are both nonzero, the\n                    // result of the bitwise-or will be nonzero.\n                    unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }\n                }\n            }\n\n            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n            impl BitOr<$Int> for $Ty {\n                type Output = Self;\n                #[inline]\n                fn bitor(self, rhs: $Int) -> Self::Output {\n                    // SAFETY: since `self` is nonzero, the result of the\n                    // bitwise-or will be nonzero regardless of the value of\n                    // `rhs`.\n                    unsafe { $Ty::new_unchecked(self.get() | rhs) }\n                }\n            }\n\n            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n            impl BitOr<$Ty> for $Int {\n                type Output = $Ty;\n                #[inline]\n                fn bitor(self, rhs: $Ty) -> Self::Output {\n                    // SAFETY: since `rhs` is nonzero, the result of the\n                    // bitwise-or will be nonzero regardless of the value of\n                    // `self`.\n                    unsafe { $Ty::new_unchecked(self | rhs.get()) }\n                }\n            }\n\n            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n            impl BitOrAssign for $Ty {\n                #[inline]\n                fn bitor_assign(&mut self, rhs: Self) {\n                    *self = *self | rhs;\n                }\n            }\n\n            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n            impl BitOrAssign<$Int> for $Ty {\n                #[inline]\n                fn bitor_assign(&mut self, rhs: $Int) {\n                    *self = *self | rhs;\n                }\n            }\n\n            impl_nonzero_fmt! {\n                #[$stability] (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n            }\n        )+\n    }\n}\n\nnonzero_integers! {\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] #[rustc_const_stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU8(u8);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] #[rustc_const_stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU16(u16);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] #[rustc_const_stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU32(u32);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] #[rustc_const_stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU64(u64);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] #[rustc_const_stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU128(u128);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] #[rustc_const_stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroUsize(usize);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] #[rustc_const_stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI8(i8);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] #[rustc_const_stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI16(i16);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] #[rustc_const_stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI32(i32);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] #[rustc_const_stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI64(i64);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] #[rustc_const_stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI128(i128);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] #[rustc_const_stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroIsize(isize);\n}\n\nmacro_rules! from_str_radix_nzint_impl {\n    ($($t:ty)*) => {$(\n        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n        impl FromStr for $t {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, Self::Err> {\n                Self::new(from_str_radix(src, 10)?)\n                    .ok_or(ParseIntError {\n                        kind: IntErrorKind::Zero\n                    })\n            }\n        }\n    )*}\n}\n\nfrom_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize\nNonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n\nmacro_rules! nonzero_leading_trailing_zeros {\n    ( $( $Ty: ident($Uint: ty) , $LeadingTestExpr:expr ;)+ ) => {\n        $(\n            impl $Ty {\n                /// Returns the number of leading zeros in the binary representation of `self`.\n                ///\n                /// On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n                ///\n                /// # Examples\n                ///\n                /// Basic usage:\n                ///\n                /// ```\n                #[doc = concat!(\"let n = std::num::\", stringify!($Ty), \"::new(\", stringify!($LeadingTestExpr), \").unwrap();\")]\n                ///\n                /// assert_eq!(n.leading_zeros(), 0);\n                /// ```\n                #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n                #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n                #[inline]\n                pub const fn leading_zeros(self) -> u32 {\n                    // SAFETY: since `self` can not be zero it is safe to call ctlz_nonzero\n                    unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }\n                }\n\n                /// Returns the number of trailing zeros in the binary representation\n                /// of `self`.\n                ///\n                /// On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n                ///\n                /// # Examples\n                ///\n                /// Basic usage:\n                ///\n                /// ```\n                #[doc = concat!(\"let n = std::num::\", stringify!($Ty), \"::new(0b0101000).unwrap();\")]\n                ///\n                /// assert_eq!(n.trailing_zeros(), 3);\n                /// ```\n                #[stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n                #[rustc_const_stable(feature = \"nonzero_leading_trailing_zeros\", since = \"1.53.0\")]\n                #[inline]\n                pub const fn trailing_zeros(self) -> u32 {\n                    // SAFETY: since `self` can not be zero it is safe to call cttz_nonzero\n                    unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }\n                }\n\n            }\n        )+\n    }\n}\n\nnonzero_leading_trailing_zeros! {\n    NonZeroU8(u8), u8::MAX;\n    NonZeroU16(u16), u16::MAX;\n    NonZeroU32(u32), u32::MAX;\n    NonZeroU64(u64), u64::MAX;\n    NonZeroU128(u128), u128::MAX;\n    NonZeroUsize(usize), usize::MAX;\n    NonZeroI8(u8), -1i8;\n    NonZeroI16(u16), -1i16;\n    NonZeroI32(u32), -1i32;\n    NonZeroI64(u64), -1i64;\n    NonZeroI128(u128), -1i128;\n    NonZeroIsize(usize), -1isize;\n}\n\nmacro_rules! nonzero_integers_div {\n    ( $( $Ty: ident($Int: ty); )+ ) => {\n        $(\n            #[stable(feature = \"nonzero_div\", since = \"1.51.0\")]\n            impl Div<$Ty> for $Int {\n                type Output = $Int;\n                /// This operation rounds towards zero,\n                /// truncating any fractional part of the exact result, and cannot panic.\n                #[inline]\n                fn div(self, other: $Ty) -> $Int {\n                    // SAFETY: div by zero is checked because `other` is a nonzero,\n                    // and MIN/-1 is checked because `self` is an unsigned int.\n                    unsafe { crate::intrinsics::unchecked_div(self, other.get()) }\n                }\n            }\n\n            #[stable(feature = \"nonzero_div\", since = \"1.51.0\")]\n            impl Rem<$Ty> for $Int {\n                type Output = $Int;\n                /// This operation satisfies `n % d == n - (n / d) * d`, and cannot panic.\n                #[inline]\n                fn rem(self, other: $Ty) -> $Int {\n                    // SAFETY: rem by zero is checked because `other` is a nonzero,\n                    // and MIN/-1 is checked because `self` is an unsigned int.\n                    unsafe { crate::intrinsics::unchecked_rem(self, other.get()) }\n                }\n            }\n        )+\n    }\n}\n\nnonzero_integers_div! {\n    NonZeroU8(u8);\n    NonZeroU16(u16);\n    NonZeroU32(u32);\n    NonZeroU64(u64);\n    NonZeroU128(u128);\n    NonZeroUsize(usize);\n}\n\n// A bunch of methods for unsigned nonzero types only.\nmacro_rules! nonzero_unsigned_operations {\n    ( $( $Ty: ident($Int: ty); )+ ) => {\n        $(\n            impl $Ty {\n                /// Add an unsigned integer to a non-zero value.\n                /// Check for overflow and return [`None`] on overflow\n                /// As a consequence, the result cannot wrap to zero.\n                ///\n                ///\n                /// # Examples\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MAX)?;\")]\n                ///\n                /// assert_eq!(Some(two), one.checked_add(1));\n                /// assert_eq!(None, max.checked_add(1));\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn checked_add(self, other: $Int) -> Option<$Ty> {\n                    if let Some(result) = self.get().checked_add(other) {\n                        // SAFETY: $Int::checked_add returns None on overflow\n                        // so the result cannot be zero.\n                        Some(unsafe { $Ty::new_unchecked(result) })\n                    } else {\n                        None\n                    }\n                }\n\n                /// Add an unsigned integer to a non-zero value.\n                #[doc = concat!(\"Return [`\", stringify!($Int), \"::MAX`] on overflow.\")]\n                ///\n                /// # Examples\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MAX)?;\")]\n                ///\n                /// assert_eq!(two, one.saturating_add(1));\n                /// assert_eq!(max, max.saturating_add(1));\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn saturating_add(self, other: $Int) -> $Ty {\n                    // SAFETY: $Int::saturating_add returns $Int::MAX on overflow\n                    // so the result cannot be zero.\n                    unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }\n                }\n\n                /// Add an unsigned integer to a non-zero value,\n                /// assuming overflow cannot occur.\n                /// Overflow is unchecked, and it is undefined behaviour to overflow\n                /// *even if the result would wrap to a non-zero value*.\n                /// The behaviour is undefined as soon as\n                #[doc = concat!(\"`self + rhs > \", stringify!($Int), \"::MAX`.\")]\n                ///\n                /// # Examples\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n                ///\n                /// assert_eq!(two, unsafe { one.unchecked_add(1) });\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub unsafe fn unchecked_add(self, other: $Int) -> $Ty {\n                    // SAFETY: The caller ensures there is no overflow.\n                    unsafe { $Ty::new_unchecked(self.get().unchecked_add(other)) }\n                }\n\n                /// Returns the smallest power of two greater than or equal to n.\n                /// Check for overflow and return [`None`]\n                /// if the next power of two is greater than the type’s maximum value.\n                /// As a consequence, the result cannot wrap to zero.\n                ///\n                /// # Examples\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n                #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MAX)?;\")]\n                ///\n                /// assert_eq!(Some(two), two.checked_next_power_of_two() );\n                /// assert_eq!(Some(four), three.checked_next_power_of_two() );\n                /// assert_eq!(None, max.checked_next_power_of_two() );\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn checked_next_power_of_two(self) -> Option<$Ty> {\n                    if let Some(nz) = self.get().checked_next_power_of_two() {\n                        // SAFETY: The next power of two is positive\n                        // and overflow is checked.\n                        Some(unsafe { $Ty::new_unchecked(nz) })\n                    } else {\n                        None\n                    }\n                }\n            }\n        )+\n    }\n}\n\nnonzero_unsigned_operations! {\n    NonZeroU8(u8);\n    NonZeroU16(u16);\n    NonZeroU32(u32);\n    NonZeroU64(u64);\n    NonZeroU128(u128);\n    NonZeroUsize(usize);\n}\n\n// A bunch of methods for signed nonzero types only.\nmacro_rules! nonzero_signed_operations {\n    ( $( $Ty: ident($Int: ty) -> $Uty: ident($Uint: ty); )+ ) => {\n        $(\n            impl $Ty {\n                /// Computes the absolute value of self.\n                #[doc = concat!(\"See [`\", stringify!($Int), \"::abs`]\")]\n                /// for documentation on overflow behaviour.\n                ///\n                /// # Example\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n                ///\n                /// assert_eq!(pos, pos.abs());\n                /// assert_eq!(pos, neg.abs());\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn abs(self) -> $Ty {\n                    // SAFETY: This cannot overflow to zero.\n                    unsafe { $Ty::new_unchecked(self.get().abs()) }\n                }\n\n                /// Checked absolute value.\n                /// Check for overflow and returns [`None`] if\n                #[doc = concat!(\"`self == \", stringify!($Int), \"::MIN`.\")]\n                /// The result cannot be zero.\n                ///\n                /// # Example\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MIN)?;\")]\n                ///\n                /// assert_eq!(Some(pos), neg.checked_abs());\n                /// assert_eq!(None, min.checked_abs());\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn checked_abs(self) -> Option<$Ty> {\n                    if let Some(nz) = self.get().checked_abs() {\n                        // SAFETY: absolute value of nonzero cannot yield zero values.\n                        Some(unsafe { $Ty::new_unchecked(nz) })\n                    } else {\n                        None\n                    }\n                }\n\n                /// Computes the absolute value of self,\n                /// with overflow information, see\n                #[doc = concat!(\"[`\", stringify!($Int), \"::overflowing_abs`].\")]\n                ///\n                /// # Example\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MIN)?;\")]\n                ///\n                /// assert_eq!((pos, false), pos.overflowing_abs());\n                /// assert_eq!((pos, false), neg.overflowing_abs());\n                /// assert_eq!((min, true), min.overflowing_abs());\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn overflowing_abs(self) -> ($Ty, bool) {\n                    let (nz, flag) = self.get().overflowing_abs();\n                    (\n                        // SAFETY: absolute value of nonzero cannot yield zero values.\n                        unsafe { $Ty::new_unchecked(nz) },\n                        flag,\n                    )\n                }\n\n                /// Saturating absolute value, see\n                #[doc = concat!(\"[`\", stringify!($Int), \"::saturating_abs`].\")]\n                ///\n                /// # Example\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MIN)?;\")]\n                #[doc = concat!(\"let min_plus = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MIN + 1)?;\")]\n                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MAX)?;\")]\n                ///\n                /// assert_eq!(pos, pos.saturating_abs());\n                /// assert_eq!(pos, neg.saturating_abs());\n                /// assert_eq!(max, min.saturating_abs());\n                /// assert_eq!(max, min_plus.saturating_abs());\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn saturating_abs(self) -> $Ty {\n                    // SAFETY: absolute value of nonzero cannot yield zero values.\n                    unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }\n                }\n\n                /// Wrapping absolute value, see\n                #[doc = concat!(\"[`\", stringify!($Int), \"::wrapping_abs`].\")]\n                ///\n                /// # Example\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n                #[doc = concat!(\"let neg = \", stringify!($Ty), \"::new(-1)?;\")]\n                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MIN)?;\")]\n                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MAX)?;\")]\n                ///\n                /// assert_eq!(pos, pos.wrapping_abs());\n                /// assert_eq!(pos, neg.wrapping_abs());\n                /// assert_eq!(min, min.wrapping_abs());\n                /// # // FIXME: add once Neg is implemented?\n                /// # // assert_eq!(max, (-max).wrapping_abs());\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn wrapping_abs(self) -> $Ty {\n                    // SAFETY: absolute value of nonzero cannot yield zero values.\n                    unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }\n                }\n\n                /// Computes the absolute value of self\n                /// without any wrapping or panicking.\n                ///\n                /// # Example\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                #[doc = concat!(\"# use std::num::\", stringify!($Uty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let u_pos = \", stringify!($Uty), \"::new(1)?;\")]\n                #[doc = concat!(\"let i_pos = \", stringify!($Ty), \"::new(1)?;\")]\n                #[doc = concat!(\"let i_neg = \", stringify!($Ty), \"::new(-1)?;\")]\n                #[doc = concat!(\"let i_min = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MIN)?;\")]\n                #[doc = concat!(\"let u_max = \", stringify!($Uty), \"::new(\",\n                                stringify!($Uint), \"::MAX / 2 + 1)?;\")]\n                ///\n                /// assert_eq!(u_pos, i_pos.unsigned_abs());\n                /// assert_eq!(u_pos, i_neg.unsigned_abs());\n                /// assert_eq!(u_max, i_min.unsigned_abs());\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn unsigned_abs(self) -> $Uty {\n                    // SAFETY: absolute value of nonzero cannot yield zero values.\n                    unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }\n                }\n            }\n        )+\n    }\n}\n\nnonzero_signed_operations! {\n    NonZeroI8(i8) -> NonZeroU8(u8);\n    NonZeroI16(i16) -> NonZeroU16(u16);\n    NonZeroI32(i32) -> NonZeroU32(u32);\n    NonZeroI64(i64) -> NonZeroU64(u64);\n    NonZeroI128(i128) -> NonZeroU128(u128);\n    NonZeroIsize(isize) -> NonZeroUsize(usize);\n}\n\n// A bunch of methods for both signed and unsigned nonzero types.\nmacro_rules! nonzero_unsigned_signed_operations {\n    ( $( $signedness:ident $Ty: ident($Int: ty); )+ ) => {\n        $(\n            impl $Ty {\n                /// Multiply two non-zero integers together.\n                /// Check for overflow and return [`None`] on overflow.\n                /// As a consequence, the result cannot wrap to zero.\n                ///\n                /// # Examples\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MAX)?;\")]\n                ///\n                /// assert_eq!(Some(four), two.checked_mul(two));\n                /// assert_eq!(None, max.checked_mul(two));\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {\n                    if let Some(result) = self.get().checked_mul(other.get()) {\n                        // SAFETY: checked_mul returns None on overflow\n                        // and `other` is also non-null\n                        // so the result cannot be zero.\n                        Some(unsafe { $Ty::new_unchecked(result) })\n                    } else {\n                        None\n                    }\n                }\n\n                /// Multiply two non-zero integers together.\n                #[doc = concat!(\"Return [`\", stringify!($Int), \"::MAX`] on overflow.\")]\n                ///\n                /// # Examples\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MAX)?;\")]\n                ///\n                /// assert_eq!(four, two.saturating_mul(two));\n                /// assert_eq!(max, four.saturating_mul(max));\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn saturating_mul(self, other: $Ty) -> $Ty {\n                    // SAFETY: saturating_mul returns u*::MAX on overflow\n                    // and `other` is also non-null\n                    // so the result cannot be zero.\n                    unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }\n                }\n\n                /// Multiply two non-zero integers together,\n                /// assuming overflow cannot occur.\n                /// Overflow is unchecked, and it is undefined behaviour to overflow\n                /// *even if the result would wrap to a non-zero value*.\n                /// The behaviour is undefined as soon as\n                #[doc = sign_dependent_expr!{\n                    $signedness ?\n                    if signed {\n                        concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`, \",\n                                \"or `self * rhs < \", stringify!($Int), \"::MIN`.\")\n                    }\n                    if unsigned {\n                        concat!(\"`self * rhs > \", stringify!($Int), \"::MAX`.\")\n                    }\n                }]\n                ///\n                /// # Examples\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n                #[doc = concat!(\"let four = \", stringify!($Ty), \"::new(4)?;\")]\n                ///\n                /// assert_eq!(four, unsafe { two.unchecked_mul(two) });\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub unsafe fn unchecked_mul(self, other: $Ty) -> $Ty {\n                    // SAFETY: The caller ensures there is no overflow.\n                    unsafe { $Ty::new_unchecked(self.get().unchecked_mul(other.get())) }\n                }\n\n                /// Raise non-zero value to an integer power.\n                /// Check for overflow and return [`None`] on overflow.\n                /// As a consequence, the result cannot wrap to zero.\n                ///\n                /// # Examples\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n                #[doc = concat!(\"let twenty_seven = \", stringify!($Ty), \"::new(27)?;\")]\n                #[doc = concat!(\"let half_max = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MAX / 2)?;\")]\n                ///\n                /// assert_eq!(Some(twenty_seven), three.checked_pow(3));\n                /// assert_eq!(None, half_max.checked_pow(3));\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn checked_pow(self, other: u32) -> Option<$Ty> {\n                    if let Some(result) = self.get().checked_pow(other) {\n                        // SAFETY: checked_pow returns None on overflow\n                        // so the result cannot be zero.\n                        Some(unsafe { $Ty::new_unchecked(result) })\n                    } else {\n                        None\n                    }\n                }\n\n                /// Raise non-zero value to an integer power.\n                #[doc = sign_dependent_expr!{\n                    $signedness ?\n                    if signed {\n                        concat!(\"Return [`\", stringify!($Int), \"::MIN`] \",\n                                    \"or [`\", stringify!($Int), \"::MAX`] on overflow.\")\n                    }\n                    if unsigned {\n                        concat!(\"Return [`\", stringify!($Int), \"::MAX`] on overflow.\")\n                    }\n                }]\n                ///\n                /// # Examples\n                ///\n                /// ```\n                /// #![feature(nonzero_ops)]\n                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                ///\n                /// # fn main() { test().unwrap(); }\n                /// # fn test() -> Option<()> {\n                #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n                #[doc = concat!(\"let twenty_seven = \", stringify!($Ty), \"::new(27)?;\")]\n                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n                                stringify!($Int), \"::MAX)?;\")]\n                ///\n                /// assert_eq!(twenty_seven, three.saturating_pow(3));\n                /// assert_eq!(max, max.saturating_pow(3));\n                /// # Some(())\n                /// # }\n                /// ```\n                #[unstable(feature = \"nonzero_ops\", issue = \"84186\")]\n                #[inline]\n                pub const fn saturating_pow(self, other: u32) -> $Ty {\n                    // SAFETY: saturating_pow returns u*::MAX on overflow\n                    // so the result cannot be zero.\n                    unsafe { $Ty::new_unchecked(self.get().saturating_pow(other)) }\n                }\n            }\n        )+\n    }\n}\n\n// Use this when the generated code should differ between signed and unsigned types.\nmacro_rules! sign_dependent_expr {\n    (signed ? if signed { $signed_case:expr } if unsigned { $unsigned_case:expr } ) => {\n        $signed_case\n    };\n    (unsigned ? if signed { $signed_case:expr } if unsigned { $unsigned_case:expr } ) => {\n        $unsigned_case\n    };\n}\n\nnonzero_unsigned_signed_operations! {\n    unsigned NonZeroU8(u8);\n    unsigned NonZeroU16(u16);\n    unsigned NonZeroU32(u32);\n    unsigned NonZeroU64(u64);\n    unsigned NonZeroU128(u128);\n    unsigned NonZeroUsize(usize);\n    signed NonZeroI8(i8);\n    signed NonZeroI16(i16);\n    signed NonZeroI32(i32);\n    signed NonZeroI64(i64);\n    signed NonZeroI128(i128);\n    signed NonZeroIsize(isize);\n}\n\nmacro_rules! nonzero_unsigned_is_power_of_two {\n    ( $( $Ty: ident )+ ) => {\n        $(\n            impl $Ty {\n\n                /// Returns `true` if and only if `self == (1 << k)` for some `k`.\n                ///\n                /// On many architectures, this function can perform better than `is_power_of_two()`\n                /// on the underlying integer type, as special handling of zero can be avoided.\n                ///\n                /// # Examples\n                ///\n                /// Basic usage:\n                ///\n                /// ```\n                /// #![feature(nonzero_is_power_of_two)]\n                ///\n                #[doc = concat!(\"let eight = std::num::\", stringify!($Ty), \"::new(8).unwrap();\")]\n                /// assert!(eight.is_power_of_two());\n                #[doc = concat!(\"let ten = std::num::\", stringify!($Ty), \"::new(10).unwrap();\")]\n                /// assert!(!ten.is_power_of_two());\n                /// ```\n                #[unstable(feature = \"nonzero_is_power_of_two\", issue = \"81106\")]\n                #[inline]\n                pub const fn is_power_of_two(self) -> bool {\n                    // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.\n                    // On the basic x86-64 target, this saves 3 instructions for the zero check.\n                    // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction\n                    // compared to the `POPCNT` implementation on the underlying integer type.\n\n                    intrinsics::ctpop(self.get()) < 2\n                }\n\n            }\n        )+\n    }\n}\n\nnonzero_unsigned_is_power_of_two! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize }\n"],[2862,"macro_rules! uint_impl {\n    ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr,\n        $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n        $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n        $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = $BITS;\n\n        /// Converts a string slice in a given base to an integer.\n        ///\n        /// The string is expected to be an optional `+` sign\n        /// followed by digits.\n        /// Leading and trailing whitespace represent an error.\n        /// Digits are a subset of these characters, depending on `radix`:\n        ///\n        /// * `0-9`\n        /// * `a-z`\n        /// * `A-Z`\n        ///\n        /// # Panics\n        ///\n        /// This function panics if `radix` is not in the range from 2 to 36.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n            from_str_radix(src, radix)\n        }\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.count_ones(), 3);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            intrinsics::ctpop(self as $ActualT) as u32\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.count_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        ///\n        /// assert_eq!(n.leading_zeros(), 2);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            intrinsics::ctlz(self as $ActualT) as u32\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_zeros(), 3);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            intrinsics::cttz(self) as u32\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        ///\n        /// assert_eq!(n.leading_ones(), 2);\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_ones(), 3);\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            intrinsics::rotate_left(self, n as $SelfT)\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            intrinsics::rotate_right(self, n as $SelfT)\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.37.0\")]\n        #[inline(always)]\n        #[must_use]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_add`.\n            unsafe { intrinsics::unchecked_add(self, rhs) }\n        }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_sub`.\n            unsafe { intrinsics::unchecked_sub(self, rhs) }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_mul`.\n            unsafe { intrinsics::unchecked_mul(self, rhs) }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if unlikely!(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if unlikely!(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if unlikely!(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if unlikely!(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shl(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_shl(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_shl`.\n            unsafe { intrinsics::unchecked_shl(self, rhs) }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shr(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_shr(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_shr`.\n            unsafe { intrinsics::unchecked_shr(self, rhs) }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n\n            // since exp!=0, finally the exp must be 1.\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n\n            Some(try_opt!(acc.checked_mul(base)))\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        /// Wrapped division on unsigned types is just normal division.\n        /// There's no way wrapping could ever happen.\n        /// This function exists, so that all operations\n        /// are accounted for in the wrapping operations.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        /// Wrapped division on unsigned types is just normal division.\n        /// There's no way wrapping could ever happen.\n        /// This function exists, so that all operations\n        /// are accounted for in the wrapping operations.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        /// Wrapped remainder calculation on unsigned types is\n        /// just the regular remainder calculation.\n        /// There's no way wrapping could ever happen.\n        /// This function exists, so that all operations\n        /// are accounted for in the wrapping operations.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        /// Wrapped modulo calculation on unsigned types is\n        /// just the regular remainder calculation.\n        /// There's no way wrapping could ever happen.\n        /// This function exists, so that all operations\n        /// are accounted for in the wrapping operations.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.wrapping_rem(rhs)`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_neg(), -100);\n        /// assert_eq!((-128i8).wrapping_neg(), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[inline]\n        pub const fn wrapping_neg(self) -> Self {\n            self.overflowing_neg().0\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = acc.wrapping_mul(base);\n                }\n                exp /= 2;\n                base = base.wrapping_mul(base);\n            }\n\n            // since exp!=0, finally the exp must be 1.\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            acc.wrapping_mul(base)\n        }\n\n        /// Calculates `self` + `rhs`\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` - `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n\n            // since exp!=0, finally the exp must be 1.\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            r = acc.overflowing_mul(base);\n            r.1 |= overflown;\n\n            r\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = acc * base;\n                }\n                exp /= 2;\n                base = base * base;\n            }\n\n            // since exp!=0, finally the exp must be 1.\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            acc * base\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[rustc_inherit_overflow_checks]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[rustc_inherit_overflow_checks]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and return value is wrapped to 0 in\n        /// release mode (the only situation in which method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behaviour\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Return the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Return the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Return the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[rustc_allow_const_fn_unstable(const_fn_transmute)]\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Create a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        /// use std::convert::TryInto;\n        ///\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Create a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        /// use std::convert::TryInto;\n        ///\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Create a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        /// use std::convert::TryInto;\n        ///\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[rustc_allow_const_fn_unstable(const_fn_transmute)]\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MIN` associated constant on this type\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MAX` associated constant on this type\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}\n"],[2863,"//! Constants for the 8-bit signed integer type.\n//!\n//! *[See also the `i8` primitive type][i8].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `i8`\"\n)]\n\nint_module! { i8 }\n"],[2864,"//! Constants for the 64-bit signed integer type.\n//!\n//! *[See also the `i64` primitive type][i64].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `i64`\"\n)]\n\nint_module! { i64 }\n"],[2865,"//! Constants for the 8-bit unsigned integer type.\n//!\n//! *[See also the `u8` primitive type][u8].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `u8`\"\n)]\n\nint_module! { u8 }\n"],[2866,"//! Constants for the 16-bit signed integer type.\n//!\n//! *[See also the `i16` primitive type][i16].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `i16`\"\n)]\n\nint_module! { i16 }\n"],[2867,"//! Constants for the 128-bit unsigned integer type.\n//!\n//! *[See also the `u128` primitive type][u128].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"i128\", since = \"1.26.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `u128`\"\n)]\n\nint_module! { u128, #[stable(feature = \"i128\", since=\"1.26.0\")] }\n"],[2868,"#![doc(hidden)]\n\nmacro_rules! int_module {\n    ($T:ident) => (int_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n    ($T:ident, #[$attr:meta]) => (\n        #[doc = concat!(\n            \"The smallest value that can be represented by this integer type. Use \",\n            \"[`\", stringify!($T), \"::MIN\", \"`] instead.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// ```rust\n        /// // deprecated way\n        #[doc = concat!(\"let min = std::\", stringify!($T), \"::MIN;\")]\n        ///\n        /// // intended way\n        #[doc = concat!(\"let min = \", stringify!($T), \"::MIN;\")]\n        /// ```\n        ///\n        #[$attr]\n        #[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MIN` associated constant on this type\")]\n        pub const MIN: $T = $T::MIN;\n\n        #[doc = concat!(\n            \"The largest value that can be represented by this integer type. Use \",\n            \"[`\", stringify!($T), \"::MAX\", \"`] instead.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// ```rust\n        /// // deprecated way\n        #[doc = concat!(\"let max = std::\", stringify!($T), \"::MAX;\")]\n        ///\n        /// // intended way\n        #[doc = concat!(\"let max = \", stringify!($T), \"::MAX;\")]\n        /// ```\n        ///\n        #[$attr]\n        #[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MAX` associated constant on this type\")]\n        pub const MAX: $T = $T::MAX;\n    )\n}\n"],[2869,"//! Constants for the 16-bit unsigned integer type.\n//!\n//! *[See also the `u16` primitive type][u16].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `u16`\"\n)]\n\nint_module! { u16 }\n"],[2870,"//! Constants for the 64-bit unsigned integer type.\n//!\n//! *[See also the `u64` primitive type][u64].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `u64`\"\n)]\n\nint_module! { u64 }\n"],[2871,"//! Constants for the 32-bit unsigned integer type.\n//!\n//! *[See also the `u32` primitive type][u32].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `u32`\"\n)]\n\nint_module! { u32 }\n"],[2872,"//! Constants for the pointer-sized signed integer type.\n//!\n//! *[See also the `isize` primitive type][isize].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `isize`\"\n)]\n\nint_module! { isize }\n"],[2873,"//! Constants for the 128-bit signed integer type.\n//!\n//! *[See also the `i128` primitive type][i128].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"i128\", since = \"1.26.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `i128`\"\n)]\n\nint_module! { i128, #[stable(feature = \"i128\", since=\"1.26.0\")] }\n"],[2874,"//! Constants for the pointer-sized unsigned integer type.\n//!\n//! *[See also the `usize` primitive type][usize].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `usize`\"\n)]\n\nint_module! { usize }\n"],[2875,"//! Constants for the 32-bit signed integer type.\n//!\n//! *[See also the `i32` primitive type][i32].*\n//!\n//! New code should use the associated constants directly on the primitive type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![rustc_deprecated(\n    since = \"TBD\",\n    reason = \"all constants in this module replaced by associated constants on `i32`\"\n)]\n\nint_module! { i32 }\n"],[2876,"//! The various algorithms from the paper.\n\nuse crate::cmp::min;\nuse crate::cmp::Ordering::{Equal, Greater, Less};\nuse crate::num::dec2flt::num::{self, Big};\nuse crate::num::dec2flt::rawfp::{self, fp_to_float, next_float, prev_float, RawFloat, Unpacked};\nuse crate::num::dec2flt::table;\nuse crate::num::diy_float::Fp;\n\n/// Number of significand bits in Fp\nconst P: u32 = 64;\n\n// We simply store the best approximation for *all* exponents, so the variable \"h\" and the\n// associated conditions can be omitted. This trades performance for a couple kilobytes of space.\n\nfn power_of_ten(e: i16) -> Fp {\n    assert!(e >= table::MIN_E);\n    let i = e - table::MIN_E;\n    let sig = table::POWERS.0[i as usize];\n    let exp = table::POWERS.1[i as usize];\n    Fp { f: sig, e: exp }\n}\n\n// In most architectures, floating point operations have an explicit bit size, therefore the\n// precision of the computation is determined on a per-operation basis.\n#[cfg(any(not(target_arch = \"x86\"), target_feature = \"sse2\"))]\nmod fpu_precision {\n    pub fn set_precision<T>() {}\n}\n\n// On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.\n// The x87 FPU operates with 80 bits of precision by default, which means that operations will\n// round to 80 bits causing double rounding to happen when values are eventually represented as\n// 32/64 bit float values. To overcome this, the FPU control word can be set so that the\n// computations are performed in the desired precision.\n#[cfg(all(target_arch = \"x86\", not(target_feature = \"sse2\")))]\nmod fpu_precision {\n    use crate::mem::size_of;\n\n    /// A structure used to preserve the original value of the FPU control word, so that it can be\n    /// restored when the structure is dropped.\n    ///\n    /// The x87 FPU is a 16-bits register whose fields are as follows:\n    ///\n    /// | 12-15 | 10-11 | 8-9 | 6-7 |  5 |  4 |  3 |  2 |  1 |  0 |\n    /// |------:|------:|----:|----:|---:|---:|---:|---:|---:|---:|\n    /// |       | RC    | PC  |     | PM | UM | OM | ZM | DM | IM |\n    ///\n    /// The documentation for all of the fields is available in the IA-32 Architectures Software\n    /// Developer's Manual (Volume 1).\n    ///\n    /// The only field which is relevant for the following code is PC, Precision Control. This\n    /// field determines the precision of the operations performed by the  FPU. It can be set to:\n    ///  - 0b00, single precision i.e., 32-bits\n    ///  - 0b10, double precision i.e., 64-bits\n    ///  - 0b11, double extended precision i.e., 80-bits (default state)\n    /// The 0b01 value is reserved and should not be used.\n    pub struct FPUControlWord(u16);\n\n    fn set_cw(cw: u16) {\n        // SAFETY: the `fldcw` instruction has been audited to be able to work correctly with\n        // any `u16`\n        unsafe {\n            asm!(\n                \"fldcw word ptr [{}]\",\n                in(reg) &cw,\n                options(nostack),\n            )\n        }\n    }\n\n    /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.\n    pub fn set_precision<T>() -> FPUControlWord {\n        let mut cw = 0_u16;\n\n        // Compute the value for the Precision Control field that is appropriate for `T`.\n        let cw_precision = match size_of::<T>() {\n            4 => 0x0000, // 32 bits\n            8 => 0x0200, // 64 bits\n            _ => 0x0300, // default, 80 bits\n        };\n\n        // Get the original value of the control word to restore it later, when the\n        // `FPUControlWord` structure is dropped\n        // SAFETY: the `fnstcw` instruction has been audited to be able to work correctly with\n        // any `u16`\n        unsafe {\n            asm!(\n                \"fnstcw word ptr [{}]\",\n                in(reg) &mut cw,\n                options(nostack),\n            )\n        }\n\n        // Set the control word to the desired precision. This is achieved by masking away the old\n        // precision (bits 8 and 9, 0x300) and replacing it with the precision flag computed above.\n        set_cw((cw & 0xFCFF) | cw_precision);\n\n        FPUControlWord(cw)\n    }\n\n    impl Drop for FPUControlWord {\n        fn drop(&mut self) {\n            set_cw(self.0)\n        }\n    }\n}\n\n/// The fast path of Bellerophon using machine-sized integers and floats.\n///\n/// This is extracted into a separate function so that it can be attempted before constructing\n/// a bignum.\npub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> {\n    let num_digits = integral.len() + fractional.len();\n    // log_10(f64::MAX_SIG) ~ 15.95. We compare the exact value to MAX_SIG near the end,\n    // this is just a quick, cheap rejection (and also frees the rest of the code from\n    // worrying about underflow).\n    if num_digits > 16 {\n        return None;\n    }\n    if e.abs() >= T::CEIL_LOG5_OF_MAX_SIG as i64 {\n        return None;\n    }\n    let f = num::from_str_unchecked(integral.iter().chain(fractional.iter()));\n    if f > T::MAX_SIG {\n        return None;\n    }\n\n    // The fast path crucially depends on arithmetic being rounded to the correct number of bits\n    // without any intermediate rounding. On x86 (without SSE or SSE2) this requires the precision\n    // of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.\n    // The `set_precision` function takes care of setting the precision on architectures which\n    // require setting it by changing the global state (like the control word of the x87 FPU).\n    let _cw = fpu_precision::set_precision::<T>();\n\n    // The case e < 0 cannot be folded into the other branch. Negative powers result in\n    // a repeating fractional part in binary, which are rounded, which causes real\n    // (and occasionally quite significant!) errors in the final result.\n    if e >= 0 {\n        Some(T::from_int(f) * T::short_fast_pow10(e as usize))\n    } else {\n        Some(T::from_int(f) / T::short_fast_pow10(e.abs() as usize))\n    }\n}\n\n/// Algorithm Bellerophon is trivial code justified by non-trivial numeric analysis.\n///\n/// It rounds ``f`` to a float with 64 bit significand and multiplies it by the best approximation\n/// of `10^e` (in the same floating point format). This is often enough to get the correct result.\n/// However, when the result is close to halfway between two adjacent (ordinary) floats, the\n/// compound rounding error from multiplying two approximation means the result may be off by a\n/// few bits. When this happens, the iterative Algorithm R fixes things up.\n///\n/// The hand-wavy \"close to halfway\" is made precise by the numeric analysis in the paper.\n/// In the words of Clinger:\n///\n/// > Slop, expressed in units of the least significant bit, is an inclusive bound for the error\n/// > accumulated during the floating point calculation of the approximation to f * 10^e. (Slop is\n/// > not a bound for the true error, but bounds the difference between the approximation z and\n/// > the best possible approximation that uses p bits of significand.)\npub fn bellerophon<T: RawFloat>(f: &Big, e: i16) -> T {\n    let slop = if f <= &Big::from_u64(T::MAX_SIG) {\n        // The cases abs(e) < log5(2^N) are in fast_path()\n        if e >= 0 { 0 } else { 3 }\n    } else {\n        if e >= 0 { 1 } else { 4 }\n    };\n    let z = rawfp::big_to_fp(f).mul(&power_of_ten(e)).normalize();\n    let exp_p_n = 1 << (P - T::SIG_BITS as u32);\n    let lowbits: i64 = (z.f % exp_p_n) as i64;\n    // Is the slop large enough to make a difference when\n    // rounding to n bits?\n    if (lowbits - exp_p_n as i64 / 2).abs() <= slop {\n        algorithm_r(f, e, fp_to_float(z))\n    } else {\n        fp_to_float(z)\n    }\n}\n\n/// An iterative algorithm that improves a floating point approximation of `f * 10^e`.\n///\n/// Each iteration gets one unit in the last place closer, which of course takes terribly long to\n/// converge if `z0` is even mildly off. Luckily, when used as fallback for Bellerophon, the\n/// starting approximation is off by at most one ULP.\nfn algorithm_r<T: RawFloat>(f: &Big, e: i16, z0: T) -> T {\n    let mut z = z0;\n    loop {\n        let raw = z.unpack();\n        let (m, k) = (raw.sig, raw.k);\n        let mut x = f.clone();\n        let mut y = Big::from_u64(m);\n\n        // Find positive integers `x`, `y` such that `x / y` is exactly `(f * 10^e) / (m * 2^k)`.\n        // This not only avoids dealing with the signs of `e` and `k`, we also eliminate the\n        // power of two common to `10^e` and `2^k` to make the numbers smaller.\n        make_ratio(&mut x, &mut y, e, k);\n\n        let m_digits = [(m & 0xFF_FF_FF_FF) as u32, (m >> 32) as u32];\n        // This is written a bit awkwardly because our bignums don't support\n        // negative numbers, so we use the absolute value + sign information.\n        // The multiplication with m_digits can't overflow. If `x` or `y` are large enough that\n        // we need to worry about overflow, then they are also large enough that `make_ratio` has\n        // reduced the fraction by a factor of 2^64 or more.\n        let (d2, d_negative) = if x >= y {\n            // Don't need x any more, save a clone().\n            x.sub(&y).mul_pow2(1).mul_digits(&m_digits);\n            (x, false)\n        } else {\n            // Still need y - make a copy.\n            let mut y = y.clone();\n            y.sub(&x).mul_pow2(1).mul_digits(&m_digits);\n            (y, true)\n        };\n\n        if d2 < y {\n            let mut d2_double = d2;\n            d2_double.mul_pow2(1);\n            if m == T::MIN_SIG && d_negative && d2_double > y {\n                z = prev_float(z);\n            } else {\n                return z;\n            }\n        } else if d2 == y {\n            if m % 2 == 0 {\n                if m == T::MIN_SIG && d_negative {\n                    z = prev_float(z);\n                } else {\n                    return z;\n                }\n            } else if d_negative {\n                z = prev_float(z);\n            } else {\n                z = next_float(z);\n            }\n        } else if d_negative {\n            z = prev_float(z);\n        } else {\n            z = next_float(z);\n        }\n    }\n}\n\n/// Given `x = f` and `y = m` where `f` represent input decimal digits as usual and `m` is the\n/// significand of a floating point approximation, make the ratio `x / y` equal to\n/// `(f * 10^e) / (m * 2^k)`, possibly reduced by a power of two both have in common.\nfn make_ratio(x: &mut Big, y: &mut Big, e: i16, k: i16) {\n    let (e_abs, k_abs) = (e.abs() as usize, k.abs() as usize);\n    if e >= 0 {\n        if k >= 0 {\n            // x = f * 10^e, y = m * 2^k, except that we reduce the fraction by some power of two.\n            let common = min(e_abs, k_abs);\n            x.mul_pow5(e_abs).mul_pow2(e_abs - common);\n            y.mul_pow2(k_abs - common);\n        } else {\n            // x = f * 10^e * 2^abs(k), y = m\n            // This can't overflow because it requires positive `e` and negative `k`, which can\n            // only happen for values extremely close to 1, which means that `e` and `k` will be\n            // comparatively tiny.\n            x.mul_pow5(e_abs).mul_pow2(e_abs + k_abs);\n        }\n    } else {\n        if k >= 0 {\n            // x = f, y = m * 10^abs(e) * 2^k\n            // This can't overflow either, see above.\n            y.mul_pow5(e_abs).mul_pow2(k_abs + e_abs);\n        } else {\n            // x = f * 2^abs(k), y = m * 10^abs(e), again reducing by a common power of two.\n            let common = min(e_abs, k_abs);\n            x.mul_pow2(k_abs - common);\n            y.mul_pow5(e_abs).mul_pow2(e_abs - common);\n        }\n    }\n}\n\n/// Conceptually, Algorithm M is the simplest way to convert a decimal to a float.\n///\n/// We form a ratio that is equal to `f * 10^e`, then throwing in powers of two until it gives\n/// a valid float significand. The binary exponent `k` is the number of times we multiplied\n/// numerator or denominator by two, i.e., at all times `f * 10^e` equals `(u / v) * 2^k`.\n/// When we have found out significand, we only need to round by inspecting the remainder of the\n/// division, which is done in helper functions further below.\n///\n/// This algorithm is super slow, even with the optimization described in `quick_start()`.\n/// However, it's the simplest of the algorithms to adapt for overflow, underflow, and subnormal\n/// results. This implementation takes over when Bellerophon and Algorithm R are overwhelmed.\n/// Detecting underflow and overflow is easy: The ratio still isn't an in-range significand,\n/// yet the minimum/maximum exponent has been reached. In the case of overflow, we simply return\n/// infinity.\n///\n/// Handling underflow and subnormals is trickier. One big problem is that, with the minimum\n/// exponent, the ratio might still be too large for a significand. See underflow() for details.\npub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n    let mut u;\n    let mut v;\n    let e_abs = e.abs() as usize;\n    let mut k = 0;\n    if e < 0 {\n        u = f.clone();\n        v = Big::from_small(1);\n        v.mul_pow5(e_abs).mul_pow2(e_abs);\n    } else {\n        // FIXME possible optimization: generalize big_to_fp so that we can do the equivalent of\n        // fp_to_float(big_to_fp(u)) here, only without the double rounding.\n        u = f.clone();\n        u.mul_pow5(e_abs).mul_pow2(e_abs);\n        v = Big::from_small(1);\n    }\n    quick_start::<T>(&mut u, &mut v, &mut k);\n    let mut rem = Big::from_small(0);\n    let mut x = Big::from_small(0);\n    let min_sig = Big::from_u64(T::MIN_SIG);\n    let max_sig = Big::from_u64(T::MAX_SIG);\n    loop {\n        u.div_rem(&v, &mut x, &mut rem);\n        if k == T::MIN_EXP_INT {\n            // We have to stop at the minimum exponent, if we wait until `k < T::MIN_EXP_INT`,\n            // then we'd be off by a factor of two. Unfortunately this means we have to special-\n            // case normal numbers with the minimum exponent.\n            // FIXME find a more elegant formulation, but run the `tiny-pow10` test to make sure\n            // that it's actually correct!\n            if x >= min_sig && x <= max_sig {\n                break;\n            }\n            return underflow(x, v, rem);\n        }\n        if k > T::MAX_EXP_INT {\n            return T::INFINITY;\n        }\n        if x < min_sig {\n            u.mul_pow2(1);\n            k -= 1;\n        } else if x > max_sig {\n            v.mul_pow2(1);\n            k += 1;\n        } else {\n            break;\n        }\n    }\n    let q = num::to_u64(&x);\n    let z = rawfp::encode_normal(Unpacked::new(q, k));\n    round_by_remainder(v, rem, q, z)\n}\n\n/// Skips over most Algorithm M iterations by checking the bit length.\nfn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n    // The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).\n    // The estimate is off by at most 1, but always an under-estimate, so the error on log(u)\n    // and log(v) are of the same sign and cancel out (if both are large). Therefore the error\n    // for log(u / v) is at most one as well.\n    // The target ratio is one where u/v is in an in-range significand. Thus our termination\n    // condition is log2(u / v) being the significand bits, plus/minus one.\n    // FIXME Looking at the second bit could improve the estimate and avoid some more divisions.\n    let target_ratio = T::SIG_BITS as i16;\n    let log2_u = u.bit_length() as i16;\n    let log2_v = v.bit_length() as i16;\n    let mut u_shift: i16 = 0;\n    let mut v_shift: i16 = 0;\n    assert!(*k == 0);\n    loop {\n        if *k == T::MIN_EXP_INT {\n            // Underflow or subnormal. Leave it to the main function.\n            break;\n        }\n        if *k == T::MAX_EXP_INT {\n            // Overflow. Leave it to the main function.\n            break;\n        }\n        let log2_ratio = (log2_u + u_shift) - (log2_v + v_shift);\n        if log2_ratio < target_ratio - 1 {\n            u_shift += 1;\n            *k -= 1;\n        } else if log2_ratio > target_ratio + 1 {\n            v_shift += 1;\n            *k += 1;\n        } else {\n            break;\n        }\n    }\n    u.mul_pow2(u_shift as usize);\n    v.mul_pow2(v_shift as usize);\n}\n\nfn underflow<T: RawFloat>(x: Big, v: Big, rem: Big) -> T {\n    if x < Big::from_u64(T::MIN_SIG) {\n        let q = num::to_u64(&x);\n        let z = rawfp::encode_subnormal(q);\n        return round_by_remainder(v, rem, q, z);\n    }\n    // Ratio isn't an in-range significand with the minimum exponent, so we need to round off\n    // excess bits and adjust the exponent accordingly. The real value now looks like this:\n    //\n    //        x        lsb\n    // /--------------\\/\n    // 1010101010101010.10101010101010 * 2^k\n    // \\-----/\\-------/ \\------------/\n    //    q     trunc.    (represented by rem)\n    //\n    // Therefore, when the rounded-off bits are != 0.5 ULP, they decide the rounding\n    // on their own. When they are equal and the remainder is non-zero, the value still\n    // needs to be rounded up. Only when the rounded off bits are 1/2 and the remainder\n    // is zero, we have a half-to-even situation.\n    let bits = x.bit_length();\n    let lsb = bits - T::SIG_BITS as usize;\n    let q = num::get_bits(&x, lsb, bits);\n    let k = T::MIN_EXP_INT + lsb as i16;\n    let z = rawfp::encode_normal(Unpacked::new(q, k));\n    let q_even = q % 2 == 0;\n    match num::compare_with_half_ulp(&x, lsb) {\n        Greater => next_float(z),\n        Less => z,\n        Equal if rem.is_zero() && q_even => z,\n        Equal => next_float(z),\n    }\n}\n\n/// Ordinary round-to-even, obfuscated by having to round based on the remainder of a division.\nfn round_by_remainder<T: RawFloat>(v: Big, r: Big, q: u64, z: T) -> T {\n    let mut v_minus_r = v;\n    v_minus_r.sub(&r);\n    if r < v_minus_r {\n        z\n    } else if r > v_minus_r {\n        next_float(z)\n    } else if q % 2 == 0 {\n        z\n    } else {\n        next_float(z)\n    }\n}\n"],[2877,"//! Bit fiddling on positive IEEE 754 floats. Negative numbers aren't and needn't be handled.\n//! Normal floating point numbers have a canonical representation as (frac, exp) such that the\n//! value is 2<sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>)) where N is the number of bits.\n//! Subnormals are slightly different and weird, but the same principle applies.\n//!\n//! Here, however, we represent them as (sig, k) with f positive, such that the value is f *\n//! 2<sup>e</sup>. Besides making the \"hidden bit\" explicit, this changes the exponent by the\n//! so-called mantissa shift.\n//!\n//! Put another way, normally floats are written as (1) but here they are written as (2):\n//!\n//! 1. `1.101100...11 * 2^m`\n//! 2. `1101100...11 * 2^n`\n//!\n//! We call (1) the **fractional representation** and (2) the **integral representation**.\n//!\n//! Many functions in this module only handle normal numbers. The dec2flt routines conservatively\n//! take the universally-correct slow path (Algorithm M) for very small and very large numbers.\n//! That algorithm needs only next_float() which does handle subnormals and zeros.\nuse crate::cmp::Ordering::{Equal, Greater, Less};\nuse crate::convert::{TryFrom, TryInto};\nuse crate::fmt::{Debug, LowerExp};\nuse crate::num::dec2flt::num::{self, Big};\nuse crate::num::dec2flt::table;\nuse crate::num::diy_float::Fp;\nuse crate::num::FpCategory;\nuse crate::num::FpCategory::{Infinite, Nan, Normal, Subnormal, Zero};\nuse crate::ops::{Add, Div, Mul, Neg};\n\n#[derive(Copy, Clone, Debug)]\npub struct Unpacked {\n    pub sig: u64,\n    pub k: i16,\n}\n\nimpl Unpacked {\n    pub fn new(sig: u64, k: i16) -> Self {\n        Unpacked { sig, k }\n    }\n}\n\n/// A helper trait to avoid duplicating basically all the conversion code for `f32` and `f64`.\n///\n/// See the parent module's doc comment for why this is necessary.\n///\n/// Should **never ever** be implemented for other types or be used outside the dec2flt module.\npub trait RawFloat:\n    Copy + Debug + LowerExp + Mul<Output = Self> + Div<Output = Self> + Neg<Output = Self>\n{\n    const INFINITY: Self;\n    const NAN: Self;\n    const ZERO: Self;\n\n    /// Type used by `to_bits` and `from_bits`.\n    type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;\n\n    /// Performs a raw transmutation to an integer.\n    fn to_bits(self) -> Self::Bits;\n\n    /// Performs a raw transmutation from an integer.\n    fn from_bits(v: Self::Bits) -> Self;\n\n    /// Returns the category that this number falls into.\n    fn classify(self) -> FpCategory;\n\n    /// Returns the mantissa, exponent and sign as integers.\n    fn integer_decode(self) -> (u64, i16, i8);\n\n    /// Decodes the float.\n    fn unpack(self) -> Unpacked;\n\n    /// Casts from a small integer that can be represented exactly. Panic if the integer can't be\n    /// represented, the other code in this module makes sure to never let that happen.\n    fn from_int(x: u64) -> Self;\n\n    /// Gets the value 10<sup>e</sup> from a pre-computed table.\n    /// Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n    fn short_fast_pow10(e: usize) -> Self;\n\n    /// What the name says. It's easier to hard code than juggling intrinsics and\n    /// hoping LLVM constant folds it.\n    const CEIL_LOG5_OF_MAX_SIG: i16;\n\n    // A conservative bound on the decimal digits of inputs that can't produce overflow or zero or\n    /// subnormals. Probably the decimal exponent of the maximum normal value, hence the name.\n    const MAX_NORMAL_DIGITS: usize;\n\n    /// When the most significant decimal digit has a place value greater than this, the number\n    /// is certainly rounded to infinity.\n    const INF_CUTOFF: i64;\n\n    /// When the most significant decimal digit has a place value less than this, the number\n    /// is certainly rounded to zero.\n    const ZERO_CUTOFF: i64;\n\n    /// The number of bits in the exponent.\n    const EXP_BITS: u8;\n\n    /// The number of bits in the significand, *including* the hidden bit.\n    const SIG_BITS: u8;\n\n    /// The number of bits in the significand, *excluding* the hidden bit.\n    const EXPLICIT_SIG_BITS: u8;\n\n    /// The maximum legal exponent in fractional representation.\n    const MAX_EXP: i16;\n\n    /// The minimum legal exponent in fractional representation, excluding subnormals.\n    const MIN_EXP: i16;\n\n    /// `MAX_EXP` for integral representation, i.e., with the shift applied.\n    const MAX_EXP_INT: i16;\n\n    /// `MAX_EXP` encoded (i.e., with offset bias)\n    const MAX_ENCODED_EXP: i16;\n\n    /// `MIN_EXP` for integral representation, i.e., with the shift applied.\n    const MIN_EXP_INT: i16;\n\n    /// The maximum normalized significand in integral representation.\n    const MAX_SIG: u64;\n\n    /// The minimal normalized significand in integral representation.\n    const MIN_SIG: u64;\n}\n\n// Mostly a workaround for #34344.\nmacro_rules! other_constants {\n    ($type: ident) => {\n        const EXPLICIT_SIG_BITS: u8 = Self::SIG_BITS - 1;\n        const MAX_EXP: i16 = (1 << (Self::EXP_BITS - 1)) - 1;\n        const MIN_EXP: i16 = -<Self as RawFloat>::MAX_EXP + 1;\n        const MAX_EXP_INT: i16 = <Self as RawFloat>::MAX_EXP - (Self::SIG_BITS as i16 - 1);\n        const MAX_ENCODED_EXP: i16 = (1 << Self::EXP_BITS) - 1;\n        const MIN_EXP_INT: i16 = <Self as RawFloat>::MIN_EXP - (Self::SIG_BITS as i16 - 1);\n        const MAX_SIG: u64 = (1 << Self::SIG_BITS) - 1;\n        const MIN_SIG: u64 = 1 << (Self::SIG_BITS - 1);\n\n        const INFINITY: Self = $type::INFINITY;\n        const NAN: Self = $type::NAN;\n        const ZERO: Self = 0.0;\n    };\n}\n\nimpl RawFloat for f32 {\n    type Bits = u32;\n\n    const SIG_BITS: u8 = 24;\n    const EXP_BITS: u8 = 8;\n    const CEIL_LOG5_OF_MAX_SIG: i16 = 11;\n    const MAX_NORMAL_DIGITS: usize = 35;\n    const INF_CUTOFF: i64 = 40;\n    const ZERO_CUTOFF: i64 = -48;\n    other_constants!(f32);\n\n    /// Returns the mantissa, exponent and sign as integers.\n    fn integer_decode(self) -> (u64, i16, i8) {\n        let bits = self.to_bits();\n        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n        let mantissa =\n            if exponent == 0 { (bits & 0x7fffff) << 1 } else { (bits & 0x7fffff) | 0x800000 };\n        // Exponent bias + mantissa shift\n        exponent -= 127 + 23;\n        (mantissa as u64, exponent, sign)\n    }\n\n    fn unpack(self) -> Unpacked {\n        let (sig, exp, _sig) = self.integer_decode();\n        Unpacked::new(sig, exp)\n    }\n\n    fn from_int(x: u64) -> f32 {\n        // rkruppe is uncertain whether `as` rounds correctly on all platforms.\n        debug_assert!(x as f32 == fp_to_float(Fp { f: x, e: 0 }));\n        x as f32\n    }\n\n    fn short_fast_pow10(e: usize) -> Self {\n        table::F32_SHORT_POWERS[e]\n    }\n\n    fn classify(self) -> FpCategory {\n        self.classify()\n    }\n    fn to_bits(self) -> Self::Bits {\n        self.to_bits()\n    }\n    fn from_bits(v: Self::Bits) -> Self {\n        Self::from_bits(v)\n    }\n}\n\nimpl RawFloat for f64 {\n    type Bits = u64;\n\n    const SIG_BITS: u8 = 53;\n    const EXP_BITS: u8 = 11;\n    const CEIL_LOG5_OF_MAX_SIG: i16 = 23;\n    const MAX_NORMAL_DIGITS: usize = 305;\n    const INF_CUTOFF: i64 = 310;\n    const ZERO_CUTOFF: i64 = -326;\n    other_constants!(f64);\n\n    /// Returns the mantissa, exponent and sign as integers.\n    fn integer_decode(self) -> (u64, i16, i8) {\n        let bits = self.to_bits();\n        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n        let mantissa = if exponent == 0 {\n            (bits & 0xfffffffffffff) << 1\n        } else {\n            (bits & 0xfffffffffffff) | 0x10000000000000\n        };\n        // Exponent bias + mantissa shift\n        exponent -= 1023 + 52;\n        (mantissa, exponent, sign)\n    }\n\n    fn unpack(self) -> Unpacked {\n        let (sig, exp, _sig) = self.integer_decode();\n        Unpacked::new(sig, exp)\n    }\n\n    fn from_int(x: u64) -> f64 {\n        // rkruppe is uncertain whether `as` rounds correctly on all platforms.\n        debug_assert!(x as f64 == fp_to_float(Fp { f: x, e: 0 }));\n        x as f64\n    }\n\n    fn short_fast_pow10(e: usize) -> Self {\n        table::F64_SHORT_POWERS[e]\n    }\n\n    fn classify(self) -> FpCategory {\n        self.classify()\n    }\n    fn to_bits(self) -> Self::Bits {\n        self.to_bits()\n    }\n    fn from_bits(v: Self::Bits) -> Self {\n        Self::from_bits(v)\n    }\n}\n\n/// Converts an `Fp` to the closest machine float type.\n/// Does not handle subnormal results.\npub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n    let x = x.normalize();\n    // x.f is 64 bit, so x.e has a mantissa shift of 63\n    let e = x.e + 63;\n    if e > T::MAX_EXP {\n        panic!(\"fp_to_float: exponent {} too large\", e)\n    } else if e > T::MIN_EXP {\n        encode_normal(round_normal::<T>(x))\n    } else {\n        panic!(\"fp_to_float: exponent {} too small\", e)\n    }\n}\n\n/// Round the 64-bit significand to T::SIG_BITS bits with half-to-even.\n/// Does not handle exponent overflow.\npub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n    let excess = 64 - T::SIG_BITS as i16;\n    let half: u64 = 1 << (excess - 1);\n    let (q, rem) = (x.f >> excess, x.f & ((1 << excess) - 1));\n    assert_eq!(q << excess | rem, x.f);\n    // Adjust mantissa shift\n    let k = x.e + excess;\n    if rem < half {\n        Unpacked::new(q, k)\n    } else if rem == half && (q % 2) == 0 {\n        Unpacked::new(q, k)\n    } else if q == T::MAX_SIG {\n        Unpacked::new(T::MIN_SIG, k + 1)\n    } else {\n        Unpacked::new(q + 1, k)\n    }\n}\n\n/// Inverse of `RawFloat::unpack()` for normalized numbers.\n/// Panics if the significand or exponent are not valid for normalized numbers.\npub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n    debug_assert!(\n        T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\n        \"encode_normal: significand not normalized\"\n    );\n    // Remove the hidden bit\n    let sig_enc = x.sig & !(1 << T::EXPLICIT_SIG_BITS);\n    // Adjust the exponent for exponent bias and mantissa shift\n    let k_enc = x.k + T::MAX_EXP + T::EXPLICIT_SIG_BITS as i16;\n    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP, \"encode_normal: exponent out of range\");\n    // Leave sign bit at 0 (\"+\"), our numbers are all positive\n    let bits = (k_enc as u64) << T::EXPLICIT_SIG_BITS | sig_enc;\n    T::from_bits(bits.try_into().unwrap_or_else(|_| unreachable!()))\n}\n\n/// Construct a subnormal. A mantissa of 0 is allowed and constructs zero.\npub fn encode_subnormal<T: RawFloat>(significand: u64) -> T {\n    assert!(significand < T::MIN_SIG, \"encode_subnormal: not actually subnormal\");\n    // Encoded exponent is 0, the sign bit is 0, so we just have to reinterpret the bits.\n    T::from_bits(significand.try_into().unwrap_or_else(|_| unreachable!()))\n}\n\n/// Approximate a bignum with an Fp. Rounds within 0.5 ULP with half-to-even.\npub fn big_to_fp(f: &Big) -> Fp {\n    let end = f.bit_length();\n    assert!(end != 0, \"big_to_fp: unexpectedly, input is zero\");\n    let start = end.saturating_sub(64);\n    let leading = num::get_bits(f, start, end);\n    // We cut off all bits prior to the index `start`, i.e., we effectively right-shift by\n    // an amount of `start`, so this is also the exponent we need.\n    let e = start as i16;\n    let rounded_down = Fp { f: leading, e }.normalize();\n    // Round (half-to-even) depending on the truncated bits.\n    match num::compare_with_half_ulp(f, start) {\n        Less => rounded_down,\n        Equal if leading % 2 == 0 => rounded_down,\n        Equal | Greater => match leading.checked_add(1) {\n            Some(f) => Fp { f, e }.normalize(),\n            None => Fp { f: 1 << 63, e: e + 1 },\n        },\n    }\n}\n\n/// Finds the largest floating point number strictly smaller than the argument.\n/// Does not handle subnormals, zero, or exponent underflow.\npub fn prev_float<T: RawFloat>(x: T) -> T {\n    match x.classify() {\n        Infinite => panic!(\"prev_float: argument is infinite\"),\n        Nan => panic!(\"prev_float: argument is NaN\"),\n        Subnormal => panic!(\"prev_float: argument is subnormal\"),\n        Zero => panic!(\"prev_float: argument is zero\"),\n        Normal => {\n            let Unpacked { sig, k } = x.unpack();\n            if sig == T::MIN_SIG {\n                encode_normal(Unpacked::new(T::MAX_SIG, k - 1))\n            } else {\n                encode_normal(Unpacked::new(sig - 1, k))\n            }\n        }\n    }\n}\n\n// Find the smallest floating point number strictly larger than the argument.\n// This operation is saturating, i.e., next_float(inf) == inf.\n// Unlike most code in this module, this function does handle zero, subnormals, and infinities.\n// However, like all other code here, it does not deal with NaN and negative numbers.\npub fn next_float<T: RawFloat>(x: T) -> T {\n    match x.classify() {\n        Nan => panic!(\"next_float: argument is NaN\"),\n        Infinite => T::INFINITY,\n        // This seems too good to be true, but it works.\n        // 0.0 is encoded as the all-zero word. Subnormals are 0x000m...m where m is the mantissa.\n        // In particular, the smallest subnormal is 0x0...01 and the largest is 0x000F...F.\n        // The smallest normal number is 0x0010...0, so this corner case works as well.\n        // If the increment overflows the mantissa, the carry bit increments the exponent as we\n        // want, and the mantissa bits become zero. Because of the hidden bit convention, this\n        // too is exactly what we want!\n        // Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.\n        Zero | Subnormal | Normal => T::from_bits(x.to_bits() + T::Bits::from(1u8)),\n    }\n}\n"],[2878,"//! Utility functions for bignums that don't make too much sense to turn into methods.\n\n// FIXME This module's name is a bit unfortunate, since other modules also import `core::num`.\n\nuse crate::cmp::Ordering::{self, Equal, Greater, Less};\n\npub use crate::num::bignum::Big32x40 as Big;\n\n/// Test whether truncating all bits less significant than `ones_place` introduces\n/// a relative error less, equal, or greater than 0.5 ULP.\npub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n    if ones_place == 0 {\n        return Less;\n    }\n    let half_bit = ones_place - 1;\n    if f.get_bit(half_bit) == 0 {\n        // < 0.5 ULP\n        return Less;\n    }\n    // If all remaining bits are zero, it's = 0.5 ULP, otherwise > 0.5\n    // If there are no more bits (half_bit == 0), the below also correctly returns Equal.\n    for i in 0..half_bit {\n        if f.get_bit(i) == 1 {\n            return Greater;\n        }\n    }\n    Equal\n}\n\n/// Converts an ASCII string containing only decimal digits to a `u64`.\n///\n/// Does not perform checks for overflow or invalid characters, so if the caller is not careful,\n/// the result is bogus and can panic (though it won't be `unsafe`). Additionally, empty strings\n/// are treated as zero. This function exists because\n///\n/// 1. using `FromStr` on `&[u8]` requires `from_utf8_unchecked`, which is bad, and\n/// 2. piecing together the results of `integral.parse()` and `fractional.parse()` is\n///    more complicated than this entire function.\npub fn from_str_unchecked<'a, T>(bytes: T) -> u64\nwhere\n    T: IntoIterator<Item = &'a u8>,\n{\n    let mut result = 0;\n    for &c in bytes {\n        result = result * 10 + (c - b'0') as u64;\n    }\n    result\n}\n\n/// Converts a string of ASCII digits into a bignum.\n///\n/// Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.\npub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n    let mut f = Big::from_small(0);\n    for &c in integral.iter().chain(fractional) {\n        let n = (c - b'0') as u32;\n        f.mul_small(10);\n        f.add_small(n);\n    }\n    f\n}\n\n/// Unwraps a bignum into a 64 bit integer. Panics if the number is too large.\npub fn to_u64(x: &Big) -> u64 {\n    assert!(x.bit_length() < 64);\n    let d = x.digits();\n    if d.len() < 2 { d[0] as u64 } else { (d[1] as u64) << 32 | d[0] as u64 }\n}\n\n/// Extracts a range of bits.\n\n/// Index 0 is the least significant bit and the range is half-open as usual.\n/// Panics if asked to extract more bits than fit into the return type.\npub fn get_bits(x: &Big, start: usize, end: usize) -> u64 {\n    assert!(end - start <= 64);\n    let mut result: u64 = 0;\n    for i in (start..end).rev() {\n        result = result << 1 | x.get_bit(i) as u64;\n    }\n    result\n}\n"],[2879,"//! Converting decimal strings into IEEE 754 binary floating point numbers.\n//!\n//! # Problem statement\n//!\n//! We are given a decimal string such as `12.34e56`. This string consists of integral (`12`),\n//! fractional (`34`), and exponent (`56`) parts. All parts are optional and interpreted as zero\n//! when missing.\n//!\n//! We seek the IEEE 754 floating point number that is closest to the exact value of the decimal\n//! string. It is well-known that many decimal strings do not have terminating representations in\n//! base two, so we round to 0.5 units in the last place (in other words, as well as possible).\n//! Ties, decimal values exactly half-way between two consecutive floats, are resolved with the\n//! half-to-even strategy, also known as banker's rounding.\n//!\n//! Needless to say, this is quite hard, both in terms of implementation complexity and in terms\n//! of CPU cycles taken.\n//!\n//! # Implementation\n//!\n//! First, we ignore signs. Or rather, we remove it at the very beginning of the conversion\n//! process and re-apply it at the very end. This is correct in all edge cases since IEEE\n//! floats are symmetric around zero, negating one simply flips the first bit.\n//!\n//! Then we remove the decimal point by adjusting the exponent: Conceptually, `12.34e56` turns\n//! into `1234e54`, which we describe with a positive integer `f = 1234` and an integer `e = 54`.\n//! The `(f, e)` representation is used by almost all code past the parsing stage.\n//!\n//! We then try a long chain of progressively more general and expensive special cases using\n//! machine-sized integers and small, fixed-sized floating point numbers (first `f32`/`f64`, then\n//! a type with 64 bit significand, `Fp`). When all these fail, we bite the bullet and resort to a\n//! simple but very slow algorithm that involved computing `f * 10^e` fully and doing an iterative\n//! search for the best approximation.\n//!\n//! Primarily, this module and its children implement the algorithms described in:\n//! \"How to Read Floating Point Numbers Accurately\" by William D. Clinger,\n//! available online: <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4152>\n//!\n//! In addition, there are numerous helper functions that are used in the paper but not available\n//! in Rust (or at least in core). Our version is additionally complicated by the need to handle\n//! overflow and underflow and the desire to handle subnormal numbers. Bellerophon and\n//! Algorithm R have trouble with overflow, subnormals, and underflow. We conservatively switch to\n//! Algorithm M (with the modifications described in section 8 of the paper) well before the\n//! inputs get into the critical region.\n//!\n//! Another aspect that needs attention is the ``RawFloat`` trait by which almost all functions\n//! are parametrized. One might think that it's enough to parse to `f64` and cast the result to\n//! `f32`. Unfortunately this is not the world we live in, and this has nothing to do with using\n//! base two or half-to-even rounding.\n//!\n//! Consider for example two types `d2` and `d4` representing a decimal type with two decimal\n//! digits and four decimal digits each and take \"0.01499\" as input. Let's use half-up rounding.\n//! Going directly to two decimal digits gives `0.01`, but if we round to four digits first,\n//! we get `0.0150`, which is then rounded up to `0.02`. The same principle applies to other\n//! operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision\n//! and round *exactly once, at the end*, by considering all truncated bits at once.\n//!\n//! FIXME: Although some code duplication is necessary, perhaps parts of the code could be shuffled\n//! around such that less code is duplicated. Large parts of the algorithms are independent of the\n//! float type to output, or only needs access to a few constants, which could be passed in as\n//! parameters.\n//!\n//! # Other\n//!\n//! The conversion should *never* panic. There are assertions and explicit panics in the code,\n//! but they should never be triggered and only serve as internal sanity checks. Any panics should\n//! be considered a bug.\n//!\n//! There are unit tests but they are woefully inadequate at ensuring correctness, they only cover\n//! a small percentage of possible errors. Far more extensive tests are located in the directory\n//! `src/etc/test-float-parse` as a Python script.\n//!\n//! A note on integer overflow: Many parts of this file perform arithmetic with the decimal\n//! exponent `e`. Primarily, we shift the decimal point around: Before the first decimal digit,\n//! after the last decimal digit, and so on. This could overflow if done carelessly. We rely on\n//! the parsing submodule to only hand out sufficiently small exponents, where \"sufficient\" means\n//! \"such that the exponent +/- the number of decimal digits fits into a 64 bit integer\".\n//! Larger exponents are accepted, but we don't do arithmetic with them, they are immediately\n//! turned into {positive,negative} {zero,infinity}.\n\n#![doc(hidden)]\n#![unstable(\n    feature = \"dec2flt\",\n    reason = \"internal routines only exposed for testing\",\n    issue = \"none\"\n)]\n\nuse crate::fmt;\nuse crate::str::FromStr;\n\nuse self::num::digits_to_big;\nuse self::parse::{parse_decimal, Decimal, ParseResult, Sign};\nuse self::rawfp::RawFloat;\n\nmod algorithm;\nmod num;\nmod table;\n// These two have their own tests.\npub mod parse;\npub mod rawfp;\n\nmacro_rules! from_str_float_impl {\n    ($t:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl FromStr for $t {\n            type Err = ParseFloatError;\n\n            /// Converts a string in base 10 to a float.\n            /// Accepts an optional decimal exponent.\n            ///\n            /// This function accepts strings such as\n            ///\n            /// * '3.14'\n            /// * '-3.14'\n            /// * '2.5E10', or equivalently, '2.5e10'\n            /// * '2.5E-10'\n            /// * '5.'\n            /// * '.5', or, equivalently, '0.5'\n            /// * 'inf', '-inf', 'NaN'\n            ///\n            /// Leading and trailing whitespace represent an error.\n            ///\n            /// # Grammar\n            ///\n            /// All strings that adhere to the following [EBNF] grammar\n            /// will result in an [`Ok`] being returned:\n            ///\n            /// ```txt\n            /// Float  ::= Sign? ( 'inf' | 'NaN' | Number )\n            /// Number ::= ( Digit+ |\n            ///              Digit+ '.' Digit* |\n            ///              Digit* '.' Digit+ ) Exp?\n            /// Exp    ::= [eE] Sign? Digit+\n            /// Sign   ::= [+-]\n            /// Digit  ::= [0-9]\n            /// ```\n            ///\n            /// [EBNF]: https://www.w3.org/TR/REC-xml/#sec-notation\n            ///\n            /// # Known bugs\n            ///\n            /// In some situations, some strings that should create a valid float\n            /// instead return an error. See [issue #31407] for details.\n            ///\n            /// [issue #31407]: https://github.com/rust-lang/rust/issues/31407\n            ///\n            /// # Arguments\n            ///\n            /// * src - A string\n            ///\n            /// # Return value\n            ///\n            /// `Err(ParseFloatError)` if the string did not represent a valid\n            /// number. Otherwise, `Ok(n)` where `n` is the floating-point\n            /// number represented by `src`.\n            #[inline]\n            fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n                dec2flt(src)\n            }\n        }\n    };\n}\nfrom_str_float_impl!(f32);\nfrom_str_float_impl!(f64);\n\n/// An error which can be returned when parsing a float.\n///\n/// This error is used as the error type for the [`FromStr`] implementation\n/// for [`f32`] and [`f64`].\n///\n/// # Example\n///\n/// ```\n/// use std::str::FromStr;\n///\n/// if let Err(e) = f64::from_str(\"a.12\") {\n///     println!(\"Failed conversion to f64: {}\", e);\n/// }\n/// ```\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ParseFloatError {\n    kind: FloatErrorKind,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum FloatErrorKind {\n    Empty,\n    Invalid,\n}\n\nimpl ParseFloatError {\n    #[unstable(\n        feature = \"int_error_internals\",\n        reason = \"available through Error trait and this method should \\\n                  not be exposed publicly\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        match self.kind {\n            FloatErrorKind::Empty => \"cannot parse float from empty string\",\n            FloatErrorKind::Invalid => \"invalid float literal\",\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for ParseFloatError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.__description().fmt(f)\n    }\n}\n\nfn pfe_empty() -> ParseFloatError {\n    ParseFloatError { kind: FloatErrorKind::Empty }\n}\n\nfn pfe_invalid() -> ParseFloatError {\n    ParseFloatError { kind: FloatErrorKind::Invalid }\n}\n\n/// Splits a decimal string into sign and the rest, without inspecting or validating the rest.\nfn extract_sign(s: &str) -> (Sign, &str) {\n    match s.as_bytes()[0] {\n        b'+' => (Sign::Positive, &s[1..]),\n        b'-' => (Sign::Negative, &s[1..]),\n        // If the string is invalid, we never use the sign, so we don't need to validate here.\n        _ => (Sign::Positive, s),\n    }\n}\n\n/// Converts a decimal string into a floating point number.\nfn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n    if s.is_empty() {\n        return Err(pfe_empty());\n    }\n    let (sign, s) = extract_sign(s);\n    let flt = match parse_decimal(s) {\n        ParseResult::Valid(decimal) => convert(decimal)?,\n        ParseResult::ShortcutToInf => T::INFINITY,\n        ParseResult::ShortcutToZero => T::ZERO,\n        ParseResult::Invalid => {\n            if s.eq_ignore_ascii_case(\"nan\") {\n                T::NAN\n            } else if s.eq_ignore_ascii_case(\"inf\") || s.eq_ignore_ascii_case(\"infinity\") {\n                T::INFINITY\n            } else {\n                return Err(pfe_invalid());\n            }\n        }\n    };\n\n    match sign {\n        Sign::Positive => Ok(flt),\n        Sign::Negative => Ok(-flt),\n    }\n}\n\n/// The main workhorse for the decimal-to-float conversion: Orchestrate all the preprocessing\n/// and figure out which algorithm should do the actual conversion.\nfn convert<T: RawFloat>(mut decimal: Decimal<'_>) -> Result<T, ParseFloatError> {\n    simplify(&mut decimal);\n    if let Some(x) = trivial_cases(&decimal) {\n        return Ok(x);\n    }\n    // Remove/shift out the decimal point.\n    let e = decimal.exp - decimal.fractional.len() as i64;\n    if let Some(x) = algorithm::fast_path(decimal.integral, decimal.fractional, e) {\n        return Ok(x);\n    }\n    // Big32x40 is limited to 1280 bits, which translates to about 385 decimal digits.\n    // If we exceed this, we'll crash, so we error out before getting too close (within 10^10).\n    let upper_bound = bound_intermediate_digits(&decimal, e);\n    if upper_bound > 375 {\n        return Err(pfe_invalid());\n    }\n    let f = digits_to_big(decimal.integral, decimal.fractional);\n\n    // Now the exponent certainly fits in 16 bit, which is used throughout the main algorithms.\n    let e = e as i16;\n    // FIXME These bounds are rather conservative. A more careful analysis of the failure modes\n    // of Bellerophon could allow using it in more cases for a massive speed up.\n    let exponent_in_range = table::MIN_E <= e && e <= table::MAX_E;\n    let value_in_range = upper_bound <= T::MAX_NORMAL_DIGITS as u64;\n    if exponent_in_range && value_in_range {\n        Ok(algorithm::bellerophon(&f, e))\n    } else {\n        Ok(algorithm::algorithm_m(&f, e))\n    }\n}\n\n// As written, this optimizes badly (see #27130, though it refers to an old version of the code).\n// `inline(always)` is a workaround for that. There are only two call sites overall and it doesn't\n// make code size worse.\n\n/// Strip zeros where possible, even when this requires changing the exponent\n#[inline(always)]\nfn simplify(decimal: &mut Decimal<'_>) {\n    let is_zero = &|&&d: &&u8| -> bool { d == b'0' };\n    // Trimming these zeros does not change anything but may enable the fast path (< 15 digits).\n    let leading_zeros = decimal.integral.iter().take_while(is_zero).count();\n    decimal.integral = &decimal.integral[leading_zeros..];\n    let trailing_zeros = decimal.fractional.iter().rev().take_while(is_zero).count();\n    let end = decimal.fractional.len() - trailing_zeros;\n    decimal.fractional = &decimal.fractional[..end];\n    // Simplify numbers of the form 0.0...x and x...0.0, adjusting the exponent accordingly.\n    // This may not always be a win (possibly pushes some numbers out of the fast path), but it\n    // simplifies other parts significantly (notably, approximating the magnitude of the value).\n    if decimal.integral.is_empty() {\n        let leading_zeros = decimal.fractional.iter().take_while(is_zero).count();\n        decimal.fractional = &decimal.fractional[leading_zeros..];\n        decimal.exp -= leading_zeros as i64;\n    } else if decimal.fractional.is_empty() {\n        let trailing_zeros = decimal.integral.iter().rev().take_while(is_zero).count();\n        let end = decimal.integral.len() - trailing_zeros;\n        decimal.integral = &decimal.integral[..end];\n        decimal.exp += trailing_zeros as i64;\n    }\n}\n\n/// Returns a quick-an-dirty upper bound on the size (log10) of the largest value that Algorithm R\n/// and Algorithm M will compute while working on the given decimal.\nfn bound_intermediate_digits(decimal: &Decimal<'_>, e: i64) -> u64 {\n    // We don't need to worry too much about overflow here thanks to trivial_cases() and the\n    // parser, which filter out the most extreme inputs for us.\n    let f_len: u64 = decimal.integral.len() as u64 + decimal.fractional.len() as u64;\n    if e >= 0 {\n        // In the case e >= 0, both algorithms compute about `f * 10^e`. Algorithm R proceeds to\n        // do some complicated calculations with this but we can ignore that for the upper bound\n        // because it also reduces the fraction beforehand, so we have plenty of buffer there.\n        f_len + (e as u64)\n    } else {\n        // If e < 0, Algorithm R does roughly the same thing, but Algorithm M differs:\n        // It tries to find a positive number k such that `f << k / 10^e` is an in-range\n        // significand. This will result in about `2^53 * f * 10^e` < `10^17 * f * 10^e`.\n        // One input that triggers this is 0.33...33 (375 x 3).\n        f_len + e.unsigned_abs() + 17\n    }\n}\n\n/// Detects obvious overflows and underflows without even looking at the decimal digits.\nfn trivial_cases<T: RawFloat>(decimal: &Decimal<'_>) -> Option<T> {\n    // There were zeros but they were stripped by simplify()\n    if decimal.integral.is_empty() && decimal.fractional.is_empty() {\n        return Some(T::ZERO);\n    }\n    // This is a crude approximation of ceil(log10(the real value)). We don't need to worry too\n    // much about overflow here because the input length is tiny (at least compared to 2^64) and\n    // the parser already handles exponents whose absolute value is greater than 10^18\n    // (which is still 10^19 short of 2^64).\n    let max_place = decimal.exp + decimal.integral.len() as i64;\n    if max_place > T::INF_CUTOFF {\n        return Some(T::INFINITY);\n    } else if max_place < T::ZERO_CUTOFF {\n        return Some(T::ZERO);\n    }\n    None\n}\n"],[2880,"//! Validating and decomposing a decimal string of the form:\n//!\n//! `(digits | digits? '.'? digits?) (('e' | 'E') ('+' | '-')? digits)?`\n//!\n//! In other words, standard floating-point syntax, with two exceptions: No sign, and no\n//! handling of \"inf\" and \"NaN\". These are handled by the driver function (super::dec2flt).\n//!\n//! Although recognizing valid inputs is relatively easy, this module also has to reject the\n//! countless invalid variations, never panic, and perform numerous checks that the other\n//! modules rely on to not panic (or overflow) in turn.\n//! To make matters worse, all that happens in a single pass over the input.\n//! So, be careful when modifying anything, and double-check with the other modules.\nuse self::ParseResult::{Invalid, ShortcutToInf, ShortcutToZero, Valid};\nuse super::num;\n\n#[derive(Debug)]\npub enum Sign {\n    Positive,\n    Negative,\n}\n\n#[derive(Debug, PartialEq, Eq)]\n/// The interesting parts of a decimal string.\npub struct Decimal<'a> {\n    pub integral: &'a [u8],\n    pub fractional: &'a [u8],\n    /// The decimal exponent, guaranteed to have fewer than 18 decimal digits.\n    pub exp: i64,\n}\n\nimpl<'a> Decimal<'a> {\n    pub fn new(integral: &'a [u8], fractional: &'a [u8], exp: i64) -> Decimal<'a> {\n        Decimal { integral, fractional, exp }\n    }\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum ParseResult<'a> {\n    Valid(Decimal<'a>),\n    ShortcutToInf,\n    ShortcutToZero,\n    Invalid,\n}\n\n/// Checks if the input string is a valid floating point number and if so, locate the integral\n/// part, the fractional part, and the exponent in it. Does not handle signs.\npub fn parse_decimal(s: &str) -> ParseResult<'_> {\n    if s.is_empty() {\n        return Invalid;\n    }\n\n    let s = s.as_bytes();\n    let (integral, s) = eat_digits(s);\n\n    match s.first() {\n        None => Valid(Decimal::new(integral, b\"\", 0)),\n        Some(&b'e' | &b'E') => {\n            if integral.is_empty() {\n                return Invalid; // No digits before 'e'\n            }\n\n            parse_exp(integral, b\"\", &s[1..])\n        }\n        Some(&b'.') => {\n            let (fractional, s) = eat_digits(&s[1..]);\n            if integral.is_empty() && fractional.is_empty() {\n                // We require at least a single digit before or after the point.\n                return Invalid;\n            }\n\n            match s.first() {\n                None => Valid(Decimal::new(integral, fractional, 0)),\n                Some(&b'e' | &b'E') => parse_exp(integral, fractional, &s[1..]),\n                _ => Invalid, // Trailing junk after fractional part\n            }\n        }\n        _ => Invalid, // Trailing junk after first digit string\n    }\n}\n\n/// Carves off decimal digits up to the first non-digit character.\nfn eat_digits(s: &[u8]) -> (&[u8], &[u8]) {\n    let pos = s.iter().position(|c| !c.is_ascii_digit()).unwrap_or(s.len());\n    s.split_at(pos)\n}\n\n/// Exponent extraction and error checking.\nfn parse_exp<'a>(integral: &'a [u8], fractional: &'a [u8], rest: &'a [u8]) -> ParseResult<'a> {\n    let (sign, rest) = match rest.first() {\n        Some(&b'-') => (Sign::Negative, &rest[1..]),\n        Some(&b'+') => (Sign::Positive, &rest[1..]),\n        _ => (Sign::Positive, rest),\n    };\n    let (mut number, trailing) = eat_digits(rest);\n    if !trailing.is_empty() {\n        return Invalid; // Trailing junk after exponent\n    }\n    if number.is_empty() {\n        return Invalid; // Empty exponent\n    }\n    // At this point, we certainly have a valid string of digits. It may be too long to put into\n    // an `i64`, but if it's that huge, the input is certainly zero or infinity. Since each zero\n    // in the decimal digits only adjusts the exponent by +/- 1, at exp = 10^18 the input would\n    // have to be 17 exabyte (!) of zeros to get even remotely close to being finite.\n    // This is not exactly a use case we need to cater to.\n    while number.first() == Some(&b'0') {\n        number = &number[1..];\n    }\n    if number.len() >= 18 {\n        return match sign {\n            Sign::Positive => ShortcutToInf,\n            Sign::Negative => ShortcutToZero,\n        };\n    }\n    let abs_exp = num::from_str_unchecked(number);\n    let e = match sign {\n        Sign::Positive => abs_exp as i64,\n        Sign::Negative => -(abs_exp as i64),\n    };\n    Valid(Decimal::new(integral, fractional, e))\n}\n"],[2881,"//! Tables of approximations of powers of ten.\n//! DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`\n\npub const MIN_E: i16 = -305;\npub const MAX_E: i16 = 305;\n\n#[rustfmt::skip]\npub static POWERS: ([u64; 611], [i16; 611]) = (\n    [\n        0xe0b62e2929aba83c,\n        0x8c71dcd9ba0b4926,\n        0xaf8e5410288e1b6f,\n        0xdb71e91432b1a24b,\n        0x892731ac9faf056f,\n        0xab70fe17c79ac6ca,\n        0xd64d3d9db981787d,\n        0x85f0468293f0eb4e,\n        0xa76c582338ed2622,\n        0xd1476e2c07286faa,\n        0x82cca4db847945ca,\n        0xa37fce126597973d,\n        0xcc5fc196fefd7d0c,\n        0xff77b1fcbebcdc4f,\n        0x9faacf3df73609b1,\n        0xc795830d75038c1e,\n        0xf97ae3d0d2446f25,\n        0x9becce62836ac577,\n        0xc2e801fb244576d5,\n        0xf3a20279ed56d48a,\n        0x9845418c345644d7,\n        0xbe5691ef416bd60c,\n        0xedec366b11c6cb8f,\n        0x94b3a202eb1c3f39,\n        0xb9e08a83a5e34f08,\n        0xe858ad248f5c22ca,\n        0x91376c36d99995be,\n        0xb58547448ffffb2e,\n        0xe2e69915b3fff9f9,\n        0x8dd01fad907ffc3c,\n        0xb1442798f49ffb4b,\n        0xdd95317f31c7fa1d,\n        0x8a7d3eef7f1cfc52,\n        0xad1c8eab5ee43b67,\n        0xd863b256369d4a41,\n        0x873e4f75e2224e68,\n        0xa90de3535aaae202,\n        0xd3515c2831559a83,\n        0x8412d9991ed58092,\n        0xa5178fff668ae0b6,\n        0xce5d73ff402d98e4,\n        0x80fa687f881c7f8e,\n        0xa139029f6a239f72,\n        0xc987434744ac874f,\n        0xfbe9141915d7a922,\n        0x9d71ac8fada6c9b5,\n        0xc4ce17b399107c23,\n        0xf6019da07f549b2b,\n        0x99c102844f94e0fb,\n        0xc0314325637a193a,\n        0xf03d93eebc589f88,\n        0x96267c7535b763b5,\n        0xbbb01b9283253ca3,\n        0xea9c227723ee8bcb,\n        0x92a1958a7675175f,\n        0xb749faed14125d37,\n        0xe51c79a85916f485,\n        0x8f31cc0937ae58d3,\n        0xb2fe3f0b8599ef08,\n        0xdfbdcece67006ac9,\n        0x8bd6a141006042be,\n        0xaecc49914078536d,\n        0xda7f5bf590966849,\n        0x888f99797a5e012d,\n        0xaab37fd7d8f58179,\n        0xd5605fcdcf32e1d7,\n        0x855c3be0a17fcd26,\n        0xa6b34ad8c9dfc070,\n        0xd0601d8efc57b08c,\n        0x823c12795db6ce57,\n        0xa2cb1717b52481ed,\n        0xcb7ddcdda26da269,\n        0xfe5d54150b090b03,\n        0x9efa548d26e5a6e2,\n        0xc6b8e9b0709f109a,\n        0xf867241c8cc6d4c1,\n        0x9b407691d7fc44f8,\n        0xc21094364dfb5637,\n        0xf294b943e17a2bc4,\n        0x979cf3ca6cec5b5b,\n        0xbd8430bd08277231,\n        0xece53cec4a314ebe,\n        0x940f4613ae5ed137,\n        0xb913179899f68584,\n        0xe757dd7ec07426e5,\n        0x9096ea6f3848984f,\n        0xb4bca50b065abe63,\n        0xe1ebce4dc7f16dfc,\n        0x8d3360f09cf6e4bd,\n        0xb080392cc4349ded,\n        0xdca04777f541c568,\n        0x89e42caaf9491b61,\n        0xac5d37d5b79b6239,\n        0xd77485cb25823ac7,\n        0x86a8d39ef77164bd,\n        0xa8530886b54dbdec,\n        0xd267caa862a12d67,\n        0x8380dea93da4bc60,\n        0xa46116538d0deb78,\n        0xcd795be870516656,\n        0x806bd9714632dff6,\n        0xa086cfcd97bf97f4,\n        0xc8a883c0fdaf7df0,\n        0xfad2a4b13d1b5d6c,\n        0x9cc3a6eec6311a64,\n        0xc3f490aa77bd60fd,\n        0xf4f1b4d515acb93c,\n        0x991711052d8bf3c5,\n        0xbf5cd54678eef0b7,\n        0xef340a98172aace5,\n        0x9580869f0e7aac0f,\n        0xbae0a846d2195713,\n        0xe998d258869facd7,\n        0x91ff83775423cc06,\n        0xb67f6455292cbf08,\n        0xe41f3d6a7377eeca,\n        0x8e938662882af53e,\n        0xb23867fb2a35b28e,\n        0xdec681f9f4c31f31,\n        0x8b3c113c38f9f37f,\n        0xae0b158b4738705f,\n        0xd98ddaee19068c76,\n        0x87f8a8d4cfa417ca,\n        0xa9f6d30a038d1dbc,\n        0xd47487cc8470652b,\n        0x84c8d4dfd2c63f3b,\n        0xa5fb0a17c777cf0a,\n        0xcf79cc9db955c2cc,\n        0x81ac1fe293d599c0,\n        0xa21727db38cb0030,\n        0xca9cf1d206fdc03c,\n        0xfd442e4688bd304b,\n        0x9e4a9cec15763e2f,\n        0xc5dd44271ad3cdba,\n        0xf7549530e188c129,\n        0x9a94dd3e8cf578ba,\n        0xc13a148e3032d6e8,\n        0xf18899b1bc3f8ca2,\n        0x96f5600f15a7b7e5,\n        0xbcb2b812db11a5de,\n        0xebdf661791d60f56,\n        0x936b9fcebb25c996,\n        0xb84687c269ef3bfb,\n        0xe65829b3046b0afa,\n        0x8ff71a0fe2c2e6dc,\n        0xb3f4e093db73a093,\n        0xe0f218b8d25088b8,\n        0x8c974f7383725573,\n        0xafbd2350644eead0,\n        0xdbac6c247d62a584,\n        0x894bc396ce5da772,\n        0xab9eb47c81f5114f,\n        0xd686619ba27255a3,\n        0x8613fd0145877586,\n        0xa798fc4196e952e7,\n        0xd17f3b51fca3a7a1,\n        0x82ef85133de648c5,\n        0xa3ab66580d5fdaf6,\n        0xcc963fee10b7d1b3,\n        0xffbbcfe994e5c620,\n        0x9fd561f1fd0f9bd4,\n        0xc7caba6e7c5382c9,\n        0xf9bd690a1b68637b,\n        0x9c1661a651213e2d,\n        0xc31bfa0fe5698db8,\n        0xf3e2f893dec3f126,\n        0x986ddb5c6b3a76b8,\n        0xbe89523386091466,\n        0xee2ba6c0678b597f,\n        0x94db483840b717f0,\n        0xba121a4650e4ddec,\n        0xe896a0d7e51e1566,\n        0x915e2486ef32cd60,\n        0xb5b5ada8aaff80b8,\n        0xe3231912d5bf60e6,\n        0x8df5efabc5979c90,\n        0xb1736b96b6fd83b4,\n        0xddd0467c64bce4a1,\n        0x8aa22c0dbef60ee4,\n        0xad4ab7112eb3929e,\n        0xd89d64d57a607745,\n        0x87625f056c7c4a8b,\n        0xa93af6c6c79b5d2e,\n        0xd389b47879823479,\n        0x843610cb4bf160cc,\n        0xa54394fe1eedb8ff,\n        0xce947a3da6a9273e,\n        0x811ccc668829b887,\n        0xa163ff802a3426a9,\n        0xc9bcff6034c13053,\n        0xfc2c3f3841f17c68,\n        0x9d9ba7832936edc1,\n        0xc5029163f384a931,\n        0xf64335bcf065d37d,\n        0x99ea0196163fa42e,\n        0xc06481fb9bcf8d3a,\n        0xf07da27a82c37088,\n        0x964e858c91ba2655,\n        0xbbe226efb628afeb,\n        0xeadab0aba3b2dbe5,\n        0x92c8ae6b464fc96f,\n        0xb77ada0617e3bbcb,\n        0xe55990879ddcaabe,\n        0x8f57fa54c2a9eab7,\n        0xb32df8e9f3546564,\n        0xdff9772470297ebd,\n        0x8bfbea76c619ef36,\n        0xaefae51477a06b04,\n        0xdab99e59958885c5,\n        0x88b402f7fd75539b,\n        0xaae103b5fcd2a882,\n        0xd59944a37c0752a2,\n        0x857fcae62d8493a5,\n        0xa6dfbd9fb8e5b88f,\n        0xd097ad07a71f26b2,\n        0x825ecc24c8737830,\n        0xa2f67f2dfa90563b,\n        0xcbb41ef979346bca,\n        0xfea126b7d78186bd,\n        0x9f24b832e6b0f436,\n        0xc6ede63fa05d3144,\n        0xf8a95fcf88747d94,\n        0x9b69dbe1b548ce7d,\n        0xc24452da229b021c,\n        0xf2d56790ab41c2a3,\n        0x97c560ba6b0919a6,\n        0xbdb6b8e905cb600f,\n        0xed246723473e3813,\n        0x9436c0760c86e30c,\n        0xb94470938fa89bcf,\n        0xe7958cb87392c2c3,\n        0x90bd77f3483bb9ba,\n        0xb4ecd5f01a4aa828,\n        0xe2280b6c20dd5232,\n        0x8d590723948a535f,\n        0xb0af48ec79ace837,\n        0xdcdb1b2798182245,\n        0x8a08f0f8bf0f156b,\n        0xac8b2d36eed2dac6,\n        0xd7adf884aa879177,\n        0x86ccbb52ea94baeb,\n        0xa87fea27a539e9a5,\n        0xd29fe4b18e88640f,\n        0x83a3eeeef9153e89,\n        0xa48ceaaab75a8e2b,\n        0xcdb02555653131b6,\n        0x808e17555f3ebf12,\n        0xa0b19d2ab70e6ed6,\n        0xc8de047564d20a8c,\n        0xfb158592be068d2f,\n        0x9ced737bb6c4183d,\n        0xc428d05aa4751e4d,\n        0xf53304714d9265e0,\n        0x993fe2c6d07b7fac,\n        0xbf8fdb78849a5f97,\n        0xef73d256a5c0f77d,\n        0x95a8637627989aae,\n        0xbb127c53b17ec159,\n        0xe9d71b689dde71b0,\n        0x9226712162ab070e,\n        0xb6b00d69bb55c8d1,\n        0xe45c10c42a2b3b06,\n        0x8eb98a7a9a5b04e3,\n        0xb267ed1940f1c61c,\n        0xdf01e85f912e37a3,\n        0x8b61313bbabce2c6,\n        0xae397d8aa96c1b78,\n        0xd9c7dced53c72256,\n        0x881cea14545c7575,\n        0xaa242499697392d3,\n        0xd4ad2dbfc3d07788,\n        0x84ec3c97da624ab5,\n        0xa6274bbdd0fadd62,\n        0xcfb11ead453994ba,\n        0x81ceb32c4b43fcf5,\n        0xa2425ff75e14fc32,\n        0xcad2f7f5359a3b3e,\n        0xfd87b5f28300ca0e,\n        0x9e74d1b791e07e48,\n        0xc612062576589ddb,\n        0xf79687aed3eec551,\n        0x9abe14cd44753b53,\n        0xc16d9a0095928a27,\n        0xf1c90080baf72cb1,\n        0x971da05074da7bef,\n        0xbce5086492111aeb,\n        0xec1e4a7db69561a5,\n        0x9392ee8e921d5d07,\n        0xb877aa3236a4b449,\n        0xe69594bec44de15b,\n        0x901d7cf73ab0acd9,\n        0xb424dc35095cd80f,\n        0xe12e13424bb40e13,\n        0x8cbccc096f5088cc,\n        0xafebff0bcb24aaff,\n        0xdbe6fecebdedd5bf,\n        0x89705f4136b4a597,\n        0xabcc77118461cefd,\n        0xd6bf94d5e57a42bc,\n        0x8637bd05af6c69b6,\n        0xa7c5ac471b478423,\n        0xd1b71758e219652c,\n        0x83126e978d4fdf3b,\n        0xa3d70a3d70a3d70a,\n        0xcccccccccccccccd,\n        0x8000000000000000,\n        0xa000000000000000,\n        0xc800000000000000,\n        0xfa00000000000000,\n        0x9c40000000000000,\n        0xc350000000000000,\n        0xf424000000000000,\n        0x9896800000000000,\n        0xbebc200000000000,\n        0xee6b280000000000,\n        0x9502f90000000000,\n        0xba43b74000000000,\n        0xe8d4a51000000000,\n        0x9184e72a00000000,\n        0xb5e620f480000000,\n        0xe35fa931a0000000,\n        0x8e1bc9bf04000000,\n        0xb1a2bc2ec5000000,\n        0xde0b6b3a76400000,\n        0x8ac7230489e80000,\n        0xad78ebc5ac620000,\n        0xd8d726b7177a8000,\n        0x878678326eac9000,\n        0xa968163f0a57b400,\n        0xd3c21bcecceda100,\n        0x84595161401484a0,\n        0xa56fa5b99019a5c8,\n        0xcecb8f27f4200f3a,\n        0x813f3978f8940984,\n        0xa18f07d736b90be5,\n        0xc9f2c9cd04674edf,\n        0xfc6f7c4045812296,\n        0x9dc5ada82b70b59e,\n        0xc5371912364ce305,\n        0xf684df56c3e01bc7,\n        0x9a130b963a6c115c,\n        0xc097ce7bc90715b3,\n        0xf0bdc21abb48db20,\n        0x96769950b50d88f4,\n        0xbc143fa4e250eb31,\n        0xeb194f8e1ae525fd,\n        0x92efd1b8d0cf37be,\n        0xb7abc627050305ae,\n        0xe596b7b0c643c719,\n        0x8f7e32ce7bea5c70,\n        0xb35dbf821ae4f38c,\n        0xe0352f62a19e306f,\n        0x8c213d9da502de45,\n        0xaf298d050e4395d7,\n        0xdaf3f04651d47b4c,\n        0x88d8762bf324cd10,\n        0xab0e93b6efee0054,\n        0xd5d238a4abe98068,\n        0x85a36366eb71f041,\n        0xa70c3c40a64e6c52,\n        0xd0cf4b50cfe20766,\n        0x82818f1281ed44a0,\n        0xa321f2d7226895c8,\n        0xcbea6f8ceb02bb3a,\n        0xfee50b7025c36a08,\n        0x9f4f2726179a2245,\n        0xc722f0ef9d80aad6,\n        0xf8ebad2b84e0d58c,\n        0x9b934c3b330c8577,\n        0xc2781f49ffcfa6d5,\n        0xf316271c7fc3908b,\n        0x97edd871cfda3a57,\n        0xbde94e8e43d0c8ec,\n        0xed63a231d4c4fb27,\n        0x945e455f24fb1cf9,\n        0xb975d6b6ee39e437,\n        0xe7d34c64a9c85d44,\n        0x90e40fbeea1d3a4b,\n        0xb51d13aea4a488dd,\n        0xe264589a4dcdab15,\n        0x8d7eb76070a08aed,\n        0xb0de65388cc8ada8,\n        0xdd15fe86affad912,\n        0x8a2dbf142dfcc7ab,\n        0xacb92ed9397bf996,\n        0xd7e77a8f87daf7fc,\n        0x86f0ac99b4e8dafd,\n        0xa8acd7c0222311bd,\n        0xd2d80db02aabd62c,\n        0x83c7088e1aab65db,\n        0xa4b8cab1a1563f52,\n        0xcde6fd5e09abcf27,\n        0x80b05e5ac60b6178,\n        0xa0dc75f1778e39d6,\n        0xc913936dd571c84c,\n        0xfb5878494ace3a5f,\n        0x9d174b2dcec0e47b,\n        0xc45d1df942711d9a,\n        0xf5746577930d6501,\n        0x9968bf6abbe85f20,\n        0xbfc2ef456ae276e9,\n        0xefb3ab16c59b14a3,\n        0x95d04aee3b80ece6,\n        0xbb445da9ca61281f,\n        0xea1575143cf97227,\n        0x924d692ca61be758,\n        0xb6e0c377cfa2e12e,\n        0xe498f455c38b997a,\n        0x8edf98b59a373fec,\n        0xb2977ee300c50fe7,\n        0xdf3d5e9bc0f653e1,\n        0x8b865b215899f46d,\n        0xae67f1e9aec07188,\n        0xda01ee641a708dea,\n        0x884134fe908658b2,\n        0xaa51823e34a7eedf,\n        0xd4e5e2cdc1d1ea96,\n        0x850fadc09923329e,\n        0xa6539930bf6bff46,\n        0xcfe87f7cef46ff17,\n        0x81f14fae158c5f6e,\n        0xa26da3999aef774a,\n        0xcb090c8001ab551c,\n        0xfdcb4fa002162a63,\n        0x9e9f11c4014dda7e,\n        0xc646d63501a1511e,\n        0xf7d88bc24209a565,\n        0x9ae757596946075f,\n        0xc1a12d2fc3978937,\n        0xf209787bb47d6b85,\n        0x9745eb4d50ce6333,\n        0xbd176620a501fc00,\n        0xec5d3fa8ce427b00,\n        0x93ba47c980e98ce0,\n        0xb8a8d9bbe123f018,\n        0xe6d3102ad96cec1e,\n        0x9043ea1ac7e41393,\n        0xb454e4a179dd1877,\n        0xe16a1dc9d8545e95,\n        0x8ce2529e2734bb1d,\n        0xb01ae745b101e9e4,\n        0xdc21a1171d42645d,\n        0x899504ae72497eba,\n        0xabfa45da0edbde69,\n        0xd6f8d7509292d603,\n        0x865b86925b9bc5c2,\n        0xa7f26836f282b733,\n        0xd1ef0244af2364ff,\n        0x8335616aed761f1f,\n        0xa402b9c5a8d3a6e7,\n        0xcd036837130890a1,\n        0x802221226be55a65,\n        0xa02aa96b06deb0fe,\n        0xc83553c5c8965d3d,\n        0xfa42a8b73abbf48d,\n        0x9c69a97284b578d8,\n        0xc38413cf25e2d70e,\n        0xf46518c2ef5b8cd1,\n        0x98bf2f79d5993803,\n        0xbeeefb584aff8604,\n        0xeeaaba2e5dbf6785,\n        0x952ab45cfa97a0b3,\n        0xba756174393d88e0,\n        0xe912b9d1478ceb17,\n        0x91abb422ccb812ef,\n        0xb616a12b7fe617aa,\n        0xe39c49765fdf9d95,\n        0x8e41ade9fbebc27d,\n        0xb1d219647ae6b31c,\n        0xde469fbd99a05fe3,\n        0x8aec23d680043bee,\n        0xada72ccc20054aea,\n        0xd910f7ff28069da4,\n        0x87aa9aff79042287,\n        0xa99541bf57452b28,\n        0xd3fa922f2d1675f2,\n        0x847c9b5d7c2e09b7,\n        0xa59bc234db398c25,\n        0xcf02b2c21207ef2f,\n        0x8161afb94b44f57d,\n        0xa1ba1ba79e1632dc,\n        0xca28a291859bbf93,\n        0xfcb2cb35e702af78,\n        0x9defbf01b061adab,\n        0xc56baec21c7a1916,\n        0xf6c69a72a3989f5c,\n        0x9a3c2087a63f6399,\n        0xc0cb28a98fcf3c80,\n        0xf0fdf2d3f3c30b9f,\n        0x969eb7c47859e744,\n        0xbc4665b596706115,\n        0xeb57ff22fc0c795a,\n        0x9316ff75dd87cbd8,\n        0xb7dcbf5354e9bece,\n        0xe5d3ef282a242e82,\n        0x8fa475791a569d11,\n        0xb38d92d760ec4455,\n        0xe070f78d3927556b,\n        0x8c469ab843b89563,\n        0xaf58416654a6babb,\n        0xdb2e51bfe9d0696a,\n        0x88fcf317f22241e2,\n        0xab3c2fddeeaad25b,\n        0xd60b3bd56a5586f2,\n        0x85c7056562757457,\n        0xa738c6bebb12d16d,\n        0xd106f86e69d785c8,\n        0x82a45b450226b39d,\n        0xa34d721642b06084,\n        0xcc20ce9bd35c78a5,\n        0xff290242c83396ce,\n        0x9f79a169bd203e41,\n        0xc75809c42c684dd1,\n        0xf92e0c3537826146,\n        0x9bbcc7a142b17ccc,\n        0xc2abf989935ddbfe,\n        0xf356f7ebf83552fe,\n        0x98165af37b2153df,\n        0xbe1bf1b059e9a8d6,\n        0xeda2ee1c7064130c,\n        0x9485d4d1c63e8be8,\n        0xb9a74a0637ce2ee1,\n        0xe8111c87c5c1ba9a,\n        0x910ab1d4db9914a0,\n        0xb54d5e4a127f59c8,\n        0xe2a0b5dc971f303a,\n        0x8da471a9de737e24,\n        0xb10d8e1456105dad,\n        0xdd50f1996b947519,\n        0x8a5296ffe33cc930,\n        0xace73cbfdc0bfb7b,\n        0xd8210befd30efa5a,\n        0x8714a775e3e95c78,\n        0xa8d9d1535ce3b396,\n        0xd31045a8341ca07c,\n        0x83ea2b892091e44e,\n        0xa4e4b66b68b65d61,\n        0xce1de40642e3f4b9,\n        0x80d2ae83e9ce78f4,\n        0xa1075a24e4421731,\n        0xc94930ae1d529cfd,\n        0xfb9b7cd9a4a7443c,\n        0x9d412e0806e88aa6,\n        0xc491798a08a2ad4f,\n        0xf5b5d7ec8acb58a3,\n        0x9991a6f3d6bf1766,\n        0xbff610b0cc6edd3f,\n        0xeff394dcff8a948f,\n        0x95f83d0a1fb69cd9,\n        0xbb764c4ca7a44410,\n        0xea53df5fd18d5514,\n        0x92746b9be2f8552c,\n        0xb7118682dbb66a77,\n        0xe4d5e82392a40515,\n        0x8f05b1163ba6832d,\n        0xb2c71d5bca9023f8,\n        0xdf78e4b2bd342cf7,\n        0x8bab8eefb6409c1a,\n        0xae9672aba3d0c321,\n        0xda3c0f568cc4f3e9,\n        0x8865899617fb1871,\n        0xaa7eebfb9df9de8e,\n        0xd51ea6fa85785631,\n        0x8533285c936b35df,\n        0xa67ff273b8460357,\n        0xd01fef10a657842c,\n        0x8213f56a67f6b29c,\n        0xa298f2c501f45f43,\n        0xcb3f2f7642717713,\n        0xfe0efb53d30dd4d8,\n        0x9ec95d1463e8a507,\n        0xc67bb4597ce2ce49,\n        0xf81aa16fdc1b81db,\n        0x9b10a4e5e9913129,\n        0xc1d4ce1f63f57d73,\n        0xf24a01a73cf2dcd0,\n        0x976e41088617ca02,\n        0xbd49d14aa79dbc82,\n        0xec9c459d51852ba3,\n        0x93e1ab8252f33b46,\n        0xb8da1662e7b00a17,\n        0xe7109bfba19c0c9d,\n        0x906a617d450187e2,\n        0xb484f9dc9641e9db,\n        0xe1a63853bbd26451,\n        0x8d07e33455637eb3,\n        0xb049dc016abc5e60,\n        0xdc5c5301c56b75f7,\n        0x89b9b3e11b6329bb,\n        0xac2820d9623bf429,\n        0xd732290fbacaf134,\n        0x867f59a9d4bed6c0,\n        0xa81f301449ee8c70,\n        0xd226fc195c6a2f8c,\n        0x83585d8fd9c25db8,\n        0xa42e74f3d032f526,\n        0xcd3a1230c43fb26f,\n        0x80444b5e7aa7cf85,\n        0xa0555e361951c367,\n        0xc86ab5c39fa63441,\n        0xfa856334878fc151,\n        0x9c935e00d4b9d8d2,\n        0xc3b8358109e84f07,\n        0xf4a642e14c6262c9,\n        0x98e7e9cccfbd7dbe,\n        0xbf21e44003acdd2d,\n        0xeeea5d5004981478,\n        0x95527a5202df0ccb,\n        0xbaa718e68396cffe,\n        0xe950df20247c83fd,\n        0x91d28b7416cdd27e,\n    ],\n    [\n        -1077,\n        -1073,\n        -1070,\n        -1067,\n        -1063,\n        -1060,\n        -1057,\n        -1053,\n        -1050,\n        -1047,\n        -1043,\n        -1040,\n        -1037,\n        -1034,\n        -1030,\n        -1027,\n        -1024,\n        -1020,\n        -1017,\n        -1014,\n        -1010,\n        -1007,\n        -1004,\n        -1000,\n        -997,\n        -994,\n        -990,\n        -987,\n        -984,\n        -980,\n        -977,\n        -974,\n        -970,\n        -967,\n        -964,\n        -960,\n        -957,\n        -954,\n        -950,\n        -947,\n        -944,\n        -940,\n        -937,\n        -934,\n        -931,\n        -927,\n        -924,\n        -921,\n        -917,\n        -914,\n        -911,\n        -907,\n        -904,\n        -901,\n        -897,\n        -894,\n        -891,\n        -887,\n        -884,\n        -881,\n        -877,\n        -874,\n        -871,\n        -867,\n        -864,\n        -861,\n        -857,\n        -854,\n        -851,\n        -847,\n        -844,\n        -841,\n        -838,\n        -834,\n        -831,\n        -828,\n        -824,\n        -821,\n        -818,\n        -814,\n        -811,\n        -808,\n        -804,\n        -801,\n        -798,\n        -794,\n        -791,\n        -788,\n        -784,\n        -781,\n        -778,\n        -774,\n        -771,\n        -768,\n        -764,\n        -761,\n        -758,\n        -754,\n        -751,\n        -748,\n        -744,\n        -741,\n        -738,\n        -735,\n        -731,\n        -728,\n        -725,\n        -721,\n        -718,\n        -715,\n        -711,\n        -708,\n        -705,\n        -701,\n        -698,\n        -695,\n        -691,\n        -688,\n        -685,\n        -681,\n        -678,\n        -675,\n        -671,\n        -668,\n        -665,\n        -661,\n        -658,\n        -655,\n        -651,\n        -648,\n        -645,\n        -642,\n        -638,\n        -635,\n        -632,\n        -628,\n        -625,\n        -622,\n        -618,\n        -615,\n        -612,\n        -608,\n        -605,\n        -602,\n        -598,\n        -595,\n        -592,\n        -588,\n        -585,\n        -582,\n        -578,\n        -575,\n        -572,\n        -568,\n        -565,\n        -562,\n        -558,\n        -555,\n        -552,\n        -549,\n        -545,\n        -542,\n        -539,\n        -535,\n        -532,\n        -529,\n        -525,\n        -522,\n        -519,\n        -515,\n        -512,\n        -509,\n        -505,\n        -502,\n        -499,\n        -495,\n        -492,\n        -489,\n        -485,\n        -482,\n        -479,\n        -475,\n        -472,\n        -469,\n        -465,\n        -462,\n        -459,\n        -455,\n        -452,\n        -449,\n        -446,\n        -442,\n        -439,\n        -436,\n        -432,\n        -429,\n        -426,\n        -422,\n        -419,\n        -416,\n        -412,\n        -409,\n        -406,\n        -402,\n        -399,\n        -396,\n        -392,\n        -389,\n        -386,\n        -382,\n        -379,\n        -376,\n        -372,\n        -369,\n        -366,\n        -362,\n        -359,\n        -356,\n        -353,\n        -349,\n        -346,\n        -343,\n        -339,\n        -336,\n        -333,\n        -329,\n        -326,\n        -323,\n        -319,\n        -316,\n        -313,\n        -309,\n        -306,\n        -303,\n        -299,\n        -296,\n        -293,\n        -289,\n        -286,\n        -283,\n        -279,\n        -276,\n        -273,\n        -269,\n        -266,\n        -263,\n        -259,\n        -256,\n        -253,\n        -250,\n        -246,\n        -243,\n        -240,\n        -236,\n        -233,\n        -230,\n        -226,\n        -223,\n        -220,\n        -216,\n        -213,\n        -210,\n        -206,\n        -203,\n        -200,\n        -196,\n        -193,\n        -190,\n        -186,\n        -183,\n        -180,\n        -176,\n        -173,\n        -170,\n        -166,\n        -163,\n        -160,\n        -157,\n        -153,\n        -150,\n        -147,\n        -143,\n        -140,\n        -137,\n        -133,\n        -130,\n        -127,\n        -123,\n        -120,\n        -117,\n        -113,\n        -110,\n        -107,\n        -103,\n        -100,\n        -97,\n        -93,\n        -90,\n        -87,\n        -83,\n        -80,\n        -77,\n        -73,\n        -70,\n        -67,\n        -63,\n        -60,\n        -57,\n        -54,\n        -50,\n        -47,\n        -44,\n        -40,\n        -37,\n        -34,\n        -30,\n        -27,\n        -24,\n        -20,\n        -17,\n        -14,\n        -10,\n        -7,\n        -4,\n        0,\n        3,\n        6,\n        10,\n        13,\n        16,\n        20,\n        23,\n        26,\n        30,\n        33,\n        36,\n        39,\n        43,\n        46,\n        49,\n        53,\n        56,\n        59,\n        63,\n        66,\n        69,\n        73,\n        76,\n        79,\n        83,\n        86,\n        89,\n        93,\n        96,\n        99,\n        103,\n        106,\n        109,\n        113,\n        116,\n        119,\n        123,\n        126,\n        129,\n        132,\n        136,\n        139,\n        142,\n        146,\n        149,\n        152,\n        156,\n        159,\n        162,\n        166,\n        169,\n        172,\n        176,\n        179,\n        182,\n        186,\n        189,\n        192,\n        196,\n        199,\n        202,\n        206,\n        209,\n        212,\n        216,\n        219,\n        222,\n        226,\n        229,\n        232,\n        235,\n        239,\n        242,\n        245,\n        249,\n        252,\n        255,\n        259,\n        262,\n        265,\n        269,\n        272,\n        275,\n        279,\n        282,\n        285,\n        289,\n        292,\n        295,\n        299,\n        302,\n        305,\n        309,\n        312,\n        315,\n        319,\n        322,\n        325,\n        328,\n        332,\n        335,\n        338,\n        342,\n        345,\n        348,\n        352,\n        355,\n        358,\n        362,\n        365,\n        368,\n        372,\n        375,\n        378,\n        382,\n        385,\n        388,\n        392,\n        395,\n        398,\n        402,\n        405,\n        408,\n        412,\n        415,\n        418,\n        422,\n        425,\n        428,\n        431,\n        435,\n        438,\n        441,\n        445,\n        448,\n        451,\n        455,\n        458,\n        461,\n        465,\n        468,\n        471,\n        475,\n        478,\n        481,\n        485,\n        488,\n        491,\n        495,\n        498,\n        501,\n        505,\n        508,\n        511,\n        515,\n        518,\n        521,\n        524,\n        528,\n        531,\n        534,\n        538,\n        541,\n        544,\n        548,\n        551,\n        554,\n        558,\n        561,\n        564,\n        568,\n        571,\n        574,\n        578,\n        581,\n        584,\n        588,\n        591,\n        594,\n        598,\n        601,\n        604,\n        608,\n        611,\n        614,\n        617,\n        621,\n        624,\n        627,\n        631,\n        634,\n        637,\n        641,\n        644,\n        647,\n        651,\n        654,\n        657,\n        661,\n        664,\n        667,\n        671,\n        674,\n        677,\n        681,\n        684,\n        687,\n        691,\n        694,\n        697,\n        701,\n        704,\n        707,\n        711,\n        714,\n        717,\n        720,\n        724,\n        727,\n        730,\n        734,\n        737,\n        740,\n        744,\n        747,\n        750,\n        754,\n        757,\n        760,\n        764,\n        767,\n        770,\n        774,\n        777,\n        780,\n        784,\n        787,\n        790,\n        794,\n        797,\n        800,\n        804,\n        807,\n        810,\n        813,\n        817,\n        820,\n        823,\n        827,\n        830,\n        833,\n        837,\n        840,\n        843,\n        847,\n        850,\n        853,\n        857,\n        860,\n        863,\n        867,\n        870,\n        873,\n        877,\n        880,\n        883,\n        887,\n        890,\n        893,\n        897,\n        900,\n        903,\n        907,\n        910,\n        913,\n        916,\n        920,\n        923,\n        926,\n        930,\n        933,\n        936,\n        940,\n        943,\n        946,\n        950,\n    ],\n);\n\n#[rustfmt::skip]\npub const F32_SHORT_POWERS: [f32; 11] = [\n    1e0,\n    1e1,\n    1e2,\n    1e3,\n    1e4,\n    1e5,\n    1e6,\n    1e7,\n    1e8,\n    1e9,\n    1e10,\n];\n\n#[rustfmt::skip]\npub const F64_SHORT_POWERS: [f64; 23] = [\n    1e0,\n    1e1,\n    1e2,\n    1e3,\n    1e4,\n    1e5,\n    1e6,\n    1e7,\n    1e8,\n    1e9,\n    1e10,\n    1e11,\n    1e12,\n    1e13,\n    1e14,\n    1e15,\n    1e16,\n    1e17,\n    1e18,\n    1e19,\n    1e20,\n    1e21,\n    1e22,\n];\n"],[2882,"//! Custom arbitrary-precision number (bignum) implementation.\n//!\n//! This is designed to avoid the heap allocation at expense of stack memory.\n//! The most used bignum type, `Big32x40`, is limited by 32 × 40 = 1,280 bits\n//! and will take at most 160 bytes of stack memory. This is more than enough\n//! for round-tripping all possible finite `f64` values.\n//!\n//! In principle it is possible to have multiple bignum types for different\n//! inputs, but we don't do so to avoid the code bloat. Each bignum is still\n//! tracked for the actual usages, so it normally doesn't matter.\n\n// This module is only for dec2flt and flt2dec, and only public because of coretests.\n// It is not intended to ever be stabilized.\n#![doc(hidden)]\n#![unstable(\n    feature = \"core_private_bignum\",\n    reason = \"internal routines only exposed for testing\",\n    issue = \"none\"\n)]\n#![macro_use]\n\nuse crate::intrinsics;\n\n/// Arithmetic operations required by bignums.\npub trait FullOps: Sized {\n    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n    /// where `W` is the number of bits in `Self`.\n    fn full_add(self, other: Self, carry: bool) -> (bool /* carry */, Self);\n\n    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`,\n    /// where `W` is the number of bits in `Self`.\n    fn full_mul(self, other: Self, carry: Self) -> (Self /* carry */, Self);\n\n    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`,\n    /// where `W` is the number of bits in `Self`.\n    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self /* carry */, Self);\n\n    /// Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n    /// and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n    fn full_div_rem(self, other: Self, borrow: Self)\n    -> (Self /* quotient */, Self /* remainder */);\n}\n\nmacro_rules! impl_full_ops {\n    ($($ty:ty: add($addfn:path), mul/div($bigty:ident);)*) => (\n        $(\n            impl FullOps for $ty {\n                fn full_add(self, other: $ty, carry: bool) -> (bool, $ty) {\n                    // This cannot overflow; the output is between `0` and `2 * 2^nbits - 1`.\n                    // FIXME: will LLVM optimize this into ADC or similar?\n                    let (v, carry1) = intrinsics::add_with_overflow(self, other);\n                    let (v, carry2) = intrinsics::add_with_overflow(v, if carry {1} else {0});\n                    (carry1 || carry2, v)\n                }\n\n                fn full_mul(self, other: $ty, carry: $ty) -> ($ty, $ty) {\n                    // This cannot overflow;\n                    // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n                    // FIXME: will LLVM optimize this into ADC or similar?\n                    let v = (self as $bigty) * (other as $bigty) + (carry as $bigty);\n                    ((v >> <$ty>::BITS) as $ty, v as $ty)\n                }\n\n                fn full_mul_add(self, other: $ty, other2: $ty, carry: $ty) -> ($ty, $ty) {\n                    // This cannot overflow;\n                    // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n                    let v = (self as $bigty) * (other as $bigty) + (other2 as $bigty) +\n                            (carry as $bigty);\n                    ((v >> <$ty>::BITS) as $ty, v as $ty)\n                }\n\n                fn full_div_rem(self, other: $ty, borrow: $ty) -> ($ty, $ty) {\n                    debug_assert!(borrow < other);\n                    // This cannot overflow; the output is between `0` and `other * (2^nbits - 1)`.\n                    let lhs = ((borrow as $bigty) << <$ty>::BITS) | (self as $bigty);\n                    let rhs = other as $bigty;\n                    ((lhs / rhs) as $ty, (lhs % rhs) as $ty)\n                }\n            }\n        )*\n    )\n}\n\nimpl_full_ops! {\n    u8:  add(intrinsics::u8_add_with_overflow),  mul/div(u16);\n    u16: add(intrinsics::u16_add_with_overflow), mul/div(u32);\n    u32: add(intrinsics::u32_add_with_overflow), mul/div(u64);\n    // See RFC #521 for enabling this.\n    // u64: add(intrinsics::u64_add_with_overflow), mul/div(u128);\n}\n\n/// Table of powers of 5 representable in digits. Specifically, the largest {u8, u16, u32} value\n/// that's a power of five, plus the corresponding exponent. Used in `mul_pow5`.\nconst SMALL_POW5: [(u64, usize); 3] = [(125, 3), (15625, 6), (1_220_703_125, 13)];\n\nmacro_rules! define_bignum {\n    ($name:ident: type=$ty:ty, n=$n:expr) => {\n        /// Stack-allocated arbitrary-precision (up to certain limit) integer.\n        ///\n        /// This is backed by a fixed-size array of given type (\"digit\").\n        /// While the array is not very large (normally some hundred bytes),\n        /// copying it recklessly may result in the performance hit.\n        /// Thus this is intentionally not `Copy`.\n        ///\n        /// All operations available to bignums panic in the case of overflows.\n        /// The caller is responsible to use large enough bignum types.\n        pub struct $name {\n            /// One plus the offset to the maximum \"digit\" in use.\n            /// This does not decrease, so be aware of the computation order.\n            /// `base[size..]` should be zero.\n            size: usize,\n            /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n            /// where `W` is the number of bits in the digit type.\n            base: [$ty; $n],\n        }\n\n        impl $name {\n            /// Makes a bignum from one digit.\n            pub fn from_small(v: $ty) -> $name {\n                let mut base = [0; $n];\n                base[0] = v;\n                $name { size: 1, base }\n            }\n\n            /// Makes a bignum from `u64` value.\n            pub fn from_u64(mut v: u64) -> $name {\n                let mut base = [0; $n];\n                let mut sz = 0;\n                while v > 0 {\n                    base[sz] = v as $ty;\n                    v >>= <$ty>::BITS;\n                    sz += 1;\n                }\n                $name { size: sz, base }\n            }\n\n            /// Returns the internal digits as a slice `[a, b, c, ...]` such that the numeric\n            /// value is `a + b * 2^W + c * 2^(2W) + ...` where `W` is the number of bits in\n            /// the digit type.\n            pub fn digits(&self) -> &[$ty] {\n                &self.base[..self.size]\n            }\n\n            /// Returns the `i`-th bit where bit 0 is the least significant one.\n            /// In other words, the bit with weight `2^i`.\n            pub fn get_bit(&self, i: usize) -> u8 {\n                let digitbits = <$ty>::BITS as usize;\n                let d = i / digitbits;\n                let b = i % digitbits;\n                ((self.base[d] >> b) & 1) as u8\n            }\n\n            /// Returns `true` if the bignum is zero.\n            pub fn is_zero(&self) -> bool {\n                self.digits().iter().all(|&v| v == 0)\n            }\n\n            /// Returns the number of bits necessary to represent this value. Note that zero\n            /// is considered to need 0 bits.\n            pub fn bit_length(&self) -> usize {\n                // Skip over the most significant digits which are zero.\n                let digits = self.digits();\n                let zeros = digits.iter().rev().take_while(|&&x| x == 0).count();\n                let end = digits.len() - zeros;\n                let nonzero = &digits[..end];\n\n                if nonzero.is_empty() {\n                    // There are no non-zero digits, i.e., the number is zero.\n                    return 0;\n                }\n                // This could be optimized with leading_zeros() and bit shifts, but that's\n                // probably not worth the hassle.\n                let digitbits = <$ty>::BITS as usize;\n                let mut i = nonzero.len() * digitbits - 1;\n                while self.get_bit(i) == 0 {\n                    i -= 1;\n                }\n                i + 1\n            }\n\n            /// Adds `other` to itself and returns its own mutable reference.\n            pub fn add<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n                use crate::cmp;\n                use crate::iter;\n                use crate::num::bignum::FullOps;\n\n                let mut sz = cmp::max(self.size, other.size);\n                let mut carry = false;\n                for (a, b) in iter::zip(&mut self.base[..sz], &other.base[..sz]) {\n                    let (c, v) = (*a).full_add(*b, carry);\n                    *a = v;\n                    carry = c;\n                }\n                if carry {\n                    self.base[sz] = 1;\n                    sz += 1;\n                }\n                self.size = sz;\n                self\n            }\n\n            pub fn add_small(&mut self, other: $ty) -> &mut $name {\n                use crate::num::bignum::FullOps;\n\n                let (mut carry, v) = self.base[0].full_add(other, false);\n                self.base[0] = v;\n                let mut i = 1;\n                while carry {\n                    let (c, v) = self.base[i].full_add(0, carry);\n                    self.base[i] = v;\n                    carry = c;\n                    i += 1;\n                }\n                if i > self.size {\n                    self.size = i;\n                }\n                self\n            }\n\n            /// Subtracts `other` from itself and returns its own mutable reference.\n            pub fn sub<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n                use crate::cmp;\n                use crate::iter;\n                use crate::num::bignum::FullOps;\n\n                let sz = cmp::max(self.size, other.size);\n                let mut noborrow = true;\n                for (a, b) in iter::zip(&mut self.base[..sz], &other.base[..sz]) {\n                    let (c, v) = (*a).full_add(!*b, noborrow);\n                    *a = v;\n                    noborrow = c;\n                }\n                assert!(noborrow);\n                self.size = sz;\n                self\n            }\n\n            /// Multiplies itself by a digit-sized `other` and returns its own\n            /// mutable reference.\n            pub fn mul_small(&mut self, other: $ty) -> &mut $name {\n                use crate::num::bignum::FullOps;\n\n                let mut sz = self.size;\n                let mut carry = 0;\n                for a in &mut self.base[..sz] {\n                    let (c, v) = (*a).full_mul(other, carry);\n                    *a = v;\n                    carry = c;\n                }\n                if carry > 0 {\n                    self.base[sz] = carry;\n                    sz += 1;\n                }\n                self.size = sz;\n                self\n            }\n\n            /// Multiplies itself by `2^bits` and returns its own mutable reference.\n            pub fn mul_pow2(&mut self, bits: usize) -> &mut $name {\n                let digitbits = <$ty>::BITS as usize;\n                let digits = bits / digitbits;\n                let bits = bits % digitbits;\n\n                assert!(digits < $n);\n                debug_assert!(self.base[$n - digits..].iter().all(|&v| v == 0));\n                debug_assert!(bits == 0 || (self.base[$n - digits - 1] >> (digitbits - bits)) == 0);\n\n                // shift by `digits * digitbits` bits\n                for i in (0..self.size).rev() {\n                    self.base[i + digits] = self.base[i];\n                }\n                for i in 0..digits {\n                    self.base[i] = 0;\n                }\n\n                // shift by `bits` bits\n                let mut sz = self.size + digits;\n                if bits > 0 {\n                    let last = sz;\n                    let overflow = self.base[last - 1] >> (digitbits - bits);\n                    if overflow > 0 {\n                        self.base[last] = overflow;\n                        sz += 1;\n                    }\n                    for i in (digits + 1..last).rev() {\n                        self.base[i] =\n                            (self.base[i] << bits) | (self.base[i - 1] >> (digitbits - bits));\n                    }\n                    self.base[digits] <<= bits;\n                    // self.base[..digits] is zero, no need to shift\n                }\n\n                self.size = sz;\n                self\n            }\n\n            /// Multiplies itself by `5^e` and returns its own mutable reference.\n            pub fn mul_pow5(&mut self, mut e: usize) -> &mut $name {\n                use crate::mem;\n                use crate::num::bignum::SMALL_POW5;\n\n                // There are exactly n trailing zeros on 2^n, and the only relevant digit sizes\n                // are consecutive powers of two, so this is well suited index for the table.\n                let table_index = mem::size_of::<$ty>().trailing_zeros() as usize;\n                let (small_power, small_e) = SMALL_POW5[table_index];\n                let small_power = small_power as $ty;\n\n                // Multiply with the largest single-digit power as long as possible ...\n                while e >= small_e {\n                    self.mul_small(small_power);\n                    e -= small_e;\n                }\n\n                // ... then finish off the remainder.\n                let mut rest_power = 1;\n                for _ in 0..e {\n                    rest_power *= 5;\n                }\n                self.mul_small(rest_power);\n\n                self\n            }\n\n            /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n            /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n            /// and returns its own mutable reference.\n            pub fn mul_digits<'a>(&'a mut self, other: &[$ty]) -> &'a mut $name {\n                // the internal routine. works best when aa.len() <= bb.len().\n                fn mul_inner(ret: &mut [$ty; $n], aa: &[$ty], bb: &[$ty]) -> usize {\n                    use crate::num::bignum::FullOps;\n\n                    let mut retsz = 0;\n                    for (i, &a) in aa.iter().enumerate() {\n                        if a == 0 {\n                            continue;\n                        }\n                        let mut sz = bb.len();\n                        let mut carry = 0;\n                        for (j, &b) in bb.iter().enumerate() {\n                            let (c, v) = a.full_mul_add(b, ret[i + j], carry);\n                            ret[i + j] = v;\n                            carry = c;\n                        }\n                        if carry > 0 {\n                            ret[i + sz] = carry;\n                            sz += 1;\n                        }\n                        if retsz < i + sz {\n                            retsz = i + sz;\n                        }\n                    }\n                    retsz\n                }\n\n                let mut ret = [0; $n];\n                let retsz = if self.size < other.len() {\n                    mul_inner(&mut ret, &self.digits(), other)\n                } else {\n                    mul_inner(&mut ret, other, &self.digits())\n                };\n                self.base = ret;\n                self.size = retsz;\n                self\n            }\n\n            /// Divides itself by a digit-sized `other` and returns its own\n            /// mutable reference *and* the remainder.\n            pub fn div_rem_small(&mut self, other: $ty) -> (&mut $name, $ty) {\n                use crate::num::bignum::FullOps;\n\n                assert!(other > 0);\n\n                let sz = self.size;\n                let mut borrow = 0;\n                for a in self.base[..sz].iter_mut().rev() {\n                    let (q, r) = (*a).full_div_rem(other, borrow);\n                    *a = q;\n                    borrow = r;\n                }\n                (self, borrow)\n            }\n\n            /// Divide self by another bignum, overwriting `q` with the quotient and `r` with the\n            /// remainder.\n            pub fn div_rem(&self, d: &$name, q: &mut $name, r: &mut $name) {\n                // Stupid slow base-2 long division taken from\n                // https://en.wikipedia.org/wiki/Division_algorithm\n                // FIXME use a greater base ($ty) for the long division.\n                assert!(!d.is_zero());\n                let digitbits = <$ty>::BITS as usize;\n                for digit in &mut q.base[..] {\n                    *digit = 0;\n                }\n                for digit in &mut r.base[..] {\n                    *digit = 0;\n                }\n                r.size = d.size;\n                q.size = 1;\n                let mut q_is_zero = true;\n                let end = self.bit_length();\n                for i in (0..end).rev() {\n                    r.mul_pow2(1);\n                    r.base[0] |= self.get_bit(i) as $ty;\n                    if &*r >= d {\n                        r.sub(d);\n                        // Set bit `i` of q to 1.\n                        let digit_idx = i / digitbits;\n                        let bit_idx = i % digitbits;\n                        if q_is_zero {\n                            q.size = digit_idx + 1;\n                            q_is_zero = false;\n                        }\n                        q.base[digit_idx] |= 1 << bit_idx;\n                    }\n                }\n                debug_assert!(q.base[q.size..].iter().all(|&d| d == 0));\n                debug_assert!(r.base[r.size..].iter().all(|&d| d == 0));\n            }\n        }\n\n        impl crate::cmp::PartialEq for $name {\n            fn eq(&self, other: &$name) -> bool {\n                self.base[..] == other.base[..]\n            }\n        }\n\n        impl crate::cmp::Eq for $name {}\n\n        impl crate::cmp::PartialOrd for $name {\n            fn partial_cmp(&self, other: &$name) -> crate::option::Option<crate::cmp::Ordering> {\n                crate::option::Option::Some(self.cmp(other))\n            }\n        }\n\n        impl crate::cmp::Ord for $name {\n            fn cmp(&self, other: &$name) -> crate::cmp::Ordering {\n                use crate::cmp::max;\n                let sz = max(self.size, other.size);\n                let lhs = self.base[..sz].iter().cloned().rev();\n                let rhs = other.base[..sz].iter().cloned().rev();\n                lhs.cmp(rhs)\n            }\n        }\n\n        impl crate::clone::Clone for $name {\n            fn clone(&self) -> Self {\n                Self { size: self.size, base: self.base }\n            }\n        }\n\n        impl crate::fmt::Debug for $name {\n            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                let sz = if self.size < 1 { 1 } else { self.size };\n                let digitlen = <$ty>::BITS as usize / 4;\n\n                write!(f, \"{:#x}\", self.base[sz - 1])?;\n                for &v in self.base[..sz - 1].iter().rev() {\n                    write!(f, \"_{:01$x}\", v, digitlen)?;\n                }\n                crate::result::Result::Ok(())\n            }\n        }\n    };\n}\n\n/// The digit type for `Big32x40`.\npub type Digit32 = u32;\n\ndefine_bignum!(Big32x40: type=Digit32, n=40);\n\n// this one is used for testing only.\n#[doc(hidden)]\npub mod tests {\n    define_bignum!(Big8x3: type=u8, n=3);\n}\n"],[2883,"//! Constants specific to the `f64` double-precision floating point type.\n//!\n//! *[See also the `f64` primitive type][f64].*\n//!\n//! Mathematically significant numbers are provided in the `consts` sub-module.\n//!\n//! For the constants defined directly in this module\n//! (as distinct from those defined in the `consts` sub-module),\n//! new code should instead use the associated constants\n//! defined directly on the `f64` type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::convert::FloatToInt;\n#[cfg(not(test))]\nuse crate::intrinsics;\nuse crate::mem;\nuse crate::num::FpCategory;\n\n/// The radix or base of the internal representation of `f64`.\n/// Use [`f64::RADIX`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let r = std::f64::RADIX;\n///\n/// // intended way\n/// let r = f64::RADIX;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `RADIX` associated constant on `f64`\")]\npub const RADIX: u32 = f64::RADIX;\n\n/// Number of significant digits in base 2.\n/// Use [`f64::MANTISSA_DIGITS`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let d = std::f64::MANTISSA_DIGITS;\n///\n/// // intended way\n/// let d = f64::MANTISSA_DIGITS;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MANTISSA_DIGITS` associated constant on `f64`\"\n)]\npub const MANTISSA_DIGITS: u32 = f64::MANTISSA_DIGITS;\n\n/// Approximate number of significant digits in base 10.\n/// Use [`f64::DIGITS`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let d = std::f64::DIGITS;\n///\n/// // intended way\n/// let d = f64::DIGITS;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `DIGITS` associated constant on `f64`\")]\npub const DIGITS: u32 = f64::DIGITS;\n\n/// [Machine epsilon] value for `f64`.\n/// Use [`f64::EPSILON`] instead.\n///\n/// This is the difference between `1.0` and the next larger representable number.\n///\n/// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let e = std::f64::EPSILON;\n///\n/// // intended way\n/// let e = f64::EPSILON;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `EPSILON` associated constant on `f64`\"\n)]\npub const EPSILON: f64 = f64::EPSILON;\n\n/// Smallest finite `f64` value.\n/// Use [`f64::MIN`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let min = std::f64::MIN;\n///\n/// // intended way\n/// let min = f64::MIN;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MIN` associated constant on `f64`\")]\npub const MIN: f64 = f64::MIN;\n\n/// Smallest positive normal `f64` value.\n/// Use [`f64::MIN_POSITIVE`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let min = std::f64::MIN_POSITIVE;\n///\n/// // intended way\n/// let min = f64::MIN_POSITIVE;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MIN_POSITIVE` associated constant on `f64`\"\n)]\npub const MIN_POSITIVE: f64 = f64::MIN_POSITIVE;\n\n/// Largest finite `f64` value.\n/// Use [`f64::MAX`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let max = std::f64::MAX;\n///\n/// // intended way\n/// let max = f64::MAX;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MAX` associated constant on `f64`\")]\npub const MAX: f64 = f64::MAX;\n\n/// One greater than the minimum possible normal power of 2 exponent.\n/// Use [`f64::MIN_EXP`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let min = std::f64::MIN_EXP;\n///\n/// // intended way\n/// let min = f64::MIN_EXP;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MIN_EXP` associated constant on `f64`\"\n)]\npub const MIN_EXP: i32 = f64::MIN_EXP;\n\n/// Maximum possible power of 2 exponent.\n/// Use [`f64::MAX_EXP`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let max = std::f64::MAX_EXP;\n///\n/// // intended way\n/// let max = f64::MAX_EXP;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MAX_EXP` associated constant on `f64`\"\n)]\npub const MAX_EXP: i32 = f64::MAX_EXP;\n\n/// Minimum possible normal power of 10 exponent.\n/// Use [`f64::MIN_10_EXP`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let min = std::f64::MIN_10_EXP;\n///\n/// // intended way\n/// let min = f64::MIN_10_EXP;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MIN_10_EXP` associated constant on `f64`\"\n)]\npub const MIN_10_EXP: i32 = f64::MIN_10_EXP;\n\n/// Maximum possible power of 10 exponent.\n/// Use [`f64::MAX_10_EXP`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let max = std::f64::MAX_10_EXP;\n///\n/// // intended way\n/// let max = f64::MAX_10_EXP;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MAX_10_EXP` associated constant on `f64`\"\n)]\npub const MAX_10_EXP: i32 = f64::MAX_10_EXP;\n\n/// Not a Number (NaN).\n/// Use [`f64::NAN`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let nan = std::f64::NAN;\n///\n/// // intended way\n/// let nan = f64::NAN;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `NAN` associated constant on `f64`\")]\npub const NAN: f64 = f64::NAN;\n\n/// Infinity (∞).\n/// Use [`f64::INFINITY`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let inf = std::f64::INFINITY;\n///\n/// // intended way\n/// let inf = f64::INFINITY;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `INFINITY` associated constant on `f64`\"\n)]\npub const INFINITY: f64 = f64::INFINITY;\n\n/// Negative infinity (−∞).\n/// Use [`f64::NEG_INFINITY`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let ninf = std::f64::NEG_INFINITY;\n///\n/// // intended way\n/// let ninf = f64::NEG_INFINITY;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `NEG_INFINITY` associated constant on `f64`\"\n)]\npub const NEG_INFINITY: f64 = f64::NEG_INFINITY;\n\n/// Basic mathematical constants.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod consts {\n    // FIXME: replace with mathematical constants from cmath.\n\n    /// Archimedes' constant (π)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const PI: f64 = 3.14159265358979323846264338327950288_f64;\n\n    /// The full circle constant (τ)\n    ///\n    /// Equal to 2π.\n    #[stable(feature = \"tau_constant\", since = \"1.47.0\")]\n    pub const TAU: f64 = 6.28318530717958647692528676655900577_f64;\n\n    /// π/2\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n\n    /// π/3\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n\n    /// π/4\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n\n    /// π/6\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n\n    /// π/8\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n\n    /// 1/π\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n\n    /// 2/π\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n\n    /// 2/sqrt(π)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_2_SQRT_PI: f64 = 1.12837916709551257389615890312154517_f64;\n\n    /// sqrt(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const SQRT_2: f64 = 1.41421356237309504880168872420969808_f64;\n\n    /// 1/sqrt(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_1_SQRT_2: f64 = 0.707106781186547524400844362104849039_f64;\n\n    /// Euler's number (e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const E: f64 = 2.71828182845904523536028747135266250_f64;\n\n    /// log<sub>2</sub>(10)\n    #[stable(feature = \"extra_log_consts\", since = \"1.43.0\")]\n    pub const LOG2_10: f64 = 3.32192809488736234787031942948939018_f64;\n\n    /// log<sub>2</sub>(e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n\n    /// log<sub>10</sub>(2)\n    #[stable(feature = \"extra_log_consts\", since = \"1.43.0\")]\n    pub const LOG10_2: f64 = 0.301029995663981195213738894724493027_f64;\n\n    /// log<sub>10</sub>(e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n\n    /// ln(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n\n    /// ln(10)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n}\n\n#[lang = \"f64\"]\n#[cfg(not(test))]\nimpl f64 {\n    /// The radix or base of the internal representation of `f64`.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const RADIX: u32 = 2;\n\n    /// Number of significant digits in base 2.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MANTISSA_DIGITS: u32 = 53;\n    /// Approximate number of significant digits in base 10.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const DIGITS: u32 = 15;\n\n    /// [Machine epsilon] value for `f64`.\n    ///\n    /// This is the difference between `1.0` and the next larger representable number.\n    ///\n    /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n\n    /// Smallest finite `f64` value.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MIN: f64 = -1.7976931348623157e+308_f64;\n    /// Smallest positive normal `f64` value.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MIN_POSITIVE: f64 = 2.2250738585072014e-308_f64;\n    /// Largest finite `f64` value.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MAX: f64 = 1.7976931348623157e+308_f64;\n\n    /// One greater than the minimum possible normal power of 2 exponent.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MIN_EXP: i32 = -1021;\n    /// Maximum possible power of 2 exponent.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MAX_EXP: i32 = 1024;\n\n    /// Minimum possible normal power of 10 exponent.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MIN_10_EXP: i32 = -307;\n    /// Maximum possible power of 10 exponent.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MAX_10_EXP: i32 = 308;\n\n    /// Not a Number (NaN).\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const NAN: f64 = 0.0_f64 / 0.0_f64;\n    /// Infinity (∞).\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const INFINITY: f64 = 1.0_f64 / 0.0_f64;\n    /// Negative infinity (−∞).\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64;\n\n    /// Returns `true` if this value is `NaN`.\n    ///\n    /// ```\n    /// let nan = f64::NAN;\n    /// let f = 7.0_f64;\n    ///\n    /// assert!(nan.is_nan());\n    /// assert!(!f.is_nan());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_nan(self) -> bool {\n        self != self\n    }\n\n    // FIXME(#50145): `abs` is publicly unavailable in libcore due to\n    // concerns about portability, so this implementation is for\n    // private use internally.\n    #[inline]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    const fn abs_private(self) -> f64 {\n        f64::from_bits(self.to_bits() & 0x7fff_ffff_ffff_ffff)\n    }\n\n    /// Returns `true` if this value is positive infinity or negative infinity, and\n    /// `false` otherwise.\n    ///\n    /// ```\n    /// let f = 7.0f64;\n    /// let inf = f64::INFINITY;\n    /// let neg_inf = f64::NEG_INFINITY;\n    /// let nan = f64::NAN;\n    ///\n    /// assert!(!f.is_infinite());\n    /// assert!(!nan.is_infinite());\n    ///\n    /// assert!(inf.is_infinite());\n    /// assert!(neg_inf.is_infinite());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_infinite(self) -> bool {\n        self.abs_private() == Self::INFINITY\n    }\n\n    /// Returns `true` if this number is neither infinite nor `NaN`.\n    ///\n    /// ```\n    /// let f = 7.0f64;\n    /// let inf: f64 = f64::INFINITY;\n    /// let neg_inf: f64 = f64::NEG_INFINITY;\n    /// let nan: f64 = f64::NAN;\n    ///\n    /// assert!(f.is_finite());\n    ///\n    /// assert!(!nan.is_finite());\n    /// assert!(!inf.is_finite());\n    /// assert!(!neg_inf.is_finite());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_finite(self) -> bool {\n        // There's no need to handle NaN separately: if self is NaN,\n        // the comparison is not true, exactly as desired.\n        self.abs_private() < Self::INFINITY\n    }\n\n    /// Returns `true` if the number is [subnormal].\n    ///\n    /// ```\n    /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308_f64\n    /// let max = f64::MAX;\n    /// let lower_than_min = 1.0e-308_f64;\n    /// let zero = 0.0_f64;\n    ///\n    /// assert!(!min.is_subnormal());\n    /// assert!(!max.is_subnormal());\n    ///\n    /// assert!(!zero.is_subnormal());\n    /// assert!(!f64::NAN.is_subnormal());\n    /// assert!(!f64::INFINITY.is_subnormal());\n    /// // Values between `0` and `min` are Subnormal.\n    /// assert!(lower_than_min.is_subnormal());\n    /// ```\n    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n    #[stable(feature = \"is_subnormal\", since = \"1.53.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_subnormal(self) -> bool {\n        matches!(self.classify(), FpCategory::Subnormal)\n    }\n\n    /// Returns `true` if the number is neither zero, infinite,\n    /// [subnormal], or `NaN`.\n    ///\n    /// ```\n    /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308f64\n    /// let max = f64::MAX;\n    /// let lower_than_min = 1.0e-308_f64;\n    /// let zero = 0.0f64;\n    ///\n    /// assert!(min.is_normal());\n    /// assert!(max.is_normal());\n    ///\n    /// assert!(!zero.is_normal());\n    /// assert!(!f64::NAN.is_normal());\n    /// assert!(!f64::INFINITY.is_normal());\n    /// // Values between `0` and `min` are Subnormal.\n    /// assert!(!lower_than_min.is_normal());\n    /// ```\n    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_normal(self) -> bool {\n        matches!(self.classify(), FpCategory::Normal)\n    }\n\n    /// Returns the floating point category of the number. If only one property\n    /// is going to be tested, it is generally faster to use the specific\n    /// predicate instead.\n    ///\n    /// ```\n    /// use std::num::FpCategory;\n    ///\n    /// let num = 12.4_f64;\n    /// let inf = f64::INFINITY;\n    ///\n    /// assert_eq!(num.classify(), FpCategory::Normal);\n    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    pub const fn classify(self) -> FpCategory {\n        const EXP_MASK: u64 = 0x7ff0000000000000;\n        const MAN_MASK: u64 = 0x000fffffffffffff;\n\n        let bits = self.to_bits();\n        match (bits & MAN_MASK, bits & EXP_MASK) {\n            (0, 0) => FpCategory::Zero,\n            (_, 0) => FpCategory::Subnormal,\n            (0, EXP_MASK) => FpCategory::Infinite,\n            (_, EXP_MASK) => FpCategory::Nan,\n            _ => FpCategory::Normal,\n        }\n    }\n\n    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n    /// positive sign bit and positive infinity.\n    ///\n    /// ```\n    /// let f = 7.0_f64;\n    /// let g = -7.0_f64;\n    ///\n    /// assert!(f.is_sign_positive());\n    /// assert!(!g.is_sign_positive());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_sign_positive(self) -> bool {\n        !self.is_sign_negative()\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n    #[inline]\n    #[doc(hidden)]\n    pub fn is_positive(self) -> bool {\n        self.is_sign_positive()\n    }\n\n    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n    /// negative sign bit and negative infinity.\n    ///\n    /// ```\n    /// let f = 7.0_f64;\n    /// let g = -7.0_f64;\n    ///\n    /// assert!(!f.is_sign_negative());\n    /// assert!(g.is_sign_negative());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_sign_negative(self) -> bool {\n        self.to_bits() & 0x8000_0000_0000_0000 != 0\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n    #[inline]\n    #[doc(hidden)]\n    pub fn is_negative(self) -> bool {\n        self.is_sign_negative()\n    }\n\n    /// Takes the reciprocal (inverse) of a number, `1/x`.\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn recip(self) -> f64 {\n        1.0 / self\n    }\n\n    /// Converts radians to degrees.\n    ///\n    /// ```\n    /// let angle = std::f64::consts::PI;\n    ///\n    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_degrees(self) -> f64 {\n        // The division here is correctly rounded with respect to the true\n        // value of 180/π. (This differs from f32, where a constant must be\n        // used to ensure a correctly rounded result.)\n        self * (180.0f64 / consts::PI)\n    }\n\n    /// Converts degrees to radians.\n    ///\n    /// ```\n    /// let angle = 180.0_f64;\n    ///\n    /// let abs_difference = (angle.to_radians() - std::f64::consts::PI).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_radians(self) -> f64 {\n        let value: f64 = consts::PI;\n        self * (value / 180.0)\n    }\n\n    /// Returns the maximum of the two numbers.\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let y = 2.0_f64;\n    ///\n    /// assert_eq!(x.max(y), y);\n    /// ```\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn max(self, other: f64) -> f64 {\n        intrinsics::maxnumf64(self, other)\n    }\n\n    /// Returns the minimum of the two numbers.\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let y = 2.0_f64;\n    ///\n    /// assert_eq!(x.min(y), x);\n    /// ```\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn min(self, other: f64) -> f64 {\n        intrinsics::minnumf64(self, other)\n    }\n\n    /// Rounds toward zero and converts to any primitive integer type,\n    /// assuming that the value is finite and fits in that type.\n    ///\n    /// ```\n    /// let value = 4.6_f64;\n    /// let rounded = unsafe { value.to_int_unchecked::<u16>() };\n    /// assert_eq!(rounded, 4);\n    ///\n    /// let value = -128.9_f64;\n    /// let rounded = unsafe { value.to_int_unchecked::<i8>() };\n    /// assert_eq!(rounded, i8::MIN);\n    /// ```\n    ///\n    /// # Safety\n    ///\n    /// The value must:\n    ///\n    /// * Not be `NaN`\n    /// * Not be infinite\n    /// * Be representable in the return type `Int`, after truncating off its fractional part\n    #[stable(feature = \"float_approx_unchecked_to\", since = \"1.44.0\")]\n    #[inline]\n    pub unsafe fn to_int_unchecked<Int>(self) -> Int\n    where\n        Self: FloatToInt<Int>,\n    {\n        // SAFETY: the caller must uphold the safety contract for\n        // `FloatToInt::to_int_unchecked`.\n        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }\n    }\n\n    /// Raw transmutation to `u64`.\n    ///\n    /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms.\n    ///\n    /// See [`from_bits`](Self::from_bits) for some discussion of the\n    /// portability of this operation (there are almost no issues).\n    ///\n    /// Note that this function is distinct from `as` casting, which attempts to\n    /// preserve the *numeric* value, and not the bitwise value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!((1f64).to_bits() != 1f64 as u64); // to_bits() is not casting!\n    /// assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n    ///\n    /// ```\n    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn to_bits(self) -> u64 {\n        // SAFETY: `u64` is a plain old datatype so we can always transmute to it\n        unsafe { mem::transmute(self) }\n    }\n\n    /// Raw transmutation from `u64`.\n    ///\n    /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n    /// It turns out this is incredibly portable, for two reasons:\n    ///\n    /// * Floats and Ints have the same endianness on all supported platforms.\n    /// * IEEE-754 very precisely specifies the bit layout of floats.\n    ///\n    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n    /// (notably x86 and ARM) picked the interpretation that was ultimately\n    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n    ///\n    /// Rather than trying to preserve signaling-ness cross-platform, this\n    /// implementation favors preserving the exact bits. This means that\n    /// any payloads encoded in NaNs will be preserved even if the result of\n    /// this method is sent over the network from an x86 machine to a MIPS one.\n    ///\n    /// If the results of this method are only manipulated by the same\n    /// architecture that produced them, then there is no portability concern.\n    ///\n    /// If the input isn't NaN, then there is no portability concern.\n    ///\n    /// If you don't care about signaling-ness (very likely), then there is no\n    /// portability concern.\n    ///\n    /// Note that this function is distinct from `as` casting, which attempts to\n    /// preserve the *numeric* value, and not the bitwise value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = f64::from_bits(0x4029000000000000);\n    /// assert_eq!(v, 12.5);\n    /// ```\n    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn from_bits(v: u64) -> Self {\n        // SAFETY: `u64` is a plain old datatype so we can always transmute from it\n        // It turns out the safety issues with sNaN were overblown! Hooray!\n        unsafe { mem::transmute(v) }\n    }\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// big-endian (network) byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f64.to_be_bytes();\n    /// assert_eq!(bytes, [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn to_be_bytes(self) -> [u8; 8] {\n        self.to_bits().to_be_bytes()\n    }\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// little-endian byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f64.to_le_bytes();\n    /// assert_eq!(bytes, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn to_le_bytes(self) -> [u8; 8] {\n        self.to_bits().to_le_bytes()\n    }\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// native byte order.\n    ///\n    /// As the target platform's native endianness is used, portable code\n    /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.\n    ///\n    /// [`to_be_bytes`]: f64::to_be_bytes\n    /// [`to_le_bytes`]: f64::to_le_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f64.to_ne_bytes();\n    /// assert_eq!(\n    ///     bytes,\n    ///     if cfg!(target_endian = \"big\") {\n    ///         [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n    ///     } else {\n    ///         [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n    ///     }\n    /// );\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn to_ne_bytes(self) -> [u8; 8] {\n        self.to_bits().to_ne_bytes()\n    }\n\n    /// Create a floating point value from its representation as a byte array in big endian.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f64::from_be_bytes([0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn from_be_bytes(bytes: [u8; 8]) -> Self {\n        Self::from_bits(u64::from_be_bytes(bytes))\n    }\n\n    /// Create a floating point value from its representation as a byte array in little endian.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f64::from_le_bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn from_le_bytes(bytes: [u8; 8]) -> Self {\n        Self::from_bits(u64::from_le_bytes(bytes))\n    }\n\n    /// Create a floating point value from its representation as a byte array in native endian.\n    ///\n    /// As the target platform's native endianness is used, portable code\n    /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n    /// appropriate instead.\n    ///\n    /// [`from_be_bytes`]: f64::from_be_bytes\n    /// [`from_le_bytes`]: f64::from_le_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f64::from_ne_bytes(if cfg!(target_endian = \"big\") {\n    ///     [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n    /// } else {\n    ///     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n    /// });\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn from_ne_bytes(bytes: [u8; 8]) -> Self {\n        Self::from_bits(u64::from_ne_bytes(bytes))\n    }\n\n    /// Returns an ordering between self and other values.\n    /// Unlike the standard partial comparison between floating point numbers,\n    /// this comparison always produces an ordering in accordance to\n    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n    /// floating point standard. The values are ordered in following order:\n    /// - Negative quiet NaN\n    /// - Negative signaling NaN\n    /// - Negative infinity\n    /// - Negative numbers\n    /// - Negative subnormal numbers\n    /// - Negative zero\n    /// - Positive zero\n    /// - Positive subnormal numbers\n    /// - Positive numbers\n    /// - Positive infinity\n    /// - Positive signaling NaN\n    /// - Positive quiet NaN\n    ///\n    /// Note that this function does not always agree with the [`PartialOrd`]\n    /// and [`PartialEq`] implementations of `f64`. In particular, they regard\n    /// negative and positive zero as equal, while `total_cmp` doesn't.\n    ///\n    /// # Example\n    /// ```\n    /// #![feature(total_cmp)]\n    /// struct GoodBoy {\n    ///     name: String,\n    ///     weight: f64,\n    /// }\n    ///\n    /// let mut bois = vec![\n    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f64::INFINITY },\n    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f64::NAN },\n    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n    /// ];\n    ///\n    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n    /// # assert!(bois.into_iter().map(|b| b.weight)\n    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f64::INFINITY, f64::NAN].iter())\n    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n    /// ```\n    #[unstable(feature = \"total_cmp\", issue = \"72599\")]\n    #[inline]\n    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n        let mut left = self.to_bits() as i64;\n        let mut right = other.to_bits() as i64;\n\n        // In case of negatives, flip all the bits except the sign\n        // to achieve a similar layout as two's complement integers\n        //\n        // Why does this work? IEEE 754 floats consist of three fields:\n        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n        // fields as a whole have the property that their bitwise order is\n        // equal to the numeric magnitude where the magnitude is defined.\n        // The magnitude is not normally defined on NaN values, but\n        // IEEE 754 totalOrder defines the NaN values also to follow the\n        // bitwise order. This leads to order explained in the doc comment.\n        // However, the representation of magnitude is the same for negative\n        // and positive numbers – only the sign bit is different.\n        // To easily compare the floats as signed integers, we need to\n        // flip the exponent and mantissa bits in case of negative numbers.\n        // We effectively convert the numbers to \"two's complement\" form.\n        //\n        // To do the flipping, we construct a mask and XOR against it.\n        // We branchlessly calculate an \"all-ones except for the sign bit\"\n        // mask from negative-signed values: right shifting sign-extends\n        // the integer, so we \"fill\" the mask with sign bits, and then\n        // convert to unsigned to push one more zero bit.\n        // On positive values, the mask is all zeros, so it's a no-op.\n        left ^= (((left >> 63) as u64) >> 1) as i64;\n        right ^= (((right >> 63) as u64) >> 1) as i64;\n\n        left.cmp(&right)\n    }\n\n    /// Restrict a value to a certain interval unless it is NaN.\n    ///\n    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n    /// less than `min`. Otherwise this returns `self`.\n    ///\n    /// Note that this function returns NaN if the initial value was NaN as\n    /// well.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `min > max`, `min` is NaN, or `max` is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!((-3.0f64).clamp(-2.0, 1.0) == -2.0);\n    /// assert!((0.0f64).clamp(-2.0, 1.0) == 0.0);\n    /// assert!((2.0f64).clamp(-2.0, 1.0) == 1.0);\n    /// assert!((f64::NAN).clamp(-2.0, 1.0).is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"clamp\", since = \"1.50.0\")]\n    #[inline]\n    pub fn clamp(self, min: f64, max: f64) -> f64 {\n        assert!(min <= max);\n        let mut x = self;\n        if x < min {\n            x = min;\n        }\n        if x > max {\n            x = max;\n        }\n        x\n    }\n}\n"],[2884,"//! Decodes a floating-point value into individual parts and error ranges.\n\nuse crate::num::dec2flt::rawfp::RawFloat;\nuse crate::num::FpCategory;\n\n/// Decoded unsigned finite value, such that:\n///\n/// - The original value equals to `mant * 2^exp`.\n///\n/// - Any number from `(mant - minus) * 2^exp` to `(mant + plus) * 2^exp` will\n///   round to the original value. The range is inclusive only when\n///   `inclusive` is `true`.\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub struct Decoded {\n    /// The scaled mantissa.\n    pub mant: u64,\n    /// The lower error range.\n    pub minus: u64,\n    /// The upper error range.\n    pub plus: u64,\n    /// The shared exponent in base 2.\n    pub exp: i16,\n    /// True when the error range is inclusive.\n    ///\n    /// In IEEE 754, this is true when the original mantissa was even.\n    pub inclusive: bool,\n}\n\n/// Decoded unsigned value.\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub enum FullDecoded {\n    /// Not-a-number.\n    Nan,\n    /// Infinities, either positive or negative.\n    Infinite,\n    /// Zero, either positive or negative.\n    Zero,\n    /// Finite numbers with further decoded fields.\n    Finite(Decoded),\n}\n\n/// A floating point type which can be `decode`d.\npub trait DecodableFloat: RawFloat + Copy {\n    /// The minimum positive normalized value.\n    fn min_pos_norm_value() -> Self;\n}\n\nimpl DecodableFloat for f32 {\n    fn min_pos_norm_value() -> Self {\n        f32::MIN_POSITIVE\n    }\n}\n\nimpl DecodableFloat for f64 {\n    fn min_pos_norm_value() -> Self {\n        f64::MIN_POSITIVE\n    }\n}\n\n/// Returns a sign (true when negative) and `FullDecoded` value\n/// from given floating point number.\npub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n    let (mant, exp, sign) = v.integer_decode();\n    let even = (mant & 1) == 0;\n    let decoded = match v.classify() {\n        FpCategory::Nan => FullDecoded::Nan,\n        FpCategory::Infinite => FullDecoded::Infinite,\n        FpCategory::Zero => FullDecoded::Zero,\n        FpCategory::Subnormal => {\n            // neighbors: (mant - 2, exp) -- (mant, exp) -- (mant + 2, exp)\n            // Float::integer_decode always preserves the exponent,\n            // so the mantissa is scaled for subnormals.\n            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1, exp, inclusive: even })\n        }\n        FpCategory::Normal => {\n            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n            if mant == minnorm.0 {\n                // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                // where maxmant = minnormmant * 2 - 1\n                FullDecoded::Finite(Decoded {\n                    mant: mant << 2,\n                    minus: 1,\n                    plus: 2,\n                    exp: exp - 2,\n                    inclusive: even,\n                })\n            } else {\n                // neighbors: (mant - 1, exp) -- (mant, exp) -- (mant + 1, exp)\n                FullDecoded::Finite(Decoded {\n                    mant: mant << 1,\n                    minus: 1,\n                    plus: 1,\n                    exp: exp - 1,\n                    inclusive: even,\n                })\n            }\n        }\n    };\n    (sign < 0, decoded)\n}\n"],[2885,"//! The exponent estimator.\n\n/// Finds `k_0` such that `10^(k_0-1) < mant * 2^exp <= 10^(k_0+1)`.\n///\n/// This is used to approximate `k = ceil(log_10 (mant * 2^exp))`;\n/// the true `k` is either `k_0` or `k_0+1`.\n#[doc(hidden)]\npub fn estimate_scaling_factor(mant: u64, exp: i16) -> i16 {\n    // 2^(nbits-1) < mant <= 2^nbits if mant > 0\n    let nbits = 64 - (mant - 1).leading_zeros() as i64;\n    // 1292913986 = floor(2^32 * log_10 2)\n    // therefore this always underestimates (or is exact), but not much.\n    (((nbits + exp as i64) * 1292913986) >> 32) as i16\n}\n"],[2886,"//! Almost direct (but slightly optimized) Rust translation of Figure 3 of \"Printing\n//! Floating-Point Numbers Quickly and Accurately\"[^1].\n//!\n//! [^1]: Burger, R. G. and Dybvig, R. K. 1996. Printing floating-point numbers\n//!   quickly and accurately. SIGPLAN Not. 31, 5 (May. 1996), 108-116.\n\nuse crate::cmp::Ordering;\nuse crate::mem::MaybeUninit;\n\nuse crate::num::bignum::Big32x40 as Big;\nuse crate::num::bignum::Digit32 as Digit;\nuse crate::num::flt2dec::estimator::estimate_scaling_factor;\nuse crate::num::flt2dec::{round_up, Decoded, MAX_SIG_DIGITS};\n\nstatic POW10: [Digit; 10] =\n    [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];\nstatic TWOPOW10: [Digit; 10] =\n    [2, 20, 200, 2000, 20000, 200000, 2000000, 20000000, 200000000, 2000000000];\n\n// precalculated arrays of `Digit`s for 10^(2^n)\nstatic POW10TO16: [Digit; 2] = [0x6fc10000, 0x2386f2];\nstatic POW10TO32: [Digit; 4] = [0, 0x85acef81, 0x2d6d415b, 0x4ee];\nstatic POW10TO64: [Digit; 7] = [0, 0, 0xbf6a1f01, 0x6e38ed64, 0xdaa797ed, 0xe93ff9f4, 0x184f03];\nstatic POW10TO128: [Digit; 14] = [\n    0, 0, 0, 0, 0x2e953e01, 0x3df9909, 0xf1538fd, 0x2374e42f, 0xd3cff5ec, 0xc404dc08, 0xbccdb0da,\n    0xa6337f19, 0xe91f2603, 0x24e,\n];\nstatic POW10TO256: [Digit; 27] = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6, 0xcf4a6e70,\n    0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e, 0xcc5573c0, 0x65f9ef17,\n    0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7,\n];\n\n#[doc(hidden)]\npub fn mul_pow10(x: &mut Big, n: usize) -> &mut Big {\n    debug_assert!(n < 512);\n    if n & 7 != 0 {\n        x.mul_small(POW10[n & 7]);\n    }\n    if n & 8 != 0 {\n        x.mul_small(POW10[8]);\n    }\n    if n & 16 != 0 {\n        x.mul_digits(&POW10TO16);\n    }\n    if n & 32 != 0 {\n        x.mul_digits(&POW10TO32);\n    }\n    if n & 64 != 0 {\n        x.mul_digits(&POW10TO64);\n    }\n    if n & 128 != 0 {\n        x.mul_digits(&POW10TO128);\n    }\n    if n & 256 != 0 {\n        x.mul_digits(&POW10TO256);\n    }\n    x\n}\n\nfn div_2pow10(x: &mut Big, mut n: usize) -> &mut Big {\n    let largest = POW10.len() - 1;\n    while n > largest {\n        x.div_rem_small(POW10[largest]);\n        n -= largest;\n    }\n    x.div_rem_small(TWOPOW10[n]);\n    x\n}\n\n// only usable when `x < 16 * scale`; `scaleN` should be `scale.mul_small(N)`\nfn div_rem_upto_16<'a>(\n    x: &'a mut Big,\n    scale: &Big,\n    scale2: &Big,\n    scale4: &Big,\n    scale8: &Big,\n) -> (u8, &'a mut Big) {\n    let mut d = 0;\n    if *x >= *scale8 {\n        x.sub(scale8);\n        d += 8;\n    }\n    if *x >= *scale4 {\n        x.sub(scale4);\n        d += 4;\n    }\n    if *x >= *scale2 {\n        x.sub(scale2);\n        d += 2;\n    }\n    if *x >= *scale {\n        x.sub(scale);\n        d += 1;\n    }\n    debug_assert!(*x < *scale);\n    (d, x)\n}\n\n/// The shortest mode implementation for Dragon.\npub fn format_shortest<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n    // the number `v` to format is known to be:\n    // - equal to `mant * 2^exp`;\n    // - preceded by `(mant - 2 * minus) * 2^exp` in the original type; and\n    // - followed by `(mant + 2 * plus) * 2^exp` in the original type.\n    //\n    // obviously, `minus` and `plus` cannot be zero. (for infinities, we use out-of-range values.)\n    // also we assume that at least one digit is generated, i.e., `mant` cannot be zero too.\n    //\n    // this also means that any number between `low = (mant - minus) * 2^exp` and\n    // `high = (mant + plus) * 2^exp` will map to this exact floating point number,\n    // with bounds included when the original mantissa was even (i.e., `!mant_was_odd`).\n\n    assert!(d.mant > 0);\n    assert!(d.minus > 0);\n    assert!(d.plus > 0);\n    assert!(d.mant.checked_add(d.plus).is_some());\n    assert!(d.mant.checked_sub(d.minus).is_some());\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n\n    // `a.cmp(&b) < rounding` is `if d.inclusive {a <= b} else {a < b}`\n    let rounding = if d.inclusive { Ordering::Greater } else { Ordering::Equal };\n\n    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < high <= 10^(k_0+1)`.\n    // the tight bound `k` satisfying `10^(k-1) < high <= 10^k` is calculated later.\n    let mut k = estimate_scaling_factor(d.mant + d.plus, d.exp);\n\n    // convert `{mant, plus, minus} * 2^exp` into the fractional form so that:\n    // - `v = mant / scale`\n    // - `low = (mant - minus) / scale`\n    // - `high = (mant + plus) / scale`\n    let mut mant = Big::from_u64(d.mant);\n    let mut minus = Big::from_u64(d.minus);\n    let mut plus = Big::from_u64(d.plus);\n    let mut scale = Big::from_small(1);\n    if d.exp < 0 {\n        scale.mul_pow2(-d.exp as usize);\n    } else {\n        mant.mul_pow2(d.exp as usize);\n        minus.mul_pow2(d.exp as usize);\n        plus.mul_pow2(d.exp as usize);\n    }\n\n    // divide `mant` by `10^k`. now `scale / 10 < mant + plus <= scale * 10`.\n    if k >= 0 {\n        mul_pow10(&mut scale, k as usize);\n    } else {\n        mul_pow10(&mut mant, -k as usize);\n        mul_pow10(&mut minus, -k as usize);\n        mul_pow10(&mut plus, -k as usize);\n    }\n\n    // fixup when `mant + plus > scale` (or `>=`).\n    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n    // now `scale < mant + plus <= scale * 10` and we are ready to generate digits.\n    //\n    // note that `d[0]` *can* be zero, when `scale - plus < mant < scale`.\n    // in this case rounding-up condition (`up` below) will be triggered immediately.\n    if scale.cmp(mant.clone().add(&plus)) < rounding {\n        // equivalent to scaling `scale` by 10\n        k += 1;\n    } else {\n        mant.mul_small(10);\n        minus.mul_small(10);\n        plus.mul_small(10);\n    }\n\n    // cache `(2, 4, 8) * scale` for digit generation.\n    let mut scale2 = scale.clone();\n    scale2.mul_pow2(1);\n    let mut scale4 = scale.clone();\n    scale4.mul_pow2(2);\n    let mut scale8 = scale.clone();\n    scale8.mul_pow2(3);\n\n    let mut down;\n    let mut up;\n    let mut i = 0;\n    loop {\n        // invariants, where `d[0..n-1]` are digits generated so far:\n        // - `v = mant / scale * 10^(k-n-1) + d[0..n-1] * 10^(k-n)`\n        // - `v - low = minus / scale * 10^(k-n-1)`\n        // - `high - v = plus / scale * 10^(k-n-1)`\n        // - `(mant + plus) / scale <= 10` (thus `mant / scale < 10`)\n        // where `d[i..j]` is a shorthand for `d[i] * 10^(j-i) + ... + d[j-1] * 10 + d[j]`.\n\n        // generate one digit: `d[n] = floor(mant / scale) < 10`.\n        let (d, _) = div_rem_upto_16(&mut mant, &scale, &scale2, &scale4, &scale8);\n        debug_assert!(d < 10);\n        buf[i] = MaybeUninit::new(b'0' + d);\n        i += 1;\n\n        // this is a simplified description of the modified Dragon algorithm.\n        // many intermediate derivations and completeness arguments are omitted for convenience.\n        //\n        // start with modified invariants, as we've updated `n`:\n        // - `v = mant / scale * 10^(k-n) + d[0..n-1] * 10^(k-n)`\n        // - `v - low = minus / scale * 10^(k-n)`\n        // - `high - v = plus / scale * 10^(k-n)`\n        //\n        // assume that `d[0..n-1]` is the shortest representation between `low` and `high`,\n        // i.e., `d[0..n-1]` satisfies both of the following but `d[0..n-2]` doesn't:\n        // - `low < d[0..n-1] * 10^(k-n) < high` (bijectivity: digits round to `v`); and\n        // - `abs(v / 10^(k-n) - d[0..n-1]) <= 1/2` (the last digit is correct).\n        //\n        // the second condition simplifies to `2 * mant <= scale`.\n        // solving invariants in terms of `mant`, `low` and `high` yields\n        // a simpler version of the first condition: `-plus < mant < minus`.\n        // since `-plus < 0 <= mant`, we have the correct shortest representation\n        // when `mant < minus` and `2 * mant <= scale`.\n        // (the former becomes `mant <= minus` when the original mantissa is even.)\n        //\n        // when the second doesn't hold (`2 * mant > scale`), we need to increase the last digit.\n        // this is enough for restoring that condition: we already know that\n        // the digit generation guarantees `0 <= v / 10^(k-n) - d[0..n-1] < 1`.\n        // in this case, the first condition becomes `-plus < mant - scale < minus`.\n        // since `mant < scale` after the generation, we have `scale < mant + plus`.\n        // (again, this becomes `scale <= mant + plus` when the original mantissa is even.)\n        //\n        // in short:\n        // - stop and round `down` (keep digits as is) when `mant < minus` (or `<=`).\n        // - stop and round `up` (increase the last digit) when `scale < mant + plus` (or `<=`).\n        // - keep generating otherwise.\n        down = mant.cmp(&minus) < rounding;\n        up = scale.cmp(mant.clone().add(&plus)) < rounding;\n        if down || up {\n            break;\n        } // we have the shortest representation, proceed to the rounding\n\n        // restore the invariants.\n        // this makes the algorithm always terminating: `minus` and `plus` always increases,\n        // but `mant` is clipped modulo `scale` and `scale` is fixed.\n        mant.mul_small(10);\n        minus.mul_small(10);\n        plus.mul_small(10);\n    }\n\n    // rounding up happens when\n    // i) only the rounding-up condition was triggered, or\n    // ii) both conditions were triggered and tie breaking prefers rounding up.\n    if up && (!down || *mant.mul_pow2(1) >= scale) {\n        // if rounding up changes the length, the exponent should also change.\n        // it seems that this condition is very hard to satisfy (possibly impossible),\n        // but we are just being safe and consistent here.\n        // SAFETY: we initialized that memory above.\n        if let Some(c) = round_up(unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..i]) }) {\n            buf[i] = MaybeUninit::new(c);\n            i += 1;\n            k += 1;\n        }\n    }\n\n    // SAFETY: we initialized that memory above.\n    (unsafe { MaybeUninit::slice_assume_init_ref(&buf[..i]) }, k)\n}\n\n/// The exact and fixed mode implementation for Dragon.\npub fn format_exact<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n    limit: i16,\n) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n    assert!(d.mant > 0);\n    assert!(d.minus > 0);\n    assert!(d.plus > 0);\n    assert!(d.mant.checked_add(d.plus).is_some());\n    assert!(d.mant.checked_sub(d.minus).is_some());\n\n    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < v <= 10^(k_0+1)`.\n    let mut k = estimate_scaling_factor(d.mant, d.exp);\n\n    // `v = mant / scale`.\n    let mut mant = Big::from_u64(d.mant);\n    let mut scale = Big::from_small(1);\n    if d.exp < 0 {\n        scale.mul_pow2(-d.exp as usize);\n    } else {\n        mant.mul_pow2(d.exp as usize);\n    }\n\n    // divide `mant` by `10^k`. now `scale / 10 < mant <= scale * 10`.\n    if k >= 0 {\n        mul_pow10(&mut scale, k as usize);\n    } else {\n        mul_pow10(&mut mant, -k as usize);\n    }\n\n    // fixup when `mant + plus >= scale`, where `plus / scale = 10^-buf.len() / 2`.\n    // in order to keep the fixed-size bignum, we actually use `mant + floor(plus) >= scale`.\n    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n    // again with the shortest algorithm, `d[0]` can be zero but will be eventually rounded up.\n    if *div_2pow10(&mut scale.clone(), buf.len()).add(&mant) >= scale {\n        // equivalent to scaling `scale` by 10\n        k += 1;\n    } else {\n        mant.mul_small(10);\n    }\n\n    // if we are working with the last-digit limitation, we need to shorten the buffer\n    // before the actual rendering in order to avoid double rounding.\n    // note that we have to enlarge the buffer again when rounding up happens!\n    let mut len = if k < limit {\n        // oops, we cannot even produce *one* digit.\n        // this is possible when, say, we've got something like 9.5 and it's being rounded to 10.\n        // we return an empty buffer, with an exception of the later rounding-up case\n        // which occurs when `k == limit` and has to produce exactly one digit.\n        0\n    } else if ((k as i32 - limit as i32) as usize) < buf.len() {\n        (k - limit) as usize\n    } else {\n        buf.len()\n    };\n\n    if len > 0 {\n        // cache `(2, 4, 8) * scale` for digit generation.\n        // (this can be expensive, so do not calculate them when the buffer is empty.)\n        let mut scale2 = scale.clone();\n        scale2.mul_pow2(1);\n        let mut scale4 = scale.clone();\n        scale4.mul_pow2(2);\n        let mut scale8 = scale.clone();\n        scale8.mul_pow2(3);\n\n        for i in 0..len {\n            if mant.is_zero() {\n                // following digits are all zeroes, we stop here\n                // do *not* try to perform rounding! rather, fill remaining digits.\n                for c in &mut buf[i..len] {\n                    *c = MaybeUninit::new(b'0');\n                }\n                // SAFETY: we initialized that memory above.\n                return (unsafe { MaybeUninit::slice_assume_init_ref(&buf[..len]) }, k);\n            }\n\n            let mut d = 0;\n            if mant >= scale8 {\n                mant.sub(&scale8);\n                d += 8;\n            }\n            if mant >= scale4 {\n                mant.sub(&scale4);\n                d += 4;\n            }\n            if mant >= scale2 {\n                mant.sub(&scale2);\n                d += 2;\n            }\n            if mant >= scale {\n                mant.sub(&scale);\n                d += 1;\n            }\n            debug_assert!(mant < scale);\n            debug_assert!(d < 10);\n            buf[i] = MaybeUninit::new(b'0' + d);\n            mant.mul_small(10);\n        }\n    }\n\n    // rounding up if we stop in the middle of digits\n    // if the following digits are exactly 5000..., check the prior digit and try to\n    // round to even (i.e., avoid rounding up when the prior digit is even).\n    let order = mant.cmp(scale.mul_small(5));\n    if order == Ordering::Greater\n        || (order == Ordering::Equal\n            // SAFETY: `buf[len-1]` is initialized.\n            && (len == 0 || unsafe { buf[len - 1].assume_init() } & 1 == 1))\n    {\n        // if rounding up changes the length, the exponent should also change.\n        // but we've been requested a fixed number of digits, so do not alter the buffer...\n        // SAFETY: we initialized that memory above.\n        if let Some(c) = round_up(unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..len]) }) {\n            // ...unless we've been requested the fixed precision instead.\n            // we also need to check that, if the original buffer was empty,\n            // the additional digit can only be added when `k == limit` (edge case).\n            k += 1;\n            if k > limit && len < buf.len() {\n                buf[len] = MaybeUninit::new(c);\n                len += 1;\n            }\n        }\n    }\n\n    // SAFETY: we initialized that memory above.\n    (unsafe { MaybeUninit::slice_assume_init_ref(&buf[..len]) }, k)\n}\n"],[2887,"//! Rust adaptation of the Grisu3 algorithm described in \"Printing Floating-Point Numbers Quickly\n//! and Accurately with Integers\"[^1]. It uses about 1KB of precomputed table, and in turn, it's\n//! very quick for most inputs.\n//!\n//! [^1]: Florian Loitsch. 2010. Printing floating-point numbers quickly and\n//!   accurately with integers. SIGPLAN Not. 45, 6 (June 2010), 233-243.\n\nuse crate::mem::MaybeUninit;\nuse crate::num::diy_float::Fp;\nuse crate::num::flt2dec::{round_up, Decoded, MAX_SIG_DIGITS};\n\n// see the comments in `format_shortest_opt` for the rationale.\n#[doc(hidden)]\npub const ALPHA: i16 = -60;\n#[doc(hidden)]\npub const GAMMA: i16 = -32;\n\n/*\n# the following Python code generates this table:\nfor i in xrange(-308, 333, 8):\n    if i >= 0: f = 10**i; e = 0\n    else: f = 2**(80-4*i) // 10**-i; e = 4 * i - 80\n    l = f.bit_length()\n    f = ((f << 64 >> (l-1)) + 1) >> 1; e += l - 64\n    print '    (%#018x, %5d, %4d),' % (f, e, i)\n*/\n\n#[doc(hidden)]\npub static CACHED_POW10: [(u64, i16, i16); 81] = [\n    // (f, e, k)\n    (0xe61acf033d1a45df, -1087, -308),\n    (0xab70fe17c79ac6ca, -1060, -300),\n    (0xff77b1fcbebcdc4f, -1034, -292),\n    (0xbe5691ef416bd60c, -1007, -284),\n    (0x8dd01fad907ffc3c, -980, -276),\n    (0xd3515c2831559a83, -954, -268),\n    (0x9d71ac8fada6c9b5, -927, -260),\n    (0xea9c227723ee8bcb, -901, -252),\n    (0xaecc49914078536d, -874, -244),\n    (0x823c12795db6ce57, -847, -236),\n    (0xc21094364dfb5637, -821, -228),\n    (0x9096ea6f3848984f, -794, -220),\n    (0xd77485cb25823ac7, -768, -212),\n    (0xa086cfcd97bf97f4, -741, -204),\n    (0xef340a98172aace5, -715, -196),\n    (0xb23867fb2a35b28e, -688, -188),\n    (0x84c8d4dfd2c63f3b, -661, -180),\n    (0xc5dd44271ad3cdba, -635, -172),\n    (0x936b9fcebb25c996, -608, -164),\n    (0xdbac6c247d62a584, -582, -156),\n    (0xa3ab66580d5fdaf6, -555, -148),\n    (0xf3e2f893dec3f126, -529, -140),\n    (0xb5b5ada8aaff80b8, -502, -132),\n    (0x87625f056c7c4a8b, -475, -124),\n    (0xc9bcff6034c13053, -449, -116),\n    (0x964e858c91ba2655, -422, -108),\n    (0xdff9772470297ebd, -396, -100),\n    (0xa6dfbd9fb8e5b88f, -369, -92),\n    (0xf8a95fcf88747d94, -343, -84),\n    (0xb94470938fa89bcf, -316, -76),\n    (0x8a08f0f8bf0f156b, -289, -68),\n    (0xcdb02555653131b6, -263, -60),\n    (0x993fe2c6d07b7fac, -236, -52),\n    (0xe45c10c42a2b3b06, -210, -44),\n    (0xaa242499697392d3, -183, -36),\n    (0xfd87b5f28300ca0e, -157, -28),\n    (0xbce5086492111aeb, -130, -20),\n    (0x8cbccc096f5088cc, -103, -12),\n    (0xd1b71758e219652c, -77, -4),\n    (0x9c40000000000000, -50, 4),\n    (0xe8d4a51000000000, -24, 12),\n    (0xad78ebc5ac620000, 3, 20),\n    (0x813f3978f8940984, 30, 28),\n    (0xc097ce7bc90715b3, 56, 36),\n    (0x8f7e32ce7bea5c70, 83, 44),\n    (0xd5d238a4abe98068, 109, 52),\n    (0x9f4f2726179a2245, 136, 60),\n    (0xed63a231d4c4fb27, 162, 68),\n    (0xb0de65388cc8ada8, 189, 76),\n    (0x83c7088e1aab65db, 216, 84),\n    (0xc45d1df942711d9a, 242, 92),\n    (0x924d692ca61be758, 269, 100),\n    (0xda01ee641a708dea, 295, 108),\n    (0xa26da3999aef774a, 322, 116),\n    (0xf209787bb47d6b85, 348, 124),\n    (0xb454e4a179dd1877, 375, 132),\n    (0x865b86925b9bc5c2, 402, 140),\n    (0xc83553c5c8965d3d, 428, 148),\n    (0x952ab45cfa97a0b3, 455, 156),\n    (0xde469fbd99a05fe3, 481, 164),\n    (0xa59bc234db398c25, 508, 172),\n    (0xf6c69a72a3989f5c, 534, 180),\n    (0xb7dcbf5354e9bece, 561, 188),\n    (0x88fcf317f22241e2, 588, 196),\n    (0xcc20ce9bd35c78a5, 614, 204),\n    (0x98165af37b2153df, 641, 212),\n    (0xe2a0b5dc971f303a, 667, 220),\n    (0xa8d9d1535ce3b396, 694, 228),\n    (0xfb9b7cd9a4a7443c, 720, 236),\n    (0xbb764c4ca7a44410, 747, 244),\n    (0x8bab8eefb6409c1a, 774, 252),\n    (0xd01fef10a657842c, 800, 260),\n    (0x9b10a4e5e9913129, 827, 268),\n    (0xe7109bfba19c0c9d, 853, 276),\n    (0xac2820d9623bf429, 880, 284),\n    (0x80444b5e7aa7cf85, 907, 292),\n    (0xbf21e44003acdd2d, 933, 300),\n    (0x8e679c2f5e44ff8f, 960, 308),\n    (0xd433179d9c8cb841, 986, 316),\n    (0x9e19db92b4e31ba9, 1013, 324),\n    (0xeb96bf6ebadf77d9, 1039, 332),\n];\n\n#[doc(hidden)]\npub const CACHED_POW10_FIRST_E: i16 = -1087;\n#[doc(hidden)]\npub const CACHED_POW10_LAST_E: i16 = 1039;\n\n#[doc(hidden)]\npub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) {\n    let offset = CACHED_POW10_FIRST_E as i32;\n    let range = (CACHED_POW10.len() as i32) - 1;\n    let domain = (CACHED_POW10_LAST_E - CACHED_POW10_FIRST_E) as i32;\n    let idx = ((gamma as i32) - offset) * range / domain;\n    let (f, e, k) = CACHED_POW10[idx as usize];\n    debug_assert!(alpha <= e && e <= gamma);\n    (k, Fp { f, e })\n}\n\n/// Given `x > 0`, returns `(k, 10^k)` such that `10^k <= x < 10^(k+1)`.\n#[doc(hidden)]\npub fn max_pow10_no_more_than(x: u32) -> (u8, u32) {\n    debug_assert!(x > 0);\n\n    const X9: u32 = 10_0000_0000;\n    const X8: u32 = 1_0000_0000;\n    const X7: u32 = 1000_0000;\n    const X6: u32 = 100_0000;\n    const X5: u32 = 10_0000;\n    const X4: u32 = 1_0000;\n    const X3: u32 = 1000;\n    const X2: u32 = 100;\n    const X1: u32 = 10;\n\n    if x < X4 {\n        if x < X2 {\n            if x < X1 { (0, 1) } else { (1, X1) }\n        } else {\n            if x < X3 { (2, X2) } else { (3, X3) }\n        }\n    } else {\n        if x < X6 {\n            if x < X5 { (4, X4) } else { (5, X5) }\n        } else if x < X8 {\n            if x < X7 { (6, X6) } else { (7, X7) }\n        } else {\n            if x < X9 { (8, X8) } else { (9, X9) }\n        }\n    }\n}\n\n/// The shortest mode implementation for Grisu.\n///\n/// It returns `None` when it would return an inexact representation otherwise.\npub fn format_shortest_opt<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n) -> Option<(/*digits*/ &'a [u8], /*exp*/ i16)> {\n    assert!(d.mant > 0);\n    assert!(d.minus > 0);\n    assert!(d.plus > 0);\n    assert!(d.mant.checked_add(d.plus).is_some());\n    assert!(d.mant.checked_sub(d.minus).is_some());\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n    assert!(d.mant + d.plus < (1 << 61)); // we need at least three bits of additional precision\n\n    // start with the normalized values with the shared exponent\n    let plus = Fp { f: d.mant + d.plus, e: d.exp }.normalize();\n    let minus = Fp { f: d.mant - d.minus, e: d.exp }.normalize_to(plus.e);\n    let v = Fp { f: d.mant, e: d.exp }.normalize_to(plus.e);\n\n    // find any `cached = 10^minusk` such that `ALPHA <= minusk + plus.e + 64 <= GAMMA`.\n    // since `plus` is normalized, this means `2^(62 + ALPHA) <= plus * cached < 2^(64 + GAMMA)`;\n    // given our choices of `ALPHA` and `GAMMA`, this puts `plus * cached` into `[4, 2^32)`.\n    //\n    // it is obviously desirable to maximize `GAMMA - ALPHA`,\n    // so that we don't need many cached powers of 10, but there are some considerations:\n    //\n    // 1. we want to keep `floor(plus * cached)` within `u32` since it needs a costly division.\n    //    (this is not really avoidable, remainder is required for accuracy estimation.)\n    // 2. the remainder of `floor(plus * cached)` repeatedly gets multiplied by 10,\n    //    and it should not overflow.\n    //\n    // the first gives `64 + GAMMA <= 32`, while the second gives `10 * 2^-ALPHA <= 2^64`;\n    // -60 and -32 is the maximal range with this constraint, and V8 also uses them.\n    let (minusk, cached) = cached_power(ALPHA - plus.e - 64, GAMMA - plus.e - 64);\n\n    // scale fps. this gives the maximal error of 1 ulp (proved from Theorem 5.1).\n    let plus = plus.mul(&cached);\n    let minus = minus.mul(&cached);\n    let v = v.mul(&cached);\n    debug_assert_eq!(plus.e, minus.e);\n    debug_assert_eq!(plus.e, v.e);\n\n    //         +- actual range of minus\n    //   | <---|---------------------- unsafe region --------------------------> |\n    //   |     |                                                                 |\n    //   |  |<--->|  | <--------------- safe region ---------------> |           |\n    //   |  |     |  |                                               |           |\n    //   |1 ulp|1 ulp|                 |1 ulp|1 ulp|                 |1 ulp|1 ulp|\n    //   |<--->|<--->|                 |<--->|<--->|                 |<--->|<--->|\n    //   |-----|-----|-------...-------|-----|-----|-------...-------|-----|-----|\n    //   |   minus   |                 |     v     |                 |   plus    |\n    // minus1     minus0           v - 1 ulp   v + 1 ulp           plus0       plus1\n    //\n    // above `minus`, `v` and `plus` are *quantized* approximations (error < 1 ulp).\n    // as we don't know the error is positive or negative, we use two approximations spaced equally\n    // and have the maximal error of 2 ulps.\n    //\n    // the \"unsafe region\" is a liberal interval which we initially generate.\n    // the \"safe region\" is a conservative interval which we only accept.\n    // we start with the correct repr within the unsafe region, and try to find the closest repr\n    // to `v` which is also within the safe region. if we can't, we give up.\n    let plus1 = plus.f + 1;\n    //  let plus0 = plus.f - 1; // only for explanation\n    //  let minus0 = minus.f + 1; // only for explanation\n    let minus1 = minus.f - 1;\n    let e = -plus.e as usize; // shared exponent\n\n    // divide `plus1` into integral and fractional parts.\n    // integral parts are guaranteed to fit in u32, since cached power guarantees `plus < 2^32`\n    // and normalized `plus.f` is always less than `2^64 - 2^4` due to the precision requirement.\n    let plus1int = (plus1 >> e) as u32;\n    let plus1frac = plus1 & ((1 << e) - 1);\n\n    // calculate the largest `10^max_kappa` no more than `plus1` (thus `plus1 < 10^(max_kappa+1)`).\n    // this is an upper bound of `kappa` below.\n    let (max_kappa, max_ten_kappa) = max_pow10_no_more_than(plus1int);\n\n    let mut i = 0;\n    let exp = max_kappa as i16 - minusk + 1;\n\n    // Theorem 6.2: if `k` is the greatest integer s.t. `0 <= y mod 10^k <= y - x`,\n    //              then `V = floor(y / 10^k) * 10^k` is in `[x, y]` and one of the shortest\n    //              representations (with the minimal number of significant digits) in that range.\n    //\n    // find the digit length `kappa` between `(minus1, plus1)` as per Theorem 6.2.\n    // Theorem 6.2 can be adopted to exclude `x` by requiring `y mod 10^k < y - x` instead.\n    // (e.g., `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n    // the algorithm relies on the later verification phase to exclude `y`.\n    let delta1 = plus1 - minus1;\n    //  let delta1int = (delta1 >> e) as usize; // only for explanation\n    let delta1frac = delta1 & ((1 << e) - 1);\n\n    // render integral parts, while checking for the accuracy at each step.\n    let mut kappa = max_kappa as i16;\n    let mut ten_kappa = max_ten_kappa; // 10^kappa\n    let mut remainder = plus1int; // digits yet to be rendered\n    loop {\n        // we always have at least one digit to render, as `plus1 >= 10^kappa`\n        // invariants:\n        // - `delta1int <= remainder < 10^(kappa+1)`\n        // - `plus1int = d[0..n-1] * 10^(kappa+1) + remainder`\n        //   (it follows that `remainder = plus1int % 10^(kappa+1)`)\n\n        // divide `remainder` by `10^kappa`. both are scaled by `2^-e`.\n        let q = remainder / ten_kappa;\n        let r = remainder % ten_kappa;\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        let plus1rem = ((r as u64) << e) + plus1frac; // == (plus1 % 10^kappa) * 2^e\n        if plus1rem < delta1 {\n            // `plus1 % 10^kappa < delta1 = plus1 - minus1`; we've found the correct `kappa`.\n            let ten_kappa = (ten_kappa as u64) << e; // scale 10^kappa back to the shared exponent\n            return round_and_weed(\n                // SAFETY: we initialized that memory above.\n                unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..i]) },\n                exp,\n                plus1rem,\n                delta1,\n                plus1 - v.f,\n                ten_kappa,\n                1,\n            );\n        }\n\n        // break the loop when we have rendered all integral digits.\n        // the exact number of digits is `max_kappa + 1` as `plus1 < 10^(max_kappa+1)`.\n        if i > max_kappa as usize {\n            debug_assert_eq!(ten_kappa, 1);\n            debug_assert_eq!(kappa, 0);\n            break;\n        }\n\n        // restore invariants\n        kappa -= 1;\n        ten_kappa /= 10;\n        remainder = r;\n    }\n\n    // render fractional parts, while checking for the accuracy at each step.\n    // this time we rely on repeated multiplications, as division will lose the precision.\n    let mut remainder = plus1frac;\n    let mut threshold = delta1frac;\n    let mut ulp = 1;\n    loop {\n        // the next digit should be significant as we've tested that before breaking out\n        // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n        // - `remainder < 2^e`\n        // - `plus1frac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n\n        remainder *= 10; // won't overflow, `2^e * 10 < 2^64`\n        threshold *= 10;\n        ulp *= 10;\n\n        // divide `remainder` by `10^kappa`.\n        // both are scaled by `2^e / 10^kappa`, so the latter is implicit here.\n        let q = remainder >> e;\n        let r = remainder & ((1 << e) - 1);\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        if r < threshold {\n            let ten_kappa = 1 << e; // implicit divisor\n            return round_and_weed(\n                // SAFETY: we initialized that memory above.\n                unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..i]) },\n                exp,\n                r,\n                threshold,\n                (plus1 - v.f) * ulp,\n                ten_kappa,\n                ulp,\n            );\n        }\n\n        // restore invariants\n        kappa -= 1;\n        remainder = r;\n    }\n\n    // we've generated all significant digits of `plus1`, but not sure if it's the optimal one.\n    // for example, if `minus1` is 3.14153... and `plus1` is 3.14158..., there are 5 different\n    // shortest representation from 3.14154 to 3.14158 but we only have the greatest one.\n    // we have to successively decrease the last digit and check if this is the optimal repr.\n    // there are at most 9 candidates (..1 to ..9), so this is fairly quick. (\"rounding\" phase)\n    //\n    // the function checks if this \"optimal\" repr is actually within the ulp ranges,\n    // and also, it is possible that the \"second-to-optimal\" repr can actually be optimal\n    // due to the rounding error. in either cases this returns `None`. (\"weeding\" phase)\n    //\n    // all arguments here are scaled by the common (but implicit) value `k`, so that:\n    // - `remainder = (plus1 % 10^kappa) * k`\n    // - `threshold = (plus1 - minus1) * k` (and also, `remainder < threshold`)\n    // - `plus1v = (plus1 - v) * k` (and also, `threshold > plus1v` from prior invariants)\n    // - `ten_kappa = 10^kappa * k`\n    // - `ulp = 2^-e * k`\n    fn round_and_weed(\n        buf: &mut [u8],\n        exp: i16,\n        remainder: u64,\n        threshold: u64,\n        plus1v: u64,\n        ten_kappa: u64,\n        ulp: u64,\n    ) -> Option<(&[u8], i16)> {\n        assert!(!buf.is_empty());\n\n        // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n        // the resulting representation should be the closest representation to both.\n        //\n        // here `plus1 - v` is used since calculations are done with respect to `plus1`\n        // in order to avoid overflow/underflow (hence the seemingly swapped names).\n        let plus1v_down = plus1v + ulp; // plus1 - (v - 1 ulp)\n        let plus1v_up = plus1v - ulp; // plus1 - (v + 1 ulp)\n\n        // decrease the last digit and stop at the closest representation to `v + 1 ulp`.\n        let mut plus1w = remainder; // plus1w(n) = plus1 - w(n)\n        {\n            let last = buf.last_mut().unwrap();\n\n            // we work with the approximated digits `w(n)`, which is initially equal to `plus1 -\n            // plus1 % 10^kappa`. after running the loop body `n` times, `w(n) = plus1 -\n            // plus1 % 10^kappa - n * 10^kappa`. we set `plus1w(n) = plus1 - w(n) =\n            // plus1 % 10^kappa + n * 10^kappa` (thus `remainder = plus1w(0)`) to simplify checks.\n            // note that `plus1w(n)` is always increasing.\n            //\n            // we have three conditions to terminate. any of them will make the loop unable to\n            // proceed, but we then have at least one valid representation known to be closest to\n            // `v + 1 ulp` anyway. we will denote them as TC1 through TC3 for brevity.\n            //\n            // TC1: `w(n) <= v + 1 ulp`, i.e., this is the last repr that can be the closest one.\n            // this is equivalent to `plus1 - w(n) = plus1w(n) >= plus1 - (v + 1 ulp) = plus1v_up`.\n            // combined with TC2 (which checks if `w(n+1)` is valid), this prevents the possible\n            // overflow on the calculation of `plus1w(n)`.\n            //\n            // TC2: `w(n+1) < minus1`, i.e., the next repr definitely does not round to `v`.\n            // this is equivalent to `plus1 - w(n) + 10^kappa = plus1w(n) + 10^kappa >\n            // plus1 - minus1 = threshold`. the left hand side can overflow, but we know\n            // `threshold > plus1v`, so if TC1 is false, `threshold - plus1w(n) >\n            // threshold - (plus1v - 1 ulp) > 1 ulp` and we can safely test if\n            // `threshold - plus1w(n) < 10^kappa` instead.\n            //\n            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e., the next repr is\n            // no closer to `v + 1 ulp` than the current repr. given `z(n) = plus1v_up - plus1w(n)`,\n            // this becomes `abs(z(n)) <= abs(z(n+1))`. again assuming that TC1 is false, we have\n            // `z(n) > 0`. we have two cases to consider:\n            //\n            // - when `z(n+1) >= 0`: TC3 becomes `z(n) <= z(n+1)`. as `plus1w(n)` is increasing,\n            //   `z(n)` should be decreasing and this is clearly false.\n            // - when `z(n+1) < 0`:\n            //   - TC3a: the precondition is `plus1v_up < plus1w(n) + 10^kappa`. assuming TC2 is\n            //     false, `threshold >= plus1w(n) + 10^kappa` so it cannot overflow.\n            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e., `plus1v_up - plus1w(n) >=\n            //     plus1w(n+1) - plus1v_up = plus1w(n) + 10^kappa - plus1v_up`. the negated TC1\n            //     gives `plus1v_up > plus1w(n)`, so it cannot overflow or underflow when\n            //     combined with TC3a.\n            //\n            // consequently, we should stop when `TC1 || TC2 || (TC3a && TC3b)`. the following is\n            // equal to its inverse, `!TC1 && !TC2 && (!TC3a || !TC3b)`.\n            while plus1w < plus1v_up\n                && threshold - plus1w >= ten_kappa\n                && (plus1w + ten_kappa < plus1v_up\n                    || plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up)\n            {\n                *last -= 1;\n                debug_assert!(*last > b'0'); // the shortest repr cannot end with `0`\n                plus1w += ten_kappa;\n            }\n        }\n\n        // check if this representation is also the closest representation to `v - 1 ulp`.\n        //\n        // this is simply same to the terminating conditions for `v + 1 ulp`, with all `plus1v_up`\n        // replaced by `plus1v_down` instead. overflow analysis equally holds.\n        if plus1w < plus1v_down\n            && threshold - plus1w >= ten_kappa\n            && (plus1w + ten_kappa < plus1v_down\n                || plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down)\n        {\n            return None;\n        }\n\n        // now we have the closest representation to `v` between `plus1` and `minus1`.\n        // this is too liberal, though, so we reject any `w(n)` not between `plus0` and `minus0`,\n        // i.e., `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n        // that `threshold = plus1 - minus1` and `plus1 - plus0 = minus0 - minus1 = 2 ulp`.\n        if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp { Some((buf, exp)) } else { None }\n    }\n}\n\n/// The shortest mode implementation for Grisu with Dragon fallback.\n///\n/// This should be used for most cases.\npub fn format_shortest<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n    use crate::num::flt2dec::strategy::dragon::format_shortest as fallback;\n    // SAFETY: The borrow checker is not smart enough to let us use `buf`\n    // in the second branch, so we launder the lifetime here. But we only re-use\n    // `buf` if `format_shortest_opt` returned `None` so this is okay.\n    match format_shortest_opt(d, unsafe { &mut *(buf as *mut _) }) {\n        Some(ret) => ret,\n        None => fallback(d, buf),\n    }\n}\n\n/// The exact and fixed mode implementation for Grisu.\n///\n/// It returns `None` when it would return an inexact representation otherwise.\npub fn format_exact_opt<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n    limit: i16,\n) -> Option<(/*digits*/ &'a [u8], /*exp*/ i16)> {\n    assert!(d.mant > 0);\n    assert!(d.mant < (1 << 61)); // we need at least three bits of additional precision\n    assert!(!buf.is_empty());\n\n    // normalize and scale `v`.\n    let v = Fp { f: d.mant, e: d.exp }.normalize();\n    let (minusk, cached) = cached_power(ALPHA - v.e - 64, GAMMA - v.e - 64);\n    let v = v.mul(&cached);\n\n    // divide `v` into integral and fractional parts.\n    let e = -v.e as usize;\n    let vint = (v.f >> e) as u32;\n    let vfrac = v.f & ((1 << e) - 1);\n\n    // both old `v` and new `v` (scaled by `10^-k`) has an error of < 1 ulp (Theorem 5.1).\n    // as we don't know the error is positive or negative, we use two approximations\n    // spaced equally and have the maximal error of 2 ulps (same to the shortest case).\n    //\n    // the goal is to find the exactly rounded series of digits that are common to\n    // both `v - 1 ulp` and `v + 1 ulp`, so that we are maximally confident.\n    // if this is not possible, we don't know which one is the correct output for `v`,\n    // so we give up and fall back.\n    //\n    // `err` is defined as `1 ulp * 2^e` here (same to the ulp in `vfrac`),\n    // and we will scale it whenever `v` gets scaled.\n    let mut err = 1;\n\n    // calculate the largest `10^max_kappa` no more than `v` (thus `v < 10^(max_kappa+1)`).\n    // this is an upper bound of `kappa` below.\n    let (max_kappa, max_ten_kappa) = max_pow10_no_more_than(vint);\n\n    let mut i = 0;\n    let exp = max_kappa as i16 - minusk + 1;\n\n    // if we are working with the last-digit limitation, we need to shorten the buffer\n    // before the actual rendering in order to avoid double rounding.\n    // note that we have to enlarge the buffer again when rounding up happens!\n    let len = if exp <= limit {\n        // oops, we cannot even produce *one* digit.\n        // this is possible when, say, we've got something like 9.5 and it's being rounded to 10.\n        //\n        // in principle we can immediately call `possibly_round` with an empty buffer,\n        // but scaling `max_ten_kappa << e` by 10 can result in overflow.\n        // thus we are being sloppy here and widen the error range by a factor of 10.\n        // this will increase the false negative rate, but only very, *very* slightly;\n        // it can only matter noticeably when the mantissa is bigger than 60 bits.\n        //\n        // SAFETY: `len=0`, so the obligation of having initialized this memory is trivial.\n        return unsafe {\n            possibly_round(buf, 0, exp, limit, v.f / 10, (max_ten_kappa as u64) << e, err << e)\n        };\n    } else if ((exp as i32 - limit as i32) as usize) < buf.len() {\n        (exp - limit) as usize\n    } else {\n        buf.len()\n    };\n    debug_assert!(len > 0);\n\n    // render integral parts.\n    // the error is entirely fractional, so we don't need to check it in this part.\n    let mut kappa = max_kappa as i16;\n    let mut ten_kappa = max_ten_kappa; // 10^kappa\n    let mut remainder = vint; // digits yet to be rendered\n    loop {\n        // we always have at least one digit to render\n        // invariants:\n        // - `remainder < 10^(kappa+1)`\n        // - `vint = d[0..n-1] * 10^(kappa+1) + remainder`\n        //   (it follows that `remainder = vint % 10^(kappa+1)`)\n\n        // divide `remainder` by `10^kappa`. both are scaled by `2^-e`.\n        let q = remainder / ten_kappa;\n        let r = remainder % ten_kappa;\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        // is the buffer full? run the rounding pass with the remainder.\n        if i == len {\n            let vrem = ((r as u64) << e) + vfrac; // == (v % 10^kappa) * 2^e\n            // SAFETY: we have initialized `len` many bytes.\n            return unsafe {\n                possibly_round(buf, len, exp, limit, vrem, (ten_kappa as u64) << e, err << e)\n            };\n        }\n\n        // break the loop when we have rendered all integral digits.\n        // the exact number of digits is `max_kappa + 1` as `plus1 < 10^(max_kappa+1)`.\n        if i > max_kappa as usize {\n            debug_assert_eq!(ten_kappa, 1);\n            debug_assert_eq!(kappa, 0);\n            break;\n        }\n\n        // restore invariants\n        kappa -= 1;\n        ten_kappa /= 10;\n        remainder = r;\n    }\n\n    // render fractional parts.\n    //\n    // in principle we can continue to the last available digit and check for the accuracy.\n    // unfortunately we are working with the finite-sized integers, so we need some criterion\n    // to detect the overflow. V8 uses `remainder > err`, which becomes false when\n    // the first `i` significant digits of `v - 1 ulp` and `v` differ. however this rejects\n    // too many otherwise valid input.\n    //\n    // since the later phase has a correct overflow detection, we instead use tighter criterion:\n    // we continue til `err` exceeds `10^kappa / 2`, so that the range between `v - 1 ulp` and\n    // `v + 1 ulp` definitely contains two or more rounded representations. this is same to\n    // the first two comparisons from `possibly_round`, for the reference.\n    let mut remainder = vfrac;\n    let maxerr = 1 << (e - 1);\n    while err < maxerr {\n        // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n        // - `remainder < 2^e`\n        // - `vfrac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n        // - `err = 10^(n-m)`\n\n        remainder *= 10; // won't overflow, `2^e * 10 < 2^64`\n        err *= 10; // won't overflow, `err * 10 < 2^e * 5 < 2^64`\n\n        // divide `remainder` by `10^kappa`.\n        // both are scaled by `2^e / 10^kappa`, so the latter is implicit here.\n        let q = remainder >> e;\n        let r = remainder & ((1 << e) - 1);\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        // is the buffer full? run the rounding pass with the remainder.\n        if i == len {\n            // SAFETY: we have initialized `len` many bytes.\n            return unsafe { possibly_round(buf, len, exp, limit, r, 1 << e, err) };\n        }\n\n        // restore invariants\n        remainder = r;\n    }\n\n    // further calculation is useless (`possibly_round` definitely fails), so we give up.\n    return None;\n\n    // we've generated all requested digits of `v`, which should be also same to corresponding\n    // digits of `v - 1 ulp`. now we check if there is a unique representation shared by\n    // both `v - 1 ulp` and `v + 1 ulp`; this can be either same to generated digits, or\n    // to the rounded-up version of those digits. if the range contains multiple representations\n    // of the same length, we cannot be sure and should return `None` instead.\n    //\n    // all arguments here are scaled by the common (but implicit) value `k`, so that:\n    // - `remainder = (v % 10^kappa) * k`\n    // - `ten_kappa = 10^kappa * k`\n    // - `ulp = 2^-e * k`\n    //\n    // SAFETY: the first `len` bytes of `buf` must be initialized.\n    unsafe fn possibly_round(\n        buf: &mut [MaybeUninit<u8>],\n        mut len: usize,\n        mut exp: i16,\n        limit: i16,\n        remainder: u64,\n        ten_kappa: u64,\n        ulp: u64,\n    ) -> Option<(&[u8], i16)> {\n        debug_assert!(remainder < ten_kappa);\n\n        //           10^kappa\n        //    :   :   :<->:   :\n        //    :   :   :   :   :\n        //    :|1 ulp|1 ulp|  :\n        //    :|<--->|<--->|  :\n        // ----|-----|-----|----\n        //     |     v     |\n        // v - 1 ulp   v + 1 ulp\n        //\n        // (for the reference, the dotted line indicates the exact value for\n        // possible representations in given number of digits.)\n        //\n        // error is too large that there are at least three possible representations\n        // between `v - 1 ulp` and `v + 1 ulp`. we cannot determine which one is correct.\n        if ulp >= ten_kappa {\n            return None;\n        }\n\n        //    10^kappa\n        //   :<------->:\n        //   :         :\n        //   : |1 ulp|1 ulp|\n        //   : |<--->|<--->|\n        // ----|-----|-----|----\n        //     |     v     |\n        // v - 1 ulp   v + 1 ulp\n        //\n        // in fact, 1/2 ulp is enough to introduce two possible representations.\n        // (remember that we need a unique representation for both `v - 1 ulp` and `v + 1 ulp`.)\n        // this won't overflow, as `ulp < ten_kappa` from the first check.\n        if ten_kappa - ulp <= ulp {\n            return None;\n        }\n\n        //     remainder\n        //       :<->|                           :\n        //       :   |                           :\n        //       :<--------- 10^kappa ---------->:\n        //     | :   |                           :\n        //     |1 ulp|1 ulp|                     :\n        //     |<--->|<--->|                     :\n        // ----|-----|-----|------------------------\n        //     |     v     |\n        // v - 1 ulp   v + 1 ulp\n        //\n        // if `v + 1 ulp` is closer to the rounded-down representation (which is already in `buf`),\n        // then we can safely return. note that `v - 1 ulp` *can* be less than the current\n        // representation, but as `1 ulp < 10^kappa / 2`, this condition is enough:\n        // the distance between `v - 1 ulp` and the current representation\n        // cannot exceed `10^kappa / 2`.\n        //\n        // the condition equals to `remainder + ulp < 10^kappa / 2`.\n        // since this can easily overflow, first check if `remainder < 10^kappa / 2`.\n        // we've already verified that `ulp < 10^kappa / 2`, so as long as\n        // `10^kappa` did not overflow after all, the second check is fine.\n        if ten_kappa - remainder > remainder && ten_kappa - 2 * remainder >= 2 * ulp {\n            // SAFETY: our caller initialized that memory.\n            return Some((unsafe { MaybeUninit::slice_assume_init_ref(&buf[..len]) }, exp));\n        }\n\n        //   :<------- remainder ------>|   :\n        //   :                          |   :\n        //   :<--------- 10^kappa --------->:\n        //   :                    |     |   : |\n        //   :                    |1 ulp|1 ulp|\n        //   :                    |<--->|<--->|\n        // -----------------------|-----|-----|-----\n        //                        |     v     |\n        //                    v - 1 ulp   v + 1 ulp\n        //\n        // on the other hands, if `v - 1 ulp` is closer to the rounded-up representation,\n        // we should round up and return. for the same reason we don't need to check `v + 1 ulp`.\n        //\n        // the condition equals to `remainder - ulp >= 10^kappa / 2`.\n        // again we first check if `remainder > ulp` (note that this is not `remainder >= ulp`,\n        // as `10^kappa` is never zero). also note that `remainder - ulp <= 10^kappa`,\n        // so the second check does not overflow.\n        if remainder > ulp && ten_kappa - (remainder - ulp) <= remainder - ulp {\n            if let Some(c) =\n                // SAFETY: our caller must have initialized that memory.\n                round_up(unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..len]) })\n            {\n                // only add an additional digit when we've been requested the fixed precision.\n                // we also need to check that, if the original buffer was empty,\n                // the additional digit can only be added when `exp == limit` (edge case).\n                exp += 1;\n                if exp > limit && len < buf.len() {\n                    buf[len] = MaybeUninit::new(c);\n                    len += 1;\n                }\n            }\n            // SAFETY: we and our caller initialized that memory.\n            return Some((unsafe { MaybeUninit::slice_assume_init_ref(&buf[..len]) }, exp));\n        }\n\n        // otherwise we are doomed (i.e., some values between `v - 1 ulp` and `v + 1 ulp` are\n        // rounding down and others are rounding up) and give up.\n        None\n    }\n}\n\n/// The exact and fixed mode implementation for Grisu with Dragon fallback.\n///\n/// This should be used for most cases.\npub fn format_exact<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n    limit: i16,\n) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n    use crate::num::flt2dec::strategy::dragon::format_exact as fallback;\n    // SAFETY: The borrow checker is not smart enough to let us use `buf`\n    // in the second branch, so we launder the lifetime here. But we only re-use\n    // `buf` if `format_exact_opt` returned `None` so this is okay.\n    match format_exact_opt(d, unsafe { &mut *(buf as *mut _) }, limit) {\n        Some(ret) => ret,\n        None => fallback(d, buf, limit),\n    }\n}\n"],[2888,"/*!\n\nFloating-point number to decimal conversion routines.\n\n# Problem statement\n\nWe are given the floating-point number `v = f * 2^e` with an integer `f`,\nand its bounds `minus` and `plus` such that any number between `v - minus` and\n`v + plus` will be rounded to `v`. For the simplicity we assume that\nthis range is exclusive. Then we would like to get the unique decimal\nrepresentation `V = 0.d[0..n-1] * 10^k` such that:\n\n- `d[0]` is non-zero.\n\n- It's correctly rounded when parsed back: `v - minus < V < v + plus`.\n  Furthermore it is shortest such one, i.e., there is no representation\n  with less than `n` digits that is correctly rounded.\n\n- It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Note that\n  there might be two representations satisfying this uniqueness requirement,\n  in which case some tie-breaking mechanism is used.\n\nWe will call this mode of operation as to the *shortest* mode. This mode is used\nwhen there is no additional constraint, and can be thought as a \"natural\" mode\nas it matches the ordinary intuition (it at least prints `0.1f32` as \"0.1\").\n\nWe have two more modes of operation closely related to each other. In these modes\nwe are given either the number of significant digits `n` or the last-digit\nlimitation `limit` (which determines the actual `n`), and we would like to get\nthe representation `V = 0.d[0..n-1] * 10^k` such that:\n\n- `d[0]` is non-zero, unless `n` was zero in which case only `k` is returned.\n\n- It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Again,\n  there might be some tie-breaking mechanism.\n\nWhen `limit` is given but not `n`, we set `n` such that `k - n = limit`\nso that the last digit `d[n-1]` is scaled by `10^(k-n) = 10^limit`.\nIf such `n` is negative, we clip it to zero so that we will only get `k`.\nWe are also limited by the supplied buffer. This limitation is used to print\nthe number up to given number of fractional digits without knowing\nthe correct `k` beforehand.\n\nWe will call the mode of operation requiring `n` as to the *exact* mode,\nand one requiring `limit` as to the *fixed* mode. The exact mode is a subset of\nthe fixed mode: the sufficiently large last-digit limitation will eventually fill\nthe supplied buffer and let the algorithm to return.\n\n# Implementation overview\n\nIt is easy to get the floating point printing correct but slow (Russ Cox has\n[demonstrated](https://research.swtch.com/ftoa) how it's easy), or incorrect but\nfast (naïve division and modulo). But it is surprisingly hard to print\nfloating point numbers correctly *and* efficiently.\n\nThere are two classes of algorithms widely known to be correct.\n\n- The \"Dragon\" family of algorithm is first described by Guy L. Steele Jr. and\n  Jon L. White. They rely on the fixed-size big integer for their correctness.\n  A slight improvement was found later, which is posthumously described by\n  Robert G. Burger and R. Kent Dybvig. David Gay's `dtoa.c` routine is\n  a popular implementation of this strategy.\n\n- The \"Grisu\" family of algorithm is first described by Florian Loitsch.\n  They use very cheap integer-only procedure to determine the close-to-correct\n  representation which is at least guaranteed to be shortest. The variant,\n  Grisu3, actively detects if the resulting representation is incorrect.\n\nWe implement both algorithms with necessary tweaks to suit our requirements.\nIn particular, published literatures are short of the actual implementation\ndifficulties like how to avoid arithmetic overflows. Each implementation,\navailable in `strategy::dragon` and `strategy::grisu` respectively,\nextensively describes all necessary justifications and many proofs for them.\n(It is still difficult to follow though. You have been warned.)\n\nBoth implementations expose two public functions:\n\n- `format_shortest(decoded, buf)`, which always needs at least\n  `MAX_SIG_DIGITS` digits of buffer. Implements the shortest mode.\n\n- `format_exact(decoded, buf, limit)`, which accepts as small as\n  one digit of buffer. Implements exact and fixed modes.\n\nThey try to fill the `u8` buffer with digits and returns the number of digits\nwritten and the exponent `k`. They are total for all finite `f32` and `f64`\ninputs (Grisu internally falls back to Dragon if necessary).\n\nThe rendered digits are formatted into the actual string form with\nfour functions:\n\n- `to_shortest_str` prints the shortest representation, which can be padded by\n  zeroes to make *at least* given number of fractional digits.\n\n- `to_shortest_exp_str` prints the shortest representation, which can be\n  padded by zeroes when its exponent is in the specified ranges,\n  or can be printed in the exponential form such as `1.23e45`.\n\n- `to_exact_exp_str` prints the exact representation with given number of\n  digits in the exponential form.\n\n- `to_exact_fixed_str` prints the fixed representation with *exactly*\n  given number of fractional digits.\n\nThey all return a slice of preallocated `Part` array, which corresponds to\nthe individual part of strings: a fixed string, a part of rendered digits,\na number of zeroes or a small (`u16`) number. The caller is expected to\nprovide a large enough buffer and `Part` array, and to assemble the final\nstring from resulting `Part`s itself.\n\nAll algorithms and formatting functions are accompanied by extensive tests\nin `coretests::num::flt2dec` module. It also shows how to use individual\nfunctions.\n\n*/\n\n// while this is extensively documented, this is in principle private which is\n// only made public for testing. do not expose us.\n#![doc(hidden)]\n#![unstable(\n    feature = \"flt2dec\",\n    reason = \"internal routines only exposed for testing\",\n    issue = \"none\"\n)]\n\npub use self::decoder::{decode, DecodableFloat, Decoded, FullDecoded};\n\nuse crate::mem::MaybeUninit;\n\npub mod decoder;\npub mod estimator;\n\n/// Digit-generation algorithms.\npub mod strategy {\n    pub mod dragon;\n    pub mod grisu;\n}\n\n/// The minimum size of buffer necessary for the shortest mode.\n///\n/// It is a bit non-trivial to derive, but this is one plus the maximal number of\n/// significant decimal digits from formatting algorithms with the shortest result.\n/// The exact formula is `ceil(# bits in mantissa * log_10 2 + 1)`.\npub const MAX_SIG_DIGITS: usize = 17;\n\n/// When `d` contains decimal digits, increase the last digit and propagate carry.\n/// Returns a next digit when it causes the length to change.\n#[doc(hidden)]\npub fn round_up(d: &mut [u8]) -> Option<u8> {\n    match d.iter().rposition(|&c| c != b'9') {\n        Some(i) => {\n            // d[i+1..n] is all nines\n            d[i] += 1;\n            for j in i + 1..d.len() {\n                d[j] = b'0';\n            }\n            None\n        }\n        None if d.len() > 0 => {\n            // 999..999 rounds to 1000..000 with an increased exponent\n            d[0] = b'1';\n            for j in 1..d.len() {\n                d[j] = b'0';\n            }\n            Some(b'0')\n        }\n        None => {\n            // an empty buffer rounds up (a bit strange but reasonable)\n            Some(b'1')\n        }\n    }\n}\n\n/// Formatted parts.\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub enum Part<'a> {\n    /// Given number of zero digits.\n    Zero(usize),\n    /// A literal number up to 5 digits.\n    Num(u16),\n    /// A verbatim copy of given bytes.\n    Copy(&'a [u8]),\n}\n\nimpl<'a> Part<'a> {\n    /// Returns the exact byte length of given part.\n    pub fn len(&self) -> usize {\n        match *self {\n            Part::Zero(nzeroes) => nzeroes,\n            Part::Num(v) => {\n                if v < 1_000 {\n                    if v < 10 {\n                        1\n                    } else if v < 100 {\n                        2\n                    } else {\n                        3\n                    }\n                } else {\n                    if v < 10_000 { 4 } else { 5 }\n                }\n            }\n            Part::Copy(buf) => buf.len(),\n        }\n    }\n\n    /// Writes a part into the supplied buffer.\n    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n        let len = self.len();\n        if out.len() >= len {\n            match *self {\n                Part::Zero(nzeroes) => {\n                    for c in &mut out[..nzeroes] {\n                        *c = b'0';\n                    }\n                }\n                Part::Num(mut v) => {\n                    for c in out[..len].iter_mut().rev() {\n                        *c = b'0' + (v % 10) as u8;\n                        v /= 10;\n                    }\n                }\n                Part::Copy(buf) => {\n                    out[..buf.len()].copy_from_slice(buf);\n                }\n            }\n            Some(len)\n        } else {\n            None\n        }\n    }\n}\n\n/// Formatted result containing one or more parts.\n/// This can be written to the byte buffer or converted to the allocated string.\n#[allow(missing_debug_implementations)]\n#[derive(Clone)]\npub struct Formatted<'a> {\n    /// A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n    pub sign: &'static str,\n    /// Formatted parts to be rendered after a sign and optional zero padding.\n    pub parts: &'a [Part<'a>],\n}\n\nimpl<'a> Formatted<'a> {\n    /// Returns the exact byte length of combined formatted result.\n    pub fn len(&self) -> usize {\n        let mut len = self.sign.len();\n        for part in self.parts {\n            len += part.len();\n        }\n        len\n    }\n\n    /// Writes all formatted parts into the supplied buffer.\n    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n        if out.len() < self.sign.len() {\n            return None;\n        }\n        out[..self.sign.len()].copy_from_slice(self.sign.as_bytes());\n\n        let mut written = self.sign.len();\n        for part in self.parts {\n            let len = part.write(&mut out[written..])?;\n            written += len;\n        }\n        Some(written)\n    }\n}\n\n/// Formats given decimal digits `0.<...buf...> * 10^exp` into the decimal form\n/// with at least given number of fractional digits. The result is stored to\n/// the supplied parts array and a slice of written parts is returned.\n///\n/// `frac_digits` can be less than the number of actual fractional digits in `buf`;\n/// it will be ignored and full digits will be printed. It is only used to print\n/// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n/// it will only print given digits and nothing else.\nfn digits_to_dec_str<'a>(\n    buf: &'a [u8],\n    exp: i16,\n    frac_digits: usize,\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> &'a [Part<'a>] {\n    assert!(!buf.is_empty());\n    assert!(buf[0] > b'0');\n    assert!(parts.len() >= 4);\n\n    // if there is the restriction on the last digit position, `buf` is assumed to be\n    // left-padded with the virtual zeroes. the number of virtual zeroes, `nzeroes`,\n    // equals to `max(0, exp + frac_digits - buf.len())`, so that the position of\n    // the last digit `exp - buf.len() - nzeroes` is no more than `-frac_digits`:\n    //\n    //                       |<-virtual->|\n    //       |<---- buf ---->|  zeroes   |     exp\n    //    0. 1 2 3 4 5 6 7 8 9 _ _ _ _ _ _ x 10\n    //    |                  |           |\n    // 10^exp    10^(exp-buf.len())   10^(exp-buf.len()-nzeroes)\n    //\n    // `nzeroes` is individually calculated for each case in order to avoid overflow.\n\n    if exp <= 0 {\n        // the decimal point is before rendered digits: [0.][000...000][1234][____]\n        let minus_exp = -(exp as i32) as usize;\n        parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n        parts[1] = MaybeUninit::new(Part::Zero(minus_exp));\n        parts[2] = MaybeUninit::new(Part::Copy(buf));\n        if frac_digits > buf.len() && frac_digits - buf.len() > minus_exp {\n            parts[3] = MaybeUninit::new(Part::Zero((frac_digits - buf.len()) - minus_exp));\n            // SAFETY: we just initialized the elements `..4`.\n            unsafe { MaybeUninit::slice_assume_init_ref(&parts[..4]) }\n        } else {\n            // SAFETY: we just initialized the elements `..3`.\n            unsafe { MaybeUninit::slice_assume_init_ref(&parts[..3]) }\n        }\n    } else {\n        let exp = exp as usize;\n        if exp < buf.len() {\n            // the decimal point is inside rendered digits: [12][.][34][____]\n            parts[0] = MaybeUninit::new(Part::Copy(&buf[..exp]));\n            parts[1] = MaybeUninit::new(Part::Copy(b\".\"));\n            parts[2] = MaybeUninit::new(Part::Copy(&buf[exp..]));\n            if frac_digits > buf.len() - exp {\n                parts[3] = MaybeUninit::new(Part::Zero(frac_digits - (buf.len() - exp)));\n                // SAFETY: we just initialized the elements `..4`.\n                unsafe { MaybeUninit::slice_assume_init_ref(&parts[..4]) }\n            } else {\n                // SAFETY: we just initialized the elements `..3`.\n                unsafe { MaybeUninit::slice_assume_init_ref(&parts[..3]) }\n            }\n        } else {\n            // the decimal point is after rendered digits: [1234][____0000] or [1234][__][.][__].\n            parts[0] = MaybeUninit::new(Part::Copy(buf));\n            parts[1] = MaybeUninit::new(Part::Zero(exp - buf.len()));\n            if frac_digits > 0 {\n                parts[2] = MaybeUninit::new(Part::Copy(b\".\"));\n                parts[3] = MaybeUninit::new(Part::Zero(frac_digits));\n                // SAFETY: we just initialized the elements `..4`.\n                unsafe { MaybeUninit::slice_assume_init_ref(&parts[..4]) }\n            } else {\n                // SAFETY: we just initialized the elements `..2`.\n                unsafe { MaybeUninit::slice_assume_init_ref(&parts[..2]) }\n            }\n        }\n    }\n}\n\n/// Formats the given decimal digits `0.<...buf...> * 10^exp` into the exponential\n/// form with at least the given number of significant digits. When `upper` is `true`,\n/// the exponent will be prefixed by `E`; otherwise that's `e`. The result is\n/// stored to the supplied parts array and a slice of written parts is returned.\n///\n/// `min_digits` can be less than the number of actual significant digits in `buf`;\n/// it will be ignored and full digits will be printed. It is only used to print\n/// additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n/// it will only print the given digits and nothing else.\nfn digits_to_exp_str<'a>(\n    buf: &'a [u8],\n    exp: i16,\n    min_ndigits: usize,\n    upper: bool,\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> &'a [Part<'a>] {\n    assert!(!buf.is_empty());\n    assert!(buf[0] > b'0');\n    assert!(parts.len() >= 6);\n\n    let mut n = 0;\n\n    parts[n] = MaybeUninit::new(Part::Copy(&buf[..1]));\n    n += 1;\n\n    if buf.len() > 1 || min_ndigits > 1 {\n        parts[n] = MaybeUninit::new(Part::Copy(b\".\"));\n        parts[n + 1] = MaybeUninit::new(Part::Copy(&buf[1..]));\n        n += 2;\n        if min_ndigits > buf.len() {\n            parts[n] = MaybeUninit::new(Part::Zero(min_ndigits - buf.len()));\n            n += 1;\n        }\n    }\n\n    // 0.1234 x 10^exp = 1.234 x 10^(exp-1)\n    let exp = exp as i32 - 1; // avoid underflow when exp is i16::MIN\n    if exp < 0 {\n        parts[n] = MaybeUninit::new(Part::Copy(if upper { b\"E-\" } else { b\"e-\" }));\n        parts[n + 1] = MaybeUninit::new(Part::Num(-exp as u16));\n    } else {\n        parts[n] = MaybeUninit::new(Part::Copy(if upper { b\"E\" } else { b\"e\" }));\n        parts[n + 1] = MaybeUninit::new(Part::Num(exp as u16));\n    }\n    // SAFETY: we just initialized the elements `..n + 2`.\n    unsafe { MaybeUninit::slice_assume_init_ref(&parts[..n + 2]) }\n}\n\n/// Sign formatting options.\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub enum Sign {\n    /// Prints `-` for any negative value.\n    Minus, // -inf -1 -0  0  1  inf nan\n    /// Prints `-` for any negative value, or `+` otherwise.\n    MinusPlus, // -inf -1 -0 +0 +1 +inf nan\n}\n\n/// Returns the static byte string corresponding to the sign to be formatted.\n/// It can be either `\"\"`, `\"+\"` or `\"-\"`.\nfn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static str {\n    match (*decoded, sign) {\n        (FullDecoded::Nan, _) => \"\",\n        (_, Sign::Minus) => {\n            if negative {\n                \"-\"\n            } else {\n                \"\"\n            }\n        }\n        (_, Sign::MinusPlus) => {\n            if negative {\n                \"-\"\n            } else {\n                \"+\"\n            }\n        }\n    }\n}\n\n/// Formats the given floating point number into the decimal form with at least\n/// given number of fractional digits. The result is stored to the supplied parts\n/// array while utilizing given byte buffer as a scratch. `upper` is currently\n/// unused but left for the future decision to change the case of non-finite values,\n/// i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n/// (which can be an empty string if no sign is rendered).\n///\n/// `format_shortest` should be the underlying digit-generation function.\n/// It should return the part of the buffer that it initialized.\n/// You probably would want `strategy::grisu::format_shortest` for this.\n///\n/// `frac_digits` can be less than the number of actual fractional digits in `v`;\n/// it will be ignored and full digits will be printed. It is only used to print\n/// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n/// it will only print given digits and nothing else.\n///\n/// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n/// There should be at least 4 parts available, due to the worst case like\n/// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\npub fn to_shortest_str<'a, T, F>(\n    mut format_shortest: F,\n    v: T,\n    sign: Sign,\n    frac_digits: usize,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 4);\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n        }\n        FullDecoded::Zero => {\n            if frac_digits > 0 {\n                // [0.][0000]\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..2`.\n                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..2]) },\n                }\n            } else {\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..1`.\n                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) },\n                }\n            }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let (buf, exp) = format_shortest(decoded, buf);\n            Formatted { sign, parts: digits_to_dec_str(buf, exp, frac_digits, parts) }\n        }\n    }\n}\n\n/// Formats the given floating point number into the decimal form or\n/// the exponential form, depending on the resulting exponent. The result is\n/// stored to the supplied parts array while utilizing given byte buffer\n/// as a scratch. `upper` is used to determine the case of non-finite values\n/// (`inf` and `nan`) or the case of the exponent prefix (`e` or `E`).\n/// The first part to be rendered is always a `Part::Sign` (which can be\n/// an empty string if no sign is rendered).\n///\n/// `format_shortest` should be the underlying digit-generation function.\n/// It should return the part of the buffer that it initialized.\n/// You probably would want `strategy::grisu::format_shortest` for this.\n///\n/// The `dec_bounds` is a tuple `(lo, hi)` such that the number is formatted\n/// as decimal only when `10^lo <= V < 10^hi`. Note that this is the *apparent* `V`\n/// instead of the actual `v`! Thus any printed exponent in the exponential form\n/// cannot be in this range, avoiding any confusion.\n///\n/// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n/// There should be at least 6 parts available, due to the worst case like\n/// `[+][1][.][2345][e][-][6]`.\npub fn to_shortest_exp_str<'a, T, F>(\n    mut format_shortest: F,\n    v: T,\n    sign: Sign,\n    dec_bounds: (i16, i16),\n    upper: bool,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 6);\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n    assert!(dec_bounds.0 <= dec_bounds.1);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n        }\n        FullDecoded::Zero => {\n            parts[0] = if dec_bounds.0 <= 0 && 0 < dec_bounds.1 {\n                MaybeUninit::new(Part::Copy(b\"0\"))\n            } else {\n                MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }))\n            };\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let (buf, exp) = format_shortest(decoded, buf);\n            let vis_exp = exp as i32 - 1;\n            let parts = if dec_bounds.0 as i32 <= vis_exp && vis_exp < dec_bounds.1 as i32 {\n                digits_to_dec_str(buf, exp, 0, parts)\n            } else {\n                digits_to_exp_str(buf, exp, 0, upper, parts)\n            };\n            Formatted { sign, parts }\n        }\n    }\n}\n\n/// Returns a rather crude approximation (upper bound) for the maximum buffer size\n/// calculated from the given decoded exponent.\n///\n/// The exact limit is:\n///\n/// - when `exp < 0`, the maximum length is `ceil(log_10 (5^-exp * (2^64 - 1)))`.\n/// - when `exp >= 0`, the maximum length is `ceil(log_10 (2^exp * (2^64 - 1)))`.\n///\n/// `ceil(log_10 (x^exp * (2^64 - 1)))` is less than `ceil(log_10 (2^64 - 1)) +\n/// ceil(exp * log_10 x)`, which is in turn less than `20 + (1 + exp * log_10 x)`.\n/// We use the facts that `log_10 2 < 5/16` and `log_10 5 < 12/16`, which is\n/// enough for our purposes.\n///\n/// Why do we need this? `format_exact` functions will fill the entire buffer\n/// unless limited by the last digit restriction, but it is possible that\n/// the number of digits requested is ridiculously large (say, 30,000 digits).\n/// The vast majority of buffer will be filled with zeroes, so we don't want to\n/// allocate all the buffer beforehand. Consequently, for any given arguments,\n/// 826 bytes of buffer should be sufficient for `f64`. Compare this with\n/// the actual number for the worst case: 770 bytes (when `exp = -1074`).\nfn estimate_max_buf_len(exp: i16) -> usize {\n    21 + ((if exp < 0 { -12 } else { 5 } * exp as i32) as usize >> 4)\n}\n\n/// Formats given floating point number into the exponential form with\n/// exactly given number of significant digits. The result is stored to\n/// the supplied parts array while utilizing given byte buffer as a scratch.\n/// `upper` is used to determine the case of the exponent prefix (`e` or `E`).\n/// The first part to be rendered is always a `Part::Sign` (which can be\n/// an empty string if no sign is rendered).\n///\n/// `format_exact` should be the underlying digit-generation function.\n/// It should return the part of the buffer that it initialized.\n/// You probably would want `strategy::grisu::format_exact` for this.\n///\n/// The byte buffer should be at least `ndigits` bytes long unless `ndigits` is\n/// so large that only the fixed number of digits will be ever written.\n/// (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n/// There should be at least 6 parts available, due to the worst case like\n/// `[+][1][.][2345][e][-][6]`.\npub fn to_exact_exp_str<'a, T, F>(\n    mut format_exact: F,\n    v: T,\n    sign: Sign,\n    ndigits: usize,\n    upper: bool,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 6);\n    assert!(ndigits > 0);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n        }\n        FullDecoded::Zero => {\n            if ndigits > 1 {\n                // [0.][0000][e0]\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                parts[1] = MaybeUninit::new(Part::Zero(ndigits - 1));\n                parts[2] = MaybeUninit::new(Part::Copy(if upper { b\"E0\" } else { b\"e0\" }));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..3`.\n                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..3]) },\n                }\n            } else {\n                parts[0] = MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..1`.\n                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) },\n                }\n            }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let maxlen = estimate_max_buf_len(decoded.exp);\n            assert!(buf.len() >= ndigits || buf.len() >= maxlen);\n\n            let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n            let (buf, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n            Formatted { sign, parts: digits_to_exp_str(buf, exp, ndigits, upper, parts) }\n        }\n    }\n}\n\n/// Formats given floating point number into the decimal form with exactly\n/// given number of fractional digits. The result is stored to the supplied parts\n/// array while utilizing given byte buffer as a scratch. `upper` is currently\n/// unused but left for the future decision to change the case of non-finite values,\n/// i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n/// (which can be an empty string if no sign is rendered).\n///\n/// `format_exact` should be the underlying digit-generation function.\n/// It should return the part of the buffer that it initialized.\n/// You probably would want `strategy::grisu::format_exact` for this.\n///\n/// The byte buffer should be enough for the output unless `frac_digits` is\n/// so large that only the fixed number of digits will be ever written.\n/// (The tipping point for `f64` is about 800, and 1000 bytes should be enough.)\n/// There should be at least 4 parts available, due to the worst case like\n/// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\npub fn to_exact_fixed_str<'a, T, F>(\n    mut format_exact: F,\n    v: T,\n    sign: Sign,\n    frac_digits: usize,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 4);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n        }\n        FullDecoded::Zero => {\n            if frac_digits > 0 {\n                // [0.][0000]\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..2`.\n                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..2]) },\n                }\n            } else {\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..1`.\n                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) },\n                }\n            }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let maxlen = estimate_max_buf_len(decoded.exp);\n            assert!(buf.len() >= maxlen);\n\n            // it *is* possible that `frac_digits` is ridiculously large.\n            // `format_exact` will end rendering digits much earlier in this case,\n            // because we are strictly limited by `maxlen`.\n            let limit = if frac_digits < 0x8000 { -(frac_digits as i16) } else { i16::MIN };\n            let (buf, exp) = format_exact(decoded, &mut buf[..maxlen], limit);\n            if exp <= limit {\n                // the restriction couldn't been met, so this should render like zero no matter\n                // `exp` was. this does not include the case that the restriction has been met\n                // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n                debug_assert_eq!(buf.len(), 0);\n                if frac_digits > 0 {\n                    // [0.][0000]\n                    parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                    parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n                    Formatted {\n                        sign,\n                        // SAFETY: we just initialized the elements `..2`.\n                        parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..2]) },\n                    }\n                } else {\n                    parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n                    Formatted {\n                        sign,\n                        // SAFETY: we just initialized the elements `..1`.\n                        parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) },\n                    }\n                }\n            } else {\n                Formatted { sign, parts: digits_to_dec_str(buf, exp, frac_digits, parts) }\n            }\n        }\n    }\n}\n"],[2889,"//! Constants specific to the `f32` single-precision floating point type.\n//!\n//! *[See also the `f32` primitive type][f32].*\n//!\n//! Mathematically significant numbers are provided in the `consts` sub-module.\n//!\n//! For the constants defined directly in this module\n//! (as distinct from those defined in the `consts` sub-module),\n//! new code should instead use the associated constants\n//! defined directly on the `f32` type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::convert::FloatToInt;\n#[cfg(not(test))]\nuse crate::intrinsics;\nuse crate::mem;\nuse crate::num::FpCategory;\n\n/// The radix or base of the internal representation of `f32`.\n/// Use [`f32::RADIX`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let r = std::f32::RADIX;\n///\n/// // intended way\n/// let r = f32::RADIX;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `RADIX` associated constant on `f32`\")]\npub const RADIX: u32 = f32::RADIX;\n\n/// Number of significant digits in base 2.\n/// Use [`f32::MANTISSA_DIGITS`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let d = std::f32::MANTISSA_DIGITS;\n///\n/// // intended way\n/// let d = f32::MANTISSA_DIGITS;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MANTISSA_DIGITS` associated constant on `f32`\"\n)]\npub const MANTISSA_DIGITS: u32 = f32::MANTISSA_DIGITS;\n\n/// Approximate number of significant digits in base 10.\n/// Use [`f32::DIGITS`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let d = std::f32::DIGITS;\n///\n/// // intended way\n/// let d = f32::DIGITS;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `DIGITS` associated constant on `f32`\")]\npub const DIGITS: u32 = f32::DIGITS;\n\n/// [Machine epsilon] value for `f32`.\n/// Use [`f32::EPSILON`] instead.\n///\n/// This is the difference between `1.0` and the next larger representable number.\n///\n/// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let e = std::f32::EPSILON;\n///\n/// // intended way\n/// let e = f32::EPSILON;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `EPSILON` associated constant on `f32`\"\n)]\npub const EPSILON: f32 = f32::EPSILON;\n\n/// Smallest finite `f32` value.\n/// Use [`f32::MIN`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let min = std::f32::MIN;\n///\n/// // intended way\n/// let min = f32::MIN;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MIN` associated constant on `f32`\")]\npub const MIN: f32 = f32::MIN;\n\n/// Smallest positive normal `f32` value.\n/// Use [`f32::MIN_POSITIVE`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let min = std::f32::MIN_POSITIVE;\n///\n/// // intended way\n/// let min = f32::MIN_POSITIVE;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MIN_POSITIVE` associated constant on `f32`\"\n)]\npub const MIN_POSITIVE: f32 = f32::MIN_POSITIVE;\n\n/// Largest finite `f32` value.\n/// Use [`f32::MAX`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let max = std::f32::MAX;\n///\n/// // intended way\n/// let max = f32::MAX;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MAX` associated constant on `f32`\")]\npub const MAX: f32 = f32::MAX;\n\n/// One greater than the minimum possible normal power of 2 exponent.\n/// Use [`f32::MIN_EXP`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let min = std::f32::MIN_EXP;\n///\n/// // intended way\n/// let min = f32::MIN_EXP;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MIN_EXP` associated constant on `f32`\"\n)]\npub const MIN_EXP: i32 = f32::MIN_EXP;\n\n/// Maximum possible power of 2 exponent.\n/// Use [`f32::MAX_EXP`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let max = std::f32::MAX_EXP;\n///\n/// // intended way\n/// let max = f32::MAX_EXP;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MAX_EXP` associated constant on `f32`\"\n)]\npub const MAX_EXP: i32 = f32::MAX_EXP;\n\n/// Minimum possible normal power of 10 exponent.\n/// Use [`f32::MIN_10_EXP`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let min = std::f32::MIN_10_EXP;\n///\n/// // intended way\n/// let min = f32::MIN_10_EXP;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MIN_10_EXP` associated constant on `f32`\"\n)]\npub const MIN_10_EXP: i32 = f32::MIN_10_EXP;\n\n/// Maximum possible power of 10 exponent.\n/// Use [`f32::MAX_10_EXP`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let max = std::f32::MAX_10_EXP;\n///\n/// // intended way\n/// let max = f32::MAX_10_EXP;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `MAX_10_EXP` associated constant on `f32`\"\n)]\npub const MAX_10_EXP: i32 = f32::MAX_10_EXP;\n\n/// Not a Number (NaN).\n/// Use [`f32::NAN`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let nan = std::f32::NAN;\n///\n/// // intended way\n/// let nan = f32::NAN;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `NAN` associated constant on `f32`\")]\npub const NAN: f32 = f32::NAN;\n\n/// Infinity (∞).\n/// Use [`f32::INFINITY`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let inf = std::f32::INFINITY;\n///\n/// // intended way\n/// let inf = f32::INFINITY;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `INFINITY` associated constant on `f32`\"\n)]\npub const INFINITY: f32 = f32::INFINITY;\n\n/// Negative infinity (−∞).\n/// Use [`f32::NEG_INFINITY`] instead.\n///\n/// # Examples\n///\n/// ```rust\n/// // deprecated way\n/// # #[allow(deprecated, deprecated_in_future)]\n/// let ninf = std::f32::NEG_INFINITY;\n///\n/// // intended way\n/// let ninf = f32::NEG_INFINITY;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"TBD\",\n    reason = \"replaced by the `NEG_INFINITY` associated constant on `f32`\"\n)]\npub const NEG_INFINITY: f32 = f32::NEG_INFINITY;\n\n/// Basic mathematical constants.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod consts {\n    // FIXME: replace with mathematical constants from cmath.\n\n    /// Archimedes' constant (π)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const PI: f32 = 3.14159265358979323846264338327950288_f32;\n\n    /// The full circle constant (τ)\n    ///\n    /// Equal to 2π.\n    #[stable(feature = \"tau_constant\", since = \"1.47.0\")]\n    pub const TAU: f32 = 6.28318530717958647692528676655900577_f32;\n\n    /// π/2\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n\n    /// π/3\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n\n    /// π/4\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n\n    /// π/6\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n\n    /// π/8\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n\n    /// 1/π\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n\n    /// 2/π\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n\n    /// 2/sqrt(π)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_2_SQRT_PI: f32 = 1.12837916709551257389615890312154517_f32;\n\n    /// sqrt(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const SQRT_2: f32 = 1.41421356237309504880168872420969808_f32;\n\n    /// 1/sqrt(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_1_SQRT_2: f32 = 0.707106781186547524400844362104849039_f32;\n\n    /// Euler's number (e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const E: f32 = 2.71828182845904523536028747135266250_f32;\n\n    /// log<sub>2</sub>(e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n\n    /// log<sub>2</sub>(10)\n    #[stable(feature = \"extra_log_consts\", since = \"1.43.0\")]\n    pub const LOG2_10: f32 = 3.32192809488736234787031942948939018_f32;\n\n    /// log<sub>10</sub>(e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n\n    /// log<sub>10</sub>(2)\n    #[stable(feature = \"extra_log_consts\", since = \"1.43.0\")]\n    pub const LOG10_2: f32 = 0.301029995663981195213738894724493027_f32;\n\n    /// ln(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n\n    /// ln(10)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n}\n\n#[lang = \"f32\"]\n#[cfg(not(test))]\nimpl f32 {\n    /// The radix or base of the internal representation of `f32`.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const RADIX: u32 = 2;\n\n    /// Number of significant digits in base 2.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MANTISSA_DIGITS: u32 = 24;\n\n    /// Approximate number of significant digits in base 10.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const DIGITS: u32 = 6;\n\n    /// [Machine epsilon] value for `f32`.\n    ///\n    /// This is the difference between `1.0` and the next larger representable number.\n    ///\n    /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const EPSILON: f32 = 1.19209290e-07_f32;\n\n    /// Smallest finite `f32` value.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MIN: f32 = -3.40282347e+38_f32;\n    /// Smallest positive normal `f32` value.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MIN_POSITIVE: f32 = 1.17549435e-38_f32;\n    /// Largest finite `f32` value.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MAX: f32 = 3.40282347e+38_f32;\n\n    /// One greater than the minimum possible normal power of 2 exponent.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MIN_EXP: i32 = -125;\n    /// Maximum possible power of 2 exponent.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MAX_EXP: i32 = 128;\n\n    /// Minimum possible normal power of 10 exponent.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MIN_10_EXP: i32 = -37;\n    /// Maximum possible power of 10 exponent.\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const MAX_10_EXP: i32 = 38;\n\n    /// Not a Number (NaN).\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const NAN: f32 = 0.0_f32 / 0.0_f32;\n    /// Infinity (∞).\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const INFINITY: f32 = 1.0_f32 / 0.0_f32;\n    /// Negative infinity (−∞).\n    #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n    pub const NEG_INFINITY: f32 = -1.0_f32 / 0.0_f32;\n\n    /// Returns `true` if this value is `NaN`.\n    ///\n    /// ```\n    /// let nan = f32::NAN;\n    /// let f = 7.0_f32;\n    ///\n    /// assert!(nan.is_nan());\n    /// assert!(!f.is_nan());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_nan(self) -> bool {\n        self != self\n    }\n\n    // FIXME(#50145): `abs` is publicly unavailable in libcore due to\n    // concerns about portability, so this implementation is for\n    // private use internally.\n    #[inline]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    const fn abs_private(self) -> f32 {\n        f32::from_bits(self.to_bits() & 0x7fff_ffff)\n    }\n\n    /// Returns `true` if this value is positive infinity or negative infinity, and\n    /// `false` otherwise.\n    ///\n    /// ```\n    /// let f = 7.0f32;\n    /// let inf = f32::INFINITY;\n    /// let neg_inf = f32::NEG_INFINITY;\n    /// let nan = f32::NAN;\n    ///\n    /// assert!(!f.is_infinite());\n    /// assert!(!nan.is_infinite());\n    ///\n    /// assert!(inf.is_infinite());\n    /// assert!(neg_inf.is_infinite());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_infinite(self) -> bool {\n        self.abs_private() == Self::INFINITY\n    }\n\n    /// Returns `true` if this number is neither infinite nor `NaN`.\n    ///\n    /// ```\n    /// let f = 7.0f32;\n    /// let inf = f32::INFINITY;\n    /// let neg_inf = f32::NEG_INFINITY;\n    /// let nan = f32::NAN;\n    ///\n    /// assert!(f.is_finite());\n    ///\n    /// assert!(!nan.is_finite());\n    /// assert!(!inf.is_finite());\n    /// assert!(!neg_inf.is_finite());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_finite(self) -> bool {\n        // There's no need to handle NaN separately: if self is NaN,\n        // the comparison is not true, exactly as desired.\n        self.abs_private() < Self::INFINITY\n    }\n\n    /// Returns `true` if the number is [subnormal].\n    ///\n    /// ```\n    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n    /// let max = f32::MAX;\n    /// let lower_than_min = 1.0e-40_f32;\n    /// let zero = 0.0_f32;\n    ///\n    /// assert!(!min.is_subnormal());\n    /// assert!(!max.is_subnormal());\n    ///\n    /// assert!(!zero.is_subnormal());\n    /// assert!(!f32::NAN.is_subnormal());\n    /// assert!(!f32::INFINITY.is_subnormal());\n    /// // Values between `0` and `min` are Subnormal.\n    /// assert!(lower_than_min.is_subnormal());\n    /// ```\n    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n    #[stable(feature = \"is_subnormal\", since = \"1.53.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_subnormal(self) -> bool {\n        matches!(self.classify(), FpCategory::Subnormal)\n    }\n\n    /// Returns `true` if the number is neither zero, infinite,\n    /// [subnormal], or `NaN`.\n    ///\n    /// ```\n    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n    /// let max = f32::MAX;\n    /// let lower_than_min = 1.0e-40_f32;\n    /// let zero = 0.0_f32;\n    ///\n    /// assert!(min.is_normal());\n    /// assert!(max.is_normal());\n    ///\n    /// assert!(!zero.is_normal());\n    /// assert!(!f32::NAN.is_normal());\n    /// assert!(!f32::INFINITY.is_normal());\n    /// // Values between `0` and `min` are Subnormal.\n    /// assert!(!lower_than_min.is_normal());\n    /// ```\n    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_normal(self) -> bool {\n        matches!(self.classify(), FpCategory::Normal)\n    }\n\n    /// Returns the floating point category of the number. If only one property\n    /// is going to be tested, it is generally faster to use the specific\n    /// predicate instead.\n    ///\n    /// ```\n    /// use std::num::FpCategory;\n    ///\n    /// let num = 12.4_f32;\n    /// let inf = f32::INFINITY;\n    ///\n    /// assert_eq!(num.classify(), FpCategory::Normal);\n    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    pub const fn classify(self) -> FpCategory {\n        const EXP_MASK: u32 = 0x7f800000;\n        const MAN_MASK: u32 = 0x007fffff;\n\n        let bits = self.to_bits();\n        match (bits & MAN_MASK, bits & EXP_MASK) {\n            (0, 0) => FpCategory::Zero,\n            (_, 0) => FpCategory::Subnormal,\n            (0, EXP_MASK) => FpCategory::Infinite,\n            (_, EXP_MASK) => FpCategory::Nan,\n            _ => FpCategory::Normal,\n        }\n    }\n\n    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n    /// positive sign bit and positive infinity.\n    ///\n    /// ```\n    /// let f = 7.0_f32;\n    /// let g = -7.0_f32;\n    ///\n    /// assert!(f.is_sign_positive());\n    /// assert!(!g.is_sign_positive());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_sign_positive(self) -> bool {\n        !self.is_sign_negative()\n    }\n\n    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n    /// negative sign bit and negative infinity.\n    ///\n    /// ```\n    /// let f = 7.0f32;\n    /// let g = -7.0f32;\n    ///\n    /// assert!(!f.is_sign_negative());\n    /// assert!(g.is_sign_negative());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_sign_negative(self) -> bool {\n        // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n        // applies to zeros and NaNs as well.\n        self.to_bits() & 0x8000_0000 != 0\n    }\n\n    /// Takes the reciprocal (inverse) of a number, `1/x`.\n    ///\n    /// ```\n    /// let x = 2.0_f32;\n    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn recip(self) -> f32 {\n        1.0 / self\n    }\n\n    /// Converts radians to degrees.\n    ///\n    /// ```\n    /// let angle = std::f32::consts::PI;\n    ///\n    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")]\n    #[inline]\n    pub fn to_degrees(self) -> f32 {\n        // Use a constant for better precision.\n        const PIS_IN_180: f32 = 57.2957795130823208767981548141051703_f32;\n        self * PIS_IN_180\n    }\n\n    /// Converts degrees to radians.\n    ///\n    /// ```\n    /// let angle = 180.0f32;\n    ///\n    /// let abs_difference = (angle.to_radians() - std::f32::consts::PI).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")]\n    #[inline]\n    pub fn to_radians(self) -> f32 {\n        let value: f32 = consts::PI;\n        self * (value / 180.0f32)\n    }\n\n    /// Returns the maximum of the two numbers.\n    ///\n    /// ```\n    /// let x = 1.0f32;\n    /// let y = 2.0f32;\n    ///\n    /// assert_eq!(x.max(y), y);\n    /// ```\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn max(self, other: f32) -> f32 {\n        intrinsics::maxnumf32(self, other)\n    }\n\n    /// Returns the minimum of the two numbers.\n    ///\n    /// ```\n    /// let x = 1.0f32;\n    /// let y = 2.0f32;\n    ///\n    /// assert_eq!(x.min(y), x);\n    /// ```\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn min(self, other: f32) -> f32 {\n        intrinsics::minnumf32(self, other)\n    }\n\n    /// Rounds toward zero and converts to any primitive integer type,\n    /// assuming that the value is finite and fits in that type.\n    ///\n    /// ```\n    /// let value = 4.6_f32;\n    /// let rounded = unsafe { value.to_int_unchecked::<u16>() };\n    /// assert_eq!(rounded, 4);\n    ///\n    /// let value = -128.9_f32;\n    /// let rounded = unsafe { value.to_int_unchecked::<i8>() };\n    /// assert_eq!(rounded, i8::MIN);\n    /// ```\n    ///\n    /// # Safety\n    ///\n    /// The value must:\n    ///\n    /// * Not be `NaN`\n    /// * Not be infinite\n    /// * Be representable in the return type `Int`, after truncating off its fractional part\n    #[stable(feature = \"float_approx_unchecked_to\", since = \"1.44.0\")]\n    #[inline]\n    pub unsafe fn to_int_unchecked<Int>(self) -> Int\n    where\n        Self: FloatToInt<Int>,\n    {\n        // SAFETY: the caller must uphold the safety contract for\n        // `FloatToInt::to_int_unchecked`.\n        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }\n    }\n\n    /// Raw transmutation to `u32`.\n    ///\n    /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n    ///\n    /// See [`from_bits`](Self::from_bits) for some discussion of the\n    /// portability of this operation (there are almost no issues).\n    ///\n    /// Note that this function is distinct from `as` casting, which attempts to\n    /// preserve the *numeric* value, and not the bitwise value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\n    /// assert_eq!((12.5f32).to_bits(), 0x41480000);\n    ///\n    /// ```\n    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn to_bits(self) -> u32 {\n        // SAFETY: `u32` is a plain old datatype so we can always transmute to it\n        unsafe { mem::transmute(self) }\n    }\n\n    /// Raw transmutation from `u32`.\n    ///\n    /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n    /// It turns out this is incredibly portable, for two reasons:\n    ///\n    /// * Floats and Ints have the same endianness on all supported platforms.\n    /// * IEEE-754 very precisely specifies the bit layout of floats.\n    ///\n    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n    /// (notably x86 and ARM) picked the interpretation that was ultimately\n    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n    ///\n    /// Rather than trying to preserve signaling-ness cross-platform, this\n    /// implementation favors preserving the exact bits. This means that\n    /// any payloads encoded in NaNs will be preserved even if the result of\n    /// this method is sent over the network from an x86 machine to a MIPS one.\n    ///\n    /// If the results of this method are only manipulated by the same\n    /// architecture that produced them, then there is no portability concern.\n    ///\n    /// If the input isn't NaN, then there is no portability concern.\n    ///\n    /// If you don't care about signalingness (very likely), then there is no\n    /// portability concern.\n    ///\n    /// Note that this function is distinct from `as` casting, which attempts to\n    /// preserve the *numeric* value, and not the bitwise value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = f32::from_bits(0x41480000);\n    /// assert_eq!(v, 12.5);\n    /// ```\n    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn from_bits(v: u32) -> Self {\n        // SAFETY: `u32` is a plain old datatype so we can always transmute from it\n        // It turns out the safety issues with sNaN were overblown! Hooray!\n        unsafe { mem::transmute(v) }\n    }\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// big-endian (network) byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f32.to_be_bytes();\n    /// assert_eq!(bytes, [0x41, 0x48, 0x00, 0x00]);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn to_be_bytes(self) -> [u8; 4] {\n        self.to_bits().to_be_bytes()\n    }\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// little-endian byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f32.to_le_bytes();\n    /// assert_eq!(bytes, [0x00, 0x00, 0x48, 0x41]);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn to_le_bytes(self) -> [u8; 4] {\n        self.to_bits().to_le_bytes()\n    }\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// native byte order.\n    ///\n    /// As the target platform's native endianness is used, portable code\n    /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.\n    ///\n    /// [`to_be_bytes`]: f32::to_be_bytes\n    /// [`to_le_bytes`]: f32::to_le_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f32.to_ne_bytes();\n    /// assert_eq!(\n    ///     bytes,\n    ///     if cfg!(target_endian = \"big\") {\n    ///         [0x41, 0x48, 0x00, 0x00]\n    ///     } else {\n    ///         [0x00, 0x00, 0x48, 0x41]\n    ///     }\n    /// );\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn to_ne_bytes(self) -> [u8; 4] {\n        self.to_bits().to_ne_bytes()\n    }\n\n    /// Create a floating point value from its representation as a byte array in big endian.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f32::from_be_bytes([0x41, 0x48, 0x00, 0x00]);\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn from_be_bytes(bytes: [u8; 4]) -> Self {\n        Self::from_bits(u32::from_be_bytes(bytes))\n    }\n\n    /// Create a floating point value from its representation as a byte array in little endian.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f32::from_le_bytes([0x00, 0x00, 0x48, 0x41]);\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn from_le_bytes(bytes: [u8; 4]) -> Self {\n        Self::from_bits(u32::from_le_bytes(bytes))\n    }\n\n    /// Create a floating point value from its representation as a byte array in native endian.\n    ///\n    /// As the target platform's native endianness is used, portable code\n    /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n    /// appropriate instead.\n    ///\n    /// [`from_be_bytes`]: f32::from_be_bytes\n    /// [`from_le_bytes`]: f32::from_le_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f32::from_ne_bytes(if cfg!(target_endian = \"big\") {\n    ///     [0x41, 0x48, 0x00, 0x00]\n    /// } else {\n    ///     [0x00, 0x00, 0x48, 0x41]\n    /// });\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[inline]\n    pub const fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n        Self::from_bits(u32::from_ne_bytes(bytes))\n    }\n\n    /// Returns an ordering between self and other values.\n    /// Unlike the standard partial comparison between floating point numbers,\n    /// this comparison always produces an ordering in accordance to\n    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n    /// floating point standard. The values are ordered in following order:\n    /// - Negative quiet NaN\n    /// - Negative signaling NaN\n    /// - Negative infinity\n    /// - Negative numbers\n    /// - Negative subnormal numbers\n    /// - Negative zero\n    /// - Positive zero\n    /// - Positive subnormal numbers\n    /// - Positive numbers\n    /// - Positive infinity\n    /// - Positive signaling NaN\n    /// - Positive quiet NaN\n    ///\n    /// Note that this function does not always agree with the [`PartialOrd`]\n    /// and [`PartialEq`] implementations of `f32`. In particular, they regard\n    /// negative and positive zero as equal, while `total_cmp` doesn't.\n    ///\n    /// # Example\n    /// ```\n    /// #![feature(total_cmp)]\n    /// struct GoodBoy {\n    ///     name: String,\n    ///     weight: f32,\n    /// }\n    ///\n    /// let mut bois = vec![\n    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f32::INFINITY },\n    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f32::NAN },\n    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n    /// ];\n    ///\n    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n    /// # assert!(bois.into_iter().map(|b| b.weight)\n    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f32::INFINITY, f32::NAN].iter())\n    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n    /// ```\n    #[unstable(feature = \"total_cmp\", issue = \"72599\")]\n    #[inline]\n    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n        let mut left = self.to_bits() as i32;\n        let mut right = other.to_bits() as i32;\n\n        // In case of negatives, flip all the bits except the sign\n        // to achieve a similar layout as two's complement integers\n        //\n        // Why does this work? IEEE 754 floats consist of three fields:\n        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n        // fields as a whole have the property that their bitwise order is\n        // equal to the numeric magnitude where the magnitude is defined.\n        // The magnitude is not normally defined on NaN values, but\n        // IEEE 754 totalOrder defines the NaN values also to follow the\n        // bitwise order. This leads to order explained in the doc comment.\n        // However, the representation of magnitude is the same for negative\n        // and positive numbers – only the sign bit is different.\n        // To easily compare the floats as signed integers, we need to\n        // flip the exponent and mantissa bits in case of negative numbers.\n        // We effectively convert the numbers to \"two's complement\" form.\n        //\n        // To do the flipping, we construct a mask and XOR against it.\n        // We branchlessly calculate an \"all-ones except for the sign bit\"\n        // mask from negative-signed values: right shifting sign-extends\n        // the integer, so we \"fill\" the mask with sign bits, and then\n        // convert to unsigned to push one more zero bit.\n        // On positive values, the mask is all zeros, so it's a no-op.\n        left ^= (((left >> 31) as u32) >> 1) as i32;\n        right ^= (((right >> 31) as u32) >> 1) as i32;\n\n        left.cmp(&right)\n    }\n\n    /// Restrict a value to a certain interval unless it is NaN.\n    ///\n    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n    /// less than `min`. Otherwise this returns `self`.\n    ///\n    /// Note that this function returns NaN if the initial value was NaN as\n    /// well.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `min > max`, `min` is NaN, or `max` is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!((-3.0f32).clamp(-2.0, 1.0) == -2.0);\n    /// assert!((0.0f32).clamp(-2.0, 1.0) == 0.0);\n    /// assert!((2.0f32).clamp(-2.0, 1.0) == 1.0);\n    /// assert!((f32::NAN).clamp(-2.0, 1.0).is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"clamp\", since = \"1.50.0\")]\n    #[inline]\n    pub fn clamp(self, min: f32, max: f32) -> f32 {\n        assert!(min <= max);\n        let mut x = self;\n        if x < min {\n            x = min;\n        }\n        if x > max {\n            x = max;\n        }\n        x\n    }\n}\n"],[2890,"//! Extended precision \"soft float\", for internal use only.\n\n// This module is only for dec2flt and flt2dec, and only public because of coretests.\n// It is not intended to ever be stabilized.\n#![doc(hidden)]\n#![unstable(\n    feature = \"core_private_diy_float\",\n    reason = \"internal routines only exposed for testing\",\n    issue = \"none\"\n)]\n\n/// A custom 64-bit floating point type, representing `f * 2^e`.\n#[derive(Copy, Clone, Debug)]\n#[doc(hidden)]\npub struct Fp {\n    /// The integer mantissa.\n    pub f: u64,\n    /// The exponent in base 2.\n    pub e: i16,\n}\n\nimpl Fp {\n    /// Returns a correctly rounded product of itself and `other`.\n    pub fn mul(&self, other: &Fp) -> Fp {\n        const MASK: u64 = 0xffffffff;\n        let a = self.f >> 32;\n        let b = self.f & MASK;\n        let c = other.f >> 32;\n        let d = other.f & MASK;\n        let ac = a * c;\n        let bc = b * c;\n        let ad = a * d;\n        let bd = b * d;\n        let tmp = (bd >> 32) + (ad & MASK) + (bc & MASK) + (1 << 31) /* round */;\n        let f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);\n        let e = self.e + other.e + 64;\n        Fp { f, e }\n    }\n\n    /// Normalizes itself so that the resulting mantissa is at least `2^63`.\n    pub fn normalize(&self) -> Fp {\n        let mut f = self.f;\n        let mut e = self.e;\n        if f >> (64 - 32) == 0 {\n            f <<= 32;\n            e -= 32;\n        }\n        if f >> (64 - 16) == 0 {\n            f <<= 16;\n            e -= 16;\n        }\n        if f >> (64 - 8) == 0 {\n            f <<= 8;\n            e -= 8;\n        }\n        if f >> (64 - 4) == 0 {\n            f <<= 4;\n            e -= 4;\n        }\n        if f >> (64 - 2) == 0 {\n            f <<= 2;\n            e -= 2;\n        }\n        if f >> (64 - 1) == 0 {\n            f <<= 1;\n            e -= 1;\n        }\n        debug_assert!(f >= (1 >> 63));\n        Fp { f, e }\n    }\n\n    /// Normalizes itself to have the shared exponent.\n    /// It can only decrease the exponent (and thus increase the mantissa).\n    pub fn normalize_to(&self, e: i16) -> Fp {\n        let edelta = self.e - e;\n        assert!(edelta >= 0);\n        let edelta = edelta as usize;\n        assert_eq!(self.f << edelta >> edelta, self.f);\n        Fp { f: self.f << edelta, e }\n    }\n}\n"],[2891,"//! Numeric traits and functions for the built-in numeric types.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::ascii;\nuse crate::intrinsics;\nuse crate::mem;\nuse crate::str::FromStr;\n\n// Used because the `?` operator is not allowed in a const context.\nmacro_rules! try_opt {\n    ($e:expr) => {\n        match $e {\n            Some(x) => x,\n            None => return None,\n        }\n    };\n}\n\n#[allow_internal_unstable(const_likely)]\nmacro_rules! unlikely {\n    ($e: expr) => {\n        intrinsics::unlikely($e)\n    };\n}\n\n// All these modules are technically private and only exposed for coretests:\npub mod bignum;\npub mod dec2flt;\npub mod diy_float;\npub mod flt2dec;\n\n#[macro_use]\nmod int_macros; // import int_impl!\n#[macro_use]\nmod uint_macros; // import uint_impl!\n\nmod error;\nmod nonzero;\nmod wrapping;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use wrapping::Wrapping;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use dec2flt::ParseFloatError;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use error::ParseIntError;\n\n#[stable(feature = \"nonzero\", since = \"1.28.0\")]\npub use nonzero::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n\n#[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\npub use nonzero::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\npub use error::TryFromIntError;\n\n#[stable(feature = \"int_error_matching\", since = \"1.55.0\")]\npub use error::IntErrorKind;\n\nmacro_rules! usize_isize_to_xe_bytes_doc {\n    () => {\n        \"\n\n**Note**: This function returns an array of length 2, 4 or 8 bytes\ndepending on the target pointer size.\n\n\"\n    };\n}\n\nmacro_rules! usize_isize_from_xe_bytes_doc {\n    () => {\n        \"\n\n**Note**: This function takes an array of length 2, 4 or 8 bytes\ndepending on the target pointer size.\n\n\"\n    };\n}\n\n#[lang = \"i8\"]\nimpl i8 {\n    int_impl! { i8, i8, u8, 8, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n    \"[0x12]\", \"[0x12]\", \"\", \"\" }\n}\n\n#[lang = \"i16\"]\nimpl i16 {\n    int_impl! { i16, i16, u16, 16, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n    \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n}\n\n#[lang = \"i32\"]\nimpl i32 {\n    int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n}\n\n#[lang = \"i64\"]\nimpl i64 {\n    int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, 12,\n    \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n    \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\" }\n}\n\n#[lang = \"i128\"]\nimpl i128 {\n    int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n    170141183460469231731687303715884105727, 16,\n    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\", \"\", \"\" }\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i16, usize, 16, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n    \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\n#[cfg(target_pointer_width = \"32\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i32, usize, 32, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\n#[cfg(target_pointer_width = \"64\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i64, usize, 64, -9223372036854775808, 9223372036854775807,\n    12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\n/// If 6th bit set ascii is upper case.\nconst ASCII_CASE_MASK: u8 = 0b0010_0000;\n\n#[lang = \"u8\"]\nimpl u8 {\n    uint_impl! { u8, u8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n    \"[0x12]\", \"\", \"\" }\n\n    /// Checks if the value is within the ASCII range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let ascii = 97u8;\n    /// let non_ascii = 150u8;\n    ///\n    /// assert!(ascii.is_ascii());\n    /// assert!(!non_ascii.is_ascii());\n    /// ```\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.43.0\")]\n    #[inline]\n    pub const fn is_ascii(&self) -> bool {\n        *self & 128 == 0\n    }\n\n    /// Makes a copy of the value in its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let lowercase_a = 97u8;\n    ///\n    /// assert_eq!(65, lowercase_a.to_ascii_uppercase());\n    /// ```\n    ///\n    /// [`make_ascii_uppercase`]: Self::make_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.52.0\")]\n    #[inline]\n    pub const fn to_ascii_uppercase(&self) -> u8 {\n        // Unset the fifth bit if this is a lowercase letter\n        *self & !((self.is_ascii_lowercase() as u8) * ASCII_CASE_MASK)\n    }\n\n    /// Makes a copy of the value in its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 65u8;\n    ///\n    /// assert_eq!(97, uppercase_a.to_ascii_lowercase());\n    /// ```\n    ///\n    /// [`make_ascii_lowercase`]: Self::make_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.52.0\")]\n    #[inline]\n    pub const fn to_ascii_lowercase(&self) -> u8 {\n        // Set the fifth bit if this is an uppercase letter\n        *self | (self.is_ascii_uppercase() as u8 * ASCII_CASE_MASK)\n    }\n\n    /// Assumes self is ascii\n    #[inline]\n    pub(crate) const fn ascii_change_case_unchecked(&self) -> u8 {\n        *self ^ ASCII_CASE_MASK\n    }\n\n    /// Checks that two values are an ASCII case-insensitive match.\n    ///\n    /// This is equivalent to `to_ascii_lowercase(a) == to_ascii_lowercase(b)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let lowercase_a = 97u8;\n    /// let uppercase_a = 65u8;\n    ///\n    /// assert!(lowercase_a.eq_ignore_ascii_case(&uppercase_a));\n    /// ```\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.52.0\")]\n    #[inline]\n    pub const fn eq_ignore_ascii_case(&self, other: &u8) -> bool {\n        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n    }\n\n    /// Converts this value to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`to_ascii_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut byte = b'a';\n    ///\n    /// byte.make_ascii_uppercase();\n    ///\n    /// assert_eq!(b'A', byte);\n    /// ```\n    ///\n    /// [`to_ascii_uppercase`]: Self::to_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        *self = self.to_ascii_uppercase();\n    }\n\n    /// Converts this value to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`to_ascii_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut byte = b'A';\n    ///\n    /// byte.make_ascii_lowercase();\n    ///\n    /// assert_eq!(b'a', byte);\n    /// ```\n    ///\n    /// [`to_ascii_lowercase`]: Self::to_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        *self = self.to_ascii_lowercase();\n    }\n\n    /// Checks if the value is an ASCII alphabetic character:\n    ///\n    /// - U+0041 'A' ..= U+005A 'Z', or\n    /// - U+0061 'a' ..= U+007A 'z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_alphabetic());\n    /// assert!(uppercase_g.is_ascii_alphabetic());\n    /// assert!(a.is_ascii_alphabetic());\n    /// assert!(g.is_ascii_alphabetic());\n    /// assert!(!zero.is_ascii_alphabetic());\n    /// assert!(!percent.is_ascii_alphabetic());\n    /// assert!(!space.is_ascii_alphabetic());\n    /// assert!(!lf.is_ascii_alphabetic());\n    /// assert!(!esc.is_ascii_alphabetic());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_alphabetic(&self) -> bool {\n        matches!(*self, b'A'..=b'Z' | b'a'..=b'z')\n    }\n\n    /// Checks if the value is an ASCII uppercase character:\n    /// U+0041 'A' ..= U+005A 'Z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_uppercase());\n    /// assert!(uppercase_g.is_ascii_uppercase());\n    /// assert!(!a.is_ascii_uppercase());\n    /// assert!(!g.is_ascii_uppercase());\n    /// assert!(!zero.is_ascii_uppercase());\n    /// assert!(!percent.is_ascii_uppercase());\n    /// assert!(!space.is_ascii_uppercase());\n    /// assert!(!lf.is_ascii_uppercase());\n    /// assert!(!esc.is_ascii_uppercase());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_uppercase(&self) -> bool {\n        matches!(*self, b'A'..=b'Z')\n    }\n\n    /// Checks if the value is an ASCII lowercase character:\n    /// U+0061 'a' ..= U+007A 'z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_lowercase());\n    /// assert!(!uppercase_g.is_ascii_lowercase());\n    /// assert!(a.is_ascii_lowercase());\n    /// assert!(g.is_ascii_lowercase());\n    /// assert!(!zero.is_ascii_lowercase());\n    /// assert!(!percent.is_ascii_lowercase());\n    /// assert!(!space.is_ascii_lowercase());\n    /// assert!(!lf.is_ascii_lowercase());\n    /// assert!(!esc.is_ascii_lowercase());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_lowercase(&self) -> bool {\n        matches!(*self, b'a'..=b'z')\n    }\n\n    /// Checks if the value is an ASCII alphanumeric character:\n    ///\n    /// - U+0041 'A' ..= U+005A 'Z', or\n    /// - U+0061 'a' ..= U+007A 'z', or\n    /// - U+0030 '0' ..= U+0039 '9'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_alphanumeric());\n    /// assert!(uppercase_g.is_ascii_alphanumeric());\n    /// assert!(a.is_ascii_alphanumeric());\n    /// assert!(g.is_ascii_alphanumeric());\n    /// assert!(zero.is_ascii_alphanumeric());\n    /// assert!(!percent.is_ascii_alphanumeric());\n    /// assert!(!space.is_ascii_alphanumeric());\n    /// assert!(!lf.is_ascii_alphanumeric());\n    /// assert!(!esc.is_ascii_alphanumeric());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_alphanumeric(&self) -> bool {\n        matches!(*self, b'0'..=b'9' | b'A'..=b'Z' | b'a'..=b'z')\n    }\n\n    /// Checks if the value is an ASCII decimal digit:\n    /// U+0030 '0' ..= U+0039 '9'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_digit());\n    /// assert!(!uppercase_g.is_ascii_digit());\n    /// assert!(!a.is_ascii_digit());\n    /// assert!(!g.is_ascii_digit());\n    /// assert!(zero.is_ascii_digit());\n    /// assert!(!percent.is_ascii_digit());\n    /// assert!(!space.is_ascii_digit());\n    /// assert!(!lf.is_ascii_digit());\n    /// assert!(!esc.is_ascii_digit());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_digit(&self) -> bool {\n        matches!(*self, b'0'..=b'9')\n    }\n\n    /// Checks if the value is an ASCII hexadecimal digit:\n    ///\n    /// - U+0030 '0' ..= U+0039 '9', or\n    /// - U+0041 'A' ..= U+0046 'F', or\n    /// - U+0061 'a' ..= U+0066 'f'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_hexdigit());\n    /// assert!(!uppercase_g.is_ascii_hexdigit());\n    /// assert!(a.is_ascii_hexdigit());\n    /// assert!(!g.is_ascii_hexdigit());\n    /// assert!(zero.is_ascii_hexdigit());\n    /// assert!(!percent.is_ascii_hexdigit());\n    /// assert!(!space.is_ascii_hexdigit());\n    /// assert!(!lf.is_ascii_hexdigit());\n    /// assert!(!esc.is_ascii_hexdigit());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_hexdigit(&self) -> bool {\n        matches!(*self, b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f')\n    }\n\n    /// Checks if the value is an ASCII punctuation character:\n    ///\n    /// - U+0021 ..= U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n    /// - U+003A ..= U+0040 `: ; < = > ? @`, or\n    /// - U+005B ..= U+0060 ``[ \\ ] ^ _ ` ``, or\n    /// - U+007B ..= U+007E `{ | } ~`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_punctuation());\n    /// assert!(!uppercase_g.is_ascii_punctuation());\n    /// assert!(!a.is_ascii_punctuation());\n    /// assert!(!g.is_ascii_punctuation());\n    /// assert!(!zero.is_ascii_punctuation());\n    /// assert!(percent.is_ascii_punctuation());\n    /// assert!(!space.is_ascii_punctuation());\n    /// assert!(!lf.is_ascii_punctuation());\n    /// assert!(!esc.is_ascii_punctuation());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_punctuation(&self) -> bool {\n        matches!(*self, b'!'..=b'/' | b':'..=b'@' | b'['..=b'`' | b'{'..=b'~')\n    }\n\n    /// Checks if the value is an ASCII graphic character:\n    /// U+0021 '!' ..= U+007E '~'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_graphic());\n    /// assert!(uppercase_g.is_ascii_graphic());\n    /// assert!(a.is_ascii_graphic());\n    /// assert!(g.is_ascii_graphic());\n    /// assert!(zero.is_ascii_graphic());\n    /// assert!(percent.is_ascii_graphic());\n    /// assert!(!space.is_ascii_graphic());\n    /// assert!(!lf.is_ascii_graphic());\n    /// assert!(!esc.is_ascii_graphic());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_graphic(&self) -> bool {\n        matches!(*self, b'!'..=b'~')\n    }\n\n    /// Checks if the value is an ASCII whitespace character:\n    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n    ///\n    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n    /// whitespace][infra-aw]. There are several other definitions in\n    /// wide use. For instance, [the POSIX locale][pct] includes\n    /// U+000B VERTICAL TAB as well as all the above characters,\n    /// but—from the very same specification—[the default rule for\n    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n    ///\n    /// If you are writing a program that will process an existing\n    /// file format, check what that format's definition of whitespace is\n    /// before using this function.\n    ///\n    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n    /// [pct]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n    /// [bfs]: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_whitespace());\n    /// assert!(!uppercase_g.is_ascii_whitespace());\n    /// assert!(!a.is_ascii_whitespace());\n    /// assert!(!g.is_ascii_whitespace());\n    /// assert!(!zero.is_ascii_whitespace());\n    /// assert!(!percent.is_ascii_whitespace());\n    /// assert!(space.is_ascii_whitespace());\n    /// assert!(lf.is_ascii_whitespace());\n    /// assert!(!esc.is_ascii_whitespace());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_whitespace(&self) -> bool {\n        matches!(*self, b'\\t' | b'\\n' | b'\\x0C' | b'\\r' | b' ')\n    }\n\n    /// Checks if the value is an ASCII control character:\n    /// U+0000 NUL ..= U+001F UNIT SEPARATOR, or U+007F DELETE.\n    /// Note that most ASCII whitespace characters are control\n    /// characters, but SPACE is not.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_control());\n    /// assert!(!uppercase_g.is_ascii_control());\n    /// assert!(!a.is_ascii_control());\n    /// assert!(!g.is_ascii_control());\n    /// assert!(!zero.is_ascii_control());\n    /// assert!(!percent.is_ascii_control());\n    /// assert!(!space.is_ascii_control());\n    /// assert!(lf.is_ascii_control());\n    /// assert!(esc.is_ascii_control());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_ctype_on_intrinsics\", since = \"1.47.0\")]\n    #[inline]\n    pub const fn is_ascii_control(&self) -> bool {\n        matches!(*self, b'\\0'..=b'\\x1F' | b'\\x7F')\n    }\n\n    /// Returns an iterator that produces an escaped version of a `u8`,\n    /// treating it as an ASCII character.\n    ///\n    /// The behavior is identical to [`ascii::escape_default`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(inherent_ascii_escape)]\n    ///\n    /// assert_eq!(\"0\", b'0'.escape_ascii().to_string());\n    /// assert_eq!(\"\\\\t\", b'\\t'.escape_ascii().to_string());\n    /// assert_eq!(\"\\\\r\", b'\\r'.escape_ascii().to_string());\n    /// assert_eq!(\"\\\\n\", b'\\n'.escape_ascii().to_string());\n    /// assert_eq!(\"\\\\'\", b'\\''.escape_ascii().to_string());\n    /// assert_eq!(\"\\\\\\\"\", b'\"'.escape_ascii().to_string());\n    /// assert_eq!(\"\\\\\\\\\", b'\\\\'.escape_ascii().to_string());\n    /// assert_eq!(\"\\\\x9d\", b'\\x9d'.escape_ascii().to_string());\n    /// ```\n    #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n    #[inline]\n    pub fn escape_ascii(&self) -> ascii::EscapeDefault {\n        ascii::escape_default(*self)\n    }\n}\n\n#[lang = \"u16\"]\nimpl u16 {\n    uint_impl! { u16, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n    \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n}\n\n#[lang = \"u32\"]\nimpl u32 {\n    uint_impl! { u32, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n}\n\n#[lang = \"u64\"]\nimpl u64 {\n    uint_impl! { u64, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n    \"\", \"\"}\n}\n\n#[lang = \"u128\"]\nimpl u128 {\n    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, 16,\n    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n     \"\", \"\"}\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n    \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n#[cfg(target_pointer_width = \"32\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\n#[cfg(target_pointer_width = \"64\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\n/// A classification of floating point numbers.\n///\n/// This `enum` is used as the return type for [`f32::classify`] and [`f64::classify`]. See\n/// their documentation for more.\n///\n/// # Examples\n///\n/// ```\n/// use std::num::FpCategory;\n///\n/// let num = 12.4_f32;\n/// let inf = f32::INFINITY;\n/// let zero = 0f32;\n/// let sub: f32 = 1.1754942e-38;\n/// let nan = f32::NAN;\n///\n/// assert_eq!(num.classify(), FpCategory::Normal);\n/// assert_eq!(inf.classify(), FpCategory::Infinite);\n/// assert_eq!(zero.classify(), FpCategory::Zero);\n/// assert_eq!(nan.classify(), FpCategory::Nan);\n/// assert_eq!(sub.classify(), FpCategory::Subnormal);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum FpCategory {\n    /// \"Not a Number\", often obtained by dividing by zero.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Nan,\n\n    /// Positive or negative infinity.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Infinite,\n\n    /// Positive or negative zero.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Zero,\n\n    /// De-normalized floating point representation (less precise than `Normal`).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Subnormal,\n\n    /// A regular floating point number.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Normal,\n}\n\n#[doc(hidden)]\ntrait FromStrRadixHelper: PartialOrd + Copy {\n    fn min_value() -> Self;\n    fn max_value() -> Self;\n    fn from_u32(u: u32) -> Self;\n    fn checked_mul(&self, other: u32) -> Option<Self>;\n    fn checked_sub(&self, other: u32) -> Option<Self>;\n    fn checked_add(&self, other: u32) -> Option<Self>;\n}\n\nmacro_rules! from_str_radix_int_impl {\n    ($($t:ty)*) => {$(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl FromStr for $t {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, ParseIntError> {\n                from_str_radix(src, 10)\n            }\n        }\n    )*}\n}\nfrom_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n\nmacro_rules! doit {\n    ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n        #[inline]\n        fn min_value() -> Self { Self::MIN }\n        #[inline]\n        fn max_value() -> Self { Self::MAX }\n        #[inline]\n        fn from_u32(u: u32) -> Self { u as Self }\n        #[inline]\n        fn checked_mul(&self, other: u32) -> Option<Self> {\n            Self::checked_mul(*self, other as Self)\n        }\n        #[inline]\n        fn checked_sub(&self, other: u32) -> Option<Self> {\n            Self::checked_sub(*self, other as Self)\n        }\n        #[inline]\n        fn checked_add(&self, other: u32) -> Option<Self> {\n            Self::checked_add(*self, other as Self)\n        }\n    })*)\n}\ndoit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n\nfn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n    use self::IntErrorKind::*;\n    use self::ParseIntError as PIE;\n\n    assert!(\n        radix >= 2 && radix <= 36,\n        \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n        radix\n    );\n\n    if src.is_empty() {\n        return Err(PIE { kind: Empty });\n    }\n\n    let is_signed_ty = T::from_u32(0) > T::min_value();\n\n    // all valid digits are ascii, so we will just iterate over the utf8 bytes\n    // and cast them to chars. .to_digit() will safely return None for anything\n    // other than a valid ascii digit for the given radix, including the first-byte\n    // of multi-byte sequences\n    let src = src.as_bytes();\n\n    let (is_positive, digits) = match src[0] {\n        b'+' | b'-' if src[1..].is_empty() => {\n            return Err(PIE { kind: InvalidDigit });\n        }\n        b'+' => (true, &src[1..]),\n        b'-' if is_signed_ty => (false, &src[1..]),\n        _ => (true, src),\n    };\n\n    let mut result = T::from_u32(0);\n    if is_positive {\n        // The number is positive\n        for &c in digits {\n            let x = match (c as char).to_digit(radix) {\n                Some(x) => x,\n                None => return Err(PIE { kind: InvalidDigit }),\n            };\n            result = match result.checked_mul(radix) {\n                Some(result) => result,\n                None => return Err(PIE { kind: PosOverflow }),\n            };\n            result = match result.checked_add(x) {\n                Some(result) => result,\n                None => return Err(PIE { kind: PosOverflow }),\n            };\n        }\n    } else {\n        // The number is negative\n        for &c in digits {\n            let x = match (c as char).to_digit(radix) {\n                Some(x) => x,\n                None => return Err(PIE { kind: InvalidDigit }),\n            };\n            result = match result.checked_mul(radix) {\n                Some(result) => result,\n                None => return Err(PIE { kind: NegOverflow }),\n            };\n            result = match result.checked_sub(x) {\n                Some(result) => result,\n                None => return Err(PIE { kind: NegOverflow }),\n            };\n        }\n    }\n    Ok(result)\n}\n"],[2892,"macro_rules! int_impl {\n    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr,\n     $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n     $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n     $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, \", stringify!($Min), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = !0 ^ ((!0 as $UnsignedT) >> 1) as Self;\n\n        /// The largest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($Max), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !Self::MIN;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = $BITS;\n\n        /// Converts a string slice in a given base to an integer.\n        ///\n        /// The string is expected to be an optional `+` or `-` sign followed by digits.\n        /// Leading and trailing whitespace represent an error. Digits are a subset of these characters,\n        /// depending on `radix`:\n        ///\n        ///  * `0-9`\n        ///  * `a-z`\n        ///  * `A-Z`\n        ///\n        /// # Panics\n        ///\n        /// This function panics if `radix` is not in the range from 2 to 36.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n            from_str_radix(src, radix)\n        }\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b100_0000\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.count_ones(), 1);\n        /// ```\n        ///\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.count_zeros(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.leading_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            (self as $UnsignedT).leading_zeros()\n        }\n\n        /// Returns the number of trailing zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -4\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_zeros(), 2);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            (self as $UnsignedT).trailing_zeros()\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (self as $UnsignedT).leading_ones()\n        }\n\n        /// Returns the number of trailing ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 3\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_ones(), 2);\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (self as $UnsignedT).trailing_ones()\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_left(n) as Self\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_right(n) as Self\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        ///\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            (self as $UnsignedT).swap_bytes() as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.37.0\")]\n        #[inline(always)]\n        #[must_use]\n        pub const fn reverse_bits(self) -> Self {\n            (self as $UnsignedT).reverse_bits() as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[inline]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[inline]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[inline]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[inline]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), Some(\", stringify!($SelfT), \"::MAX - 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_add`.\n            unsafe { intrinsics::unchecked_add(self, rhs) }\n        }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(1), Some(\", stringify!($SelfT), \"::MIN + 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_sub`.\n            unsafe { intrinsics::unchecked_sub(self, rhs) }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(1), Some(\", stringify!($SelfT), \"::MAX));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_mul`.\n            unsafe { intrinsics::unchecked_mul(self, rhs) }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\n        /// or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// returning `None` if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div_euclid(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None` if\n        /// `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_neg(), Some(-5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shl(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_shl(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_shl`.\n            unsafe { intrinsics::unchecked_shl(self, rhs) }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shr(rhs);\n            if unlikely!(b) {None} else {Some(a)}\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_math\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n        #[inline(always)]\n        pub const unsafe fn unchecked_shr(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_shr`.\n            unsafe { intrinsics::unchecked_shr(self, rhs) }\n        }\n\n        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n        /// `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").checked_abs(), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[inline]\n        pub const fn checked_abs(self) -> Option<Self> {\n            if self.is_negative() {\n                self.checked_neg()\n            } else {\n                Some(self)\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n            // since exp!=0, finally the exp must be 1.\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            Some(try_opt!(acc.checked_mul(base)))\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n        /// bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(100), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_add(-1), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub(100), \", stringify!($SelfT), \"::MIN);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_sub(-1), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\n        /// instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_neg(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_neg(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_neg(), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_neg(self) -> Self {\n            intrinsics::saturating_sub(0, self)\n        }\n\n        /// Saturating absolute value. Computes `self.abs()`, returning `MAX` if `self ==\n        /// MIN` instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline]\n        pub const fn saturating_abs(self) -> Self {\n            if self.is_negative() {\n                self.saturating_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".saturating_mul(12), 120);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(10), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => if (self < 0) == (rhs < 0) {\n                    Self::MAX\n                } else {\n                    Self::MIN\n                }\n            }\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None if self < 0 && exp % 2 == 1 => Self::MIN,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\")]\n        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub(\", stringify!($SelfT), \"::MAX), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\")]\n        /// assert_eq!(11i8.wrapping_mul(12), -124);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self.overflowing_div(rhs).0\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). This is equivalent to `-MIN`, a positive value that is too large to represent in the\n        /// type. In this case, this method returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self.overflowing_div_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// Such wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\n        /// invalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\n        /// this function returns `0`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self.overflowing_rem(rhs).0\n        }\n\n        /// Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\n        /// at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). In this case, this method returns 0.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self.overflowing_rem_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n        /// of the type.\n        ///\n        /// The only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\n        /// is the negative minimal value for the type); this is a positive value that is too large to represent\n        /// in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_neg(), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline]\n        pub const fn wrapping_neg(self) -> Self {\n            self.overflowing_neg().0\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\n        /// any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\n        /// the range of the type, rather than the bits shifted out of the LHS being returned to the other end.\n        /// The primitive integer types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\")]\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\n        /// removes any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\n        /// to the range of the type, rather than the bits shifted out of the LHS being returned to the other\n        /// end. The primitive integer types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\")]\n        /// assert_eq!((-128i16).wrapping_shr(64), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n            }\n        }\n\n        /// Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one takes the absolute value of the negative\n        /// minimal value for the type; this is a positive value that is too large to represent in the type. In\n        /// such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_abs(), \", stringify!($SelfT), \"::MIN);\")]\n        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[allow(unused_attributes)]\n        #[inline]\n        pub const fn wrapping_abs(self) -> Self {\n             if self.is_negative() {\n                 self.wrapping_neg()\n             } else {\n                 self\n             }\n        }\n\n        /// Computes the absolute value of `self` without any wrapping\n        /// or panicking.\n        ///\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        /// assert_eq!((-128i8).unsigned_abs(), 128u8);\n        /// ```\n        #[stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[rustc_const_stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[inline]\n        pub const fn unsigned_abs(self) -> $UnsignedT {\n             self.wrapping_abs() as $UnsignedT\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\")]\n        /// assert_eq!(3i8.wrapping_pow(5), -13);\n        /// assert_eq!(3i8.wrapping_pow(6), -39);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = acc.wrapping_mul(base);\n                }\n                exp /= 2;\n                base = base.wrapping_mul(base);\n            }\n\n            // since exp!=0, finally the exp must be 1.\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            acc.wrapping_mul(base)\n        }\n\n        /// Calculates `self` + `rhs`\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` - `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\")]\n        /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then self is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            if unlikely!(self == Self::MIN && rhs == -1) {\n                (self, true)\n            } else {\n                (self / rhs, false)\n            }\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then `self` is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            if unlikely!(self == Self::MIN && rhs == -1) {\n                (self, true)\n            } else {\n                (self.div_euclid(rhs), false)\n            }\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            if unlikely!(self == Self::MIN && rhs == -1) {\n                (0, true)\n            } else {\n                (self % rhs, false)\n            }\n        }\n\n\n        /// Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            if unlikely!(self == Self::MIN && rhs == -1) {\n                (0, true)\n            } else {\n                (self.rem_euclid(rhs), false)\n            }\n        }\n\n\n        /// Negates self, overflowing if this is equal to the minimum value.\n        ///\n        /// Returns a tuple of the negated version of self along with a boolean indicating whether an overflow\n        /// happened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\n        /// minimum value will be returned again and `true` will be returned for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[allow(unused_attributes)]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            if unlikely!(self == Self::MIN) {\n                (Self::MIN, true)\n            } else {\n                (-self, false)\n            }\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT),\".overflowing_shl(4), (0x10, false));\")]\n        /// assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow\n        /// happened. If self is the minimum value\n        #[doc = concat!(\"(e.g., \", stringify!($SelfT), \"::MIN for values of type \", stringify!($SelfT), \"),\")]\n        /// then the minimum value will be returned again and true will be returned\n        /// for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_abs(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline]\n        pub const fn overflowing_abs(self) -> (Self, bool) {\n            (self.wrapping_abs(), self == Self::MIN)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\")]\n        /// assert_eq!(3i8.overflowing_pow(5), (-13, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0 {\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n\n            // since exp!=0, finally the exp must be 1.\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            r = acc.overflowing_mul(base);\n            r.1 |= overflown;\n            r\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let x: \", stringify!($SelfT), \" = 2; // or any other integer type\")]\n        ///\n        /// assert_eq!(x.pow(5), 32);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            while exp > 1 {\n                if (exp & 1) == 1 {\n                    acc = acc * base;\n                }\n                exp /= 2;\n                base = base * base;\n            }\n\n            // since exp!=0, finally the exp must be 1.\n            // Deal with the final bit of the exponent separately, since\n            // squaring the base afterwards is not necessary and may cause a\n            // needless overflow.\n            acc * base\n        }\n\n        /// Calculates the quotient of Euclidean division of `self` by `rhs`.\n        ///\n        /// This computes the integer `q` such that `self = q * rhs + r`, with\n        /// `r = self.rem_euclid(rhs)` and `0 <= r < abs(rhs)`.\n        ///\n        /// In other words, the result is `self / rhs` rounded to the integer `q`\n        /// such that `self >= q * rhs`.\n        /// If `self > 0`, this is equal to round towards zero (the default in Rust);\n        /// if `self < 0`, this is equal to round towards +/- infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0 or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\n        /// assert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\n        /// assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n        /// assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            let q = self / rhs;\n            if self % rhs < 0 {\n                return if rhs > 0 { q - 1 } else { q + 1 }\n            }\n            q\n        }\n\n\n        /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n        ///\n        /// This is done as if by the Euclidean division algorithm -- given\n        /// `r = self.rem_euclid(rhs)`, `self = rhs * self.div_euclid(rhs) + r`, and\n        /// `0 <= r < abs(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is 0 or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.rem_euclid(b), 3);\n        /// assert_eq!((-a).rem_euclid(b), 1);\n        /// assert_eq!(a.rem_euclid(-b), 3);\n        /// assert_eq!((-a).rem_euclid(-b), 1);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            let r = self % rhs;\n            if r < 0 {\n                if rhs < 0 {\n                    r - rhs\n                } else {\n                    r + rhs\n                }\n            } else {\n                r\n            }\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// # Overflow behavior\n        ///\n        /// The absolute value of\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// cannot be represented as an\n        #[doc = concat!(\"`\", stringify!($SelfT), \"`,\")]\n        /// and attempting to calculate it will cause an overflow. This means\n        /// that code in debug mode will trigger a panic on this case and\n        /// optimized code will return\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// without a panic.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[allow(unused_attributes)]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn abs(self) -> Self {\n            // Note that the #[rustc_inherit_overflow_checks] and #[inline]\n            // above mean that the overflow semantics of the subtraction\n            // depend on the crate we're being called from.\n            if self.is_negative() {\n                -self\n            } else {\n                self\n            }\n        }\n\n        /// Returns a number representing sign of `self`.\n        ///\n        ///  - `0` if the number is zero\n        ///  - `1` if the number is positive\n        ///  - `-1` if the number is negative\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".signum(), 0);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_sign\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn signum(self) -> Self {\n            match self {\n                n if n > 0 =>  1,\n                0          =>  0,\n                _          => -1,\n            }\n        }\n\n        /// Returns `true` if `self` is positive and `false` if the number is zero or\n        /// negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(10\", stringify!($SelfT), \".is_positive());\")]\n        #[doc = concat!(\"assert!(!(-10\", stringify!($SelfT), \").is_positive());\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_positive(self) -> bool { self > 0 }\n\n        /// Returns `true` if `self` is negative and `false` if the number is zero or\n        /// positive.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!((-10\", stringify!($SelfT), \").is_negative());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_negative());\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_negative(self) -> bool { self < 0 }\n\n        /// Return the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Return the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Return the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[rustc_allow_const_fn_unstable(const_fn_transmute)]\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Create an integer value from its representation as a byte array in\n        /// big endian.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        /// use std::convert::TryInto;\n        ///\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Create an integer value from its representation as a byte array in\n        /// little endian.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        /// use std::convert::TryInto;\n        ///\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Create an integer value from its memory representation as a byte\n        /// array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes)]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes)]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        /// use std::convert::TryInto;\n        ///\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[rustc_allow_const_fn_unstable(const_fn_transmute)]\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n        #[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MIN` associated constant on this type\")]\n        pub const fn min_value() -> Self {\n            Self::MIN\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[rustc_deprecated(since = \"TBD\", reason = \"replaced by the `MAX` associated constant on this type\")]\n        pub const fn max_value() -> Self {\n            Self::MAX\n        }\n    }\n}\n"],[2893,"//! Error types for conversion to integral types.\n\nuse crate::convert::Infallible;\nuse crate::fmt;\n\n/// The error type returned when a checked integral type conversion fails.\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub struct TryFromIntError(pub(crate) ());\n\nimpl TryFromIntError {\n    #[unstable(\n        feature = \"int_error_internals\",\n        reason = \"available through Error trait and this method should \\\n                  not be exposed publicly\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        \"out of range integral type conversion attempted\"\n    }\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl fmt::Display for TryFromIntError {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.__description().fmt(fmt)\n    }\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl From<Infallible> for TryFromIntError {\n    fn from(x: Infallible) -> TryFromIntError {\n        match x {}\n    }\n}\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl From<!> for TryFromIntError {\n    fn from(never: !) -> TryFromIntError {\n        // Match rather than coerce to make sure that code like\n        // `From<Infallible> for TryFromIntError` above will keep working\n        // when `Infallible` becomes an alias to `!`.\n        match never {}\n    }\n}\n\n/// An error which can be returned when parsing an integer.\n///\n/// This error is used as the error type for the `from_str_radix()` functions\n/// on the primitive integer types, such as [`i8::from_str_radix`].\n///\n/// # Potential causes\n///\n/// Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace\n/// in the string e.g., when it is obtained from the standard input.\n/// Using the [`str::trim()`] method ensures that no whitespace remains before parsing.\n///\n/// # Example\n///\n/// ```\n/// if let Err(e) = i32::from_str_radix(\"a12\", 10) {\n///     println!(\"Failed conversion to i32: {}\", e);\n/// }\n/// ```\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ParseIntError {\n    pub(super) kind: IntErrorKind,\n}\n\n/// Enum to store the various types of errors that can cause parsing an integer to fail.\n///\n/// # Example\n///\n/// ```\n/// # fn main() {\n/// if let Err(e) = i32::from_str_radix(\"a12\", 10) {\n///     println!(\"Failed conversion to i32: {:?}\", e.kind());\n/// }\n/// # }\n/// ```\n#[stable(feature = \"int_error_matching\", since = \"1.55.0\")]\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[non_exhaustive]\npub enum IntErrorKind {\n    /// Value being parsed is empty.\n    ///\n    /// This variant will be constructed when parsing an empty string.\n    #[stable(feature = \"int_error_matching\", since = \"1.55.0\")]\n    Empty,\n    /// Contains an invalid digit in its context.\n    ///\n    /// Among other causes, this variant will be constructed when parsing a string that\n    /// contains a non-ASCII char.\n    ///\n    /// This variant is also constructed when a `+` or `-` is misplaced within a string\n    /// either on its own or in the middle of a number.\n    #[stable(feature = \"int_error_matching\", since = \"1.55.0\")]\n    InvalidDigit,\n    /// Integer is too large to store in target integer type.\n    #[stable(feature = \"int_error_matching\", since = \"1.55.0\")]\n    PosOverflow,\n    /// Integer is too small to store in target integer type.\n    #[stable(feature = \"int_error_matching\", since = \"1.55.0\")]\n    NegOverflow,\n    /// Value was Zero\n    ///\n    /// This variant will be emitted when the parsing string has a value of zero, which\n    /// would be illegal for non-zero types.\n    #[stable(feature = \"int_error_matching\", since = \"1.55.0\")]\n    Zero,\n}\n\nimpl ParseIntError {\n    /// Outputs the detailed cause of parsing an integer failing.\n    #[stable(feature = \"int_error_matching\", since = \"1.55.0\")]\n    pub fn kind(&self) -> &IntErrorKind {\n        &self.kind\n    }\n    #[unstable(\n        feature = \"int_error_internals\",\n        reason = \"available through Error trait and this method should \\\n                  not be exposed publicly\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        match self.kind {\n            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n            IntErrorKind::PosOverflow => \"number too large to fit in target type\",\n            IntErrorKind::NegOverflow => \"number too small to fit in target type\",\n            IntErrorKind::Zero => \"number would be zero for non-zero type\",\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for ParseIntError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.__description().fmt(f)\n    }\n}\n"],[2894,"//! Definitions of `Wrapping<T>`.\n\nuse crate::fmt;\nuse crate::ops::{Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign};\nuse crate::ops::{BitXor, BitXorAssign, Div, DivAssign};\nuse crate::ops::{Mul, MulAssign, Neg, Not, Rem, RemAssign};\nuse crate::ops::{Shl, ShlAssign, Shr, ShrAssign, Sub, SubAssign};\n\n/// Provides intentionally-wrapped arithmetic on `T`.\n///\n/// Operations like `+` on `u32` values are intended to never overflow,\n/// and in some debug configurations overflow is detected and results\n/// in a panic. While most arithmetic falls into this category, some\n/// code explicitly expects and relies upon modular arithmetic (e.g.,\n/// hashing).\n///\n/// Wrapping arithmetic can be achieved either through methods like\n/// `wrapping_add`, or through the `Wrapping<T>` type, which says that\n/// all standard arithmetic operations on the underlying value are\n/// intended to have wrapping semantics.\n///\n/// The underlying value can be retrieved through the `.0` index of the\n/// `Wrapping` tuple.\n///\n/// # Examples\n///\n/// ```\n/// use std::num::Wrapping;\n///\n/// let zero = Wrapping(0u32);\n/// let one = Wrapping(1u32);\n///\n/// assert_eq!(u32::MAX, (zero - one).0);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n#[repr(transparent)]\npub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_display\", since = \"1.10.0\")]\nimpl<T: fmt::Display> fmt::Display for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::Binary> fmt::Binary for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::Octal> fmt::Octal for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::LowerHex> fmt::LowerHex for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::UpperHex> fmt::UpperHex for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! sh_impl_signed {\n    ($t:ident, $f:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shl<$f> for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn shl(self, other: $f) -> Wrapping<$t> {\n                if other < 0 {\n                    Wrapping(self.0.wrapping_shr((-other & self::shift_max::$t as $f) as u32))\n                } else {\n                    Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))\n                }\n            }\n        }\n        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShlAssign<$f> for Wrapping<$t> {\n            #[inline]\n            fn shl_assign(&mut self, other: $f) {\n                *self = *self << other;\n            }\n        }\n        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shr<$f> for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn shr(self, other: $f) -> Wrapping<$t> {\n                if other < 0 {\n                    Wrapping(self.0.wrapping_shl((-other & self::shift_max::$t as $f) as u32))\n                } else {\n                    Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))\n                }\n            }\n        }\n        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShrAssign<$f> for Wrapping<$t> {\n            #[inline]\n            fn shr_assign(&mut self, other: $f) {\n                *self = *self >> other;\n            }\n        }\n        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n    };\n}\n\nmacro_rules! sh_impl_unsigned {\n    ($t:ident, $f:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shl<$f> for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn shl(self, other: $f) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))\n            }\n        }\n        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShlAssign<$f> for Wrapping<$t> {\n            #[inline]\n            fn shl_assign(&mut self, other: $f) {\n                *self = *self << other;\n            }\n        }\n        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shr<$f> for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn shr(self, other: $f) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))\n            }\n        }\n        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShrAssign<$f> for Wrapping<$t> {\n            #[inline]\n            fn shr_assign(&mut self, other: $f) {\n                *self = *self >> other;\n            }\n        }\n        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n    };\n}\n\n// FIXME (#23545): uncomment the remaining impls\nmacro_rules! sh_impl_all {\n    ($($t:ident)*) => ($(\n        //sh_impl_unsigned! { $t, u8 }\n        //sh_impl_unsigned! { $t, u16 }\n        //sh_impl_unsigned! { $t, u32 }\n        //sh_impl_unsigned! { $t, u64 }\n        //sh_impl_unsigned! { $t, u128 }\n        sh_impl_unsigned! { $t, usize }\n\n        //sh_impl_signed! { $t, i8 }\n        //sh_impl_signed! { $t, i16 }\n        //sh_impl_signed! { $t, i32 }\n        //sh_impl_signed! { $t, i64 }\n        //sh_impl_signed! { $t, i128 }\n        //sh_impl_signed! { $t, isize }\n    )*)\n}\n\nsh_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n\n// FIXME(30524): impl Op<T> for Wrapping<T>, impl OpAssign<T> for Wrapping<T>\nmacro_rules! wrapping_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Add for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_add(other.0))\n            }\n        }\n        forward_ref_binop! { impl Add, add for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl AddAssign for Wrapping<$t> {\n            #[inline]\n            fn add_assign(&mut self, other: Wrapping<$t>) {\n                *self = *self + other;\n            }\n        }\n        forward_ref_op_assign! { impl AddAssign, add_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Sub for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_sub(other.0))\n            }\n        }\n        forward_ref_binop! { impl Sub, sub for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl SubAssign for Wrapping<$t> {\n            #[inline]\n            fn sub_assign(&mut self, other: Wrapping<$t>) {\n                *self = *self - other;\n            }\n        }\n        forward_ref_op_assign! { impl SubAssign, sub_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Mul for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_mul(other.0))\n            }\n        }\n        forward_ref_binop! { impl Mul, mul for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl MulAssign for Wrapping<$t> {\n            #[inline]\n            fn mul_assign(&mut self, other: Wrapping<$t>) {\n                *self = *self * other;\n            }\n        }\n        forward_ref_op_assign! { impl MulAssign, mul_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"wrapping_div\", since = \"1.3.0\")]\n        impl Div for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_div(other.0))\n            }\n        }\n        forward_ref_binop! { impl Div, div for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl DivAssign for Wrapping<$t> {\n            #[inline]\n            fn div_assign(&mut self, other: Wrapping<$t>) {\n                *self = *self / other;\n            }\n        }\n        forward_ref_op_assign! { impl DivAssign, div_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n        impl Rem for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_rem(other.0))\n            }\n        }\n        forward_ref_binop! { impl Rem, rem for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl RemAssign for Wrapping<$t> {\n            #[inline]\n            fn rem_assign(&mut self, other: Wrapping<$t>) {\n                *self = *self % other;\n            }\n        }\n        forward_ref_op_assign! { impl RemAssign, rem_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Not for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn not(self) -> Wrapping<$t> {\n                Wrapping(!self.0)\n            }\n        }\n        forward_ref_unop! { impl Not, not for Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitXor for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0 ^ other.0)\n            }\n        }\n        forward_ref_binop! { impl BitXor, bitxor for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitXorAssign for Wrapping<$t> {\n            #[inline]\n            fn bitxor_assign(&mut self, other: Wrapping<$t>) {\n                *self = *self ^ other;\n            }\n        }\n        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitOr for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0 | other.0)\n            }\n        }\n        forward_ref_binop! { impl BitOr, bitor for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitOrAssign for Wrapping<$t> {\n            #[inline]\n            fn bitor_assign(&mut self, other: Wrapping<$t>) {\n                *self = *self | other;\n            }\n        }\n        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitAnd for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0 & other.0)\n            }\n        }\n        forward_ref_binop! { impl BitAnd, bitand for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitAndAssign for Wrapping<$t> {\n            #[inline]\n            fn bitand_assign(&mut self, other: Wrapping<$t>) {\n                *self = *self & other;\n            }\n        }\n        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"wrapping_neg\", since = \"1.10.0\")]\n        impl Neg for Wrapping<$t> {\n            type Output = Self;\n            #[inline]\n            fn neg(self) -> Self {\n                Wrapping(0) - self\n            }\n        }\n        forward_ref_unop! { impl Neg, neg for Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n    )*)\n}\n\nwrapping_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\nmacro_rules! wrapping_int_impl {\n    ($($t:ty)*) => ($(\n        impl Wrapping<$t> {\n            /// Returns the smallest value that can be represented by this integer type.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(<Wrapping<\", stringify!($t), \">>::MIN, Wrapping(\", stringify!($t), \"::MIN));\")]\n            /// ```\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const MIN: Self = Self(<$t>::MIN);\n\n            /// Returns the largest value that can be represented by this integer type.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(<Wrapping<\", stringify!($t), \">>::MAX, Wrapping(\", stringify!($t), \"::MAX));\")]\n            /// ```\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const MAX: Self = Self(<$t>::MAX);\n\n            /// Returns the size of this integer type in bits.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(<Wrapping<\", stringify!($t), \">>::BITS, \", stringify!($t), \"::BITS);\")]\n            /// ```\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const BITS: u32 = <$t>::BITS;\n\n            /// Returns the number of ones in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0b01001100\", stringify!($t), \");\")]\n            ///\n            /// assert_eq!(n.count_ones(), 3);\n            /// ```\n            #[inline]\n            #[doc(alias = \"popcount\")]\n            #[doc(alias = \"popcnt\")]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn count_ones(self) -> u32 {\n                self.0.count_ones()\n            }\n\n            /// Returns the number of zeros in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(Wrapping(!0\", stringify!($t), \").count_zeros(), 0);\")]\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn count_zeros(self) -> u32 {\n                self.0.count_zeros()\n            }\n\n            /// Returns the number of trailing zeros in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0b0101000\", stringify!($t), \");\")]\n            ///\n            /// assert_eq!(n.trailing_zeros(), 3);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn trailing_zeros(self) -> u32 {\n                self.0.trailing_zeros()\n            }\n\n            /// Shifts the bits to the left by a specified amount, `n`,\n            /// wrapping the truncated bits to the end of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `<<` shifting\n            /// operator!\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n            /// let m: Wrapping<i64> = Wrapping(-0x76543210FEDCBA99);\n            ///\n            /// assert_eq!(n.rotate_left(32), m);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn rotate_left(self, n: u32) -> Self {\n                Wrapping(self.0.rotate_left(n))\n            }\n\n            /// Shifts the bits to the right by a specified amount, `n`,\n            /// wrapping the truncated bits to the beginning of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `>>` shifting\n            /// operator!\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n            /// let m: Wrapping<i64> = Wrapping(-0xFEDCBA987654322);\n            ///\n            /// assert_eq!(n.rotate_right(4), m);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn rotate_right(self, n: u32) -> Self {\n                Wrapping(self.0.rotate_right(n))\n            }\n\n            /// Reverses the byte order of the integer.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// let n: Wrapping<i16> = Wrapping(0b0000000_01010101);\n            /// assert_eq!(n, Wrapping(85));\n            ///\n            /// let m = n.swap_bytes();\n            ///\n            /// assert_eq!(m, Wrapping(0b01010101_00000000));\n            /// assert_eq!(m, Wrapping(21760));\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn swap_bytes(self) -> Self {\n                Wrapping(self.0.swap_bytes())\n            }\n\n            /// Reverses the bit pattern of the integer.\n            ///\n            /// # Examples\n            ///\n            /// Please note that this example is shared between integer types.\n            /// Which explains why `i16` is used here.\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// use std::num::Wrapping;\n            ///\n            /// let n = Wrapping(0b0000000_01010101i16);\n            /// assert_eq!(n, Wrapping(85));\n            ///\n            /// let m = n.reverse_bits();\n            ///\n            /// assert_eq!(m.0 as u16, 0b10101010_00000000);\n            /// assert_eq!(m, Wrapping(-22016));\n            /// ```\n            #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n            #[rustc_const_stable(feature = \"const_reverse_bits\", since = \"1.37.0\")]\n            #[inline]\n            #[must_use]\n            pub const fn reverse_bits(self) -> Self {\n                Wrapping(self.0.reverse_bits())\n            }\n\n            /// Converts an integer from big endian to the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n.swap_bytes())\")]\n            /// }\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn from_be(x: Self) -> Self {\n                Wrapping(<$t>::from_be(x.0))\n            }\n\n            /// Converts an integer from little endian to the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n)\")]\n            /// } else {\n            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n.swap_bytes())\")]\n            /// }\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn from_le(x: Self) -> Self {\n                Wrapping(<$t>::from_le(x.0))\n            }\n\n            /// Converts `self` to big endian from the target's endianness.\n            ///\n            /// On big endian this is a no-op. On little endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n            ///\n            /// if cfg!(target_endian = \"big\") {\n            ///     assert_eq!(n.to_be(), n)\n            /// } else {\n            ///     assert_eq!(n.to_be(), n.swap_bytes())\n            /// }\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn to_be(self) -> Self {\n                Wrapping(self.0.to_be())\n            }\n\n            /// Converts `self` to little endian from the target's endianness.\n            ///\n            /// On little endian this is a no-op. On big endian the bytes are\n            /// swapped.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n            ///\n            /// if cfg!(target_endian = \"little\") {\n            ///     assert_eq!(n.to_le(), n)\n            /// } else {\n            ///     assert_eq!(n.to_le(), n.swap_bytes())\n            /// }\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn to_le(self) -> Self {\n                Wrapping(self.0.to_le())\n            }\n\n            /// Raises self to the power of `exp`, using exponentiation by squaring.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(Wrapping(3\", stringify!($t), \").pow(4), Wrapping(81));\")]\n            /// ```\n            ///\n            /// Results that are too large are wrapped:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// assert_eq!(Wrapping(3i8).pow(5), Wrapping(-13));\n            /// assert_eq!(Wrapping(3i8).pow(6), Wrapping(-39));\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub fn pow(self, exp: u32) -> Self {\n                Wrapping(self.0.wrapping_pow(exp))\n            }\n        }\n    )*)\n}\n\nwrapping_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\nmacro_rules! wrapping_int_impl_signed {\n    ($($t:ty)*) => ($(\n        impl Wrapping<$t> {\n            /// Returns the number of leading zeros in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\")]\n            ///\n            /// assert_eq!(n.leading_zeros(), 3);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn leading_zeros(self) -> u32 {\n                self.0.leading_zeros()\n            }\n\n            /// Computes the absolute value of `self`, wrapping around at\n            /// the boundary of the type.\n            ///\n            /// The only case where such wrapping can occur is when one takes the absolute value of the negative\n            /// minimal value for the type this is a positive value that is too large to represent in the type. In\n            /// such a case, this function returns `MIN` itself.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(Wrapping(100\", stringify!($t), \").abs(), Wrapping(100));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(-100\", stringify!($t), \").abs(), Wrapping(100));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(\", stringify!($t), \"::MIN).abs(), Wrapping(\", stringify!($t), \"::MIN));\")]\n            /// assert_eq!(Wrapping(-128i8).abs().0 as u8, 128u8);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub fn abs(self) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_abs())\n            }\n\n            /// Returns a number representing sign of `self`.\n            ///\n            ///  - `0` if the number is zero\n            ///  - `1` if the number is positive\n            ///  - `-1` if the number is negative\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(Wrapping(10\", stringify!($t), \").signum(), Wrapping(1));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(0\", stringify!($t), \").signum(), Wrapping(0));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(-10\", stringify!($t), \").signum(), Wrapping(-1));\")]\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub fn signum(self) -> Wrapping<$t> {\n                Wrapping(self.0.signum())\n            }\n\n            /// Returns `true` if `self` is positive and `false` if the number is zero or\n            /// negative.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert!(Wrapping(10\", stringify!($t), \").is_positive());\")]\n            #[doc = concat!(\"assert!(!Wrapping(-10\", stringify!($t), \").is_positive());\")]\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn is_positive(self) -> bool {\n                self.0.is_positive()\n            }\n\n            /// Returns `true` if `self` is negative and `false` if the number is zero or\n            /// positive.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert!(Wrapping(-10\", stringify!($t), \").is_negative());\")]\n            #[doc = concat!(\"assert!(!Wrapping(10\", stringify!($t), \").is_negative());\")]\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn is_negative(self) -> bool {\n                self.0.is_negative()\n            }\n        }\n    )*)\n}\n\nwrapping_int_impl_signed! { isize i8 i16 i32 i64 i128 }\n\nmacro_rules! wrapping_int_impl_unsigned {\n    ($($t:ty)*) => ($(\n        impl Wrapping<$t> {\n            /// Returns the number of leading zeros in the binary representation of `self`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\")]\n            ///\n            /// assert_eq!(n.leading_zeros(), 2);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn leading_zeros(self) -> u32 {\n                self.0.leading_zeros()\n            }\n\n            /// Returns `true` if and only if `self == 2^k` for some `k`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert!(Wrapping(16\", stringify!($t), \").is_power_of_two());\")]\n            #[doc = concat!(\"assert!(!Wrapping(10\", stringify!($t), \").is_power_of_two());\")]\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub fn is_power_of_two(self) -> bool {\n                self.0.is_power_of_two()\n            }\n\n            /// Returns the smallest power of two greater than or equal to `self`.\n            ///\n            /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n            /// `uN`), overflows to `2^N = 0`.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_next_power_of_two)]\n            /// use std::num::Wrapping;\n            ///\n            #[doc = concat!(\"assert_eq!(Wrapping(2\", stringify!($t), \").next_power_of_two(), Wrapping(2));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(3\", stringify!($t), \").next_power_of_two(), Wrapping(4));\")]\n            #[doc = concat!(\"assert_eq!(Wrapping(200_u8).next_power_of_two(), Wrapping(0));\")]\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                       reason = \"needs decision on wrapping behaviour\")]\n            pub fn next_power_of_two(self) -> Self {\n                Wrapping(self.0.wrapping_next_power_of_two())\n            }\n        }\n    )*)\n}\n\nwrapping_int_impl_unsigned! { usize u8 u16 u32 u64 u128 }\n\nmod shift_max {\n    #![allow(non_upper_case_globals)]\n\n    #[cfg(target_pointer_width = \"16\")]\n    mod platform {\n        pub const usize: u32 = super::u16;\n        pub const isize: u32 = super::i16;\n    }\n\n    #[cfg(target_pointer_width = \"32\")]\n    mod platform {\n        pub const usize: u32 = super::u32;\n        pub const isize: u32 = super::i32;\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    mod platform {\n        pub const usize: u32 = super::u64;\n        pub const isize: u32 = super::i64;\n    }\n\n    pub const i8: u32 = (1 << 3) - 1;\n    pub const i16: u32 = (1 << 4) - 1;\n    pub const i32: u32 = (1 << 5) - 1;\n    pub const i64: u32 = (1 << 6) - 1;\n    pub const i128: u32 = (1 << 7) - 1;\n    pub use self::platform::isize;\n\n    pub const u8: u32 = i8;\n    pub const u16: u32 = i16;\n    pub const u32: u32 = i32;\n    pub const u64: u32 = i64;\n    pub const u128: u32 = i128;\n    pub use self::platform::usize;\n}\n"],[2895,"use crate::iter::FromIterator;\n\n/// Collapses all unit items from an iterator into one.\n///\n/// This is more useful when combined with higher-level abstractions, like\n/// collecting to a `Result<(), E>` where you only care about errors:\n///\n/// ```\n/// use std::io::*;\n/// let data = vec![1, 2, 3, 4, 5];\n/// let res: Result<()> = data.iter()\n///     .map(|x| writeln!(stdout(), \"{}\", x))\n///     .collect();\n/// assert!(res.is_ok());\n/// ```\n#[stable(feature = \"unit_from_iter\", since = \"1.23.0\")]\nimpl FromIterator<()> for () {\n    fn from_iter<I: IntoIterator<Item = ()>>(iter: I) -> Self {\n        iter.into_iter().for_each(|()| {})\n    }\n}\n"],[2896,"#![stable(feature = \"core_hint\", since = \"1.27.0\")]\n\n//! Hints to compiler that affects how code should be emitted or optimized.\n//! Hints may be compile time or runtime.\n\nuse crate::intrinsics;\n\n/// Informs the compiler that this point in the code is not reachable, enabling\n/// further optimizations.\n///\n/// # Safety\n///\n/// Reaching this function is completely *undefined behavior* (UB). In\n/// particular, the compiler assumes that all UB must never happen, and\n/// therefore will eliminate all branches that reach to a call to\n/// `unreachable_unchecked()`.\n///\n/// Like all instances of UB, if this assumption turns out to be wrong, i.e., the\n/// `unreachable_unchecked()` call is actually reachable among all possible\n/// control flow, the compiler will apply the wrong optimization strategy, and\n/// may sometimes even corrupt seemingly unrelated code, causing\n/// difficult-to-debug problems.\n///\n/// Use this function only when you can prove that the code will never call it.\n/// Otherwise, consider using the [`unreachable!`] macro, which does not allow\n/// optimizations but will panic when executed.\n///\n/// # Example\n///\n/// ```\n/// fn div_1(a: u32, b: u32) -> u32 {\n///     use std::hint::unreachable_unchecked;\n///\n///     // `b.saturating_add(1)` is always positive (not zero),\n///     // hence `checked_div` will never return `None`.\n///     // Therefore, the else branch is unreachable.\n///     a.checked_div(b.saturating_add(1))\n///         .unwrap_or_else(|| unsafe { unreachable_unchecked() })\n/// }\n///\n/// assert_eq!(div_1(7, 0), 7);\n/// assert_eq!(div_1(9, 1), 4);\n/// assert_eq!(div_1(11, u32::MAX), 0);\n/// ```\n#[inline]\n#[stable(feature = \"unreachable\", since = \"1.27.0\")]\n#[rustc_const_unstable(feature = \"const_unreachable_unchecked\", issue = \"53188\")]\npub const unsafe fn unreachable_unchecked() -> ! {\n    // SAFETY: the safety contract for `intrinsics::unreachable` must\n    // be upheld by the caller.\n    unsafe { intrinsics::unreachable() }\n}\n\n/// Emits a machine instruction to signal the processor that it is running in\n/// a busy-wait spin-loop (\"spin lock\").\n///\n/// Upon receiving the spin-loop signal the processor can optimize its behavior by,\n/// for example, saving power or switching hyper-threads.\n///\n/// This function is different from [`thread::yield_now`] which directly\n/// yields to the system's scheduler, whereas `spin_loop` does not interact\n/// with the operating system.\n///\n/// A common use case for `spin_loop` is implementing bounded optimistic\n/// spinning in a CAS loop in synchronization primitives. To avoid problems\n/// like priority inversion, it is strongly recommended that the spin loop is\n/// terminated after a finite amount of iterations and an appropriate blocking\n/// syscall is made.\n///\n/// **Note**: On platforms that do not support receiving spin-loop hints this\n/// function does not do anything at all.\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::atomic::{AtomicBool, Ordering};\n/// use std::sync::Arc;\n/// use std::{hint, thread};\n///\n/// // A shared atomic value that threads will use to coordinate\n/// let live = Arc::new(AtomicBool::new(false));\n///\n/// // In a background thread we'll eventually set the value\n/// let bg_work = {\n///     let live = live.clone();\n///     thread::spawn(move || {\n///         // Do some work, then make the value live\n///         do_some_work();\n///         live.store(true, Ordering::Release);\n///     })\n/// };\n///\n/// // Back on our current thread, we wait for the value to be set\n/// while !live.load(Ordering::Acquire) {\n///     // The spin loop is a hint to the CPU that we're waiting, but probably\n///     // not for very long\n///     hint::spin_loop();\n/// }\n///\n/// // The value is now set\n/// # fn do_some_work() {}\n/// do_some_work();\n/// bg_work.join()?;\n/// # Ok::<(), Box<dyn core::any::Any + Send + 'static>>(())\n/// ```\n///\n/// [`thread::yield_now`]: ../../std/thread/fn.yield_now.html\n#[inline]\n#[stable(feature = \"renamed_spin_loop\", since = \"1.49.0\")]\npub fn spin_loop() {\n    #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"), target_feature = \"sse2\"))]\n    {\n        #[cfg(target_arch = \"x86\")]\n        {\n            // SAFETY: the `cfg` attr ensures that we only execute this on x86 targets.\n            unsafe { crate::arch::x86::_mm_pause() };\n        }\n\n        #[cfg(target_arch = \"x86_64\")]\n        {\n            // SAFETY: the `cfg` attr ensures that we only execute this on x86_64 targets.\n            unsafe { crate::arch::x86_64::_mm_pause() };\n        }\n    }\n\n    #[cfg(any(target_arch = \"aarch64\", all(target_arch = \"arm\", target_feature = \"v6\")))]\n    {\n        #[cfg(target_arch = \"aarch64\")]\n        {\n            // SAFETY: the `cfg` attr ensures that we only execute this on aarch64 targets.\n            unsafe { crate::arch::aarch64::__isb(crate::arch::aarch64::SY) };\n        }\n        #[cfg(target_arch = \"arm\")]\n        {\n            // SAFETY: the `cfg` attr ensures that we only execute this on arm targets\n            // with support for the v6 feature.\n            unsafe { crate::arch::arm::__yield() };\n        }\n    }\n}\n\n/// An identity function that *__hints__* to the compiler to be maximally pessimistic about what\n/// `black_box` could do.\n///\n/// Unlike [`std::convert::identity`], a Rust compiler is encouraged to assume that `black_box` can\n/// use `dummy` in any possible valid way that Rust code is allowed to without introducing undefined\n/// behavior in the calling code. This property makes `black_box` useful for writing code in which\n/// certain optimizations are not desired, such as benchmarks.\n///\n/// Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis. The\n/// extent to which it can block optimisations may vary depending upon the platform and code-gen\n/// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n///\n/// [`std::convert::identity`]: crate::convert::identity\n#[cfg_attr(not(miri), inline)]\n#[cfg_attr(miri, inline(never))]\n#[unstable(feature = \"bench_black_box\", issue = \"64102\")]\n#[cfg_attr(miri, allow(unused_mut))]\npub fn black_box<T>(mut dummy: T) -> T {\n    // We need to \"use\" the argument in some way LLVM can't introspect, and on\n    // targets that support it we can typically leverage inline assembly to do\n    // this. LLVM's interpretation of inline assembly is that it's, well, a black\n    // box. This isn't the greatest implementation since it probably deoptimizes\n    // more than we want, but it's so far good enough.\n\n    #[cfg(not(miri))] // This is just a hint, so it is fine to skip in Miri.\n    // SAFETY: the inline assembly is a no-op.\n    unsafe {\n        // FIXME: Cannot use `asm!` because it doesn't support MIPS and other architectures.\n        llvm_asm!(\"\" : : \"r\"(&mut dummy) : \"memory\" : \"volatile\");\n    }\n\n    dummy\n}\n"],[2897,"//! The `Clone` trait for types that cannot be 'implicitly copied'.\n//!\n//! In Rust, some simple types are \"implicitly copyable\" and when you\n//! assign them or pass them as arguments, the receiver will get a copy,\n//! leaving the original value in place. These types do not require\n//! allocation to copy and do not have finalizers (i.e., they do not\n//! contain owned boxes or implement [`Drop`]), so the compiler considers\n//! them cheap and safe to copy. For other types copies must be made\n//! explicitly, by convention implementing the [`Clone`] trait and calling\n//! the [`clone`] method.\n//!\n//! [`clone`]: Clone::clone\n//!\n//! Basic usage example:\n//!\n//! ```\n//! let s = String::new(); // String type implements Clone\n//! let copy = s.clone(); // so we can clone it\n//! ```\n//!\n//! To easily implement the Clone trait, you can also use\n//! `#[derive(Clone)]`. Example:\n//!\n//! ```\n//! #[derive(Clone)] // we add the Clone trait to Morpheus struct\n//! struct Morpheus {\n//!    blue_pill: f32,\n//!    red_pill: i64,\n//! }\n//!\n//! fn main() {\n//!    let f = Morpheus { blue_pill: 0.0, red_pill: 0 };\n//!    let copy = f.clone(); // and now we can clone it!\n//! }\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n/// A common trait for the ability to explicitly duplicate an object.\n///\n/// Differs from [`Copy`] in that [`Copy`] is implicit and an inexpensive bit-wise copy, while\n/// `Clone` is always explicit and may or may not be expensive. In order to enforce\n/// these characteristics, Rust does not allow you to reimplement [`Copy`], but you\n/// may reimplement `Clone` and run arbitrary code.\n///\n/// Since `Clone` is more general than [`Copy`], you can automatically make anything\n/// [`Copy`] be `Clone` as well.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\n/// implementation of [`Clone`] calls [`clone`] on each field.\n///\n/// [`clone`]: Clone::clone\n///\n/// For a generic struct, `#[derive]` implements `Clone` conditionally by adding bound `Clone` on\n/// generic parameters.\n///\n/// ```\n/// // `derive` implements Clone for Reading<T> when T is Clone.\n/// #[derive(Clone)]\n/// struct Reading<T> {\n///     frequency: T,\n/// }\n/// ```\n///\n/// ## How can I implement `Clone`?\n///\n/// Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:\n/// if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`.\n/// Manual implementations should be careful to uphold this invariant; however, unsafe code\n/// must not rely on it to ensure memory safety.\n///\n/// An example is a generic struct holding a function pointer. In this case, the\n/// implementation of `Clone` cannot be `derive`d, but can be implemented as:\n///\n/// ```\n/// struct Generate<T>(fn() -> T);\n///\n/// impl<T> Copy for Generate<T> {}\n///\n/// impl<T> Clone for Generate<T> {\n///     fn clone(&self) -> Self {\n///         *self\n///     }\n/// }\n/// ```\n///\n/// ## Additional implementors\n///\n/// In addition to the [implementors listed below][impls],\n/// the following types also implement `Clone`:\n///\n/// * Function item types (i.e., the distinct types defined for each function)\n/// * Function pointer types (e.g., `fn() -> i32`)\n/// * Array types, for all sizes, if the item type also implements `Clone` (e.g., `[i32; 123456]`)\n/// * Tuple types, if each component also implements `Clone` (e.g., `()`, `(i32, bool)`)\n/// * Closure types, if they capture no value from the environment\n///   or if all such captured values implement `Clone` themselves.\n///   Note that variables captured by shared reference always implement `Clone`\n///   (even if the referent doesn't),\n///   while variables captured by mutable reference never implement `Clone`.\n///\n/// [impls]: #implementors\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[lang = \"clone\"]\n#[rustc_diagnostic_item = \"Clone\"]\npub trait Clone: Sized {\n    /// Returns a copy of the value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![allow(noop_method_call)]\n    /// let hello = \"Hello\"; // &str implements Clone\n    ///\n    /// assert_eq!(\"Hello\", hello.clone());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[must_use = \"cloning is often expensive and is not expected to have side effects\"]\n    fn clone(&self) -> Self;\n\n    /// Performs copy-assignment from `source`.\n    ///\n    /// `a.clone_from(&b)` is equivalent to `a = b.clone()` in functionality,\n    /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n    /// allocations.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn clone_from(&mut self, source: &Self) {\n        *self = source.clone()\n    }\n}\n\n/// Derive macro generating an impl of the trait `Clone`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\npub macro Clone($item:item) {\n    /* compiler built-in */\n}\n\n// FIXME(aburka): these structs are used solely by #[derive] to\n// assert that every component of a type implements Clone or Copy.\n//\n// These structs should never appear in user code.\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(\n    feature = \"derive_clone_copy\",\n    reason = \"deriving hack, should not be public\",\n    issue = \"none\"\n)]\npub struct AssertParamIsClone<T: Clone + ?Sized> {\n    _field: crate::marker::PhantomData<T>,\n}\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(\n    feature = \"derive_clone_copy\",\n    reason = \"deriving hack, should not be public\",\n    issue = \"none\"\n)]\npub struct AssertParamIsCopy<T: Copy + ?Sized> {\n    _field: crate::marker::PhantomData<T>,\n}\n\n/// Implementations of `Clone` for primitive types.\n///\n/// Implementations that cannot be described in Rust\n/// are implemented in `traits::SelectionContext::copy_clone_conditions()`\n/// in `rustc_trait_selection`.\nmod impls {\n\n    use super::Clone;\n\n    macro_rules! impl_clone {\n        ($($t:ty)*) => {\n            $(\n                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                impl Clone for $t {\n                    #[inline]\n                    fn clone(&self) -> Self {\n                        *self\n                    }\n                }\n            )*\n        }\n    }\n\n    impl_clone! {\n        usize u8 u16 u32 u64 u128\n        isize i8 i16 i32 i64 i128\n        f32 f64\n        bool char\n    }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl Clone for ! {\n        #[inline]\n        fn clone(&self) -> Self {\n            *self\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Clone for *const T {\n        #[inline]\n        fn clone(&self) -> Self {\n            *self\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Clone for *mut T {\n        #[inline]\n        fn clone(&self) -> Self {\n            *self\n        }\n    }\n\n    /// Shared references can be cloned, but mutable references *cannot*!\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Clone for &T {\n        #[inline]\n        #[rustc_diagnostic_item = \"noop_method_clone\"]\n        fn clone(&self) -> Self {\n            *self\n        }\n    }\n\n    /// Shared references can be cloned, but mutable references *cannot*!\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> !Clone for &mut T {}\n}\n"],[2898,"#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n\n//! Types and Traits for working with asynchronous tasks.\n\nmod poll;\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub use self::poll::Poll;\n\nmod wake;\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};\n\nmod ready;\n#[unstable(feature = \"ready_macro\", issue = \"70922\")]\npub use ready::ready;\n"],[2899,"#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n\nuse crate::convert;\nuse crate::ops::{self, ControlFlow};\nuse crate::result::Result;\n\n/// Indicates whether a value is available or if the current task has been\n/// scheduled to receive a wakeup instead.\n#[must_use = \"this `Poll` may be a `Pending` variant, which should be handled\"]\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub enum Poll<T> {\n    /// Represents that a value is immediately ready.\n    #[lang = \"Ready\"]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    Ready(#[stable(feature = \"futures_api\", since = \"1.36.0\")] T),\n\n    /// Represents that a value is not ready yet.\n    ///\n    /// When a function returns `Pending`, the function *must* also\n    /// ensure that the current task is scheduled to be awoken when\n    /// progress can be made.\n    #[lang = \"Pending\"]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    Pending,\n}\n\nimpl<T> Poll<T> {\n    /// Changes the ready value of this `Poll` with the closure provided.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn map<U, F>(self, f: F) -> Poll<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Poll::Ready(t) => Poll::Ready(f(t)),\n            Poll::Pending => Poll::Pending,\n        }\n    }\n\n    /// Returns `true` if this is `Poll::Ready`\n    #[inline]\n    #[rustc_const_stable(feature = \"const_poll\", since = \"1.49.0\")]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub const fn is_ready(&self) -> bool {\n        matches!(*self, Poll::Ready(_))\n    }\n\n    /// Returns `true` if this is `Poll::Pending`\n    #[inline]\n    #[rustc_const_stable(feature = \"const_poll\", since = \"1.49.0\")]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub const fn is_pending(&self) -> bool {\n        !self.is_ready()\n    }\n}\n\nimpl<T, E> Poll<Result<T, E>> {\n    /// Changes the success value of this `Poll` with the closure provided.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Poll::Ready(Ok(t)) => Poll::Ready(Ok(f(t))),\n            Poll::Ready(Err(e)) => Poll::Ready(Err(e)),\n            Poll::Pending => Poll::Pending,\n        }\n    }\n\n    /// Changes the error value of this `Poll` with the closure provided.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n    where\n        F: FnOnce(E) -> U,\n    {\n        match self {\n            Poll::Ready(Ok(t)) => Poll::Ready(Ok(t)),\n            Poll::Ready(Err(e)) => Poll::Ready(Err(f(e))),\n            Poll::Pending => Poll::Pending,\n        }\n    }\n}\n\nimpl<T, E> Poll<Option<Result<T, E>>> {\n    /// Changes the success value of this `Poll` with the closure provided.\n    #[stable(feature = \"poll_map\", since = \"1.51.0\")]\n    pub fn map_ok<U, F>(self, f: F) -> Poll<Option<Result<U, E>>>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(f(t)))),\n            Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(e))),\n            Poll::Ready(None) => Poll::Ready(None),\n            Poll::Pending => Poll::Pending,\n        }\n    }\n\n    /// Changes the error value of this `Poll` with the closure provided.\n    #[stable(feature = \"poll_map\", since = \"1.51.0\")]\n    pub fn map_err<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n    where\n        F: FnOnce(E) -> U,\n    {\n        match self {\n            Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(t))),\n            Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(f(e)))),\n            Poll::Ready(None) => Poll::Ready(None),\n            Poll::Pending => Poll::Pending,\n        }\n    }\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl<T> From<T> for Poll<T> {\n    /// Convert to a `Ready` variant.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use core::task::Poll;\n    /// assert_eq!(Poll::from(true), Poll::Ready(true));\n    /// ```\n    fn from(t: T) -> Poll<T> {\n        Poll::Ready(t)\n    }\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n#[cfg(bootstrap)]\nimpl<T, E> ops::TryV1 for Poll<Result<T, E>> {\n    type Output = Poll<T>;\n    type Error = E;\n\n    #[inline]\n    fn into_result(self) -> Result<Self::Output, Self::Error> {\n        match self {\n            Poll::Ready(Ok(x)) => Ok(Poll::Ready(x)),\n            Poll::Ready(Err(e)) => Err(e),\n            Poll::Pending => Ok(Poll::Pending),\n        }\n    }\n\n    #[inline]\n    fn from_error(e: Self::Error) -> Self {\n        Poll::Ready(Err(e))\n    }\n\n    #[inline]\n    fn from_ok(x: Self::Output) -> Self {\n        x.map(Ok)\n    }\n}\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\nimpl<T, E> ops::TryV2 for Poll<Result<T, E>> {\n    type Output = Poll<T>;\n    type Residual = Result<convert::Infallible, E>;\n\n    #[inline]\n    fn from_output(c: Self::Output) -> Self {\n        c.map(Ok)\n    }\n\n    #[inline]\n    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Poll::Ready(Ok(x)) => ControlFlow::Continue(Poll::Ready(x)),\n            Poll::Ready(Err(e)) => ControlFlow::Break(Err(e)),\n            Poll::Pending => ControlFlow::Continue(Poll::Pending),\n        }\n    }\n}\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\nimpl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Poll<Result<T, F>> {\n    #[inline]\n    fn from_residual(x: Result<convert::Infallible, E>) -> Self {\n        match x {\n            Err(e) => Poll::Ready(Err(From::from(e))),\n        }\n    }\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n#[cfg(bootstrap)]\nimpl<T, E> ops::TryV1 for Poll<Option<Result<T, E>>> {\n    type Output = Poll<Option<T>>;\n    type Error = E;\n\n    #[inline]\n    fn into_result(self) -> Result<Self::Output, Self::Error> {\n        match self {\n            Poll::Ready(Some(Ok(x))) => Ok(Poll::Ready(Some(x))),\n            Poll::Ready(Some(Err(e))) => Err(e),\n            Poll::Ready(None) => Ok(Poll::Ready(None)),\n            Poll::Pending => Ok(Poll::Pending),\n        }\n    }\n\n    #[inline]\n    fn from_error(e: Self::Error) -> Self {\n        Poll::Ready(Some(Err(e)))\n    }\n\n    #[inline]\n    fn from_ok(x: Self::Output) -> Self {\n        x.map(|x| x.map(Ok))\n    }\n}\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\nimpl<T, E> ops::TryV2 for Poll<Option<Result<T, E>>> {\n    type Output = Poll<Option<T>>;\n    type Residual = Result<convert::Infallible, E>;\n\n    #[inline]\n    fn from_output(c: Self::Output) -> Self {\n        c.map(|x| x.map(Ok))\n    }\n\n    #[inline]\n    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Poll::Ready(Some(Ok(x))) => ControlFlow::Continue(Poll::Ready(Some(x))),\n            Poll::Ready(Some(Err(e))) => ControlFlow::Break(Err(e)),\n            Poll::Ready(None) => ControlFlow::Continue(Poll::Ready(None)),\n            Poll::Pending => ControlFlow::Continue(Poll::Pending),\n        }\n    }\n}\n\n#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\nimpl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>>\n    for Poll<Option<Result<T, F>>>\n{\n    #[inline]\n    fn from_residual(x: Result<convert::Infallible, E>) -> Self {\n        match x {\n            Err(e) => Poll::Ready(Some(Err(From::from(e)))),\n        }\n    }\n}\n"],[2900,"#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n\nuse crate::fmt;\nuse crate::marker::{PhantomData, Unpin};\n\n/// A `RawWaker` allows the implementor of a task executor to create a [`Waker`]\n/// which provides customized wakeup behavior.\n///\n/// [vtable]: https://en.wikipedia.org/wiki/Virtual_method_table\n///\n/// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable]\n/// that customizes the behavior of the `RawWaker`.\n#[derive(PartialEq, Debug)]\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub struct RawWaker {\n    /// A data pointer, which can be used to store arbitrary data as required\n    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n    /// that is associated with the task.\n    /// The value of this field gets passed to all functions that are part of\n    /// the vtable as the first parameter.\n    data: *const (),\n    /// Virtual function pointer table that customizes the behavior of this waker.\n    vtable: &'static RawWakerVTable,\n}\n\nimpl RawWaker {\n    /// Creates a new `RawWaker` from the provided `data` pointer and `vtable`.\n    ///\n    /// The `data` pointer can be used to store arbitrary data as required\n    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n    /// that is associated with the task.\n    /// The value of this pointer will get passed to all functions that are part\n    /// of the `vtable` as the first parameter.\n    ///\n    /// The `vtable` customizes the behavior of a `Waker` which gets created\n    /// from a `RawWaker`. For each operation on the `Waker`, the associated\n    /// function in the `vtable` of the underlying `RawWaker` will be called.\n    #[inline]\n    #[rustc_promotable]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    #[rustc_const_stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n        RawWaker { data, vtable }\n    }\n}\n\n/// A virtual function pointer table (vtable) that specifies the behavior\n/// of a [`RawWaker`].\n///\n/// The pointer passed to all functions inside the vtable is the `data` pointer\n/// from the enclosing [`RawWaker`] object.\n///\n/// The functions inside this struct are only intended to be called on the `data`\n/// pointer of a properly constructed [`RawWaker`] object from inside the\n/// [`RawWaker`] implementation. Calling one of the contained functions using\n/// any other `data` pointer will cause undefined behavior.\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n#[derive(PartialEq, Copy, Clone, Debug)]\npub struct RawWakerVTable {\n    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.\n    ///\n    /// The implementation of this function must retain all resources that are\n    /// required for this additional instance of a [`RawWaker`] and associated\n    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n    /// of the same task that would have been awoken by the original [`RawWaker`].\n    clone: unsafe fn(*const ()) -> RawWaker,\n\n    /// This function will be called when `wake` is called on the [`Waker`].\n    /// It must wake up the task associated with this [`RawWaker`].\n    ///\n    /// The implementation of this function must make sure to release any\n    /// resources that are associated with this instance of a [`RawWaker`] and\n    /// associated task.\n    wake: unsafe fn(*const ()),\n\n    /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n    /// It must wake up the task associated with this [`RawWaker`].\n    ///\n    /// This function is similar to `wake`, but must not consume the provided data\n    /// pointer.\n    wake_by_ref: unsafe fn(*const ()),\n\n    /// This function gets called when a [`RawWaker`] gets dropped.\n    ///\n    /// The implementation of this function must make sure to release any\n    /// resources that are associated with this instance of a [`RawWaker`] and\n    /// associated task.\n    drop: unsafe fn(*const ()),\n}\n\nimpl RawWakerVTable {\n    /// Creates a new `RawWakerVTable` from the provided `clone`, `wake`,\n    /// `wake_by_ref`, and `drop` functions.\n    ///\n    /// # `clone`\n    ///\n    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.\n    ///\n    /// The implementation of this function must retain all resources that are\n    /// required for this additional instance of a [`RawWaker`] and associated\n    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n    /// of the same task that would have been awoken by the original [`RawWaker`].\n    ///\n    /// # `wake`\n    ///\n    /// This function will be called when `wake` is called on the [`Waker`].\n    /// It must wake up the task associated with this [`RawWaker`].\n    ///\n    /// The implementation of this function must make sure to release any\n    /// resources that are associated with this instance of a [`RawWaker`] and\n    /// associated task.\n    ///\n    /// # `wake_by_ref`\n    ///\n    /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n    /// It must wake up the task associated with this [`RawWaker`].\n    ///\n    /// This function is similar to `wake`, but must not consume the provided data\n    /// pointer.\n    ///\n    /// # `drop`\n    ///\n    /// This function gets called when a [`RawWaker`] gets dropped.\n    ///\n    /// The implementation of this function must make sure to release any\n    /// resources that are associated with this instance of a [`RawWaker`] and\n    /// associated task.\n    #[rustc_promotable]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    #[rustc_const_stable(feature = \"futures_api\", since = \"1.36.0\")]\n    #[rustc_allow_const_fn_unstable(const_fn_fn_ptr_basics)]\n    pub const fn new(\n        clone: unsafe fn(*const ()) -> RawWaker,\n        wake: unsafe fn(*const ()),\n        wake_by_ref: unsafe fn(*const ()),\n        drop: unsafe fn(*const ()),\n    ) -> Self {\n        Self { clone, wake, wake_by_ref, drop }\n    }\n}\n\n/// The `Context` of an asynchronous task.\n///\n/// Currently, `Context` only serves to provide access to a `&Waker`\n/// which can be used to wake the current task.\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub struct Context<'a> {\n    waker: &'a Waker,\n    // Ensure we future-proof against variance changes by forcing\n    // the lifetime to be invariant (argument-position lifetimes\n    // are contravariant while return-position lifetimes are\n    // covariant).\n    _marker: PhantomData<fn(&'a ()) -> &'a ()>,\n}\n\nimpl<'a> Context<'a> {\n    /// Create a new `Context` from a `&Waker`.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    #[inline]\n    pub fn from_waker(waker: &'a Waker) -> Self {\n        Context { waker, _marker: PhantomData }\n    }\n\n    /// Returns a reference to the `Waker` for the current task.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    #[inline]\n    pub fn waker(&self) -> &'a Waker {\n        &self.waker\n    }\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl fmt::Debug for Context<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Context\").field(\"waker\", &self.waker).finish()\n    }\n}\n\n/// A `Waker` is a handle for waking up a task by notifying its executor that it\n/// is ready to be run.\n///\n/// This handle encapsulates a [`RawWaker`] instance, which defines the\n/// executor-specific wakeup behavior.\n///\n/// Implements [`Clone`], [`Send`], and [`Sync`].\n#[repr(transparent)]\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub struct Waker {\n    waker: RawWaker,\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl Unpin for Waker {}\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nunsafe impl Send for Waker {}\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nunsafe impl Sync for Waker {}\n\nimpl Waker {\n    /// Wake up the task associated with this `Waker`.\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn wake(self) {\n        // The actual wakeup call is delegated through a virtual function call\n        // to the implementation which is defined by the executor.\n        let wake = self.waker.vtable.wake;\n        let data = self.waker.data;\n\n        // Don't call `drop` -- the waker will be consumed by `wake`.\n        crate::mem::forget(self);\n\n        // SAFETY: This is safe because `Waker::from_raw` is the only way\n        // to initialize `wake` and `data` requiring the user to acknowledge\n        // that the contract of `RawWaker` is upheld.\n        unsafe { (wake)(data) };\n    }\n\n    /// Wake up the task associated with this `Waker` without consuming the `Waker`.\n    ///\n    /// This is similar to `wake`, but may be slightly less efficient in the case\n    /// where an owned `Waker` is available. This method should be preferred to\n    /// calling `waker.clone().wake()`.\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn wake_by_ref(&self) {\n        // The actual wakeup call is delegated through a virtual function call\n        // to the implementation which is defined by the executor.\n\n        // SAFETY: see `wake`\n        unsafe { (self.waker.vtable.wake_by_ref)(self.waker.data) }\n    }\n\n    /// Returns `true` if this `Waker` and another `Waker` have awoken the same task.\n    ///\n    /// This function works on a best-effort basis, and may return false even\n    /// when the `Waker`s would awaken the same task. However, if this function\n    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same task.\n    ///\n    /// This function is primarily used for optimization purposes.\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn will_wake(&self, other: &Waker) -> bool {\n        self.waker == other.waker\n    }\n\n    /// Creates a new `Waker` from [`RawWaker`].\n    ///\n    /// The behavior of the returned `Waker` is undefined if the contract defined\n    /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n    /// Therefore this method is unsafe.\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub unsafe fn from_raw(waker: RawWaker) -> Waker {\n        Waker { waker }\n    }\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl Clone for Waker {\n    #[inline]\n    fn clone(&self) -> Self {\n        Waker {\n            // SAFETY: This is safe because `Waker::from_raw` is the only way\n            // to initialize `clone` and `data` requiring the user to acknowledge\n            // that the contract of [`RawWaker`] is upheld.\n            waker: unsafe { (self.waker.vtable.clone)(self.waker.data) },\n        }\n    }\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl Drop for Waker {\n    #[inline]\n    fn drop(&mut self) {\n        // SAFETY: This is safe because `Waker::from_raw` is the only way\n        // to initialize `drop` and `data` requiring the user to acknowledge\n        // that the contract of `RawWaker` is upheld.\n        unsafe { (self.waker.vtable.drop)(self.waker.data) }\n    }\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl fmt::Debug for Waker {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let vtable_ptr = self.waker.vtable as *const RawWakerVTable;\n        f.debug_struct(\"Waker\")\n            .field(\"data\", &self.waker.data)\n            .field(\"vtable\", &vtable_ptr)\n            .finish()\n    }\n}\n"],[2901,"/// Extracts the successful type of a [`Poll<T>`].\n///\n/// This macro bakes in propagation of [`Pending`] signals by returning early.\n///\n/// [`Poll<T>`]: crate::task::Poll\n/// [`Pending`]: crate::task::Poll::Pending\n///\n/// # Examples\n///\n/// ```\n/// #![feature(ready_macro)]\n///\n/// use std::task::{ready, Context, Poll};\n/// use std::future::{self, Future};\n/// use std::pin::Pin;\n///\n/// pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n///     let mut fut = future::ready(42);\n///     let fut = Pin::new(&mut fut);\n///\n///     let num = ready!(fut.poll(cx));\n///     # drop(num);\n///     // ... use num\n///\n///     Poll::Ready(())\n/// }\n/// ```\n///\n/// The `ready!` call expands to:\n///\n/// ```\n/// # #![feature(ready_macro)]\n/// #\n/// # use std::task::{Context, Poll};\n/// # use std::future::{self, Future};\n/// # use std::pin::Pin;\n/// #\n/// # pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n///     # let mut fut = future::ready(42);\n///     # let fut = Pin::new(&mut fut);\n///     #\n/// let num = match fut.poll(cx) {\n///     Poll::Ready(t) => t,\n///     Poll::Pending => return Poll::Pending,\n/// };\n///     # drop(num);\n///     # // ... use num\n///     #\n///     # Poll::Ready(())\n/// # }\n/// ```\n#[unstable(feature = \"ready_macro\", issue = \"70922\")]\n#[rustc_macro_transparency = \"semitransparent\"]\npub macro ready($e:expr) {\n    match $e {\n        $crate::task::Poll::Ready(t) => t,\n        $crate::task::Poll::Pending => {\n            return $crate::task::Poll::Pending;\n        }\n    }\n}\n"],[2902,"//! Defines the `IntoIter` owned iterator for arrays.\n\nuse crate::{\n    fmt,\n    iter::{self, ExactSizeIterator, FusedIterator, TrustedLen, TrustedRandomAccess},\n    mem::{self, MaybeUninit},\n    ops::Range,\n    ptr,\n};\n\n/// A by-value [array] iterator.\n#[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\npub struct IntoIter<T, const N: usize> {\n    /// This is the array we are iterating over.\n    ///\n    /// Elements with index `i` where `alive.start <= i < alive.end` have not\n    /// been yielded yet and are valid array entries. Elements with indices `i\n    /// < alive.start` or `i >= alive.end` have been yielded already and must\n    /// not be accessed anymore! Those dead elements might even be in a\n    /// completely uninitialized state!\n    ///\n    /// So the invariants are:\n    /// - `data[alive]` is alive (i.e. contains valid elements)\n    /// - `data[..alive.start]` and `data[alive.end..]` are dead (i.e. the\n    ///   elements were already read and must not be touched anymore!)\n    data: [MaybeUninit<T>; N],\n\n    /// The elements in `data` that have not been yielded yet.\n    ///\n    /// Invariants:\n    /// - `alive.start <= alive.end`\n    /// - `alive.end <= N`\n    alive: Range<usize>,\n}\n\nimpl<T, const N: usize> IntoIter<T, N> {\n    /// Creates a new iterator over the given `array`.\n    ///\n    /// *Note*: this method might be deprecated in the future,\n    /// after [`IntoIterator` is implemented for arrays][array-into-iter].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::array;\n    ///\n    /// for value in array::IntoIter::new([1, 2, 3, 4, 5]) {\n    ///     // The type of `value` is a `i32` here, instead of `&i32`\n    ///     let _: i32 = value;\n    /// }\n    /// ```\n    /// [array-into-iter]: https://github.com/rust-lang/rust/pull/65819\n    #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n    pub fn new(array: [T; N]) -> Self {\n        // SAFETY: The transmute here is actually safe. The docs of `MaybeUninit`\n        // promise:\n        //\n        // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n        // > as `T`.\n        //\n        // The docs even show a transmute from an array of `MaybeUninit<T>` to\n        // an array of `T`.\n        //\n        // With that, this initialization satisfies the invariants.\n\n        // FIXME(LukasKalbertodt): actually use `mem::transmute` here, once it\n        // works with const generics:\n        //     `mem::transmute::<[T; N], [MaybeUninit<T>; N]>(array)`\n        //\n        // Until then, we can use `mem::transmute_copy` to create a bitwise copy\n        // as a different type, then forget `array` so that it is not dropped.\n        unsafe {\n            let iter = Self { data: mem::transmute_copy(&array), alive: 0..N };\n            mem::forget(array);\n            iter\n        }\n    }\n\n    /// Returns an immutable slice of all elements that have not been yielded\n    /// yet.\n    #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n    pub fn as_slice(&self) -> &[T] {\n        // SAFETY: We know that all elements within `alive` are properly initialized.\n        unsafe {\n            let slice = self.data.get_unchecked(self.alive.clone());\n            MaybeUninit::slice_assume_init_ref(slice)\n        }\n    }\n\n    /// Returns a mutable slice of all elements that have not been yielded yet.\n    #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        // SAFETY: We know that all elements within `alive` are properly initialized.\n        unsafe {\n            let slice = self.data.get_unchecked_mut(self.alive.clone());\n            MaybeUninit::slice_assume_init_mut(slice)\n        }\n    }\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> Iterator for IntoIter<T, N> {\n    type Item = T;\n    fn next(&mut self) -> Option<Self::Item> {\n        // Get the next index from the front.\n        //\n        // Increasing `alive.start` by 1 maintains the invariant regarding\n        // `alive`. However, due to this change, for a short time, the alive\n        // zone is not `data[alive]` anymore, but `data[idx..alive.end]`.\n        self.alive.next().map(|idx| {\n            // Read the element from the array.\n            // SAFETY: `idx` is an index into the former \"alive\" region of the\n            // array. Reading this element means that `data[idx]` is regarded as\n            // dead now (i.e. do not touch). As `idx` was the start of the\n            // alive-zone, the alive zone is now `data[alive]` again, restoring\n            // all invariants.\n            unsafe { self.data.get_unchecked(idx).assume_init_read() }\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len();\n        (len, Some(len))\n    }\n\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n\n    #[inline]\n    #[doc(hidden)]\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n    where\n        Self: TrustedRandomAccess,\n    {\n        // SAFETY: Callers are only allowed to pass an index that is in bounds\n        // Additionally Self: TrustedRandomAccess is only implemented for T: Copy which means even\n        // multiple repeated reads of the same index would be safe and the\n        // values are !Drop, thus won't suffer from double drops.\n        unsafe { self.data.get_unchecked(self.alive.start + idx).assume_init_read() }\n    }\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        // Get the next index from the back.\n        //\n        // Decreasing `alive.end` by 1 maintains the invariant regarding\n        // `alive`. However, due to this change, for a short time, the alive\n        // zone is not `data[alive]` anymore, but `data[alive.start..=idx]`.\n        self.alive.next_back().map(|idx| {\n            // Read the element from the array.\n            // SAFETY: `idx` is an index into the former \"alive\" region of the\n            // array. Reading this element means that `data[idx]` is regarded as\n            // dead now (i.e. do not touch). As `idx` was the end of the\n            // alive-zone, the alive zone is now `data[alive]` again, restoring\n            // all invariants.\n            unsafe { self.data.get_unchecked(idx).assume_init_read() }\n        })\n    }\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> Drop for IntoIter<T, N> {\n    fn drop(&mut self) {\n        // SAFETY: This is safe: `as_mut_slice` returns exactly the sub-slice\n        // of elements that have not been moved out yet and that remain\n        // to be dropped.\n        unsafe { ptr::drop_in_place(self.as_mut_slice()) }\n    }\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> ExactSizeIterator for IntoIter<T, N> {\n    fn len(&self) -> usize {\n        // Will never underflow due to the invariant `alive.start <=\n        // alive.end`.\n        self.alive.end - self.alive.start\n    }\n    fn is_empty(&self) -> bool {\n        self.alive.is_empty()\n    }\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> FusedIterator for IntoIter<T, N> {}\n\n// The iterator indeed reports the correct length. The number of \"alive\"\n// elements (that will still be yielded) is the length of the range `alive`.\n// This range is decremented in length in either `next` or `next_back`. It is\n// always decremented by 1 in those methods, but only if `Some(_)` is returned.\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nunsafe impl<T, const N: usize> TrustedLen for IntoIter<T, N> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n// T: Copy as approximation for !Drop since get_unchecked does not update the pointers\n// and thus we can't implement drop-handling\nunsafe impl<T, const N: usize> TrustedRandomAccess for IntoIter<T, N>\nwhere\n    T: Copy,\n{\n    const MAY_HAVE_SIDE_EFFECT: bool = false;\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T: Clone, const N: usize> Clone for IntoIter<T, N> {\n    fn clone(&self) -> Self {\n        // Note, we don't really need to match the exact same alive range, so\n        // we can just clone into offset 0 regardless of where `self` is.\n        let mut new = Self { data: MaybeUninit::uninit_array(), alive: 0..0 };\n\n        // Clone all alive elements.\n        for (src, dst) in iter::zip(self.as_slice(), &mut new.data) {\n            // Write a clone into the new array, then update its alive range.\n            // If cloning panics, we'll correctly drop the previous items.\n            dst.write(src.clone());\n            new.alive.end += 1;\n        }\n\n        new\n    }\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, N> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Only print the elements that were not yielded yet: we cannot\n        // access the yielded elements anymore.\n        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n    }\n}\n"],[2903,"//! Helper functions and types for fixed-length arrays.\n//!\n//! *[See also the array primitive type](array).*\n\n#![stable(feature = \"core_array\", since = \"1.36.0\")]\n\nuse crate::borrow::{Borrow, BorrowMut};\nuse crate::cmp::Ordering;\nuse crate::convert::{Infallible, TryFrom};\nuse crate::fmt;\nuse crate::hash::{self, Hash};\nuse crate::iter::TrustedLen;\nuse crate::mem::{self, MaybeUninit};\nuse crate::ops::{Index, IndexMut};\nuse crate::slice::{Iter, IterMut};\n\nmod iter;\n\n#[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\npub use iter::IntoIter;\n\n/// Converts a reference to `T` into a reference to an array of length 1 (without copying).\n#[stable(feature = \"array_from_ref\", since = \"1.53.0\")]\npub fn from_ref<T>(s: &T) -> &[T; 1] {\n    // SAFETY: Converting `&T` to `&[T; 1]` is sound.\n    unsafe { &*(s as *const T).cast::<[T; 1]>() }\n}\n\n/// Converts a mutable reference to `T` into a mutable reference to an array of length 1 (without copying).\n#[stable(feature = \"array_from_ref\", since = \"1.53.0\")]\npub fn from_mut<T>(s: &mut T) -> &mut [T; 1] {\n    // SAFETY: Converting `&mut T` to `&mut [T; 1]` is sound.\n    unsafe { &mut *(s as *mut T).cast::<[T; 1]>() }\n}\n\n/// The error type returned when a conversion from a slice to an array fails.\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\n#[derive(Debug, Copy, Clone)]\npub struct TryFromSliceError(());\n\n#[stable(feature = \"core_array\", since = \"1.36.0\")]\nimpl fmt::Display for TryFromSliceError {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.__description(), f)\n    }\n}\n\nimpl TryFromSliceError {\n    #[unstable(\n        feature = \"array_error_internals\",\n        reason = \"available through Error trait and this method should not \\\n                     be exposed publicly\",\n        issue = \"none\"\n    )]\n    #[inline]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n        \"could not convert slice to array\"\n    }\n}\n\n#[stable(feature = \"try_from_slice_error\", since = \"1.36.0\")]\nimpl From<Infallible> for TryFromSliceError {\n    fn from(x: Infallible) -> TryFromSliceError {\n        match x {}\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, const N: usize> AsRef<[T]> for [T; N] {\n    #[inline]\n    fn as_ref(&self) -> &[T] {\n        &self[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, const N: usize> AsMut<[T]> for [T; N] {\n    #[inline]\n    fn as_mut(&mut self) -> &mut [T] {\n        &mut self[..]\n    }\n}\n\n#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\nimpl<T, const N: usize> Borrow<[T]> for [T; N] {\n    fn borrow(&self) -> &[T] {\n        self\n    }\n}\n\n#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\nimpl<T, const N: usize> BorrowMut<[T]> for [T; N] {\n    fn borrow_mut(&mut self) -> &mut [T] {\n        self\n    }\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<T, const N: usize> TryFrom<&[T]> for [T; N]\nwhere\n    T: Copy,\n{\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n        <&Self>::try_from(slice).map(|r| *r)\n    }\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N] {\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n        if slice.len() == N {\n            let ptr = slice.as_ptr() as *const [T; N];\n            // SAFETY: ok because we just checked that the length fits\n            unsafe { Ok(&*ptr) }\n        } else {\n            Err(TryFromSliceError(()))\n        }\n    }\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N] {\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n        if slice.len() == N {\n            let ptr = slice.as_mut_ptr() as *mut [T; N];\n            // SAFETY: ok because we just checked that the length fits\n            unsafe { Ok(&mut *ptr) }\n        } else {\n            Err(TryFromSliceError(()))\n        }\n    }\n}\n\n/// The hash of an array is the same as that of the corresponding slice,\n/// as required by the `Borrow` implementation.\n///\n/// ```\n/// #![feature(build_hasher_simple_hash_one)]\n/// use std::hash::BuildHasher;\n///\n/// let b = std::collections::hash_map::RandomState::new();\n/// let a: [u8; 3] = [0xa8, 0x3c, 0x09];\n/// let s: &[u8] = &[0xa8, 0x3c, 0x09];\n/// assert_eq!(b.hash_one(a), b.hash_one(s));\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Hash, const N: usize> Hash for [T; N] {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        Hash::hash(&self[..], state)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug, const N: usize> fmt::Debug for [T; N] {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&&self[..], f)\n    }\n}\n\n// Note: the `#[rustc_skip_array_during_method_dispatch]` on `trait IntoIterator`\n// hides this implementation from explicit `.into_iter()` calls on editions < 2021,\n// so those calls will still resolve to the slice implementation, by reference.\n#[stable(feature = \"array_into_iter_impl\", since = \"1.53.0\")]\nimpl<T, const N: usize> IntoIterator for [T; N] {\n    type Item = T;\n    type IntoIter = IntoIter<T, N>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out of\n    /// the array (from start to end). The array cannot be used after calling\n    /// this unless `T` implements `Copy`, so the whole array is copied.\n    ///\n    /// Arrays have special behavior when calling `.into_iter()` prior to the\n    /// 2021 edition -- see the [array] Editions section for more information.\n    ///\n    /// [array]: prim@array\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter::new(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, const N: usize> IntoIterator for &'a [T; N] {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, const N: usize> IntoIterator for &'a mut [T; N] {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n\n#[stable(feature = \"index_trait_on_arrays\", since = \"1.50.0\")]\nimpl<T, I, const N: usize> Index<I> for [T; N]\nwhere\n    [T]: Index<I>,\n{\n    type Output = <[T] as Index<I>>::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &Self::Output {\n        Index::index(self as &[T], index)\n    }\n}\n\n#[stable(feature = \"index_trait_on_arrays\", since = \"1.50.0\")]\nimpl<T, I, const N: usize> IndexMut<I> for [T; N]\nwhere\n    [T]: IndexMut<I>,\n{\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut Self::Output {\n        IndexMut::index_mut(self as &mut [T], index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<[B; N]> for [A; N]\nwhere\n    A: PartialEq<B>,\n{\n    #[inline]\n    fn eq(&self, other: &[B; N]) -> bool {\n        self[..] == other[..]\n    }\n    #[inline]\n    fn ne(&self, other: &[B; N]) -> bool {\n        self[..] != other[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<[B]> for [A; N]\nwhere\n    A: PartialEq<B>,\n{\n    #[inline]\n    fn eq(&self, other: &[B]) -> bool {\n        self[..] == other[..]\n    }\n    #[inline]\n    fn ne(&self, other: &[B]) -> bool {\n        self[..] != other[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<[A; N]> for [B]\nwhere\n    B: PartialEq<A>,\n{\n    #[inline]\n    fn eq(&self, other: &[A; N]) -> bool {\n        self[..] == other[..]\n    }\n    #[inline]\n    fn ne(&self, other: &[A; N]) -> bool {\n        self[..] != other[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<&[B]> for [A; N]\nwhere\n    A: PartialEq<B>,\n{\n    #[inline]\n    fn eq(&self, other: &&[B]) -> bool {\n        self[..] == other[..]\n    }\n    #[inline]\n    fn ne(&self, other: &&[B]) -> bool {\n        self[..] != other[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<[A; N]> for &[B]\nwhere\n    B: PartialEq<A>,\n{\n    #[inline]\n    fn eq(&self, other: &[A; N]) -> bool {\n        self[..] == other[..]\n    }\n    #[inline]\n    fn ne(&self, other: &[A; N]) -> bool {\n        self[..] != other[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<&mut [B]> for [A; N]\nwhere\n    A: PartialEq<B>,\n{\n    #[inline]\n    fn eq(&self, other: &&mut [B]) -> bool {\n        self[..] == other[..]\n    }\n    #[inline]\n    fn ne(&self, other: &&mut [B]) -> bool {\n        self[..] != other[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<[A; N]> for &mut [B]\nwhere\n    B: PartialEq<A>,\n{\n    #[inline]\n    fn eq(&self, other: &[A; N]) -> bool {\n        self[..] == other[..]\n    }\n    #[inline]\n    fn ne(&self, other: &[A; N]) -> bool {\n        self[..] != other[..]\n    }\n}\n\n// NOTE: some less important impls are omitted to reduce code bloat\n// __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n// __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq, const N: usize> Eq for [T; N] {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd, const N: usize> PartialOrd for [T; N] {\n    #[inline]\n    fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {\n        PartialOrd::partial_cmp(&&self[..], &&other[..])\n    }\n    #[inline]\n    fn lt(&self, other: &[T; N]) -> bool {\n        PartialOrd::lt(&&self[..], &&other[..])\n    }\n    #[inline]\n    fn le(&self, other: &[T; N]) -> bool {\n        PartialOrd::le(&&self[..], &&other[..])\n    }\n    #[inline]\n    fn ge(&self, other: &[T; N]) -> bool {\n        PartialOrd::ge(&&self[..], &&other[..])\n    }\n    #[inline]\n    fn gt(&self, other: &[T; N]) -> bool {\n        PartialOrd::gt(&&self[..], &&other[..])\n    }\n}\n\n/// Implements comparison of arrays [lexicographically](Ord#lexicographical-comparison).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord, const N: usize> Ord for [T; N] {\n    #[inline]\n    fn cmp(&self, other: &[T; N]) -> Ordering {\n        Ord::cmp(&&self[..], &&other[..])\n    }\n}\n\n// The Default impls cannot be done with const generics because `[T; 0]` doesn't\n// require Default to be implemented, and having different impl blocks for\n// different numbers isn't supported yet.\n\nmacro_rules! array_impl_default {\n    {$n:expr, $t:ident $($ts:ident)*} => {\n        #[stable(since = \"1.4.0\", feature = \"array_default\")]\n        impl<T> Default for [T; $n] where T: Default {\n            fn default() -> [T; $n] {\n                [$t::default(), $($ts::default()),*]\n            }\n        }\n        array_impl_default!{($n - 1), $($ts)*}\n    };\n    {$n:expr,} => {\n        #[stable(since = \"1.4.0\", feature = \"array_default\")]\n        impl<T> Default for [T; $n] {\n            fn default() -> [T; $n] { [] }\n        }\n    };\n}\n\narray_impl_default! {32, T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T}\n\n#[lang = \"array\"]\nimpl<T, const N: usize> [T; N] {\n    /// Returns an array of the same size as `self`, with function `f` applied to each element\n    /// in order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(array_map)]\n    /// let x = [1, 2, 3];\n    /// let y = x.map(|v| v + 1);\n    /// assert_eq!(y, [2, 3, 4]);\n    ///\n    /// let x = [1, 2, 3];\n    /// let mut temp = 0;\n    /// let y = x.map(|v| { temp += 1; v * temp });\n    /// assert_eq!(y, [1, 4, 9]);\n    ///\n    /// let x = [\"Ferris\", \"Bueller's\", \"Day\", \"Off\"];\n    /// let y = x.map(|v| v.len());\n    /// assert_eq!(y, [6, 9, 3, 3]);\n    /// ```\n    #[unstable(feature = \"array_map\", issue = \"75243\")]\n    pub fn map<F, U>(self, f: F) -> [U; N]\n    where\n        F: FnMut(T) -> U,\n    {\n        // SAFETY: we know for certain that this iterator will yield exactly `N`\n        // items.\n        unsafe { collect_into_array_unchecked(&mut IntoIterator::into_iter(self).map(f)) }\n    }\n\n    /// 'Zips up' two arrays into a single array of pairs.\n    ///\n    /// `zip()` returns a new array where every element is a tuple where the\n    /// first element comes from the first array, and the second element comes\n    /// from the second array. In other words, it zips two arrays together,\n    /// into a single one.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(array_zip)]\n    /// let x = [1, 2, 3];\n    /// let y = [4, 5, 6];\n    /// let z = x.zip(y);\n    /// assert_eq!(z, [(1, 4), (2, 5), (3, 6)]);\n    /// ```\n    #[unstable(feature = \"array_zip\", issue = \"80094\")]\n    pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n        let mut iter = IntoIterator::into_iter(self).zip(rhs);\n\n        // SAFETY: we know for certain that this iterator will yield exactly `N`\n        // items.\n        unsafe { collect_into_array_unchecked(&mut iter) }\n    }\n\n    /// Returns a slice containing the entire array. Equivalent to `&s[..]`.\n    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n    pub fn as_slice(&self) -> &[T] {\n        self\n    }\n\n    /// Returns a mutable slice containing the entire array. Equivalent to\n    /// `&mut s[..]`.\n    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        self\n    }\n\n    /// Borrows each element and returns an array of references with the same\n    /// size as `self`.\n    ///\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #![feature(array_methods)]\n    ///\n    /// let floats = [3.1, 2.7, -1.0];\n    /// let float_refs: [&f64; 3] = floats.each_ref();\n    /// assert_eq!(float_refs, [&3.1, &2.7, &-1.0]);\n    /// ```\n    ///\n    /// This method is particularly useful if combined with other methods, like\n    /// [`map`](#method.map). This way, you can avoid moving the original\n    /// array if its elements are not `Copy`.\n    ///\n    /// ```\n    /// #![feature(array_methods, array_map)]\n    ///\n    /// let strings = [\"Ferris\".to_string(), \"♥\".to_string(), \"Rust\".to_string()];\n    /// let is_ascii = strings.each_ref().map(|s| s.is_ascii());\n    /// assert_eq!(is_ascii, [true, false, true]);\n    ///\n    /// // We can still access the original array: it has not been moved.\n    /// assert_eq!(strings.len(), 3);\n    /// ```\n    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n    pub fn each_ref(&self) -> [&T; N] {\n        // SAFETY: we know for certain that this iterator will yield exactly `N`\n        // items.\n        unsafe { collect_into_array_unchecked(&mut self.iter()) }\n    }\n\n    /// Borrows each element mutably and returns an array of mutable references\n    /// with the same size as `self`.\n    ///\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #![feature(array_methods)]\n    ///\n    /// let mut floats = [3.1, 2.7, -1.0];\n    /// let float_refs: [&mut f64; 3] = floats.each_mut();\n    /// *float_refs[0] = 0.0;\n    /// assert_eq!(float_refs, [&mut 0.0, &mut 2.7, &mut -1.0]);\n    /// assert_eq!(floats, [0.0, 2.7, -1.0]);\n    /// ```\n    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n    pub fn each_mut(&mut self) -> [&mut T; N] {\n        // SAFETY: we know for certain that this iterator will yield exactly `N`\n        // items.\n        unsafe { collect_into_array_unchecked(&mut self.iter_mut()) }\n    }\n}\n\n/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n/// yields fewer than `N` items, this function exhibits undefined behavior.\n///\n/// See [`collect_into_array`] for more information.\n///\n///\n/// # Safety\n///\n/// It is up to the caller to guarantee that `iter` yields at least `N` items.\n/// Violating this condition causes undefined behavior.\nunsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\nwhere\n    // Note: `TrustedLen` here is somewhat of an experiment. This is just an\n    // internal function, so feel free to remove if this bound turns out to be a\n    // bad idea. In that case, remember to also remove the lower bound\n    // `debug_assert!` below!\n    I: Iterator + TrustedLen,\n{\n    debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n    debug_assert!(N <= iter.size_hint().0);\n\n    match collect_into_array(iter) {\n        Some(array) => array,\n        // SAFETY: covered by the function contract.\n        None => unsafe { crate::hint::unreachable_unchecked() },\n    }\n}\n\n/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n/// yields fewer than `N` items, `None` is returned and all already yielded\n/// items are dropped.\n///\n/// Since the iterator is passed as a mutable reference and this function calls\n/// `next` at most `N` times, the iterator can still be used afterwards to\n/// retrieve the remaining items.\n///\n/// If `iter.next()` panicks, all items already yielded by the iterator are\n/// dropped.\nfn collect_into_array<I, const N: usize>(iter: &mut I) -> Option<[I::Item; N]>\nwhere\n    I: Iterator,\n{\n    if N == 0 {\n        // SAFETY: An empty array is always inhabited and has no validity invariants.\n        return unsafe { Some(mem::zeroed()) };\n    }\n\n    struct Guard<T, const N: usize> {\n        ptr: *mut T,\n        initialized: usize,\n    }\n\n    impl<T, const N: usize> Drop for Guard<T, N> {\n        fn drop(&mut self) {\n            debug_assert!(self.initialized <= N);\n\n            let initialized_part = crate::ptr::slice_from_raw_parts_mut(self.ptr, self.initialized);\n\n            // SAFETY: this raw slice will contain only initialized objects.\n            unsafe {\n                crate::ptr::drop_in_place(initialized_part);\n            }\n        }\n    }\n\n    let mut array = MaybeUninit::uninit_array::<N>();\n    let mut guard: Guard<_, N> =\n        Guard { ptr: MaybeUninit::slice_as_mut_ptr(&mut array), initialized: 0 };\n\n    while let Some(item) = iter.next() {\n        // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n        // loop and the loop is aborted once it reaches N (which is\n        // `array.len()`).\n        unsafe {\n            array.get_unchecked_mut(guard.initialized).write(item);\n        }\n        guard.initialized += 1;\n\n        // Check if the whole array was initialized.\n        if guard.initialized == N {\n            mem::forget(guard);\n\n            // SAFETY: the condition above asserts that all elements are\n            // initialized.\n            let out = unsafe { MaybeUninit::array_assume_init(array) };\n            return Some(out);\n        }\n    }\n\n    // This is only reached if the iterator is exhausted before\n    // `guard.initialized` reaches `N`. Also note that `guard` is dropped here,\n    // dropping all already initialized elements.\n    None\n}\n"],[2904,"//! A module for working with borrowed data.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n/// A trait for borrowing data.\n///\n/// In Rust, it is common to provide different representations of a type for\n/// different use cases. For instance, storage location and management for a\n/// value can be specifically chosen as appropriate for a particular use via\n/// pointer types such as [`Box<T>`] or [`Rc<T>`]. Beyond these generic\n/// wrappers that can be used with any type, some types provide optional\n/// facets providing potentially costly functionality. An example for such a\n/// type is [`String`] which adds the ability to extend a string to the basic\n/// [`str`]. This requires keeping additional information unnecessary for a\n/// simple, immutable string.\n///\n/// These types provide access to the underlying data through references\n/// to the type of that data. They are said to be ‘borrowed as’ that type.\n/// For instance, a [`Box<T>`] can be borrowed as `T` while a [`String`]\n/// can be borrowed as `str`.\n///\n/// Types express that they can be borrowed as some type `T` by implementing\n/// `Borrow<T>`, providing a reference to a `T` in the trait’s\n/// [`borrow`] method. A type is free to borrow as several different types.\n/// If it wishes to mutably borrow as the type – allowing the underlying data\n/// to be modified, it can additionally implement [`BorrowMut<T>`].\n///\n/// Further, when providing implementations for additional traits, it needs\n/// to be considered whether they should behave identical to those of the\n/// underlying type as a consequence of acting as a representation of that\n/// underlying type. Generic code typically uses `Borrow<T>` when it relies\n/// on the identical behavior of these additional trait implementations.\n/// These traits will likely appear as additional trait bounds.\n///\n/// In particular `Eq`, `Ord` and `Hash` must be equivalent for\n/// borrowed and owned values: `x.borrow() == y.borrow()` should give the\n/// same result as `x == y`.\n///\n/// If generic code merely needs to work for all types that can\n/// provide a reference to related type `T`, it is often better to use\n/// [`AsRef<T>`] as more types can safely implement it.\n///\n/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n/// [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`borrow`]: Borrow::borrow\n///\n/// # Examples\n///\n/// As a data collection, [`HashMap<K, V>`] owns both keys and values. If\n/// the key’s actual data is wrapped in a managing type of some kind, it\n/// should, however, still be possible to search for a value using a\n/// reference to the key’s data. For instance, if the key is a string, then\n/// it is likely stored with the hash map as a [`String`], while it should\n/// be possible to search using a [`&str`][`str`]. Thus, `insert` needs to\n/// operate on a `String` while `get` needs to be able to use a `&str`.\n///\n/// Slightly simplified, the relevant parts of `HashMap<K, V>` look like\n/// this:\n///\n/// ```\n/// use std::borrow::Borrow;\n/// use std::hash::Hash;\n///\n/// pub struct HashMap<K, V> {\n///     # marker: ::std::marker::PhantomData<(K, V)>,\n///     // fields omitted\n/// }\n///\n/// impl<K, V> HashMap<K, V> {\n///     pub fn insert(&self, key: K, value: V) -> Option<V>\n///     where K: Hash + Eq\n///     {\n///         # unimplemented!()\n///         // ...\n///     }\n///\n///     pub fn get<Q>(&self, k: &Q) -> Option<&V>\n///     where\n///         K: Borrow<Q>,\n///         Q: Hash + Eq + ?Sized\n///     {\n///         # unimplemented!()\n///         // ...\n///     }\n/// }\n/// ```\n///\n/// The entire hash map is generic over a key type `K`. Because these keys\n/// are stored with the hash map, this type has to own the key’s data.\n/// When inserting a key-value pair, the map is given such a `K` and needs\n/// to find the correct hash bucket and check if the key is already present\n/// based on that `K`. It therefore requires `K: Hash + Eq`.\n///\n/// When searching for a value in the map, however, having to provide a\n/// reference to a `K` as the key to search for would require to always\n/// create such an owned value. For string keys, this would mean a `String`\n/// value needs to be created just for the search for cases where only a\n/// `str` is available.\n///\n/// Instead, the `get` method is generic over the type of the underlying key\n/// data, called `Q` in the method signature above. It states that `K`\n/// borrows as a `Q` by requiring that `K: Borrow<Q>`. By additionally\n/// requiring `Q: Hash + Eq`, it signals the requirement that `K` and `Q`\n/// have implementations of the `Hash` and `Eq` traits that produce identical\n/// results.\n///\n/// The implementation of `get` relies in particular on identical\n/// implementations of `Hash` by determining the key’s hash bucket by calling\n/// `Hash::hash` on the `Q` value even though it inserted the key based on\n/// the hash value calculated from the `K` value.\n///\n/// As a consequence, the hash map breaks if a `K` wrapping a `Q` value\n/// produces a different hash than `Q`. For instance, imagine you have a\n/// type that wraps a string but compares ASCII letters ignoring their case:\n///\n/// ```\n/// pub struct CaseInsensitiveString(String);\n///\n/// impl PartialEq for CaseInsensitiveString {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.0.eq_ignore_ascii_case(&other.0)\n///     }\n/// }\n///\n/// impl Eq for CaseInsensitiveString { }\n/// ```\n///\n/// Because two equal values need to produce the same hash value, the\n/// implementation of `Hash` needs to ignore ASCII case, too:\n///\n/// ```\n/// # use std::hash::{Hash, Hasher};\n/// # pub struct CaseInsensitiveString(String);\n/// impl Hash for CaseInsensitiveString {\n///     fn hash<H: Hasher>(&self, state: &mut H) {\n///         for c in self.0.as_bytes() {\n///             c.to_ascii_lowercase().hash(state)\n///         }\n///     }\n/// }\n/// ```\n///\n/// Can `CaseInsensitiveString` implement `Borrow<str>`? It certainly can\n/// provide a reference to a string slice via its contained owned string.\n/// But because its `Hash` implementation differs, it behaves differently\n/// from `str` and therefore must not, in fact, implement `Borrow<str>`.\n/// If it wants to allow others access to the underlying `str`, it can do\n/// that via `AsRef<str>` which doesn’t carry any extra requirements.\n///\n/// [`Hash`]: crate::hash::Hash\n/// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n/// [`String`]: ../../std/string/struct.String.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_diagnostic_item = \"Borrow\"]\npub trait Borrow<Borrowed: ?Sized> {\n    /// Immutably borrows from an owned value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::borrow::Borrow;\n    ///\n    /// fn check<T: Borrow<str>>(s: T) {\n    ///     assert_eq!(\"Hello\", s.borrow());\n    /// }\n    ///\n    /// let s = \"Hello\".to_string();\n    ///\n    /// check(s);\n    ///\n    /// let s = \"Hello\";\n    ///\n    /// check(s);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn borrow(&self) -> &Borrowed;\n}\n\n/// A trait for mutably borrowing data.\n///\n/// As a companion to [`Borrow<T>`] this trait allows a type to borrow as\n/// an underlying type by providing a mutable reference. See [`Borrow<T>`]\n/// for more information on borrowing as another type.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n    /// Mutably borrows from an owned value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::borrow::BorrowMut;\n    ///\n    /// fn check<T: BorrowMut<[i32]>>(mut v: T) {\n    ///     assert_eq!(&mut [1, 2, 3], v.borrow_mut());\n    /// }\n    ///\n    /// let v = vec![1, 2, 3];\n    ///\n    /// check(v);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn borrow_mut(&mut self) -> &mut Borrowed;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Borrow<T> for T {\n    #[rustc_diagnostic_item = \"noop_method_borrow\"]\n    fn borrow(&self) -> &T {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> BorrowMut<T> for T {\n    fn borrow_mut(&mut self) -> &mut T {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Borrow<T> for &T {\n    fn borrow(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Borrow<T> for &mut T {\n    fn borrow(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> BorrowMut<T> for &mut T {\n    fn borrow_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n"],[2905,"//! The `Default` trait for types which may have meaningful default values.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n/// A trait for giving a type a useful default value.\n///\n/// Sometimes, you want to fall back to some kind of default value, and\n/// don't particularly care what it is. This comes up often with `struct`s\n/// that define a set of options:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// struct SomeOptions {\n///     foo: i32,\n///     bar: f32,\n/// }\n/// ```\n///\n/// How can we define some default values? You can use `Default`:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// #[derive(Default)]\n/// struct SomeOptions {\n///     foo: i32,\n///     bar: f32,\n/// }\n///\n/// fn main() {\n///     let options: SomeOptions = Default::default();\n/// }\n/// ```\n///\n/// Now, you get all of the default values. Rust implements `Default` for various primitives types.\n///\n/// If you want to override a particular option, but still retain the other defaults:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// # #[derive(Default)]\n/// # struct SomeOptions {\n/// #     foo: i32,\n/// #     bar: f32,\n/// # }\n/// fn main() {\n///     let options = SomeOptions { foo: 42, ..Default::default() };\n/// }\n/// ```\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]` if all of the type's fields implement\n/// `Default`. When `derive`d, it will use the default value for each field's type.\n///\n/// ## How can I implement `Default`?\n///\n/// Provide an implementation for the `default()` method that returns the value of\n/// your type that should be the default:\n///\n/// ```\n/// # #![allow(dead_code)]\n/// enum Kind {\n///     A,\n///     B,\n///     C,\n/// }\n///\n/// impl Default for Kind {\n///     fn default() -> Self { Kind::A }\n/// }\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # #[allow(dead_code)]\n/// #[derive(Default)]\n/// struct SomeOptions {\n///     foo: i32,\n///     bar: f32,\n/// }\n/// ```\n#[cfg_attr(not(test), rustc_diagnostic_item = \"Default\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Default: Sized {\n    /// Returns the \"default value\" for a type.\n    ///\n    /// Default values are often some kind of initial value, identity value, or anything else that\n    /// may make sense as a default.\n    ///\n    /// # Examples\n    ///\n    /// Using built-in default values:\n    ///\n    /// ```\n    /// let i: i8 = Default::default();\n    /// let (x, y): (Option<String>, f64) = Default::default();\n    /// let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();\n    /// ```\n    ///\n    /// Making your own:\n    ///\n    /// ```\n    /// # #[allow(dead_code)]\n    /// enum Kind {\n    ///     A,\n    ///     B,\n    ///     C,\n    /// }\n    ///\n    /// impl Default for Kind {\n    ///     fn default() -> Self { Kind::A }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn default() -> Self;\n}\n\n/// Return the default value of a type according to the `Default` trait.\n///\n/// The type to return is inferred from context; this is equivalent to\n/// `Default::default()` but shorter to type.\n///\n/// For example:\n/// ```\n/// #![feature(default_free_fn)]\n///\n/// use std::default::default;\n///\n/// #[derive(Default)]\n/// struct AppConfig {\n///     foo: FooConfig,\n///     bar: BarConfig,\n/// }\n///\n/// #[derive(Default)]\n/// struct FooConfig {\n///     foo: i32,\n/// }\n///\n/// #[derive(Default)]\n/// struct BarConfig {\n///     bar: f32,\n///     baz: u8,\n/// }\n///\n/// fn main() {\n///     let options = AppConfig {\n///         foo: default(),\n///         bar: BarConfig {\n///             bar: 10.1,\n///             ..default()\n///         },\n///     };\n/// }\n/// ```\n#[unstable(feature = \"default_free_fn\", issue = \"73014\")]\n#[inline]\npub fn default<T: Default>() -> T {\n    Default::default()\n}\n\n/// Derive macro generating an impl of the trait `Default`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics)]\npub macro Default($item:item) {\n    /* compiler built-in */\n}\n\nmacro_rules! default_impl {\n    ($t:ty, $v:expr, $doc:tt) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Default for $t {\n            #[inline]\n            #[doc = $doc]\n            fn default() -> $t {\n                $v\n            }\n        }\n    };\n}\n\ndefault_impl! { (), (), \"Returns the default value of `()`\" }\ndefault_impl! { bool, false, \"Returns the default value of `false`\" }\ndefault_impl! { char, '\\x00', \"Returns the default value of `\\\\x00`\" }\n\ndefault_impl! { usize, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u8, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u16, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u32, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u64, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u128, 0, \"Returns the default value of `0`\" }\n\ndefault_impl! { isize, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i8, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i16, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i32, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i64, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i128, 0, \"Returns the default value of `0`\" }\n\ndefault_impl! { f32, 0.0f32, \"Returns the default value of `0.0`\" }\ndefault_impl! { f64, 0.0f64, \"Returns the default value of `0.0`\" }\n"],[2906,"#![stable(feature = \"duration_core\", since = \"1.25.0\")]\n\n//! Temporal quantification.\n//!\n//! Example:\n//!\n//! ```\n//! use std::time::Duration;\n//!\n//! let five_seconds = Duration::new(5, 0);\n//! // both declarations are equivalent\n//! assert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n//! ```\n\nuse crate::fmt;\nuse crate::iter::Sum;\nuse crate::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\nconst NANOS_PER_SEC: u32 = 1_000_000_000;\nconst NANOS_PER_MILLI: u32 = 1_000_000;\nconst NANOS_PER_MICRO: u32 = 1_000;\nconst MILLIS_PER_SEC: u64 = 1_000;\nconst MICROS_PER_SEC: u64 = 1_000_000;\n\n/// A `Duration` type to represent a span of time, typically used for system\n/// timeouts.\n///\n/// Each `Duration` is composed of a whole number of seconds and a fractional part\n/// represented in nanoseconds. If the underlying system does not support\n/// nanosecond-level precision, APIs binding a system timeout will typically round up\n/// the number of nanoseconds.\n///\n/// [`Duration`]s implement many common traits, including [`Add`], [`Sub`], and other\n/// [`ops`] traits. It implements [`Default`] by returning a zero-length `Duration`.\n///\n/// [`ops`]: crate::ops\n///\n/// # Examples\n///\n/// ```\n/// use std::time::Duration;\n///\n/// let five_seconds = Duration::new(5, 0);\n/// let five_seconds_and_five_nanos = five_seconds + Duration::new(0, 5);\n///\n/// assert_eq!(five_seconds_and_five_nanos.as_secs(), 5);\n/// assert_eq!(five_seconds_and_five_nanos.subsec_nanos(), 5);\n///\n/// let ten_millis = Duration::from_millis(10);\n/// ```\n///\n/// # Formatting `Duration` values\n///\n/// `Duration` intentionally does not have a `Display` impl, as there are a\n/// variety of ways to format spans of time for human readability. `Duration`\n/// provides a `Debug` impl that shows the full precision of the value.\n///\n/// The `Debug` output uses the non-ASCII \"µs\" suffix for microseconds. If your\n/// program output may appear in contexts that cannot rely on full Unicode\n/// compatibility, you may wish to format `Duration` objects yourself or use a\n/// crate to do so.\n#[stable(feature = \"duration\", since = \"1.3.0\")]\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\npub struct Duration {\n    secs: u64,\n    nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC\n}\n\nimpl Duration {\n    /// The duration of one second.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::SECOND, Duration::from_secs(1));\n    /// ```\n    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n    pub const SECOND: Duration = Duration::from_secs(1);\n\n    /// The duration of one millisecond.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::MILLISECOND, Duration::from_millis(1));\n    /// ```\n    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n    pub const MILLISECOND: Duration = Duration::from_millis(1);\n\n    /// The duration of one microsecond.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::MICROSECOND, Duration::from_micros(1));\n    /// ```\n    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n    pub const MICROSECOND: Duration = Duration::from_micros(1);\n\n    /// The duration of one nanosecond.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::NANOSECOND, Duration::from_nanos(1));\n    /// ```\n    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n    pub const NANOSECOND: Duration = Duration::from_nanos(1);\n\n    /// A duration of zero time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::ZERO;\n    /// assert!(duration.is_zero());\n    /// assert_eq!(duration.as_nanos(), 0);\n    /// ```\n    #[stable(feature = \"duration_zero\", since = \"1.53.0\")]\n    pub const ZERO: Duration = Duration::from_nanos(0);\n\n    /// The maximum duration.\n    ///\n    /// May vary by platform as necessary. Must be able to contain the difference between\n    /// two instances of [`Instant`] or two instances of [`SystemTime`].\n    /// This constraint gives it a value of about 584,942,417,355 years in practice,\n    /// which is currently used on all platforms.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::MAX, Duration::new(u64::MAX, 1_000_000_000 - 1));\n    /// ```\n    /// [`Instant`]: ../../std/time/struct.Instant.html\n    /// [`SystemTime`]: ../../std/time/struct.SystemTime.html\n    #[stable(feature = \"duration_saturating_ops\", since = \"1.53.0\")]\n    pub const MAX: Duration = Duration::new(u64::MAX, NANOS_PER_SEC - 1);\n\n    /// Creates a new `Duration` from the specified number of whole seconds and\n    /// additional nanoseconds.\n    ///\n    /// If the number of nanoseconds is greater than 1 billion (the number of\n    /// nanoseconds in a second), then it will carry over into the seconds provided.\n    ///\n    /// # Panics\n    ///\n    /// This constructor will panic if the carry from the nanoseconds overflows\n    /// the seconds counter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let five_seconds = Duration::new(5, 0);\n    /// ```\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn new(secs: u64, nanos: u32) -> Duration {\n        let secs = match secs.checked_add((nanos / NANOS_PER_SEC) as u64) {\n            Some(secs) => secs,\n            None => panic!(\"overflow in Duration::new\"),\n        };\n        let nanos = nanos % NANOS_PER_SEC;\n        Duration { secs, nanos }\n    }\n\n    /// Creates a new `Duration` from the specified number of whole seconds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_secs(5);\n    ///\n    /// assert_eq!(5, duration.as_secs());\n    /// assert_eq!(0, duration.subsec_nanos());\n    /// ```\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_secs(secs: u64) -> Duration {\n        Duration { secs, nanos: 0 }\n    }\n\n    /// Creates a new `Duration` from the specified number of milliseconds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_millis(2569);\n    ///\n    /// assert_eq!(2, duration.as_secs());\n    /// assert_eq!(569_000_000, duration.subsec_nanos());\n    /// ```\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_millis(millis: u64) -> Duration {\n        Duration {\n            secs: millis / MILLIS_PER_SEC,\n            nanos: ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI,\n        }\n    }\n\n    /// Creates a new `Duration` from the specified number of microseconds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_micros(1_000_002);\n    ///\n    /// assert_eq!(1, duration.as_secs());\n    /// assert_eq!(2000, duration.subsec_nanos());\n    /// ```\n    #[stable(feature = \"duration_from_micros\", since = \"1.27.0\")]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_micros(micros: u64) -> Duration {\n        Duration {\n            secs: micros / MICROS_PER_SEC,\n            nanos: ((micros % MICROS_PER_SEC) as u32) * NANOS_PER_MICRO,\n        }\n    }\n\n    /// Creates a new `Duration` from the specified number of nanoseconds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_nanos(1_000_000_123);\n    ///\n    /// assert_eq!(1, duration.as_secs());\n    /// assert_eq!(123, duration.subsec_nanos());\n    /// ```\n    #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_nanos(nanos: u64) -> Duration {\n        Duration {\n            secs: nanos / (NANOS_PER_SEC as u64),\n            nanos: (nanos % (NANOS_PER_SEC as u64)) as u32,\n        }\n    }\n\n    /// Returns true if this `Duration` spans no time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert!(Duration::ZERO.is_zero());\n    /// assert!(Duration::new(0, 0).is_zero());\n    /// assert!(Duration::from_nanos(0).is_zero());\n    /// assert!(Duration::from_secs(0).is_zero());\n    ///\n    /// assert!(!Duration::new(1, 1).is_zero());\n    /// assert!(!Duration::from_nanos(1).is_zero());\n    /// assert!(!Duration::from_secs(1).is_zero());\n    /// ```\n    #[stable(feature = \"duration_zero\", since = \"1.53.0\")]\n    #[rustc_const_stable(feature = \"duration_zero\", since = \"1.53.0\")]\n    #[inline]\n    pub const fn is_zero(&self) -> bool {\n        self.secs == 0 && self.nanos == 0\n    }\n\n    /// Returns the number of _whole_ seconds contained by this `Duration`.\n    ///\n    /// The returned value does not include the fractional (nanosecond) part of the\n    /// duration, which can be obtained using [`subsec_nanos`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    /// assert_eq!(duration.as_secs(), 5);\n    /// ```\n    ///\n    /// To determine the total number of seconds represented by the `Duration`,\n    /// use `as_secs` in combination with [`subsec_nanos`]:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    ///\n    /// assert_eq!(5.730023852,\n    ///            duration.as_secs() as f64\n    ///            + duration.subsec_nanos() as f64 * 1e-9);\n    /// ```\n    ///\n    /// [`subsec_nanos`]: Duration::subsec_nanos\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[rustc_const_stable(feature = \"duration\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn as_secs(&self) -> u64 {\n        self.secs\n    }\n\n    /// Returns the fractional part of this `Duration`, in whole milliseconds.\n    ///\n    /// This method does **not** return the length of the duration when\n    /// represented by milliseconds. The returned number always represents a\n    /// fractional portion of a second (i.e., it is less than one thousand).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_millis(5432);\n    /// assert_eq!(duration.as_secs(), 5);\n    /// assert_eq!(duration.subsec_millis(), 432);\n    /// ```\n    #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n    #[rustc_const_stable(feature = \"duration_extras\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn subsec_millis(&self) -> u32 {\n        self.nanos / NANOS_PER_MILLI\n    }\n\n    /// Returns the fractional part of this `Duration`, in whole microseconds.\n    ///\n    /// This method does **not** return the length of the duration when\n    /// represented by microseconds. The returned number always represents a\n    /// fractional portion of a second (i.e., it is less than one million).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_micros(1_234_567);\n    /// assert_eq!(duration.as_secs(), 1);\n    /// assert_eq!(duration.subsec_micros(), 234_567);\n    /// ```\n    #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n    #[rustc_const_stable(feature = \"duration_extras\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn subsec_micros(&self) -> u32 {\n        self.nanos / NANOS_PER_MICRO\n    }\n\n    /// Returns the fractional part of this `Duration`, in nanoseconds.\n    ///\n    /// This method does **not** return the length of the duration when\n    /// represented by nanoseconds. The returned number always represents a\n    /// fractional portion of a second (i.e., it is less than one billion).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_millis(5010);\n    /// assert_eq!(duration.as_secs(), 5);\n    /// assert_eq!(duration.subsec_nanos(), 10_000_000);\n    /// ```\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[rustc_const_stable(feature = \"duration\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn subsec_nanos(&self) -> u32 {\n        self.nanos\n    }\n\n    /// Returns the total number of whole milliseconds contained by this `Duration`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    /// assert_eq!(duration.as_millis(), 5730);\n    /// ```\n    #[stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[rustc_const_stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[inline]\n    pub const fn as_millis(&self) -> u128 {\n        self.secs as u128 * MILLIS_PER_SEC as u128 + (self.nanos / NANOS_PER_MILLI) as u128\n    }\n\n    /// Returns the total number of whole microseconds contained by this `Duration`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    /// assert_eq!(duration.as_micros(), 5730023);\n    /// ```\n    #[stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[rustc_const_stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[inline]\n    pub const fn as_micros(&self) -> u128 {\n        self.secs as u128 * MICROS_PER_SEC as u128 + (self.nanos / NANOS_PER_MICRO) as u128\n    }\n\n    /// Returns the total number of nanoseconds contained by this `Duration`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    /// assert_eq!(duration.as_nanos(), 5730023852);\n    /// ```\n    #[stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[rustc_const_stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[inline]\n    pub const fn as_nanos(&self) -> u128 {\n        self.secs as u128 * NANOS_PER_SEC as u128 + self.nanos as u128\n    }\n\n    /// Checked `Duration` addition. Computes `self + other`, returning [`None`]\n    /// if overflow occurred.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)), Some(Duration::new(0, 1)));\n    /// assert_eq!(Duration::new(1, 0).checked_add(Duration::new(u64::MAX, 0)), None);\n    /// ```\n    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn checked_add(self, rhs: Duration) -> Option<Duration> {\n        if let Some(mut secs) = self.secs.checked_add(rhs.secs) {\n            let mut nanos = self.nanos + rhs.nanos;\n            if nanos >= NANOS_PER_SEC {\n                nanos -= NANOS_PER_SEC;\n                if let Some(new_secs) = secs.checked_add(1) {\n                    secs = new_secs;\n                } else {\n                    return None;\n                }\n            }\n            debug_assert!(nanos < NANOS_PER_SEC);\n            Some(Duration { secs, nanos })\n        } else {\n            None\n        }\n    }\n\n    /// Saturating `Duration` addition. Computes `self + other`, returning [`Duration::MAX`]\n    /// if overflow occurred.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(0, 0).saturating_add(Duration::new(0, 1)), Duration::new(0, 1));\n    /// assert_eq!(Duration::new(1, 0).saturating_add(Duration::new(u64::MAX, 0)), Duration::MAX);\n    /// ```\n    #[stable(feature = \"duration_saturating_ops\", since = \"1.53.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn saturating_add(self, rhs: Duration) -> Duration {\n        match self.checked_add(rhs) {\n            Some(res) => res,\n            None => Duration::MAX,\n        }\n    }\n\n    /// Checked `Duration` subtraction. Computes `self - other`, returning [`None`]\n    /// if the result would be negative or if overflow occurred.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(0, 1).checked_sub(Duration::new(0, 0)), Some(Duration::new(0, 1)));\n    /// assert_eq!(Duration::new(0, 0).checked_sub(Duration::new(0, 1)), None);\n    /// ```\n    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn checked_sub(self, rhs: Duration) -> Option<Duration> {\n        if let Some(mut secs) = self.secs.checked_sub(rhs.secs) {\n            let nanos = if self.nanos >= rhs.nanos {\n                self.nanos - rhs.nanos\n            } else if let Some(sub_secs) = secs.checked_sub(1) {\n                secs = sub_secs;\n                self.nanos + NANOS_PER_SEC - rhs.nanos\n            } else {\n                return None;\n            };\n            debug_assert!(nanos < NANOS_PER_SEC);\n            Some(Duration { secs, nanos })\n        } else {\n            None\n        }\n    }\n\n    /// Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::ZERO`]\n    /// if the result would be negative or if overflow occurred.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(0, 1).saturating_sub(Duration::new(0, 0)), Duration::new(0, 1));\n    /// assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::ZERO);\n    /// ```\n    #[stable(feature = \"duration_saturating_ops\", since = \"1.53.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn saturating_sub(self, rhs: Duration) -> Duration {\n        match self.checked_sub(rhs) {\n            Some(res) => res,\n            None => Duration::ZERO,\n        }\n    }\n\n    /// Checked `Duration` multiplication. Computes `self * other`, returning\n    /// [`None`] if overflow occurred.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(0, 500_000_001).checked_mul(2), Some(Duration::new(1, 2)));\n    /// assert_eq!(Duration::new(u64::MAX - 1, 0).checked_mul(2), None);\n    /// ```\n    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn checked_mul(self, rhs: u32) -> Option<Duration> {\n        // Multiply nanoseconds as u64, because it cannot overflow that way.\n        let total_nanos = self.nanos as u64 * rhs as u64;\n        let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n        let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n        if let Some(s) = self.secs.checked_mul(rhs as u64) {\n            if let Some(secs) = s.checked_add(extra_secs) {\n                debug_assert!(nanos < NANOS_PER_SEC);\n                return Some(Duration { secs, nanos });\n            }\n        }\n        None\n    }\n\n    /// Saturating `Duration` multiplication. Computes `self * other`, returning\n    /// [`Duration::MAX`] if overflow occurred.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(0, 500_000_001).saturating_mul(2), Duration::new(1, 2));\n    /// assert_eq!(Duration::new(u64::MAX - 1, 0).saturating_mul(2), Duration::MAX);\n    /// ```\n    #[stable(feature = \"duration_saturating_ops\", since = \"1.53.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn saturating_mul(self, rhs: u32) -> Duration {\n        match self.checked_mul(rhs) {\n            Some(res) => res,\n            None => Duration::MAX,\n        }\n    }\n\n    /// Checked `Duration` division. Computes `self / other`, returning [`None`]\n    /// if `other == 0`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(2, 0).checked_div(2), Some(Duration::new(1, 0)));\n    /// assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n    /// assert_eq!(Duration::new(2, 0).checked_div(0), None);\n    /// ```\n    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn checked_div(self, rhs: u32) -> Option<Duration> {\n        if rhs != 0 {\n            let secs = self.secs / (rhs as u64);\n            let carry = self.secs - secs * (rhs as u64);\n            let extra_nanos = carry * (NANOS_PER_SEC as u64) / (rhs as u64);\n            let nanos = self.nanos / rhs + (extra_nanos as u32);\n            debug_assert!(nanos < NANOS_PER_SEC);\n            Some(Duration { secs, nanos })\n        } else {\n            None\n        }\n    }\n\n    /// Returns the number of seconds contained by this `Duration` as `f64`.\n    ///\n    /// The returned value does include the fractional (nanosecond) part of the duration.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// assert_eq!(dur.as_secs_f64(), 2.7);\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn as_secs_f64(&self) -> f64 {\n        (self.secs as f64) + (self.nanos as f64) / (NANOS_PER_SEC as f64)\n    }\n\n    /// Returns the number of seconds contained by this `Duration` as `f32`.\n    ///\n    /// The returned value does include the fractional (nanosecond) part of the duration.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// assert_eq!(dur.as_secs_f32(), 2.7);\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn as_secs_f32(&self) -> f32 {\n        (self.secs as f32) + (self.nanos as f32) / (NANOS_PER_SEC as f32)\n    }\n\n    /// Creates a new `Duration` from the specified number of seconds represented\n    /// as `f64`.\n    ///\n    /// # Panics\n    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::from_secs_f64(2.7);\n    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn from_secs_f64(secs: f64) -> Duration {\n        match Duration::try_from_secs_f64(secs) {\n            Ok(v) => v,\n            Err(e) => crate::panicking::panic(e.description()),\n        }\n    }\n\n    /// The checked version of [`from_secs_f64`].\n    ///\n    /// [`from_secs_f64`]: Duration::from_secs_f64\n    ///\n    /// This constructor will return an `Err` if `secs` is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// #![feature(duration_checked_float)]\n    ///\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::try_from_secs_f64(2.7);\n    /// assert_eq!(dur, Ok(Duration::new(2, 700_000_000)));\n    ///\n    /// let negative = Duration::try_from_secs_f64(-5.0);\n    /// assert!(negative.is_err());\n    /// ```\n    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n    #[inline]\n    pub const fn try_from_secs_f64(secs: f64) -> Result<Duration, FromSecsError> {\n        const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f64;\n        let nanos = secs * (NANOS_PER_SEC as f64);\n        if !nanos.is_finite() {\n            Err(FromSecsError { kind: FromSecsErrorKind::NonFinite })\n        } else if nanos >= MAX_NANOS_F64 {\n            Err(FromSecsError { kind: FromSecsErrorKind::Overflow })\n        } else if nanos < 0.0 {\n            Err(FromSecsError { kind: FromSecsErrorKind::Underflow })\n        } else {\n            let nanos = nanos as u128;\n            Ok(Duration {\n                secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n                nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n            })\n        }\n    }\n\n    /// Creates a new `Duration` from the specified number of seconds represented\n    /// as `f32`.\n    ///\n    /// # Panics\n    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::from_secs_f32(2.7);\n    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn from_secs_f32(secs: f32) -> Duration {\n        match Duration::try_from_secs_f32(secs) {\n            Ok(v) => v,\n            Err(e) => crate::panicking::panic(e.description()),\n        }\n    }\n\n    /// The checked version of [`from_secs_f32`].\n    ///\n    /// [`from_secs_f32`]: Duration::from_secs_f32\n    ///\n    /// This constructor will return an `Err` if `secs` is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// #![feature(duration_checked_float)]\n    ///\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::try_from_secs_f32(2.7);\n    /// assert_eq!(dur, Ok(Duration::new(2, 700_000_000)));\n    ///\n    /// let negative = Duration::try_from_secs_f32(-5.0);\n    /// assert!(negative.is_err());\n    /// ```\n    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n    #[inline]\n    pub const fn try_from_secs_f32(secs: f32) -> Result<Duration, FromSecsError> {\n        const MAX_NANOS_F32: f32 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f32;\n        let nanos = secs * (NANOS_PER_SEC as f32);\n        if !nanos.is_finite() {\n            Err(FromSecsError { kind: FromSecsErrorKind::NonFinite })\n        } else if nanos >= MAX_NANOS_F32 {\n            Err(FromSecsError { kind: FromSecsErrorKind::Overflow })\n        } else if nanos < 0.0 {\n            Err(FromSecsError { kind: FromSecsErrorKind::Underflow })\n        } else {\n            let nanos = nanos as u128;\n            Ok(Duration {\n                secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n                nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n            })\n        }\n    }\n\n    /// Multiplies `Duration` by `f64`.\n    ///\n    /// # Panics\n    /// This method will panic if result is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// assert_eq!(dur.mul_f64(3.14), Duration::new(8, 478_000_000));\n    /// assert_eq!(dur.mul_f64(3.14e5), Duration::new(847_800, 0));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn mul_f64(self, rhs: f64) -> Duration {\n        Duration::from_secs_f64(rhs * self.as_secs_f64())\n    }\n\n    /// Multiplies `Duration` by `f32`.\n    ///\n    /// # Panics\n    /// This method will panic if result is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// // note that due to rounding errors result is slightly different\n    /// // from 8.478 and 847800.0\n    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_640));\n    /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847799, 969_120_256));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn mul_f32(self, rhs: f32) -> Duration {\n        Duration::from_secs_f32(rhs * self.as_secs_f32())\n    }\n\n    /// Divide `Duration` by `f64`.\n    ///\n    /// # Panics\n    /// This method will panic if result is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));\n    /// // note that truncation is used, not rounding\n    /// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_598));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn div_f64(self, rhs: f64) -> Duration {\n        Duration::from_secs_f64(self.as_secs_f64() / rhs)\n    }\n\n    /// Divide `Duration` by `f32`.\n    ///\n    /// # Panics\n    /// This method will panic if result is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// // note that due to rounding errors result is slightly\n    /// // different from 0.859_872_611\n    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_576));\n    /// // note that truncation is used, not rounding\n    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_598));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn div_f32(self, rhs: f32) -> Duration {\n        Duration::from_secs_f32(self.as_secs_f32() / rhs)\n    }\n\n    /// Divide `Duration` by `Duration` and return `f64`.\n    ///\n    /// # Examples\n    /// ```\n    /// #![feature(div_duration)]\n    /// use std::time::Duration;\n    ///\n    /// let dur1 = Duration::new(2, 700_000_000);\n    /// let dur2 = Duration::new(5, 400_000_000);\n    /// assert_eq!(dur1.div_duration_f64(dur2), 0.5);\n    /// ```\n    #[unstable(feature = \"div_duration\", issue = \"63139\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn div_duration_f64(self, rhs: Duration) -> f64 {\n        self.as_secs_f64() / rhs.as_secs_f64()\n    }\n\n    /// Divide `Duration` by `Duration` and return `f32`.\n    ///\n    /// # Examples\n    /// ```\n    /// #![feature(div_duration)]\n    /// use std::time::Duration;\n    ///\n    /// let dur1 = Duration::new(2, 700_000_000);\n    /// let dur2 = Duration::new(5, 400_000_000);\n    /// assert_eq!(dur1.div_duration_f32(dur2), 0.5);\n    /// ```\n    #[unstable(feature = \"div_duration\", issue = \"63139\")]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n    pub const fn div_duration_f32(self, rhs: Duration) -> f32 {\n        self.as_secs_f32() / rhs.as_secs_f32()\n    }\n}\n\n#[stable(feature = \"duration\", since = \"1.3.0\")]\nimpl Add for Duration {\n    type Output = Duration;\n\n    fn add(self, rhs: Duration) -> Duration {\n        self.checked_add(rhs).expect(\"overflow when adding durations\")\n    }\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl AddAssign for Duration {\n    fn add_assign(&mut self, rhs: Duration) {\n        *self = *self + rhs;\n    }\n}\n\n#[stable(feature = \"duration\", since = \"1.3.0\")]\nimpl Sub for Duration {\n    type Output = Duration;\n\n    fn sub(self, rhs: Duration) -> Duration {\n        self.checked_sub(rhs).expect(\"overflow when subtracting durations\")\n    }\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl SubAssign for Duration {\n    fn sub_assign(&mut self, rhs: Duration) {\n        *self = *self - rhs;\n    }\n}\n\n#[stable(feature = \"duration\", since = \"1.3.0\")]\nimpl Mul<u32> for Duration {\n    type Output = Duration;\n\n    fn mul(self, rhs: u32) -> Duration {\n        self.checked_mul(rhs).expect(\"overflow when multiplying duration by scalar\")\n    }\n}\n\n#[stable(feature = \"symmetric_u32_duration_mul\", since = \"1.31.0\")]\nimpl Mul<Duration> for u32 {\n    type Output = Duration;\n\n    fn mul(self, rhs: Duration) -> Duration {\n        rhs * self\n    }\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl MulAssign<u32> for Duration {\n    fn mul_assign(&mut self, rhs: u32) {\n        *self = *self * rhs;\n    }\n}\n\n#[stable(feature = \"duration\", since = \"1.3.0\")]\nimpl Div<u32> for Duration {\n    type Output = Duration;\n\n    fn div(self, rhs: u32) -> Duration {\n        self.checked_div(rhs).expect(\"divide by zero error when dividing duration by scalar\")\n    }\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl DivAssign<u32> for Duration {\n    fn div_assign(&mut self, rhs: u32) {\n        *self = *self / rhs;\n    }\n}\n\nmacro_rules! sum_durations {\n    ($iter:expr) => {{\n        let mut total_secs: u64 = 0;\n        let mut total_nanos: u64 = 0;\n\n        for entry in $iter {\n            total_secs =\n                total_secs.checked_add(entry.secs).expect(\"overflow in iter::sum over durations\");\n            total_nanos = match total_nanos.checked_add(entry.nanos as u64) {\n                Some(n) => n,\n                None => {\n                    total_secs = total_secs\n                        .checked_add(total_nanos / NANOS_PER_SEC as u64)\n                        .expect(\"overflow in iter::sum over durations\");\n                    (total_nanos % NANOS_PER_SEC as u64) + entry.nanos as u64\n                }\n            };\n        }\n        total_secs = total_secs\n            .checked_add(total_nanos / NANOS_PER_SEC as u64)\n            .expect(\"overflow in iter::sum over durations\");\n        total_nanos = total_nanos % NANOS_PER_SEC as u64;\n        Duration { secs: total_secs, nanos: total_nanos as u32 }\n    }};\n}\n\n#[stable(feature = \"duration_sum\", since = \"1.16.0\")]\nimpl Sum for Duration {\n    fn sum<I: Iterator<Item = Duration>>(iter: I) -> Duration {\n        sum_durations!(iter)\n    }\n}\n\n#[stable(feature = \"duration_sum\", since = \"1.16.0\")]\nimpl<'a> Sum<&'a Duration> for Duration {\n    fn sum<I: Iterator<Item = &'a Duration>>(iter: I) -> Duration {\n        sum_durations!(iter)\n    }\n}\n\n#[stable(feature = \"duration_debug_impl\", since = \"1.27.0\")]\nimpl fmt::Debug for Duration {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        /// Formats a floating point number in decimal notation.\n        ///\n        /// The number is given as the `integer_part` and a fractional part.\n        /// The value of the fractional part is `fractional_part / divisor`. So\n        /// `integer_part` = 3, `fractional_part` = 12 and `divisor` = 100\n        /// represents the number `3.012`. Trailing zeros are omitted.\n        ///\n        /// `divisor` must not be above 100_000_000. It also should be a power\n        /// of 10, everything else doesn't make sense. `fractional_part` has\n        /// to be less than `10 * divisor`!\n        fn fmt_decimal(\n            f: &mut fmt::Formatter<'_>,\n            mut integer_part: u64,\n            mut fractional_part: u32,\n            mut divisor: u32,\n        ) -> fmt::Result {\n            // Encode the fractional part into a temporary buffer. The buffer\n            // only need to hold 9 elements, because `fractional_part` has to\n            // be smaller than 10^9. The buffer is prefilled with '0' digits\n            // to simplify the code below.\n            let mut buf = [b'0'; 9];\n\n            // The next digit is written at this position\n            let mut pos = 0;\n\n            // We keep writing digits into the buffer while there are non-zero\n            // digits left and we haven't written enough digits yet.\n            while fractional_part > 0 && pos < f.precision().unwrap_or(9) {\n                // Write new digit into the buffer\n                buf[pos] = b'0' + (fractional_part / divisor) as u8;\n\n                fractional_part %= divisor;\n                divisor /= 10;\n                pos += 1;\n            }\n\n            // If a precision < 9 was specified, there may be some non-zero\n            // digits left that weren't written into the buffer. In that case we\n            // need to perform rounding to match the semantics of printing\n            // normal floating point numbers. However, we only need to do work\n            // when rounding up. This happens if the first digit of the\n            // remaining ones is >= 5.\n            if fractional_part > 0 && fractional_part >= divisor * 5 {\n                // Round up the number contained in the buffer. We go through\n                // the buffer backwards and keep track of the carry.\n                let mut rev_pos = pos;\n                let mut carry = true;\n                while carry && rev_pos > 0 {\n                    rev_pos -= 1;\n\n                    // If the digit in the buffer is not '9', we just need to\n                    // increment it and can stop then (since we don't have a\n                    // carry anymore). Otherwise, we set it to '0' (overflow)\n                    // and continue.\n                    if buf[rev_pos] < b'9' {\n                        buf[rev_pos] += 1;\n                        carry = false;\n                    } else {\n                        buf[rev_pos] = b'0';\n                    }\n                }\n\n                // If we still have the carry bit set, that means that we set\n                // the whole buffer to '0's and need to increment the integer\n                // part.\n                if carry {\n                    integer_part += 1;\n                }\n            }\n\n            // Determine the end of the buffer: if precision is set, we just\n            // use as many digits from the buffer (capped to 9). If it isn't\n            // set, we only use all digits up to the last non-zero one.\n            let end = f.precision().map(|p| crate::cmp::min(p, 9)).unwrap_or(pos);\n\n            // If we haven't emitted a single fractional digit and the precision\n            // wasn't set to a non-zero value, we don't print the decimal point.\n            if end == 0 {\n                write!(f, \"{}\", integer_part)\n            } else {\n                // SAFETY: We are only writing ASCII digits into the buffer and it was\n                // initialized with '0's, so it contains valid UTF8.\n                let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n\n                // If the user request a precision > 9, we pad '0's at the end.\n                let w = f.precision().unwrap_or(pos);\n                write!(f, \"{}.{:0<width$}\", integer_part, s, width = w)\n            }\n        }\n\n        // Print leading '+' sign if requested\n        if f.sign_plus() {\n            write!(f, \"+\")?;\n        }\n\n        if self.secs > 0 {\n            fmt_decimal(f, self.secs, self.nanos, NANOS_PER_SEC / 10)?;\n            f.write_str(\"s\")\n        } else if self.nanos >= NANOS_PER_MILLI {\n            fmt_decimal(\n                f,\n                (self.nanos / NANOS_PER_MILLI) as u64,\n                self.nanos % NANOS_PER_MILLI,\n                NANOS_PER_MILLI / 10,\n            )?;\n            f.write_str(\"ms\")\n        } else if self.nanos >= NANOS_PER_MICRO {\n            fmt_decimal(\n                f,\n                (self.nanos / NANOS_PER_MICRO) as u64,\n                self.nanos % NANOS_PER_MICRO,\n                NANOS_PER_MICRO / 10,\n            )?;\n            f.write_str(\"µs\")\n        } else {\n            fmt_decimal(f, self.nanos as u64, 0, 1)?;\n            f.write_str(\"ns\")\n        }\n    }\n}\n\n/// An error which can be returned when converting a floating-point value of seconds\n/// into a [`Duration`].\n///\n/// This error is used as the error type for [`Duration::try_from_secs_f32`] and\n/// [`Duration::try_from_secs_f64`].\n///\n/// # Example\n///\n/// ```\n/// #![feature(duration_checked_float)]\n///\n/// use std::time::Duration;\n///\n/// if let Err(e) = Duration::try_from_secs_f32(-1.0) {\n///     println!(\"Failed conversion to Duration: {}\", e);\n/// }\n/// ```\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\npub struct FromSecsError {\n    kind: FromSecsErrorKind,\n}\n\nimpl FromSecsError {\n    const fn description(&self) -> &'static str {\n        match self.kind {\n            FromSecsErrorKind::NonFinite => {\n                \"got non-finite value when converting float to duration\"\n            }\n            FromSecsErrorKind::Overflow => \"overflow when converting float to duration\",\n            FromSecsErrorKind::Underflow => \"underflow when converting float to duration\",\n        }\n    }\n}\n\n#[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\nimpl fmt::Display for FromSecsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.description(), f)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum FromSecsErrorKind {\n    // Value is not a finite value (either infinity or NaN).\n    NonFinite,\n    // Value is too large to store in a `Duration`.\n    Overflow,\n    // Value is less than `0.0`.\n    Underflow,\n}\n"],[2907,"#![stable(feature = \"\", since = \"1.30.0\")]\n#![allow(non_camel_case_types)]\n\n//! Utilities related to foreign function interface (FFI) bindings.\n\nuse crate::fmt;\nuse crate::marker::PhantomData;\nuse crate::ops::{Deref, DerefMut};\n\n/// Equivalent to C's `void` type when used as a [pointer].\n///\n/// In essence, `*const c_void` is equivalent to C's `const void*`\n/// and `*mut c_void` is equivalent to C's `void*`. That said, this is\n/// *not* the same as C's `void` return type, which is Rust's `()` type.\n///\n/// To model pointers to opaque types in FFI, until `extern type` is\n/// stabilized, it is recommended to use a newtype wrapper around an empty\n/// byte array. See the [Nomicon] for details.\n///\n/// One could use `std::os::raw::c_void` if they want to support old Rust\n/// compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by\n/// this definition. For more information, please read [RFC 2521].\n///\n/// [Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs\n/// [RFC 2521]: https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md\n// N.B., for LLVM to recognize the void pointer type and by extension\n//     functions like malloc(), we need to have it represented as i8* in\n//     LLVM bitcode. The enum used here ensures this and prevents misuse\n//     of the \"raw\" type by only having private variants. We need two\n//     variants, because the compiler complains about the repr attribute\n//     otherwise and we need at least one variant as otherwise the enum\n//     would be uninhabited and at least dereferencing such pointers would\n//     be UB.\n#[repr(u8)]\n#[stable(feature = \"core_c_void\", since = \"1.30.0\")]\npub enum c_void {\n    #[unstable(\n        feature = \"c_void_variant\",\n        reason = \"temporary implementation detail\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    __variant1,\n    #[unstable(\n        feature = \"c_void_variant\",\n        reason = \"temporary implementation detail\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    __variant2,\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for c_void {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"c_void\").finish()\n    }\n}\n\n/// Basic implementation of a `va_list`.\n// The name is WIP, using `VaListImpl` for now.\n#[cfg(any(\n    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n    all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n    target_arch = \"wasm32\",\n    target_arch = \"asmjs\",\n    windows\n))]\n#[repr(transparent)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\n#[lang = \"va_list\"]\npub struct VaListImpl<'f> {\n    ptr: *mut c_void,\n\n    // Invariant over `'f`, so each `VaListImpl<'f>` object is tied to\n    // the region of the function it's defined in\n    _marker: PhantomData<&'f mut &'f c_void>,\n}\n\n#[cfg(any(\n    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n    all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n    target_arch = \"wasm32\",\n    target_arch = \"asmjs\",\n    windows\n))]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> fmt::Debug for VaListImpl<'f> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"va_list* {:p}\", self.ptr)\n    }\n}\n\n/// AArch64 ABI implementation of a `va_list`. See the\n/// [AArch64 Procedure Call Standard] for more details.\n///\n/// [AArch64 Procedure Call Standard]:\n/// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf\n#[cfg(all(\n    target_arch = \"aarch64\",\n    not(any(target_os = \"macos\", target_os = \"ios\")),\n    not(windows)\n))]\n#[repr(C)]\n#[derive(Debug)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\n#[lang = \"va_list\"]\npub struct VaListImpl<'f> {\n    stack: *mut c_void,\n    gr_top: *mut c_void,\n    vr_top: *mut c_void,\n    gr_offs: i32,\n    vr_offs: i32,\n    _marker: PhantomData<&'f mut &'f c_void>,\n}\n\n/// PowerPC ABI implementation of a `va_list`.\n#[cfg(all(target_arch = \"powerpc\", not(windows)))]\n#[repr(C)]\n#[derive(Debug)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\n#[lang = \"va_list\"]\npub struct VaListImpl<'f> {\n    gpr: u8,\n    fpr: u8,\n    reserved: u16,\n    overflow_arg_area: *mut c_void,\n    reg_save_area: *mut c_void,\n    _marker: PhantomData<&'f mut &'f c_void>,\n}\n\n/// x86_64 ABI implementation of a `va_list`.\n#[cfg(all(target_arch = \"x86_64\", not(windows)))]\n#[repr(C)]\n#[derive(Debug)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\n#[lang = \"va_list\"]\npub struct VaListImpl<'f> {\n    gp_offset: i32,\n    fp_offset: i32,\n    overflow_arg_area: *mut c_void,\n    reg_save_area: *mut c_void,\n    _marker: PhantomData<&'f mut &'f c_void>,\n}\n\n/// A wrapper for a `va_list`\n#[repr(transparent)]\n#[derive(Debug)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\npub struct VaList<'a, 'f: 'a> {\n    #[cfg(any(\n        all(\n            not(target_arch = \"aarch64\"),\n            not(target_arch = \"powerpc\"),\n            not(target_arch = \"x86_64\")\n        ),\n        all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n        target_arch = \"wasm32\",\n        target_arch = \"asmjs\",\n        windows\n    ))]\n    inner: VaListImpl<'f>,\n\n    #[cfg(all(\n        any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n        any(not(target_arch = \"aarch64\"), not(any(target_os = \"macos\", target_os = \"ios\"))),\n        not(target_arch = \"wasm32\"),\n        not(target_arch = \"asmjs\"),\n        not(windows)\n    ))]\n    inner: &'a mut VaListImpl<'f>,\n\n    _marker: PhantomData<&'a mut VaListImpl<'f>>,\n}\n\n#[cfg(any(\n    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n    all(target_arch = \"aarch64\", any(target_os = \"macos\", target_os = \"ios\")),\n    target_arch = \"wasm32\",\n    target_arch = \"asmjs\",\n    windows\n))]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> VaListImpl<'f> {\n    /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n    #[inline]\n    pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n        VaList { inner: VaListImpl { ..*self }, _marker: PhantomData }\n    }\n}\n\n#[cfg(all(\n    any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n    any(not(target_arch = \"aarch64\"), not(any(target_os = \"macos\", target_os = \"ios\"))),\n    not(target_arch = \"wasm32\"),\n    not(target_arch = \"asmjs\"),\n    not(windows)\n))]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> VaListImpl<'f> {\n    /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n    #[inline]\n    pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n        VaList { inner: self, _marker: PhantomData }\n    }\n}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'a, 'f: 'a> Deref for VaList<'a, 'f> {\n    type Target = VaListImpl<'f>;\n\n    #[inline]\n    fn deref(&self) -> &VaListImpl<'f> {\n        &self.inner\n    }\n}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'a, 'f: 'a> DerefMut for VaList<'a, 'f> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut VaListImpl<'f> {\n        &mut self.inner\n    }\n}\n\n// The VaArgSafe trait needs to be used in public interfaces, however, the trait\n// itself must not be allowed to be used outside this module. Allowing users to\n// implement the trait for a new type (thereby allowing the va_arg intrinsic to\n// be used on a new type) is likely to cause undefined behavior.\n//\n// FIXME(dlrobertson): In order to use the VaArgSafe trait in a public interface\n// but also ensure it cannot be used elsewhere, the trait needs to be public\n// within a private module. Once RFC 2145 has been implemented look into\n// improving this.\nmod sealed_trait {\n    /// Trait which permits the allowed types to be used with [super::VaListImpl::arg].\n    #[unstable(\n        feature = \"c_variadic\",\n        reason = \"the `c_variadic` feature has not been properly tested on \\\n                  all supported platforms\",\n        issue = \"44930\"\n    )]\n    pub trait VaArgSafe {}\n}\n\nmacro_rules! impl_va_arg_safe {\n    ($($t:ty),+) => {\n        $(\n            #[unstable(feature = \"c_variadic\",\n                       reason = \"the `c_variadic` feature has not been properly tested on \\\n                                 all supported platforms\",\n                       issue = \"44930\")]\n            impl sealed_trait::VaArgSafe for $t {}\n        )+\n    }\n}\n\nimpl_va_arg_safe! {i8, i16, i32, i64, usize}\nimpl_va_arg_safe! {u8, u16, u32, u64, isize}\nimpl_va_arg_safe! {f64}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<T> sealed_trait::VaArgSafe for *mut T {}\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<T> sealed_trait::VaArgSafe for *const T {}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> VaListImpl<'f> {\n    /// Advance to the next arg.\n    #[inline]\n    pub unsafe fn arg<T: sealed_trait::VaArgSafe>(&mut self) -> T {\n        // SAFETY: the caller must uphold the safety contract for `va_arg`.\n        unsafe { va_arg(self) }\n    }\n\n    /// Copies the `va_list` at the current location.\n    pub unsafe fn with_copy<F, R>(&self, f: F) -> R\n    where\n        F: for<'copy> FnOnce(VaList<'copy, 'f>) -> R,\n    {\n        let mut ap = self.clone();\n        let ret = f(ap.as_va_list());\n        // SAFETY: the caller must uphold the safety contract for `va_end`.\n        unsafe {\n            va_end(&mut ap);\n        }\n        ret\n    }\n}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> Clone for VaListImpl<'f> {\n    #[inline]\n    fn clone(&self) -> Self {\n        let mut dest = crate::mem::MaybeUninit::uninit();\n        // SAFETY: we write to the `MaybeUninit`, thus it is initialized and `assume_init` is legal\n        unsafe {\n            va_copy(dest.as_mut_ptr(), self);\n            dest.assume_init()\n        }\n    }\n}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> Drop for VaListImpl<'f> {\n    fn drop(&mut self) {\n        // FIXME: this should call `va_end`, but there's no clean way to\n        // guarantee that `drop` always gets inlined into its caller,\n        // so the `va_end` would get directly called from the same function as\n        // the corresponding `va_copy`. `man va_end` states that C requires this,\n        // and LLVM basically follows the C semantics, so we need to make sure\n        // that `va_end` is always called from the same function as `va_copy`.\n        // For more details, see https://github.com/rust-lang/rust/pull/59625\n        // and https://llvm.org/docs/LangRef.html#llvm-va-end-intrinsic.\n        //\n        // This works for now, since `va_end` is a no-op on all current LLVM targets.\n    }\n}\n\nextern \"rust-intrinsic\" {\n    /// Destroy the arglist `ap` after initialization with `va_start` or\n    /// `va_copy`.\n    fn va_end(ap: &mut VaListImpl<'_>);\n\n    /// Copies the current location of arglist `src` to the arglist `dst`.\n    fn va_copy<'f>(dest: *mut VaListImpl<'f>, src: &VaListImpl<'f>);\n\n    /// Loads an argument of type `T` from the `va_list` `ap` and increment the\n    /// argument `ap` points to.\n    fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaListImpl<'_>) -> T;\n}\n"],[2908,"#[test]\nfn test_borrowed_clone() {\n    let x = 5;\n    let y: &i32 = &x;\n    let z: &i32 = (&y).clone();\n    assert_eq!(*z, 5);\n}\n\n#[test]\nfn test_clone_from() {\n    let a = box 5;\n    let mut b = box 10;\n    b.clone_from(&a);\n    assert_eq!(*b, 5);\n}\n"],[2909,"#[test]\npub fn version() {\n    let (major, _minor, _update) = core::unicode::UNICODE_VERSION;\n    assert!(major >= 10);\n}\n"],[2910,"use core::mem::ManuallyDrop;\n\n#[test]\nfn smoke() {\n    struct TypeWithDrop;\n    impl Drop for TypeWithDrop {\n        fn drop(&mut self) {\n            unreachable!(\"Should not get dropped\");\n        }\n    }\n\n    let x = ManuallyDrop::new(TypeWithDrop);\n    drop(x);\n\n    // also test unsizing\n    let x: Box<ManuallyDrop<[TypeWithDrop]>> =\n        Box::new(ManuallyDrop::new([TypeWithDrop, TypeWithDrop]));\n    drop(x);\n}\n"],[2911,"use core::cmp::Ordering::{Equal, Greater, Less};\nuse core::ops::{BitAnd, BitOr, BitXor};\n\n#[test]\nfn test_bool() {\n    assert_eq!(false.eq(&true), false);\n    assert_eq!(false == false, true);\n    assert_eq!(false != true, true);\n    assert_eq!(false.ne(&false), false);\n\n    assert_eq!(false.bitand(false), false);\n    assert_eq!(true.bitand(false), false);\n    assert_eq!(false.bitand(true), false);\n    assert_eq!(true.bitand(true), true);\n\n    assert_eq!(false & false, false);\n    assert_eq!(true & false, false);\n    assert_eq!(false & true, false);\n    assert_eq!(true & true, true);\n\n    assert_eq!(false.bitor(false), false);\n    assert_eq!(true.bitor(false), true);\n    assert_eq!(false.bitor(true), true);\n    assert_eq!(true.bitor(true), true);\n\n    assert_eq!(false | false, false);\n    assert_eq!(true | false, true);\n    assert_eq!(false | true, true);\n    assert_eq!(true | true, true);\n\n    assert_eq!(false.bitxor(false), false);\n    assert_eq!(true.bitxor(false), true);\n    assert_eq!(false.bitxor(true), true);\n    assert_eq!(true.bitxor(true), false);\n\n    assert_eq!(false ^ false, false);\n    assert_eq!(true ^ false, true);\n    assert_eq!(false ^ true, true);\n    assert_eq!(true ^ true, false);\n\n    assert_eq!(!true, false);\n    assert_eq!(!false, true);\n\n    let s = false.to_string();\n    assert_eq!(s, \"false\");\n    let s = true.to_string();\n    assert_eq!(s, \"true\");\n\n    assert!(true > false);\n    assert!(!(false > true));\n\n    assert!(false < true);\n    assert!(!(true < false));\n\n    assert!(false <= false);\n    assert!(false >= false);\n    assert!(true <= true);\n    assert!(true >= true);\n\n    assert!(false <= true);\n    assert!(!(false >= true));\n    assert!(true >= false);\n    assert!(!(true <= false));\n\n    assert_eq!(true.cmp(&true), Equal);\n    assert_eq!(false.cmp(&false), Equal);\n    assert_eq!(true.cmp(&false), Greater);\n    assert_eq!(false.cmp(&true), Less);\n}\n\n#[test]\npub fn test_bool_not() {\n    if !false {\n        assert!((true));\n    } else {\n        assert!((false));\n    }\n    if !true {\n        assert!((false));\n    } else {\n        assert!((true));\n    }\n}\n\n#[test]\nfn test_bool_to_option() {\n    assert_eq!(false.then_some(0), None);\n    assert_eq!(true.then_some(0), Some(0));\n    assert_eq!(false.then(|| 0), None);\n    assert_eq!(true.then(|| 0), Some(0));\n}\n"],[2912,"use std::str::pattern::*;\n\n// This macro makes it easier to write\n// tests that do a series of iterations\nmacro_rules! search_asserts {\n    ($haystack:expr, $needle:expr, $testname:expr, [$($func:ident),*], $result:expr) => {\n        let mut searcher = $needle.into_searcher($haystack);\n        let arr = [$( Step::from(searcher.$func()) ),*];\n        assert_eq!(&arr[..], &$result, $testname);\n    }\n}\n\n/// Combined enum for the results of next() and next_match()/next_reject()\n#[derive(Debug, PartialEq, Eq)]\nenum Step {\n    // variant names purposely chosen to\n    // be the same length for easy alignment\n    Matches(usize, usize),\n    Rejects(usize, usize),\n    InRange(usize, usize),\n    Done,\n}\n\nuse self::Step::*;\n\nimpl From<SearchStep> for Step {\n    fn from(x: SearchStep) -> Self {\n        match x {\n            SearchStep::Match(a, b) => Matches(a, b),\n            SearchStep::Reject(a, b) => Rejects(a, b),\n            SearchStep::Done => Done,\n        }\n    }\n}\n\nimpl From<Option<(usize, usize)>> for Step {\n    fn from(x: Option<(usize, usize)>) -> Self {\n        match x {\n            Some((a, b)) => InRange(a, b),\n            None => Done,\n        }\n    }\n}\n\n// FIXME(Manishearth) these tests focus on single-character searching  (CharSearcher)\n// and on next()/next_match(), not next_reject(). This is because\n// the memchr changes make next_match() for single chars complex, but next_reject()\n// continues to use next() under the hood. We should add more test cases for all\n// of these, as well as tests for StrSearcher and higher level tests for str::find() (etc)\n\n#[test]\nfn test_simple_iteration() {\n    search_asserts!(\n        \"abcdeabcd\",\n        'a',\n        \"forward iteration for ASCII string\",\n        // a            b              c              d              e              a              b              c              d              EOF\n        [next, next, next, next, next, next, next, next, next, next],\n        [\n            Matches(0, 1),\n            Rejects(1, 2),\n            Rejects(2, 3),\n            Rejects(3, 4),\n            Rejects(4, 5),\n            Matches(5, 6),\n            Rejects(6, 7),\n            Rejects(7, 8),\n            Rejects(8, 9),\n            Done\n        ]\n    );\n\n    search_asserts!(\n        \"abcdeabcd\",\n        'a',\n        \"reverse iteration for ASCII string\",\n        // d            c              b              a            e                d              c              b              a             EOF\n        [\n            next_back, next_back, next_back, next_back, next_back, next_back, next_back, next_back,\n            next_back, next_back\n        ],\n        [\n            Rejects(8, 9),\n            Rejects(7, 8),\n            Rejects(6, 7),\n            Matches(5, 6),\n            Rejects(4, 5),\n            Rejects(3, 4),\n            Rejects(2, 3),\n            Rejects(1, 2),\n            Matches(0, 1),\n            Done\n        ]\n    );\n\n    search_asserts!(\n        \"我爱我的猫\",\n        '我',\n        \"forward iteration for Chinese string\",\n        // 我           愛             我             的              貓               EOF\n        [next, next, next, next, next, next],\n        [Matches(0, 3), Rejects(3, 6), Matches(6, 9), Rejects(9, 12), Rejects(12, 15), Done]\n    );\n\n    search_asserts!(\n        \"我的猫说meow\",\n        'm',\n        \"forward iteration for mixed string\",\n        // 我           的             猫             说              m                e                o                w                EOF\n        [next, next, next, next, next, next, next, next, next],\n        [\n            Rejects(0, 3),\n            Rejects(3, 6),\n            Rejects(6, 9),\n            Rejects(9, 12),\n            Matches(12, 13),\n            Rejects(13, 14),\n            Rejects(14, 15),\n            Rejects(15, 16),\n            Done\n        ]\n    );\n\n    search_asserts!(\n        \"我的猫说meow\",\n        '猫',\n        \"reverse iteration for mixed string\",\n        // w             o                 e                m                说              猫             的             我             EOF\n        [\n            next_back, next_back, next_back, next_back, next_back, next_back, next_back, next_back,\n            next_back\n        ],\n        [\n            Rejects(15, 16),\n            Rejects(14, 15),\n            Rejects(13, 14),\n            Rejects(12, 13),\n            Rejects(9, 12),\n            Matches(6, 9),\n            Rejects(3, 6),\n            Rejects(0, 3),\n            Done\n        ]\n    );\n}\n\n#[test]\nfn test_simple_search() {\n    search_asserts!(\n        \"abcdeabcdeabcde\",\n        'a',\n        \"next_match for ASCII string\",\n        [next_match, next_match, next_match, next_match],\n        [InRange(0, 1), InRange(5, 6), InRange(10, 11), Done]\n    );\n\n    search_asserts!(\n        \"abcdeabcdeabcde\",\n        'a',\n        \"next_match_back for ASCII string\",\n        [next_match_back, next_match_back, next_match_back, next_match_back],\n        [InRange(10, 11), InRange(5, 6), InRange(0, 1), Done]\n    );\n\n    search_asserts!(\n        \"abcdeab\",\n        'a',\n        \"next_reject for ASCII string\",\n        [next_reject, next_reject, next_match, next_reject, next_reject],\n        [InRange(1, 2), InRange(2, 3), InRange(5, 6), InRange(6, 7), Done]\n    );\n\n    search_asserts!(\n        \"abcdeabcdeabcde\",\n        'a',\n        \"next_reject_back for ASCII string\",\n        [\n            next_reject_back,\n            next_reject_back,\n            next_match_back,\n            next_reject_back,\n            next_reject_back,\n            next_reject_back\n        ],\n        [\n            InRange(14, 15),\n            InRange(13, 14),\n            InRange(10, 11),\n            InRange(9, 10),\n            InRange(8, 9),\n            InRange(7, 8)\n        ]\n    );\n}\n\n// Á, 각, ก, 😀 all end in 0x81\n// 🁀, ᘀ do not end in 0x81 but contain the byte\n// ꁁ has 0x81 as its second and third bytes.\n//\n// The memchr-using implementation of next_match\n// and next_match_back temporarily violate\n// the property that the search is always on a unicode boundary,\n// which is fine as long as this never reaches next() or next_back().\n// So we test if next() is correct after each next_match() as well.\nconst STRESS: &str = \"Áa🁀bÁꁁfg😁각กᘀ각aÁ각ꁁก😁a\";\n\n#[test]\nfn test_stress_indices() {\n    // this isn't really a test, more of documentation on the indices of each character in the stresstest string\n\n    search_asserts!(\n        STRESS,\n        'x',\n        \"Indices of characters in stress test\",\n        [\n            next, next, next, next, next, next, next, next, next, next, next, next, next, next,\n            next, next, next, next, next, next, next\n        ],\n        [\n            Rejects(0, 2),   // Á\n            Rejects(2, 3),   // a\n            Rejects(3, 7),   // 🁀\n            Rejects(7, 8),   // b\n            Rejects(8, 10),  // Á\n            Rejects(10, 13), // ꁁ\n            Rejects(13, 14), // f\n            Rejects(14, 15), // g\n            Rejects(15, 19), // 😀\n            Rejects(19, 22), // 각\n            Rejects(22, 25), // ก\n            Rejects(25, 28), // ᘀ\n            Rejects(28, 31), // 각\n            Rejects(31, 32), // a\n            Rejects(32, 34), // Á\n            Rejects(34, 37), // 각\n            Rejects(37, 40), // ꁁ\n            Rejects(40, 43), // ก\n            Rejects(43, 47), // 😀\n            Rejects(47, 48), // a\n            Done\n        ]\n    );\n}\n\n#[test]\nfn test_forward_search_shared_bytes() {\n    search_asserts!(\n        STRESS,\n        'Á',\n        \"Forward search for two-byte Latin character\",\n        [next_match, next_match, next_match, next_match],\n        [InRange(0, 2), InRange(8, 10), InRange(32, 34), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        'Á',\n        \"Forward search for two-byte Latin character; check if next() still works\",\n        [next_match, next, next_match, next, next_match, next, next_match],\n        [\n            InRange(0, 2),\n            Rejects(2, 3),\n            InRange(8, 10),\n            Rejects(10, 13),\n            InRange(32, 34),\n            Rejects(34, 37),\n            Done\n        ]\n    );\n\n    search_asserts!(\n        STRESS,\n        '각',\n        \"Forward search for three-byte Hangul character\",\n        [next_match, next, next_match, next_match, next_match],\n        [InRange(19, 22), Rejects(22, 25), InRange(28, 31), InRange(34, 37), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        '각',\n        \"Forward search for three-byte Hangul character; check if next() still works\",\n        [next_match, next, next_match, next, next_match, next, next_match],\n        [\n            InRange(19, 22),\n            Rejects(22, 25),\n            InRange(28, 31),\n            Rejects(31, 32),\n            InRange(34, 37),\n            Rejects(37, 40),\n            Done\n        ]\n    );\n\n    search_asserts!(\n        STRESS,\n        'ก',\n        \"Forward search for three-byte Thai character\",\n        [next_match, next, next_match, next, next_match],\n        [InRange(22, 25), Rejects(25, 28), InRange(40, 43), Rejects(43, 47), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        'ก',\n        \"Forward search for three-byte Thai character; check if next() still works\",\n        [next_match, next, next_match, next, next_match],\n        [InRange(22, 25), Rejects(25, 28), InRange(40, 43), Rejects(43, 47), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        '😁',\n        \"Forward search for four-byte emoji\",\n        [next_match, next, next_match, next, next_match],\n        [InRange(15, 19), Rejects(19, 22), InRange(43, 47), Rejects(47, 48), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        '😁',\n        \"Forward search for four-byte emoji; check if next() still works\",\n        [next_match, next, next_match, next, next_match],\n        [InRange(15, 19), Rejects(19, 22), InRange(43, 47), Rejects(47, 48), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        'ꁁ',\n        \"Forward search for three-byte Yi character with repeated bytes\",\n        [next_match, next, next_match, next, next_match],\n        [InRange(10, 13), Rejects(13, 14), InRange(37, 40), Rejects(40, 43), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        'ꁁ',\n        \"Forward search for three-byte Yi character with repeated bytes; check if next() still works\",\n        [next_match, next, next_match, next, next_match],\n        [InRange(10, 13), Rejects(13, 14), InRange(37, 40), Rejects(40, 43), Done]\n    );\n}\n\n#[test]\nfn test_reverse_search_shared_bytes() {\n    search_asserts!(\n        STRESS,\n        'Á',\n        \"Reverse search for two-byte Latin character\",\n        [next_match_back, next_match_back, next_match_back, next_match_back],\n        [InRange(32, 34), InRange(8, 10), InRange(0, 2), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        'Á',\n        \"Reverse search for two-byte Latin character; check if next_back() still works\",\n        [next_match_back, next_back, next_match_back, next_back, next_match_back, next_back],\n        [InRange(32, 34), Rejects(31, 32), InRange(8, 10), Rejects(7, 8), InRange(0, 2), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        '각',\n        \"Reverse search for three-byte Hangul character\",\n        [next_match_back, next_back, next_match_back, next_match_back, next_match_back],\n        [InRange(34, 37), Rejects(32, 34), InRange(28, 31), InRange(19, 22), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        '각',\n        \"Reverse search for three-byte Hangul character; check if next_back() still works\",\n        [\n            next_match_back,\n            next_back,\n            next_match_back,\n            next_back,\n            next_match_back,\n            next_back,\n            next_match_back\n        ],\n        [\n            InRange(34, 37),\n            Rejects(32, 34),\n            InRange(28, 31),\n            Rejects(25, 28),\n            InRange(19, 22),\n            Rejects(15, 19),\n            Done\n        ]\n    );\n\n    search_asserts!(\n        STRESS,\n        'ก',\n        \"Reverse search for three-byte Thai character\",\n        [next_match_back, next_back, next_match_back, next_back, next_match_back],\n        [InRange(40, 43), Rejects(37, 40), InRange(22, 25), Rejects(19, 22), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        'ก',\n        \"Reverse search for three-byte Thai character; check if next_back() still works\",\n        [next_match_back, next_back, next_match_back, next_back, next_match_back],\n        [InRange(40, 43), Rejects(37, 40), InRange(22, 25), Rejects(19, 22), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        '😁',\n        \"Reverse search for four-byte emoji\",\n        [next_match_back, next_back, next_match_back, next_back, next_match_back],\n        [InRange(43, 47), Rejects(40, 43), InRange(15, 19), Rejects(14, 15), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        '😁',\n        \"Reverse search for four-byte emoji; check if next_back() still works\",\n        [next_match_back, next_back, next_match_back, next_back, next_match_back],\n        [InRange(43, 47), Rejects(40, 43), InRange(15, 19), Rejects(14, 15), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        'ꁁ',\n        \"Reverse search for three-byte Yi character with repeated bytes\",\n        [next_match_back, next_back, next_match_back, next_back, next_match_back],\n        [InRange(37, 40), Rejects(34, 37), InRange(10, 13), Rejects(8, 10), Done]\n    );\n\n    search_asserts!(\n        STRESS,\n        'ꁁ',\n        \"Reverse search for three-byte Yi character with repeated bytes; check if next_back() still works\",\n        [next_match_back, next_back, next_match_back, next_back, next_match_back],\n        [InRange(37, 40), Rejects(34, 37), InRange(10, 13), Rejects(8, 10), Done]\n    );\n}\n\n#[test]\nfn double_ended_regression_test() {\n    // https://github.com/rust-lang/rust/issues/47175\n    // Ensures that double ended searching comes to a convergence\n    search_asserts!(\n        \"abcdeabcdeabcde\",\n        'a',\n        \"alternating double ended search\",\n        [next_match, next_match_back, next_match, next_match_back],\n        [InRange(0, 1), InRange(10, 11), InRange(5, 6), Done]\n    );\n    search_asserts!(\n        \"abcdeabcdeabcde\",\n        'a',\n        \"triple double ended search for a\",\n        [next_match, next_match_back, next_match_back, next_match_back],\n        [InRange(0, 1), InRange(10, 11), InRange(5, 6), Done]\n    );\n    search_asserts!(\n        \"abcdeabcdeabcde\",\n        'd',\n        \"triple double ended search for d\",\n        [next_match, next_match_back, next_match_back, next_match_back],\n        [InRange(3, 4), InRange(13, 14), InRange(8, 9), Done]\n    );\n    search_asserts!(\n        STRESS,\n        'Á',\n        \"Double ended search for two-byte Latin character\",\n        [next_match, next_match_back, next_match, next_match_back],\n        [InRange(0, 2), InRange(32, 34), InRange(8, 10), Done]\n    );\n    search_asserts!(\n        STRESS,\n        '각',\n        \"Reverse double ended search for three-byte Hangul character\",\n        [next_match_back, next_back, next_match, next, next_match_back, next_match],\n        [InRange(34, 37), Rejects(32, 34), InRange(19, 22), Rejects(22, 25), InRange(28, 31), Done]\n    );\n    search_asserts!(\n        STRESS,\n        'ก',\n        \"Double ended search for three-byte Thai character\",\n        [next_match, next_back, next, next_match_back, next_match],\n        [InRange(22, 25), Rejects(47, 48), Rejects(25, 28), InRange(40, 43), Done]\n    );\n    search_asserts!(\n        STRESS,\n        '😁',\n        \"Double ended search for four-byte emoji\",\n        [next_match_back, next, next_match, next_back, next_match],\n        [InRange(43, 47), Rejects(0, 2), InRange(15, 19), Rejects(40, 43), Done]\n    );\n    search_asserts!(\n        STRESS,\n        'ꁁ',\n        \"Double ended search for three-byte Yi character with repeated bytes\",\n        [next_match, next, next_match_back, next_back, next_match],\n        [InRange(10, 13), Rejects(13, 14), InRange(37, 40), Rejects(34, 37), Done]\n    );\n}\n"],[2913,"use core::num::Wrapping;\n\nmacro_rules! wrapping_operation {\n    ($result:expr, $lhs:ident $op:tt $rhs:expr) => {\n        assert_eq!($result, $lhs $op $rhs);\n        assert_eq!($result, &$lhs $op $rhs);\n        assert_eq!($result, $lhs $op &$rhs);\n        assert_eq!($result, &$lhs $op &$rhs);\n    };\n    ($result:expr, $op:tt $expr:expr) => {\n        assert_eq!($result, $op $expr);\n        assert_eq!($result, $op &$expr);\n    };\n}\n\nmacro_rules! wrapping_assignment {\n    ($result:expr, $lhs:ident $op:tt $rhs:expr) => {\n        let mut lhs1 = $lhs;\n        lhs1 $op $rhs;\n        assert_eq!($result, lhs1);\n\n        let mut lhs2 = $lhs;\n        lhs2 $op &$rhs;\n        assert_eq!($result, lhs2);\n    };\n}\n\nmacro_rules! wrapping_test {\n    ($fn_name:ident, $type:ty, $min:expr, $max:expr) => {\n        #[test]\n        fn $fn_name() {\n            let zero: Wrapping<$type> = Wrapping(0);\n            let one: Wrapping<$type> = Wrapping(1);\n            let min: Wrapping<$type> = Wrapping($min);\n            let max: Wrapping<$type> = Wrapping($max);\n\n            wrapping_operation!(min, max + one);\n            wrapping_assignment!(min, max += one);\n            wrapping_operation!(max, min - one);\n            wrapping_assignment!(max, min -= one);\n            wrapping_operation!(max, max * one);\n            wrapping_assignment!(max, max *= one);\n            wrapping_operation!(max, max / one);\n            wrapping_assignment!(max, max /= one);\n            wrapping_operation!(zero, max % one);\n            wrapping_assignment!(zero, max %= one);\n            wrapping_operation!(zero, zero & max);\n            wrapping_assignment!(zero, zero &= max);\n            wrapping_operation!(max, zero | max);\n            wrapping_assignment!(max, zero |= max);\n            wrapping_operation!(zero, max ^ max);\n            wrapping_assignment!(zero, max ^= max);\n            wrapping_operation!(zero, zero << 1usize);\n            wrapping_assignment!(zero, zero <<= 1usize);\n            wrapping_operation!(zero, zero >> 1usize);\n            wrapping_assignment!(zero, zero >>= 1usize);\n            wrapping_operation!(zero, -zero);\n            wrapping_operation!(max, !min);\n        }\n    };\n}\n\nwrapping_test!(test_wrapping_i8, i8, i8::MIN, i8::MAX);\nwrapping_test!(test_wrapping_i16, i16, i16::MIN, i16::MAX);\nwrapping_test!(test_wrapping_i32, i32, i32::MIN, i32::MAX);\nwrapping_test!(test_wrapping_i64, i64, i64::MIN, i64::MAX);\n#[cfg(not(target_os = \"emscripten\"))]\nwrapping_test!(test_wrapping_i128, i128, i128::MIN, i128::MAX);\nwrapping_test!(test_wrapping_isize, isize, isize::MIN, isize::MAX);\nwrapping_test!(test_wrapping_u8, u8, u8::MIN, u8::MAX);\nwrapping_test!(test_wrapping_u16, u16, u16::MIN, u16::MAX);\nwrapping_test!(test_wrapping_u32, u32, u32::MIN, u32::MAX);\nwrapping_test!(test_wrapping_u64, u64, u64::MIN, u64::MAX);\n#[cfg(not(target_os = \"emscripten\"))]\nwrapping_test!(test_wrapping_u128, u128, u128::MIN, u128::MAX);\nwrapping_test!(test_wrapping_usize, usize, usize::MIN, usize::MAX);\n\n// Don't warn about overflowing ops on 32-bit platforms\n#[cfg_attr(target_pointer_width = \"32\", allow(const_err))]\n#[test]\nfn wrapping_int_api() {\n    assert_eq!(i8::MAX.wrapping_add(1), i8::MIN);\n    assert_eq!(i16::MAX.wrapping_add(1), i16::MIN);\n    assert_eq!(i32::MAX.wrapping_add(1), i32::MIN);\n    assert_eq!(i64::MAX.wrapping_add(1), i64::MIN);\n    assert_eq!(isize::MAX.wrapping_add(1), isize::MIN);\n\n    assert_eq!(i8::MIN.wrapping_sub(1), i8::MAX);\n    assert_eq!(i16::MIN.wrapping_sub(1), i16::MAX);\n    assert_eq!(i32::MIN.wrapping_sub(1), i32::MAX);\n    assert_eq!(i64::MIN.wrapping_sub(1), i64::MAX);\n    assert_eq!(isize::MIN.wrapping_sub(1), isize::MAX);\n\n    assert_eq!(u8::MAX.wrapping_add(1), u8::MIN);\n    assert_eq!(u16::MAX.wrapping_add(1), u16::MIN);\n    assert_eq!(u32::MAX.wrapping_add(1), u32::MIN);\n    assert_eq!(u64::MAX.wrapping_add(1), u64::MIN);\n    assert_eq!(usize::MAX.wrapping_add(1), usize::MIN);\n\n    assert_eq!(u8::MIN.wrapping_sub(1), u8::MAX);\n    assert_eq!(u16::MIN.wrapping_sub(1), u16::MAX);\n    assert_eq!(u32::MIN.wrapping_sub(1), u32::MAX);\n    assert_eq!(u64::MIN.wrapping_sub(1), u64::MAX);\n    assert_eq!(usize::MIN.wrapping_sub(1), usize::MAX);\n\n    assert_eq!((0xfe_u8 as i8).wrapping_mul(16), (0xe0_u8 as i8));\n    assert_eq!((0xfedc_u16 as i16).wrapping_mul(16), (0xedc0_u16 as i16));\n    assert_eq!((0xfedc_ba98_u32 as i32).wrapping_mul(16), (0xedcb_a980_u32 as i32));\n    assert_eq!(\n        (0xfedc_ba98_7654_3217_u64 as i64).wrapping_mul(16),\n        (0xedcb_a987_6543_2170_u64 as i64)\n    );\n\n    match () {\n        #[cfg(target_pointer_width = \"32\")]\n        () => {\n            assert_eq!((0xfedc_ba98_u32 as isize).wrapping_mul(16), (0xedcb_a980_u32 as isize));\n        }\n        #[cfg(target_pointer_width = \"64\")]\n        () => {\n            assert_eq!(\n                (0xfedc_ba98_7654_3217_u64 as isize).wrapping_mul(16),\n                (0xedcb_a987_6543_2170_u64 as isize)\n            );\n        }\n    }\n\n    assert_eq!((0xfe as u8).wrapping_mul(16), (0xe0 as u8));\n    assert_eq!((0xfedc as u16).wrapping_mul(16), (0xedc0 as u16));\n    assert_eq!((0xfedc_ba98 as u32).wrapping_mul(16), (0xedcb_a980 as u32));\n    assert_eq!((0xfedc_ba98_7654_3217 as u64).wrapping_mul(16), (0xedcb_a987_6543_2170 as u64));\n\n    match () {\n        #[cfg(target_pointer_width = \"32\")]\n        () => {\n            assert_eq!((0xfedc_ba98 as usize).wrapping_mul(16), (0xedcb_a980 as usize));\n        }\n        #[cfg(target_pointer_width = \"64\")]\n        () => {\n            assert_eq!(\n                (0xfedc_ba98_7654_3217 as usize).wrapping_mul(16),\n                (0xedcb_a987_6543_2170 as usize)\n            );\n        }\n    }\n\n    macro_rules! check_mul_no_wrap {\n        ($e:expr, $f:expr) => {\n            assert_eq!(($e).wrapping_mul($f), ($e) * $f);\n        };\n    }\n    macro_rules! check_mul_wraps {\n        ($e:expr, $f:expr) => {\n            assert_eq!(($e).wrapping_mul($f), $e);\n        };\n    }\n\n    check_mul_no_wrap!(0xfe_u8 as i8, -1);\n    check_mul_no_wrap!(0xfedc_u16 as i16, -1);\n    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n\n    check_mul_no_wrap!(0xfe_u8 as i8, -2);\n    check_mul_no_wrap!(0xfedc_u16 as i16, -2);\n    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n    check_mul_no_wrap!(0xfedc_ba98_fedc_ba98_u64 as u64 as isize, -2);\n\n    check_mul_no_wrap!(0xfe_u8 as i8, 2);\n    check_mul_no_wrap!(0xfedc_u16 as i16, 2);\n    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n    check_mul_no_wrap!(0xfedc_ba98_fedc_ba98_u64 as u64 as isize, 2);\n\n    check_mul_wraps!(0x80_u8 as i8, -1);\n    check_mul_wraps!(0x8000_u16 as i16, -1);\n    check_mul_wraps!(0x8000_0000_u32 as i32, -1);\n    check_mul_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n    match () {\n        #[cfg(target_pointer_width = \"32\")]\n        () => {\n            check_mul_wraps!(0x8000_0000_u32 as isize, -1);\n        }\n        #[cfg(target_pointer_width = \"64\")]\n        () => {\n            check_mul_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n        }\n    }\n\n    macro_rules! check_div_no_wrap {\n        ($e:expr, $f:expr) => {\n            assert_eq!(($e).wrapping_div($f), ($e) / $f);\n        };\n    }\n    macro_rules! check_div_wraps {\n        ($e:expr, $f:expr) => {\n            assert_eq!(($e).wrapping_div($f), $e);\n        };\n    }\n\n    check_div_no_wrap!(0xfe_u8 as i8, -1);\n    check_div_no_wrap!(0xfedc_u16 as i16, -1);\n    check_div_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n\n    check_div_no_wrap!(0xfe_u8 as i8, -2);\n    check_div_no_wrap!(0xfedc_u16 as i16, -2);\n    check_div_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -2);\n\n    check_div_no_wrap!(0xfe_u8 as i8, 2);\n    check_div_no_wrap!(0xfedc_u16 as i16, 2);\n    check_div_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, 2);\n\n    check_div_wraps!(-128 as i8, -1);\n    check_div_wraps!(0x8000_u16 as i16, -1);\n    check_div_wraps!(0x8000_0000_u32 as i32, -1);\n    check_div_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n    match () {\n        #[cfg(target_pointer_width = \"32\")]\n        () => {\n            check_div_wraps!(0x8000_0000_u32 as isize, -1);\n        }\n        #[cfg(target_pointer_width = \"64\")]\n        () => {\n            check_div_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n        }\n    }\n\n    macro_rules! check_rem_no_wrap {\n        ($e:expr, $f:expr) => {\n            assert_eq!(($e).wrapping_rem($f), ($e) % $f);\n        };\n    }\n    macro_rules! check_rem_wraps {\n        ($e:expr, $f:expr) => {\n            assert_eq!(($e).wrapping_rem($f), 0);\n        };\n    }\n\n    check_rem_no_wrap!(0xfe_u8 as i8, -1);\n    check_rem_no_wrap!(0xfedc_u16 as i16, -1);\n    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n\n    check_rem_no_wrap!(0xfe_u8 as i8, -2);\n    check_rem_no_wrap!(0xfedc_u16 as i16, -2);\n    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -2);\n\n    check_rem_no_wrap!(0xfe_u8 as i8, 2);\n    check_rem_no_wrap!(0xfedc_u16 as i16, 2);\n    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, 2);\n\n    check_rem_wraps!(0x80_u8 as i8, -1);\n    check_rem_wraps!(0x8000_u16 as i16, -1);\n    check_rem_wraps!(0x8000_0000_u32 as i32, -1);\n    check_rem_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n    match () {\n        #[cfg(target_pointer_width = \"32\")]\n        () => {\n            check_rem_wraps!(0x8000_0000_u32 as isize, -1);\n        }\n        #[cfg(target_pointer_width = \"64\")]\n        () => {\n            check_rem_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n        }\n    }\n\n    macro_rules! check_neg_no_wrap {\n        ($e:expr) => {\n            assert_eq!(($e).wrapping_neg(), -($e));\n        };\n    }\n    macro_rules! check_neg_wraps {\n        ($e:expr) => {\n            assert_eq!(($e).wrapping_neg(), ($e));\n        };\n    }\n\n    check_neg_no_wrap!(0xfe_u8 as i8);\n    check_neg_no_wrap!(0xfedc_u16 as i16);\n    check_neg_no_wrap!(0xfedc_ba98_u32 as i32);\n    check_neg_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64);\n    check_neg_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize);\n\n    check_neg_wraps!(0x80_u8 as i8);\n    check_neg_wraps!(0x8000_u16 as i16);\n    check_neg_wraps!(0x8000_0000_u32 as i32);\n    check_neg_wraps!(0x8000_0000_0000_0000_u64 as i64);\n    match () {\n        #[cfg(target_pointer_width = \"32\")]\n        () => {\n            check_neg_wraps!(0x8000_0000_u32 as isize);\n        }\n        #[cfg(target_pointer_width = \"64\")]\n        () => {\n            check_neg_wraps!(0x8000_0000_0000_0000_u64 as isize);\n        }\n    }\n}\n"],[2914,"int_module!(i32, i32);\n\n#[test]\nfn test_arith_operation() {\n    let a: isize = 10;\n    assert_eq!(a * (a - 1), 90);\n    let i32_a: isize = 10;\n    assert_eq!(i32_a, 10);\n    assert_eq!(i32_a - 10, 0);\n    assert_eq!(i32_a / 10, 1);\n    assert_eq!(i32_a - 20, -10);\n    assert_eq!(i32_a << 10, 10240);\n    assert_eq!(i32_a << 16, 655360);\n    assert_eq!(i32_a * 16, 160);\n    assert_eq!(i32_a * i32_a * i32_a, 1000);\n    assert_eq!(i32_a * i32_a * i32_a * i32_a, 10000);\n    assert_eq!(i32_a * i32_a / i32_a * i32_a, 100);\n    assert_eq!(i32_a * (i32_a - 1) << (2 + i32_a as usize), 368640);\n    let i32_b: isize = 0x10101010;\n    assert_eq!(i32_b + 1 - 1, i32_b);\n    assert_eq!(i32_b << 1, i32_b << 1);\n    assert_eq!(i32_b >> 1, i32_b >> 1);\n    assert_eq!(i32_b & i32_b << 1, 0);\n    assert_eq!(i32_b | i32_b << 1, 0x30303030);\n    let i32_c: isize = 0x10101010;\n    assert_eq!(\n        i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3),\n        i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3)\n    );\n}\n"],[2915,"int_module!(i8, i8);\n"],[2916,"use core::num::bignum::tests::Big8x3 as Big;\n\n#[test]\n#[should_panic]\nfn test_from_u64_overflow() {\n    Big::from_u64(0x1000000);\n}\n\n#[test]\nfn test_add() {\n    assert_eq!(*Big::from_small(3).add(&Big::from_small(4)), Big::from_small(7));\n    assert_eq!(*Big::from_small(3).add(&Big::from_small(0)), Big::from_small(3));\n    assert_eq!(*Big::from_small(0).add(&Big::from_small(3)), Big::from_small(3));\n    assert_eq!(*Big::from_small(3).add(&Big::from_u64(0xfffe)), Big::from_u64(0x10001));\n    assert_eq!(*Big::from_u64(0xfedc).add(&Big::from_u64(0x789)), Big::from_u64(0x10665));\n    assert_eq!(*Big::from_u64(0x789).add(&Big::from_u64(0xfedc)), Big::from_u64(0x10665));\n}\n\n#[test]\n#[should_panic]\nfn test_add_overflow_1() {\n    Big::from_small(1).add(&Big::from_u64(0xffffff));\n}\n\n#[test]\n#[should_panic]\nfn test_add_overflow_2() {\n    Big::from_u64(0xffffff).add(&Big::from_small(1));\n}\n\n#[test]\nfn test_add_small() {\n    assert_eq!(*Big::from_small(3).add_small(4), Big::from_small(7));\n    assert_eq!(*Big::from_small(3).add_small(0), Big::from_small(3));\n    assert_eq!(*Big::from_small(0).add_small(3), Big::from_small(3));\n    assert_eq!(*Big::from_small(7).add_small(250), Big::from_u64(257));\n    assert_eq!(*Big::from_u64(0x7fff).add_small(1), Big::from_u64(0x8000));\n    assert_eq!(*Big::from_u64(0x2ffe).add_small(0x35), Big::from_u64(0x3033));\n    assert_eq!(*Big::from_small(0xdc).add_small(0x89), Big::from_u64(0x165));\n}\n\n#[test]\n#[should_panic]\nfn test_add_small_overflow() {\n    Big::from_u64(0xffffff).add_small(1);\n}\n\n#[test]\nfn test_sub() {\n    assert_eq!(*Big::from_small(7).sub(&Big::from_small(4)), Big::from_small(3));\n    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0x789)), Big::from_u64(0xfedc));\n    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0xfedc)), Big::from_u64(0x789));\n    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0x10664)), Big::from_small(1));\n    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0x10665)), Big::from_small(0));\n}\n\n#[test]\n#[should_panic]\nfn test_sub_underflow_1() {\n    Big::from_u64(0x10665).sub(&Big::from_u64(0x10666));\n}\n\n#[test]\n#[should_panic]\nfn test_sub_underflow_2() {\n    Big::from_small(0).sub(&Big::from_u64(0x123456));\n}\n\n#[test]\nfn test_mul_small() {\n    assert_eq!(*Big::from_small(7).mul_small(5), Big::from_small(35));\n    assert_eq!(*Big::from_small(0xff).mul_small(0xff), Big::from_u64(0xfe01));\n    assert_eq!(*Big::from_u64(0xffffff / 13).mul_small(13), Big::from_u64(0xffffff));\n}\n\n#[test]\n#[should_panic]\nfn test_mul_small_overflow() {\n    Big::from_u64(0x800000).mul_small(2);\n}\n\n#[test]\nfn test_mul_pow2() {\n    assert_eq!(*Big::from_small(0x7).mul_pow2(4), Big::from_small(0x70));\n    assert_eq!(*Big::from_small(0xff).mul_pow2(1), Big::from_u64(0x1fe));\n    assert_eq!(*Big::from_small(0xff).mul_pow2(12), Big::from_u64(0xff000));\n    assert_eq!(*Big::from_small(0x1).mul_pow2(23), Big::from_u64(0x800000));\n    assert_eq!(*Big::from_u64(0x123).mul_pow2(0), Big::from_u64(0x123));\n    assert_eq!(*Big::from_u64(0x123).mul_pow2(7), Big::from_u64(0x9180));\n    assert_eq!(*Big::from_u64(0x123).mul_pow2(15), Big::from_u64(0x918000));\n    assert_eq!(*Big::from_small(0).mul_pow2(23), Big::from_small(0));\n}\n\n#[test]\n#[should_panic]\nfn test_mul_pow2_overflow_1() {\n    Big::from_u64(0x1).mul_pow2(24);\n}\n\n#[test]\n#[should_panic]\nfn test_mul_pow2_overflow_2() {\n    Big::from_u64(0x123).mul_pow2(16);\n}\n\n#[test]\nfn test_mul_pow5() {\n    assert_eq!(*Big::from_small(42).mul_pow5(0), Big::from_small(42));\n    assert_eq!(*Big::from_small(1).mul_pow5(2), Big::from_small(25));\n    assert_eq!(*Big::from_small(1).mul_pow5(4), Big::from_u64(25 * 25));\n    assert_eq!(*Big::from_small(4).mul_pow5(3), Big::from_u64(500));\n    assert_eq!(*Big::from_small(140).mul_pow5(2), Big::from_u64(25 * 140));\n    assert_eq!(*Big::from_small(25).mul_pow5(1), Big::from_small(125));\n    assert_eq!(*Big::from_small(125).mul_pow5(7), Big::from_u64(9765625));\n    assert_eq!(*Big::from_small(0).mul_pow5(127), Big::from_small(0));\n}\n\n#[test]\n#[should_panic]\nfn test_mul_pow5_overflow_1() {\n    Big::from_small(1).mul_pow5(12);\n}\n\n#[test]\n#[should_panic]\nfn test_mul_pow5_overflow_2() {\n    Big::from_small(230).mul_pow5(8);\n}\n\n#[test]\nfn test_mul_digits() {\n    assert_eq!(*Big::from_small(3).mul_digits(&[5]), Big::from_small(15));\n    assert_eq!(*Big::from_small(0xff).mul_digits(&[0xff]), Big::from_u64(0xfe01));\n    assert_eq!(*Big::from_u64(0x123).mul_digits(&[0x56, 0x4]), Big::from_u64(0x4edc2));\n    assert_eq!(*Big::from_u64(0x12345).mul_digits(&[0x67]), Big::from_u64(0x7530c3));\n    assert_eq!(*Big::from_small(0x12).mul_digits(&[0x67, 0x45, 0x3]), Big::from_u64(0x3ae13e));\n    assert_eq!(*Big::from_u64(0xffffff / 13).mul_digits(&[13]), Big::from_u64(0xffffff));\n    assert_eq!(*Big::from_small(13).mul_digits(&[0x3b, 0xb1, 0x13]), Big::from_u64(0xffffff));\n}\n\n#[test]\n#[should_panic]\nfn test_mul_digits_overflow_1() {\n    Big::from_u64(0x800000).mul_digits(&[2]);\n}\n\n#[test]\n#[should_panic]\nfn test_mul_digits_overflow_2() {\n    Big::from_u64(0x1000).mul_digits(&[0, 0x10]);\n}\n\n#[test]\nfn test_div_rem_small() {\n    let as_val = |(q, r): (&mut Big, u8)| (q.clone(), r);\n    assert_eq!(as_val(Big::from_small(0xff).div_rem_small(15)), (Big::from_small(17), 0));\n    assert_eq!(as_val(Big::from_small(0xff).div_rem_small(16)), (Big::from_small(15), 15));\n    assert_eq!(as_val(Big::from_small(3).div_rem_small(40)), (Big::from_small(0), 3));\n    assert_eq!(\n        as_val(Big::from_u64(0xffffff).div_rem_small(123)),\n        (Big::from_u64(0xffffff / 123), (0xffffffu64 % 123) as u8)\n    );\n    assert_eq!(\n        as_val(Big::from_u64(0x10000).div_rem_small(123)),\n        (Big::from_u64(0x10000 / 123), (0x10000u64 % 123) as u8)\n    );\n}\n\n#[test]\nfn test_div_rem() {\n    fn div_rem(n: u64, d: u64) -> (Big, Big) {\n        let mut q = Big::from_small(42);\n        let mut r = Big::from_small(42);\n        Big::from_u64(n).div_rem(&Big::from_u64(d), &mut q, &mut r);\n        (q, r)\n    }\n    assert_eq!(div_rem(1, 1), (Big::from_small(1), Big::from_small(0)));\n    assert_eq!(div_rem(4, 3), (Big::from_small(1), Big::from_small(1)));\n    assert_eq!(div_rem(1, 7), (Big::from_small(0), Big::from_small(1)));\n    assert_eq!(div_rem(45, 9), (Big::from_small(5), Big::from_small(0)));\n    assert_eq!(div_rem(103, 9), (Big::from_small(11), Big::from_small(4)));\n    assert_eq!(div_rem(123456, 77), (Big::from_u64(1603), Big::from_small(25)));\n    assert_eq!(div_rem(0xffff, 1), (Big::from_u64(0xffff), Big::from_small(0)));\n    assert_eq!(div_rem(0xeeee, 0xffff), (Big::from_small(0), Big::from_u64(0xeeee)));\n    assert_eq!(div_rem(2_000_000, 2), (Big::from_u64(1_000_000), Big::from_u64(0)));\n}\n\n#[test]\nfn test_is_zero() {\n    assert!(Big::from_small(0).is_zero());\n    assert!(!Big::from_small(3).is_zero());\n    assert!(!Big::from_u64(0x123).is_zero());\n    assert!(!Big::from_u64(0xffffff).sub(&Big::from_u64(0xfffffe)).is_zero());\n    assert!(Big::from_u64(0xffffff).sub(&Big::from_u64(0xffffff)).is_zero());\n}\n\n#[test]\nfn test_get_bit() {\n    let x = Big::from_small(0b1101);\n    assert_eq!(x.get_bit(0), 1);\n    assert_eq!(x.get_bit(1), 0);\n    assert_eq!(x.get_bit(2), 1);\n    assert_eq!(x.get_bit(3), 1);\n    let y = Big::from_u64(1 << 15);\n    assert_eq!(y.get_bit(14), 0);\n    assert_eq!(y.get_bit(15), 1);\n    assert_eq!(y.get_bit(16), 0);\n}\n\n#[test]\n#[should_panic]\nfn test_get_bit_out_of_range() {\n    Big::from_small(42).get_bit(24);\n}\n\n#[test]\nfn test_bit_length() {\n    assert_eq!(Big::from_small(0).bit_length(), 0);\n    assert_eq!(Big::from_small(1).bit_length(), 1);\n    assert_eq!(Big::from_small(5).bit_length(), 3);\n    assert_eq!(Big::from_small(0x18).bit_length(), 5);\n    assert_eq!(Big::from_u64(0x4073).bit_length(), 15);\n    assert_eq!(Big::from_u64(0xffffff).bit_length(), 24);\n}\n\n#[test]\nfn test_ord() {\n    assert!(Big::from_u64(0) < Big::from_u64(0xffffff));\n    assert!(Big::from_u64(0x102) < Big::from_u64(0x201));\n}\n\n#[test]\nfn test_fmt() {\n    assert_eq!(format!(\"{:?}\", Big::from_u64(0)), \"0x0\");\n    assert_eq!(format!(\"{:?}\", Big::from_u64(0x1)), \"0x1\");\n    assert_eq!(format!(\"{:?}\", Big::from_u64(0x12)), \"0x12\");\n    assert_eq!(format!(\"{:?}\", Big::from_u64(0x123)), \"0x1_23\");\n    assert_eq!(format!(\"{:?}\", Big::from_u64(0x1234)), \"0x12_34\");\n    assert_eq!(format!(\"{:?}\", Big::from_u64(0x12345)), \"0x1_23_45\");\n    assert_eq!(format!(\"{:?}\", Big::from_u64(0x123456)), \"0x12_34_56\");\n}\n"],[2917,"uint_module!(u32, u32);\n"],[2918,"macro_rules! uint_module {\n    ($T:ident, $T_i:ident) => {\n        #[cfg(test)]\n        mod tests {\n            use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n            use core::$T_i::*;\n            use std::str::FromStr;\n\n            use crate::num;\n\n            #[test]\n            fn test_overflows() {\n                assert!(MAX > 0);\n                assert!(MIN <= 0);\n                assert!((MIN + MAX).wrapping_add(1) == 0);\n            }\n\n            #[test]\n            fn test_num() {\n                num::test_num(10 as $T, 2 as $T);\n            }\n\n            #[test]\n            fn test_bitwise_operators() {\n                assert!(0b1110 as $T == (0b1100 as $T).bitor(0b1010 as $T));\n                assert!(0b1000 as $T == (0b1100 as $T).bitand(0b1010 as $T));\n                assert!(0b0110 as $T == (0b1100 as $T).bitxor(0b1010 as $T));\n                assert!(0b1110 as $T == (0b0111 as $T).shl(1));\n                assert!(0b0111 as $T == (0b1110 as $T).shr(1));\n                assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n            }\n\n            const A: $T = 0b0101100;\n            const B: $T = 0b0100001;\n            const C: $T = 0b1111001;\n\n            const _0: $T = 0;\n            const _1: $T = !0;\n\n            #[test]\n            fn test_count_ones() {\n                assert!(A.count_ones() == 3);\n                assert!(B.count_ones() == 2);\n                assert!(C.count_ones() == 5);\n            }\n\n            #[test]\n            fn test_count_zeros() {\n                assert!(A.count_zeros() == $T::BITS - 3);\n                assert!(B.count_zeros() == $T::BITS - 2);\n                assert!(C.count_zeros() == $T::BITS - 5);\n            }\n\n            #[test]\n            fn test_leading_trailing_ones() {\n                let a: $T = 0b0101_1111;\n                assert_eq!(a.trailing_ones(), 5);\n                assert_eq!((!a).leading_ones(), $T::BITS - 7);\n\n                assert_eq!(a.reverse_bits().leading_ones(), 5);\n\n                assert_eq!(_1.leading_ones(), $T::BITS);\n                assert_eq!(_1.trailing_ones(), $T::BITS);\n\n                assert_eq!((_1 << 1).trailing_ones(), 0);\n                assert_eq!((_1 >> 1).leading_ones(), 0);\n\n                assert_eq!((_1 << 1).leading_ones(), $T::BITS - 1);\n                assert_eq!((_1 >> 1).trailing_ones(), $T::BITS - 1);\n\n                assert_eq!(_0.leading_ones(), 0);\n                assert_eq!(_0.trailing_ones(), 0);\n\n                let x: $T = 0b0010_1100;\n                assert_eq!(x.leading_ones(), 0);\n                assert_eq!(x.trailing_ones(), 0);\n            }\n\n            #[test]\n            fn test_rotate() {\n                assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n                assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n                assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n\n                // Rotating these should make no difference\n                //\n                // We test using 124 bits because to ensure that overlong bit shifts do\n                // not cause undefined behaviour. See #10183.\n                assert_eq!(_0.rotate_left(124), _0);\n                assert_eq!(_1.rotate_left(124), _1);\n                assert_eq!(_0.rotate_right(124), _0);\n                assert_eq!(_1.rotate_right(124), _1);\n\n                // Rotating by 0 should have no effect\n                assert_eq!(A.rotate_left(0), A);\n                assert_eq!(B.rotate_left(0), B);\n                assert_eq!(C.rotate_left(0), C);\n                // Rotating by a multiple of word size should also have no effect\n                assert_eq!(A.rotate_left(128), A);\n                assert_eq!(B.rotate_left(128), B);\n                assert_eq!(C.rotate_left(128), C);\n            }\n\n            #[test]\n            fn test_swap_bytes() {\n                assert_eq!(A.swap_bytes().swap_bytes(), A);\n                assert_eq!(B.swap_bytes().swap_bytes(), B);\n                assert_eq!(C.swap_bytes().swap_bytes(), C);\n\n                // Swapping these should make no difference\n                assert_eq!(_0.swap_bytes(), _0);\n                assert_eq!(_1.swap_bytes(), _1);\n            }\n\n            #[test]\n            fn test_reverse_bits() {\n                assert_eq!(A.reverse_bits().reverse_bits(), A);\n                assert_eq!(B.reverse_bits().reverse_bits(), B);\n                assert_eq!(C.reverse_bits().reverse_bits(), C);\n\n                // Swapping these should make no difference\n                assert_eq!(_0.reverse_bits(), _0);\n                assert_eq!(_1.reverse_bits(), _1);\n            }\n\n            #[test]\n            fn test_le() {\n                assert_eq!($T::from_le(A.to_le()), A);\n                assert_eq!($T::from_le(B.to_le()), B);\n                assert_eq!($T::from_le(C.to_le()), C);\n                assert_eq!($T::from_le(_0), _0);\n                assert_eq!($T::from_le(_1), _1);\n                assert_eq!(_0.to_le(), _0);\n                assert_eq!(_1.to_le(), _1);\n            }\n\n            #[test]\n            fn test_be() {\n                assert_eq!($T::from_be(A.to_be()), A);\n                assert_eq!($T::from_be(B.to_be()), B);\n                assert_eq!($T::from_be(C.to_be()), C);\n                assert_eq!($T::from_be(_0), _0);\n                assert_eq!($T::from_be(_1), _1);\n                assert_eq!(_0.to_be(), _0);\n                assert_eq!(_1.to_be(), _1);\n            }\n\n            #[test]\n            fn test_unsigned_checked_div() {\n                assert!((10 as $T).checked_div(2) == Some(5));\n                assert!((5 as $T).checked_div(0) == None);\n            }\n\n            fn from_str<T: FromStr>(t: &str) -> Option<T> {\n                FromStr::from_str(t).ok()\n            }\n\n            #[test]\n            pub fn test_from_str() {\n                assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n                assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n                assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n                assert_eq!(from_str::<u32>(\"123456789\"), Some(123456789 as u32));\n                assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n\n                assert_eq!(from_str::<$T>(\"\"), None);\n                assert_eq!(from_str::<$T>(\" \"), None);\n                assert_eq!(from_str::<$T>(\"x\"), None);\n            }\n\n            #[test]\n            pub fn test_parse_bytes() {\n                assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n                assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n                assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n                assert_eq!(u16::from_str_radix(\"123\", 16), Ok(291 as u16));\n                assert_eq!(u16::from_str_radix(\"ffff\", 16), Ok(65535 as u16));\n                assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n\n                assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n                assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n            }\n\n            #[test]\n            fn test_pow() {\n                let mut r = 2 as $T;\n                assert_eq!(r.pow(2), 4 as $T);\n                assert_eq!(r.pow(0), 1 as $T);\n                assert_eq!(r.wrapping_pow(2), 4 as $T);\n                assert_eq!(r.wrapping_pow(0), 1 as $T);\n                assert_eq!(r.checked_pow(2), Some(4 as $T));\n                assert_eq!(r.checked_pow(0), Some(1 as $T));\n                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n                assert_eq!(r.saturating_pow(2), 4 as $T);\n                assert_eq!(r.saturating_pow(0), 1 as $T);\n\n                r = MAX;\n                // use `^` to represent .pow() with no overflow.\n                // if itest::MAX == 2^j-1, then itest is a `j` bit int,\n                // so that `itest::MAX*itest::MAX == 2^(2*j)-2^(j+1)+1`,\n                // thussaturating_pow the overflowing result is exactly 1.\n                assert_eq!(r.wrapping_pow(2), 1 as $T);\n                assert_eq!(r.checked_pow(2), None);\n                assert_eq!(r.overflowing_pow(2), (1 as $T, true));\n                assert_eq!(r.saturating_pow(2), MAX);\n            }\n        }\n    };\n}\n"],[2919,"#![cfg(not(target_arch = \"wasm32\"))]\n\nuse std::mem::MaybeUninit;\nuse std::str;\n\nuse core::num::flt2dec::strategy::grisu::format_exact_opt;\nuse core::num::flt2dec::strategy::grisu::format_shortest_opt;\nuse core::num::flt2dec::MAX_SIG_DIGITS;\nuse core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\n\nuse rand::distributions::{Distribution, Uniform};\nuse rand::rngs::StdRng;\nuse rand::SeedableRng;\n\npub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n    match decode(v).1 {\n        FullDecoded::Finite(decoded) => decoded,\n        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded),\n    }\n}\n\nfn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V) -> (usize, usize)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> Option<(&'a [u8], i16)>,\n    G: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n    V: FnMut(usize) -> Decoded,\n{\n    assert!(k <= 1024);\n\n    let mut npassed = 0; // f(x) = Some(g(x))\n    let mut nignored = 0; // f(x) = None\n\n    for i in 0..n {\n        if (i & 0xfffff) == 0 {\n            println!(\n                \"in progress, {:x}/{:x} (ignored={} passed={} failed={})\",\n                i,\n                n,\n                nignored,\n                npassed,\n                i - nignored - npassed\n            );\n        }\n\n        let decoded = v(i);\n        let mut buf1 = [MaybeUninit::new(0); 1024];\n        if let Some((buf1, e1)) = f(&decoded, &mut buf1[..k]) {\n            let mut buf2 = [MaybeUninit::new(0); 1024];\n            let (buf2, e2) = g(&decoded, &mut buf2[..k]);\n            if e1 == e2 && buf1 == buf2 {\n                npassed += 1;\n            } else {\n                println!(\n                    \"equivalence test failed, {:x}/{:x}: {:?} f(i)={}e{} g(i)={}e{}\",\n                    i,\n                    n,\n                    decoded,\n                    str::from_utf8(buf1).unwrap(),\n                    e1,\n                    str::from_utf8(buf2).unwrap(),\n                    e2\n                );\n            }\n        } else {\n            nignored += 1;\n        }\n    }\n    println!(\n        \"{}({}): done, ignored={} passed={} failed={}\",\n        func,\n        k,\n        nignored,\n        npassed,\n        n - nignored - npassed\n    );\n    assert!(\n        nignored + npassed == n,\n        \"{}({}): {} out of {} values returns an incorrect value!\",\n        func,\n        k,\n        n - nignored - npassed,\n        n\n    );\n    (npassed, nignored)\n}\n\npub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> Option<(&'a [u8], i16)>,\n    G: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    if cfg!(target_os = \"emscripten\") {\n        return; // using rng pulls in i128 support, which doesn't work\n    }\n    let mut rng = StdRng::from_entropy();\n    let f32_range = Uniform::new(0x0000_0001u32, 0x7f80_0000);\n    iterate(\"f32_random_equivalence_test\", k, n, f, g, |_| {\n        let x = f32::from_bits(f32_range.sample(&mut rng));\n        decode_finite(x)\n    });\n}\n\npub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> Option<(&'a [u8], i16)>,\n    G: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    if cfg!(target_os = \"emscripten\") {\n        return; // using rng pulls in i128 support, which doesn't work\n    }\n    let mut rng = StdRng::from_entropy();\n    let f64_range = Uniform::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n    iterate(\"f64_random_equivalence_test\", k, n, f, g, |_| {\n        let x = f64::from_bits(f64_range.sample(&mut rng));\n        decode_finite(x)\n    });\n}\n\npub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> Option<(&'a [u8], i16)>,\n    G: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    // we have only 2^23 * (2^8 - 1) - 1 = 2,139,095,039 positive finite f32 values,\n    // so why not simply testing all of them?\n    //\n    // this is of course very stressful (and thus should be behind an `#[ignore]` attribute),\n    // but with `-C opt-level=3 -C lto` this only takes about an hour or so.\n\n    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e., all finite ranges\n    let (npassed, nignored) =\n        iterate(\"f32_exhaustive_equivalence_test\", k, 0x7f7f_ffff, f, g, |i: usize| {\n            let x = f32::from_bits(i as u32 + 1);\n            decode_finite(x)\n        });\n    assert_eq!((npassed, nignored), (2121451881, 17643158));\n}\n\n#[test]\nfn shortest_random_equivalence_test() {\n    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n    // Miri is too slow\n    let n = if cfg!(miri) { 10 } else { 10_000 };\n\n    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, n);\n    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, n);\n}\n\n#[test]\n#[ignore] // it is too expensive\nfn shortest_f32_exhaustive_equivalence_test() {\n    // it is hard to directly test the optimality of the output, but we can at least test if\n    // two different algorithms agree to each other.\n    //\n    // this reports the progress and the number of f32 values returned `None`.\n    // with `--nocapture` (and plenty of time and appropriate rustc flags), this should print:\n    // `done, ignored=17643158 passed=2121451881 failed=0`.\n\n    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n    f32_exhaustive_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS);\n}\n\n#[test]\n#[ignore] // it is too expensive\nfn shortest_f64_hard_random_equivalence_test() {\n    // this again probably has to use appropriate rustc flags.\n\n    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 100_000_000);\n}\n\n#[test]\nfn exact_f32_random_equivalence_test() {\n    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n    // Miri is too slow\n    let n = if cfg!(miri) { 3 } else { 1_000 };\n\n    for k in 1..21 {\n        f32_random_equivalence_test(\n            |d, buf| format_exact_opt(d, buf, i16::MIN),\n            |d, buf| fallback(d, buf, i16::MIN),\n            k,\n            n,\n        );\n    }\n}\n\n#[test]\nfn exact_f64_random_equivalence_test() {\n    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n    // Miri is too slow\n    let n = if cfg!(miri) { 2 } else { 1_000 };\n\n    for k in 1..21 {\n        f64_random_equivalence_test(\n            |d, buf| format_exact_opt(d, buf, i16::MIN),\n            |d, buf| fallback(d, buf, i16::MIN),\n            k,\n            n,\n        );\n    }\n}\n"],[2920,"use core::num::flt2dec::estimator::*;\n\n#[test]\nfn test_estimate_scaling_factor() {\n    macro_rules! assert_almost_eq {\n        ($actual:expr, $expected:expr) => {{\n            let actual = $actual;\n            let expected = $expected;\n            println!(\n                \"{} - {} = {} - {} = {}\",\n                stringify!($expected),\n                stringify!($actual),\n                expected,\n                actual,\n                expected - actual\n            );\n            assert!(\n                expected == actual || expected == actual + 1,\n                \"expected {}, actual {}\",\n                expected,\n                actual\n            );\n        }};\n    }\n\n    assert_almost_eq!(estimate_scaling_factor(1, 0), 0);\n    assert_almost_eq!(estimate_scaling_factor(2, 0), 1);\n    assert_almost_eq!(estimate_scaling_factor(10, 0), 1);\n    assert_almost_eq!(estimate_scaling_factor(11, 0), 2);\n    assert_almost_eq!(estimate_scaling_factor(100, 0), 2);\n    assert_almost_eq!(estimate_scaling_factor(101, 0), 3);\n    assert_almost_eq!(estimate_scaling_factor(10000000000000000000, 0), 19);\n    assert_almost_eq!(estimate_scaling_factor(10000000000000000001, 0), 20);\n\n    // 1/2^20 = 0.00000095367...\n    assert_almost_eq!(estimate_scaling_factor(1 * 1048576 / 1000000, -20), -6);\n    assert_almost_eq!(estimate_scaling_factor(1 * 1048576 / 1000000 + 1, -20), -5);\n    assert_almost_eq!(estimate_scaling_factor(10 * 1048576 / 1000000, -20), -5);\n    assert_almost_eq!(estimate_scaling_factor(10 * 1048576 / 1000000 + 1, -20), -4);\n    assert_almost_eq!(estimate_scaling_factor(100 * 1048576 / 1000000, -20), -4);\n    assert_almost_eq!(estimate_scaling_factor(100 * 1048576 / 1000000 + 1, -20), -3);\n    assert_almost_eq!(estimate_scaling_factor(1048575, -20), 0);\n    assert_almost_eq!(estimate_scaling_factor(1048576, -20), 0);\n    assert_almost_eq!(estimate_scaling_factor(1048577, -20), 1);\n    assert_almost_eq!(estimate_scaling_factor(10485759999999999999, -20), 13);\n    assert_almost_eq!(estimate_scaling_factor(10485760000000000000, -20), 13);\n    assert_almost_eq!(estimate_scaling_factor(10485760000000000001, -20), 14);\n\n    // extreme values:\n    // 2^-1074 = 4.94065... * 10^-324\n    // (2^53-1) * 2^971 = 1.79763... * 10^308\n    assert_almost_eq!(estimate_scaling_factor(1, -1074), -323);\n    assert_almost_eq!(estimate_scaling_factor(0x1fffffffffffff, 971), 309);\n\n    // Miri is too slow\n    let step = if cfg!(miri) { 37 } else { 1 };\n\n    for i in (-1074..972).step_by(step) {\n        let expected = super::ldexp_f64(1.0, i).log10().ceil();\n        assert_almost_eq!(estimate_scaling_factor(1, i as i16), expected as i16);\n    }\n}\n"],[2921,"use super::super::*;\nuse core::num::bignum::Big32x40 as Big;\nuse core::num::flt2dec::strategy::dragon::*;\n\n#[test]\nfn test_mul_pow10() {\n    let mut prevpow10 = Big::from_small(1);\n    for i in 1..340 {\n        let mut curpow10 = Big::from_small(1);\n        mul_pow10(&mut curpow10, i);\n        assert_eq!(curpow10, *prevpow10.clone().mul_small(10));\n        prevpow10 = curpow10;\n    }\n}\n\n#[test]\nfn shortest_sanity_test() {\n    f64_shortest_sanity_test(format_shortest);\n    f32_shortest_sanity_test(format_shortest);\n    more_shortest_sanity_test(format_shortest);\n}\n\n#[test]\n#[cfg_attr(miri, ignore)] // Miri is too slow\nfn exact_sanity_test() {\n    // This test ends up running what I can only assume is some corner-ish case\n    // of the `exp2` library function, defined in whatever C runtime we're\n    // using. In VS 2013 this function apparently had a bug as this test fails\n    // when linked, but with VS 2015 the bug appears fixed as the test runs just\n    // fine.\n    //\n    // The bug seems to be a difference in return value of `exp2(-1057)`, where\n    // in VS 2013 it returns a double with the bit pattern 0x2 and in VS 2015 it\n    // returns 0x20000.\n    //\n    // For now just ignore this test entirely on MSVC as it's tested elsewhere\n    // anyway and we're not super interested in testing each platform's exp2\n    // implementation.\n    if !cfg!(target_env = \"msvc\") {\n        f64_exact_sanity_test(format_exact);\n    }\n    f32_exact_sanity_test(format_exact);\n}\n\n#[test]\nfn test_to_shortest_str() {\n    to_shortest_str_test(format_shortest);\n}\n\n#[test]\nfn test_to_shortest_exp_str() {\n    to_shortest_exp_str_test(format_shortest);\n}\n\n#[test]\nfn test_to_exact_exp_str() {\n    to_exact_exp_str_test(format_exact);\n}\n\n#[test]\nfn test_to_exact_fixed_str() {\n    to_exact_fixed_str_test(format_exact);\n}\n"],[2922,"use super::super::*;\nuse core::num::flt2dec::strategy::grisu::*;\n\n#[test]\n#[cfg_attr(miri, ignore)] // Miri is too slow\nfn test_cached_power() {\n    assert_eq!(CACHED_POW10.first().unwrap().1, CACHED_POW10_FIRST_E);\n    assert_eq!(CACHED_POW10.last().unwrap().1, CACHED_POW10_LAST_E);\n\n    for e in -1137..961 {\n        // full range for f64\n        let low = ALPHA - e - 64;\n        let high = GAMMA - e - 64;\n        let (_k, cached) = cached_power(low, high);\n        assert!(\n            low <= cached.e && cached.e <= high,\n            \"cached_power({}, {}) = {:?} is incorrect\",\n            low,\n            high,\n            cached\n        );\n    }\n}\n\n#[test]\nfn test_max_pow10_no_more_than() {\n    let mut prevtenk = 1;\n    for k in 1..10 {\n        let tenk = prevtenk * 10;\n        assert_eq!(max_pow10_no_more_than(tenk - 1), (k - 1, prevtenk));\n        assert_eq!(max_pow10_no_more_than(tenk), (k, tenk));\n        prevtenk = tenk;\n    }\n}\n\n#[test]\nfn shortest_sanity_test() {\n    f64_shortest_sanity_test(format_shortest);\n    f32_shortest_sanity_test(format_shortest);\n    more_shortest_sanity_test(format_shortest);\n}\n\n#[test]\n#[cfg_attr(miri, ignore)] // Miri is too slow\nfn exact_sanity_test() {\n    // See comments in dragon.rs's exact_sanity_test for why this test is\n    // ignored on MSVC\n    if !cfg!(target_env = \"msvc\") {\n        f64_exact_sanity_test(format_exact);\n    }\n    f32_exact_sanity_test(format_exact);\n}\n\n#[test]\nfn test_to_shortest_str() {\n    to_shortest_str_test(format_shortest);\n}\n\n#[test]\nfn test_to_shortest_exp_str() {\n    to_shortest_exp_str_test(format_shortest);\n}\n\n#[test]\nfn test_to_exact_exp_str() {\n    to_exact_exp_str_test(format_exact);\n}\n\n#[test]\nfn test_to_exact_fixed_str() {\n    to_exact_fixed_str_test(format_exact);\n}\n"],[2923,"use std::mem::MaybeUninit;\nuse std::{fmt, str};\n\nuse core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\nuse core::num::flt2dec::{round_up, Formatted, Part, Sign, MAX_SIG_DIGITS};\nuse core::num::flt2dec::{\n    to_exact_exp_str, to_exact_fixed_str, to_shortest_exp_str, to_shortest_str,\n};\n\npub use test::Bencher;\n\nmod estimator;\nmod strategy {\n    mod dragon;\n    mod grisu;\n}\nmod random;\n\npub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n    match decode(v).1 {\n        FullDecoded::Finite(decoded) => decoded,\n        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded),\n    }\n}\n\nmacro_rules! check_shortest {\n    ($f:ident($v:expr) => $buf:expr, $exp:expr) => (\n        check_shortest!($f($v) => $buf, $exp;\n                        \"shortest mismatch for v={v}: actual {actual:?}, expected {expected:?}\",\n                        v = stringify!($v))\n    );\n\n    ($f:ident{$($k:ident: $v:expr),+} => $buf:expr, $exp:expr) => (\n        check_shortest!($f{$($k: $v),+} => $buf, $exp;\n                        \"shortest mismatch for {v:?}: actual {actual:?}, expected {expected:?}\",\n                        v = Decoded { $($k: $v),+ })\n    );\n\n    ($f:ident($v:expr) => $buf:expr, $exp:expr; $fmt:expr, $($key:ident = $val:expr),*) => ({\n        let mut buf = [MaybeUninit::new(b'_'); MAX_SIG_DIGITS];\n        let (buf, k) = $f(&decode_finite($v), &mut buf);\n        assert!((buf, k) == ($buf, $exp),\n                $fmt, actual = (str::from_utf8(buf).unwrap(), k),\n                      expected = (str::from_utf8($buf).unwrap(), $exp),\n                      $($key = $val),*);\n    });\n\n    ($f:ident{$($k:ident: $v:expr),+} => $buf:expr, $exp:expr;\n                                         $fmt:expr, $($key:ident = $val:expr),*) => ({\n        let mut buf = [MaybeUninit::new(b'_'); MAX_SIG_DIGITS];\n        let (buf, k) = $f(&Decoded { $($k: $v),+ }, &mut buf);\n        assert!((buf, k) == ($buf, $exp),\n                $fmt, actual = (str::from_utf8(buf).unwrap(), k),\n                      expected = (str::from_utf8($buf).unwrap(), $exp),\n                      $($key = $val),*);\n    })\n}\n\nmacro_rules! try_exact {\n    ($f:ident($decoded:expr) => $buf:expr, $expected:expr, $expectedk:expr;\n                                $fmt:expr, $($key:ident = $val:expr),*) => ({\n        let (buf, k) = $f($decoded, &mut $buf[..$expected.len()], i16::MIN);\n        assert!((buf, k) == ($expected, $expectedk),\n                $fmt, actual = (str::from_utf8(buf).unwrap(), k),\n                      expected = (str::from_utf8($expected).unwrap(), $expectedk),\n                      $($key = $val),*);\n    })\n}\n\nmacro_rules! try_fixed {\n    ($f:ident($decoded:expr) => $buf:expr, $request:expr, $expected:expr, $expectedk:expr;\n                                $fmt:expr, $($key:ident = $val:expr),*) => ({\n        let (buf, k) = $f($decoded, &mut $buf[..], $request);\n        assert!((buf, k) == ($expected, $expectedk),\n                $fmt, actual = (str::from_utf8(buf).unwrap(), k),\n                      expected = (str::from_utf8($expected).unwrap(), $expectedk),\n                      $($key = $val),*);\n    })\n}\n\nfn ldexp_f32(a: f32, b: i32) -> f32 {\n    ldexp_f64(a as f64, b) as f32\n}\n\nfn ldexp_f64(a: f64, b: i32) -> f64 {\n    extern \"C\" {\n        fn ldexp(x: f64, n: i32) -> f64;\n    }\n    // SAFETY: assuming a correct `ldexp` has been supplied, the given arguments cannot possibly\n    // cause undefined behavior\n    unsafe { ldexp(a, b) }\n}\n\nfn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16)\nwhere\n    T: DecodableFloat,\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    // use a large enough buffer\n    let mut buf = [MaybeUninit::new(b'_'); 1024];\n    let mut expected_ = [b'_'; 1024];\n\n    let decoded = decode_finite(v);\n    let cut = expected.iter().position(|&c| c == b' ');\n\n    // check significant digits\n    for i in 1..cut.unwrap_or(expected.len() - 1) {\n        expected_[..i].copy_from_slice(&expected[..i]);\n        let mut expectedk_ = expectedk;\n        if expected[i] >= b'5' {\n            // check if this is a rounding-to-even case.\n            // we avoid rounding ...x5000... (with infinite zeroes) to ...(x+1) when x is even.\n            if !(i + 1 < expected.len()\n                && expected[i - 1] & 1 == 0\n                && expected[i] == b'5'\n                && expected[i + 1] == b' ')\n            {\n                // if this returns true, expected_[..i] is all `9`s and being rounded up.\n                // we should always return `100..00` (`i` digits) instead, since that's\n                // what we can came up with `i` digits anyway. `round_up` assumes that\n                // the adjustment to the length is done by caller, which we simply ignore.\n                if let Some(_) = round_up(&mut expected_[..i]) {\n                    expectedk_ += 1;\n                }\n            }\n        }\n\n        try_exact!(f(&decoded) => &mut buf, &expected_[..i], expectedk_;\n                   \"exact sigdigit mismatch for v={v}, i={i}: \\\n                    actual {actual:?}, expected {expected:?}\",\n                   v = vstr, i = i);\n        try_fixed!(f(&decoded) => &mut buf, expectedk_ - i as i16, &expected_[..i], expectedk_;\n                   \"fixed sigdigit mismatch for v={v}, i={i}: \\\n                    actual {actual:?}, expected {expected:?}\",\n                   v = vstr, i = i);\n    }\n\n    // check exact rounding for zero- and negative-width cases\n    let start;\n    if expected[0] >= b'5' {\n        try_fixed!(f(&decoded) => &mut buf, expectedk, b\"1\", expectedk + 1;\n                   \"zero-width rounding-up mismatch for v={v}: \\\n                    actual {actual:?}, expected {expected:?}\",\n                   v = vstr);\n        start = 1;\n    } else {\n        start = 0;\n    }\n    for i in start..-10 {\n        try_fixed!(f(&decoded) => &mut buf, expectedk - i, b\"\", expectedk;\n                   \"rounding-down mismatch for v={v}, i={i}: \\\n                    actual {actual:?}, expected {expected:?}\",\n                   v = vstr, i = -i);\n    }\n\n    // check infinite zero digits\n    if let Some(cut) = cut {\n        for i in cut..expected.len() - 1 {\n            expected_[..cut].copy_from_slice(&expected[..cut]);\n            for c in &mut expected_[cut..i] {\n                *c = b'0';\n            }\n\n            try_exact!(f(&decoded) => &mut buf, &expected_[..i], expectedk;\n                       \"exact infzero mismatch for v={v}, i={i}: \\\n                        actual {actual:?}, expected {expected:?}\",\n                       v = vstr, i = i);\n            try_fixed!(f(&decoded) => &mut buf, expectedk - i as i16, &expected_[..i], expectedk;\n                       \"fixed infzero mismatch for v={v}, i={i}: \\\n                        actual {actual:?}, expected {expected:?}\",\n                       v = vstr, i = i);\n        }\n    }\n}\n\ntrait TestableFloat: DecodableFloat + fmt::Display {\n    /// Returns `x * 2^exp`. Almost same to `std::{f32,f64}::ldexp`.\n    /// This is used for testing.\n    fn ldexpi(f: i64, exp: isize) -> Self;\n}\n\nimpl TestableFloat for f32 {\n    fn ldexpi(f: i64, exp: isize) -> Self {\n        f as Self * (exp as Self).exp2()\n    }\n}\n\nimpl TestableFloat for f64 {\n    fn ldexpi(f: i64, exp: isize) -> Self {\n        f as Self * (exp as Self).exp2()\n    }\n}\n\nfn check_exact_one<F, T>(mut f: F, x: i64, e: isize, tstr: &str, expected: &[u8], expectedk: i16)\nwhere\n    T: TestableFloat,\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    // use a large enough buffer\n    let mut buf = [MaybeUninit::new(b'_'); 1024];\n    let v: T = TestableFloat::ldexpi(x, e);\n    let decoded = decode_finite(v);\n\n    try_exact!(f(&decoded) => &mut buf, &expected, expectedk;\n               \"exact mismatch for v={x}p{e}{t}: actual {actual:?}, expected {expected:?}\",\n               x = x, e = e, t = tstr);\n    try_fixed!(f(&decoded) => &mut buf, expectedk - expected.len() as i16, &expected, expectedk;\n               \"fixed mismatch for v={x}p{e}{t}: actual {actual:?}, expected {expected:?}\",\n               x = x, e = e, t = tstr);\n}\n\nmacro_rules! check_exact {\n    ($f:ident($v:expr) => $buf:expr, $exp:expr) => {\n        check_exact(|d, b, k| $f(d, b, k), $v, stringify!($v), $buf, $exp)\n    };\n}\n\nmacro_rules! check_exact_one {\n    ($f:ident($x:expr, $e:expr; $t:ty) => $buf:expr, $exp:expr) => {\n        check_exact_one::<_, $t>(|d, b, k| $f(d, b, k), $x, $e, stringify!($t), $buf, $exp)\n    };\n}\n\n// in the following comments, three numbers are spaced by 1 ulp apart,\n// and the second one is being formatted.\n//\n// some tests are derived from [1].\n//\n// [1] Vern Paxson, A Program for Testing IEEE Decimal-Binary Conversion\n//     ftp://ftp.ee.lbl.gov/testbase-report.ps.Z\n\npub fn f32_shortest_sanity_test<F>(mut f: F)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    // 0.0999999940395355224609375\n    // 0.100000001490116119384765625\n    // 0.10000000894069671630859375\n    check_shortest!(f(0.1f32) => b\"1\", 0);\n\n    // 0.333333313465118408203125\n    // 0.3333333432674407958984375 (1/3 in the default rounding)\n    // 0.33333337306976318359375\n    check_shortest!(f(1.0f32/3.0) => b\"33333334\", 0);\n\n    // 10^1 * 0.31415917873382568359375\n    // 10^1 * 0.31415920257568359375\n    // 10^1 * 0.31415922641754150390625\n    check_shortest!(f(3.141592f32) => b\"3141592\", 1);\n\n    // 10^18 * 0.31415916243714048\n    // 10^18 * 0.314159196796878848\n    // 10^18 * 0.314159231156617216\n    check_shortest!(f(3.141592e17f32) => b\"3141592\", 18);\n\n    // regression test for decoders\n    // 10^8 * 0.3355443\n    // 10^8 * 0.33554432\n    // 10^8 * 0.33554436\n    check_shortest!(f(ldexp_f32(1.0, 25)) => b\"33554432\", 8);\n\n    // 10^39 * 0.340282326356119256160033759537265639424\n    // 10^39 * 0.34028234663852885981170418348451692544\n    // 10^39 * 0.340282366920938463463374607431768211456\n    check_shortest!(f(f32::MAX) => b\"34028235\", 39);\n\n    // 10^-37 * 0.1175494210692441075487029444849287348827...\n    // 10^-37 * 0.1175494350822287507968736537222245677818...\n    // 10^-37 * 0.1175494490952133940450443629595204006810...\n    check_shortest!(f(f32::MIN_POSITIVE) => b\"11754944\", -37);\n\n    // 10^-44 * 0\n    // 10^-44 * 0.1401298464324817070923729583289916131280...\n    // 10^-44 * 0.2802596928649634141847459166579832262560...\n    let minf32 = ldexp_f32(1.0, -149);\n    check_shortest!(f(minf32) => b\"1\", -44);\n}\n\npub fn f32_exact_sanity_test<F>(mut f: F)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    let minf32 = ldexp_f32(1.0, -149);\n\n    check_exact!(f(0.1f32)            => b\"100000001490116119384765625             \", 0);\n    check_exact!(f(0.5f32)            => b\"5                                       \", 0);\n    check_exact!(f(1.0f32/3.0)        => b\"3333333432674407958984375               \", 0);\n    check_exact!(f(3.141592f32)       => b\"31415920257568359375                    \", 1);\n    check_exact!(f(3.141592e17f32)    => b\"314159196796878848                      \", 18);\n    check_exact!(f(f32::MAX)          => b\"34028234663852885981170418348451692544  \", 39);\n    check_exact!(f(f32::MIN_POSITIVE) => b\"1175494350822287507968736537222245677818\", -37);\n    check_exact!(f(minf32)            => b\"1401298464324817070923729583289916131280\", -44);\n\n    // [1], Table 16: Stress Inputs for Converting 24-bit Binary to Decimal, < 1/2 ULP\n    check_exact_one!(f(12676506, -102; f32) => b\"2\",            -23);\n    check_exact_one!(f(12676506, -103; f32) => b\"12\",           -23);\n    check_exact_one!(f(15445013,   86; f32) => b\"119\",           34);\n    check_exact_one!(f(13734123, -138; f32) => b\"3941\",         -34);\n    check_exact_one!(f(12428269, -130; f32) => b\"91308\",        -32);\n    check_exact_one!(f(15334037, -146; f32) => b\"171900\",       -36);\n    check_exact_one!(f(11518287,  -41; f32) => b\"5237910\",       -5);\n    check_exact_one!(f(12584953, -145; f32) => b\"28216440\",     -36);\n    check_exact_one!(f(15961084, -125; f32) => b\"375243281\",    -30);\n    check_exact_one!(f(14915817, -146; f32) => b\"1672120916\",   -36);\n    check_exact_one!(f(10845484, -102; f32) => b\"21388945814\",  -23);\n    check_exact_one!(f(16431059,  -61; f32) => b\"712583594561\", -11);\n\n    // [1], Table 17: Stress Inputs for Converting 24-bit Binary to Decimal, > 1/2 ULP\n    check_exact_one!(f(16093626,   69; f32) => b\"1\",             29);\n    check_exact_one!(f( 9983778,   25; f32) => b\"34\",            15);\n    check_exact_one!(f(12745034,  104; f32) => b\"259\",           39);\n    check_exact_one!(f(12706553,   72; f32) => b\"6001\",          29);\n    check_exact_one!(f(11005028,   45; f32) => b\"38721\",         21);\n    check_exact_one!(f(15059547,   71; f32) => b\"355584\",        29);\n    check_exact_one!(f(16015691,  -99; f32) => b\"2526831\",      -22);\n    check_exact_one!(f( 8667859,   56; f32) => b\"62458507\",      24);\n    check_exact_one!(f(14855922,  -82; f32) => b\"307213267\",    -17);\n    check_exact_one!(f(14855922,  -83; f32) => b\"1536066333\",   -17);\n    check_exact_one!(f(10144164, -110; f32) => b\"78147796834\",  -26);\n    check_exact_one!(f(13248074,   95; f32) => b\"524810279937\",  36);\n}\n\npub fn f64_shortest_sanity_test<F>(mut f: F)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    // 0.0999999999999999777955395074968691915273...\n    // 0.1000000000000000055511151231257827021181...\n    // 0.1000000000000000333066907387546962127089...\n    check_shortest!(f(0.1f64) => b\"1\", 0);\n\n    // this example is explicitly mentioned in the paper.\n    // 10^3 * 0.0999999999999999857891452847979962825775...\n    // 10^3 * 0.1 (exact)\n    // 10^3 * 0.1000000000000000142108547152020037174224...\n    check_shortest!(f(100.0f64) => b\"1\", 3);\n\n    // 0.3333333333333332593184650249895639717578...\n    // 0.3333333333333333148296162562473909929394... (1/3 in the default rounding)\n    // 0.3333333333333333703407674875052180141210...\n    check_shortest!(f(1.0f64/3.0) => b\"3333333333333333\", 0);\n\n    // explicit test case for equally closest representations.\n    // Dragon has its own tie-breaking rule; Grisu should fall back.\n    // 10^1 * 0.1000007629394531027955395074968691915273...\n    // 10^1 * 0.100000762939453125 (exact)\n    // 10^1 * 0.1000007629394531472044604925031308084726...\n    check_shortest!(f(1.00000762939453125f64) => b\"10000076293945313\", 1);\n\n    // 10^1 * 0.3141591999999999718085064159822650253772...\n    // 10^1 * 0.3141592000000000162174274009885266423225...\n    // 10^1 * 0.3141592000000000606263483859947882592678...\n    check_shortest!(f(3.141592f64) => b\"3141592\", 1);\n\n    // 10^18 * 0.314159199999999936\n    // 10^18 * 0.3141592 (exact)\n    // 10^18 * 0.314159200000000064\n    check_shortest!(f(3.141592e17f64) => b\"3141592\", 18);\n\n    // regression test for decoders\n    // 10^20 * 0.18446744073709549568\n    // 10^20 * 0.18446744073709551616\n    // 10^20 * 0.18446744073709555712\n    check_shortest!(f(ldexp_f64(1.0, 64)) => b\"18446744073709552\", 20);\n\n    // pathological case: high = 10^23 (exact). tie breaking should always prefer that.\n    // 10^24 * 0.099999999999999974834176\n    // 10^24 * 0.099999999999999991611392\n    // 10^24 * 0.100000000000000008388608\n    check_shortest!(f(1.0e23f64) => b\"1\", 24);\n\n    // 10^309 * 0.1797693134862315508561243283845062402343...\n    // 10^309 * 0.1797693134862315708145274237317043567980...\n    // 10^309 * 0.1797693134862315907729305190789024733617...\n    check_shortest!(f(f64::MAX) => b\"17976931348623157\", 309);\n\n    // 10^-307 * 0.2225073858507200889024586876085859887650...\n    // 10^-307 * 0.2225073858507201383090232717332404064219...\n    // 10^-307 * 0.2225073858507201877155878558578948240788...\n    check_shortest!(f(f64::MIN_POSITIVE) => b\"22250738585072014\", -307);\n\n    // 10^-323 * 0\n    // 10^-323 * 0.4940656458412465441765687928682213723650...\n    // 10^-323 * 0.9881312916824930883531375857364427447301...\n    let minf64 = ldexp_f64(1.0, -1074);\n    check_shortest!(f(minf64) => b\"5\", -323);\n}\n\npub fn f64_exact_sanity_test<F>(mut f: F)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    let minf64 = ldexp_f64(1.0, -1074);\n\n    check_exact!(f(0.1f64)            => b\"1000000000000000055511151231257827021181\", 0);\n    check_exact!(f(0.45f64)           => b\"4500000000000000111022302462515654042363\", 0);\n    check_exact!(f(0.5f64)            => b\"5                                       \", 0);\n    check_exact!(f(0.95f64)           => b\"9499999999999999555910790149937383830547\", 0);\n    check_exact!(f(100.0f64)          => b\"1                                       \", 3);\n    check_exact!(f(999.5f64)          => b\"9995000000000000000000000000000000000000\", 3);\n    check_exact!(f(1.0f64/3.0)        => b\"3333333333333333148296162562473909929394\", 0);\n    check_exact!(f(3.141592f64)       => b\"3141592000000000162174274009885266423225\", 1);\n    check_exact!(f(3.141592e17f64)    => b\"3141592                                 \", 18);\n    check_exact!(f(1.0e23f64)         => b\"99999999999999991611392                 \", 23);\n    check_exact!(f(f64::MAX)          => b\"1797693134862315708145274237317043567980\", 309);\n    check_exact!(f(f64::MIN_POSITIVE) => b\"2225073858507201383090232717332404064219\", -307);\n    check_exact!(f(minf64)            => b\"4940656458412465441765687928682213723650\\\n                                           5980261432476442558568250067550727020875\\\n                                           1865299836361635992379796564695445717730\\\n                                           9266567103559397963987747960107818781263\\\n                                           0071319031140452784581716784898210368871\\\n                                           8636056998730723050006387409153564984387\\\n                                           3124733972731696151400317153853980741262\\\n                                           3856559117102665855668676818703956031062\\\n                                           4931945271591492455329305456544401127480\\\n                                           1297099995419319894090804165633245247571\\\n                                           4786901472678015935523861155013480352649\\\n                                           3472019379026810710749170333222684475333\\\n                                           5720832431936092382893458368060106011506\\\n                                           1698097530783422773183292479049825247307\\\n                                           7637592724787465608477820373446969953364\\\n                                           7017972677717585125660551199131504891101\\\n                                           4510378627381672509558373897335989936648\\\n                                           0994116420570263709027924276754456522908\\\n                                           7538682506419718265533447265625         \", -323);\n\n    // [1], Table 3: Stress Inputs for Converting 53-bit Binary to Decimal, < 1/2 ULP\n    check_exact_one!(f(8511030020275656,  -342; f64) => b\"9\",                       -87);\n    check_exact_one!(f(5201988407066741,  -824; f64) => b\"46\",                     -232);\n    check_exact_one!(f(6406892948269899,   237; f64) => b\"141\",                      88);\n    check_exact_one!(f(8431154198732492,    72; f64) => b\"3981\",                     38);\n    check_exact_one!(f(6475049196144587,    99; f64) => b\"41040\",                    46);\n    check_exact_one!(f(8274307542972842,   726; f64) => b\"292084\",                  235);\n    check_exact_one!(f(5381065484265332,  -456; f64) => b\"2891946\",                -121);\n    check_exact_one!(f(6761728585499734, -1057; f64) => b\"43787718\",               -302);\n    check_exact_one!(f(7976538478610756,   376; f64) => b\"122770163\",               130);\n    check_exact_one!(f(5982403858958067,   377; f64) => b\"1841552452\",              130);\n    check_exact_one!(f(5536995190630837,    93; f64) => b\"54835744350\",              44);\n    check_exact_one!(f(7225450889282194,   710; f64) => b\"389190181146\",            230);\n    check_exact_one!(f(7225450889282194,   709; f64) => b\"1945950905732\",           230);\n    check_exact_one!(f(8703372741147379,   117; f64) => b\"14460958381605\",           52);\n    check_exact_one!(f(8944262675275217, -1001; f64) => b\"417367747458531\",        -285);\n    check_exact_one!(f(7459803696087692,  -707; f64) => b\"1107950772878888\",       -196);\n    check_exact_one!(f(6080469016670379,  -381; f64) => b\"12345501366327440\",       -98);\n    check_exact_one!(f(8385515147034757,   721; f64) => b\"925031711960365024\",      233);\n    check_exact_one!(f(7514216811389786,  -828; f64) => b\"4198047150284889840\",    -233);\n    check_exact_one!(f(8397297803260511,  -345; f64) => b\"11716315319786511046\",    -87);\n    check_exact_one!(f(6733459239310543,   202; f64) => b\"432810072844612493629\",    77);\n    check_exact_one!(f(8091450587292794,  -473; f64) => b\"3317710118160031081518\", -126);\n\n    // [1], Table 4: Stress Inputs for Converting 53-bit Binary to Decimal, > 1/2 ULP\n    check_exact_one!(f(6567258882077402,   952; f64) => b\"3\",                       303);\n    check_exact_one!(f(6712731423444934,   535; f64) => b\"76\",                      177);\n    check_exact_one!(f(6712731423444934,   534; f64) => b\"378\",                     177);\n    check_exact_one!(f(5298405411573037,  -957; f64) => b\"4350\",                   -272);\n    check_exact_one!(f(5137311167659507,  -144; f64) => b\"23037\",                   -27);\n    check_exact_one!(f(6722280709661868,   363; f64) => b\"126301\",                  126);\n    check_exact_one!(f(5344436398034927,  -169; f64) => b\"7142211\",                 -35);\n    check_exact_one!(f(8369123604277281,  -853; f64) => b\"13934574\",               -240);\n    check_exact_one!(f(8995822108487663,  -780; f64) => b\"141463449\",              -218);\n    check_exact_one!(f(8942832835564782,  -383; f64) => b\"4539277920\",              -99);\n    check_exact_one!(f(8942832835564782,  -384; f64) => b\"22696389598\",             -99);\n    check_exact_one!(f(8942832835564782,  -385; f64) => b\"113481947988\",            -99);\n    check_exact_one!(f(6965949469487146,  -249; f64) => b\"7700366561890\",           -59);\n    check_exact_one!(f(6965949469487146,  -250; f64) => b\"38501832809448\",          -59);\n    check_exact_one!(f(6965949469487146,  -251; f64) => b\"192509164047238\",         -59);\n    check_exact_one!(f(7487252720986826,   548; f64) => b\"6898586531774201\",        181);\n    check_exact_one!(f(5592117679628511,   164; f64) => b\"13076622631878654\",        66);\n    check_exact_one!(f(8887055249355788,   665; f64) => b\"136052020756121240\",      217);\n    check_exact_one!(f(6994187472632449,   690; f64) => b\"3592810217475959676\",     224);\n    check_exact_one!(f(8797576579012143,   588; f64) => b\"89125197712484551899\",    193);\n    check_exact_one!(f(7363326733505337,   272; f64) => b\"558769757362301140950\",    98);\n    check_exact_one!(f(8549497411294502,  -448; f64) => b\"1176257830728540379990\", -118);\n}\n\npub fn more_shortest_sanity_test<F>(mut f: F)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    check_shortest!(f{mant: 99_999_999_999_999_999, minus: 1, plus: 1,\n                      exp: 0, inclusive: true} => b\"1\", 18);\n    check_shortest!(f{mant: 99_999_999_999_999_999, minus: 1, plus: 1,\n                      exp: 0, inclusive: false} => b\"99999999999999999\", 17);\n}\n\nfn to_string_with_parts<F>(mut f: F) -> String\nwhere\n    F: for<'a> FnMut(&'a mut [MaybeUninit<u8>], &'a mut [MaybeUninit<Part<'a>>]) -> Formatted<'a>,\n{\n    let mut buf = [MaybeUninit::new(0); 1024];\n    let mut parts = [MaybeUninit::new(Part::Zero(0)); 16];\n    let formatted = f(&mut buf, &mut parts);\n    let mut ret = vec![0; formatted.len()];\n    assert_eq!(formatted.write(&mut ret), Some(ret.len()));\n    String::from_utf8(ret).unwrap()\n}\n\npub fn to_shortest_str_test<F>(mut f_: F)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    use core::num::flt2dec::Sign::*;\n\n    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize) -> String\n    where\n        T: DecodableFloat,\n        F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n    {\n        to_string_with_parts(|buf, parts| {\n            to_shortest_str(|d, b| f(d, b), v, sign, frac_digits, buf, parts)\n        })\n    }\n\n    let f = &mut f_;\n\n    assert_eq!(to_string(f, 0.0, Minus, 0), \"0\");\n    assert_eq!(to_string(f, 0.0, Minus, 0), \"0\");\n    assert_eq!(to_string(f, 0.0, MinusPlus, 0), \"+0\");\n    assert_eq!(to_string(f, -0.0, Minus, 0), \"-0\");\n    assert_eq!(to_string(f, -0.0, MinusPlus, 0), \"-0\");\n    assert_eq!(to_string(f, 0.0, Minus, 1), \"0.0\");\n    assert_eq!(to_string(f, 0.0, Minus, 1), \"0.0\");\n    assert_eq!(to_string(f, 0.0, MinusPlus, 1), \"+0.0\");\n    assert_eq!(to_string(f, -0.0, Minus, 8), \"-0.00000000\");\n    assert_eq!(to_string(f, -0.0, MinusPlus, 8), \"-0.00000000\");\n\n    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0), \"inf\");\n    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0), \"inf\");\n    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 0), \"+inf\");\n    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0), \"NaN\");\n    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 1), \"NaN\");\n    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 64), \"NaN\");\n    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0), \"-inf\");\n    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 1), \"-inf\");\n    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 64), \"-inf\");\n\n    assert_eq!(to_string(f, 3.14, Minus, 0), \"3.14\");\n    assert_eq!(to_string(f, 3.14, Minus, 0), \"3.14\");\n    assert_eq!(to_string(f, 3.14, MinusPlus, 0), \"+3.14\");\n    assert_eq!(to_string(f, -3.14, Minus, 0), \"-3.14\");\n    assert_eq!(to_string(f, -3.14, Minus, 0), \"-3.14\");\n    assert_eq!(to_string(f, -3.14, MinusPlus, 0), \"-3.14\");\n    assert_eq!(to_string(f, 3.14, Minus, 1), \"3.14\");\n    assert_eq!(to_string(f, 3.14, Minus, 2), \"3.14\");\n    assert_eq!(to_string(f, 3.14, MinusPlus, 4), \"+3.1400\");\n    assert_eq!(to_string(f, -3.14, Minus, 8), \"-3.14000000\");\n    assert_eq!(to_string(f, -3.14, Minus, 8), \"-3.14000000\");\n    assert_eq!(to_string(f, -3.14, MinusPlus, 8), \"-3.14000000\");\n\n    assert_eq!(to_string(f, 7.5e-11, Minus, 0), \"0.000000000075\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, 3), \"0.000000000075\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, 12), \"0.000000000075\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, 13), \"0.0000000000750\");\n\n    assert_eq!(to_string(f, 1.9971e20, Minus, 0), \"199710000000000000000\");\n    assert_eq!(to_string(f, 1.9971e20, Minus, 1), \"199710000000000000000.0\");\n    assert_eq!(to_string(f, 1.9971e20, Minus, 8), \"199710000000000000000.00000000\");\n\n    assert_eq!(to_string(f, f32::MAX, Minus, 0), format!(\"34028235{:0>31}\", \"\"));\n    assert_eq!(to_string(f, f32::MAX, Minus, 1), format!(\"34028235{:0>31}.0\", \"\"));\n    assert_eq!(to_string(f, f32::MAX, Minus, 8), format!(\"34028235{:0>31}.00000000\", \"\"));\n\n    let minf32 = ldexp_f32(1.0, -149);\n    assert_eq!(to_string(f, minf32, Minus, 0), format!(\"0.{:0>44}1\", \"\"));\n    assert_eq!(to_string(f, minf32, Minus, 45), format!(\"0.{:0>44}1\", \"\"));\n    assert_eq!(to_string(f, minf32, Minus, 46), format!(\"0.{:0>44}10\", \"\"));\n\n    assert_eq!(to_string(f, f64::MAX, Minus, 0), format!(\"17976931348623157{:0>292}\", \"\"));\n    assert_eq!(to_string(f, f64::MAX, Minus, 1), format!(\"17976931348623157{:0>292}.0\", \"\"));\n    assert_eq!(to_string(f, f64::MAX, Minus, 8), format!(\"17976931348623157{:0>292}.00000000\", \"\"));\n\n    let minf64 = ldexp_f64(1.0, -1074);\n    assert_eq!(to_string(f, minf64, Minus, 0), format!(\"0.{:0>323}5\", \"\"));\n    assert_eq!(to_string(f, minf64, Minus, 324), format!(\"0.{:0>323}5\", \"\"));\n    assert_eq!(to_string(f, minf64, Minus, 325), format!(\"0.{:0>323}50\", \"\"));\n\n    if cfg!(miri) {\n        // Miri is too slow\n        return;\n    }\n\n    // very large output\n    assert_eq!(to_string(f, 1.1, Minus, 80000), format!(\"1.1{:0>79999}\", \"\"));\n}\n\npub fn to_shortest_exp_str_test<F>(mut f_: F)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    use core::num::flt2dec::Sign::*;\n\n    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, exp_bounds: (i16, i16), upper: bool) -> String\n    where\n        T: DecodableFloat,\n        F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n    {\n        to_string_with_parts(|buf, parts| {\n            to_shortest_exp_str(|d, b| f(d, b), v, sign, exp_bounds, upper, buf, parts)\n        })\n    }\n\n    let f = &mut f_;\n\n    assert_eq!(to_string(f, 0.0, Minus, (-4, 16), false), \"0\");\n    assert_eq!(to_string(f, 0.0, Minus, (-4, 16), false), \"0\");\n    assert_eq!(to_string(f, 0.0, MinusPlus, (-4, 16), false), \"+0\");\n    assert_eq!(to_string(f, -0.0, Minus, (-4, 16), false), \"-0\");\n    assert_eq!(to_string(f, -0.0, MinusPlus, (-4, 16), false), \"-0\");\n    assert_eq!(to_string(f, 0.0, Minus, (0, 0), true), \"0E0\");\n    assert_eq!(to_string(f, 0.0, Minus, (0, 0), false), \"0e0\");\n    assert_eq!(to_string(f, 0.0, MinusPlus, (5, 9), false), \"+0e0\");\n    assert_eq!(to_string(f, -0.0, Minus, (0, 0), true), \"-0E0\");\n    assert_eq!(to_string(f, -0.0, MinusPlus, (5, 9), false), \"-0e0\");\n\n    assert_eq!(to_string(f, 1.0 / 0.0, Minus, (-4, 16), false), \"inf\");\n    assert_eq!(to_string(f, 1.0 / 0.0, Minus, (-4, 16), true), \"inf\");\n    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, (-4, 16), true), \"+inf\");\n    assert_eq!(to_string(f, 0.0 / 0.0, Minus, (0, 0), false), \"NaN\");\n    assert_eq!(to_string(f, 0.0 / 0.0, Minus, (0, 0), true), \"NaN\");\n    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, (5, 9), true), \"NaN\");\n    assert_eq!(to_string(f, -1.0 / 0.0, Minus, (0, 0), false), \"-inf\");\n    assert_eq!(to_string(f, -1.0 / 0.0, Minus, (0, 0), true), \"-inf\");\n    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, (5, 9), true), \"-inf\");\n\n    assert_eq!(to_string(f, 3.14, Minus, (-4, 16), false), \"3.14\");\n    assert_eq!(to_string(f, 3.14, MinusPlus, (-4, 16), false), \"+3.14\");\n    assert_eq!(to_string(f, -3.14, Minus, (-4, 16), false), \"-3.14\");\n    assert_eq!(to_string(f, -3.14, MinusPlus, (-4, 16), false), \"-3.14\");\n    assert_eq!(to_string(f, 3.14, Minus, (0, 0), true), \"3.14E0\");\n    assert_eq!(to_string(f, 3.14, Minus, (0, 0), false), \"3.14e0\");\n    assert_eq!(to_string(f, 3.14, MinusPlus, (5, 9), false), \"+3.14e0\");\n    assert_eq!(to_string(f, -3.14, Minus, (0, 0), true), \"-3.14E0\");\n    assert_eq!(to_string(f, -3.14, Minus, (0, 0), false), \"-3.14e0\");\n    assert_eq!(to_string(f, -3.14, MinusPlus, (5, 9), false), \"-3.14e0\");\n\n    assert_eq!(to_string(f, 0.1, Minus, (-4, 16), false), \"0.1\");\n    assert_eq!(to_string(f, 0.1, Minus, (-4, 16), false), \"0.1\");\n    assert_eq!(to_string(f, 0.1, MinusPlus, (-4, 16), false), \"+0.1\");\n    assert_eq!(to_string(f, -0.1, Minus, (-4, 16), false), \"-0.1\");\n    assert_eq!(to_string(f, -0.1, MinusPlus, (-4, 16), false), \"-0.1\");\n    assert_eq!(to_string(f, 0.1, Minus, (0, 0), true), \"1E-1\");\n    assert_eq!(to_string(f, 0.1, Minus, (0, 0), false), \"1e-1\");\n    assert_eq!(to_string(f, 0.1, MinusPlus, (5, 9), false), \"+1e-1\");\n    assert_eq!(to_string(f, -0.1, Minus, (0, 0), true), \"-1E-1\");\n    assert_eq!(to_string(f, -0.1, Minus, (0, 0), false), \"-1e-1\");\n    assert_eq!(to_string(f, -0.1, MinusPlus, (5, 9), false), \"-1e-1\");\n\n    assert_eq!(to_string(f, 7.5e-11, Minus, (-4, 16), false), \"7.5e-11\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, (-11, 10), false), \"0.000000000075\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, (-10, 11), false), \"7.5e-11\");\n\n    assert_eq!(to_string(f, 1.9971e20, Minus, (-4, 16), false), \"1.9971e20\");\n    assert_eq!(to_string(f, 1.9971e20, Minus, (-20, 21), false), \"199710000000000000000\");\n    assert_eq!(to_string(f, 1.9971e20, Minus, (-21, 20), false), \"1.9971e20\");\n\n    // the true value of 1.0e23f64 is less than 10^23, but that shouldn't matter here\n    assert_eq!(to_string(f, 1.0e23, Minus, (22, 23), false), \"1e23\");\n    assert_eq!(to_string(f, 1.0e23, Minus, (23, 24), false), \"100000000000000000000000\");\n    assert_eq!(to_string(f, 1.0e23, Minus, (24, 25), false), \"1e23\");\n\n    assert_eq!(to_string(f, f32::MAX, Minus, (-4, 16), false), \"3.4028235e38\");\n    assert_eq!(to_string(f, f32::MAX, Minus, (-39, 38), false), \"3.4028235e38\");\n    assert_eq!(to_string(f, f32::MAX, Minus, (-38, 39), false), format!(\"34028235{:0>31}\", \"\"));\n\n    let minf32 = ldexp_f32(1.0, -149);\n    assert_eq!(to_string(f, minf32, Minus, (-4, 16), false), \"1e-45\");\n    assert_eq!(to_string(f, minf32, Minus, (-44, 45), false), \"1e-45\");\n    assert_eq!(to_string(f, minf32, Minus, (-45, 44), false), format!(\"0.{:0>44}1\", \"\"));\n\n    assert_eq!(to_string(f, f64::MAX, Minus, (-4, 16), false), \"1.7976931348623157e308\");\n    assert_eq!(\n        to_string(f, f64::MAX, Minus, (-308, 309), false),\n        format!(\"17976931348623157{:0>292}\", \"\")\n    );\n    assert_eq!(to_string(f, f64::MAX, Minus, (-309, 308), false), \"1.7976931348623157e308\");\n\n    let minf64 = ldexp_f64(1.0, -1074);\n    assert_eq!(to_string(f, minf64, Minus, (-4, 16), false), \"5e-324\");\n    assert_eq!(to_string(f, minf64, Minus, (-324, 323), false), format!(\"0.{:0>323}5\", \"\"));\n    assert_eq!(to_string(f, minf64, Minus, (-323, 324), false), \"5e-324\");\n\n    assert_eq!(to_string(f, 1.1, Minus, (i16::MIN, i16::MAX), false), \"1.1\");\n}\n\npub fn to_exact_exp_str_test<F>(mut f_: F)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    use core::num::flt2dec::Sign::*;\n\n    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, ndigits: usize, upper: bool) -> String\n    where\n        T: DecodableFloat,\n        F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n    {\n        to_string_with_parts(|buf, parts| {\n            to_exact_exp_str(|d, b, l| f(d, b, l), v, sign, ndigits, upper, buf, parts)\n        })\n    }\n\n    let f = &mut f_;\n\n    assert_eq!(to_string(f, 0.0, Minus, 1, true), \"0E0\");\n    assert_eq!(to_string(f, 0.0, Minus, 1, false), \"0e0\");\n    assert_eq!(to_string(f, 0.0, MinusPlus, 1, false), \"+0e0\");\n    assert_eq!(to_string(f, -0.0, Minus, 1, true), \"-0E0\");\n    assert_eq!(to_string(f, -0.0, MinusPlus, 1, false), \"-0e0\");\n    assert_eq!(to_string(f, 0.0, Minus, 2, true), \"0.0E0\");\n    assert_eq!(to_string(f, 0.0, Minus, 2, false), \"0.0e0\");\n    assert_eq!(to_string(f, 0.0, MinusPlus, 2, false), \"+0.0e0\");\n    assert_eq!(to_string(f, -0.0, Minus, 8, false), \"-0.0000000e0\");\n    assert_eq!(to_string(f, -0.0, MinusPlus, 8, false), \"-0.0000000e0\");\n\n    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 1, false), \"inf\");\n    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 1, true), \"inf\");\n    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 1, true), \"+inf\");\n    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 8, false), \"NaN\");\n    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 8, true), \"NaN\");\n    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 8, true), \"NaN\");\n    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 64, false), \"-inf\");\n    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 64, true), \"-inf\");\n    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 64, true), \"-inf\");\n\n    assert_eq!(to_string(f, 3.14, Minus, 1, true), \"3E0\");\n    assert_eq!(to_string(f, 3.14, Minus, 1, false), \"3e0\");\n    assert_eq!(to_string(f, 3.14, MinusPlus, 1, false), \"+3e0\");\n    assert_eq!(to_string(f, -3.14, Minus, 2, true), \"-3.1E0\");\n    assert_eq!(to_string(f, -3.14, Minus, 2, false), \"-3.1e0\");\n    assert_eq!(to_string(f, -3.14, MinusPlus, 2, false), \"-3.1e0\");\n    assert_eq!(to_string(f, 3.14, Minus, 3, true), \"3.14E0\");\n    assert_eq!(to_string(f, 3.14, Minus, 3, false), \"3.14e0\");\n    assert_eq!(to_string(f, 3.14, MinusPlus, 3, false), \"+3.14e0\");\n    assert_eq!(to_string(f, -3.14, Minus, 4, true), \"-3.140E0\");\n    assert_eq!(to_string(f, -3.14, Minus, 4, false), \"-3.140e0\");\n    assert_eq!(to_string(f, -3.14, MinusPlus, 4, false), \"-3.140e0\");\n\n    assert_eq!(to_string(f, 0.195, Minus, 1, false), \"2e-1\");\n    assert_eq!(to_string(f, 0.195, Minus, 1, true), \"2E-1\");\n    assert_eq!(to_string(f, 0.195, MinusPlus, 1, true), \"+2E-1\");\n    assert_eq!(to_string(f, -0.195, Minus, 2, false), \"-2.0e-1\");\n    assert_eq!(to_string(f, -0.195, Minus, 2, true), \"-2.0E-1\");\n    assert_eq!(to_string(f, -0.195, MinusPlus, 2, true), \"-2.0E-1\");\n    assert_eq!(to_string(f, 0.195, Minus, 3, false), \"1.95e-1\");\n    assert_eq!(to_string(f, 0.195, Minus, 3, true), \"1.95E-1\");\n    assert_eq!(to_string(f, 0.195, MinusPlus, 3, true), \"+1.95E-1\");\n    assert_eq!(to_string(f, -0.195, Minus, 4, false), \"-1.950e-1\");\n    assert_eq!(to_string(f, -0.195, Minus, 4, true), \"-1.950E-1\");\n    assert_eq!(to_string(f, -0.195, MinusPlus, 4, true), \"-1.950E-1\");\n\n    assert_eq!(to_string(f, 9.5, Minus, 1, false), \"1e1\");\n    assert_eq!(to_string(f, 9.5, Minus, 2, false), \"9.5e0\");\n    assert_eq!(to_string(f, 9.5, Minus, 3, false), \"9.50e0\");\n    assert_eq!(to_string(f, 9.5, Minus, 30, false), \"9.50000000000000000000000000000e0\");\n\n    assert_eq!(to_string(f, 1.0e25, Minus, 1, false), \"1e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 2, false), \"1.0e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 15, false), \"1.00000000000000e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 16, false), \"1.000000000000000e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 17, false), \"1.0000000000000001e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 18, false), \"1.00000000000000009e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 19, false), \"1.000000000000000091e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 20, false), \"1.0000000000000000906e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 21, false), \"1.00000000000000009060e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 22, false), \"1.000000000000000090597e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 23, false), \"1.0000000000000000905970e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 24, false), \"1.00000000000000009059697e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 25, false), \"1.000000000000000090596966e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 26, false), \"1.0000000000000000905969664e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 27, false), \"1.00000000000000009059696640e25\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 30, false), \"1.00000000000000009059696640000e25\");\n\n    assert_eq!(to_string(f, 1.0e-6, Minus, 1, false), \"1e-6\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 2, false), \"1.0e-6\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 16, false), \"1.000000000000000e-6\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 17, false), \"9.9999999999999995e-7\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 18, false), \"9.99999999999999955e-7\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 19, false), \"9.999999999999999547e-7\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 20, false), \"9.9999999999999995475e-7\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 30, false), \"9.99999999999999954748111825886e-7\");\n    assert_eq!(\n        to_string(f, 1.0e-6, Minus, 40, false),\n        \"9.999999999999999547481118258862586856139e-7\"\n    );\n    assert_eq!(\n        to_string(f, 1.0e-6, Minus, 50, false),\n        \"9.9999999999999995474811182588625868561393872369081e-7\"\n    );\n    assert_eq!(\n        to_string(f, 1.0e-6, Minus, 60, false),\n        \"9.99999999999999954748111825886258685613938723690807819366455e-7\"\n    );\n    assert_eq!(\n        to_string(f, 1.0e-6, Minus, 70, false),\n        \"9.999999999999999547481118258862586856139387236908078193664550781250000e-7\"\n    );\n\n    assert_eq!(to_string(f, f32::MAX, Minus, 1, false), \"3e38\");\n    assert_eq!(to_string(f, f32::MAX, Minus, 2, false), \"3.4e38\");\n    assert_eq!(to_string(f, f32::MAX, Minus, 4, false), \"3.403e38\");\n    assert_eq!(to_string(f, f32::MAX, Minus, 8, false), \"3.4028235e38\");\n    assert_eq!(to_string(f, f32::MAX, Minus, 16, false), \"3.402823466385289e38\");\n    assert_eq!(to_string(f, f32::MAX, Minus, 32, false), \"3.4028234663852885981170418348452e38\");\n    assert_eq!(\n        to_string(f, f32::MAX, Minus, 64, false),\n        \"3.402823466385288598117041834845169254400000000000000000000000000e38\"\n    );\n\n    let minf32 = ldexp_f32(1.0, -149);\n    assert_eq!(to_string(f, minf32, Minus, 1, false), \"1e-45\");\n    assert_eq!(to_string(f, minf32, Minus, 2, false), \"1.4e-45\");\n    assert_eq!(to_string(f, minf32, Minus, 4, false), \"1.401e-45\");\n    assert_eq!(to_string(f, minf32, Minus, 8, false), \"1.4012985e-45\");\n    assert_eq!(to_string(f, minf32, Minus, 16, false), \"1.401298464324817e-45\");\n    assert_eq!(to_string(f, minf32, Minus, 32, false), \"1.4012984643248170709237295832899e-45\");\n    assert_eq!(\n        to_string(f, minf32, Minus, 64, false),\n        \"1.401298464324817070923729583289916131280261941876515771757068284e-45\"\n    );\n    assert_eq!(\n        to_string(f, minf32, Minus, 128, false),\n        \"1.401298464324817070923729583289916131280261941876515771757068283\\\n                 8897910826858606014866381883621215820312500000000000000000000000e-45\"\n    );\n\n    if cfg!(miri) {\n        // Miri is too slow\n        return;\n    }\n\n    assert_eq!(to_string(f, f64::MAX, Minus, 1, false), \"2e308\");\n    assert_eq!(to_string(f, f64::MAX, Minus, 2, false), \"1.8e308\");\n    assert_eq!(to_string(f, f64::MAX, Minus, 4, false), \"1.798e308\");\n    assert_eq!(to_string(f, f64::MAX, Minus, 8, false), \"1.7976931e308\");\n    assert_eq!(to_string(f, f64::MAX, Minus, 16, false), \"1.797693134862316e308\");\n    assert_eq!(to_string(f, f64::MAX, Minus, 32, false), \"1.7976931348623157081452742373170e308\");\n    assert_eq!(\n        to_string(f, f64::MAX, Minus, 64, false),\n        \"1.797693134862315708145274237317043567980705675258449965989174768e308\"\n    );\n    assert_eq!(\n        to_string(f, f64::MAX, Minus, 128, false),\n        \"1.797693134862315708145274237317043567980705675258449965989174768\\\n                 0315726078002853876058955863276687817154045895351438246423432133e308\"\n    );\n    assert_eq!(\n        to_string(f, f64::MAX, Minus, 256, false),\n        \"1.797693134862315708145274237317043567980705675258449965989174768\\\n                 0315726078002853876058955863276687817154045895351438246423432132\\\n                 6889464182768467546703537516986049910576551282076245490090389328\\\n                 9440758685084551339423045832369032229481658085593321233482747978e308\"\n    );\n    assert_eq!(\n        to_string(f, f64::MAX, Minus, 512, false),\n        \"1.797693134862315708145274237317043567980705675258449965989174768\\\n                 0315726078002853876058955863276687817154045895351438246423432132\\\n                 6889464182768467546703537516986049910576551282076245490090389328\\\n                 9440758685084551339423045832369032229481658085593321233482747978\\\n                 2620414472316873817718091929988125040402618412485836800000000000\\\n                 0000000000000000000000000000000000000000000000000000000000000000\\\n                 0000000000000000000000000000000000000000000000000000000000000000\\\n                 0000000000000000000000000000000000000000000000000000000000000000e308\"\n    );\n\n    // okay, this is becoming tough. fortunately for us, this is almost the worst case.\n    let minf64 = ldexp_f64(1.0, -1074);\n    assert_eq!(to_string(f, minf64, Minus, 1, false), \"5e-324\");\n    assert_eq!(to_string(f, minf64, Minus, 2, false), \"4.9e-324\");\n    assert_eq!(to_string(f, minf64, Minus, 4, false), \"4.941e-324\");\n    assert_eq!(to_string(f, minf64, Minus, 8, false), \"4.9406565e-324\");\n    assert_eq!(to_string(f, minf64, Minus, 16, false), \"4.940656458412465e-324\");\n    assert_eq!(to_string(f, minf64, Minus, 32, false), \"4.9406564584124654417656879286822e-324\");\n    assert_eq!(\n        to_string(f, minf64, Minus, 64, false),\n        \"4.940656458412465441765687928682213723650598026143247644255856825e-324\"\n    );\n    assert_eq!(\n        to_string(f, minf64, Minus, 128, false),\n        \"4.940656458412465441765687928682213723650598026143247644255856825\\\n                 0067550727020875186529983636163599237979656469544571773092665671e-324\"\n    );\n    assert_eq!(\n        to_string(f, minf64, Minus, 256, false),\n        \"4.940656458412465441765687928682213723650598026143247644255856825\\\n                 0067550727020875186529983636163599237979656469544571773092665671\\\n                 0355939796398774796010781878126300713190311404527845817167848982\\\n                 1036887186360569987307230500063874091535649843873124733972731696e-324\"\n    );\n    assert_eq!(\n        to_string(f, minf64, Minus, 512, false),\n        \"4.940656458412465441765687928682213723650598026143247644255856825\\\n                 0067550727020875186529983636163599237979656469544571773092665671\\\n                 0355939796398774796010781878126300713190311404527845817167848982\\\n                 1036887186360569987307230500063874091535649843873124733972731696\\\n                 1514003171538539807412623856559117102665855668676818703956031062\\\n                 4931945271591492455329305456544401127480129709999541931989409080\\\n                 4165633245247571478690147267801593552386115501348035264934720193\\\n                 7902681071074917033322268447533357208324319360923828934583680601e-324\"\n    );\n    assert_eq!(\n        to_string(f, minf64, Minus, 1024, false),\n        \"4.940656458412465441765687928682213723650598026143247644255856825\\\n                 0067550727020875186529983636163599237979656469544571773092665671\\\n                 0355939796398774796010781878126300713190311404527845817167848982\\\n                 1036887186360569987307230500063874091535649843873124733972731696\\\n                 1514003171538539807412623856559117102665855668676818703956031062\\\n                 4931945271591492455329305456544401127480129709999541931989409080\\\n                 4165633245247571478690147267801593552386115501348035264934720193\\\n                 7902681071074917033322268447533357208324319360923828934583680601\\\n                 0601150616980975307834227731832924790498252473077637592724787465\\\n                 6084778203734469699533647017972677717585125660551199131504891101\\\n                 4510378627381672509558373897335989936648099411642057026370902792\\\n                 4276754456522908753868250641971826553344726562500000000000000000\\\n                 0000000000000000000000000000000000000000000000000000000000000000\\\n                 0000000000000000000000000000000000000000000000000000000000000000\\\n                 0000000000000000000000000000000000000000000000000000000000000000\\\n                 0000000000000000000000000000000000000000000000000000000000000000e-324\"\n    );\n\n    // very large output\n    assert_eq!(to_string(f, 0.0, Minus, 80000, false), format!(\"0.{:0>79999}e0\", \"\"));\n    assert_eq!(to_string(f, 1.0e1, Minus, 80000, false), format!(\"1.{:0>79999}e1\", \"\"));\n    assert_eq!(to_string(f, 1.0e0, Minus, 80000, false), format!(\"1.{:0>79999}e0\", \"\"));\n    assert_eq!(\n        to_string(f, 1.0e-1, Minus, 80000, false),\n        format!(\n            \"1.000000000000000055511151231257827021181583404541015625{:0>79945}\\\n                        e-1\",\n            \"\"\n        )\n    );\n    assert_eq!(\n        to_string(f, 1.0e-20, Minus, 80000, false),\n        format!(\n            \"9.999999999999999451532714542095716517295037027873924471077157760\\\n                         66783064379706047475337982177734375{:0>79901}e-21\",\n            \"\"\n        )\n    );\n}\n\npub fn to_exact_fixed_str_test<F>(mut f_: F)\nwhere\n    F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    use core::num::flt2dec::Sign::*;\n\n    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize) -> String\n    where\n        T: DecodableFloat,\n        F: for<'a> FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n    {\n        to_string_with_parts(|buf, parts| {\n            to_exact_fixed_str(|d, b, l| f(d, b, l), v, sign, frac_digits, buf, parts)\n        })\n    }\n\n    let f = &mut f_;\n\n    assert_eq!(to_string(f, 0.0, Minus, 0), \"0\");\n    assert_eq!(to_string(f, 0.0, MinusPlus, 0), \"+0\");\n    assert_eq!(to_string(f, -0.0, Minus, 0), \"-0\");\n    assert_eq!(to_string(f, -0.0, MinusPlus, 0), \"-0\");\n    assert_eq!(to_string(f, 0.0, Minus, 1), \"0.0\");\n    assert_eq!(to_string(f, 0.0, MinusPlus, 1), \"+0.0\");\n    assert_eq!(to_string(f, -0.0, Minus, 8), \"-0.00000000\");\n    assert_eq!(to_string(f, -0.0, MinusPlus, 8), \"-0.00000000\");\n\n    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0), \"inf\");\n    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 1), \"inf\");\n    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 64), \"+inf\");\n    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0), \"NaN\");\n    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 1), \"NaN\");\n    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 64), \"NaN\");\n    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0), \"-inf\");\n    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 1), \"-inf\");\n    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 64), \"-inf\");\n\n    assert_eq!(to_string(f, 3.14, Minus, 0), \"3\");\n    assert_eq!(to_string(f, 3.14, Minus, 0), \"3\");\n    assert_eq!(to_string(f, 3.14, MinusPlus, 0), \"+3\");\n    assert_eq!(to_string(f, -3.14, Minus, 0), \"-3\");\n    assert_eq!(to_string(f, -3.14, Minus, 0), \"-3\");\n    assert_eq!(to_string(f, -3.14, MinusPlus, 0), \"-3\");\n    assert_eq!(to_string(f, 3.14, Minus, 1), \"3.1\");\n    assert_eq!(to_string(f, 3.14, Minus, 2), \"3.14\");\n    assert_eq!(to_string(f, 3.14, MinusPlus, 4), \"+3.1400\");\n    assert_eq!(to_string(f, -3.14, Minus, 8), \"-3.14000000\");\n    assert_eq!(to_string(f, -3.14, Minus, 8), \"-3.14000000\");\n    assert_eq!(to_string(f, -3.14, MinusPlus, 8), \"-3.14000000\");\n\n    assert_eq!(to_string(f, 0.195, Minus, 0), \"0\");\n    assert_eq!(to_string(f, 0.195, MinusPlus, 0), \"+0\");\n    assert_eq!(to_string(f, -0.195, Minus, 0), \"-0\");\n    assert_eq!(to_string(f, -0.195, Minus, 0), \"-0\");\n    assert_eq!(to_string(f, -0.195, MinusPlus, 0), \"-0\");\n    assert_eq!(to_string(f, 0.195, Minus, 1), \"0.2\");\n    assert_eq!(to_string(f, 0.195, Minus, 2), \"0.20\");\n    assert_eq!(to_string(f, 0.195, MinusPlus, 4), \"+0.1950\");\n    assert_eq!(to_string(f, -0.195, Minus, 5), \"-0.19500\");\n    assert_eq!(to_string(f, -0.195, Minus, 6), \"-0.195000\");\n    assert_eq!(to_string(f, -0.195, MinusPlus, 8), \"-0.19500000\");\n\n    assert_eq!(to_string(f, 999.5, Minus, 0), \"1000\");\n    assert_eq!(to_string(f, 999.5, Minus, 1), \"999.5\");\n    assert_eq!(to_string(f, 999.5, Minus, 2), \"999.50\");\n    assert_eq!(to_string(f, 999.5, Minus, 3), \"999.500\");\n    assert_eq!(to_string(f, 999.5, Minus, 30), \"999.500000000000000000000000000000\");\n\n    assert_eq!(to_string(f, 0.5, Minus, 0), \"1\");\n    assert_eq!(to_string(f, 0.5, Minus, 1), \"0.5\");\n    assert_eq!(to_string(f, 0.5, Minus, 2), \"0.50\");\n    assert_eq!(to_string(f, 0.5, Minus, 3), \"0.500\");\n\n    assert_eq!(to_string(f, 0.95, Minus, 0), \"1\");\n    assert_eq!(to_string(f, 0.95, Minus, 1), \"0.9\"); // because it really is less than 0.95\n    assert_eq!(to_string(f, 0.95, Minus, 2), \"0.95\");\n    assert_eq!(to_string(f, 0.95, Minus, 3), \"0.950\");\n    assert_eq!(to_string(f, 0.95, Minus, 10), \"0.9500000000\");\n    assert_eq!(to_string(f, 0.95, Minus, 30), \"0.949999999999999955591079014994\");\n\n    assert_eq!(to_string(f, 0.095, Minus, 0), \"0\");\n    assert_eq!(to_string(f, 0.095, Minus, 1), \"0.1\");\n    assert_eq!(to_string(f, 0.095, Minus, 2), \"0.10\");\n    assert_eq!(to_string(f, 0.095, Minus, 3), \"0.095\");\n    assert_eq!(to_string(f, 0.095, Minus, 4), \"0.0950\");\n    assert_eq!(to_string(f, 0.095, Minus, 10), \"0.0950000000\");\n    assert_eq!(to_string(f, 0.095, Minus, 30), \"0.095000000000000001110223024625\");\n\n    assert_eq!(to_string(f, 0.0095, Minus, 0), \"0\");\n    assert_eq!(to_string(f, 0.0095, Minus, 1), \"0.0\");\n    assert_eq!(to_string(f, 0.0095, Minus, 2), \"0.01\");\n    assert_eq!(to_string(f, 0.0095, Minus, 3), \"0.009\"); // really is less than 0.0095\n    assert_eq!(to_string(f, 0.0095, Minus, 4), \"0.0095\");\n    assert_eq!(to_string(f, 0.0095, Minus, 5), \"0.00950\");\n    assert_eq!(to_string(f, 0.0095, Minus, 10), \"0.0095000000\");\n    assert_eq!(to_string(f, 0.0095, Minus, 30), \"0.009499999999999999764077607267\");\n\n    assert_eq!(to_string(f, 7.5e-11, Minus, 0), \"0\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, 3), \"0.000\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, 10), \"0.0000000001\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, 11), \"0.00000000007\"); // ditto\n    assert_eq!(to_string(f, 7.5e-11, Minus, 12), \"0.000000000075\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, 13), \"0.0000000000750\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, 20), \"0.00000000007500000000\");\n    assert_eq!(to_string(f, 7.5e-11, Minus, 30), \"0.000000000074999999999999999501\");\n\n    assert_eq!(to_string(f, 1.0e25, Minus, 0), \"10000000000000000905969664\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 1), \"10000000000000000905969664.0\");\n    assert_eq!(to_string(f, 1.0e25, Minus, 3), \"10000000000000000905969664.000\");\n\n    assert_eq!(to_string(f, 1.0e-6, Minus, 0), \"0\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 3), \"0.000\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 6), \"0.000001\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 9), \"0.000001000\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 12), \"0.000001000000\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 22), \"0.0000010000000000000000\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 23), \"0.00000099999999999999995\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 24), \"0.000000999999999999999955\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 25), \"0.0000009999999999999999547\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 35), \"0.00000099999999999999995474811182589\");\n    assert_eq!(to_string(f, 1.0e-6, Minus, 45), \"0.000000999999999999999954748111825886258685614\");\n    assert_eq!(\n        to_string(f, 1.0e-6, Minus, 55),\n        \"0.0000009999999999999999547481118258862586856139387236908\"\n    );\n    assert_eq!(\n        to_string(f, 1.0e-6, Minus, 65),\n        \"0.00000099999999999999995474811182588625868561393872369080781936646\"\n    );\n    assert_eq!(\n        to_string(f, 1.0e-6, Minus, 75),\n        \"0.000000999999999999999954748111825886258685613938723690807819366455078125000\"\n    );\n\n    assert_eq!(to_string(f, f32::MAX, Minus, 0), \"340282346638528859811704183484516925440\");\n    assert_eq!(to_string(f, f32::MAX, Minus, 1), \"340282346638528859811704183484516925440.0\");\n    assert_eq!(to_string(f, f32::MAX, Minus, 2), \"340282346638528859811704183484516925440.00\");\n\n    if cfg!(miri) {\n        // Miri is too slow\n        return;\n    }\n\n    let minf32 = ldexp_f32(1.0, -149);\n    assert_eq!(to_string(f, minf32, Minus, 0), \"0\");\n    assert_eq!(to_string(f, minf32, Minus, 1), \"0.0\");\n    assert_eq!(to_string(f, minf32, Minus, 2), \"0.00\");\n    assert_eq!(to_string(f, minf32, Minus, 4), \"0.0000\");\n    assert_eq!(to_string(f, minf32, Minus, 8), \"0.00000000\");\n    assert_eq!(to_string(f, minf32, Minus, 16), \"0.0000000000000000\");\n    assert_eq!(to_string(f, minf32, Minus, 32), \"0.00000000000000000000000000000000\");\n    assert_eq!(\n        to_string(f, minf32, Minus, 64),\n        \"0.0000000000000000000000000000000000000000000014012984643248170709\"\n    );\n    assert_eq!(\n        to_string(f, minf32, Minus, 128),\n        \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n                  2372958328991613128026194187651577175706828388979108268586060149\"\n    );\n    assert_eq!(\n        to_string(f, minf32, Minus, 256),\n        \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n                  2372958328991613128026194187651577175706828388979108268586060148\\\n                  6638188362121582031250000000000000000000000000000000000000000000\\\n                  0000000000000000000000000000000000000000000000000000000000000000\"\n    );\n\n    assert_eq!(\n        to_string(f, f64::MAX, Minus, 0),\n        \"1797693134862315708145274237317043567980705675258449965989174768\\\n                0315726078002853876058955863276687817154045895351438246423432132\\\n                6889464182768467546703537516986049910576551282076245490090389328\\\n                9440758685084551339423045832369032229481658085593321233482747978\\\n                26204144723168738177180919299881250404026184124858368\"\n    );\n    assert_eq!(\n        to_string(f, f64::MAX, Minus, 10),\n        \"1797693134862315708145274237317043567980705675258449965989174768\\\n                0315726078002853876058955863276687817154045895351438246423432132\\\n                6889464182768467546703537516986049910576551282076245490090389328\\\n                9440758685084551339423045832369032229481658085593321233482747978\\\n                26204144723168738177180919299881250404026184124858368.0000000000\"\n    );\n\n    let minf64 = ldexp_f64(1.0, -1074);\n    assert_eq!(to_string(f, minf64, Minus, 0), \"0\");\n    assert_eq!(to_string(f, minf64, Minus, 1), \"0.0\");\n    assert_eq!(to_string(f, minf64, Minus, 10), \"0.0000000000\");\n    assert_eq!(\n        to_string(f, minf64, Minus, 100),\n        \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n                  000000000000000000000000000000000000\"\n    );\n    assert_eq!(\n        to_string(f, minf64, Minus, 1000),\n        \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n                  0000000000000000000000000000000000000000000000000000000000000000\\\n                  0000000000000000000000000000000000000000000000000000000000000000\\\n                  0000000000000000000000000000000000000000000000000000000000000000\\\n                  0000000000000000000000000000000000000000000000000000000000000000\\\n                  0004940656458412465441765687928682213723650598026143247644255856\\\n                  8250067550727020875186529983636163599237979656469544571773092665\\\n                  6710355939796398774796010781878126300713190311404527845817167848\\\n                  9821036887186360569987307230500063874091535649843873124733972731\\\n                  6961514003171538539807412623856559117102665855668676818703956031\\\n                  0624931945271591492455329305456544401127480129709999541931989409\\\n                  0804165633245247571478690147267801593552386115501348035264934720\\\n                  1937902681071074917033322268447533357208324319360923828934583680\\\n                  6010601150616980975307834227731832924790498252473077637592724787\\\n                  4656084778203734469699533647017972677717585125660551199131504891\\\n                  1014510378627381672509558373897335989937\"\n    );\n\n    // very large output\n    assert_eq!(to_string(f, 0.0, Minus, 80000), format!(\"0.{:0>80000}\", \"\"));\n    assert_eq!(to_string(f, 1.0e1, Minus, 80000), format!(\"10.{:0>80000}\", \"\"));\n    assert_eq!(to_string(f, 1.0e0, Minus, 80000), format!(\"1.{:0>80000}\", \"\"));\n    assert_eq!(\n        to_string(f, 1.0e-1, Minus, 80000),\n        format!(\"0.1000000000000000055511151231257827021181583404541015625{:0>79945}\", \"\")\n    );\n    assert_eq!(\n        to_string(f, 1.0e-20, Minus, 80000),\n        format!(\n            \"0.0000000000000000000099999999999999994515327145420957165172950370\\\n                          2787392447107715776066783064379706047475337982177734375{:0>79881}\",\n            \"\"\n        )\n    );\n}\n"],[2924,"uint_module!(u8, u8);\n"],[2925,"int_module!(i128, i128);\n"],[2926,"//! IEEE 754 floating point compliance tests\n//!\n//! To understand IEEE 754's requirements on a programming language, one must understand that the\n//! requirements of IEEE 754 rest on the total programming environment, and not entirely on any\n//! one component. That means the hardware, language, and even libraries are considered part of\n//! conforming floating point support in a programming environment.\n//!\n//! A programming language's duty, accordingly, is:\n//!   1. offer access to the hardware where the hardware offers support\n//!   2. provide operations that fulfill the remaining requirements of the standard\n//!   3. provide the ability to write additional software that can fulfill those requirements\n//!\n//! This may be fulfilled in any combination that the language sees fit. However, to claim that\n//! a language supports IEEE 754 is to suggest that it has fulfilled requirements 1 and 2, without\n//! deferring minimum requirements to libraries. This is because support for IEEE 754 is defined\n//! as complete support for at least one specified floating point type as an \"arithmetic\" and\n//! \"interchange\" format, plus specified type conversions to \"external character sequences\" and\n//! integer types.\n//!\n//! For our purposes,\n//! \"interchange format\"          => f32, f64\n//! \"arithmetic format\"           => f32, f64, and any \"soft floats\"\n//! \"external character sequence\" => str from any float\n//! \"integer format\"              => {i,u}{8,16,32,64,128}\n//!\n//! None of these tests are against Rust's own implementation. They are only tests against the\n//! standard. That is why they accept wildly diverse inputs or may seem to duplicate other tests.\n//! Please consider this carefully when adding, removing, or reorganizing these tests. They are\n//! here so that it is clear what tests are required by the standard and what can be changed.\nuse ::core::str::FromStr;\n\n// IEEE 754 for many tests is applied to specific bit patterns.\n// These generally are not applicable to NaN, however.\nmacro_rules! assert_biteq {\n    ($lhs:expr, $rhs:expr) => {\n        assert_eq!($lhs.to_bits(), $rhs.to_bits())\n    };\n}\n\n// ToString uses the default fmt::Display impl without special concerns, and bypasses other parts\n// of the formatting infrastructure, which makes it ideal for testing here.\n#[allow(unused_macros)]\nmacro_rules! roundtrip {\n    ($f:expr => $t:ty) => {\n        ($f).to_string().parse::<$t>().unwrap()\n    };\n}\n\nmacro_rules! assert_floats_roundtrip {\n    ($f:ident) => {\n        assert_biteq!(f32::$f, roundtrip!(f32::$f => f32));\n        assert_biteq!(f64::$f, roundtrip!(f64::$f => f64));\n    };\n    ($f:expr) => {\n        assert_biteq!($f as f32, roundtrip!($f => f32));\n        assert_biteq!($f as f64, roundtrip!($f => f64));\n    }\n}\n\nmacro_rules! assert_floats_bitne {\n    ($lhs:ident, $rhs:ident) => {\n        assert_ne!(f32::$lhs.to_bits(), f32::$rhs.to_bits());\n        assert_ne!(f64::$lhs.to_bits(), f64::$rhs.to_bits());\n    };\n    ($lhs:expr, $rhs:expr) => {\n        assert_ne!(f32::to_bits($lhs), f32::to_bits($rhs));\n        assert_ne!(f64::to_bits($lhs), f64::to_bits($rhs));\n    };\n}\n\n// We must preserve signs on all numbers. That includes zero.\n// -0 and 0 are == normally, so test bit equality.\n#[test]\nfn preserve_signed_zero() {\n    assert_floats_roundtrip!(-0.0);\n    assert_floats_roundtrip!(0.0);\n    assert_floats_bitne!(0.0, -0.0);\n}\n\n#[test]\nfn preserve_signed_infinity() {\n    assert_floats_roundtrip!(INFINITY);\n    assert_floats_roundtrip!(NEG_INFINITY);\n    assert_floats_bitne!(INFINITY, NEG_INFINITY);\n}\n\n#[test]\nfn infinity_to_str() {\n    assert!(match f32::INFINITY.to_string().to_lowercase().as_str() {\n        \"+infinity\" | \"infinity\" => true,\n        \"+inf\" | \"inf\" => true,\n        _ => false,\n    });\n    assert!(\n        match f64::INFINITY.to_string().to_lowercase().as_str() {\n            \"+infinity\" | \"infinity\" => true,\n            \"+inf\" | \"inf\" => true,\n            _ => false,\n        },\n        \"Infinity must write to a string as some casing of inf or infinity, with an optional +.\"\n    );\n}\n\n#[test]\nfn neg_infinity_to_str() {\n    assert!(match f32::NEG_INFINITY.to_string().to_lowercase().as_str() {\n        \"-infinity\" | \"-inf\" => true,\n        _ => false,\n    });\n    assert!(\n        match f64::NEG_INFINITY.to_string().to_lowercase().as_str() {\n            \"-infinity\" | \"-inf\" => true,\n            _ => false,\n        },\n        \"Negative Infinity must write to a string as some casing of -inf or -infinity\"\n    )\n}\n\n#[test]\nfn nan_to_str() {\n    assert!(\n        match f32::NAN.to_string().to_lowercase().as_str() {\n            \"nan\" | \"+nan\" | \"-nan\" => true,\n            _ => false,\n        },\n        \"NaNs must write to a string as some casing of nan.\"\n    )\n}\n\n// \"+\"?(\"inf\"|\"infinity\") in any case => Infinity\n#[test]\nfn infinity_from_str() {\n    assert_biteq!(f32::INFINITY, f32::from_str(\"infinity\").unwrap());\n    assert_biteq!(f32::INFINITY, f32::from_str(\"inf\").unwrap());\n    assert_biteq!(f32::INFINITY, f32::from_str(\"+infinity\").unwrap());\n    assert_biteq!(f32::INFINITY, f32::from_str(\"+inf\").unwrap());\n    // yes! this means you are weLcOmE tO mY iNfInItElY tWiStEd MiNd\n    assert_biteq!(f32::INFINITY, f32::from_str(\"+iNfInItY\").unwrap());\n}\n\n// \"-inf\"|\"-infinity\" in any case => Negative Infinity\n#[test]\nfn neg_infinity_from_str() {\n    assert_biteq!(f32::NEG_INFINITY, f32::from_str(\"-infinity\").unwrap());\n    assert_biteq!(f32::NEG_INFINITY, f32::from_str(\"-inf\").unwrap());\n    assert_biteq!(f32::NEG_INFINITY, f32::from_str(\"-INF\").unwrap());\n    assert_biteq!(f32::NEG_INFINITY, f32::from_str(\"-INFinity\").unwrap());\n}\n\n// (\"+\"|\"-\"\")?\"s\"?\"nan\" in any case => qNaN\n#[test]\nfn qnan_from_str() {\n    assert!(\"nan\".parse::<f32>().unwrap().is_nan());\n    assert!(\"-nan\".parse::<f32>().unwrap().is_nan());\n    assert!(\"+nan\".parse::<f32>().unwrap().is_nan());\n    assert!(\"+NAN\".parse::<f32>().unwrap().is_nan());\n    assert!(\"-NaN\".parse::<f32>().unwrap().is_nan());\n}\n"],[2927,"uint_module!(u16, u16);\n"],[2928,"#![allow(overflowing_literals)]\n\nmod parse;\nmod rawfp;\n\n// Take a float literal, turn it into a string in various ways (that are all trusted\n// to be correct) and see if those strings are parsed back to the value of the literal.\n// Requires a *polymorphic literal*, i.e., one that can serve as f64 as well as f32.\nmacro_rules! test_literal {\n    ($x: expr) => {{\n        let x32: f32 = $x;\n        let x64: f64 = $x;\n        let inputs = &[stringify!($x).into(), format!(\"{:?}\", x64), format!(\"{:e}\", x64)];\n        for input in inputs {\n            assert_eq!(input.parse(), Ok(x64));\n            assert_eq!(input.parse(), Ok(x32));\n            let neg_input = &format!(\"-{}\", input);\n            assert_eq!(neg_input.parse(), Ok(-x64));\n            assert_eq!(neg_input.parse(), Ok(-x32));\n        }\n    }};\n}\n\n#[test]\nfn ordinary() {\n    test_literal!(1.0);\n    test_literal!(3e-5);\n    test_literal!(0.1);\n    test_literal!(12345.);\n    test_literal!(0.9999999);\n\n    if cfg!(miri) {\n        // Miri is too slow\n        return;\n    }\n\n    test_literal!(2.2250738585072014e-308);\n}\n\n#[test]\nfn special_code_paths() {\n    test_literal!(36893488147419103229.0); // 2^65 - 3, triggers half-to-even with even significand\n    test_literal!(101e-33); // Triggers the tricky underflow case in AlgorithmM (for f32)\n    test_literal!(1e23); // Triggers AlgorithmR\n    test_literal!(2075e23); // Triggers another path through AlgorithmR\n    test_literal!(8713e-23); // ... and yet another.\n}\n\n#[test]\nfn large() {\n    test_literal!(1e300);\n    test_literal!(123456789.34567e250);\n    test_literal!(943794359898089732078308743689303290943794359843568973207830874368930329.);\n}\n\n#[test]\n#[cfg_attr(miri, ignore)] // Miri is too slow\nfn subnormals() {\n    test_literal!(5e-324);\n    test_literal!(91e-324);\n    test_literal!(1e-322);\n    test_literal!(13245643e-320);\n    test_literal!(2.22507385851e-308);\n    test_literal!(2.1e-308);\n    test_literal!(4.9406564584124654e-324);\n}\n\n#[test]\n#[cfg_attr(miri, ignore)] // Miri is too slow\nfn infinity() {\n    test_literal!(1e400);\n    test_literal!(1e309);\n    test_literal!(2e308);\n    test_literal!(1.7976931348624e308);\n}\n\n#[test]\nfn zero() {\n    test_literal!(0.0);\n    test_literal!(1e-325);\n\n    if cfg!(miri) {\n        // Miri is too slow\n        return;\n    }\n\n    test_literal!(1e-326);\n    test_literal!(1e-500);\n}\n\n#[test]\nfn fast_path_correct() {\n    // This number triggers the fast path and is handled incorrectly when compiling on\n    // x86 without SSE2 (i.e., using the x87 FPU stack).\n    test_literal!(1.448997445238699);\n}\n\n#[test]\nfn lonely_dot() {\n    assert!(\".\".parse::<f32>().is_err());\n    assert!(\".\".parse::<f64>().is_err());\n}\n\n#[test]\nfn exponentiated_dot() {\n    assert!(\".e0\".parse::<f32>().is_err());\n    assert!(\".e0\".parse::<f64>().is_err());\n}\n\n#[test]\nfn lonely_sign() {\n    assert!(\"+\".parse::<f32>().is_err());\n    assert!(\"-\".parse::<f64>().is_err());\n}\n\n#[test]\nfn whitespace() {\n    assert!(\" 1.0\".parse::<f32>().is_err());\n    assert!(\"1.0 \".parse::<f64>().is_err());\n}\n\n#[test]\nfn nan() {\n    assert!(\"NaN\".parse::<f32>().unwrap().is_nan());\n    assert!(\"NaN\".parse::<f64>().unwrap().is_nan());\n}\n\n#[test]\nfn inf() {\n    assert_eq!(\"inf\".parse(), Ok(f64::INFINITY));\n    assert_eq!(\"-inf\".parse(), Ok(f64::NEG_INFINITY));\n    assert_eq!(\"inf\".parse(), Ok(f32::INFINITY));\n    assert_eq!(\"-inf\".parse(), Ok(f32::NEG_INFINITY));\n}\n\n#[test]\nfn massive_exponent() {\n    let max = i64::MAX;\n    assert_eq!(format!(\"1e{}000\", max).parse(), Ok(f64::INFINITY));\n    assert_eq!(format!(\"1e-{}000\", max).parse(), Ok(0.0));\n    assert_eq!(format!(\"1e{}000\", max).parse(), Ok(f64::INFINITY));\n}\n\n#[test]\nfn borderline_overflow() {\n    let mut s = \"0.\".to_string();\n    for _ in 0..375 {\n        s.push('3');\n    }\n    // At the time of this writing, this returns Err(..), but this is a bug that should be fixed.\n    // It makes no sense to enshrine that in a test, the important part is that it doesn't panic.\n    let _ = s.parse::<f64>();\n}\n"],[2929,"use core::num::dec2flt::parse::ParseResult::{Invalid, Valid};\nuse core::num::dec2flt::parse::{parse_decimal, Decimal};\n\n#[test]\nfn missing_pieces() {\n    let permutations = &[\".e\", \"1e\", \"e4\", \"e\", \".12e\", \"321.e\", \"32.12e+\", \"12.32e-\"];\n    for &s in permutations {\n        assert_eq!(parse_decimal(s), Invalid);\n    }\n}\n\n#[test]\nfn invalid_chars() {\n    let invalid = \"r,?<j\";\n    let valid_strings = &[\"123\", \"666.\", \".1\", \"5e1\", \"7e-3\", \"0.0e+1\"];\n    for c in invalid.chars() {\n        for s in valid_strings {\n            for i in 0..s.len() {\n                let mut input = String::new();\n                input.push_str(s);\n                input.insert(i, c);\n                assert!(parse_decimal(&input) == Invalid, \"did not reject invalid {:?}\", input);\n            }\n        }\n    }\n}\n\n#[test]\nfn valid() {\n    assert_eq!(parse_decimal(\"123.456e789\"), Valid(Decimal::new(b\"123\", b\"456\", 789)));\n    assert_eq!(parse_decimal(\"123.456e+789\"), Valid(Decimal::new(b\"123\", b\"456\", 789)));\n    assert_eq!(parse_decimal(\"123.456e-789\"), Valid(Decimal::new(b\"123\", b\"456\", -789)));\n    assert_eq!(parse_decimal(\".050\"), Valid(Decimal::new(b\"\", b\"050\", 0)));\n    assert_eq!(parse_decimal(\"999\"), Valid(Decimal::new(b\"999\", b\"\", 0)));\n    assert_eq!(parse_decimal(\"1.e300\"), Valid(Decimal::new(b\"1\", b\"\", 300)));\n    assert_eq!(parse_decimal(\".1e300\"), Valid(Decimal::new(b\"\", b\"1\", 300)));\n    assert_eq!(parse_decimal(\"101e-33\"), Valid(Decimal::new(b\"101\", b\"\", -33)));\n    let zeros = \"0\".repeat(25);\n    let s = format!(\"1.5e{}\", zeros);\n    assert_eq!(parse_decimal(&s), Valid(Decimal::new(b\"1\", b\"5\", 0)));\n}\n"],[2930,"use core::num::dec2flt::rawfp::RawFloat;\nuse core::num::dec2flt::rawfp::{fp_to_float, next_float, prev_float, round_normal};\nuse core::num::diy_float::Fp;\n\nfn integer_decode(f: f64) -> (u64, i16, i8) {\n    RawFloat::integer_decode(f)\n}\n\n#[test]\nfn fp_to_float_half_to_even() {\n    fn is_normalized(sig: u64) -> bool {\n        // intentionally written without {min,max}_sig() as a sanity check\n        sig >> 52 == 1 && sig >> 53 == 0\n    }\n\n    fn conv(sig: u64) -> u64 {\n        // The significands are perfectly in range, so the exponent should not matter\n        let (m1, e1, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: 0 }));\n        assert_eq!(e1, 0 + 64 - 53);\n        let (m2, e2, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: 55 }));\n        assert_eq!(e2, 55 + 64 - 53);\n        assert_eq!(m2, m1);\n        let (m3, e3, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: -78 }));\n        assert_eq!(e3, -78 + 64 - 53);\n        assert_eq!(m3, m2);\n        m3\n    }\n\n    let odd = 0x1F_EDCB_A012_345F;\n    let even = odd - 1;\n    assert!(is_normalized(odd));\n    assert!(is_normalized(even));\n    assert_eq!(conv(odd << 11), odd);\n    assert_eq!(conv(even << 11), even);\n    assert_eq!(conv(odd << 11 | 1 << 10), odd + 1);\n    assert_eq!(conv(even << 11 | 1 << 10), even);\n    assert_eq!(conv(even << 11 | 1 << 10 | 1), even + 1);\n    assert_eq!(conv(odd << 11 | 1 << 9), odd);\n    assert_eq!(conv(even << 11 | 1 << 9), even);\n    assert_eq!(conv(odd << 11 | 0x7FF), odd + 1);\n    assert_eq!(conv(even << 11 | 0x7FF), even + 1);\n    assert_eq!(conv(odd << 11 | 0x3FF), odd);\n    assert_eq!(conv(even << 11 | 0x3FF), even);\n}\n\n#[test]\nfn integers_to_f64() {\n    assert_eq!(fp_to_float::<f64>(Fp { f: 1, e: 0 }), 1.0);\n    assert_eq!(fp_to_float::<f64>(Fp { f: 42, e: 7 }), (42 << 7) as f64);\n    assert_eq!(fp_to_float::<f64>(Fp { f: 1 << 20, e: 30 }), (1u64 << 50) as f64);\n    assert_eq!(fp_to_float::<f64>(Fp { f: 4, e: -3 }), 0.5);\n}\n\nconst SOME_FLOATS: [f64; 9] = [\n    0.1f64,\n    33.568,\n    42.1e-5,\n    777.0e9,\n    1.1111,\n    0.347997,\n    9843579834.35892,\n    12456.0e-150,\n    54389573.0e-150,\n];\n\n#[test]\nfn human_f64_roundtrip() {\n    for &x in &SOME_FLOATS {\n        let (f, e, _) = integer_decode(x);\n        let fp = Fp { f: f, e: e };\n        assert_eq!(fp_to_float::<f64>(fp), x);\n    }\n}\n\n#[test]\nfn rounding_overflow() {\n    let x = Fp { f: 0xFF_FF_FF_FF_FF_FF_FF_00u64, e: 42 };\n    let rounded = round_normal::<f64>(x);\n    let adjusted_k = x.e + 64 - 53;\n    assert_eq!(rounded.sig, 1 << 52);\n    assert_eq!(rounded.k, adjusted_k + 1);\n}\n\n#[test]\nfn prev_float_monotonic() {\n    let mut x = 1.0;\n    for _ in 0..100 {\n        let x1 = prev_float(x);\n        assert!(x1 < x);\n        assert!(x - x1 < 1e-15);\n        x = x1;\n    }\n}\n\nconst MIN_SUBNORMAL: f64 = 5e-324;\n\n#[test]\nfn next_float_zero() {\n    let tiny = next_float(0.0);\n    assert_eq!(tiny, MIN_SUBNORMAL);\n    assert!(tiny != 0.0);\n}\n\n#[test]\nfn next_float_subnormal() {\n    let second = next_float(MIN_SUBNORMAL);\n    // For subnormals, MIN_SUBNORMAL is the ULP\n    assert!(second != MIN_SUBNORMAL);\n    assert!(second > 0.0);\n    assert_eq!(second - MIN_SUBNORMAL, MIN_SUBNORMAL);\n}\n\n#[test]\nfn next_float_inf() {\n    assert_eq!(next_float(f64::MAX), f64::INFINITY);\n    assert_eq!(next_float(f64::INFINITY), f64::INFINITY);\n}\n\n#[test]\nfn next_prev_identity() {\n    for &x in &SOME_FLOATS {\n        assert_eq!(prev_float(next_float(x)), x);\n        assert_eq!(prev_float(prev_float(next_float(next_float(x)))), x);\n        assert_eq!(next_float(prev_float(x)), x);\n        assert_eq!(next_float(next_float(prev_float(prev_float(x)))), x);\n    }\n}\n\n#[test]\nfn next_float_monotonic() {\n    let mut x = 0.49999999999999;\n    assert!(x < 0.5);\n    for _ in 0..200 {\n        let x1 = next_float(x);\n        assert!(x1 > x);\n        assert!(x1 - x < 1e-15, \"next_float_monotonic: delta = {:?}\", x1 - x);\n        x = x1;\n    }\n    assert!(x > 0.5);\n}\n\n#[test]\nfn test_f32_integer_decode() {\n    assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n    assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n    assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n    assert_eq!(0f32.integer_decode(), (0, -150, 1));\n    assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n    assert_eq!(f32::INFINITY.integer_decode(), (8388608, 105, 1));\n    assert_eq!(f32::NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n\n    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n    // It can vary between runtime operations and LLVM folding.\n    let (nan_m, nan_e, _nan_s) = f32::NAN.integer_decode();\n    assert_eq!((nan_m, nan_e), (12582912, 105));\n}\n\n#[test]\nfn test_f64_integer_decode() {\n    assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n    assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n    assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n    assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n    assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n    assert_eq!(f64::INFINITY.integer_decode(), (4503599627370496, 972, 1));\n    assert_eq!(f64::NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n\n    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n    // It can vary between runtime operations and LLVM folding.\n    let (nan_m, nan_e, _nan_s) = f64::NAN.integer_decode();\n    assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n}\n"],[2931,"use core::cmp::PartialEq;\nuse core::convert::{TryFrom, TryInto};\nuse core::fmt::Debug;\nuse core::marker::Copy;\nuse core::num::{IntErrorKind, ParseIntError, TryFromIntError};\nuse core::ops::{Add, Div, Mul, Rem, Sub};\nuse core::option::Option;\nuse core::option::Option::None;\nuse core::str::FromStr;\n\n#[macro_use]\nmod int_macros;\n\nmod i128;\nmod i16;\nmod i32;\nmod i64;\nmod i8;\n\n#[macro_use]\nmod uint_macros;\n\nmod u128;\nmod u16;\nmod u32;\nmod u64;\nmod u8;\n\nmod bignum;\nmod dec2flt;\nmod flt2dec;\nmod ops;\nmod wrapping;\n\nmod ieee754;\nmod nan;\n\n/// Adds the attribute to all items in the block.\nmacro_rules! cfg_block {\n    ($(#[$attr:meta]{$($it:item)*})*) => {$($(\n        #[$attr]\n        $it\n    )*)*}\n}\n\n/// Groups items that assume the pointer width is either 16/32/64, and has to be altered if\n/// support for larger/smaller pointer widths are added in the future.\nmacro_rules! assume_usize_width {\n    {$($it:item)*} => {#[cfg(not(any(\n        target_pointer_width = \"16\", target_pointer_width = \"32\", target_pointer_width = \"64\")))]\n           compile_error!(\"The current tests of try_from on usize/isize assume that \\\n                           the pointer width is either 16, 32, or 64\");\n                    $($it)*\n    }\n}\n\n/// Helper function for testing numeric operations\npub fn test_num<T>(ten: T, two: T)\nwhere\n    T: PartialEq\n        + Add<Output = T>\n        + Sub<Output = T>\n        + Mul<Output = T>\n        + Div<Output = T>\n        + Rem<Output = T>\n        + Debug\n        + Copy,\n{\n    assert_eq!(ten.add(two), ten + two);\n    assert_eq!(ten.sub(two), ten - two);\n    assert_eq!(ten.mul(two), ten * two);\n    assert_eq!(ten.div(two), ten / two);\n    assert_eq!(ten.rem(two), ten % two);\n}\n\n/// Helper function for asserting number parsing returns a specific error\nfn test_parse<T>(num_str: &str, expected: Result<T, IntErrorKind>)\nwhere\n    T: FromStr<Err = ParseIntError>,\n    Result<T, IntErrorKind>: PartialEq + Debug,\n{\n    assert_eq!(num_str.parse::<T>().map_err(|e| e.kind().clone()), expected)\n}\n\n#[test]\nfn from_str_issue7588() {\n    let u: Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n    assert_eq!(u, None);\n    let s: Option<i16> = i16::from_str_radix(\"80000\", 10).ok();\n    assert_eq!(s, None);\n}\n\n#[test]\nfn test_int_from_str_overflow() {\n    test_parse::<i8>(\"127\", Ok(127));\n    test_parse::<i8>(\"128\", Err(IntErrorKind::PosOverflow));\n\n    test_parse::<i8>(\"-128\", Ok(-128));\n    test_parse::<i8>(\"-129\", Err(IntErrorKind::NegOverflow));\n\n    test_parse::<i16>(\"32767\", Ok(32_767));\n    test_parse::<i16>(\"32768\", Err(IntErrorKind::PosOverflow));\n\n    test_parse::<i16>(\"-32768\", Ok(-32_768));\n    test_parse::<i16>(\"-32769\", Err(IntErrorKind::NegOverflow));\n\n    test_parse::<i32>(\"2147483647\", Ok(2_147_483_647));\n    test_parse::<i32>(\"2147483648\", Err(IntErrorKind::PosOverflow));\n\n    test_parse::<i32>(\"-2147483648\", Ok(-2_147_483_648));\n    test_parse::<i32>(\"-2147483649\", Err(IntErrorKind::NegOverflow));\n\n    test_parse::<i64>(\"9223372036854775807\", Ok(9_223_372_036_854_775_807));\n    test_parse::<i64>(\"9223372036854775808\", Err(IntErrorKind::PosOverflow));\n\n    test_parse::<i64>(\"-9223372036854775808\", Ok(-9_223_372_036_854_775_808));\n    test_parse::<i64>(\"-9223372036854775809\", Err(IntErrorKind::NegOverflow));\n}\n\n#[test]\nfn test_leading_plus() {\n    test_parse::<u8>(\"+127\", Ok(127));\n    test_parse::<i64>(\"+9223372036854775807\", Ok(9223372036854775807));\n}\n\n#[test]\nfn test_invalid() {\n    test_parse::<i8>(\"--129\", Err(IntErrorKind::InvalidDigit));\n    test_parse::<i8>(\"++129\", Err(IntErrorKind::InvalidDigit));\n    test_parse::<u8>(\"Съешь\", Err(IntErrorKind::InvalidDigit));\n    test_parse::<u8>(\"123Hello\", Err(IntErrorKind::InvalidDigit));\n    test_parse::<i8>(\"--\", Err(IntErrorKind::InvalidDigit));\n    test_parse::<i8>(\"-\", Err(IntErrorKind::InvalidDigit));\n    test_parse::<i8>(\"+\", Err(IntErrorKind::InvalidDigit));\n    test_parse::<u8>(\"-1\", Err(IntErrorKind::InvalidDigit));\n}\n\n#[test]\nfn test_empty() {\n    test_parse::<u8>(\"\", Err(IntErrorKind::Empty));\n}\n\n#[test]\nfn test_infallible_try_from_int_error() {\n    let func = |x: i8| -> Result<i32, TryFromIntError> { Ok(x.try_into()?) };\n\n    assert!(func(0).is_ok());\n}\n\nmacro_rules! test_impl_from {\n    ($fn_name:ident, bool, $target: ty) => {\n        #[test]\n        fn $fn_name() {\n            let one: $target = 1;\n            let zero: $target = 0;\n            assert_eq!(one, <$target>::from(true));\n            assert_eq!(zero, <$target>::from(false));\n        }\n    };\n    ($fn_name: ident, $Small: ty, $Large: ty) => {\n        #[test]\n        fn $fn_name() {\n            let small_max = <$Small>::MAX;\n            let small_min = <$Small>::MIN;\n            let large_max: $Large = small_max.into();\n            let large_min: $Large = small_min.into();\n            assert_eq!(large_max as $Small, small_max);\n            assert_eq!(large_min as $Small, small_min);\n        }\n    };\n}\n\n// Unsigned -> Unsigned\ntest_impl_from! { test_u8u16, u8, u16 }\ntest_impl_from! { test_u8u32, u8, u32 }\ntest_impl_from! { test_u8u64, u8, u64 }\ntest_impl_from! { test_u8usize, u8, usize }\ntest_impl_from! { test_u16u32, u16, u32 }\ntest_impl_from! { test_u16u64, u16, u64 }\ntest_impl_from! { test_u32u64, u32, u64 }\n\n// Signed -> Signed\ntest_impl_from! { test_i8i16, i8, i16 }\ntest_impl_from! { test_i8i32, i8, i32 }\ntest_impl_from! { test_i8i64, i8, i64 }\ntest_impl_from! { test_i8isize, i8, isize }\ntest_impl_from! { test_i16i32, i16, i32 }\ntest_impl_from! { test_i16i64, i16, i64 }\ntest_impl_from! { test_i32i64, i32, i64 }\n\n// Unsigned -> Signed\ntest_impl_from! { test_u8i16, u8, i16 }\ntest_impl_from! { test_u8i32, u8, i32 }\ntest_impl_from! { test_u8i64, u8, i64 }\ntest_impl_from! { test_u16i32, u16, i32 }\ntest_impl_from! { test_u16i64, u16, i64 }\ntest_impl_from! { test_u32i64, u32, i64 }\n\n// Bool -> Integer\ntest_impl_from! { test_boolu8, bool, u8 }\ntest_impl_from! { test_boolu16, bool, u16 }\ntest_impl_from! { test_boolu32, bool, u32 }\ntest_impl_from! { test_boolu64, bool, u64 }\ntest_impl_from! { test_boolu128, bool, u128 }\ntest_impl_from! { test_booli8, bool, i8 }\ntest_impl_from! { test_booli16, bool, i16 }\ntest_impl_from! { test_booli32, bool, i32 }\ntest_impl_from! { test_booli64, bool, i64 }\ntest_impl_from! { test_booli128, bool, i128 }\n\n// Signed -> Float\ntest_impl_from! { test_i8f32, i8, f32 }\ntest_impl_from! { test_i8f64, i8, f64 }\ntest_impl_from! { test_i16f32, i16, f32 }\ntest_impl_from! { test_i16f64, i16, f64 }\ntest_impl_from! { test_i32f64, i32, f64 }\n\n// Unsigned -> Float\ntest_impl_from! { test_u8f32, u8, f32 }\ntest_impl_from! { test_u8f64, u8, f64 }\ntest_impl_from! { test_u16f32, u16, f32 }\ntest_impl_from! { test_u16f64, u16, f64 }\ntest_impl_from! { test_u32f64, u32, f64 }\n\n// Float -> Float\n#[test]\nfn test_f32f64() {\n    let max: f64 = f32::MAX.into();\n    assert_eq!(max as f32, f32::MAX);\n    assert!(max.is_normal());\n\n    let min: f64 = f32::MIN.into();\n    assert_eq!(min as f32, f32::MIN);\n    assert!(min.is_normal());\n\n    let min_positive: f64 = f32::MIN_POSITIVE.into();\n    assert_eq!(min_positive as f32, f32::MIN_POSITIVE);\n    assert!(min_positive.is_normal());\n\n    let epsilon: f64 = f32::EPSILON.into();\n    assert_eq!(epsilon as f32, f32::EPSILON);\n    assert!(epsilon.is_normal());\n\n    let zero: f64 = (0.0f32).into();\n    assert_eq!(zero as f32, 0.0f32);\n    assert!(zero.is_sign_positive());\n\n    let neg_zero: f64 = (-0.0f32).into();\n    assert_eq!(neg_zero as f32, -0.0f32);\n    assert!(neg_zero.is_sign_negative());\n\n    let infinity: f64 = f32::INFINITY.into();\n    assert_eq!(infinity as f32, f32::INFINITY);\n    assert!(infinity.is_infinite());\n    assert!(infinity.is_sign_positive());\n\n    let neg_infinity: f64 = f32::NEG_INFINITY.into();\n    assert_eq!(neg_infinity as f32, f32::NEG_INFINITY);\n    assert!(neg_infinity.is_infinite());\n    assert!(neg_infinity.is_sign_negative());\n\n    let nan: f64 = f32::NAN.into();\n    assert!(nan.is_nan());\n}\n\n/// Conversions where the full width of $source can be represented as $target\nmacro_rules! test_impl_try_from_always_ok {\n    ($fn_name:ident, $source:ty, $target: ty) => {\n        #[test]\n        fn $fn_name() {\n            let max = <$source>::MAX;\n            let min = <$source>::MIN;\n            let zero: $source = 0;\n            assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(), max as $target);\n            assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(), min as $target);\n            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(), zero as $target);\n        }\n    };\n}\n\ntest_impl_try_from_always_ok! { test_try_u8u8, u8, u8 }\ntest_impl_try_from_always_ok! { test_try_u8u16, u8, u16 }\ntest_impl_try_from_always_ok! { test_try_u8u32, u8, u32 }\ntest_impl_try_from_always_ok! { test_try_u8u64, u8, u64 }\ntest_impl_try_from_always_ok! { test_try_u8u128, u8, u128 }\ntest_impl_try_from_always_ok! { test_try_u8i16, u8, i16 }\ntest_impl_try_from_always_ok! { test_try_u8i32, u8, i32 }\ntest_impl_try_from_always_ok! { test_try_u8i64, u8, i64 }\ntest_impl_try_from_always_ok! { test_try_u8i128, u8, i128 }\n\ntest_impl_try_from_always_ok! { test_try_u16u16, u16, u16 }\ntest_impl_try_from_always_ok! { test_try_u16u32, u16, u32 }\ntest_impl_try_from_always_ok! { test_try_u16u64, u16, u64 }\ntest_impl_try_from_always_ok! { test_try_u16u128, u16, u128 }\ntest_impl_try_from_always_ok! { test_try_u16i32, u16, i32 }\ntest_impl_try_from_always_ok! { test_try_u16i64, u16, i64 }\ntest_impl_try_from_always_ok! { test_try_u16i128, u16, i128 }\n\ntest_impl_try_from_always_ok! { test_try_u32u32, u32, u32 }\ntest_impl_try_from_always_ok! { test_try_u32u64, u32, u64 }\ntest_impl_try_from_always_ok! { test_try_u32u128, u32, u128 }\ntest_impl_try_from_always_ok! { test_try_u32i64, u32, i64 }\ntest_impl_try_from_always_ok! { test_try_u32i128, u32, i128 }\n\ntest_impl_try_from_always_ok! { test_try_u64u64, u64, u64 }\ntest_impl_try_from_always_ok! { test_try_u64u128, u64, u128 }\ntest_impl_try_from_always_ok! { test_try_u64i128, u64, i128 }\n\ntest_impl_try_from_always_ok! { test_try_u128u128, u128, u128 }\n\ntest_impl_try_from_always_ok! { test_try_i8i8, i8, i8 }\ntest_impl_try_from_always_ok! { test_try_i8i16, i8, i16 }\ntest_impl_try_from_always_ok! { test_try_i8i32, i8, i32 }\ntest_impl_try_from_always_ok! { test_try_i8i64, i8, i64 }\ntest_impl_try_from_always_ok! { test_try_i8i128, i8, i128 }\n\ntest_impl_try_from_always_ok! { test_try_i16i16, i16, i16 }\ntest_impl_try_from_always_ok! { test_try_i16i32, i16, i32 }\ntest_impl_try_from_always_ok! { test_try_i16i64, i16, i64 }\ntest_impl_try_from_always_ok! { test_try_i16i128, i16, i128 }\n\ntest_impl_try_from_always_ok! { test_try_i32i32, i32, i32 }\ntest_impl_try_from_always_ok! { test_try_i32i64, i32, i64 }\ntest_impl_try_from_always_ok! { test_try_i32i128, i32, i128 }\n\ntest_impl_try_from_always_ok! { test_try_i64i64, i64, i64 }\ntest_impl_try_from_always_ok! { test_try_i64i128, i64, i128 }\n\ntest_impl_try_from_always_ok! { test_try_i128i128, i128, i128 }\n\ntest_impl_try_from_always_ok! { test_try_usizeusize, usize, usize }\ntest_impl_try_from_always_ok! { test_try_isizeisize, isize, isize }\n\nassume_usize_width! {\n    test_impl_try_from_always_ok! { test_try_u8usize, u8, usize }\n    test_impl_try_from_always_ok! { test_try_u8isize, u8, isize }\n    test_impl_try_from_always_ok! { test_try_i8isize, i8, isize }\n\n    test_impl_try_from_always_ok! { test_try_u16usize, u16, usize }\n    test_impl_try_from_always_ok! { test_try_i16isize, i16, isize }\n\n    test_impl_try_from_always_ok! { test_try_usizeu64, usize, u64 }\n    test_impl_try_from_always_ok! { test_try_usizeu128, usize, u128 }\n    test_impl_try_from_always_ok! { test_try_usizei128, usize, i128 }\n\n    test_impl_try_from_always_ok! { test_try_isizei64, isize, i64 }\n    test_impl_try_from_always_ok! { test_try_isizei128, isize, i128 }\n\n    cfg_block!(\n        #[cfg(target_pointer_width = \"16\")] {\n            test_impl_try_from_always_ok! { test_try_usizeu16, usize, u16 }\n            test_impl_try_from_always_ok! { test_try_isizei16, isize, i16 }\n            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n            test_impl_try_from_always_ok! { test_try_usizei32, usize, i32 }\n            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n        }\n\n        #[cfg(target_pointer_width = \"32\")] {\n            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n        }\n\n        #[cfg(target_pointer_width = \"64\")] {\n            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n            test_impl_try_from_always_ok! { test_try_u32isize, u32, isize }\n            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n            test_impl_try_from_always_ok! { test_try_u64usize, u64, usize }\n            test_impl_try_from_always_ok! { test_try_i64isize, i64, isize }\n        }\n    );\n}\n\n/// Conversions where max of $source can be represented as $target,\nmacro_rules! test_impl_try_from_signed_to_unsigned_upper_ok {\n    ($fn_name:ident, $source:ty, $target:ty) => {\n        #[test]\n        fn $fn_name() {\n            let max = <$source>::MAX;\n            let min = <$source>::MIN;\n            let zero: $source = 0;\n            let neg_one: $source = -1;\n            assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(), max as $target);\n            assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(), zero as $target);\n            assert!(<$target as TryFrom<$source>>::try_from(neg_one).is_err());\n        }\n    };\n}\n\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u8, i8, u8 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u16, i8, u16 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u32, i8, u32 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u64, i8, u64 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u128, i8, u128 }\n\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u16, i16, u16 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u32, i16, u32 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u64, i16, u64 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u128, i16, u128 }\n\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u32, i32, u32 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u64, i32, u64 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u128, i32, u128 }\n\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64u64, i64, u64 }\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64u128, i64, u128 }\n\ntest_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i128u128, i128, u128 }\n\nassume_usize_width! {\n    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8usize, i8, usize }\n    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16usize, i16, usize }\n\n    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu64, isize, u64 }\n    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu128, isize, u128 }\n    test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeusize, isize, usize }\n\n    cfg_block!(\n        #[cfg(target_pointer_width = \"16\")] {\n            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu16, isize, u16 }\n            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n        }\n\n        #[cfg(target_pointer_width = \"32\")] {\n            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n\n            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n        }\n\n        #[cfg(target_pointer_width = \"64\")] {\n            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64usize, i64, usize }\n        }\n    );\n}\n\n/// Conversions where max of $source can not be represented as $target,\n/// but min can.\nmacro_rules! test_impl_try_from_unsigned_to_signed_upper_err {\n    ($fn_name:ident, $source:ty, $target:ty) => {\n        #[test]\n        fn $fn_name() {\n            let max = <$source>::MAX;\n            let min = <$source>::MIN;\n            let zero: $source = 0;\n            assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n            assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(), min as $target);\n            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(), zero as $target);\n        }\n    };\n}\n\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u8i8, u8, i8 }\n\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16i8, u16, i8 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16i16, u16, i16 }\n\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i8, u32, i8 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i16, u32, i16 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i32, u32, i32 }\n\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i8, u64, i8 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i16, u64, i16 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i32, u64, i32 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i64, u64, i64 }\n\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i8, u128, i8 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i16, u128, i16 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i32, u128, i32 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i64, u128, i64 }\ntest_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i128, u128, i128 }\n\nassume_usize_width! {\n    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64isize, u64, isize }\n    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128isize, u128, isize }\n\n    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei8, usize, i8 }\n    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei16, usize, i16 }\n    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizeisize, usize, isize }\n\n    cfg_block!(\n        #[cfg(target_pointer_width = \"16\")] {\n            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16isize, u16, isize }\n            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n        }\n\n        #[cfg(target_pointer_width = \"32\")] {\n            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n        }\n\n        #[cfg(target_pointer_width = \"64\")] {\n            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei64, usize, i64 }\n        }\n    );\n}\n\n/// Conversions where min/max of $source can not be represented as $target.\nmacro_rules! test_impl_try_from_same_sign_err {\n    ($fn_name:ident, $source:ty, $target:ty) => {\n        #[test]\n        fn $fn_name() {\n            let max = <$source>::MAX;\n            let min = <$source>::MIN;\n            let zero: $source = 0;\n            let t_max = <$target>::MAX;\n            let t_min = <$target>::MIN;\n            assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n            if min != 0 {\n                assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n            }\n            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(), zero as $target);\n            assert_eq!(\n                <$target as TryFrom<$source>>::try_from(t_max as $source).unwrap(),\n                t_max as $target\n            );\n            assert_eq!(\n                <$target as TryFrom<$source>>::try_from(t_min as $source).unwrap(),\n                t_min as $target\n            );\n        }\n    };\n}\n\ntest_impl_try_from_same_sign_err! { test_try_u16u8, u16, u8 }\n\ntest_impl_try_from_same_sign_err! { test_try_u32u8, u32, u8 }\ntest_impl_try_from_same_sign_err! { test_try_u32u16, u32, u16 }\n\ntest_impl_try_from_same_sign_err! { test_try_u64u8, u64, u8 }\ntest_impl_try_from_same_sign_err! { test_try_u64u16, u64, u16 }\ntest_impl_try_from_same_sign_err! { test_try_u64u32, u64, u32 }\n\ntest_impl_try_from_same_sign_err! { test_try_u128u8, u128, u8 }\ntest_impl_try_from_same_sign_err! { test_try_u128u16, u128, u16 }\ntest_impl_try_from_same_sign_err! { test_try_u128u32, u128, u32 }\ntest_impl_try_from_same_sign_err! { test_try_u128u64, u128, u64 }\n\ntest_impl_try_from_same_sign_err! { test_try_i16i8, i16, i8 }\ntest_impl_try_from_same_sign_err! { test_try_isizei8, isize, i8 }\n\ntest_impl_try_from_same_sign_err! { test_try_i32i8, i32, i8 }\ntest_impl_try_from_same_sign_err! { test_try_i32i16, i32, i16 }\n\ntest_impl_try_from_same_sign_err! { test_try_i64i8, i64, i8 }\ntest_impl_try_from_same_sign_err! { test_try_i64i16, i64, i16 }\ntest_impl_try_from_same_sign_err! { test_try_i64i32, i64, i32 }\n\ntest_impl_try_from_same_sign_err! { test_try_i128i8, i128, i8 }\ntest_impl_try_from_same_sign_err! { test_try_i128i16, i128, i16 }\ntest_impl_try_from_same_sign_err! { test_try_i128i32, i128, i32 }\ntest_impl_try_from_same_sign_err! { test_try_i128i64, i128, i64 }\n\nassume_usize_width! {\n    test_impl_try_from_same_sign_err! { test_try_usizeu8, usize, u8 }\n    test_impl_try_from_same_sign_err! { test_try_u128usize, u128, usize }\n    test_impl_try_from_same_sign_err! { test_try_i128isize, i128, isize }\n\n    cfg_block!(\n        #[cfg(target_pointer_width = \"16\")] {\n            test_impl_try_from_same_sign_err! { test_try_u32usize, u32, usize }\n            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n\n            test_impl_try_from_same_sign_err! { test_try_i32isize, i32, isize }\n            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n        }\n\n        #[cfg(target_pointer_width = \"32\")] {\n            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n\n            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n        }\n\n        #[cfg(target_pointer_width = \"64\")] {\n            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n            test_impl_try_from_same_sign_err! { test_try_usizeu32, usize, u32 }\n\n            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n            test_impl_try_from_same_sign_err! { test_try_isizei32, isize, i32 }\n        }\n    );\n}\n\n/// Conversions where neither the min nor the max of $source can be represented by\n/// $target, but max/min of the target can be represented by the source.\nmacro_rules! test_impl_try_from_signed_to_unsigned_err {\n    ($fn_name:ident, $source:ty, $target:ty) => {\n        #[test]\n        fn $fn_name() {\n            let max = <$source>::MAX;\n            let min = <$source>::MIN;\n            let zero: $source = 0;\n            let t_max = <$target>::MAX;\n            let t_min = <$target>::MIN;\n            assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n            assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(), zero as $target);\n            assert_eq!(\n                <$target as TryFrom<$source>>::try_from(t_max as $source).unwrap(),\n                t_max as $target\n            );\n            assert_eq!(\n                <$target as TryFrom<$source>>::try_from(t_min as $source).unwrap(),\n                t_min as $target\n            );\n        }\n    };\n}\n\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i16u8, i16, u8 }\n\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i32u8, i32, u8 }\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i32u16, i32, u16 }\n\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i64u8, i64, u8 }\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i64u16, i64, u16 }\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i64u32, i64, u32 }\n\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i128u8, i128, u8 }\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i128u16, i128, u16 }\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i128u32, i128, u32 }\ntest_impl_try_from_signed_to_unsigned_err! { test_try_i128u64, i128, u64 }\n\nassume_usize_width! {\n    test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu8, isize, u8 }\n    test_impl_try_from_signed_to_unsigned_err! { test_try_i128usize, i128, usize }\n\n    cfg_block! {\n        #[cfg(target_pointer_width = \"16\")] {\n            test_impl_try_from_signed_to_unsigned_err! { test_try_i32usize, i32, usize }\n            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n        }\n        #[cfg(target_pointer_width = \"32\")] {\n            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n\n            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n        }\n        #[cfg(target_pointer_width = \"64\")] {\n            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu32, isize, u32 }\n        }\n    }\n}\n\nmacro_rules! test_float {\n    ($modname: ident, $fty: ty, $inf: expr, $neginf: expr, $nan: expr) => {\n        mod $modname {\n            #[test]\n            fn min() {\n                assert_eq!((0.0 as $fty).min(0.0), 0.0);\n                assert!((0.0 as $fty).min(0.0).is_sign_positive());\n                assert_eq!((-0.0 as $fty).min(-0.0), -0.0);\n                assert!((-0.0 as $fty).min(-0.0).is_sign_negative());\n                assert_eq!((9.0 as $fty).min(9.0), 9.0);\n                assert_eq!((-9.0 as $fty).min(0.0), -9.0);\n                assert_eq!((0.0 as $fty).min(9.0), 0.0);\n                assert!((0.0 as $fty).min(9.0).is_sign_positive());\n                assert_eq!((-0.0 as $fty).min(9.0), -0.0);\n                assert!((-0.0 as $fty).min(9.0).is_sign_negative());\n                assert_eq!((-0.0 as $fty).min(-9.0), -9.0);\n                assert_eq!(($inf as $fty).min(9.0), 9.0);\n                assert_eq!((9.0 as $fty).min($inf), 9.0);\n                assert_eq!(($inf as $fty).min(-9.0), -9.0);\n                assert_eq!((-9.0 as $fty).min($inf), -9.0);\n                assert_eq!(($neginf as $fty).min(9.0), $neginf);\n                assert_eq!((9.0 as $fty).min($neginf), $neginf);\n                assert_eq!(($neginf as $fty).min(-9.0), $neginf);\n                assert_eq!((-9.0 as $fty).min($neginf), $neginf);\n                assert_eq!(($nan as $fty).min(9.0), 9.0);\n                assert_eq!(($nan as $fty).min(-9.0), -9.0);\n                assert_eq!((9.0 as $fty).min($nan), 9.0);\n                assert_eq!((-9.0 as $fty).min($nan), -9.0);\n                assert!(($nan as $fty).min($nan).is_nan());\n            }\n            #[test]\n            fn max() {\n                assert_eq!((0.0 as $fty).max(0.0), 0.0);\n                assert!((0.0 as $fty).max(0.0).is_sign_positive());\n                assert_eq!((-0.0 as $fty).max(-0.0), -0.0);\n                assert!((-0.0 as $fty).max(-0.0).is_sign_negative());\n                assert_eq!((9.0 as $fty).max(9.0), 9.0);\n                assert_eq!((-9.0 as $fty).max(0.0), 0.0);\n                assert!((-9.0 as $fty).max(0.0).is_sign_positive());\n                assert_eq!((-9.0 as $fty).max(-0.0), -0.0);\n                assert!((-9.0 as $fty).max(-0.0).is_sign_negative());\n                assert_eq!((0.0 as $fty).max(9.0), 9.0);\n                assert_eq!((0.0 as $fty).max(-9.0), 0.0);\n                assert!((0.0 as $fty).max(-9.0).is_sign_positive());\n                assert_eq!((-0.0 as $fty).max(-9.0), -0.0);\n                assert!((-0.0 as $fty).max(-9.0).is_sign_negative());\n                assert_eq!(($inf as $fty).max(9.0), $inf);\n                assert_eq!((9.0 as $fty).max($inf), $inf);\n                assert_eq!(($inf as $fty).max(-9.0), $inf);\n                assert_eq!((-9.0 as $fty).max($inf), $inf);\n                assert_eq!(($neginf as $fty).max(9.0), 9.0);\n                assert_eq!((9.0 as $fty).max($neginf), 9.0);\n                assert_eq!(($neginf as $fty).max(-9.0), -9.0);\n                assert_eq!((-9.0 as $fty).max($neginf), -9.0);\n                assert_eq!(($nan as $fty).max(9.0), 9.0);\n                assert_eq!(($nan as $fty).max(-9.0), -9.0);\n                assert_eq!((9.0 as $fty).max($nan), 9.0);\n                assert_eq!((-9.0 as $fty).max($nan), -9.0);\n                assert!(($nan as $fty).max($nan).is_nan());\n            }\n            #[test]\n            fn rem_euclid() {\n                let a: $fty = 42.0;\n                assert!($inf.rem_euclid(a).is_nan());\n                assert_eq!(a.rem_euclid($inf), a);\n                assert!(a.rem_euclid($nan).is_nan());\n                assert!($inf.rem_euclid($inf).is_nan());\n                assert!($inf.rem_euclid($nan).is_nan());\n                assert!($nan.rem_euclid($inf).is_nan());\n            }\n            #[test]\n            fn div_euclid() {\n                let a: $fty = 42.0;\n                assert_eq!(a.div_euclid($inf), 0.0);\n                assert!(a.div_euclid($nan).is_nan());\n                assert!($inf.div_euclid($inf).is_nan());\n                assert!($inf.div_euclid($nan).is_nan());\n                assert!($nan.div_euclid($inf).is_nan());\n            }\n        }\n    };\n}\n\ntest_float!(f32, f32, f32::INFINITY, f32::NEG_INFINITY, f32::NAN);\ntest_float!(f64, f64, f64::INFINITY, f64::NEG_INFINITY, f64::NAN);\n"],[2932,"use core::ops::*;\n\n// For types L and R, checks that a trait implementation exists for\n//   * binary ops: L op R, L op &R, &L op R and &L op &R\n//   * assign ops: &mut L op R, &mut L op &R\nmacro_rules! impl_defined {\n    ($op:ident, $method:ident($lhs:literal, $rhs:literal), $result:literal, $lt:ty, $rt:ty) => {\n        let lhs = $lhs as $lt;\n        let rhs = $rhs as $rt;\n        assert_eq!($result as $lt, $op::$method(lhs, rhs));\n        assert_eq!($result as $lt, $op::$method(lhs, &rhs));\n        assert_eq!($result as $lt, $op::$method(&lhs, rhs));\n        assert_eq!($result as $lt, $op::$method(&lhs, &rhs));\n    };\n    ($op:ident, $method:ident(&mut $lhs:literal, $rhs:literal), $result:literal, $lt:ty, $rt:ty) => {\n        let rhs = $rhs as $rt;\n        let mut lhs = $lhs as $lt;\n        $op::$method(&mut lhs, rhs);\n        assert_eq!($result as $lt, lhs);\n\n        let mut lhs = $lhs as $lt;\n        $op::$method(&mut lhs, &rhs);\n        assert_eq!($result as $lt, lhs);\n    };\n}\n\n// For all specified types T, checks that a trait implementation exists for\n//   * binary ops: T op T, T op &T, &T op T and &T op &T\n//   * assign ops: &mut T op T, &mut T op &T\n//   * unary ops: op T and op &T\nmacro_rules! impls_defined {\n    ($op:ident, $method:ident($lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {$(\n        impl_defined!($op, $method($lhs, $rhs), $result, $t, $t);\n    )+};\n    ($op:ident, $method:ident(&mut $lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {$(\n        impl_defined!($op, $method(&mut $lhs, $rhs), $result, $t, $t);\n    )+};\n    ($op:ident, $method:ident($operand:literal), $result:literal, $($t:ty),+) => {$(\n        let operand = $operand as $t;\n        assert_eq!($result as $t, $op::$method(operand));\n        assert_eq!($result as $t, $op::$method(&operand));\n    )+};\n}\n\nmacro_rules! test_op {\n    ($fn_name:ident, $op:ident::$method:ident($lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {\n        #[test]\n        fn $fn_name() {\n            impls_defined!($op, $method($lhs, $rhs), $result, $($t),+);\n        }\n    };\n    ($fn_name:ident, $op:ident::$method:ident(&mut $lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {\n        #[test]\n        fn $fn_name() {\n            impls_defined!($op, $method(&mut $lhs, $rhs), $result, $($t),+);\n        }\n    };\n    ($fn_name:ident, $op:ident::$method:ident($lhs:literal), $result:literal, $($t:ty),+) => {\n        #[test]\n        fn $fn_name() {\n            impls_defined!($op, $method($lhs), $result, $($t),+);\n        }\n    };\n}\n\ntest_op!(test_neg_defined, Neg::neg(0), 0, i8, i16, i32, i64, f32, f64);\n#[cfg(not(target_os = \"emscripten\"))]\ntest_op!(test_neg_defined_128, Neg::neg(0), 0, i128);\n\ntest_op!(test_not_defined_bool, Not::not(true), false, bool);\n\nmacro_rules! test_arith_op {\n    ($fn_name:ident, $op:ident::$method:ident($lhs:literal, $rhs:literal)) => {\n        #[test]\n        fn $fn_name() {\n            impls_defined!(\n                $op,\n                $method($lhs, $rhs),\n                0,\n                i8,\n                i16,\n                i32,\n                i64,\n                isize,\n                u8,\n                u16,\n                u32,\n                u64,\n                usize,\n                f32,\n                f64\n            );\n            #[cfg(not(target_os = \"emscripten\"))]\n            impls_defined!($op, $method($lhs, $rhs), 0, i128, u128);\n        }\n    };\n    ($fn_name:ident, $op:ident::$method:ident(&mut $lhs:literal, $rhs:literal)) => {\n        #[test]\n        fn $fn_name() {\n            impls_defined!(\n                $op,\n                $method(&mut $lhs, $rhs),\n                0,\n                i8,\n                i16,\n                i32,\n                i64,\n                isize,\n                u8,\n                u16,\n                u32,\n                u64,\n                usize,\n                f32,\n                f64\n            );\n            #[cfg(not(target_os = \"emscripten\"))]\n            impls_defined!($op, $method(&mut $lhs, $rhs), 0, i128, u128);\n        }\n    };\n}\n\ntest_arith_op!(test_add_defined, Add::add(0, 0));\ntest_arith_op!(test_add_assign_defined, AddAssign::add_assign(&mut 0, 0));\ntest_arith_op!(test_sub_defined, Sub::sub(0, 0));\ntest_arith_op!(test_sub_assign_defined, SubAssign::sub_assign(&mut 0, 0));\ntest_arith_op!(test_mul_defined, Mul::mul(0, 0));\ntest_arith_op!(test_mul_assign_defined, MulAssign::mul_assign(&mut 0, 0));\ntest_arith_op!(test_div_defined, Div::div(0, 1));\ntest_arith_op!(test_div_assign_defined, DivAssign::div_assign(&mut 0, 1));\ntest_arith_op!(test_rem_defined, Rem::rem(0, 1));\ntest_arith_op!(test_rem_assign_defined, RemAssign::rem_assign(&mut 0, 1));\n\nmacro_rules! test_bitop {\n    ($test_name:ident, $op:ident::$method:ident) => {\n        #[test]\n        fn $test_name() {\n            impls_defined!(\n                $op,\n                $method(0, 0),\n                0,\n                i8,\n                i16,\n                i32,\n                i64,\n                isize,\n                u8,\n                u16,\n                u32,\n                u64,\n                usize\n            );\n            #[cfg(not(target_os = \"emscripten\"))]\n            impls_defined!($op, $method(0, 0), 0, i128, u128);\n            impls_defined!($op, $method(false, false), false, bool);\n        }\n    };\n}\nmacro_rules! test_bitop_assign {\n    ($test_name:ident, $op:ident::$method:ident) => {\n        #[test]\n        fn $test_name() {\n            impls_defined!(\n                $op,\n                $method(&mut 0, 0),\n                0,\n                i8,\n                i16,\n                i32,\n                i64,\n                isize,\n                u8,\n                u16,\n                u32,\n                u64,\n                usize\n            );\n            #[cfg(not(target_os = \"emscripten\"))]\n            impls_defined!($op, $method(&mut 0, 0), 0, i128, u128);\n            impls_defined!($op, $method(&mut false, false), false, bool);\n        }\n    };\n}\n\ntest_bitop!(test_bitand_defined, BitAnd::bitand);\ntest_bitop_assign!(test_bitand_assign_defined, BitAndAssign::bitand_assign);\ntest_bitop!(test_bitor_defined, BitOr::bitor);\ntest_bitop_assign!(test_bitor_assign_defined, BitOrAssign::bitor_assign);\ntest_bitop!(test_bitxor_defined, BitXor::bitxor);\ntest_bitop_assign!(test_bitxor_assign_defined, BitXorAssign::bitxor_assign);\n\nmacro_rules! test_shift_inner {\n    ($op:ident::$method:ident, $lt:ty, $($rt:ty),+) => {\n        $(impl_defined!($op, $method(0,0), 0, $lt, $rt);)+\n    };\n    ($op:ident::$method:ident, $lt:ty) => {\n        test_shift_inner!($op::$method, $lt, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n        #[cfg(not(target_os = \"emscripten\"))]\n        test_shift_inner!($op::$method, $lt, i128, u128);\n    };\n}\n\nmacro_rules! test_shift {\n    ($op:ident::$method:ident, $($lt:ty),+) => {\n        $(test_shift_inner!($op::$method, $lt);)+\n    };\n    ($test_name:ident, $op:ident::$method:ident) => {\n        #[test]\n        fn $test_name() {\n            test_shift!($op::$method, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n            #[cfg(not(target_os = \"emscripten\"))]\n            test_shift!($op::$method, i128, u128);\n        }\n    };\n}\n\nmacro_rules! test_shift_assign_inner {\n    ($op:ident::$method:ident, $lt:ty, $($rt:ty),+) => {\n        $(impl_defined!($op, $method(&mut 0,0), 0, $lt, $rt);)+\n    };\n    ($op:ident::$method:ident, $lt:ty) => {\n        test_shift_assign_inner!($op::$method, $lt, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n        #[cfg(not(target_os = \"emscripten\"))]\n        test_shift_assign_inner!($op::$method, $lt, i128, u128);\n    };\n}\n\nmacro_rules! test_shift_assign {\n    ($op:ident::$method:ident, $($lt:ty),+) => {\n        $(test_shift_assign_inner!($op::$method, $lt);)+\n    };\n    ($test_name:ident, $op:ident::$method:ident) => {\n        #[test]\n        fn $test_name() {\n            test_shift_assign!($op::$method, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n            #[cfg(not(target_os = \"emscripten\"))]\n            test_shift_assign!($op::$method, i128, u128);\n        }\n    };\n}\ntest_shift!(test_shl_defined, Shl::shl);\ntest_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\ntest_shift!(test_shr_defined, Shr::shr);\ntest_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n"],[2933,"uint_module!(u64, u64);\n"],[2934,"int_module!(i64, i64);\n"],[2935,"macro_rules! int_module {\n    ($T:ident, $T_i:ident) => {\n        #[cfg(test)]\n        mod tests {\n            use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n            use core::$T_i::*;\n\n            use crate::num;\n\n            #[test]\n            fn test_overflows() {\n                assert!(MAX > 0);\n                assert!(MIN <= 0);\n                assert_eq!(MIN + MAX + 1, 0);\n            }\n\n            #[test]\n            fn test_num() {\n                num::test_num(10 as $T, 2 as $T);\n            }\n\n            #[test]\n            fn test_rem_euclid() {\n                assert_eq!((-1 as $T).rem_euclid(MIN), MAX);\n            }\n\n            #[test]\n            pub fn test_abs() {\n                assert_eq!((1 as $T).abs(), 1 as $T);\n                assert_eq!((0 as $T).abs(), 0 as $T);\n                assert_eq!((-1 as $T).abs(), 1 as $T);\n            }\n\n            #[test]\n            fn test_signum() {\n                assert_eq!((1 as $T).signum(), 1 as $T);\n                assert_eq!((0 as $T).signum(), 0 as $T);\n                assert_eq!((-0 as $T).signum(), 0 as $T);\n                assert_eq!((-1 as $T).signum(), -1 as $T);\n            }\n\n            #[test]\n            fn test_is_positive() {\n                assert!((1 as $T).is_positive());\n                assert!(!(0 as $T).is_positive());\n                assert!(!(-0 as $T).is_positive());\n                assert!(!(-1 as $T).is_positive());\n            }\n\n            #[test]\n            fn test_is_negative() {\n                assert!(!(1 as $T).is_negative());\n                assert!(!(0 as $T).is_negative());\n                assert!(!(-0 as $T).is_negative());\n                assert!((-1 as $T).is_negative());\n            }\n\n            #[test]\n            fn test_bitwise_operators() {\n                assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(0b1010 as $T));\n                assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(0b1010 as $T));\n                assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(0b1010 as $T));\n                assert_eq!(0b1110 as $T, (0b0111 as $T).shl(1));\n                assert_eq!(0b0111 as $T, (0b1110 as $T).shr(1));\n                assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n            }\n\n            const A: $T = 0b0101100;\n            const B: $T = 0b0100001;\n            const C: $T = 0b1111001;\n\n            const _0: $T = 0;\n            const _1: $T = !0;\n\n            #[test]\n            fn test_count_ones() {\n                assert_eq!(A.count_ones(), 3);\n                assert_eq!(B.count_ones(), 2);\n                assert_eq!(C.count_ones(), 5);\n            }\n\n            #[test]\n            fn test_count_zeros() {\n                assert_eq!(A.count_zeros(), $T::BITS - 3);\n                assert_eq!(B.count_zeros(), $T::BITS - 2);\n                assert_eq!(C.count_zeros(), $T::BITS - 5);\n            }\n\n            #[test]\n            fn test_leading_trailing_ones() {\n                let a: $T = 0b0101_1111;\n                assert_eq!(a.trailing_ones(), 5);\n                assert_eq!((!a).leading_ones(), $T::BITS - 7);\n\n                assert_eq!(a.reverse_bits().leading_ones(), 5);\n\n                assert_eq!(_1.leading_ones(), $T::BITS);\n                assert_eq!(_1.trailing_ones(), $T::BITS);\n\n                assert_eq!((_1 << 1).trailing_ones(), 0);\n                assert_eq!(MAX.leading_ones(), 0);\n\n                assert_eq!((_1 << 1).leading_ones(), $T::BITS - 1);\n                assert_eq!(MAX.trailing_ones(), $T::BITS - 1);\n\n                assert_eq!(_0.leading_ones(), 0);\n                assert_eq!(_0.trailing_ones(), 0);\n\n                let x: $T = 0b0010_1100;\n                assert_eq!(x.leading_ones(), 0);\n                assert_eq!(x.trailing_ones(), 0);\n            }\n\n            #[test]\n            fn test_rotate() {\n                assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n                assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n                assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n\n                // Rotating these should make no difference\n                //\n                // We test using 124 bits because to ensure that overlong bit shifts do\n                // not cause undefined behaviour. See #10183.\n                assert_eq!(_0.rotate_left(124), _0);\n                assert_eq!(_1.rotate_left(124), _1);\n                assert_eq!(_0.rotate_right(124), _0);\n                assert_eq!(_1.rotate_right(124), _1);\n\n                // Rotating by 0 should have no effect\n                assert_eq!(A.rotate_left(0), A);\n                assert_eq!(B.rotate_left(0), B);\n                assert_eq!(C.rotate_left(0), C);\n                // Rotating by a multiple of word size should also have no effect\n                assert_eq!(A.rotate_left(128), A);\n                assert_eq!(B.rotate_left(128), B);\n                assert_eq!(C.rotate_left(128), C);\n            }\n\n            #[test]\n            fn test_swap_bytes() {\n                assert_eq!(A.swap_bytes().swap_bytes(), A);\n                assert_eq!(B.swap_bytes().swap_bytes(), B);\n                assert_eq!(C.swap_bytes().swap_bytes(), C);\n\n                // Swapping these should make no difference\n                assert_eq!(_0.swap_bytes(), _0);\n                assert_eq!(_1.swap_bytes(), _1);\n            }\n\n            #[test]\n            fn test_le() {\n                assert_eq!($T::from_le(A.to_le()), A);\n                assert_eq!($T::from_le(B.to_le()), B);\n                assert_eq!($T::from_le(C.to_le()), C);\n                assert_eq!($T::from_le(_0), _0);\n                assert_eq!($T::from_le(_1), _1);\n                assert_eq!(_0.to_le(), _0);\n                assert_eq!(_1.to_le(), _1);\n            }\n\n            #[test]\n            fn test_be() {\n                assert_eq!($T::from_be(A.to_be()), A);\n                assert_eq!($T::from_be(B.to_be()), B);\n                assert_eq!($T::from_be(C.to_be()), C);\n                assert_eq!($T::from_be(_0), _0);\n                assert_eq!($T::from_be(_1), _1);\n                assert_eq!(_0.to_be(), _0);\n                assert_eq!(_1.to_be(), _1);\n            }\n\n            #[test]\n            fn test_signed_checked_div() {\n                assert_eq!((10 as $T).checked_div(2), Some(5));\n                assert_eq!((5 as $T).checked_div(0), None);\n                assert_eq!(isize::MIN.checked_div(-1), None);\n            }\n\n            #[test]\n            fn test_saturating_abs() {\n                assert_eq!((0 as $T).saturating_abs(), 0);\n                assert_eq!((123 as $T).saturating_abs(), 123);\n                assert_eq!((-123 as $T).saturating_abs(), 123);\n                assert_eq!((MAX - 2).saturating_abs(), MAX - 2);\n                assert_eq!((MAX - 1).saturating_abs(), MAX - 1);\n                assert_eq!(MAX.saturating_abs(), MAX);\n                assert_eq!((MIN + 2).saturating_abs(), MAX - 1);\n                assert_eq!((MIN + 1).saturating_abs(), MAX);\n                assert_eq!(MIN.saturating_abs(), MAX);\n            }\n\n            #[test]\n            fn test_saturating_neg() {\n                assert_eq!((0 as $T).saturating_neg(), 0);\n                assert_eq!((123 as $T).saturating_neg(), -123);\n                assert_eq!((-123 as $T).saturating_neg(), 123);\n                assert_eq!((MAX - 2).saturating_neg(), MIN + 3);\n                assert_eq!((MAX - 1).saturating_neg(), MIN + 2);\n                assert_eq!(MAX.saturating_neg(), MIN + 1);\n                assert_eq!((MIN + 2).saturating_neg(), MAX - 1);\n                assert_eq!((MIN + 1).saturating_neg(), MAX);\n                assert_eq!(MIN.saturating_neg(), MAX);\n            }\n\n            #[test]\n            fn test_from_str() {\n                fn from_str<T: std::str::FromStr>(t: &str) -> Option<T> {\n                    std::str::FromStr::from_str(t).ok()\n                }\n                assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n                assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n                assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n                assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n                assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n\n                assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n                assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n                assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n                assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n                assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n\n                assert_eq!(from_str::<$T>(\"\"), None);\n                assert_eq!(from_str::<$T>(\" \"), None);\n                assert_eq!(from_str::<$T>(\"x\"), None);\n            }\n\n            #[test]\n            fn test_from_str_radix() {\n                assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n                assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n                assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n                assert_eq!(i32::from_str_radix(\"123\", 16), Ok(291 as i32));\n                assert_eq!(i32::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n                assert_eq!(i32::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n                assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n                assert_eq!($T::from_str_radix(\"Z\", 36), Ok(35 as $T));\n\n                assert_eq!($T::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n                assert_eq!($T::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n                assert_eq!($T::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n                assert_eq!(i32::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n                assert_eq!(i32::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n                assert_eq!(i32::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n                assert_eq!($T::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n                assert_eq!($T::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n\n                assert_eq!($T::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n                assert_eq!($T::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n            }\n\n            #[test]\n            fn test_pow() {\n                let mut r = 2 as $T;\n                assert_eq!(r.pow(2), 4 as $T);\n                assert_eq!(r.pow(0), 1 as $T);\n                assert_eq!(r.wrapping_pow(2), 4 as $T);\n                assert_eq!(r.wrapping_pow(0), 1 as $T);\n                assert_eq!(r.checked_pow(2), Some(4 as $T));\n                assert_eq!(r.checked_pow(0), Some(1 as $T));\n                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n                assert_eq!(r.saturating_pow(2), 4 as $T);\n                assert_eq!(r.saturating_pow(0), 1 as $T);\n\n                r = MAX;\n                // use `^` to represent .pow() with no overflow.\n                // if itest::MAX == 2^j-1, then itest is a `j` bit int,\n                // so that `itest::MAX*itest::MAX == 2^(2*j)-2^(j+1)+1`,\n                // thussaturating_pow the overflowing result is exactly 1.\n                assert_eq!(r.wrapping_pow(2), 1 as $T);\n                assert_eq!(r.checked_pow(2), None);\n                assert_eq!(r.overflowing_pow(2), (1 as $T, true));\n                assert_eq!(r.saturating_pow(2), MAX);\n                //test for negative exponent.\n                r = -2 as $T;\n                assert_eq!(r.pow(2), 4 as $T);\n                assert_eq!(r.pow(3), -8 as $T);\n                assert_eq!(r.pow(0), 1 as $T);\n                assert_eq!(r.wrapping_pow(2), 4 as $T);\n                assert_eq!(r.wrapping_pow(3), -8 as $T);\n                assert_eq!(r.wrapping_pow(0), 1 as $T);\n                assert_eq!(r.checked_pow(2), Some(4 as $T));\n                assert_eq!(r.checked_pow(3), Some(-8 as $T));\n                assert_eq!(r.checked_pow(0), Some(1 as $T));\n                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n                assert_eq!(r.overflowing_pow(3), (-8 as $T, false));\n                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n                assert_eq!(r.saturating_pow(2), 4 as $T);\n                assert_eq!(r.saturating_pow(3), -8 as $T);\n                assert_eq!(r.saturating_pow(0), 1 as $T);\n            }\n        }\n    };\n}\n"],[2936,"int_module!(i16, i16);\n"],[2937,"#[test]\nfn test_nan() {\n    let x = \"NaN\".to_string();\n    assert_eq!(format!(\"{}\", f64::NAN), x);\n    assert_eq!(format!(\"{:e}\", f64::NAN), x);\n    assert_eq!(format!(\"{:E}\", f64::NAN), x);\n}\n"],[2938,"uint_module!(u128, u128);\n"],[2939,"#[test]\nfn assert_eq_trailing_comma() {\n    assert_eq!(1, 1,);\n}\n\n#[test]\nfn assert_escape() {\n    assert!(r#\"☃\\backslash\"#.contains(\"\\\\\"));\n}\n\n#[test]\nfn assert_ne_trailing_comma() {\n    assert_ne!(1, 2,);\n}\n"],[2940,"use core::cmp::{\n    self,\n    Ordering::{self, *},\n};\n\n#[test]\nfn test_int_totalord() {\n    assert_eq!(5.cmp(&10), Less);\n    assert_eq!(10.cmp(&5), Greater);\n    assert_eq!(5.cmp(&5), Equal);\n    assert_eq!((-5).cmp(&12), Less);\n    assert_eq!(12.cmp(&-5), Greater);\n}\n\n#[test]\nfn test_bool_totalord() {\n    assert_eq!(true.cmp(&false), Greater);\n    assert_eq!(false.cmp(&true), Less);\n    assert_eq!(true.cmp(&true), Equal);\n    assert_eq!(false.cmp(&false), Equal);\n}\n\n#[test]\nfn test_mut_int_totalord() {\n    assert_eq!((&mut 5).cmp(&&mut 10), Less);\n    assert_eq!((&mut 10).cmp(&&mut 5), Greater);\n    assert_eq!((&mut 5).cmp(&&mut 5), Equal);\n    assert_eq!((&mut -5).cmp(&&mut 12), Less);\n    assert_eq!((&mut 12).cmp(&&mut -5), Greater);\n}\n\n#[test]\nfn test_ord_max_min() {\n    assert_eq!(1.max(2), 2);\n    assert_eq!(2.max(1), 2);\n    assert_eq!(1.min(2), 1);\n    assert_eq!(2.min(1), 1);\n    assert_eq!(1.max(1), 1);\n    assert_eq!(1.min(1), 1);\n}\n\n#[test]\nfn test_ord_min_max_by() {\n    let f = |x: &i32, y: &i32| x.abs().cmp(&y.abs());\n    assert_eq!(cmp::min_by(1, -1, f), 1);\n    assert_eq!(cmp::min_by(1, -2, f), 1);\n    assert_eq!(cmp::min_by(2, -1, f), -1);\n    assert_eq!(cmp::max_by(1, -1, f), -1);\n    assert_eq!(cmp::max_by(1, -2, f), -2);\n    assert_eq!(cmp::max_by(2, -1, f), 2);\n}\n\n#[test]\nfn test_ord_min_max_by_key() {\n    let f = |x: &i32| x.abs();\n    assert_eq!(cmp::min_by_key(1, -1, f), 1);\n    assert_eq!(cmp::min_by_key(1, -2, f), 1);\n    assert_eq!(cmp::min_by_key(2, -1, f), -1);\n    assert_eq!(cmp::max_by_key(1, -1, f), -1);\n    assert_eq!(cmp::max_by_key(1, -2, f), -2);\n    assert_eq!(cmp::max_by_key(2, -1, f), 2);\n}\n\n#[test]\nfn test_ordering_reverse() {\n    assert_eq!(Less.reverse(), Greater);\n    assert_eq!(Equal.reverse(), Equal);\n    assert_eq!(Greater.reverse(), Less);\n}\n\n#[test]\nfn test_ordering_order() {\n    assert!(Less < Equal);\n    assert_eq!(Greater.cmp(&Less), Greater);\n}\n\n#[test]\nfn test_ordering_then() {\n    assert_eq!(Equal.then(Less), Less);\n    assert_eq!(Equal.then(Equal), Equal);\n    assert_eq!(Equal.then(Greater), Greater);\n    assert_eq!(Less.then(Less), Less);\n    assert_eq!(Less.then(Equal), Less);\n    assert_eq!(Less.then(Greater), Less);\n    assert_eq!(Greater.then(Less), Greater);\n    assert_eq!(Greater.then(Equal), Greater);\n    assert_eq!(Greater.then(Greater), Greater);\n}\n\n#[test]\nfn test_ordering_then_with() {\n    assert_eq!(Equal.then_with(|| Less), Less);\n    assert_eq!(Equal.then_with(|| Equal), Equal);\n    assert_eq!(Equal.then_with(|| Greater), Greater);\n    assert_eq!(Less.then_with(|| Less), Less);\n    assert_eq!(Less.then_with(|| Equal), Less);\n    assert_eq!(Less.then_with(|| Greater), Less);\n    assert_eq!(Greater.then_with(|| Less), Greater);\n    assert_eq!(Greater.then_with(|| Equal), Greater);\n    assert_eq!(Greater.then_with(|| Greater), Greater);\n}\n\n#[test]\nfn test_user_defined_eq() {\n    // Our type.\n    struct SketchyNum {\n        num: isize,\n    }\n\n    // Our implementation of `PartialEq` to support `==` and `!=`.\n    impl PartialEq for SketchyNum {\n        // Our custom eq allows numbers which are near each other to be equal! :D\n        fn eq(&self, other: &SketchyNum) -> bool {\n            (self.num - other.num).abs() < 5\n        }\n    }\n\n    // Now these binary operators will work when applied!\n    assert!(SketchyNum { num: 37 } == SketchyNum { num: 34 });\n    assert!(SketchyNum { num: 25 } != SketchyNum { num: 57 });\n}\n\n#[test]\nfn ordering_const() {\n    // test that the methods of `Ordering` are usable in a const context\n\n    const ORDERING: Ordering = Greater;\n\n    const REVERSE: Ordering = ORDERING.reverse();\n    assert_eq!(REVERSE, Less);\n\n    const THEN: Ordering = Equal.then(ORDERING);\n    assert_eq!(THEN, Greater);\n}\n\n#[test]\nfn cmp_default() {\n    // Test default methods in PartialOrd and PartialEq\n\n    #[derive(Debug)]\n    struct Fool(bool);\n\n    impl PartialEq for Fool {\n        fn eq(&self, other: &Fool) -> bool {\n            let Fool(this) = *self;\n            let Fool(other) = *other;\n            this != other\n        }\n    }\n\n    struct Int(isize);\n\n    impl PartialEq for Int {\n        fn eq(&self, other: &Int) -> bool {\n            let Int(this) = *self;\n            let Int(other) = *other;\n            this == other\n        }\n    }\n\n    impl PartialOrd for Int {\n        fn partial_cmp(&self, other: &Int) -> Option<Ordering> {\n            let Int(this) = *self;\n            let Int(other) = *other;\n            this.partial_cmp(&other)\n        }\n    }\n\n    struct RevInt(isize);\n\n    impl PartialEq for RevInt {\n        fn eq(&self, other: &RevInt) -> bool {\n            let RevInt(this) = *self;\n            let RevInt(other) = *other;\n            this == other\n        }\n    }\n\n    impl PartialOrd for RevInt {\n        fn partial_cmp(&self, other: &RevInt) -> Option<Ordering> {\n            let RevInt(this) = *self;\n            let RevInt(other) = *other;\n            other.partial_cmp(&this)\n        }\n    }\n\n    assert!(Int(2) > Int(1));\n    assert!(Int(2) >= Int(1));\n    assert!(Int(1) >= Int(1));\n    assert!(Int(1) < Int(2));\n    assert!(Int(1) <= Int(2));\n    assert!(Int(1) <= Int(1));\n\n    assert!(RevInt(2) < RevInt(1));\n    assert!(RevInt(2) <= RevInt(1));\n    assert!(RevInt(1) <= RevInt(1));\n    assert!(RevInt(1) > RevInt(2));\n    assert!(RevInt(1) >= RevInt(2));\n    assert!(RevInt(1) >= RevInt(1));\n\n    assert_eq!(Fool(true), Fool(false));\n    assert!(Fool(true) != Fool(true));\n    assert!(Fool(false) != Fool(false));\n    assert_eq!(Fool(false), Fool(true));\n}\n"],[2941,"use core::cell::*;\nuse core::default::Default;\nuse std::mem::drop;\n\n#[test]\nfn smoketest_cell() {\n    let x = Cell::new(10);\n    assert_eq!(x, Cell::new(10));\n    assert_eq!(x.get(), 10);\n    x.set(20);\n    assert_eq!(x, Cell::new(20));\n    assert_eq!(x.get(), 20);\n\n    let y = Cell::new((30, 40));\n    assert_eq!(y, Cell::new((30, 40)));\n    assert_eq!(y.get(), (30, 40));\n}\n\n#[test]\nfn cell_update() {\n    let x = Cell::new(10);\n\n    assert_eq!(x.update(|x| x + 5), 15);\n    assert_eq!(x.get(), 15);\n\n    assert_eq!(x.update(|x| x / 3), 5);\n    assert_eq!(x.get(), 5);\n}\n\n#[test]\nfn cell_has_sensible_show() {\n    let x = Cell::new(\"foo bar\");\n    assert!(format!(\"{:?}\", x).contains(x.get()));\n\n    x.set(\"baz qux\");\n    assert!(format!(\"{:?}\", x).contains(x.get()));\n}\n\n#[test]\nfn ref_and_refmut_have_sensible_show() {\n    let refcell = RefCell::new(\"foo\");\n\n    let refcell_refmut = refcell.borrow_mut();\n    assert!(format!(\"{:?}\", refcell_refmut).contains(\"foo\"));\n    drop(refcell_refmut);\n\n    let refcell_ref = refcell.borrow();\n    assert!(format!(\"{:?}\", refcell_ref).contains(\"foo\"));\n    drop(refcell_ref);\n}\n\n#[test]\nfn double_imm_borrow() {\n    let x = RefCell::new(0);\n    let _b1 = x.borrow();\n    x.borrow();\n}\n\n#[test]\nfn no_mut_then_imm_borrow() {\n    let x = RefCell::new(0);\n    let _b1 = x.borrow_mut();\n    assert!(x.try_borrow().is_err());\n}\n\n#[test]\nfn no_imm_then_borrow_mut() {\n    let x = RefCell::new(0);\n    let _b1 = x.borrow();\n    assert!(x.try_borrow_mut().is_err());\n}\n\n#[test]\nfn no_double_borrow_mut() {\n    let x = RefCell::new(0);\n    assert!(x.try_borrow().is_ok());\n    let _b1 = x.borrow_mut();\n    assert!(x.try_borrow().is_err());\n}\n\n#[test]\nfn imm_release_borrow_mut() {\n    let x = RefCell::new(0);\n    {\n        let _b1 = x.borrow();\n    }\n    x.borrow_mut();\n}\n\n#[test]\nfn mut_release_borrow_mut() {\n    let x = RefCell::new(0);\n    {\n        let _b1 = x.borrow_mut();\n    }\n    x.borrow();\n}\n\n#[test]\nfn double_borrow_single_release_no_borrow_mut() {\n    let x = RefCell::new(0);\n    let _b1 = x.borrow();\n    {\n        let _b2 = x.borrow();\n    }\n    assert!(x.try_borrow().is_ok());\n    assert!(x.try_borrow_mut().is_err());\n}\n\n#[test]\n#[should_panic]\nfn discard_doesnt_unborrow() {\n    let x = RefCell::new(0);\n    let _b = x.borrow();\n    let _ = _b;\n    let _b = x.borrow_mut();\n}\n\n#[test]\nfn ref_clone_updates_flag() {\n    let x = RefCell::new(0);\n    {\n        let b1 = x.borrow();\n        assert!(x.try_borrow().is_ok());\n        assert!(x.try_borrow_mut().is_err());\n        {\n            let _b2 = Ref::clone(&b1);\n            assert!(x.try_borrow().is_ok());\n            assert!(x.try_borrow_mut().is_err());\n        }\n        assert!(x.try_borrow().is_ok());\n        assert!(x.try_borrow_mut().is_err());\n    }\n    assert!(x.try_borrow().is_ok());\n    assert!(x.try_borrow_mut().is_ok());\n}\n\n#[test]\nfn ref_map_does_not_update_flag() {\n    let x = RefCell::new(Some(5));\n    {\n        let b1: Ref<'_, Option<u32>> = x.borrow();\n        assert!(x.try_borrow().is_ok());\n        assert!(x.try_borrow_mut().is_err());\n        {\n            let b2: Ref<'_, u32> = Ref::map(b1, |o| o.as_ref().unwrap());\n            assert_eq!(*b2, 5);\n            assert!(x.try_borrow().is_ok());\n            assert!(x.try_borrow_mut().is_err());\n        }\n        assert!(x.try_borrow().is_ok());\n        assert!(x.try_borrow_mut().is_ok());\n    }\n    assert!(x.try_borrow().is_ok());\n    assert!(x.try_borrow_mut().is_ok());\n}\n\n#[test]\nfn ref_map_split_updates_flag() {\n    let x = RefCell::new([1, 2]);\n    {\n        let b1 = x.borrow();\n        assert!(x.try_borrow().is_ok());\n        assert!(x.try_borrow_mut().is_err());\n        {\n            let (_b2, _b3) = Ref::map_split(b1, |slc| slc.split_at(1));\n            assert!(x.try_borrow().is_ok());\n            assert!(x.try_borrow_mut().is_err());\n        }\n        assert!(x.try_borrow().is_ok());\n        assert!(x.try_borrow_mut().is_ok());\n    }\n    assert!(x.try_borrow().is_ok());\n    assert!(x.try_borrow_mut().is_ok());\n\n    {\n        let b1 = x.borrow_mut();\n        assert!(x.try_borrow().is_err());\n        assert!(x.try_borrow_mut().is_err());\n        {\n            let (_b2, _b3) = RefMut::map_split(b1, |slc| slc.split_at_mut(1));\n            assert!(x.try_borrow().is_err());\n            assert!(x.try_borrow_mut().is_err());\n            drop(_b2);\n            assert!(x.try_borrow().is_err());\n            assert!(x.try_borrow_mut().is_err());\n        }\n        assert!(x.try_borrow().is_ok());\n        assert!(x.try_borrow_mut().is_ok());\n    }\n    assert!(x.try_borrow().is_ok());\n    assert!(x.try_borrow_mut().is_ok());\n}\n\n#[test]\nfn ref_map_split() {\n    let x = RefCell::new([1, 2]);\n    let (b1, b2) = Ref::map_split(x.borrow(), |slc| slc.split_at(1));\n    assert_eq!(*b1, [1]);\n    assert_eq!(*b2, [2]);\n}\n\n#[test]\nfn ref_mut_map_split() {\n    let x = RefCell::new([1, 2]);\n    {\n        let (mut b1, mut b2) = RefMut::map_split(x.borrow_mut(), |slc| slc.split_at_mut(1));\n        assert_eq!(*b1, [1]);\n        assert_eq!(*b2, [2]);\n        b1[0] = 2;\n        b2[0] = 1;\n    }\n    assert_eq!(*x.borrow(), [2, 1]);\n}\n\n#[test]\nfn ref_map_accessor() {\n    struct X(RefCell<(u32, char)>);\n    impl X {\n        fn accessor(&self) -> Ref<'_, u32> {\n            Ref::map(self.0.borrow(), |tuple| &tuple.0)\n        }\n    }\n    let x = X(RefCell::new((7, 'z')));\n    let d: Ref<'_, u32> = x.accessor();\n    assert_eq!(*d, 7);\n}\n\n#[test]\nfn ref_mut_map_accessor() {\n    struct X(RefCell<(u32, char)>);\n    impl X {\n        fn accessor(&self) -> RefMut<'_, u32> {\n            RefMut::map(self.0.borrow_mut(), |tuple| &mut tuple.0)\n        }\n    }\n    let x = X(RefCell::new((7, 'z')));\n    {\n        let mut d: RefMut<'_, u32> = x.accessor();\n        assert_eq!(*d, 7);\n        *d += 1;\n    }\n    assert_eq!(*x.0.borrow(), (8, 'z'));\n}\n\n#[test]\nfn as_ptr() {\n    let c1: Cell<usize> = Cell::new(0);\n    c1.set(1);\n    assert_eq!(1, unsafe { *c1.as_ptr() });\n\n    let c2: Cell<usize> = Cell::new(0);\n    unsafe {\n        *c2.as_ptr() = 1;\n    }\n    assert_eq!(1, c2.get());\n\n    let r1: RefCell<usize> = RefCell::new(0);\n    *r1.borrow_mut() = 1;\n    assert_eq!(1, unsafe { *r1.as_ptr() });\n\n    let r2: RefCell<usize> = RefCell::new(0);\n    unsafe {\n        *r2.as_ptr() = 1;\n    }\n    assert_eq!(1, *r2.borrow());\n}\n\n#[test]\nfn cell_default() {\n    let cell: Cell<u32> = Default::default();\n    assert_eq!(0, cell.get());\n}\n\n#[test]\nfn cell_set() {\n    let cell = Cell::new(10);\n    cell.set(20);\n    assert_eq!(20, cell.get());\n\n    let cell = Cell::new(\"Hello\".to_owned());\n    cell.set(\"World\".to_owned());\n    assert_eq!(\"World\".to_owned(), cell.into_inner());\n}\n\n#[test]\nfn cell_replace() {\n    let cell = Cell::new(10);\n    assert_eq!(10, cell.replace(20));\n    assert_eq!(20, cell.get());\n\n    let cell = Cell::new(\"Hello\".to_owned());\n    assert_eq!(\"Hello\".to_owned(), cell.replace(\"World\".to_owned()));\n    assert_eq!(\"World\".to_owned(), cell.into_inner());\n}\n\n#[test]\nfn cell_into_inner() {\n    let cell = Cell::new(10);\n    assert_eq!(10, cell.into_inner());\n\n    let cell = Cell::new(\"Hello world\".to_owned());\n    assert_eq!(\"Hello world\".to_owned(), cell.into_inner());\n}\n\n#[test]\nfn cell_exterior() {\n    #[derive(Copy, Clone)]\n    #[allow(dead_code)]\n    struct Point {\n        x: isize,\n        y: isize,\n        z: isize,\n    }\n\n    fn f(p: &Cell<Point>) {\n        assert_eq!(p.get().z, 12);\n        p.set(Point { x: 10, y: 11, z: 13 });\n        assert_eq!(p.get().z, 13);\n    }\n\n    let a = Point { x: 10, y: 11, z: 12 };\n    let b = &Cell::new(a);\n    assert_eq!(b.get().z, 12);\n    f(b);\n    assert_eq!(a.z, 12);\n    assert_eq!(b.get().z, 13);\n}\n\n#[test]\nfn cell_does_not_clone() {\n    #[derive(Copy)]\n    #[allow(dead_code)]\n    struct Foo {\n        x: isize,\n    }\n\n    impl Clone for Foo {\n        fn clone(&self) -> Foo {\n            // Using Cell in any way should never cause clone() to be\n            // invoked -- after all, that would permit evil user code to\n            // abuse `Cell` and trigger crashes.\n\n            panic!();\n        }\n    }\n\n    let x = Cell::new(Foo { x: 22 });\n    let _y = x.get();\n    let _z = x.clone();\n}\n\n#[test]\nfn refcell_default() {\n    let cell: RefCell<u64> = Default::default();\n    assert_eq!(0, *cell.borrow());\n}\n\n#[test]\nfn unsafe_cell_unsized() {\n    let cell: &UnsafeCell<[i32]> = &UnsafeCell::new([1, 2, 3]);\n    {\n        let val: &mut [i32] = unsafe { &mut *cell.get() };\n        val[0] = 4;\n        val[2] = 5;\n    }\n    let comp: &mut [i32] = &mut [4, 2, 5];\n    assert_eq!(unsafe { &mut *cell.get() }, comp);\n}\n\n#[test]\nfn refcell_unsized() {\n    let cell: &RefCell<[i32]> = &RefCell::new([1, 2, 3]);\n    {\n        let b = &mut *cell.borrow_mut();\n        b[0] = 4;\n        b[2] = 5;\n    }\n    let comp: &mut [i32] = &mut [4, 2, 5];\n    assert_eq!(&*cell.borrow(), comp);\n}\n\n#[test]\nfn refcell_ref_coercion() {\n    let cell: RefCell<[i32; 3]> = RefCell::new([1, 2, 3]);\n    {\n        let mut cellref: RefMut<'_, [i32; 3]> = cell.borrow_mut();\n        cellref[0] = 4;\n        let mut coerced: RefMut<'_, [i32]> = cellref;\n        coerced[2] = 5;\n    }\n    {\n        let comp: &mut [i32] = &mut [4, 2, 5];\n        let cellref: Ref<'_, [i32; 3]> = cell.borrow();\n        assert_eq!(&*cellref, comp);\n        let coerced: Ref<'_, [i32]> = cellref;\n        assert_eq!(&*coerced, comp);\n    }\n}\n\n#[test]\n#[should_panic]\nfn refcell_swap_borrows() {\n    let x = RefCell::new(0);\n    let _b = x.borrow();\n    let y = RefCell::new(1);\n    x.swap(&y);\n}\n\n#[test]\n#[should_panic]\nfn refcell_replace_borrows() {\n    let x = RefCell::new(0);\n    let _b = x.borrow();\n    x.replace(1);\n}\n\n#[test]\nfn refcell_format() {\n    let name = RefCell::new(\"rust\");\n    let what = RefCell::new(\"rocks\");\n    let msg = format!(\"{name} {}\", &*what.borrow(), name = &*name.borrow());\n    assert_eq!(msg, \"rust rocks\".to_string());\n}\n\n#[allow(dead_code)]\nfn const_cells() {\n    const UNSAFE_CELL: UnsafeCell<i32> = UnsafeCell::new(3);\n    const _: i32 = UNSAFE_CELL.into_inner();\n\n    const REF_CELL: RefCell<i32> = RefCell::new(3);\n    const _: i32 = REF_CELL.into_inner();\n\n    const CELL: Cell<i32> = Cell::new(3);\n    const _: i32 = CELL.into_inner();\n}\n"],[2942,"#![feature(alloc_layout_extra)]\n#![feature(array_chunks)]\n#![feature(array_methods)]\n#![feature(array_map)]\n#![feature(array_windows)]\n#![feature(bool_to_option)]\n#![feature(bound_cloned)]\n#![feature(box_syntax)]\n#![feature(cell_update)]\n#![feature(cfg_panic)]\n#![feature(cfg_target_has_atomic)]\n#![feature(const_assume)]\n#![feature(const_cell_into_inner)]\n#![feature(const_maybe_uninit_assume_init)]\n#![feature(const_ptr_read)]\n#![feature(const_ptr_write)]\n#![feature(const_ptr_offset)]\n#![feature(core_intrinsics)]\n#![feature(core_private_bignum)]\n#![feature(core_private_diy_float)]\n#![feature(dec2flt)]\n#![feature(div_duration)]\n#![feature(duration_consts_2)]\n#![feature(duration_constants)]\n#![feature(exact_size_is_empty)]\n#![feature(extern_types)]\n#![feature(flt2dec)]\n#![feature(fmt_internals)]\n#![feature(hashmap_internals)]\n#![feature(try_find)]\n#![feature(is_sorted)]\n#![feature(pattern)]\n#![feature(raw)]\n#![feature(sort_internals)]\n#![feature(slice_partition_at_index)]\n#![feature(maybe_uninit_uninit_array)]\n#![feature(maybe_uninit_array_assume_init)]\n#![feature(maybe_uninit_extra)]\n#![feature(maybe_uninit_write_slice)]\n#![feature(min_specialization)]\n#![feature(step_trait)]\n#![feature(str_internals)]\n#![feature(test)]\n#![feature(trusted_len)]\n#![feature(try_trait_v2)]\n#![feature(slice_internals)]\n#![feature(slice_partition_dedup)]\n#![feature(iter_advance_by)]\n#![feature(iter_partition_in_place)]\n#![feature(iter_intersperse)]\n#![feature(iter_is_partitioned)]\n#![feature(iter_order_by)]\n#![feature(iter_map_while)]\n#![feature(const_mut_refs)]\n#![feature(const_pin)]\n#![feature(const_slice_from_raw_parts)]\n#![feature(const_raw_ptr_deref)]\n#![feature(never_type)]\n#![feature(unwrap_infallible)]\n#![feature(option_result_unwrap_unchecked)]\n#![feature(result_into_ok_or_err)]\n#![feature(ptr_metadata)]\n#![feature(once_cell)]\n#![feature(unsized_tuple_coercion)]\n#![feature(const_option)]\n#![feature(integer_atomics)]\n#![feature(slice_group_by)]\n#![feature(trusted_random_access)]\n#![feature(unsize)]\n#![deny(unsafe_op_in_unsafe_fn)]\n\nextern crate test;\n\nmod alloc;\nmod any;\nmod array;\nmod ascii;\nmod atomic;\nmod bool;\nmod cell;\nmod char;\nmod clone;\nmod cmp;\nmod const_ptr;\nmod fmt;\nmod hash;\nmod intrinsics;\nmod iter;\nmod lazy;\nmod macros;\nmod manually_drop;\nmod mem;\nmod nonzero;\nmod num;\nmod ops;\nmod option;\nmod pattern;\nmod pin;\nmod ptr;\nmod result;\nmod slice;\nmod str;\nmod str_lossy;\nmod task;\nmod time;\nmod tuple;\nmod unicode;\n"],[2943,"use core::ops::DerefMut;\nuse core::option::*;\n\nfn op1() -> Result<isize, &'static str> {\n    Ok(666)\n}\nfn op2() -> Result<isize, &'static str> {\n    Err(\"sadface\")\n}\n\n#[test]\nfn test_and() {\n    assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n    assert_eq!(op1().and(Err::<i32, &'static str>(\"bad\")).unwrap_err(), \"bad\");\n\n    assert_eq!(op2().and(Ok(667)).unwrap_err(), \"sadface\");\n    assert_eq!(op2().and(Err::<i32, &'static str>(\"bad\")).unwrap_err(), \"sadface\");\n}\n\n#[test]\nfn test_and_then() {\n    assert_eq!(op1().and_then(|i| Ok::<isize, &'static str>(i + 1)).unwrap(), 667);\n    assert_eq!(op1().and_then(|_| Err::<isize, &'static str>(\"bad\")).unwrap_err(), \"bad\");\n\n    assert_eq!(op2().and_then(|i| Ok::<isize, &'static str>(i + 1)).unwrap_err(), \"sadface\");\n    assert_eq!(op2().and_then(|_| Err::<isize, &'static str>(\"bad\")).unwrap_err(), \"sadface\");\n}\n\n#[test]\nfn test_or() {\n    assert_eq!(op1().or(Ok::<_, &'static str>(667)).unwrap(), 666);\n    assert_eq!(op1().or(Err(\"bad\")).unwrap(), 666);\n\n    assert_eq!(op2().or(Ok::<_, &'static str>(667)).unwrap(), 667);\n    assert_eq!(op2().or(Err(\"bad\")).unwrap_err(), \"bad\");\n}\n\n#[test]\nfn test_or_else() {\n    assert_eq!(op1().or_else(|_| Ok::<isize, &'static str>(667)).unwrap(), 666);\n    assert_eq!(op1().or_else(|e| Err::<isize, &'static str>(e)).unwrap(), 666);\n\n    assert_eq!(op2().or_else(|_| Ok::<isize, &'static str>(667)).unwrap(), 667);\n    assert_eq!(op2().or_else(|e| Err::<isize, &'static str>(e)).unwrap_err(), \"sadface\");\n}\n\n#[test]\nfn test_impl_map() {\n    assert!(Ok::<isize, isize>(1).map(|x| x + 1) == Ok(2));\n    assert!(Err::<isize, isize>(1).map(|x| x + 1) == Err(1));\n}\n\n#[test]\nfn test_impl_map_err() {\n    assert!(Ok::<isize, isize>(1).map_err(|x| x + 1) == Ok(1));\n    assert!(Err::<isize, isize>(1).map_err(|x| x + 1) == Err(2));\n}\n\n#[test]\nfn test_collect() {\n    let v: Result<Vec<isize>, ()> = (0..0).map(|_| Ok::<isize, ()>(0)).collect();\n    assert!(v == Ok(vec![]));\n\n    let v: Result<Vec<isize>, ()> = (0..3).map(|x| Ok::<isize, ()>(x)).collect();\n    assert!(v == Ok(vec![0, 1, 2]));\n\n    let v: Result<Vec<isize>, isize> = (0..3).map(|x| if x > 1 { Err(x) } else { Ok(x) }).collect();\n    assert!(v == Err(2));\n\n    // test that it does not take more elements than it needs\n    let mut functions: [Box<dyn Fn() -> Result<(), isize>>; 3] =\n        [box || Ok(()), box || Err(1), box || panic!()];\n\n    let v: Result<Vec<()>, isize> = functions.iter_mut().map(|f| (*f)()).collect();\n    assert!(v == Err(1));\n}\n\n#[test]\nfn test_fmt_default() {\n    let ok: Result<isize, &'static str> = Ok(100);\n    let err: Result<isize, &'static str> = Err(\"Err\");\n\n    let s = format!(\"{:?}\", ok);\n    assert_eq!(s, \"Ok(100)\");\n    let s = format!(\"{:?}\", err);\n    assert_eq!(s, \"Err(\\\"Err\\\")\");\n}\n\n#[test]\nfn test_unwrap_or() {\n    let ok: Result<isize, &'static str> = Ok(100);\n    let ok_err: Result<isize, &'static str> = Err(\"Err\");\n\n    assert_eq!(ok.unwrap_or(50), 100);\n    assert_eq!(ok_err.unwrap_or(50), 50);\n}\n\n#[test]\nfn test_ok_or_err() {\n    let ok: Result<isize, isize> = Ok(100);\n    let err: Result<isize, isize> = Err(200);\n\n    assert_eq!(ok.into_ok_or_err(), 100);\n    assert_eq!(err.into_ok_or_err(), 200);\n}\n\n#[test]\nfn test_unwrap_or_else() {\n    fn handler(msg: &'static str) -> isize {\n        if msg == \"I got this.\" { 50 } else { panic!(\"BadBad\") }\n    }\n\n    let ok: Result<isize, &'static str> = Ok(100);\n    let ok_err: Result<isize, &'static str> = Err(\"I got this.\");\n\n    assert_eq!(ok.unwrap_or_else(handler), 100);\n    assert_eq!(ok_err.unwrap_or_else(handler), 50);\n}\n\n#[test]\n#[should_panic]\npub fn test_unwrap_or_else_panic() {\n    fn handler(msg: &'static str) -> isize {\n        if msg == \"I got this.\" { 50 } else { panic!(\"BadBad\") }\n    }\n\n    let bad_err: Result<isize, &'static str> = Err(\"Unrecoverable mess.\");\n    let _: isize = bad_err.unwrap_or_else(handler);\n}\n\n#[test]\nfn test_unwrap_unchecked() {\n    let ok: Result<isize, &'static str> = Ok(100);\n    assert_eq!(unsafe { ok.unwrap_unchecked() }, 100);\n}\n\n#[test]\nfn test_unwrap_err_unchecked() {\n    let ok_err: Result<isize, &'static str> = Err(\"Err\");\n    assert_eq!(unsafe { ok_err.unwrap_err_unchecked() }, \"Err\");\n}\n\n#[test]\npub fn test_expect_ok() {\n    let ok: Result<isize, &'static str> = Ok(100);\n    assert_eq!(ok.expect(\"Unexpected error\"), 100);\n}\n#[test]\n#[should_panic(expected = \"Got expected error: \\\"All good\\\"\")]\npub fn test_expect_err() {\n    let err: Result<isize, &'static str> = Err(\"All good\");\n    err.expect(\"Got expected error\");\n}\n\n#[test]\npub fn test_expect_err_err() {\n    let ok: Result<&'static str, isize> = Err(100);\n    assert_eq!(ok.expect_err(\"Unexpected ok\"), 100);\n}\n#[test]\n#[should_panic(expected = \"Got expected ok: \\\"All good\\\"\")]\npub fn test_expect_err_ok() {\n    let err: Result<&'static str, isize> = Ok(\"All good\");\n    err.expect_err(\"Got expected ok\");\n}\n\n#[test]\npub fn test_iter() {\n    let ok: Result<isize, &'static str> = Ok(100);\n    let mut it = ok.iter();\n    assert_eq!(it.size_hint(), (1, Some(1)));\n    assert_eq!(it.next(), Some(&100));\n    assert_eq!(it.size_hint(), (0, Some(0)));\n    assert!(it.next().is_none());\n    assert_eq!((&ok).into_iter().next(), Some(&100));\n\n    let err: Result<isize, &'static str> = Err(\"error\");\n    assert_eq!(err.iter().next(), None);\n}\n\n#[test]\npub fn test_iter_mut() {\n    let mut ok: Result<isize, &'static str> = Ok(100);\n    for loc in ok.iter_mut() {\n        *loc = 200;\n    }\n    assert_eq!(ok, Ok(200));\n    for loc in &mut ok {\n        *loc = 300;\n    }\n    assert_eq!(ok, Ok(300));\n\n    let mut err: Result<isize, &'static str> = Err(\"error\");\n    for loc in err.iter_mut() {\n        *loc = 200;\n    }\n    assert_eq!(err, Err(\"error\"));\n}\n\n#[test]\npub fn test_unwrap_or_default() {\n    assert_eq!(op1().unwrap_or_default(), 666);\n    assert_eq!(op2().unwrap_or_default(), 0);\n}\n\n#[test]\npub fn test_into_ok() {\n    fn infallible_op() -> Result<isize, !> {\n        Ok(666)\n    }\n\n    assert_eq!(infallible_op().into_ok(), 666);\n\n    enum MyNeverToken {}\n    impl From<MyNeverToken> for ! {\n        fn from(never: MyNeverToken) -> ! {\n            match never {}\n        }\n    }\n\n    fn infallible_op2() -> Result<isize, MyNeverToken> {\n        Ok(667)\n    }\n\n    assert_eq!(infallible_op2().into_ok(), 667);\n}\n\n#[test]\npub fn test_into_err() {\n    fn until_error_op() -> Result<!, isize> {\n        Err(666)\n    }\n\n    assert_eq!(until_error_op().into_err(), 666);\n\n    enum MyNeverToken {}\n    impl From<MyNeverToken> for ! {\n        fn from(never: MyNeverToken) -> ! {\n            match never {}\n        }\n    }\n\n    fn until_error_op2() -> Result<MyNeverToken, isize> {\n        Err(667)\n    }\n\n    assert_eq!(until_error_op2().into_err(), 667);\n}\n\n#[test]\nfn test_try() {\n    fn try_result_ok() -> Result<u8, u32> {\n        let result: Result<u8, u8> = Ok(1);\n        let val = result?;\n        Ok(val)\n    }\n    assert_eq!(try_result_ok(), Ok(1));\n\n    fn try_result_err() -> Result<u8, u32> {\n        let result: Result<u8, u8> = Err(1);\n        let val = result?;\n        Ok(val)\n    }\n    assert_eq!(try_result_err(), Err(1));\n}\n\n#[test]\nfn test_result_as_deref() {\n    // &Result<T: Deref, E>::Ok(T).as_deref() ->\n    //      Result<&T::Deref::Target, &E>::Ok(&*T)\n    let ref_ok = &Result::Ok::<&i32, u8>(&42);\n    let expected_result = Result::Ok::<&i32, &u8>(&42);\n    assert_eq!(ref_ok.as_deref(), expected_result);\n\n    let ref_ok = &Result::Ok::<String, u32>(String::from(\"a result\"));\n    let expected_result = Result::Ok::<&str, &u32>(\"a result\");\n    assert_eq!(ref_ok.as_deref(), expected_result);\n\n    let ref_ok = &Result::Ok::<Vec<i32>, u32>(vec![1, 2, 3, 4, 5]);\n    let expected_result = Result::Ok::<&[i32], &u32>([1, 2, 3, 4, 5].as_slice());\n    assert_eq!(ref_ok.as_deref(), expected_result);\n\n    // &Result<T: Deref, E>::Err(T).as_deref() ->\n    //      Result<&T::Deref::Target, &E>::Err(&*E)\n    let val = 41;\n    let ref_err = &Result::Err::<&u8, i32>(val);\n    let expected_result = Result::Err::<&u8, &i32>(&val);\n    assert_eq!(ref_err.as_deref(), expected_result);\n\n    let s = String::from(\"an error\");\n    let ref_err = &Result::Err::<&u32, String>(s.clone());\n    let expected_result = Result::Err::<&u32, &String>(&s);\n    assert_eq!(ref_err.as_deref(), expected_result);\n\n    let v = vec![5, 4, 3, 2, 1];\n    let ref_err = &Result::Err::<&u32, Vec<i32>>(v.clone());\n    let expected_result = Result::Err::<&u32, &Vec<i32>>(&v);\n    assert_eq!(ref_err.as_deref(), expected_result);\n}\n\n#[test]\nfn test_result_as_deref_mut() {\n    // &mut Result<T: DerefMut, E>::Ok(T).as_deref_mut() ->\n    //      Result<&mut T::DerefMut::Target, &mut E>::Ok(&mut *T)\n    let mut val = 42;\n    let mut expected_val = 42;\n    let mut_ok = &mut Result::Ok::<&mut i32, u8>(&mut val);\n    let expected_result = Result::Ok::<&mut i32, &mut u8>(&mut expected_val);\n    assert_eq!(mut_ok.as_deref_mut(), expected_result);\n\n    let mut expected_string = String::from(\"a result\");\n    let mut_ok = &mut Result::Ok::<String, u32>(expected_string.clone());\n    let expected_result = Result::Ok::<&mut str, &mut u32>(expected_string.deref_mut());\n    assert_eq!(mut_ok.as_deref_mut(), expected_result);\n\n    let mut expected_vec = vec![1, 2, 3, 4, 5];\n    let mut_ok = &mut Result::Ok::<Vec<i32>, u32>(expected_vec.clone());\n    let expected_result = Result::Ok::<&mut [i32], &mut u32>(expected_vec.as_mut_slice());\n    assert_eq!(mut_ok.as_deref_mut(), expected_result);\n\n    // &mut Result<T: DerefMut, E>::Err(T).as_deref_mut() ->\n    //      Result<&mut T, &mut E>::Err(&mut *E)\n    let mut val = 41;\n    let mut_err = &mut Result::Err::<&mut u8, i32>(val);\n    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut val);\n    assert_eq!(mut_err.as_deref_mut(), expected_result);\n\n    let mut expected_string = String::from(\"an error\");\n    let mut_err = &mut Result::Err::<&mut u32, String>(expected_string.clone());\n    let expected_result = Result::Err::<&mut u32, &mut String>(&mut expected_string);\n    assert_eq!(mut_err.as_deref_mut(), expected_result);\n\n    let mut expected_vec = vec![5, 4, 3, 2, 1];\n    let mut_err = &mut Result::Err::<&mut u32, Vec<i32>>(expected_vec.clone());\n    let expected_result = Result::Err::<&mut u32, &mut Vec<i32>>(&mut expected_vec);\n    assert_eq!(mut_err.as_deref_mut(), expected_result);\n}\n\n#[test]\nfn result_const() {\n    // test that the methods of `Result` are usable in a const context\n\n    const RESULT: Result<usize, bool> = Ok(32);\n\n    const REF: Result<&usize, &bool> = RESULT.as_ref();\n    assert_eq!(REF, Ok(&32));\n\n    const IS_OK: bool = RESULT.is_ok();\n    assert!(IS_OK);\n\n    const IS_ERR: bool = RESULT.is_err();\n    assert!(!IS_ERR)\n}\n\n#[test]\nfn result_opt_conversions() {\n    #[derive(Copy, Clone, Debug, PartialEq)]\n    struct BadNumErr;\n\n    fn try_num(x: i32) -> Result<i32, BadNumErr> {\n        if x <= 5 { Ok(x + 1) } else { Err(BadNumErr) }\n    }\n\n    type ResOpt = Result<Option<i32>, BadNumErr>;\n    type OptRes = Option<Result<i32, BadNumErr>>;\n\n    let mut x: ResOpt = Ok(Some(5));\n    let mut y: OptRes = Some(Ok(5));\n    assert_eq!(x, y.transpose());\n    assert_eq!(x.transpose(), y);\n\n    x = Ok(None);\n    y = None;\n    assert_eq!(x, y.transpose());\n    assert_eq!(x.transpose(), y);\n\n    x = Err(BadNumErr);\n    y = Some(Err(BadNumErr));\n    assert_eq!(x, y.transpose());\n    assert_eq!(x.transpose(), y);\n\n    let res: Result<Vec<i32>, BadNumErr> = (0..10)\n        .map(|x| {\n            let y = try_num(x)?;\n            Ok(if y % 2 == 0 { Some(y - 1) } else { None })\n        })\n        .filter_map(Result::transpose)\n        .collect();\n\n    assert_eq!(res, Err(BadNumErr))\n}\n\n#[test]\n#[cfg(not(bootstrap))] // Needs the V2 trait\nfn result_try_trait_v2_branch() {\n    use core::num::NonZeroU32;\n    use core::ops::{ControlFlow::*, Try};\n    assert_eq!(Ok::<i32, i32>(4).branch(), Continue(4));\n    assert_eq!(Err::<i32, i32>(4).branch(), Break(Err(4)));\n    let one = NonZeroU32::new(1).unwrap();\n    assert_eq!(Ok::<(), NonZeroU32>(()).branch(), Continue(()));\n    assert_eq!(Err::<(), NonZeroU32>(one).branch(), Break(Err(one)));\n    assert_eq!(Ok::<NonZeroU32, ()>(one).branch(), Continue(one));\n    assert_eq!(Err::<NonZeroU32, ()>(()).branch(), Break(Err(())));\n}\n"],[2944,"use std::cmp::Ordering::{Equal, Greater, Less};\n\n#[test]\nfn test_clone() {\n    let a = (1, \"2\");\n    let b = a.clone();\n    assert_eq!(a, b);\n}\n\n#[test]\nfn test_partial_eq() {\n    let (small, big) = ((1, 2, 3), (3, 2, 1));\n    assert_eq!(small, small);\n    assert_eq!(big, big);\n    assert_ne!(small, big);\n    assert_ne!(big, small);\n}\n\n#[test]\nfn test_partial_ord() {\n    let (small, big) = ((1, 2, 3), (3, 2, 1));\n\n    assert!(small < big);\n    assert!(!(small < small));\n    assert!(!(big < small));\n    assert!(!(big < big));\n\n    assert!(small <= small);\n    assert!(big <= big);\n\n    assert!(big > small);\n    assert!(small >= small);\n    assert!(big >= small);\n    assert!(big >= big);\n\n    assert!(!((1.0f64, 2.0f64) < (f64::NAN, 3.0)));\n    assert!(!((1.0f64, 2.0f64) <= (f64::NAN, 3.0)));\n    assert!(!((1.0f64, 2.0f64) > (f64::NAN, 3.0)));\n    assert!(!((1.0f64, 2.0f64) >= (f64::NAN, 3.0)));\n    assert!(((1.0f64, 2.0f64) < (2.0, f64::NAN)));\n    assert!(!((2.0f64, 2.0f64) < (2.0, f64::NAN)));\n}\n\n#[test]\nfn test_ord() {\n    let (small, big) = ((1, 2, 3), (3, 2, 1));\n    assert_eq!(small.cmp(&small), Equal);\n    assert_eq!(big.cmp(&big), Equal);\n    assert_eq!(small.cmp(&big), Less);\n    assert_eq!(big.cmp(&small), Greater);\n}\n\n#[test]\nfn test_show() {\n    let s = format!(\"{:?}\", (1,));\n    assert_eq!(s, \"(1,)\");\n    let s = format!(\"{:?}\", (1, true));\n    assert_eq!(s, \"(1, true)\");\n    let s = format!(\"{:?}\", (1, \"hi\", true));\n    assert_eq!(s, \"(1, \\\"hi\\\", true)\");\n}\n"],[2945,"mod builders;\nmod float;\nmod num;\n\n#[test]\nfn test_format_flags() {\n    // No residual flags left by pointer formatting\n    let p = \"\".as_ptr();\n    assert_eq!(format!(\"{:p} {:x}\", p, 16), format!(\"{:p} 10\", p));\n\n    assert_eq!(format!(\"{: >3}\", 'a'), \"  a\");\n}\n\n#[test]\nfn test_pointer_formats_data_pointer() {\n    let b: &[u8] = b\"\";\n    let s: &str = \"\";\n    assert_eq!(format!(\"{:p}\", s), format!(\"{:p}\", s.as_ptr()));\n    assert_eq!(format!(\"{:p}\", b), format!(\"{:p}\", b.as_ptr()));\n}\n\n#[test]\nfn test_estimated_capacity() {\n    assert_eq!(format_args!(\"\").estimated_capacity(), 0);\n    assert_eq!(format_args!(\"{}\", \"\").estimated_capacity(), 0);\n    assert_eq!(format_args!(\"Hello\").estimated_capacity(), 5);\n    assert_eq!(format_args!(\"Hello, {}!\", \"\").estimated_capacity(), 16);\n    assert_eq!(format_args!(\"{}, hello!\", \"World\").estimated_capacity(), 0);\n    assert_eq!(format_args!(\"{}. 16-bytes piece\", \"World\").estimated_capacity(), 32);\n}\n\n#[test]\nfn pad_integral_resets() {\n    struct Bar;\n\n    impl core::fmt::Display for Bar {\n        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n            \"1\".fmt(f)?;\n            f.pad_integral(true, \"\", \"5\")?;\n            \"1\".fmt(f)\n        }\n    }\n\n    assert_eq!(format!(\"{:<03}\", Bar), \"1  0051  \");\n}\n"],[2946,"#[test]\nfn test_format_int() {\n    // Formatting integers should select the right implementation based off\n    // the type of the argument. Also, hex/octal/binary should be defined\n    // for integers, but they shouldn't emit the negative sign.\n    assert_eq!(format!(\"{}\", 1isize), \"1\");\n    assert_eq!(format!(\"{}\", 1i8), \"1\");\n    assert_eq!(format!(\"{}\", 1i16), \"1\");\n    assert_eq!(format!(\"{}\", 1i32), \"1\");\n    assert_eq!(format!(\"{}\", 1i64), \"1\");\n    assert_eq!(format!(\"{}\", -1isize), \"-1\");\n    assert_eq!(format!(\"{}\", -1i8), \"-1\");\n    assert_eq!(format!(\"{}\", -1i16), \"-1\");\n    assert_eq!(format!(\"{}\", -1i32), \"-1\");\n    assert_eq!(format!(\"{}\", -1i64), \"-1\");\n    assert_eq!(format!(\"{:?}\", 1isize), \"1\");\n    assert_eq!(format!(\"{:?}\", 1i8), \"1\");\n    assert_eq!(format!(\"{:?}\", 1i16), \"1\");\n    assert_eq!(format!(\"{:?}\", 1i32), \"1\");\n    assert_eq!(format!(\"{:?}\", 1i64), \"1\");\n    assert_eq!(format!(\"{:b}\", 1isize), \"1\");\n    assert_eq!(format!(\"{:b}\", 1i8), \"1\");\n    assert_eq!(format!(\"{:b}\", 1i16), \"1\");\n    assert_eq!(format!(\"{:b}\", 1i32), \"1\");\n    assert_eq!(format!(\"{:b}\", 1i64), \"1\");\n    assert_eq!(format!(\"{:x}\", 1isize), \"1\");\n    assert_eq!(format!(\"{:x}\", 1i8), \"1\");\n    assert_eq!(format!(\"{:x}\", 1i16), \"1\");\n    assert_eq!(format!(\"{:x}\", 1i32), \"1\");\n    assert_eq!(format!(\"{:x}\", 1i64), \"1\");\n    assert_eq!(format!(\"{:X}\", 1isize), \"1\");\n    assert_eq!(format!(\"{:X}\", 1i8), \"1\");\n    assert_eq!(format!(\"{:X}\", 1i16), \"1\");\n    assert_eq!(format!(\"{:X}\", 1i32), \"1\");\n    assert_eq!(format!(\"{:X}\", 1i64), \"1\");\n    assert_eq!(format!(\"{:o}\", 1isize), \"1\");\n    assert_eq!(format!(\"{:o}\", 1i8), \"1\");\n    assert_eq!(format!(\"{:o}\", 1i16), \"1\");\n    assert_eq!(format!(\"{:o}\", 1i32), \"1\");\n    assert_eq!(format!(\"{:o}\", 1i64), \"1\");\n    assert_eq!(format!(\"{:e}\", 1isize), \"1e0\");\n    assert_eq!(format!(\"{:e}\", 1i8), \"1e0\");\n    assert_eq!(format!(\"{:e}\", 1i16), \"1e0\");\n    assert_eq!(format!(\"{:e}\", 1i32), \"1e0\");\n    assert_eq!(format!(\"{:e}\", 1i64), \"1e0\");\n    assert_eq!(format!(\"{:E}\", 1isize), \"1E0\");\n    assert_eq!(format!(\"{:E}\", 1i8), \"1E0\");\n    assert_eq!(format!(\"{:E}\", 1i16), \"1E0\");\n    assert_eq!(format!(\"{:E}\", 1i32), \"1E0\");\n    assert_eq!(format!(\"{:E}\", 1i64), \"1E0\");\n\n    assert_eq!(format!(\"{}\", 1usize), \"1\");\n    assert_eq!(format!(\"{}\", 1u8), \"1\");\n    assert_eq!(format!(\"{}\", 1u16), \"1\");\n    assert_eq!(format!(\"{}\", 1u32), \"1\");\n    assert_eq!(format!(\"{}\", 1u64), \"1\");\n    assert_eq!(format!(\"{:?}\", 1usize), \"1\");\n    assert_eq!(format!(\"{:?}\", 1u8), \"1\");\n    assert_eq!(format!(\"{:?}\", 1u16), \"1\");\n    assert_eq!(format!(\"{:?}\", 1u32), \"1\");\n    assert_eq!(format!(\"{:?}\", 1u64), \"1\");\n    assert_eq!(format!(\"{:b}\", 1usize), \"1\");\n    assert_eq!(format!(\"{:b}\", 1u8), \"1\");\n    assert_eq!(format!(\"{:b}\", 1u16), \"1\");\n    assert_eq!(format!(\"{:b}\", 1u32), \"1\");\n    assert_eq!(format!(\"{:b}\", 1u64), \"1\");\n    assert_eq!(format!(\"{:x}\", 1usize), \"1\");\n    assert_eq!(format!(\"{:x}\", 1u8), \"1\");\n    assert_eq!(format!(\"{:x}\", 1u16), \"1\");\n    assert_eq!(format!(\"{:x}\", 1u32), \"1\");\n    assert_eq!(format!(\"{:x}\", 1u64), \"1\");\n    assert_eq!(format!(\"{:X}\", 1usize), \"1\");\n    assert_eq!(format!(\"{:X}\", 1u8), \"1\");\n    assert_eq!(format!(\"{:X}\", 1u16), \"1\");\n    assert_eq!(format!(\"{:X}\", 1u32), \"1\");\n    assert_eq!(format!(\"{:X}\", 1u64), \"1\");\n    assert_eq!(format!(\"{:o}\", 1usize), \"1\");\n    assert_eq!(format!(\"{:o}\", 1u8), \"1\");\n    assert_eq!(format!(\"{:o}\", 1u16), \"1\");\n    assert_eq!(format!(\"{:o}\", 1u32), \"1\");\n    assert_eq!(format!(\"{:o}\", 1u64), \"1\");\n    assert_eq!(format!(\"{:e}\", 1u8), \"1e0\");\n    assert_eq!(format!(\"{:e}\", 1u16), \"1e0\");\n    assert_eq!(format!(\"{:e}\", 1u32), \"1e0\");\n    assert_eq!(format!(\"{:e}\", 1u64), \"1e0\");\n    assert_eq!(format!(\"{:E}\", 1u8), \"1E0\");\n    assert_eq!(format!(\"{:E}\", 1u16), \"1E0\");\n    assert_eq!(format!(\"{:E}\", 1u32), \"1E0\");\n    assert_eq!(format!(\"{:E}\", 1u64), \"1E0\");\n\n    // Test a larger number\n    assert_eq!(format!(\"{:b}\", 55), \"110111\");\n    assert_eq!(format!(\"{:o}\", 55), \"67\");\n    assert_eq!(format!(\"{}\", 55), \"55\");\n    assert_eq!(format!(\"{:x}\", 55), \"37\");\n    assert_eq!(format!(\"{:X}\", 55), \"37\");\n    assert_eq!(format!(\"{:e}\", 55), \"5.5e1\");\n    assert_eq!(format!(\"{:E}\", 55), \"5.5E1\");\n    assert_eq!(format!(\"{:e}\", 10000000000u64), \"1e10\");\n    assert_eq!(format!(\"{:E}\", 10000000000u64), \"1E10\");\n    assert_eq!(format!(\"{:e}\", 10000000001u64), \"1.0000000001e10\");\n    assert_eq!(format!(\"{:E}\", 10000000001u64), \"1.0000000001E10\");\n}\n\n#[test]\nfn test_format_int_exp_limits() {\n    assert_eq!(format!(\"{:e}\", i8::MIN), \"-1.28e2\");\n    assert_eq!(format!(\"{:e}\", i8::MAX), \"1.27e2\");\n    assert_eq!(format!(\"{:e}\", i16::MIN), \"-3.2768e4\");\n    assert_eq!(format!(\"{:e}\", i16::MAX), \"3.2767e4\");\n    assert_eq!(format!(\"{:e}\", i32::MIN), \"-2.147483648e9\");\n    assert_eq!(format!(\"{:e}\", i32::MAX), \"2.147483647e9\");\n    assert_eq!(format!(\"{:e}\", i64::MIN), \"-9.223372036854775808e18\");\n    assert_eq!(format!(\"{:e}\", i64::MAX), \"9.223372036854775807e18\");\n    assert_eq!(format!(\"{:e}\", i128::MIN), \"-1.70141183460469231731687303715884105728e38\");\n    assert_eq!(format!(\"{:e}\", i128::MAX), \"1.70141183460469231731687303715884105727e38\");\n\n    assert_eq!(format!(\"{:e}\", u8::MAX), \"2.55e2\");\n    assert_eq!(format!(\"{:e}\", u16::MAX), \"6.5535e4\");\n    assert_eq!(format!(\"{:e}\", u32::MAX), \"4.294967295e9\");\n    assert_eq!(format!(\"{:e}\", u64::MAX), \"1.8446744073709551615e19\");\n    assert_eq!(format!(\"{:e}\", u128::MAX), \"3.40282366920938463463374607431768211455e38\");\n}\n\n#[test]\nfn test_format_int_exp_precision() {\n    //test that float and integer match\n    let big_int: u32 = 314_159_265;\n    assert_eq!(format!(\"{:.1e}\", big_int), format!(\"{:.1e}\", f64::from(big_int)));\n\n    //test adding precision\n    assert_eq!(format!(\"{:.10e}\", i8::MIN), \"-1.2800000000e2\");\n    assert_eq!(format!(\"{:.10e}\", i16::MIN), \"-3.2768000000e4\");\n    assert_eq!(format!(\"{:.10e}\", i32::MIN), \"-2.1474836480e9\");\n    assert_eq!(format!(\"{:.20e}\", i64::MIN), \"-9.22337203685477580800e18\");\n    assert_eq!(format!(\"{:.40e}\", i128::MIN), \"-1.7014118346046923173168730371588410572800e38\");\n\n    //test rounding\n    assert_eq!(format!(\"{:.1e}\", i8::MIN), \"-1.3e2\");\n    assert_eq!(format!(\"{:.1e}\", i16::MIN), \"-3.3e4\");\n    assert_eq!(format!(\"{:.1e}\", i32::MIN), \"-2.1e9\");\n    assert_eq!(format!(\"{:.1e}\", i64::MIN), \"-9.2e18\");\n    assert_eq!(format!(\"{:.1e}\", i128::MIN), \"-1.7e38\");\n\n    //test huge precision\n    assert_eq!(format!(\"{:.1000e}\", 1), format!(\"1.{}e0\", \"0\".repeat(1000)));\n    //test zero precision\n    assert_eq!(format!(\"{:.0e}\", 1), format!(\"1e0\",));\n\n    //test padding with precision (and sign)\n    assert_eq!(format!(\"{:+10.3e}\", 1), \"  +1.000e0\");\n}\n\n#[test]\nfn test_format_int_zero() {\n    assert_eq!(format!(\"{}\", 0), \"0\");\n    assert_eq!(format!(\"{:?}\", 0), \"0\");\n    assert_eq!(format!(\"{:b}\", 0), \"0\");\n    assert_eq!(format!(\"{:o}\", 0), \"0\");\n    assert_eq!(format!(\"{:x}\", 0), \"0\");\n    assert_eq!(format!(\"{:X}\", 0), \"0\");\n    assert_eq!(format!(\"{:e}\", 0), \"0e0\");\n    assert_eq!(format!(\"{:E}\", 0), \"0E0\");\n\n    assert_eq!(format!(\"{}\", 0u32), \"0\");\n    assert_eq!(format!(\"{:?}\", 0u32), \"0\");\n    assert_eq!(format!(\"{:b}\", 0u32), \"0\");\n    assert_eq!(format!(\"{:o}\", 0u32), \"0\");\n    assert_eq!(format!(\"{:x}\", 0u32), \"0\");\n    assert_eq!(format!(\"{:X}\", 0u32), \"0\");\n    assert_eq!(format!(\"{:e}\", 0u32), \"0e0\");\n    assert_eq!(format!(\"{:E}\", 0u32), \"0E0\");\n}\n\n#[test]\nfn test_format_int_flags() {\n    assert_eq!(format!(\"{:3}\", 1), \"  1\");\n    assert_eq!(format!(\"{:>3}\", 1), \"  1\");\n    assert_eq!(format!(\"{:>+3}\", 1), \" +1\");\n    assert_eq!(format!(\"{:<3}\", 1), \"1  \");\n    assert_eq!(format!(\"{:#}\", 1), \"1\");\n    assert_eq!(format!(\"{:#x}\", 10), \"0xa\");\n    assert_eq!(format!(\"{:#X}\", 10), \"0xA\");\n    assert_eq!(format!(\"{:#5x}\", 10), \"  0xa\");\n    assert_eq!(format!(\"{:#o}\", 10), \"0o12\");\n    assert_eq!(format!(\"{:08x}\", 10), \"0000000a\");\n    assert_eq!(format!(\"{:8x}\", 10), \"       a\");\n    assert_eq!(format!(\"{:<8x}\", 10), \"a       \");\n    assert_eq!(format!(\"{:>8x}\", 10), \"       a\");\n    assert_eq!(format!(\"{:#08x}\", 10), \"0x00000a\");\n    assert_eq!(format!(\"{:08}\", -10), \"-0000010\");\n    assert_eq!(format!(\"{:x}\", !0u8), \"ff\");\n    assert_eq!(format!(\"{:X}\", !0u8), \"FF\");\n    assert_eq!(format!(\"{:b}\", !0u8), \"11111111\");\n    assert_eq!(format!(\"{:o}\", !0u8), \"377\");\n    assert_eq!(format!(\"{:#x}\", !0u8), \"0xff\");\n    assert_eq!(format!(\"{:#X}\", !0u8), \"0xFF\");\n    assert_eq!(format!(\"{:#b}\", !0u8), \"0b11111111\");\n    assert_eq!(format!(\"{:#o}\", !0u8), \"0o377\");\n}\n\n#[test]\nfn test_format_int_sign_padding() {\n    assert_eq!(format!(\"{:+5}\", 1), \"   +1\");\n    assert_eq!(format!(\"{:+5}\", -1), \"   -1\");\n    assert_eq!(format!(\"{:05}\", 1), \"00001\");\n    assert_eq!(format!(\"{:05}\", -1), \"-0001\");\n    assert_eq!(format!(\"{:+05}\", 1), \"+0001\");\n    assert_eq!(format!(\"{:+05}\", -1), \"-0001\");\n}\n\n#[test]\nfn test_format_int_twos_complement() {\n    assert_eq!(format!(\"{}\", i8::MIN), \"-128\");\n    assert_eq!(format!(\"{}\", i16::MIN), \"-32768\");\n    assert_eq!(format!(\"{}\", i32::MIN), \"-2147483648\");\n    assert_eq!(format!(\"{}\", i64::MIN), \"-9223372036854775808\");\n}\n\n#[test]\nfn test_format_debug_hex() {\n    assert_eq!(format!(\"{:02x?}\", b\"Foo\\0\"), \"[46, 6f, 6f, 00]\");\n    assert_eq!(format!(\"{:02X?}\", b\"Foo\\0\"), \"[46, 6F, 6F, 00]\");\n}\n"],[2947,"mod debug_struct {\n    use std::fmt;\n\n    #[test]\n    fn test_empty() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_struct(\"Foo\").finish()\n            }\n        }\n\n        assert_eq!(\"Foo\", format!(\"{:?}\", Foo));\n        assert_eq!(\"Foo\", format!(\"{:#?}\", Foo));\n    }\n\n    #[test]\n    fn test_single() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_struct(\"Foo\").field(\"bar\", &true).finish()\n            }\n        }\n\n        assert_eq!(\"Foo { bar: true }\", format!(\"{:?}\", Foo));\n        assert_eq!(\n            \"Foo {\n    bar: true,\n}\",\n            format!(\"{:#?}\", Foo)\n        );\n    }\n\n    #[test]\n    fn test_multiple() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_struct(\"Foo\")\n                    .field(\"bar\", &true)\n                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n                    .finish()\n            }\n        }\n\n        assert_eq!(\"Foo { bar: true, baz: 10/20 }\", format!(\"{:?}\", Foo));\n        assert_eq!(\n            \"Foo {\n    bar: true,\n    baz: 10/20,\n}\",\n            format!(\"{:#?}\", Foo)\n        );\n    }\n\n    #[test]\n    fn test_nested() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_struct(\"Foo\")\n                    .field(\"bar\", &true)\n                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n                    .finish()\n            }\n        }\n\n        struct Bar;\n\n        impl fmt::Debug for Bar {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_struct(\"Bar\").field(\"foo\", &Foo).field(\"hello\", &\"world\").finish()\n            }\n        }\n\n        assert_eq!(\n            \"Bar { foo: Foo { bar: true, baz: 10/20 }, hello: \\\"world\\\" }\",\n            format!(\"{:?}\", Bar)\n        );\n        assert_eq!(\n            \"Bar {\n    foo: Foo {\n        bar: true,\n        baz: 10/20,\n    },\n    hello: \\\"world\\\",\n}\",\n            format!(\"{:#?}\", Bar)\n        );\n    }\n\n    #[test]\n    fn test_only_non_exhaustive() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_struct(\"Foo\").finish_non_exhaustive()\n            }\n        }\n\n        assert_eq!(\"Foo { .. }\", format!(\"{:?}\", Foo));\n        assert_eq!(\"Foo { .. }\", format!(\"{:#?}\", Foo));\n    }\n\n    #[test]\n    fn test_multiple_and_non_exhaustive() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_struct(\"Foo\")\n                    .field(\"bar\", &true)\n                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n                    .finish_non_exhaustive()\n            }\n        }\n\n        assert_eq!(\"Foo { bar: true, baz: 10/20, .. }\", format!(\"{:?}\", Foo));\n        assert_eq!(\n            \"Foo {\n    bar: true,\n    baz: 10/20,\n    ..\n}\",\n            format!(\"{:#?}\", Foo)\n        );\n    }\n\n    #[test]\n    fn test_nested_non_exhaustive() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_struct(\"Foo\")\n                    .field(\"bar\", &true)\n                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n                    .finish_non_exhaustive()\n            }\n        }\n\n        struct Bar;\n\n        impl fmt::Debug for Bar {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_struct(\"Bar\")\n                    .field(\"foo\", &Foo)\n                    .field(\"hello\", &\"world\")\n                    .finish_non_exhaustive()\n            }\n        }\n\n        assert_eq!(\n            \"Bar { foo: Foo { bar: true, baz: 10/20, .. }, hello: \\\"world\\\", .. }\",\n            format!(\"{:?}\", Bar)\n        );\n        assert_eq!(\n            \"Bar {\n    foo: Foo {\n        bar: true,\n        baz: 10/20,\n        ..\n    },\n    hello: \\\"world\\\",\n    ..\n}\",\n            format!(\"{:#?}\", Bar)\n        );\n    }\n}\n\nmod debug_tuple {\n    use std::fmt;\n\n    #[test]\n    fn test_empty() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_tuple(\"Foo\").finish()\n            }\n        }\n\n        assert_eq!(\"Foo\", format!(\"{:?}\", Foo));\n        assert_eq!(\"Foo\", format!(\"{:#?}\", Foo));\n    }\n\n    #[test]\n    fn test_single() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_tuple(\"Foo\").field(&true).finish()\n            }\n        }\n\n        assert_eq!(\"Foo(true)\", format!(\"{:?}\", Foo));\n        assert_eq!(\n            \"Foo(\n    true,\n)\",\n            format!(\"{:#?}\", Foo)\n        );\n    }\n\n    #[test]\n    fn test_multiple() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_tuple(\"Foo\").field(&true).field(&format_args!(\"{}/{}\", 10, 20)).finish()\n            }\n        }\n\n        assert_eq!(\"Foo(true, 10/20)\", format!(\"{:?}\", Foo));\n        assert_eq!(\n            \"Foo(\n    true,\n    10/20,\n)\",\n            format!(\"{:#?}\", Foo)\n        );\n    }\n\n    #[test]\n    fn test_nested() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_tuple(\"Foo\").field(&true).field(&format_args!(\"{}/{}\", 10, 20)).finish()\n            }\n        }\n\n        struct Bar;\n\n        impl fmt::Debug for Bar {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_tuple(\"Bar\").field(&Foo).field(&\"world\").finish()\n            }\n        }\n\n        assert_eq!(\"Bar(Foo(true, 10/20), \\\"world\\\")\", format!(\"{:?}\", Bar));\n        assert_eq!(\n            \"Bar(\n    Foo(\n        true,\n        10/20,\n    ),\n    \\\"world\\\",\n)\",\n            format!(\"{:#?}\", Bar)\n        );\n    }\n}\n\nmod debug_map {\n    use std::fmt;\n\n    #[test]\n    fn test_empty() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map().finish()\n            }\n        }\n\n        assert_eq!(\"{}\", format!(\"{:?}\", Foo));\n        assert_eq!(\"{}\", format!(\"{:#?}\", Foo));\n    }\n\n    #[test]\n    fn test_single() {\n        struct Entry;\n\n        impl fmt::Debug for Entry {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map().entry(&\"bar\", &true).finish()\n            }\n        }\n\n        struct KeyValue;\n\n        impl fmt::Debug for KeyValue {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map().key(&\"bar\").value(&true).finish()\n            }\n        }\n\n        assert_eq!(format!(\"{:?}\", Entry), format!(\"{:?}\", KeyValue));\n        assert_eq!(format!(\"{:#?}\", Entry), format!(\"{:#?}\", KeyValue));\n\n        assert_eq!(\"{\\\"bar\\\": true}\", format!(\"{:?}\", Entry));\n        assert_eq!(\n            \"{\n    \\\"bar\\\": true,\n}\",\n            format!(\"{:#?}\", Entry)\n        );\n    }\n\n    #[test]\n    fn test_multiple() {\n        struct Entry;\n\n        impl fmt::Debug for Entry {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map()\n                    .entry(&\"bar\", &true)\n                    .entry(&10, &format_args!(\"{}/{}\", 10, 20))\n                    .finish()\n            }\n        }\n\n        struct KeyValue;\n\n        impl fmt::Debug for KeyValue {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map()\n                    .key(&\"bar\")\n                    .value(&true)\n                    .key(&10)\n                    .value(&format_args!(\"{}/{}\", 10, 20))\n                    .finish()\n            }\n        }\n\n        assert_eq!(format!(\"{:?}\", Entry), format!(\"{:?}\", KeyValue));\n        assert_eq!(format!(\"{:#?}\", Entry), format!(\"{:#?}\", KeyValue));\n\n        assert_eq!(\"{\\\"bar\\\": true, 10: 10/20}\", format!(\"{:?}\", Entry));\n        assert_eq!(\n            \"{\n    \\\"bar\\\": true,\n    10: 10/20,\n}\",\n            format!(\"{:#?}\", Entry)\n        );\n    }\n\n    #[test]\n    fn test_nested() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map()\n                    .entry(&\"bar\", &true)\n                    .entry(&10, &format_args!(\"{}/{}\", 10, 20))\n                    .finish()\n            }\n        }\n\n        struct Bar;\n\n        impl fmt::Debug for Bar {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map().entry(&\"foo\", &Foo).entry(&Foo, &\"world\").finish()\n            }\n        }\n\n        assert_eq!(\n            \"{\\\"foo\\\": {\\\"bar\\\": true, 10: 10/20}, \\\n                    {\\\"bar\\\": true, 10: 10/20}: \\\"world\\\"}\",\n            format!(\"{:?}\", Bar)\n        );\n        assert_eq!(\n            \"{\n    \\\"foo\\\": {\n        \\\"bar\\\": true,\n        10: 10/20,\n    },\n    {\n        \\\"bar\\\": true,\n        10: 10/20,\n    }: \\\"world\\\",\n}\",\n            format!(\"{:#?}\", Bar)\n        );\n    }\n\n    #[test]\n    fn test_entry_err() {\n        // Ensure errors in a map entry don't trigger panics (#65231)\n        use std::fmt::Write;\n\n        struct ErrorFmt;\n\n        impl fmt::Debug for ErrorFmt {\n            fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n                Err(fmt::Error)\n            }\n        }\n\n        struct KeyValue<K, V>(usize, K, V);\n\n        impl<K, V> fmt::Debug for KeyValue<K, V>\n        where\n            K: fmt::Debug,\n            V: fmt::Debug,\n        {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                let mut map = fmt.debug_map();\n\n                for _ in 0..self.0 {\n                    map.entry(&self.1, &self.2);\n                }\n\n                map.finish()\n            }\n        }\n\n        let mut buf = String::new();\n\n        assert!(write!(&mut buf, \"{:?}\", KeyValue(1, ErrorFmt, \"bar\")).is_err());\n        assert!(write!(&mut buf, \"{:?}\", KeyValue(1, \"foo\", ErrorFmt)).is_err());\n\n        assert!(write!(&mut buf, \"{:?}\", KeyValue(2, ErrorFmt, \"bar\")).is_err());\n        assert!(write!(&mut buf, \"{:?}\", KeyValue(2, \"foo\", ErrorFmt)).is_err());\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_invalid_key_when_entry_is_incomplete() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map().key(&\"bar\").key(&\"invalid\").finish()\n            }\n        }\n\n        format!(\"{:?}\", Foo);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_invalid_finish_incomplete_entry() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map().key(&\"bar\").finish()\n            }\n        }\n\n        format!(\"{:?}\", Foo);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_invalid_value_before_key() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_map().value(&\"invalid\").key(&\"bar\").finish()\n            }\n        }\n\n        format!(\"{:?}\", Foo);\n    }\n}\n\nmod debug_set {\n    use std::fmt;\n\n    #[test]\n    fn test_empty() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_set().finish()\n            }\n        }\n\n        assert_eq!(\"{}\", format!(\"{:?}\", Foo));\n        assert_eq!(\"{}\", format!(\"{:#?}\", Foo));\n    }\n\n    #[test]\n    fn test_single() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_set().entry(&true).finish()\n            }\n        }\n\n        assert_eq!(\"{true}\", format!(\"{:?}\", Foo));\n        assert_eq!(\n            \"{\n    true,\n}\",\n            format!(\"{:#?}\", Foo)\n        );\n    }\n\n    #[test]\n    fn test_multiple() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_set().entry(&true).entry(&format_args!(\"{}/{}\", 10, 20)).finish()\n            }\n        }\n\n        assert_eq!(\"{true, 10/20}\", format!(\"{:?}\", Foo));\n        assert_eq!(\n            \"{\n    true,\n    10/20,\n}\",\n            format!(\"{:#?}\", Foo)\n        );\n    }\n\n    #[test]\n    fn test_nested() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_set().entry(&true).entry(&format_args!(\"{}/{}\", 10, 20)).finish()\n            }\n        }\n\n        struct Bar;\n\n        impl fmt::Debug for Bar {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_set().entry(&Foo).entry(&\"world\").finish()\n            }\n        }\n\n        assert_eq!(\"{{true, 10/20}, \\\"world\\\"}\", format!(\"{:?}\", Bar));\n        assert_eq!(\n            \"{\n    {\n        true,\n        10/20,\n    },\n    \\\"world\\\",\n}\",\n            format!(\"{:#?}\", Bar)\n        );\n    }\n}\n\nmod debug_list {\n    use std::fmt;\n\n    #[test]\n    fn test_empty() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_list().finish()\n            }\n        }\n\n        assert_eq!(\"[]\", format!(\"{:?}\", Foo));\n        assert_eq!(\"[]\", format!(\"{:#?}\", Foo));\n    }\n\n    #[test]\n    fn test_single() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_list().entry(&true).finish()\n            }\n        }\n\n        assert_eq!(\"[true]\", format!(\"{:?}\", Foo));\n        assert_eq!(\n            \"[\n    true,\n]\",\n            format!(\"{:#?}\", Foo)\n        );\n    }\n\n    #[test]\n    fn test_multiple() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_list().entry(&true).entry(&format_args!(\"{}/{}\", 10, 20)).finish()\n            }\n        }\n\n        assert_eq!(\"[true, 10/20]\", format!(\"{:?}\", Foo));\n        assert_eq!(\n            \"[\n    true,\n    10/20,\n]\",\n            format!(\"{:#?}\", Foo)\n        );\n    }\n\n    #[test]\n    fn test_nested() {\n        struct Foo;\n\n        impl fmt::Debug for Foo {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_list().entry(&true).entry(&format_args!(\"{}/{}\", 10, 20)).finish()\n            }\n        }\n\n        struct Bar;\n\n        impl fmt::Debug for Bar {\n            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt.debug_list().entry(&Foo).entry(&\"world\").finish()\n            }\n        }\n\n        assert_eq!(\"[[true, 10/20], \\\"world\\\"]\", format!(\"{:?}\", Bar));\n        assert_eq!(\n            \"[\n    [\n        true,\n        10/20,\n    ],\n    \\\"world\\\",\n]\",\n            format!(\"{:#?}\", Bar)\n        );\n    }\n}\n\n#[test]\nfn test_formatting_parameters_are_forwarded() {\n    use std::collections::{BTreeMap, BTreeSet};\n    #[derive(Debug)]\n    struct Foo {\n        bar: u32,\n        baz: u32,\n    }\n    let struct_ = Foo { bar: 1024, baz: 7 };\n    let tuple = (1024, 7);\n    let list = [1024, 7];\n    let mut map = BTreeMap::new();\n    map.insert(\"bar\", 1024);\n    map.insert(\"baz\", 7);\n    let mut set = BTreeSet::new();\n    set.insert(1024);\n    set.insert(7);\n\n    assert_eq!(format!(\"{:03?}\", struct_), \"Foo { bar: 1024, baz: 007 }\");\n    assert_eq!(format!(\"{:03?}\", tuple), \"(1024, 007)\");\n    assert_eq!(format!(\"{:03?}\", list), \"[1024, 007]\");\n    assert_eq!(format!(\"{:03?}\", map), r#\"{\"bar\": 1024, \"baz\": 007}\"#);\n    assert_eq!(format!(\"{:03?}\", set), \"{007, 1024}\");\n    assert_eq!(\n        format!(\"{:#03?}\", struct_),\n        \"\nFoo {\n    bar: 1024,\n    baz: 007,\n}\n    \"\n        .trim()\n    );\n    assert_eq!(\n        format!(\"{:#03?}\", tuple),\n        \"\n(\n    1024,\n    007,\n)\n    \"\n        .trim()\n    );\n    assert_eq!(\n        format!(\"{:#03?}\", list),\n        \"\n[\n    1024,\n    007,\n]\n    \"\n        .trim()\n    );\n    assert_eq!(\n        format!(\"{:#03?}\", map),\n        r#\"\n{\n    \"bar\": 1024,\n    \"baz\": 007,\n}\n    \"#\n        .trim()\n    );\n    assert_eq!(\n        format!(\"{:#03?}\", set),\n        \"\n{\n    007,\n    1024,\n}\n    \"\n        .trim()\n    );\n}\n"],[2948,"#[test]\nfn test_format_f64() {\n    assert_eq!(\"1\", format!(\"{:.0}\", 1.0f64));\n    assert_eq!(\"9\", format!(\"{:.0}\", 9.4f64));\n    assert_eq!(\"10\", format!(\"{:.0}\", 9.9f64));\n    assert_eq!(\"9.8\", format!(\"{:.1}\", 9.849f64));\n    assert_eq!(\"9.9\", format!(\"{:.1}\", 9.851f64));\n    assert_eq!(\"1\", format!(\"{:.0}\", 0.5f64));\n    assert_eq!(\"1.23456789e6\", format!(\"{:e}\", 1234567.89f64));\n    assert_eq!(\"1.23456789e3\", format!(\"{:e}\", 1234.56789f64));\n    assert_eq!(\"1.23456789E6\", format!(\"{:E}\", 1234567.89f64));\n    assert_eq!(\"1.23456789E3\", format!(\"{:E}\", 1234.56789f64));\n    assert_eq!(\"0.0\", format!(\"{:?}\", 0.0f64));\n    assert_eq!(\"1.01\", format!(\"{:?}\", 1.01f64));\n}\n\n#[test]\nfn test_format_f32() {\n    assert_eq!(\"1\", format!(\"{:.0}\", 1.0f32));\n    assert_eq!(\"9\", format!(\"{:.0}\", 9.4f32));\n    assert_eq!(\"10\", format!(\"{:.0}\", 9.9f32));\n    assert_eq!(\"9.8\", format!(\"{:.1}\", 9.849f32));\n    assert_eq!(\"9.9\", format!(\"{:.1}\", 9.851f32));\n    assert_eq!(\"1\", format!(\"{:.0}\", 0.5f32));\n    assert_eq!(\"1.2345679e6\", format!(\"{:e}\", 1234567.89f32));\n    assert_eq!(\"1.2345679e3\", format!(\"{:e}\", 1234.56789f32));\n    assert_eq!(\"1.2345679E6\", format!(\"{:E}\", 1234567.89f32));\n    assert_eq!(\"1.2345679E3\", format!(\"{:E}\", 1234.56789f32));\n    assert_eq!(\"0.0\", format!(\"{:?}\", 0.0f32));\n    assert_eq!(\"1.01\", format!(\"{:?}\", 1.01f32));\n}\n"],[2949,"use core::mem::*;\n\n#[cfg(panic = \"unwind\")]\nuse std::rc::Rc;\n\n#[test]\nfn size_of_basic() {\n    assert_eq!(size_of::<u8>(), 1);\n    assert_eq!(size_of::<u16>(), 2);\n    assert_eq!(size_of::<u32>(), 4);\n    assert_eq!(size_of::<u64>(), 8);\n}\n\n#[test]\n#[cfg(target_pointer_width = \"16\")]\nfn size_of_16() {\n    assert_eq!(size_of::<usize>(), 2);\n    assert_eq!(size_of::<*const usize>(), 2);\n}\n\n#[test]\n#[cfg(target_pointer_width = \"32\")]\nfn size_of_32() {\n    assert_eq!(size_of::<usize>(), 4);\n    assert_eq!(size_of::<*const usize>(), 4);\n}\n\n#[test]\n#[cfg(target_pointer_width = \"64\")]\nfn size_of_64() {\n    assert_eq!(size_of::<usize>(), 8);\n    assert_eq!(size_of::<*const usize>(), 8);\n}\n\n#[test]\nfn size_of_val_basic() {\n    assert_eq!(size_of_val(&1u8), 1);\n    assert_eq!(size_of_val(&1u16), 2);\n    assert_eq!(size_of_val(&1u32), 4);\n    assert_eq!(size_of_val(&1u64), 8);\n}\n\n#[test]\nfn align_of_basic() {\n    assert_eq!(align_of::<u8>(), 1);\n    assert_eq!(align_of::<u16>(), 2);\n    assert_eq!(align_of::<u32>(), 4);\n}\n\n#[test]\n#[cfg(target_pointer_width = \"16\")]\nfn align_of_16() {\n    assert_eq!(align_of::<usize>(), 2);\n    assert_eq!(align_of::<*const usize>(), 2);\n}\n\n#[test]\n#[cfg(target_pointer_width = \"32\")]\nfn align_of_32() {\n    assert_eq!(align_of::<usize>(), 4);\n    assert_eq!(align_of::<*const usize>(), 4);\n}\n\n#[test]\n#[cfg(target_pointer_width = \"64\")]\nfn align_of_64() {\n    assert_eq!(align_of::<usize>(), 8);\n    assert_eq!(align_of::<*const usize>(), 8);\n}\n\n#[test]\nfn align_of_val_basic() {\n    assert_eq!(align_of_val(&1u8), 1);\n    assert_eq!(align_of_val(&1u16), 2);\n    assert_eq!(align_of_val(&1u32), 4);\n}\n\n#[test]\nfn test_swap() {\n    let mut x = 31337;\n    let mut y = 42;\n    swap(&mut x, &mut y);\n    assert_eq!(x, 42);\n    assert_eq!(y, 31337);\n}\n\n#[test]\nfn test_replace() {\n    let mut x = Some(\"test\".to_string());\n    let y = replace(&mut x, None);\n    assert!(x.is_none());\n    assert!(y.is_some());\n}\n\n#[test]\nfn test_transmute_copy() {\n    assert_eq!(1, unsafe { transmute_copy(&1) });\n}\n\n// Remove this test when `std::raw` is removed.\n// The replacement pointer metadata APIs are tested in library/core/tests/ptr.rs\n#[allow(deprecated)]\n#[test]\nfn test_transmute() {\n    trait Foo {\n        fn dummy(&self) {}\n    }\n    impl Foo for isize {}\n\n    let a = box 100isize as Box<dyn Foo>;\n    unsafe {\n        let x: ::core::raw::TraitObject = transmute(a);\n        assert!(*(x.data as *const isize) == 100);\n        let _x: Box<dyn Foo> = transmute(x);\n    }\n\n    unsafe {\n        assert_eq!(transmute::<_, Vec<u8>>(\"L\".to_string()), [76]);\n    }\n}\n\n#[test]\n#[allow(dead_code)]\nfn test_discriminant_send_sync() {\n    enum Regular {\n        A,\n        B(i32),\n    }\n    enum NotSendSync {\n        A(*const i32),\n    }\n\n    fn is_send_sync<T: Send + Sync>() {}\n\n    is_send_sync::<Discriminant<Regular>>();\n    is_send_sync::<Discriminant<NotSendSync>>();\n}\n\n#[test]\nfn assume_init_good() {\n    const TRUE: bool = unsafe { MaybeUninit::<bool>::new(true).assume_init() };\n\n    assert!(TRUE);\n}\n\n#[test]\nfn uninit_array_assume_init() {\n    let mut array: [MaybeUninit<i16>; 5] = MaybeUninit::uninit_array();\n    array[0].write(3);\n    array[1].write(1);\n    array[2].write(4);\n    array[3].write(1);\n    array[4].write(5);\n\n    let array = unsafe { MaybeUninit::array_assume_init(array) };\n\n    assert_eq!(array, [3, 1, 4, 1, 5]);\n\n    let [] = unsafe { MaybeUninit::<!>::array_assume_init([]) };\n}\n\n#[test]\nfn uninit_write_slice() {\n    let mut dst = [MaybeUninit::new(255); 64];\n    let src = [0; 64];\n\n    assert_eq!(MaybeUninit::write_slice(&mut dst, &src), &src);\n}\n\n#[test]\n#[should_panic(expected = \"source slice length (32) does not match destination slice length (64)\")]\nfn uninit_write_slice_panic_lt() {\n    let mut dst = [MaybeUninit::uninit(); 64];\n    let src = [0; 32];\n\n    MaybeUninit::write_slice(&mut dst, &src);\n}\n\n#[test]\n#[should_panic(expected = \"source slice length (128) does not match destination slice length (64)\")]\nfn uninit_write_slice_panic_gt() {\n    let mut dst = [MaybeUninit::uninit(); 64];\n    let src = [0; 128];\n\n    MaybeUninit::write_slice(&mut dst, &src);\n}\n\n#[test]\nfn uninit_clone_from_slice() {\n    let mut dst = [MaybeUninit::new(255); 64];\n    let src = [0; 64];\n\n    assert_eq!(MaybeUninit::write_slice_cloned(&mut dst, &src), &src);\n}\n\n#[test]\n#[should_panic(expected = \"destination and source slices have different lengths\")]\nfn uninit_write_slice_cloned_panic_lt() {\n    let mut dst = [MaybeUninit::uninit(); 64];\n    let src = [0; 32];\n\n    MaybeUninit::write_slice_cloned(&mut dst, &src);\n}\n\n#[test]\n#[should_panic(expected = \"destination and source slices have different lengths\")]\nfn uninit_write_slice_cloned_panic_gt() {\n    let mut dst = [MaybeUninit::uninit(); 64];\n    let src = [0; 128];\n\n    MaybeUninit::write_slice_cloned(&mut dst, &src);\n}\n\n#[test]\n#[cfg(panic = \"unwind\")]\nfn uninit_write_slice_cloned_mid_panic() {\n    use std::panic;\n\n    enum IncrementOrPanic {\n        Increment(Rc<()>),\n        ExpectedPanic,\n        UnexpectedPanic,\n    }\n\n    impl Clone for IncrementOrPanic {\n        fn clone(&self) -> Self {\n            match self {\n                Self::Increment(rc) => Self::Increment(rc.clone()),\n                Self::ExpectedPanic => panic!(\"expected panic on clone\"),\n                Self::UnexpectedPanic => panic!(\"unexpected panic on clone\"),\n            }\n        }\n    }\n\n    let rc = Rc::new(());\n\n    let mut dst = [\n        MaybeUninit::uninit(),\n        MaybeUninit::uninit(),\n        MaybeUninit::uninit(),\n        MaybeUninit::uninit(),\n    ];\n\n    let src = [\n        IncrementOrPanic::Increment(rc.clone()),\n        IncrementOrPanic::Increment(rc.clone()),\n        IncrementOrPanic::ExpectedPanic,\n        IncrementOrPanic::UnexpectedPanic,\n    ];\n\n    let err = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n        MaybeUninit::write_slice_cloned(&mut dst, &src);\n    }));\n\n    drop(src);\n\n    match err {\n        Ok(_) => unreachable!(),\n        Err(payload) => {\n            payload\n                .downcast::<&'static str>()\n                .and_then(|s| if *s == \"expected panic on clone\" { Ok(s) } else { Err(s) })\n                .unwrap_or_else(|p| panic::resume_unwind(p));\n\n            assert_eq!(Rc::strong_count(&rc), 1)\n        }\n    }\n}\n\n#[test]\nfn uninit_write_slice_cloned_no_drop() {\n    #[derive(Clone)]\n    struct Bomb;\n\n    impl Drop for Bomb {\n        fn drop(&mut self) {\n            panic!(\"dropped a bomb! kaboom\")\n        }\n    }\n\n    let mut dst = [MaybeUninit::uninit()];\n    let src = [Bomb];\n\n    MaybeUninit::write_slice_cloned(&mut dst, &src);\n\n    forget(src);\n}\n\n#[test]\nfn uninit_const_assume_init_read() {\n    const FOO: u32 = unsafe { MaybeUninit::new(42).assume_init_read() };\n    assert_eq!(FOO, 42);\n}\n"],[2950,"use core::cell::RefCell;\nuse core::ptr;\nuse core::ptr::*;\nuse std::fmt::{Debug, Display};\n\n#[test]\nfn test_const_from_raw_parts() {\n    const SLICE: &[u8] = &[1, 2, 3, 4];\n    const FROM_RAW: &[u8] = unsafe { &*slice_from_raw_parts(SLICE.as_ptr(), SLICE.len()) };\n    assert_eq!(SLICE, FROM_RAW);\n\n    let slice = &[1, 2, 3, 4, 5];\n    let from_raw = unsafe { &*slice_from_raw_parts(slice.as_ptr(), 2) };\n    assert_eq!(&slice[..2], from_raw);\n}\n\n#[test]\nfn test() {\n    unsafe {\n        struct Pair {\n            fst: isize,\n            snd: isize,\n        }\n        let mut p = Pair { fst: 10, snd: 20 };\n        let pptr: *mut Pair = &mut p;\n        let iptr: *mut isize = pptr as *mut isize;\n        assert_eq!(*iptr, 10);\n        *iptr = 30;\n        assert_eq!(*iptr, 30);\n        assert_eq!(p.fst, 30);\n\n        *pptr = Pair { fst: 50, snd: 60 };\n        assert_eq!(*iptr, 50);\n        assert_eq!(p.fst, 50);\n        assert_eq!(p.snd, 60);\n\n        let v0 = vec![32000u16, 32001u16, 32002u16];\n        let mut v1 = vec![0u16, 0u16, 0u16];\n\n        copy(v0.as_ptr().offset(1), v1.as_mut_ptr().offset(1), 1);\n        assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n        copy(v0.as_ptr().offset(2), v1.as_mut_ptr(), 1);\n        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n        copy(v0.as_ptr(), v1.as_mut_ptr().offset(2), 1);\n        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16));\n    }\n}\n\n#[test]\nfn test_is_null() {\n    let p: *const isize = null();\n    assert!(p.is_null());\n\n    let q = p.wrapping_offset(1);\n    assert!(!q.is_null());\n\n    let mp: *mut isize = null_mut();\n    assert!(mp.is_null());\n\n    let mq = mp.wrapping_offset(1);\n    assert!(!mq.is_null());\n\n    // Pointers to unsized types -- slices\n    let s: &mut [u8] = &mut [1, 2, 3];\n    let cs: *const [u8] = s;\n    assert!(!cs.is_null());\n\n    let ms: *mut [u8] = s;\n    assert!(!ms.is_null());\n\n    let cz: *const [u8] = &[];\n    assert!(!cz.is_null());\n\n    let mz: *mut [u8] = &mut [];\n    assert!(!mz.is_null());\n\n    let ncs: *const [u8] = null::<[u8; 3]>();\n    assert!(ncs.is_null());\n\n    let nms: *mut [u8] = null_mut::<[u8; 3]>();\n    assert!(nms.is_null());\n\n    // Pointers to unsized types -- trait objects\n    let ci: *const dyn ToString = &3;\n    assert!(!ci.is_null());\n\n    let mi: *mut dyn ToString = &mut 3;\n    assert!(!mi.is_null());\n\n    let nci: *const dyn ToString = null::<isize>();\n    assert!(nci.is_null());\n\n    let nmi: *mut dyn ToString = null_mut::<isize>();\n    assert!(nmi.is_null());\n}\n\n#[test]\nfn test_as_ref() {\n    unsafe {\n        let p: *const isize = null();\n        assert_eq!(p.as_ref(), None);\n\n        let q: *const isize = &2;\n        assert_eq!(q.as_ref().unwrap(), &2);\n\n        let p: *mut isize = null_mut();\n        assert_eq!(p.as_ref(), None);\n\n        let q: *mut isize = &mut 2;\n        assert_eq!(q.as_ref().unwrap(), &2);\n\n        // Lifetime inference\n        let u = 2isize;\n        {\n            let p = &u as *const isize;\n            assert_eq!(p.as_ref().unwrap(), &2);\n        }\n\n        // Pointers to unsized types -- slices\n        let s: &mut [u8] = &mut [1, 2, 3];\n        let cs: *const [u8] = s;\n        assert_eq!(cs.as_ref(), Some(&*s));\n\n        let ms: *mut [u8] = s;\n        assert_eq!(ms.as_ref(), Some(&*s));\n\n        let cz: *const [u8] = &[];\n        assert_eq!(cz.as_ref(), Some(&[][..]));\n\n        let mz: *mut [u8] = &mut [];\n        assert_eq!(mz.as_ref(), Some(&[][..]));\n\n        let ncs: *const [u8] = null::<[u8; 3]>();\n        assert_eq!(ncs.as_ref(), None);\n\n        let nms: *mut [u8] = null_mut::<[u8; 3]>();\n        assert_eq!(nms.as_ref(), None);\n\n        // Pointers to unsized types -- trait objects\n        let ci: *const dyn ToString = &3;\n        assert!(ci.as_ref().is_some());\n\n        let mi: *mut dyn ToString = &mut 3;\n        assert!(mi.as_ref().is_some());\n\n        let nci: *const dyn ToString = null::<isize>();\n        assert!(nci.as_ref().is_none());\n\n        let nmi: *mut dyn ToString = null_mut::<isize>();\n        assert!(nmi.as_ref().is_none());\n    }\n}\n\n#[test]\nfn test_as_mut() {\n    unsafe {\n        let p: *mut isize = null_mut();\n        assert!(p.as_mut() == None);\n\n        let q: *mut isize = &mut 2;\n        assert!(q.as_mut().unwrap() == &mut 2);\n\n        // Lifetime inference\n        let mut u = 2isize;\n        {\n            let p = &mut u as *mut isize;\n            assert!(p.as_mut().unwrap() == &mut 2);\n        }\n\n        // Pointers to unsized types -- slices\n        let s: &mut [u8] = &mut [1, 2, 3];\n        let ms: *mut [u8] = s;\n        assert_eq!(ms.as_mut(), Some(&mut [1, 2, 3][..]));\n\n        let mz: *mut [u8] = &mut [];\n        assert_eq!(mz.as_mut(), Some(&mut [][..]));\n\n        let nms: *mut [u8] = null_mut::<[u8; 3]>();\n        assert_eq!(nms.as_mut(), None);\n\n        // Pointers to unsized types -- trait objects\n        let mi: *mut dyn ToString = &mut 3;\n        assert!(mi.as_mut().is_some());\n\n        let nmi: *mut dyn ToString = null_mut::<isize>();\n        assert!(nmi.as_mut().is_none());\n    }\n}\n\n#[test]\nfn test_ptr_addition() {\n    unsafe {\n        let xs = vec![5; 16];\n        let mut ptr = xs.as_ptr();\n        let end = ptr.offset(16);\n\n        while ptr < end {\n            assert_eq!(*ptr, 5);\n            ptr = ptr.offset(1);\n        }\n\n        let mut xs_mut = xs;\n        let mut m_ptr = xs_mut.as_mut_ptr();\n        let m_end = m_ptr.offset(16);\n\n        while m_ptr < m_end {\n            *m_ptr += 5;\n            m_ptr = m_ptr.offset(1);\n        }\n\n        assert!(xs_mut == vec![10; 16]);\n    }\n}\n\n#[test]\nfn test_ptr_subtraction() {\n    unsafe {\n        let xs = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n        let mut idx = 9;\n        let ptr = xs.as_ptr();\n\n        while idx >= 0 {\n            assert_eq!(*(ptr.offset(idx as isize)), idx as isize);\n            idx = idx - 1;\n        }\n\n        let mut xs_mut = xs;\n        let m_start = xs_mut.as_mut_ptr();\n        let mut m_ptr = m_start.offset(9);\n\n        loop {\n            *m_ptr += *m_ptr;\n            if m_ptr == m_start {\n                break;\n            }\n            m_ptr = m_ptr.offset(-1);\n        }\n\n        assert_eq!(xs_mut, [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]);\n    }\n}\n\n#[test]\nfn test_set_memory() {\n    let mut xs = [0u8; 20];\n    let ptr = xs.as_mut_ptr();\n    unsafe {\n        write_bytes(ptr, 5u8, xs.len());\n    }\n    assert!(xs == [5u8; 20]);\n}\n\n#[test]\nfn test_unsized_nonnull() {\n    let xs: &[i32] = &[1, 2, 3];\n    let ptr = unsafe { NonNull::new_unchecked(xs as *const [i32] as *mut [i32]) };\n    let ys = unsafe { ptr.as_ref() };\n    let zs: &[i32] = &[1, 2, 3];\n    assert!(ys == zs);\n}\n\n#[test]\n#[allow(warnings)]\n// Have a symbol for the test below. It doesn’t need to be an actual variadic function, match the\n// ABI, or even point to an actual executable code, because the function itself is never invoked.\n#[no_mangle]\npub fn test_variadic_fnptr() {\n    use core::hash::{Hash, SipHasher};\n    extern \"C\" {\n        fn test_variadic_fnptr(_: u64, ...) -> f64;\n    }\n    let p: unsafe extern \"C\" fn(u64, ...) -> f64 = test_variadic_fnptr;\n    let q = p.clone();\n    assert_eq!(p, q);\n    assert!(!(p < q));\n    let mut s = SipHasher::new();\n    assert_eq!(p.hash(&mut s), q.hash(&mut s));\n}\n\n#[test]\nfn write_unaligned_drop() {\n    thread_local! {\n        static DROPS: RefCell<Vec<u32>> = RefCell::new(Vec::new());\n    }\n\n    struct Dropper(u32);\n\n    impl Drop for Dropper {\n        fn drop(&mut self) {\n            DROPS.with(|d| d.borrow_mut().push(self.0));\n        }\n    }\n\n    {\n        let c = Dropper(0);\n        let mut t = Dropper(1);\n        unsafe {\n            write_unaligned(&mut t, c);\n        }\n    }\n    DROPS.with(|d| assert_eq!(*d.borrow(), [0]));\n}\n\n#[test]\nfn align_offset_zst() {\n    // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n    // all, because no amount of elements will align the pointer.\n    let mut p = 1;\n    while p < 1024 {\n        assert_eq!((p as *const ()).align_offset(p), 0);\n        if p != 1 {\n            assert_eq!(((p + 1) as *const ()).align_offset(p), !0);\n        }\n        p = (p + 1).next_power_of_two();\n    }\n}\n\n#[test]\nfn align_offset_stride1() {\n    // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n    // number of bytes.\n    let mut align = 1;\n    while align < 1024 {\n        for ptr in 1..2 * align {\n            let expected = ptr % align;\n            let offset = if expected == 0 { 0 } else { align - expected };\n            assert_eq!(\n                (ptr as *const u8).align_offset(align),\n                offset,\n                \"ptr = {}, align = {}, size = 1\",\n                ptr,\n                align\n            );\n        }\n        align = (align + 1).next_power_of_two();\n    }\n}\n\n#[test]\nfn align_offset_weird_strides() {\n    #[repr(packed)]\n    struct A3(u16, u8);\n    struct A4(u32);\n    #[repr(packed)]\n    struct A5(u32, u8);\n    #[repr(packed)]\n    struct A6(u32, u16);\n    #[repr(packed)]\n    struct A7(u32, u16, u8);\n    #[repr(packed)]\n    struct A8(u32, u32);\n    #[repr(packed)]\n    struct A9(u32, u32, u8);\n    #[repr(packed)]\n    struct A10(u32, u32, u16);\n\n    unsafe fn test_weird_stride<T>(ptr: *const T, align: usize) -> bool {\n        let numptr = ptr as usize;\n        let mut expected = usize::MAX;\n        // Naive but definitely correct way to find the *first* aligned element of stride::<T>.\n        for el in 0..align {\n            if (numptr + el * ::std::mem::size_of::<T>()) % align == 0 {\n                expected = el;\n                break;\n            }\n        }\n        let got = ptr.align_offset(align);\n        if got != expected {\n            eprintln!(\n                \"aligning {:p} (with stride of {}) to {}, expected {}, got {}\",\n                ptr,\n                ::std::mem::size_of::<T>(),\n                align,\n                expected,\n                got\n            );\n            return true;\n        }\n        return false;\n    }\n\n    // For pointers of stride != 1, we verify the algorithm against the naivest possible\n    // implementation\n    let mut align = 1;\n    let mut x = false;\n    // Miri is too slow\n    let limit = if cfg!(miri) { 32 } else { 1024 };\n    while align < limit {\n        for ptr in 1usize..4 * align {\n            unsafe {\n                x |= test_weird_stride::<A3>(ptr as *const A3, align);\n                x |= test_weird_stride::<A4>(ptr as *const A4, align);\n                x |= test_weird_stride::<A5>(ptr as *const A5, align);\n                x |= test_weird_stride::<A6>(ptr as *const A6, align);\n                x |= test_weird_stride::<A7>(ptr as *const A7, align);\n                x |= test_weird_stride::<A8>(ptr as *const A8, align);\n                x |= test_weird_stride::<A9>(ptr as *const A9, align);\n                x |= test_weird_stride::<A10>(ptr as *const A10, align);\n            }\n        }\n        align = (align + 1).next_power_of_two();\n    }\n    assert!(!x);\n}\n\n#[test]\nfn offset_from() {\n    let mut a = [0; 5];\n    let ptr1: *mut i32 = &mut a[1];\n    let ptr2: *mut i32 = &mut a[3];\n    unsafe {\n        assert_eq!(ptr2.offset_from(ptr1), 2);\n        assert_eq!(ptr1.offset_from(ptr2), -2);\n        assert_eq!(ptr1.offset(2), ptr2);\n        assert_eq!(ptr2.offset(-2), ptr1);\n    }\n}\n\n#[test]\nfn ptr_metadata() {\n    struct Unit;\n    struct Pair<A, B: ?Sized>(A, B);\n    extern \"C\" {\n        type Extern;\n    }\n    let () = metadata(&());\n    let () = metadata(&Unit);\n    let () = metadata(&4_u32);\n    let () = metadata(&String::new());\n    let () = metadata(&Some(4_u32));\n    let () = metadata(&ptr_metadata);\n    let () = metadata(&|| {});\n    let () = metadata(&[4, 7]);\n    let () = metadata(&(4, String::new()));\n    let () = metadata(&Pair(4, String::new()));\n    let () = metadata(0 as *const Extern);\n    let () = metadata(0 as *const <&u32 as std::ops::Deref>::Target);\n\n    assert_eq!(metadata(\"foo\"), 3_usize);\n    assert_eq!(metadata(&[4, 7][..]), 2_usize);\n\n    let dst_tuple: &(bool, [u8]) = &(true, [0x66, 0x6F, 0x6F]);\n    let dst_struct: &Pair<bool, [u8]> = &Pair(true, [0x66, 0x6F, 0x6F]);\n    assert_eq!(metadata(dst_tuple), 3_usize);\n    assert_eq!(metadata(dst_struct), 3_usize);\n    unsafe {\n        let dst_tuple: &(bool, str) = std::mem::transmute(dst_tuple);\n        let dst_struct: &Pair<bool, str> = std::mem::transmute(dst_struct);\n        assert_eq!(&dst_tuple.1, \"foo\");\n        assert_eq!(&dst_struct.1, \"foo\");\n        assert_eq!(metadata(dst_tuple), 3_usize);\n        assert_eq!(metadata(dst_struct), 3_usize);\n    }\n\n    let vtable_1: DynMetadata<dyn Debug> = metadata(&4_u16 as &dyn Debug);\n    let vtable_2: DynMetadata<dyn Display> = metadata(&4_u16 as &dyn Display);\n    let vtable_3: DynMetadata<dyn Display> = metadata(&4_u32 as &dyn Display);\n    let vtable_4: DynMetadata<dyn Display> = metadata(&(true, 7_u32) as &(bool, dyn Display));\n    let vtable_5: DynMetadata<dyn Display> =\n        metadata(&Pair(true, 7_u32) as &Pair<bool, dyn Display>);\n    unsafe {\n        let address_1: usize = std::mem::transmute(vtable_1);\n        let address_2: usize = std::mem::transmute(vtable_2);\n        let address_3: usize = std::mem::transmute(vtable_3);\n        let address_4: usize = std::mem::transmute(vtable_4);\n        let address_5: usize = std::mem::transmute(vtable_5);\n        // Different trait => different vtable pointer\n        assert_ne!(address_1, address_2);\n        // Different erased type => different vtable pointer\n        assert_ne!(address_2, address_3);\n        // Same erased type and same trait => same vtable pointer\n        assert_eq!(address_3, address_4);\n        assert_eq!(address_3, address_5);\n    }\n}\n\n#[test]\nfn ptr_metadata_bounds() {\n    fn metadata_eq_method_address<T: ?Sized>() -> usize {\n        // The `Metadata` associated type has an `Ord` bound, so this is valid:\n        <<T as Pointee>::Metadata as PartialEq>::eq as usize\n    }\n    // \"Synthetic\" trait impls generated by the compiler like those of `Pointee`\n    // are not checked for bounds of associated type.\n    // So with a buggy libcore we could have both:\n    // * `<dyn Display as Pointee>::Metadata == DynMetadata`\n    // * `DynMetadata: !PartialEq`\n    // … and cause an ICE here:\n    metadata_eq_method_address::<dyn Display>();\n\n    // For this reason, let’s check here that bounds are satisfied:\n\n    let _ = static_assert_expected_bounds_for_metadata::<()>;\n    let _ = static_assert_expected_bounds_for_metadata::<usize>;\n    let _ = static_assert_expected_bounds_for_metadata::<DynMetadata<dyn Display>>;\n    fn _static_assert_associated_type<T: ?Sized>() {\n        let _ = static_assert_expected_bounds_for_metadata::<<T as Pointee>::Metadata>;\n    }\n\n    fn static_assert_expected_bounds_for_metadata<Meta>()\n    where\n        // Keep this in sync with the associated type in `library/core/src/ptr/metadata.rs`\n        Meta: Copy + Send + Sync + Ord + std::hash::Hash + Unpin,\n    {\n    }\n}\n\n#[test]\nfn dyn_metadata() {\n    #[derive(Debug)]\n    #[repr(align(32))]\n    struct Something([u8; 47]);\n\n    let value = Something([0; 47]);\n    let trait_object: &dyn Debug = &value;\n    let meta = metadata(trait_object);\n\n    assert_eq!(meta.size_of(), 64);\n    assert_eq!(meta.size_of(), std::mem::size_of::<Something>());\n    assert_eq!(meta.align_of(), 32);\n    assert_eq!(meta.align_of(), std::mem::align_of::<Something>());\n    assert_eq!(meta.layout(), std::alloc::Layout::new::<Something>());\n\n    assert!(format!(\"{:?}\", meta).starts_with(\"DynMetadata(0x\"));\n}\n\n#[test]\nfn from_raw_parts() {\n    let mut value = 5_u32;\n    let address = &mut value as *mut _ as *mut ();\n    let trait_object: &dyn Display = &mut value;\n    let vtable = metadata(trait_object);\n    let trait_object = NonNull::from(trait_object);\n\n    assert_eq!(ptr::from_raw_parts(address, vtable), trait_object.as_ptr());\n    assert_eq!(ptr::from_raw_parts_mut(address, vtable), trait_object.as_ptr());\n    assert_eq!(NonNull::from_raw_parts(NonNull::new(address).unwrap(), vtable), trait_object);\n\n    let mut array = [5_u32, 5, 5, 5, 5];\n    let address = &mut array as *mut _ as *mut ();\n    let array_ptr = NonNull::from(&mut array);\n    let slice_ptr = NonNull::from(&mut array[..]);\n\n    assert_eq!(ptr::from_raw_parts(address, ()), array_ptr.as_ptr());\n    assert_eq!(ptr::from_raw_parts_mut(address, ()), array_ptr.as_ptr());\n    assert_eq!(NonNull::from_raw_parts(NonNull::new(address).unwrap(), ()), array_ptr);\n\n    assert_eq!(ptr::from_raw_parts(address, 5), slice_ptr.as_ptr());\n    assert_eq!(ptr::from_raw_parts_mut(address, 5), slice_ptr.as_ptr());\n    assert_eq!(NonNull::from_raw_parts(NonNull::new(address).unwrap(), 5), slice_ptr);\n}\n\n#[test]\nfn thin_box() {\n    let foo = ThinBox::<dyn Display>::new(4);\n    assert_eq!(foo.to_string(), \"4\");\n    drop(foo);\n    let bar = ThinBox::<dyn Display>::new(7);\n    assert_eq!(bar.to_string(), \"7\");\n\n    // A slightly more interesting library that could be built on top of metadata APIs.\n    //\n    // * It could be generalized to any `T: ?Sized` (not just trait object)\n    //   if `{size,align}_of_for_meta<T: ?Sized>(T::Metadata)` are added.\n    // * Constructing a `ThinBox` without consuming and deallocating a `Box`\n    //   requires either the unstable `Unsize` marker trait,\n    //   or the unstable `unsized_locals` language feature,\n    //   or taking `&dyn T` and restricting to `T: Copy`.\n\n    use std::alloc::*;\n    use std::marker::PhantomData;\n\n    struct ThinBox<T>\n    where\n        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n    {\n        ptr: NonNull<DynMetadata<T>>,\n        phantom: PhantomData<T>,\n    }\n\n    impl<T> ThinBox<T>\n    where\n        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n    {\n        pub fn new<Value: std::marker::Unsize<T>>(value: Value) -> Self {\n            let unsized_: &T = &value;\n            let meta = metadata(unsized_);\n            let meta_layout = Layout::for_value(&meta);\n            let value_layout = Layout::for_value(&value);\n            let (layout, offset) = meta_layout.extend(value_layout).unwrap();\n            // `DynMetadata` is pointer-sized:\n            assert!(layout.size() > 0);\n            // If `ThinBox<T>` is generalized to any `T: ?Sized`,\n            // handle ZSTs with a dangling pointer without going through `alloc()`,\n            // like `Box<T>` does.\n            unsafe {\n                let ptr = NonNull::new(alloc(layout))\n                    .unwrap_or_else(|| handle_alloc_error(layout))\n                    .cast::<DynMetadata<T>>();\n                ptr.as_ptr().write(meta);\n                ptr.cast::<u8>().as_ptr().add(offset).cast::<Value>().write(value);\n                Self { ptr, phantom: PhantomData }\n            }\n        }\n\n        fn meta(&self) -> DynMetadata<T> {\n            unsafe { *self.ptr.as_ref() }\n        }\n\n        fn layout(&self) -> (Layout, usize) {\n            let meta = self.meta();\n            Layout::for_value(&meta).extend(meta.layout()).unwrap()\n        }\n\n        fn value_ptr(&self) -> *const T {\n            let (_, offset) = self.layout();\n            let data_ptr = unsafe { self.ptr.cast::<u8>().as_ptr().add(offset) };\n            ptr::from_raw_parts(data_ptr.cast(), self.meta())\n        }\n\n        fn value_mut_ptr(&mut self) -> *mut T {\n            let (_, offset) = self.layout();\n            // FIXME: can this line be shared with the same in `value_ptr()`\n            // without upsetting Stacked Borrows?\n            let data_ptr = unsafe { self.ptr.cast::<u8>().as_ptr().add(offset) };\n            from_raw_parts_mut(data_ptr.cast(), self.meta())\n        }\n    }\n\n    impl<T> std::ops::Deref for ThinBox<T>\n    where\n        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n    {\n        type Target = T;\n\n        fn deref(&self) -> &T {\n            unsafe { &*self.value_ptr() }\n        }\n    }\n\n    impl<T> std::ops::DerefMut for ThinBox<T>\n    where\n        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n    {\n        fn deref_mut(&mut self) -> &mut T {\n            unsafe { &mut *self.value_mut_ptr() }\n        }\n    }\n\n    impl<T> std::ops::Drop for ThinBox<T>\n    where\n        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n    {\n        fn drop(&mut self) {\n            let (layout, _) = self.layout();\n            unsafe {\n                drop_in_place::<T>(&mut **self);\n                dealloc(self.ptr.cast().as_ptr(), layout);\n            }\n        }\n    }\n}\n"],[2951,"// Aligned to two bytes\nconst DATA: [u16; 2] = [u16::from_ne_bytes([0x01, 0x23]), u16::from_ne_bytes([0x45, 0x67])];\n\nconst fn unaligned_ptr() -> *const u16 {\n    // Since DATA.as_ptr() is aligned to two bytes, adding 1 byte to that produces an unaligned *const u16\n    unsafe { (DATA.as_ptr() as *const u8).add(1) as *const u16 }\n}\n\n#[test]\nfn read() {\n    use core::ptr;\n\n    const FOO: i32 = unsafe { ptr::read(&42 as *const i32) };\n    assert_eq!(FOO, 42);\n\n    const ALIGNED: i32 = unsafe { ptr::read_unaligned(&42 as *const i32) };\n    assert_eq!(ALIGNED, 42);\n\n    const UNALIGNED_PTR: *const u16 = unaligned_ptr();\n\n    const UNALIGNED: u16 = unsafe { ptr::read_unaligned(UNALIGNED_PTR) };\n    assert_eq!(UNALIGNED, u16::from_ne_bytes([0x23, 0x45]));\n}\n\n#[test]\nfn const_ptr_read() {\n    const FOO: i32 = unsafe { (&42 as *const i32).read() };\n    assert_eq!(FOO, 42);\n\n    const ALIGNED: i32 = unsafe { (&42 as *const i32).read_unaligned() };\n    assert_eq!(ALIGNED, 42);\n\n    const UNALIGNED_PTR: *const u16 = unaligned_ptr();\n\n    const UNALIGNED: u16 = unsafe { UNALIGNED_PTR.read_unaligned() };\n    assert_eq!(UNALIGNED, u16::from_ne_bytes([0x23, 0x45]));\n}\n\n#[test]\nfn mut_ptr_read() {\n    const FOO: i32 = unsafe { (&42 as *const i32 as *mut i32).read() };\n    assert_eq!(FOO, 42);\n\n    const ALIGNED: i32 = unsafe { (&42 as *const i32 as *mut i32).read_unaligned() };\n    assert_eq!(ALIGNED, 42);\n\n    const UNALIGNED_PTR: *mut u16 = unaligned_ptr() as *mut u16;\n\n    const UNALIGNED: u16 = unsafe { UNALIGNED_PTR.read_unaligned() };\n    assert_eq!(UNALIGNED, u16::from_ne_bytes([0x23, 0x45]));\n}\n\n#[test]\nfn write() {\n    use core::ptr;\n\n    const fn write_aligned() -> i32 {\n        let mut res = 0;\n        unsafe {\n            ptr::write(&mut res as *mut _, 42);\n        }\n        res\n    }\n    const ALIGNED: i32 = write_aligned();\n    assert_eq!(ALIGNED, 42);\n\n    const fn write_unaligned() -> [u16; 2] {\n        let mut two_aligned = [0u16; 2];\n        unsafe {\n            let unaligned_ptr = (two_aligned.as_mut_ptr() as *mut u8).add(1) as *mut u16;\n            ptr::write_unaligned(unaligned_ptr, u16::from_ne_bytes([0x23, 0x45]));\n        }\n        two_aligned\n    }\n    const UNALIGNED: [u16; 2] = write_unaligned();\n    assert_eq!(UNALIGNED, [u16::from_ne_bytes([0x00, 0x23]), u16::from_ne_bytes([0x45, 0x00])]);\n}\n\n#[test]\nfn mut_ptr_write() {\n    const fn aligned() -> i32 {\n        let mut res = 0;\n        unsafe {\n            (&mut res as *mut i32).write(42);\n        }\n        res\n    }\n    const ALIGNED: i32 = aligned();\n    assert_eq!(ALIGNED, 42);\n\n    const fn write_unaligned() -> [u16; 2] {\n        let mut two_aligned = [0u16; 2];\n        unsafe {\n            let unaligned_ptr = (two_aligned.as_mut_ptr() as *mut u8).add(1) as *mut u16;\n            unaligned_ptr.write_unaligned(u16::from_ne_bytes([0x23, 0x45]));\n        }\n        two_aligned\n    }\n    const UNALIGNED: [u16; 2] = write_unaligned();\n    assert_eq!(UNALIGNED, [u16::from_ne_bytes([0x00, 0x23]), u16::from_ne_bytes([0x45, 0x00])]);\n}\n"],[2952,"use std::convert::TryFrom;\nuse std::str::FromStr;\nuse std::{char, str};\n\n#[test]\nfn test_convert() {\n    assert_eq!(u32::from('a'), 0x61);\n    assert_eq!(char::from(b'\\0'), '\\0');\n    assert_eq!(char::from(b'a'), 'a');\n    assert_eq!(char::from(b'\\xFF'), '\\u{FF}');\n    assert_eq!(char::try_from(0_u32), Ok('\\0'));\n    assert_eq!(char::try_from(0x61_u32), Ok('a'));\n    assert_eq!(char::try_from(0xD7FF_u32), Ok('\\u{D7FF}'));\n    assert!(char::try_from(0xD800_u32).is_err());\n    assert!(char::try_from(0xDFFF_u32).is_err());\n    assert_eq!(char::try_from(0xE000_u32), Ok('\\u{E000}'));\n    assert_eq!(char::try_from(0x10FFFF_u32), Ok('\\u{10FFFF}'));\n    assert!(char::try_from(0x110000_u32).is_err());\n    assert!(char::try_from(0xFFFF_FFFF_u32).is_err());\n}\n\n#[test]\nfn test_from_str() {\n    assert_eq!(char::from_str(\"a\").unwrap(), 'a');\n    assert_eq!(char::from_str(\"\\0\").unwrap(), '\\0');\n    assert_eq!(char::from_str(\"\\u{D7FF}\").unwrap(), '\\u{d7FF}');\n    assert!(char::from_str(\"\").is_err());\n    assert!(char::from_str(\"abc\").is_err());\n}\n\n#[test]\nfn test_is_lowercase() {\n    assert!('a'.is_lowercase());\n    assert!('ö'.is_lowercase());\n    assert!('ß'.is_lowercase());\n    assert!(!'Ü'.is_lowercase());\n    assert!(!'P'.is_lowercase());\n}\n\n#[test]\nfn test_is_uppercase() {\n    assert!(!'h'.is_uppercase());\n    assert!(!'ä'.is_uppercase());\n    assert!(!'ß'.is_uppercase());\n    assert!('Ö'.is_uppercase());\n    assert!('T'.is_uppercase());\n}\n\n#[test]\nfn test_is_whitespace() {\n    assert!(' '.is_whitespace());\n    assert!('\\u{2007}'.is_whitespace());\n    assert!('\\t'.is_whitespace());\n    assert!('\\n'.is_whitespace());\n    assert!(!'a'.is_whitespace());\n    assert!(!'_'.is_whitespace());\n    assert!(!'\\u{0}'.is_whitespace());\n}\n\n#[test]\nfn test_to_digit() {\n    assert_eq!('0'.to_digit(10), Some(0));\n    assert_eq!('1'.to_digit(2), Some(1));\n    assert_eq!('2'.to_digit(3), Some(2));\n    assert_eq!('9'.to_digit(10), Some(9));\n    assert_eq!('a'.to_digit(16), Some(10));\n    assert_eq!('A'.to_digit(16), Some(10));\n    assert_eq!('b'.to_digit(16), Some(11));\n    assert_eq!('B'.to_digit(16), Some(11));\n    assert_eq!('A'.to_digit(36), Some(10));\n    assert_eq!('z'.to_digit(36), Some(35));\n    assert_eq!('Z'.to_digit(36), Some(35));\n    assert_eq!('['.to_digit(36), None);\n    assert_eq!('`'.to_digit(36), None);\n    assert_eq!('{'.to_digit(36), None);\n    assert_eq!('$'.to_digit(36), None);\n    assert_eq!('@'.to_digit(16), None);\n    assert_eq!('G'.to_digit(16), None);\n    assert_eq!('g'.to_digit(16), None);\n    assert_eq!(' '.to_digit(10), None);\n    assert_eq!('/'.to_digit(10), None);\n    assert_eq!(':'.to_digit(10), None);\n    assert_eq!(':'.to_digit(11), None);\n}\n\n#[test]\nfn test_to_lowercase() {\n    fn lower(c: char) -> String {\n        let to_lowercase = c.to_lowercase();\n        assert_eq!(to_lowercase.len(), to_lowercase.count());\n        let iter: String = c.to_lowercase().collect();\n        let disp: String = c.to_lowercase().to_string();\n        assert_eq!(iter, disp);\n        iter\n    }\n    assert_eq!(lower('A'), \"a\");\n    assert_eq!(lower('Ö'), \"ö\");\n    assert_eq!(lower('ß'), \"ß\");\n    assert_eq!(lower('Ü'), \"ü\");\n    assert_eq!(lower('💩'), \"💩\");\n    assert_eq!(lower('Σ'), \"σ\");\n    assert_eq!(lower('Τ'), \"τ\");\n    assert_eq!(lower('Ι'), \"ι\");\n    assert_eq!(lower('Γ'), \"γ\");\n    assert_eq!(lower('Μ'), \"μ\");\n    assert_eq!(lower('Α'), \"α\");\n    assert_eq!(lower('Σ'), \"σ\");\n    assert_eq!(lower('ǅ'), \"ǆ\");\n    assert_eq!(lower('ﬁ'), \"ﬁ\");\n    assert_eq!(lower('İ'), \"i\\u{307}\");\n}\n\n#[test]\nfn test_to_uppercase() {\n    fn upper(c: char) -> String {\n        let to_uppercase = c.to_uppercase();\n        assert_eq!(to_uppercase.len(), to_uppercase.count());\n        let iter: String = c.to_uppercase().collect();\n        let disp: String = c.to_uppercase().to_string();\n        assert_eq!(iter, disp);\n        iter\n    }\n    assert_eq!(upper('a'), \"A\");\n    assert_eq!(upper('ö'), \"Ö\");\n    assert_eq!(upper('ß'), \"SS\"); // not ẞ: Latin capital letter sharp s\n    assert_eq!(upper('ü'), \"Ü\");\n    assert_eq!(upper('💩'), \"💩\");\n\n    assert_eq!(upper('σ'), \"Σ\");\n    assert_eq!(upper('τ'), \"Τ\");\n    assert_eq!(upper('ι'), \"Ι\");\n    assert_eq!(upper('γ'), \"Γ\");\n    assert_eq!(upper('μ'), \"Μ\");\n    assert_eq!(upper('α'), \"Α\");\n    assert_eq!(upper('ς'), \"Σ\");\n    assert_eq!(upper('ǅ'), \"Ǆ\");\n    assert_eq!(upper('ﬁ'), \"FI\");\n    assert_eq!(upper('ᾀ'), \"ἈΙ\");\n}\n\n#[test]\nfn test_is_control() {\n    assert!('\\u{0}'.is_control());\n    assert!('\\u{3}'.is_control());\n    assert!('\\u{6}'.is_control());\n    assert!('\\u{9}'.is_control());\n    assert!('\\u{7f}'.is_control());\n    assert!('\\u{92}'.is_control());\n    assert!(!'\\u{20}'.is_control());\n    assert!(!'\\u{55}'.is_control());\n    assert!(!'\\u{68}'.is_control());\n}\n\n#[test]\nfn test_is_numeric() {\n    assert!('2'.is_numeric());\n    assert!('7'.is_numeric());\n    assert!('¾'.is_numeric());\n    assert!(!'c'.is_numeric());\n    assert!(!'i'.is_numeric());\n    assert!(!'z'.is_numeric());\n    assert!(!'Q'.is_numeric());\n}\n\n#[test]\nfn test_escape_debug() {\n    fn string(c: char) -> String {\n        let iter: String = c.escape_debug().collect();\n        let disp: String = c.escape_debug().to_string();\n        assert_eq!(iter, disp);\n        iter\n    }\n    assert_eq!(string('\\n'), \"\\\\n\");\n    assert_eq!(string('\\r'), \"\\\\r\");\n    assert_eq!(string('\\''), \"\\\\'\");\n    assert_eq!(string('\"'), \"\\\\\\\"\");\n    assert_eq!(string(' '), \" \");\n    assert_eq!(string('a'), \"a\");\n    assert_eq!(string('~'), \"~\");\n    assert_eq!(string('é'), \"é\");\n    assert_eq!(string('文'), \"文\");\n    assert_eq!(string('\\x00'), \"\\\\u{0}\");\n    assert_eq!(string('\\x1f'), \"\\\\u{1f}\");\n    assert_eq!(string('\\x7f'), \"\\\\u{7f}\");\n    assert_eq!(string('\\u{80}'), \"\\\\u{80}\");\n    assert_eq!(string('\\u{ff}'), \"\\u{ff}\");\n    assert_eq!(string('\\u{11b}'), \"\\u{11b}\");\n    assert_eq!(string('\\u{1d4b6}'), \"\\u{1d4b6}\");\n    assert_eq!(string('\\u{301}'), \"\\\\u{301}\"); // combining character\n    assert_eq!(string('\\u{200b}'), \"\\\\u{200b}\"); // zero width space\n    assert_eq!(string('\\u{e000}'), \"\\\\u{e000}\"); // private use 1\n    assert_eq!(string('\\u{100000}'), \"\\\\u{100000}\"); // private use 2\n}\n\n#[test]\nfn test_escape_default() {\n    fn string(c: char) -> String {\n        let iter: String = c.escape_default().collect();\n        let disp: String = c.escape_default().to_string();\n        assert_eq!(iter, disp);\n        iter\n    }\n    assert_eq!(string('\\n'), \"\\\\n\");\n    assert_eq!(string('\\r'), \"\\\\r\");\n    assert_eq!(string('\\''), \"\\\\'\");\n    assert_eq!(string('\"'), \"\\\\\\\"\");\n    assert_eq!(string(' '), \" \");\n    assert_eq!(string('a'), \"a\");\n    assert_eq!(string('~'), \"~\");\n    assert_eq!(string('é'), \"\\\\u{e9}\");\n    assert_eq!(string('\\x00'), \"\\\\u{0}\");\n    assert_eq!(string('\\x1f'), \"\\\\u{1f}\");\n    assert_eq!(string('\\x7f'), \"\\\\u{7f}\");\n    assert_eq!(string('\\u{80}'), \"\\\\u{80}\");\n    assert_eq!(string('\\u{ff}'), \"\\\\u{ff}\");\n    assert_eq!(string('\\u{11b}'), \"\\\\u{11b}\");\n    assert_eq!(string('\\u{1d4b6}'), \"\\\\u{1d4b6}\");\n    assert_eq!(string('\\u{200b}'), \"\\\\u{200b}\"); // zero width space\n    assert_eq!(string('\\u{e000}'), \"\\\\u{e000}\"); // private use 1\n    assert_eq!(string('\\u{100000}'), \"\\\\u{100000}\"); // private use 2\n}\n\n#[test]\nfn test_escape_unicode() {\n    fn string(c: char) -> String {\n        let iter: String = c.escape_unicode().collect();\n        let disp: String = c.escape_unicode().to_string();\n        assert_eq!(iter, disp);\n        iter\n    }\n\n    assert_eq!(string('\\x00'), \"\\\\u{0}\");\n    assert_eq!(string('\\n'), \"\\\\u{a}\");\n    assert_eq!(string(' '), \"\\\\u{20}\");\n    assert_eq!(string('a'), \"\\\\u{61}\");\n    assert_eq!(string('\\u{11b}'), \"\\\\u{11b}\");\n    assert_eq!(string('\\u{1d4b6}'), \"\\\\u{1d4b6}\");\n}\n\n#[test]\nfn test_encode_utf8() {\n    fn check(input: char, expect: &[u8]) {\n        let mut buf = [0; 4];\n        let ptr = buf.as_ptr();\n        let s = input.encode_utf8(&mut buf);\n        assert_eq!(s.as_ptr() as usize, ptr as usize);\n        assert!(str::from_utf8(s.as_bytes()).is_ok());\n        assert_eq!(s.as_bytes(), expect);\n    }\n\n    check('x', &[0x78]);\n    check('\\u{e9}', &[0xc3, 0xa9]);\n    check('\\u{a66e}', &[0xea, 0x99, 0xae]);\n    check('\\u{1f4a9}', &[0xf0, 0x9f, 0x92, 0xa9]);\n}\n\n#[test]\nfn test_encode_utf16() {\n    fn check(input: char, expect: &[u16]) {\n        let mut buf = [0; 2];\n        let ptr = buf.as_mut_ptr();\n        let b = input.encode_utf16(&mut buf);\n        assert_eq!(b.as_mut_ptr() as usize, ptr as usize);\n        assert_eq!(b, expect);\n    }\n\n    check('x', &[0x0078]);\n    check('\\u{e9}', &[0x00e9]);\n    check('\\u{a66e}', &[0xa66e]);\n    check('\\u{1f4a9}', &[0xd83d, 0xdca9]);\n}\n\n#[test]\nfn test_len_utf16() {\n    assert!('x'.len_utf16() == 1);\n    assert!('\\u{e9}'.len_utf16() == 1);\n    assert!('\\u{a66e}'.len_utf16() == 1);\n    assert!('\\u{1f4a9}'.len_utf16() == 2);\n}\n\n#[test]\nfn test_decode_utf16() {\n    fn check(s: &[u16], expected: &[Result<char, u16>]) {\n        let v = char::decode_utf16(s.iter().cloned())\n            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n            .collect::<Vec<_>>();\n        assert_eq!(v, expected);\n    }\n    check(&[0xD800, 0x41, 0x42], &[Err(0xD800), Ok('A'), Ok('B')]);\n    check(&[0xD800, 0], &[Err(0xD800), Ok('\\0')]);\n}\n\n#[test]\nfn ed_iterator_specializations() {\n    // Check counting\n    assert_eq!('\\n'.escape_default().count(), 2);\n    assert_eq!('c'.escape_default().count(), 1);\n    assert_eq!(' '.escape_default().count(), 1);\n    assert_eq!('\\\\'.escape_default().count(), 2);\n    assert_eq!('\\''.escape_default().count(), 2);\n\n    // Check nth\n\n    // Check that OoB is handled correctly\n    assert_eq!('\\n'.escape_default().nth(2), None);\n    assert_eq!('c'.escape_default().nth(1), None);\n    assert_eq!(' '.escape_default().nth(1), None);\n    assert_eq!('\\\\'.escape_default().nth(2), None);\n    assert_eq!('\\''.escape_default().nth(2), None);\n\n    // Check the first char\n    assert_eq!('\\n'.escape_default().nth(0), Some('\\\\'));\n    assert_eq!('c'.escape_default().nth(0), Some('c'));\n    assert_eq!(' '.escape_default().nth(0), Some(' '));\n    assert_eq!('\\\\'.escape_default().nth(0), Some('\\\\'));\n    assert_eq!('\\''.escape_default().nth(0), Some('\\\\'));\n\n    // Check the second char\n    assert_eq!('\\n'.escape_default().nth(1), Some('n'));\n    assert_eq!('\\\\'.escape_default().nth(1), Some('\\\\'));\n    assert_eq!('\\''.escape_default().nth(1), Some('\\''));\n\n    // Check the last char\n    assert_eq!('\\n'.escape_default().last(), Some('n'));\n    assert_eq!('c'.escape_default().last(), Some('c'));\n    assert_eq!(' '.escape_default().last(), Some(' '));\n    assert_eq!('\\\\'.escape_default().last(), Some('\\\\'));\n    assert_eq!('\\''.escape_default().last(), Some('\\''));\n}\n\n#[test]\nfn eu_iterator_specializations() {\n    fn check(c: char) {\n        let len = c.escape_unicode().count();\n\n        // Check OoB\n        assert_eq!(c.escape_unicode().nth(len), None);\n\n        // For all possible in-bound offsets\n        let mut iter = c.escape_unicode();\n        for offset in 0..len {\n            // Check last\n            assert_eq!(iter.clone().last(), Some('}'));\n\n            // Check len\n            assert_eq!(iter.len(), len - offset);\n\n            // Check size_hint (= len in ExactSizeIterator)\n            assert_eq!(iter.size_hint(), (iter.len(), Some(iter.len())));\n\n            // Check counting\n            assert_eq!(iter.clone().count(), len - offset);\n\n            // Check nth\n            assert_eq!(c.escape_unicode().nth(offset), iter.next());\n        }\n\n        // Check post-last\n        assert_eq!(iter.clone().last(), None);\n        assert_eq!(iter.clone().count(), 0);\n    }\n\n    check('\\u{0}');\n    check('\\u{1}');\n    check('\\u{12}');\n    check('\\u{123}');\n    check('\\u{1234}');\n    check('\\u{12340}');\n    check('\\u{10FFFF}');\n}\n"],[2953,"mod control_flow;\n\nuse core::ops::{Bound, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo, RangeToInclusive};\nuse core::ops::{Deref, DerefMut};\n\n// Test the Range structs and syntax.\n\n#[test]\nfn test_range() {\n    let r = Range { start: 2, end: 10 };\n    let mut count = 0;\n    for (i, ri) in r.enumerate() {\n        assert_eq!(ri, i + 2);\n        assert!(ri >= 2 && ri < 10);\n        count += 1;\n    }\n    assert_eq!(count, 8);\n}\n\n#[test]\nfn test_range_from() {\n    let r = RangeFrom { start: 2 };\n    let mut count = 0;\n    for (i, ri) in r.take(10).enumerate() {\n        assert_eq!(ri, i + 2);\n        assert!(ri >= 2 && ri < 12);\n        count += 1;\n    }\n    assert_eq!(count, 10);\n}\n\n#[test]\nfn test_range_to() {\n    // Not much to test.\n    let _ = RangeTo { end: 42 };\n}\n\n#[test]\nfn test_full_range() {\n    // Not much to test.\n    let _ = RangeFull;\n}\n\n#[test]\nfn test_range_inclusive() {\n    let mut r = RangeInclusive::new(1i8, 2);\n    assert_eq!(r.next(), Some(1));\n    assert_eq!(r.next(), Some(2));\n    assert_eq!(r.next(), None);\n\n    r = RangeInclusive::new(127i8, 127);\n    assert_eq!(r.next(), Some(127));\n    assert_eq!(r.next(), None);\n\n    r = RangeInclusive::new(-128i8, -128);\n    assert_eq!(r.next_back(), Some(-128));\n    assert_eq!(r.next_back(), None);\n\n    // degenerate\n    r = RangeInclusive::new(1, -1);\n    assert_eq!(r.size_hint(), (0, Some(0)));\n    assert_eq!(r.next(), None);\n}\n\n#[test]\nfn test_range_to_inclusive() {\n    // Not much to test.\n    let _ = RangeToInclusive { end: 42 };\n}\n\n#[test]\nfn test_range_is_empty() {\n    assert!(!(0.0..10.0).is_empty());\n    assert!((-0.0..0.0).is_empty());\n    assert!((10.0..0.0).is_empty());\n\n    assert!(!(f32::NEG_INFINITY..f32::INFINITY).is_empty());\n    assert!((f32::EPSILON..f32::NAN).is_empty());\n    assert!((f32::NAN..f32::EPSILON).is_empty());\n    assert!((f32::NAN..f32::NAN).is_empty());\n\n    assert!(!(0.0..=10.0).is_empty());\n    assert!(!(-0.0..=0.0).is_empty());\n    assert!((10.0..=0.0).is_empty());\n\n    assert!(!(f32::NEG_INFINITY..=f32::INFINITY).is_empty());\n    assert!((f32::EPSILON..=f32::NAN).is_empty());\n    assert!((f32::NAN..=f32::EPSILON).is_empty());\n    assert!((f32::NAN..=f32::NAN).is_empty());\n}\n\n#[test]\nfn test_bound_cloned_unbounded() {\n    assert_eq!(Bound::<&u32>::Unbounded.cloned(), Bound::Unbounded);\n}\n\n#[test]\nfn test_bound_cloned_included() {\n    assert_eq!(Bound::Included(&3).cloned(), Bound::Included(3));\n}\n\n#[test]\nfn test_bound_cloned_excluded() {\n    assert_eq!(Bound::Excluded(&3).cloned(), Bound::Excluded(3));\n}\n\n#[test]\n#[allow(unused_comparisons)]\n#[allow(unused_mut)]\nfn test_range_syntax() {\n    let mut count = 0;\n    for i in 0_usize..10 {\n        assert!(i >= 0 && i < 10);\n        count += i;\n    }\n    assert_eq!(count, 45);\n\n    let mut count = 0;\n    let mut range = 0_usize..10;\n    for i in range {\n        assert!(i >= 0 && i < 10);\n        count += i;\n    }\n    assert_eq!(count, 45);\n\n    let mut count = 0;\n    let mut rf = 3_usize..;\n    for i in rf.take(10) {\n        assert!(i >= 3 && i < 13);\n        count += i;\n    }\n    assert_eq!(count, 75);\n\n    let _ = 0_usize..4 + 4 - 3;\n\n    fn foo() -> isize {\n        42\n    }\n    let _ = 0..foo();\n\n    let _ = { &42..&100 }; // references to literals are OK\n    let _ = ..42_usize;\n\n    // Test we can use two different types with a common supertype.\n    let x = &42;\n    {\n        let y = 42;\n        let _ = x..&y;\n    }\n}\n\n#[test]\n#[allow(dead_code)]\nfn test_range_syntax_in_return_statement() {\n    fn return_range_to() -> RangeTo<i32> {\n        return ..1;\n    }\n    fn return_full_range() -> RangeFull {\n        return ..;\n    }\n    // Not much to test.\n}\n\n#[test]\nfn range_structural_match() {\n    // test that all range types can be structurally matched upon\n\n    const RANGE: Range<usize> = 0..1000;\n    match RANGE {\n        RANGE => {}\n        _ => unreachable!(),\n    }\n\n    const RANGE_FROM: RangeFrom<usize> = 0..;\n    match RANGE_FROM {\n        RANGE_FROM => {}\n        _ => unreachable!(),\n    }\n\n    const RANGE_FULL: RangeFull = ..;\n    match RANGE_FULL {\n        RANGE_FULL => {}\n    }\n\n    const RANGE_INCLUSIVE: RangeInclusive<usize> = 0..=999;\n    match RANGE_INCLUSIVE {\n        RANGE_INCLUSIVE => {}\n        _ => unreachable!(),\n    }\n\n    const RANGE_TO: RangeTo<usize> = ..1000;\n    match RANGE_TO {\n        RANGE_TO => {}\n        _ => unreachable!(),\n    }\n\n    const RANGE_TO_INCLUSIVE: RangeToInclusive<usize> = ..=999;\n    match RANGE_TO_INCLUSIVE {\n        RANGE_TO_INCLUSIVE => {}\n        _ => unreachable!(),\n    }\n}\n\n// Test Deref implementations\n\n#[test]\nfn deref_mut_on_ref() {\n    // Test that `&mut T` implements `DerefMut<T>`\n\n    fn inc<T: Deref<Target = isize> + DerefMut>(mut t: T) {\n        *t += 1;\n    }\n\n    let mut x: isize = 5;\n    inc(&mut x);\n    assert_eq!(x, 6);\n}\n\n#[test]\nfn deref_on_ref() {\n    // Test that `&T` and `&mut T` implement `Deref<T>`\n\n    fn deref<U: Copy, T: Deref<Target = U>>(t: T) -> U {\n        *t\n    }\n\n    let x: isize = 3;\n    let y = deref(&x);\n    assert_eq!(y, 3);\n\n    let mut x: isize = 4;\n    let y = deref(&mut x);\n    assert_eq!(y, 4);\n}\n"],[2954,"use core::char::from_u32;\n\n#[test]\nfn test_is_ascii() {\n    assert!(b\"\".is_ascii());\n    assert!(b\"banana\\0\\x7F\".is_ascii());\n    assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n    assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n\n    assert!(\"\".is_ascii());\n    assert!(\"banana\\0\\u{7F}\".is_ascii());\n    assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n    assert!(!\"ประเทศไทย中华Việt Nam\".chars().all(|c| c.is_ascii()));\n    assert!(!\"ประเทศไทย中华ệ \".chars().any(|c| c.is_ascii()));\n}\n\n#[test]\nfn test_to_ascii_uppercase() {\n    assert_eq!(\"url()URL()uRl()ürl\".to_ascii_uppercase(), \"URL()URL()URL()üRL\");\n    assert_eq!(\"hıKß\".to_ascii_uppercase(), \"HıKß\");\n\n    for i in 0..501 {\n        let upper =\n            if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 } else { i };\n        assert_eq!(\n            (from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n            (from_u32(upper).unwrap()).to_string()\n        );\n    }\n}\n\n#[test]\nfn test_to_ascii_lowercase() {\n    assert_eq!(\"url()URL()uRl()Ürl\".to_ascii_lowercase(), \"url()url()url()Ürl\");\n    // Dotted capital I, Kelvin sign, Sharp S.\n    assert_eq!(\"HİKß\".to_ascii_lowercase(), \"hİKß\");\n\n    for i in 0..501 {\n        let lower =\n            if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 } else { i };\n        assert_eq!(\n            (from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n            (from_u32(lower).unwrap()).to_string()\n        );\n    }\n}\n\n#[test]\nfn test_make_ascii_lower_case() {\n    macro_rules! test {\n        ($from: expr, $to: expr) => {{\n            let mut x = $from;\n            x.make_ascii_lowercase();\n            assert_eq!(x, $to);\n        }};\n    }\n    test!(b'A', b'a');\n    test!(b'a', b'a');\n    test!(b'!', b'!');\n    test!('A', 'a');\n    test!('À', 'À');\n    test!('a', 'a');\n    test!('!', '!');\n    test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n    test!(\"HİKß\".to_string(), \"hİKß\");\n}\n\n#[test]\nfn test_make_ascii_upper_case() {\n    macro_rules! test {\n        ($from: expr, $to: expr) => {{\n            let mut x = $from;\n            x.make_ascii_uppercase();\n            assert_eq!(x, $to);\n        }};\n    }\n    test!(b'a', b'A');\n    test!(b'A', b'A');\n    test!(b'!', b'!');\n    test!('a', 'A');\n    test!('à', 'à');\n    test!('A', 'A');\n    test!('!', '!');\n    test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n    test!(\"hıKß\".to_string(), \"HıKß\");\n\n    let mut x = \"Hello\".to_string();\n    x[..3].make_ascii_uppercase(); // Test IndexMut on String.\n    assert_eq!(x, \"HELlo\")\n}\n\n#[test]\nfn test_eq_ignore_ascii_case() {\n    assert!(\"url()URL()uRl()Ürl\".eq_ignore_ascii_case(\"url()url()url()Ürl\"));\n    assert!(!\"Ürl\".eq_ignore_ascii_case(\"ürl\"));\n    // Dotted capital I, Kelvin sign, Sharp S.\n    assert!(\"HİKß\".eq_ignore_ascii_case(\"hİKß\"));\n    assert!(!\"İ\".eq_ignore_ascii_case(\"i\"));\n    assert!(!\"K\".eq_ignore_ascii_case(\"k\"));\n    assert!(!\"ß\".eq_ignore_ascii_case(\"s\"));\n\n    for i in 0..501 {\n        let lower =\n            if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 } else { i };\n        assert!(\n            (from_u32(i).unwrap())\n                .to_string()\n                .eq_ignore_ascii_case(&from_u32(lower).unwrap().to_string())\n        );\n    }\n}\n\n#[test]\nfn inference_works() {\n    let x = \"a\".to_string();\n    x.eq_ignore_ascii_case(\"A\");\n}\n\n// Shorthands used by the is_ascii_* tests.\nmacro_rules! assert_all {\n    ($what:ident, $($str:tt),+) => {{\n        $(\n            for b in $str.chars() {\n                if !b.$what() {\n                    panic!(\"expected {}({}) but it isn't\",\n                           stringify!($what), b);\n                }\n            }\n            for b in $str.as_bytes().iter() {\n                if !b.$what() {\n                    panic!(\"expected {}(0x{:02x})) but it isn't\",\n                           stringify!($what), b);\n                }\n            }\n        )+\n    }};\n    ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n}\nmacro_rules! assert_none {\n    ($what:ident, $($str:tt),+) => {{\n        $(\n            for b in $str.chars() {\n                if b.$what() {\n                    panic!(\"expected not-{}({}) but it is\",\n                           stringify!($what), b);\n                }\n            }\n            for b in $str.as_bytes().iter() {\n                if b.$what() {\n                    panic!(\"expected not-{}(0x{:02x})) but it is\",\n                           stringify!($what), b);\n                }\n            }\n        )+\n    }};\n    ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n}\n\n#[test]\nfn test_is_ascii_alphabetic() {\n    assert_all!(\n        is_ascii_alphabetic,\n        \"\",\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n    );\n    assert_none!(\n        is_ascii_alphabetic,\n        \"0123456789\",\n        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        \" \\t\\n\\x0c\\r\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n}\n\n#[test]\nfn test_is_ascii_uppercase() {\n    assert_all!(is_ascii_uppercase, \"\", \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",);\n    assert_none!(\n        is_ascii_uppercase,\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"0123456789\",\n        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        \" \\t\\n\\x0c\\r\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n}\n\n#[test]\nfn test_is_ascii_lowercase() {\n    assert_all!(is_ascii_lowercase, \"abcdefghijklmnopqrstuvwxyz\",);\n    assert_none!(\n        is_ascii_lowercase,\n        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n        \"0123456789\",\n        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        \" \\t\\n\\x0c\\r\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n}\n\n#[test]\nfn test_is_ascii_alphanumeric() {\n    assert_all!(\n        is_ascii_alphanumeric,\n        \"\",\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n        \"0123456789\",\n    );\n    assert_none!(\n        is_ascii_alphanumeric,\n        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        \" \\t\\n\\x0c\\r\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n}\n\n#[test]\nfn test_is_ascii_digit() {\n    assert_all!(is_ascii_digit, \"\", \"0123456789\",);\n    assert_none!(\n        is_ascii_digit,\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        \" \\t\\n\\x0c\\r\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n}\n\n#[test]\nfn test_is_ascii_hexdigit() {\n    assert_all!(is_ascii_hexdigit, \"\", \"0123456789\", \"abcdefABCDEF\",);\n    assert_none!(\n        is_ascii_hexdigit,\n        \"ghijklmnopqrstuvwxyz\",\n        \"GHIJKLMNOQPRSTUVWXYZ\",\n        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        \" \\t\\n\\x0c\\r\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n}\n\n#[test]\nfn test_is_ascii_punctuation() {\n    assert_all!(is_ascii_punctuation, \"\", \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",);\n    assert_none!(\n        is_ascii_punctuation,\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n        \"0123456789\",\n        \" \\t\\n\\x0c\\r\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n}\n\n#[test]\nfn test_is_ascii_graphic() {\n    assert_all!(\n        is_ascii_graphic,\n        \"\",\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n        \"0123456789\",\n        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n    );\n    assert_none!(\n        is_ascii_graphic,\n        \" \\t\\n\\x0c\\r\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n}\n\n#[test]\nfn test_is_ascii_whitespace() {\n    assert_all!(is_ascii_whitespace, \"\", \" \\t\\n\\x0c\\r\",);\n    assert_none!(\n        is_ascii_whitespace,\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n        \"0123456789\",\n        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x0b\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n}\n\n#[test]\nfn test_is_ascii_control() {\n    assert_all!(\n        is_ascii_control,\n        \"\",\n        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        \"\\x7f\",\n    );\n    assert_none!(\n        is_ascii_control,\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n        \"0123456789\",\n        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        \" \",\n    );\n}\n\n// `is_ascii` does a good amount of pointer manipulation and has\n// alignment-dependent computation. This is all sanity-checked via\n// `debug_assert!`s, so we test various sizes/alignments thoroughly versus an\n// \"obviously correct\" baseline function.\n#[test]\nfn test_is_ascii_align_size_thoroughly() {\n    // The \"obviously-correct\" baseline mentioned above.\n    fn is_ascii_baseline(s: &[u8]) -> bool {\n        s.iter().all(|b| b.is_ascii())\n    }\n\n    // Helper to repeat `l` copies of `b0` followed by `l` copies of `b1`.\n    fn repeat_concat(b0: u8, b1: u8, l: usize) -> Vec<u8> {\n        use core::iter::repeat;\n        repeat(b0).take(l).chain(repeat(b1).take(l)).collect()\n    }\n\n    // Miri is too slow\n    let iter = if cfg!(miri) { 0..20 } else { 0..100 };\n\n    for i in iter {\n        #[cfg(not(miri))]\n        let cases = &[\n            b\"a\".repeat(i),\n            b\"\\0\".repeat(i),\n            b\"\\x7f\".repeat(i),\n            b\"\\x80\".repeat(i),\n            b\"\\xff\".repeat(i),\n            repeat_concat(b'a', 0x80u8, i),\n            repeat_concat(0x80u8, b'a', i),\n        ];\n\n        #[cfg(miri)]\n        let cases = &[b\"a\".repeat(i), b\"\\x80\".repeat(i), repeat_concat(b'a', 0x80u8, i)];\n\n        for case in cases {\n            for pos in 0..=case.len() {\n                // Potentially misaligned head\n                let prefix = &case[pos..];\n                assert_eq!(is_ascii_baseline(prefix), prefix.is_ascii(),);\n\n                // Potentially misaligned tail\n                let suffix = &case[..case.len() - pos];\n\n                assert_eq!(is_ascii_baseline(suffix), suffix.is_ascii(),);\n\n                // Both head and tail are potentially misaligned\n                let mid = &case[(pos / 2)..(case.len() - (pos / 2))];\n                assert_eq!(is_ascii_baseline(mid), mid.is_ascii(),);\n            }\n        }\n    }\n}\n\n#[test]\nfn ascii_const() {\n    // test that the `is_ascii` methods of `char` and `u8` are usable in a const context\n\n    const CHAR_IS_ASCII: bool = 'a'.is_ascii();\n    assert!(CHAR_IS_ASCII);\n\n    const BYTE_IS_ASCII: bool = 97u8.is_ascii();\n    assert!(BYTE_IS_ASCII);\n}\n\n#[test]\nfn ascii_ctype_const() {\n    macro_rules! suite {\n        ( $( $fn:ident => [$a:ident, $A:ident, $nine:ident, $dot:ident, $space:ident]; )* ) => {\n            $(\n                mod $fn {\n                    const CHAR_A_LOWER: bool = 'a'.$fn();\n                    const CHAR_A_UPPER: bool = 'A'.$fn();\n                    const CHAR_NINE: bool = '9'.$fn();\n                    const CHAR_DOT: bool = '.'.$fn();\n                    const CHAR_SPACE: bool = ' '.$fn();\n\n                    const U8_A_LOWER: bool = b'a'.$fn();\n                    const U8_A_UPPER: bool = b'A'.$fn();\n                    const U8_NINE: bool = b'9'.$fn();\n                    const U8_DOT: bool = b'.'.$fn();\n                    const U8_SPACE: bool = b' '.$fn();\n\n                    pub fn run() {\n                        assert_eq!(CHAR_A_LOWER, $a);\n                        assert_eq!(CHAR_A_UPPER, $A);\n                        assert_eq!(CHAR_NINE, $nine);\n                        assert_eq!(CHAR_DOT, $dot);\n                        assert_eq!(CHAR_SPACE, $space);\n\n                        assert_eq!(U8_A_LOWER, $a);\n                        assert_eq!(U8_A_UPPER, $A);\n                        assert_eq!(U8_NINE, $nine);\n                        assert_eq!(U8_DOT, $dot);\n                        assert_eq!(U8_SPACE, $space);\n                    }\n                }\n            )*\n\n            $( $fn::run(); )*\n        }\n    }\n\n    suite! {\n        //                        'a'    'A'    '9'    '.'    ' '\n        is_ascii_alphabetic   => [true,  true,  false, false, false];\n        is_ascii_uppercase    => [false, true,  false, false, false];\n        is_ascii_lowercase    => [true,  false, false, false, false];\n        is_ascii_alphanumeric => [true,  true,  true,  false, false];\n        is_ascii_digit        => [false, false, true,  false, false];\n        is_ascii_hexdigit     => [true,  true,  true,  false, false];\n        is_ascii_punctuation  => [false, false, false, true,  false];\n        is_ascii_graphic      => [true,  true,  true,  true,  false];\n        is_ascii_whitespace   => [false, false, false, false, true];\n        is_ascii_control      => [false, false, false, false, false];\n    }\n}\n"],[2955,"use core::array;\nuse core::convert::TryFrom;\n\n#[test]\nfn array_from_ref() {\n    let value: String = \"Hello World!\".into();\n    let arr: &[String; 1] = array::from_ref(&value);\n    assert_eq!(&[value.clone()], arr);\n}\n\n#[test]\nfn array_from_mut() {\n    let mut value: String = \"Hello World\".into();\n    let arr: &mut [String; 1] = array::from_mut(&mut value);\n    arr[0].push_str(\"!\");\n    assert_eq!(&value, \"Hello World!\");\n}\n\n#[test]\nfn array_try_from() {\n    macro_rules! test {\n        ($($N:expr)+) => {\n            $({\n                type Array = [u8; $N];\n                let array: Array = [0; $N];\n                let slice: &[u8] = &array[..];\n\n                let result = <&Array>::try_from(slice);\n                assert_eq!(&array, result.unwrap());\n            })+\n        }\n    }\n    test! {\n         0  1  2  3  4  5  6  7  8  9\n        10 11 12 13 14 15 16 17 18 19\n        20 21 22 23 24 25 26 27 28 29\n        30 31 32\n    }\n}\n\n#[test]\nfn iterator_collect() {\n    let arr = [0, 1, 2, 5, 9];\n    let v: Vec<_> = IntoIterator::into_iter(arr.clone()).collect();\n    assert_eq!(&arr[..], &v[..]);\n}\n\n#[test]\nfn iterator_rev_collect() {\n    let arr = [0, 1, 2, 5, 9];\n    let v: Vec<_> = IntoIterator::into_iter(arr.clone()).rev().collect();\n    assert_eq!(&v[..], &[9, 5, 2, 1, 0]);\n}\n\n#[test]\nfn iterator_nth() {\n    let v = [0, 1, 2, 3, 4];\n    for i in 0..v.len() {\n        assert_eq!(IntoIterator::into_iter(v.clone()).nth(i).unwrap(), v[i]);\n    }\n    assert_eq!(IntoIterator::into_iter(v.clone()).nth(v.len()), None);\n\n    let mut iter = IntoIterator::into_iter(v);\n    assert_eq!(iter.nth(2).unwrap(), v[2]);\n    assert_eq!(iter.nth(1).unwrap(), v[4]);\n}\n\n#[test]\nfn iterator_last() {\n    let v = [0, 1, 2, 3, 4];\n    assert_eq!(IntoIterator::into_iter(v).last().unwrap(), 4);\n    assert_eq!(IntoIterator::into_iter([0]).last().unwrap(), 0);\n\n    let mut it = IntoIterator::into_iter([0, 9, 2, 4]);\n    assert_eq!(it.next_back(), Some(4));\n    assert_eq!(it.last(), Some(2));\n}\n\n#[test]\nfn iterator_clone() {\n    let mut it = IntoIterator::into_iter([0, 2, 4, 6, 8]);\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.next_back(), Some(8));\n    let mut clone = it.clone();\n    assert_eq!(it.next_back(), Some(6));\n    assert_eq!(clone.next_back(), Some(6));\n    assert_eq!(it.next_back(), Some(4));\n    assert_eq!(clone.next_back(), Some(4));\n    assert_eq!(it.next(), Some(2));\n    assert_eq!(clone.next(), Some(2));\n}\n\n#[test]\nfn iterator_fused() {\n    let mut it = IntoIterator::into_iter([0, 9, 2]);\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.next(), Some(9));\n    assert_eq!(it.next(), Some(2));\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn iterator_len() {\n    let mut it = IntoIterator::into_iter([0, 1, 2, 5, 9]);\n    assert_eq!(it.size_hint(), (5, Some(5)));\n    assert_eq!(it.len(), 5);\n    assert_eq!(it.is_empty(), false);\n\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.size_hint(), (4, Some(4)));\n    assert_eq!(it.len(), 4);\n    assert_eq!(it.is_empty(), false);\n\n    assert_eq!(it.next_back(), Some(9));\n    assert_eq!(it.size_hint(), (3, Some(3)));\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.is_empty(), false);\n\n    // Empty\n    let it = IntoIterator::into_iter([] as [String; 0]);\n    assert_eq!(it.size_hint(), (0, Some(0)));\n    assert_eq!(it.len(), 0);\n    assert_eq!(it.is_empty(), true);\n}\n\n#[test]\nfn iterator_count() {\n    let v = [0, 1, 2, 3, 4];\n    assert_eq!(IntoIterator::into_iter(v.clone()).count(), 5);\n\n    let mut iter2 = IntoIterator::into_iter(v);\n    iter2.next();\n    iter2.next();\n    assert_eq!(iter2.count(), 3);\n}\n\n#[test]\nfn iterator_flat_map() {\n    assert!((0..5).flat_map(|i| IntoIterator::into_iter([2 * i, 2 * i + 1])).eq(0..10));\n}\n\n#[test]\nfn iterator_debug() {\n    let arr = [0, 1, 2, 5, 9];\n    assert_eq!(format!(\"{:?}\", IntoIterator::into_iter(arr)), \"IntoIter([0, 1, 2, 5, 9])\",);\n}\n\n#[test]\nfn iterator_drops() {\n    use core::cell::Cell;\n\n    // This test makes sure the correct number of elements are dropped. The `R`\n    // type is just a reference to a `Cell` that is incremented when an `R` is\n    // dropped.\n\n    #[derive(Clone)]\n    struct Foo<'a>(&'a Cell<usize>);\n\n    impl Drop for Foo<'_> {\n        fn drop(&mut self) {\n            self.0.set(self.0.get() + 1);\n        }\n    }\n\n    fn five(i: &Cell<usize>) -> [Foo<'_>; 5] {\n        // This is somewhat verbose because `Foo` does not implement `Copy`\n        // since it implements `Drop`. Consequently, we cannot write\n        // `[Foo(i); 5]`.\n        [Foo(i), Foo(i), Foo(i), Foo(i), Foo(i)]\n    }\n\n    // Simple: drop new iterator.\n    let i = Cell::new(0);\n    {\n        IntoIterator::into_iter(five(&i));\n    }\n    assert_eq!(i.get(), 5);\n\n    // Call `next()` once.\n    let i = Cell::new(0);\n    {\n        let mut iter = IntoIterator::into_iter(five(&i));\n        let _x = iter.next();\n        assert_eq!(i.get(), 0);\n        assert_eq!(iter.count(), 4);\n        assert_eq!(i.get(), 4);\n    }\n    assert_eq!(i.get(), 5);\n\n    // Check `clone` and calling `next`/`next_back`.\n    let i = Cell::new(0);\n    {\n        let mut iter = IntoIterator::into_iter(five(&i));\n        iter.next();\n        assert_eq!(i.get(), 1);\n        iter.next_back();\n        assert_eq!(i.get(), 2);\n\n        let mut clone = iter.clone();\n        assert_eq!(i.get(), 2);\n\n        iter.next();\n        assert_eq!(i.get(), 3);\n\n        clone.next();\n        assert_eq!(i.get(), 4);\n\n        assert_eq!(clone.count(), 2);\n        assert_eq!(i.get(), 6);\n    }\n    assert_eq!(i.get(), 8);\n\n    // Check via `nth`.\n    let i = Cell::new(0);\n    {\n        let mut iter = IntoIterator::into_iter(five(&i));\n        let _x = iter.nth(2);\n        assert_eq!(i.get(), 2);\n        let _y = iter.last();\n        assert_eq!(i.get(), 3);\n    }\n    assert_eq!(i.get(), 5);\n\n    // Check every element.\n    let i = Cell::new(0);\n    for (index, _x) in IntoIterator::into_iter(five(&i)).enumerate() {\n        assert_eq!(i.get(), index);\n    }\n    assert_eq!(i.get(), 5);\n\n    let i = Cell::new(0);\n    for (index, _x) in IntoIterator::into_iter(five(&i)).rev().enumerate() {\n        assert_eq!(i.get(), index);\n    }\n    assert_eq!(i.get(), 5);\n}\n\n// This test does not work on targets without panic=unwind support.\n// To work around this problem, test is marked is should_panic, so it will\n// be automagically skipped on unsuitable targets, such as\n// wasm32-unknown-unkown.\n//\n// It means that we use panic for indicating success.\n#[test]\n#[should_panic(expected = \"test succeeded\")]\nfn array_default_impl_avoids_leaks_on_panic() {\n    use core::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n    static COUNTER: AtomicUsize = AtomicUsize::new(0);\n    #[derive(Debug)]\n    struct Bomb(usize);\n\n    impl Default for Bomb {\n        fn default() -> Bomb {\n            if COUNTER.load(Relaxed) == 3 {\n                panic!(\"bomb limit exceeded\");\n            }\n\n            COUNTER.fetch_add(1, Relaxed);\n            Bomb(COUNTER.load(Relaxed))\n        }\n    }\n\n    impl Drop for Bomb {\n        fn drop(&mut self) {\n            COUNTER.fetch_sub(1, Relaxed);\n        }\n    }\n\n    let res = std::panic::catch_unwind(|| <[Bomb; 5]>::default());\n    let panic_msg = match res {\n        Ok(_) => unreachable!(),\n        Err(p) => p.downcast::<&'static str>().unwrap(),\n    };\n    assert_eq!(*panic_msg, \"bomb limit exceeded\");\n    // check that all bombs are successfully dropped\n    assert_eq!(COUNTER.load(Relaxed), 0);\n    panic!(\"test succeeded\")\n}\n\n#[test]\nfn empty_array_is_always_default() {\n    struct DoesNotImplDefault;\n\n    let _arr = <[DoesNotImplDefault; 0]>::default();\n}\n\n#[test]\nfn array_map() {\n    let a = [1, 2, 3];\n    let b = a.map(|v| v + 1);\n    assert_eq!(b, [2, 3, 4]);\n\n    let a = [1u8, 2, 3];\n    let b = a.map(|v| v as u64);\n    assert_eq!(b, [1, 2, 3]);\n}\n\n// See note on above test for why `should_panic` is used.\n#[test]\n#[should_panic(expected = \"test succeeded\")]\nfn array_map_drop_safety() {\n    use core::sync::atomic::AtomicUsize;\n    use core::sync::atomic::Ordering;\n    static DROPPED: AtomicUsize = AtomicUsize::new(0);\n    struct DropCounter;\n    impl Drop for DropCounter {\n        fn drop(&mut self) {\n            DROPPED.fetch_add(1, Ordering::SeqCst);\n        }\n    }\n\n    let num_to_create = 5;\n    let success = std::panic::catch_unwind(|| {\n        let items = [0; 10];\n        let mut nth = 0;\n        items.map(|_| {\n            assert!(nth < num_to_create);\n            nth += 1;\n            DropCounter\n        });\n    });\n    assert!(success.is_err());\n    assert_eq!(DROPPED.load(Ordering::SeqCst), num_to_create);\n    panic!(\"test succeeded\")\n}\n\n#[test]\nfn cell_allows_array_cycle() {\n    use core::cell::Cell;\n\n    #[derive(Debug)]\n    struct B<'a> {\n        a: [Cell<Option<&'a B<'a>>>; 2],\n    }\n\n    impl<'a> B<'a> {\n        fn new() -> B<'a> {\n            B { a: [Cell::new(None), Cell::new(None)] }\n        }\n    }\n\n    let b1 = B::new();\n    let b2 = B::new();\n    let b3 = B::new();\n\n    b1.a[0].set(Some(&b2));\n    b1.a[1].set(Some(&b3));\n\n    b2.a[0].set(Some(&b2));\n    b2.a[1].set(Some(&b3));\n\n    b3.a[0].set(Some(&b1));\n    b3.a[1].set(Some(&b2));\n}\n"],[2956,"use core::any::TypeId;\nuse core::intrinsics::assume;\n\n#[test]\nfn test_typeid_sized_types() {\n    struct X;\n    struct Y(u32);\n\n    assert_eq!(TypeId::of::<X>(), TypeId::of::<X>());\n    assert_eq!(TypeId::of::<Y>(), TypeId::of::<Y>());\n    assert!(TypeId::of::<X>() != TypeId::of::<Y>());\n}\n\n#[test]\nfn test_typeid_unsized_types() {\n    trait Z {}\n    struct X(str);\n    struct Y(dyn Z + 'static);\n\n    assert_eq!(TypeId::of::<X>(), TypeId::of::<X>());\n    assert_eq!(TypeId::of::<Y>(), TypeId::of::<Y>());\n    assert!(TypeId::of::<X>() != TypeId::of::<Y>());\n}\n\n// Check that `const_assume` feature allow `assume` intrinsic\n// to be used in const contexts.\n#[test]\nfn test_assume_can_be_in_const_contexts() {\n    const unsafe fn foo(x: usize, y: usize) -> usize {\n        // SAFETY: the entire function is not safe,\n        // but it is just an example not used elsewhere.\n        unsafe { assume(y != 0) };\n        x / y\n    }\n    let rs = unsafe { foo(42, 97) };\n    assert_eq!(rs, 0);\n}\n"],[2957,"use core::alloc::Layout;\nuse core::ptr::NonNull;\n\n#[test]\nfn const_unchecked_layout() {\n    const SIZE: usize = 0x2000;\n    const ALIGN: usize = 0x1000;\n    const LAYOUT: Layout = unsafe { Layout::from_size_align_unchecked(SIZE, ALIGN) };\n    const DANGLING: NonNull<u8> = LAYOUT.dangling();\n    assert_eq!(LAYOUT.size(), SIZE);\n    assert_eq!(LAYOUT.align(), ALIGN);\n    assert_eq!(Some(DANGLING), NonNull::new(ALIGN as *mut u8));\n}\n"],[2958,"use core::{\n    cell::Cell,\n    lazy::{Lazy, OnceCell},\n    sync::atomic::{AtomicUsize, Ordering::SeqCst},\n};\n\n#[test]\nfn once_cell() {\n    let c = OnceCell::new();\n    assert!(c.get().is_none());\n    c.get_or_init(|| 92);\n    assert_eq!(c.get(), Some(&92));\n\n    c.get_or_init(|| panic!(\"Kabom!\"));\n    assert_eq!(c.get(), Some(&92));\n}\n\n#[test]\nfn once_cell_get_mut() {\n    let mut c = OnceCell::new();\n    assert!(c.get_mut().is_none());\n    c.set(90).unwrap();\n    *c.get_mut().unwrap() += 2;\n    assert_eq!(c.get_mut(), Some(&mut 92));\n}\n\n#[test]\nfn once_cell_drop() {\n    static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n    struct Dropper;\n    impl Drop for Dropper {\n        fn drop(&mut self) {\n            DROP_CNT.fetch_add(1, SeqCst);\n        }\n    }\n\n    let x = OnceCell::new();\n    x.get_or_init(|| Dropper);\n    assert_eq!(DROP_CNT.load(SeqCst), 0);\n    drop(x);\n    assert_eq!(DROP_CNT.load(SeqCst), 1);\n}\n\n#[test]\nfn unsync_once_cell_drop_empty() {\n    let x = OnceCell::<&'static str>::new();\n    drop(x);\n}\n\n#[test]\nfn clone() {\n    let s = OnceCell::new();\n    let c = s.clone();\n    assert!(c.get().is_none());\n\n    s.set(\"hello\").unwrap();\n    let c = s.clone();\n    assert_eq!(c.get().map(|c| *c), Some(\"hello\"));\n}\n\n#[test]\nfn from_impl() {\n    assert_eq!(OnceCell::from(\"value\").get(), Some(&\"value\"));\n    assert_ne!(OnceCell::from(\"foo\").get(), Some(&\"bar\"));\n}\n\n#[test]\nfn partialeq_impl() {\n    assert!(OnceCell::from(\"value\") == OnceCell::from(\"value\"));\n    assert!(OnceCell::from(\"foo\") != OnceCell::from(\"bar\"));\n\n    assert!(OnceCell::<&'static str>::new() == OnceCell::new());\n    assert!(OnceCell::<&'static str>::new() != OnceCell::from(\"value\"));\n}\n\n#[test]\nfn into_inner() {\n    let cell: OnceCell<&'static str> = OnceCell::new();\n    assert_eq!(cell.into_inner(), None);\n    let cell = OnceCell::new();\n    cell.set(\"hello\").unwrap();\n    assert_eq!(cell.into_inner(), Some(\"hello\"));\n}\n\n#[test]\nfn lazy_new() {\n    let called = Cell::new(0);\n    let x = Lazy::new(|| {\n        called.set(called.get() + 1);\n        92\n    });\n\n    assert_eq!(called.get(), 0);\n\n    let y = *x - 30;\n    assert_eq!(y, 62);\n    assert_eq!(called.get(), 1);\n\n    let y = *x - 30;\n    assert_eq!(y, 62);\n    assert_eq!(called.get(), 1);\n}\n\n#[test]\nfn aliasing_in_get() {\n    let x = OnceCell::new();\n    x.set(42).unwrap();\n    let at_x = x.get().unwrap(); // --- (shared) borrow of inner `Option<T>` --+\n    let _ = x.set(27); // <-- temporary (unique) borrow of inner `Option<T>`   |\n    println!(\"{}\", at_x); // <------- up until here ---------------------------+\n}\n\n#[test]\n#[should_panic(expected = \"reentrant init\")]\nfn reentrant_init() {\n    let x: OnceCell<Box<i32>> = OnceCell::new();\n    let dangling_ref: Cell<Option<&i32>> = Cell::new(None);\n    x.get_or_init(|| {\n        let r = x.get_or_init(|| Box::new(92));\n        dangling_ref.set(Some(r));\n        Box::new(62)\n    });\n    eprintln!(\"use after free: {:?}\", dangling_ref.get().unwrap());\n}\n\n#[test]\nfn dropck() {\n    let cell = OnceCell::new();\n    {\n        let s = String::new();\n        cell.set(&s).unwrap();\n    }\n}\n"],[2959,"//! Note\n//! ----\n//! You're probably viewing this file because you're adding a test (or you might\n//! just be browsing, in that case, hey there!).\n//!\n//! The iter test suite is split into two big modules, and some miscellaneous\n//! smaller modules. The two big modules are `adapters` and `traits`.\n//!\n//! `adapters` are for methods on `Iterator` that adapt the data inside the\n//! iterator, whether it be by emitting another iterator or returning an item\n//! from inside the iterator after executing a closure on each item.\n//!\n//! `traits` are for trait's that extend an `Iterator` (and the `Iterator`\n//! trait itself, mostly containing miscellaneous methods). For the most part,\n//! if a test in `traits` uses a specific adapter, then it should be moved to\n//! that adapter's test file in `adapters`.\n\nmod adapters;\nmod range;\nmod sources;\nmod traits;\n\nuse core::cell::Cell;\nuse core::convert::TryFrom;\nuse core::iter::*;\n\npub fn is_trusted_len<I: TrustedLen>(_: I) {}\n\n#[test]\nfn test_multi_iter() {\n    let xs = [1, 2, 3, 4];\n    let ys = [4, 3, 2, 1];\n    assert!(xs.iter().eq(ys.iter().rev()));\n    assert!(xs.iter().lt(xs.iter().skip(2)));\n}\n\n#[test]\nfn test_counter_from_iter() {\n    let it = (0..).step_by(5).take(10);\n    let xs: Vec<isize> = FromIterator::from_iter(it);\n    assert_eq!(xs, [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n}\n\n#[test]\nfn test_functor_laws() {\n    // identity:\n    fn identity<T>(x: T) -> T {\n        x\n    }\n    assert_eq!((0..10).map(identity).sum::<usize>(), (0..10).sum());\n\n    // composition:\n    fn f(x: usize) -> usize {\n        x + 3\n    }\n    fn g(x: usize) -> usize {\n        x * 2\n    }\n    fn h(x: usize) -> usize {\n        g(f(x))\n    }\n    assert_eq!((0..10).map(f).map(g).sum::<usize>(), (0..10).map(h).sum());\n}\n\n#[test]\nfn test_monad_laws_left_identity() {\n    fn f(x: usize) -> impl Iterator<Item = usize> {\n        (0..10).map(move |y| x * y)\n    }\n    assert_eq!(once(42).flat_map(f.clone()).sum::<usize>(), f(42).sum());\n}\n\n#[test]\nfn test_monad_laws_right_identity() {\n    assert_eq!((0..10).flat_map(|x| once(x)).sum::<usize>(), (0..10).sum());\n}\n\n#[test]\nfn test_monad_laws_associativity() {\n    fn f(x: usize) -> impl Iterator<Item = usize> {\n        0..x\n    }\n    fn g(x: usize) -> impl Iterator<Item = usize> {\n        (0..x).rev()\n    }\n    assert_eq!(\n        (0..10).flat_map(f).flat_map(g).sum::<usize>(),\n        (0..10).flat_map(|x| f(x).flat_map(g)).sum::<usize>()\n    );\n}\n\n#[test]\npub fn extend_for_unit() {\n    let mut x = 0;\n    {\n        let iter = (0..5).map(|_| {\n            x += 1;\n        });\n        ().extend(iter);\n    }\n    assert_eq!(x, 5);\n}\n"],[2960,"use super::*;\nuse core::iter::*;\n\n#[test]\nfn test_repeat() {\n    let mut it = repeat(42);\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(repeat(42).size_hint(), (usize::MAX, None));\n}\n\n#[test]\nfn test_repeat_take() {\n    let mut it = repeat(42).take(3);\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(it.next(), None);\n    is_trusted_len(repeat(42).take(3));\n    assert_eq!(repeat(42).take(3).size_hint(), (3, Some(3)));\n    assert_eq!(repeat(42).take(0).size_hint(), (0, Some(0)));\n    assert_eq!(repeat(42).take(usize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n}\n\n#[test]\nfn test_repeat_take_collect() {\n    let v: Vec<_> = repeat(42).take(3).collect();\n    assert_eq!(v, vec![42, 42, 42]);\n}\n\n#[test]\nfn test_repeat_with() {\n    #[derive(PartialEq, Debug)]\n    struct NotClone(usize);\n    let mut it = repeat_with(|| NotClone(42));\n    assert_eq!(it.next(), Some(NotClone(42)));\n    assert_eq!(it.next(), Some(NotClone(42)));\n    assert_eq!(it.next(), Some(NotClone(42)));\n    assert_eq!(repeat_with(|| NotClone(42)).size_hint(), (usize::MAX, None));\n}\n\n#[test]\nfn test_repeat_with_take() {\n    let mut it = repeat_with(|| 42).take(3);\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(it.next(), None);\n    is_trusted_len(repeat_with(|| 42).take(3));\n    assert_eq!(repeat_with(|| 42).take(3).size_hint(), (3, Some(3)));\n    assert_eq!(repeat_with(|| 42).take(0).size_hint(), (0, Some(0)));\n    assert_eq!(repeat_with(|| 42).take(usize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n}\n\n#[test]\nfn test_repeat_with_take_collect() {\n    let mut curr = 1;\n    let v: Vec<_> = repeat_with(|| {\n        let tmp = curr;\n        curr *= 2;\n        tmp\n    })\n    .take(5)\n    .collect();\n    assert_eq!(v, vec![1, 2, 4, 8, 16]);\n}\n\n#[test]\nfn test_successors() {\n    let mut powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n    assert_eq!(powers_of_10.by_ref().collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n    assert_eq!(powers_of_10.next(), None);\n\n    let mut empty = successors(None::<u32>, |_| unimplemented!());\n    assert_eq!(empty.next(), None);\n    assert_eq!(empty.next(), None);\n}\n\n#[test]\nfn test_once() {\n    let mut it = once(42);\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn test_once_with() {\n    let count = Cell::new(0);\n    let mut it = once_with(|| {\n        count.set(count.get() + 1);\n        42\n    });\n\n    assert_eq!(count.get(), 0);\n    assert_eq!(it.next(), Some(42));\n    assert_eq!(count.get(), 1);\n    assert_eq!(it.next(), None);\n    assert_eq!(count.get(), 1);\n    assert_eq!(it.next(), None);\n    assert_eq!(count.get(), 1);\n}\n\n#[test]\nfn test_empty() {\n    let mut it = empty::<i32>();\n    assert_eq!(it.next(), None);\n}\n"],[2961,"use super::*;\n\n#[test]\nfn test_range() {\n    assert_eq!((0..5).collect::<Vec<_>>(), [0, 1, 2, 3, 4]);\n    assert_eq!((-10..-1).collect::<Vec<_>>(), [-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n    assert_eq!((0..5).rev().collect::<Vec<_>>(), [4, 3, 2, 1, 0]);\n    assert_eq!((200..-5).count(), 0);\n    assert_eq!((200..-5).rev().count(), 0);\n    assert_eq!((200..200).count(), 0);\n    assert_eq!((200..200).rev().count(), 0);\n\n    assert_eq!((0..100).size_hint(), (100, Some(100)));\n    // this test is only meaningful when sizeof usize < sizeof u64\n    assert_eq!((usize::MAX - 1..usize::MAX).size_hint(), (1, Some(1)));\n    assert_eq!((-10..-1).size_hint(), (9, Some(9)));\n    assert_eq!((-1..-10).size_hint(), (0, Some(0)));\n\n    assert_eq!((-70..58).size_hint(), (128, Some(128)));\n    assert_eq!((-128..127).size_hint(), (255, Some(255)));\n    assert_eq!(\n        (-2..isize::MAX).size_hint(),\n        (isize::MAX as usize + 2, Some(isize::MAX as usize + 2))\n    );\n}\n\n#[test]\nfn test_char_range() {\n    use std::char;\n    // Miri is too slow\n    let from = if cfg!(miri) { char::from_u32(0xD800 - 10).unwrap() } else { '\\0' };\n    let to = if cfg!(miri) { char::from_u32(0xDFFF + 10).unwrap() } else { char::MAX };\n    assert!((from..=to).eq((from as u32..=to as u32).filter_map(char::from_u32)));\n    assert!((from..=to).rev().eq((from as u32..=to as u32).filter_map(char::from_u32).rev()));\n\n    assert_eq!(('\\u{D7FF}'..='\\u{E000}').count(), 2);\n    assert_eq!(('\\u{D7FF}'..='\\u{E000}').size_hint(), (2, Some(2)));\n    assert_eq!(('\\u{D7FF}'..'\\u{E000}').count(), 1);\n    assert_eq!(('\\u{D7FF}'..'\\u{E000}').size_hint(), (1, Some(1)));\n}\n\n#[test]\nfn test_range_exhaustion() {\n    let mut r = 10..10;\n    assert!(r.is_empty());\n    assert_eq!(r.next(), None);\n    assert_eq!(r.next_back(), None);\n    assert_eq!(r, 10..10);\n\n    let mut r = 10..12;\n    assert_eq!(r.next(), Some(10));\n    assert_eq!(r.next(), Some(11));\n    assert!(r.is_empty());\n    assert_eq!(r, 12..12);\n    assert_eq!(r.next(), None);\n\n    let mut r = 10..12;\n    assert_eq!(r.next_back(), Some(11));\n    assert_eq!(r.next_back(), Some(10));\n    assert!(r.is_empty());\n    assert_eq!(r, 10..10);\n    assert_eq!(r.next_back(), None);\n\n    let mut r = 100..10;\n    assert!(r.is_empty());\n    assert_eq!(r.next(), None);\n    assert_eq!(r.next_back(), None);\n    assert_eq!(r, 100..10);\n}\n\n#[test]\nfn test_range_inclusive_exhaustion() {\n    let mut r = 10..=10;\n    assert_eq!(r.next(), Some(10));\n    assert!(r.is_empty());\n    assert_eq!(r.next(), None);\n    assert_eq!(r.next(), None);\n\n    assert_eq!(*r.start(), 10);\n    assert_eq!(*r.end(), 10);\n    assert_ne!(r, 10..=10);\n\n    let mut r = 10..=10;\n    assert_eq!(r.next_back(), Some(10));\n    assert!(r.is_empty());\n    assert_eq!(r.next_back(), None);\n\n    assert_eq!(*r.start(), 10);\n    assert_eq!(*r.end(), 10);\n    assert_ne!(r, 10..=10);\n\n    let mut r = 10..=12;\n    assert_eq!(r.next(), Some(10));\n    assert_eq!(r.next(), Some(11));\n    assert_eq!(r.next(), Some(12));\n    assert!(r.is_empty());\n    assert_eq!(r.next(), None);\n\n    let mut r = 10..=12;\n    assert_eq!(r.next_back(), Some(12));\n    assert_eq!(r.next_back(), Some(11));\n    assert_eq!(r.next_back(), Some(10));\n    assert!(r.is_empty());\n    assert_eq!(r.next_back(), None);\n\n    let mut r = 10..=12;\n    assert_eq!(r.nth(2), Some(12));\n    assert!(r.is_empty());\n    assert_eq!(r.next(), None);\n\n    let mut r = 10..=12;\n    assert_eq!(r.nth(5), None);\n    assert!(r.is_empty());\n    assert_eq!(r.next(), None);\n\n    let mut r = 100..=10;\n    assert_eq!(r.next(), None);\n    assert!(r.is_empty());\n    assert_eq!(r.next(), None);\n    assert_eq!(r.next(), None);\n    assert_eq!(r, 100..=10);\n\n    let mut r = 100..=10;\n    assert_eq!(r.next_back(), None);\n    assert!(r.is_empty());\n    assert_eq!(r.next_back(), None);\n    assert_eq!(r.next_back(), None);\n    assert_eq!(r, 100..=10);\n}\n\n#[test]\nfn test_range_nth() {\n    assert_eq!((10..15).nth(0), Some(10));\n    assert_eq!((10..15).nth(1), Some(11));\n    assert_eq!((10..15).nth(4), Some(14));\n    assert_eq!((10..15).nth(5), None);\n\n    let mut r = 10..20;\n    assert_eq!(r.nth(2), Some(12));\n    assert_eq!(r, 13..20);\n    assert_eq!(r.nth(2), Some(15));\n    assert_eq!(r, 16..20);\n    assert_eq!(r.nth(10), None);\n    assert_eq!(r, 20..20);\n}\n\n#[test]\nfn test_range_nth_back() {\n    assert_eq!((10..15).nth_back(0), Some(14));\n    assert_eq!((10..15).nth_back(1), Some(13));\n    assert_eq!((10..15).nth_back(4), Some(10));\n    assert_eq!((10..15).nth_back(5), None);\n    assert_eq!((-120..80_i8).nth_back(199), Some(-120));\n\n    let mut r = 10..20;\n    assert_eq!(r.nth_back(2), Some(17));\n    assert_eq!(r, 10..17);\n    assert_eq!(r.nth_back(2), Some(14));\n    assert_eq!(r, 10..14);\n    assert_eq!(r.nth_back(10), None);\n    assert_eq!(r, 10..10);\n}\n\n#[test]\nfn test_range_from_nth() {\n    assert_eq!((10..).nth(0), Some(10));\n    assert_eq!((10..).nth(1), Some(11));\n    assert_eq!((10..).nth(4), Some(14));\n\n    let mut r = 10..;\n    assert_eq!(r.nth(2), Some(12));\n    assert_eq!(r, 13..);\n    assert_eq!(r.nth(2), Some(15));\n    assert_eq!(r, 16..);\n    assert_eq!(r.nth(10), Some(26));\n    assert_eq!(r, 27..);\n\n    assert_eq!((0..).size_hint(), (usize::MAX, None));\n}\n\n#[test]\nfn test_range_from_take() {\n    let mut it = (0..).take(3);\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.next(), Some(1));\n    assert_eq!(it.next(), Some(2));\n    assert_eq!(it.next(), None);\n    is_trusted_len((0..).take(3));\n    assert_eq!((0..).take(3).size_hint(), (3, Some(3)));\n    assert_eq!((0..).take(0).size_hint(), (0, Some(0)));\n    assert_eq!((0..).take(usize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n}\n\n#[test]\nfn test_range_from_take_collect() {\n    let v: Vec<_> = (0..).take(3).collect();\n    assert_eq!(v, vec![0, 1, 2]);\n}\n\n#[test]\nfn test_range_inclusive_nth() {\n    assert_eq!((10..=15).nth(0), Some(10));\n    assert_eq!((10..=15).nth(1), Some(11));\n    assert_eq!((10..=15).nth(5), Some(15));\n    assert_eq!((10..=15).nth(6), None);\n\n    let mut exhausted_via_next = 10_u8..=20;\n    while exhausted_via_next.next().is_some() {}\n\n    let mut r = 10_u8..=20;\n    assert_eq!(r.nth(2), Some(12));\n    assert_eq!(r, 13..=20);\n    assert_eq!(r.nth(2), Some(15));\n    assert_eq!(r, 16..=20);\n    assert_eq!(r.is_empty(), false);\n    assert_eq!(ExactSizeIterator::is_empty(&r), false);\n    assert_eq!(r.nth(10), None);\n    assert_eq!(r.is_empty(), true);\n    assert_eq!(r, exhausted_via_next);\n    assert_eq!(ExactSizeIterator::is_empty(&r), true);\n}\n\n#[test]\nfn test_range_inclusive_nth_back() {\n    assert_eq!((10..=15).nth_back(0), Some(15));\n    assert_eq!((10..=15).nth_back(1), Some(14));\n    assert_eq!((10..=15).nth_back(5), Some(10));\n    assert_eq!((10..=15).nth_back(6), None);\n    assert_eq!((-120..=80_i8).nth_back(200), Some(-120));\n\n    let mut exhausted_via_next_back = 10_u8..=20;\n    while exhausted_via_next_back.next_back().is_some() {}\n\n    let mut r = 10_u8..=20;\n    assert_eq!(r.nth_back(2), Some(18));\n    assert_eq!(r, 10..=17);\n    assert_eq!(r.nth_back(2), Some(15));\n    assert_eq!(r, 10..=14);\n    assert_eq!(r.is_empty(), false);\n    assert_eq!(ExactSizeIterator::is_empty(&r), false);\n    assert_eq!(r.nth_back(10), None);\n    assert_eq!(r.is_empty(), true);\n    assert_eq!(r, exhausted_via_next_back);\n    assert_eq!(ExactSizeIterator::is_empty(&r), true);\n}\n\n#[test]\nfn test_range_len() {\n    assert_eq!((0..10_u8).len(), 10);\n    assert_eq!((9..10_u8).len(), 1);\n    assert_eq!((10..10_u8).len(), 0);\n    assert_eq!((11..10_u8).len(), 0);\n    assert_eq!((100..10_u8).len(), 0);\n}\n\n#[test]\nfn test_range_inclusive_len() {\n    assert_eq!((0..=10_u8).len(), 11);\n    assert_eq!((9..=10_u8).len(), 2);\n    assert_eq!((10..=10_u8).len(), 1);\n    assert_eq!((11..=10_u8).len(), 0);\n    assert_eq!((100..=10_u8).len(), 0);\n}\n\n#[test]\nfn test_range_step() {\n    #![allow(deprecated)]\n\n    assert_eq!((0..20).step_by(5).collect::<Vec<isize>>(), [0, 5, 10, 15]);\n    assert_eq!((1..21).rev().step_by(5).collect::<Vec<isize>>(), [20, 15, 10, 5]);\n    assert_eq!((1..21).rev().step_by(6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n    assert_eq!((200..255).step_by(50).collect::<Vec<u8>>(), [200, 250]);\n    assert_eq!((200..-5).step_by(1).collect::<Vec<isize>>(), []);\n    assert_eq!((200..200).step_by(1).collect::<Vec<isize>>(), []);\n\n    assert_eq!((0..20).step_by(1).size_hint(), (20, Some(20)));\n    assert_eq!((0..20).step_by(21).size_hint(), (1, Some(1)));\n    assert_eq!((0..20).step_by(5).size_hint(), (4, Some(4)));\n    assert_eq!((1..21).rev().step_by(5).size_hint(), (4, Some(4)));\n    assert_eq!((1..21).rev().step_by(6).size_hint(), (4, Some(4)));\n    assert_eq!((20..-5).step_by(1).size_hint(), (0, Some(0)));\n    assert_eq!((20..20).step_by(1).size_hint(), (0, Some(0)));\n    assert_eq!((i8::MIN..i8::MAX).step_by(-(i8::MIN as i32) as usize).size_hint(), (2, Some(2)));\n    assert_eq!((i16::MIN..i16::MAX).step_by(i16::MAX as usize).size_hint(), (3, Some(3)));\n    assert_eq!((isize::MIN..isize::MAX).step_by(1).size_hint(), (usize::MAX, Some(usize::MAX)));\n}\n\n#[test]\nfn test_range_inclusive_step() {\n    assert_eq!((0..=50).step_by(10).collect::<Vec<_>>(), [0, 10, 20, 30, 40, 50]);\n    assert_eq!((0..=5).step_by(1).collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5]);\n    assert_eq!((200..=255u8).step_by(10).collect::<Vec<_>>(), [200, 210, 220, 230, 240, 250]);\n    assert_eq!((250..=255u8).step_by(1).collect::<Vec<_>>(), [250, 251, 252, 253, 254, 255]);\n}\n\n#[test]\nfn test_range_last_max() {\n    assert_eq!((0..20).last(), Some(19));\n    assert_eq!((-20..0).last(), Some(-1));\n    assert_eq!((5..5).last(), None);\n\n    assert_eq!((0..20).max(), Some(19));\n    assert_eq!((-20..0).max(), Some(-1));\n    assert_eq!((5..5).max(), None);\n}\n\n#[test]\nfn test_range_inclusive_last_max() {\n    assert_eq!((0..=20).last(), Some(20));\n    assert_eq!((-20..=0).last(), Some(0));\n    assert_eq!((5..=5).last(), Some(5));\n    let mut r = 10..=10;\n    r.next();\n    assert_eq!(r.last(), None);\n\n    assert_eq!((0..=20).max(), Some(20));\n    assert_eq!((-20..=0).max(), Some(0));\n    assert_eq!((5..=5).max(), Some(5));\n    let mut r = 10..=10;\n    r.next();\n    assert_eq!(r.max(), None);\n}\n\n#[test]\nfn test_range_min() {\n    assert_eq!((0..20).min(), Some(0));\n    assert_eq!((-20..0).min(), Some(-20));\n    assert_eq!((5..5).min(), None);\n}\n\n#[test]\nfn test_range_inclusive_min() {\n    assert_eq!((0..=20).min(), Some(0));\n    assert_eq!((-20..=0).min(), Some(-20));\n    assert_eq!((5..=5).min(), Some(5));\n    let mut r = 10..=10;\n    r.next();\n    assert_eq!(r.min(), None);\n}\n\n#[test]\nfn test_range_inclusive_folds() {\n    assert_eq!((1..=10).sum::<i32>(), 55);\n    assert_eq!((1..=10).rev().sum::<i32>(), 55);\n\n    let mut it = 44..=50;\n    assert_eq!(it.try_fold(0, i8::checked_add), None);\n    assert_eq!(it, 47..=50);\n    assert_eq!(it.try_fold(0, i8::checked_add), None);\n    assert_eq!(it, 50..=50);\n    assert_eq!(it.try_fold(0, i8::checked_add), Some(50));\n    assert!(it.is_empty());\n    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n    assert!(it.is_empty());\n\n    let mut it = 40..=47;\n    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n    assert_eq!(it, 40..=44);\n    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n    assert_eq!(it, 40..=41);\n    assert_eq!(it.try_rfold(0, i8::checked_add), Some(81));\n    assert!(it.is_empty());\n    assert_eq!(it.try_rfold(0, i8::checked_add), Some(0));\n    assert!(it.is_empty());\n\n    let mut it = 10..=20;\n    assert_eq!(it.try_fold(0, |a, b| Some(a + b)), Some(165));\n    assert!(it.is_empty());\n    assert_eq!(it.try_fold(0, |a, b| Some(a + b)), Some(0));\n    assert!(it.is_empty());\n\n    let mut it = 10..=20;\n    assert_eq!(it.try_rfold(0, |a, b| Some(a + b)), Some(165));\n    assert!(it.is_empty());\n    assert_eq!(it.try_rfold(0, |a, b| Some(a + b)), Some(0));\n    assert!(it.is_empty());\n}\n\n#[test]\nfn test_range_size_hint() {\n    assert_eq!((0..0usize).size_hint(), (0, Some(0)));\n    assert_eq!((0..100usize).size_hint(), (100, Some(100)));\n    assert_eq!((0..usize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n\n    let umax = u128::try_from(usize::MAX).unwrap();\n    assert_eq!((0..0u128).size_hint(), (0, Some(0)));\n    assert_eq!((0..100u128).size_hint(), (100, Some(100)));\n    assert_eq!((0..umax).size_hint(), (usize::MAX, Some(usize::MAX)));\n    assert_eq!((0..umax + 1).size_hint(), (usize::MAX, None));\n\n    assert_eq!((0..0isize).size_hint(), (0, Some(0)));\n    assert_eq!((-100..100isize).size_hint(), (200, Some(200)));\n    assert_eq!((isize::MIN..isize::MAX).size_hint(), (usize::MAX, Some(usize::MAX)));\n\n    let imin = i128::try_from(isize::MIN).unwrap();\n    let imax = i128::try_from(isize::MAX).unwrap();\n    assert_eq!((0..0i128).size_hint(), (0, Some(0)));\n    assert_eq!((-100..100i128).size_hint(), (200, Some(200)));\n    assert_eq!((imin..imax).size_hint(), (usize::MAX, Some(usize::MAX)));\n    assert_eq!((imin..imax + 1).size_hint(), (usize::MAX, None));\n}\n\n#[test]\nfn test_range_inclusive_size_hint() {\n    assert_eq!((1..=0usize).size_hint(), (0, Some(0)));\n    assert_eq!((0..=0usize).size_hint(), (1, Some(1)));\n    assert_eq!((0..=100usize).size_hint(), (101, Some(101)));\n    assert_eq!((0..=usize::MAX - 1).size_hint(), (usize::MAX, Some(usize::MAX)));\n    assert_eq!((0..=usize::MAX).size_hint(), (usize::MAX, None));\n\n    let umax = u128::try_from(usize::MAX).unwrap();\n    assert_eq!((1..=0u128).size_hint(), (0, Some(0)));\n    assert_eq!((0..=0u128).size_hint(), (1, Some(1)));\n    assert_eq!((0..=100u128).size_hint(), (101, Some(101)));\n    assert_eq!((0..=umax - 1).size_hint(), (usize::MAX, Some(usize::MAX)));\n    assert_eq!((0..=umax).size_hint(), (usize::MAX, None));\n    assert_eq!((0..=umax + 1).size_hint(), (usize::MAX, None));\n\n    assert_eq!((0..=-1isize).size_hint(), (0, Some(0)));\n    assert_eq!((0..=0isize).size_hint(), (1, Some(1)));\n    assert_eq!((-100..=100isize).size_hint(), (201, Some(201)));\n    assert_eq!((isize::MIN..=isize::MAX - 1).size_hint(), (usize::MAX, Some(usize::MAX)));\n    assert_eq!((isize::MIN..=isize::MAX).size_hint(), (usize::MAX, None));\n\n    let imin = i128::try_from(isize::MIN).unwrap();\n    let imax = i128::try_from(isize::MAX).unwrap();\n    assert_eq!((0..=-1i128).size_hint(), (0, Some(0)));\n    assert_eq!((0..=0i128).size_hint(), (1, Some(1)));\n    assert_eq!((-100..=100i128).size_hint(), (201, Some(201)));\n    assert_eq!((imin..=imax - 1).size_hint(), (usize::MAX, Some(usize::MAX)));\n    assert_eq!((imin..=imax).size_hint(), (usize::MAX, None));\n    assert_eq!((imin..=imax + 1).size_hint(), (usize::MAX, None));\n}\n\n#[test]\nfn test_double_ended_range() {\n    assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n    for _ in (10..0).rev() {\n        panic!(\"unreachable\");\n    }\n\n    assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n    for _ in (10..0).rev() {\n        panic!(\"unreachable\");\n    }\n}\n"],[2962,"mod accum;\nmod double_ended;\nmod iterator;\nmod step;\n"],[2963,"/// A wrapper struct that implements `Eq` and `Ord` based on the wrapped\n/// integer modulo 3. Used to test that `Iterator::max` and `Iterator::min`\n/// return the correct element if some of them are equal.\n#[derive(Debug)]\nstruct Mod3(i32);\n\nimpl PartialEq for Mod3 {\n    fn eq(&self, other: &Self) -> bool {\n        self.0 % 3 == other.0 % 3\n    }\n}\n\nimpl Eq for Mod3 {}\n\nimpl PartialOrd for Mod3 {\n    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Mod3 {\n    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n        (self.0 % 3).cmp(&(other.0 % 3))\n    }\n}\n\n#[test]\nfn test_lt() {\n    let empty: [isize; 0] = [];\n    let xs = [1, 2, 3];\n    let ys = [1, 2, 0];\n\n    assert!(!xs.iter().lt(ys.iter()));\n    assert!(!xs.iter().le(ys.iter()));\n    assert!(xs.iter().gt(ys.iter()));\n    assert!(xs.iter().ge(ys.iter()));\n\n    assert!(ys.iter().lt(xs.iter()));\n    assert!(ys.iter().le(xs.iter()));\n    assert!(!ys.iter().gt(xs.iter()));\n    assert!(!ys.iter().ge(xs.iter()));\n\n    assert!(empty.iter().lt(xs.iter()));\n    assert!(empty.iter().le(xs.iter()));\n    assert!(!empty.iter().gt(xs.iter()));\n    assert!(!empty.iter().ge(xs.iter()));\n\n    // Sequence with NaN\n    let u = [1.0f64, 2.0];\n    let v = [0.0f64 / 0.0, 3.0];\n\n    assert!(!u.iter().lt(v.iter()));\n    assert!(!u.iter().le(v.iter()));\n    assert!(!u.iter().gt(v.iter()));\n    assert!(!u.iter().ge(v.iter()));\n\n    let a = [0.0f64 / 0.0];\n    let b = [1.0f64];\n    let c = [2.0f64];\n\n    assert!(a.iter().lt(b.iter()) == (a[0] < b[0]));\n    assert!(a.iter().le(b.iter()) == (a[0] <= b[0]));\n    assert!(a.iter().gt(b.iter()) == (a[0] > b[0]));\n    assert!(a.iter().ge(b.iter()) == (a[0] >= b[0]));\n\n    assert!(c.iter().lt(b.iter()) == (c[0] < b[0]));\n    assert!(c.iter().le(b.iter()) == (c[0] <= b[0]));\n    assert!(c.iter().gt(b.iter()) == (c[0] > b[0]));\n    assert!(c.iter().ge(b.iter()) == (c[0] >= b[0]));\n}\n\n#[test]\nfn test_cmp_by() {\n    use core::cmp::Ordering;\n\n    let f = |x: i32, y: i32| (x * x).cmp(&y);\n    let xs = || [1, 2, 3, 4].iter().copied();\n    let ys = || [1, 4, 16].iter().copied();\n\n    assert_eq!(xs().cmp_by(ys(), f), Ordering::Less);\n    assert_eq!(ys().cmp_by(xs(), f), Ordering::Greater);\n    assert_eq!(xs().cmp_by(xs().map(|x| x * x), f), Ordering::Equal);\n    assert_eq!(xs().rev().cmp_by(ys().rev(), f), Ordering::Greater);\n    assert_eq!(xs().cmp_by(ys().rev(), f), Ordering::Less);\n    assert_eq!(xs().cmp_by(ys().take(2), f), Ordering::Greater);\n}\n\n#[test]\nfn test_partial_cmp_by() {\n    use core::cmp::Ordering;\n\n    let f = |x: i32, y: i32| (x * x).partial_cmp(&y);\n    let xs = || [1, 2, 3, 4].iter().copied();\n    let ys = || [1, 4, 16].iter().copied();\n\n    assert_eq!(xs().partial_cmp_by(ys(), f), Some(Ordering::Less));\n    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n    assert_eq!(xs().partial_cmp_by(xs().map(|x| x * x), f), Some(Ordering::Equal));\n    assert_eq!(xs().rev().partial_cmp_by(ys().rev(), f), Some(Ordering::Greater));\n    assert_eq!(xs().partial_cmp_by(xs().rev(), f), Some(Ordering::Less));\n    assert_eq!(xs().partial_cmp_by(ys().take(2), f), Some(Ordering::Greater));\n\n    let f = |x: f64, y: f64| (x * x).partial_cmp(&y);\n    let xs = || [1.0, 2.0, 3.0, 4.0].iter().copied();\n    let ys = || [1.0, 4.0, f64::NAN, 16.0].iter().copied();\n\n    assert_eq!(xs().partial_cmp_by(ys(), f), None);\n    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n}\n\n#[test]\nfn test_eq_by() {\n    let f = |x: i32, y: i32| x * x == y;\n    let xs = || [1, 2, 3, 4].iter().copied();\n    let ys = || [1, 4, 9, 16].iter().copied();\n\n    assert!(xs().eq_by(ys(), f));\n    assert!(!ys().eq_by(xs(), f));\n    assert!(!xs().eq_by(xs(), f));\n    assert!(!ys().eq_by(ys(), f));\n\n    assert!(!xs().take(3).eq_by(ys(), f));\n    assert!(!xs().eq_by(ys().take(3), f));\n    assert!(xs().take(3).eq_by(ys().take(3), f));\n}\n\n#[test]\nfn test_iterator_nth() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n    for i in 0..v.len() {\n        assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n    }\n    assert_eq!(v.iter().nth(v.len()), None);\n}\n\n#[test]\nfn test_iterator_nth_back() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n    for i in 0..v.len() {\n        assert_eq!(v.iter().nth_back(i).unwrap(), &v[v.len() - 1 - i]);\n    }\n    assert_eq!(v.iter().nth_back(v.len()), None);\n}\n\n#[test]\nfn test_iterator_advance_by() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n\n    for i in 0..v.len() {\n        let mut iter = v.iter();\n        assert_eq!(iter.advance_by(i), Ok(()));\n        assert_eq!(iter.next().unwrap(), &v[i]);\n        assert_eq!(iter.advance_by(100), Err(v.len() - 1 - i));\n    }\n\n    assert_eq!(v.iter().advance_by(v.len()), Ok(()));\n    assert_eq!(v.iter().advance_by(100), Err(v.len()));\n}\n\n#[test]\nfn test_iterator_advance_back_by() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n\n    for i in 0..v.len() {\n        let mut iter = v.iter();\n        assert_eq!(iter.advance_back_by(i), Ok(()));\n        assert_eq!(iter.next_back().unwrap(), &v[v.len() - 1 - i]);\n        assert_eq!(iter.advance_back_by(100), Err(v.len() - 1 - i));\n    }\n\n    assert_eq!(v.iter().advance_back_by(v.len()), Ok(()));\n    assert_eq!(v.iter().advance_back_by(100), Err(v.len()));\n}\n\n#[test]\nfn test_iterator_rev_advance_back_by() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n\n    for i in 0..v.len() {\n        let mut iter = v.iter().rev();\n        assert_eq!(iter.advance_back_by(i), Ok(()));\n        assert_eq!(iter.next_back().unwrap(), &v[i]);\n        assert_eq!(iter.advance_back_by(100), Err(v.len() - 1 - i));\n    }\n\n    assert_eq!(v.iter().rev().advance_back_by(v.len()), Ok(()));\n    assert_eq!(v.iter().rev().advance_back_by(100), Err(v.len()));\n}\n\n#[test]\nfn test_iterator_last() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n    assert_eq!(v.iter().last().unwrap(), &4);\n    assert_eq!(v[..1].iter().last().unwrap(), &0);\n}\n\n#[test]\nfn test_iterator_max() {\n    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..4].iter().cloned().max(), Some(3));\n    assert_eq!(v.iter().cloned().max(), Some(10));\n    assert_eq!(v[..0].iter().cloned().max(), None);\n    assert_eq!(v.iter().cloned().map(Mod3).max().map(|x| x.0), Some(8));\n}\n\n#[test]\nfn test_iterator_min() {\n    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..4].iter().cloned().min(), Some(0));\n    assert_eq!(v.iter().cloned().min(), Some(0));\n    assert_eq!(v[..0].iter().cloned().min(), None);\n    assert_eq!(v.iter().cloned().map(Mod3).min().map(|x| x.0), Some(0));\n}\n\n#[test]\nfn test_iterator_size_hint() {\n    let c = (0..).step_by(1);\n    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let v2 = &[10, 11, 12];\n    let vi = v.iter();\n\n    assert_eq!((0..).size_hint(), (usize::MAX, None));\n    assert_eq!(c.size_hint(), (usize::MAX, None));\n    assert_eq!(vi.clone().size_hint(), (10, Some(10)));\n\n    assert_eq!(c.clone().take(5).size_hint(), (5, Some(5)));\n    assert_eq!(c.clone().skip(5).size_hint().1, None);\n    assert_eq!(c.clone().take_while(|_| false).size_hint(), (0, None));\n    assert_eq!(c.clone().map_while(|_| None::<()>).size_hint(), (0, None));\n    assert_eq!(c.clone().skip_while(|_| false).size_hint(), (0, None));\n    assert_eq!(c.clone().enumerate().size_hint(), (usize::MAX, None));\n    assert_eq!(c.clone().chain(vi.clone().cloned()).size_hint(), (usize::MAX, None));\n    assert_eq!(c.clone().zip(vi.clone()).size_hint(), (10, Some(10)));\n    assert_eq!(c.clone().scan(0, |_, _| Some(0)).size_hint(), (0, None));\n    assert_eq!(c.clone().filter(|_| false).size_hint(), (0, None));\n    assert_eq!(c.clone().map(|_| 0).size_hint(), (usize::MAX, None));\n    assert_eq!(c.filter_map(|_| Some(0)).size_hint(), (0, None));\n\n    assert_eq!(vi.clone().take(5).size_hint(), (5, Some(5)));\n    assert_eq!(vi.clone().take(12).size_hint(), (10, Some(10)));\n    assert_eq!(vi.clone().skip(3).size_hint(), (7, Some(7)));\n    assert_eq!(vi.clone().skip(12).size_hint(), (0, Some(0)));\n    assert_eq!(vi.clone().take_while(|_| false).size_hint(), (0, Some(10)));\n    assert_eq!(vi.clone().map_while(|_| None::<()>).size_hint(), (0, Some(10)));\n    assert_eq!(vi.clone().skip_while(|_| false).size_hint(), (0, Some(10)));\n    assert_eq!(vi.clone().enumerate().size_hint(), (10, Some(10)));\n    assert_eq!(vi.clone().chain(v2).size_hint(), (13, Some(13)));\n    assert_eq!(vi.clone().zip(v2).size_hint(), (3, Some(3)));\n    assert_eq!(vi.clone().scan(0, |_, _| Some(0)).size_hint(), (0, Some(10)));\n    assert_eq!(vi.clone().filter(|_| false).size_hint(), (0, Some(10)));\n    assert_eq!(vi.clone().map(|&i| i + 1).size_hint(), (10, Some(10)));\n    assert_eq!(vi.filter_map(|_| Some(0)).size_hint(), (0, Some(10)));\n}\n\n#[test]\nfn test_all() {\n    let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n    assert!(v.iter().all(|&x| x < 10));\n    assert!(!v.iter().all(|&x| x % 2 == 0));\n    assert!(!v.iter().all(|&x| x > 100));\n    assert!(v[..0].iter().all(|_| panic!()));\n}\n\n#[test]\nfn test_any() {\n    let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n    assert!(v.iter().any(|&x| x < 10));\n    assert!(v.iter().any(|&x| x % 2 == 0));\n    assert!(!v.iter().any(|&x| x > 100));\n    assert!(!v[..0].iter().any(|_| panic!()));\n}\n\n#[test]\nfn test_find() {\n    let v: &[isize] = &[1, 3, 9, 27, 103, 14, 11];\n    assert_eq!(*v.iter().find(|&&x| x & 1 == 0).unwrap(), 14);\n    assert_eq!(*v.iter().find(|&&x| x % 3 == 0).unwrap(), 3);\n    assert!(v.iter().find(|&&x| x % 12 == 0).is_none());\n}\n\n#[test]\nfn test_try_find() {\n    let xs: &[isize] = &[];\n    assert_eq!(xs.iter().try_find(testfn), Ok(None));\n    let xs: &[isize] = &[1, 2, 3, 4];\n    assert_eq!(xs.iter().try_find(testfn), Ok(Some(&2)));\n    let xs: &[isize] = &[1, 3, 4];\n    assert_eq!(xs.iter().try_find(testfn), Err(()));\n\n    let xs: &[isize] = &[1, 2, 3, 4, 5, 6, 7];\n    let mut iter = xs.iter();\n    assert_eq!(iter.try_find(testfn), Ok(Some(&2)));\n    assert_eq!(iter.try_find(testfn), Err(()));\n    assert_eq!(iter.next(), Some(&5));\n\n    fn testfn(x: &&isize) -> Result<bool, ()> {\n        if **x == 2 {\n            return Ok(true);\n        }\n        if **x == 4 {\n            return Err(());\n        }\n        Ok(false)\n    }\n}\n\n#[test]\nfn test_try_find_api_usability() -> Result<(), Box<dyn std::error::Error>> {\n    let a = [\"1\", \"2\"];\n\n    let is_my_num = |s: &str, search: i32| -> Result<bool, std::num::ParseIntError> {\n        Ok(s.parse::<i32>()? == search)\n    };\n\n    let val = a.iter().try_find(|&&s| is_my_num(s, 2))?;\n    assert_eq!(val, Some(&\"2\"));\n\n    Ok(())\n}\n\n#[test]\nfn test_position() {\n    let v = &[1, 3, 9, 27, 103, 14, 11];\n    assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n    assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n    assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n}\n\n#[test]\nfn test_count() {\n    let xs = &[1, 2, 2, 1, 5, 9, 0, 2];\n    assert_eq!(xs.iter().filter(|x| **x == 2).count(), 3);\n    assert_eq!(xs.iter().filter(|x| **x == 5).count(), 1);\n    assert_eq!(xs.iter().filter(|x| **x == 95).count(), 0);\n}\n\n#[test]\nfn test_max_by_key() {\n    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n    assert_eq!(*xs.iter().max_by_key(|x| x.abs()).unwrap(), -10);\n}\n\n#[test]\nfn test_max_by() {\n    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n    assert_eq!(*xs.iter().max_by(|x, y| x.abs().cmp(&y.abs())).unwrap(), -10);\n}\n\n#[test]\nfn test_min_by_key() {\n    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n    assert_eq!(*xs.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n}\n\n#[test]\nfn test_min_by() {\n    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n    assert_eq!(*xs.iter().min_by(|x, y| x.abs().cmp(&y.abs())).unwrap(), 0);\n}\n\n#[test]\nfn test_by_ref() {\n    let mut xs = 0..10;\n    // sum the first five values\n    let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n    assert_eq!(partial_sum, 10);\n    assert_eq!(xs.next(), Some(5));\n}\n\n#[test]\nfn test_is_sorted() {\n    assert!([1, 2, 2, 9].iter().is_sorted());\n    assert!(![1, 3, 2].iter().is_sorted());\n    assert!([0].iter().is_sorted());\n    assert!(std::iter::empty::<i32>().is_sorted());\n    assert!(![0.0, 1.0, f32::NAN].iter().is_sorted());\n    assert!([-2, -1, 0, 3].iter().is_sorted());\n    assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n    assert!(![\"c\", \"bb\", \"aaa\"].iter().is_sorted());\n    assert!([\"c\", \"bb\", \"aaa\"].iter().is_sorted_by_key(|s| s.len()));\n}\n\n#[test]\nfn test_partition() {\n    fn check(xs: &mut [i32], ref p: impl Fn(&i32) -> bool, expected: usize) {\n        let i = xs.iter_mut().partition_in_place(p);\n        assert_eq!(expected, i);\n        assert!(xs[..i].iter().all(p));\n        assert!(!xs[i..].iter().any(p));\n        assert!(xs.iter().is_partitioned(p));\n        if i == 0 || i == xs.len() {\n            assert!(xs.iter().rev().is_partitioned(p));\n        } else {\n            assert!(!xs.iter().rev().is_partitioned(p));\n        }\n    }\n\n    check(&mut [], |_| true, 0);\n    check(&mut [], |_| false, 0);\n\n    check(&mut [0], |_| true, 1);\n    check(&mut [0], |_| false, 0);\n\n    check(&mut [-1, 1], |&x| x > 0, 1);\n    check(&mut [-1, 1], |&x| x < 0, 1);\n\n    let ref mut xs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    check(xs, |_| true, 10);\n    check(xs, |_| false, 0);\n    check(xs, |&x| x % 2 == 0, 5); // evens\n    check(xs, |&x| x % 2 == 1, 5); // odds\n    check(xs, |&x| x % 3 == 0, 4); // multiple of 3\n    check(xs, |&x| x % 4 == 0, 3); // multiple of 4\n    check(xs, |&x| x % 5 == 0, 2); // multiple of 5\n    check(xs, |&x| x < 3, 3); // small\n    check(xs, |&x| x > 6, 3); // large\n}\n\n#[test]\nfn test_iterator_rev_advance_by() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n\n    for i in 0..v.len() {\n        let mut iter = v.iter().rev();\n        assert_eq!(iter.advance_by(i), Ok(()));\n        assert_eq!(iter.next().unwrap(), &v[v.len() - 1 - i]);\n        assert_eq!(iter.advance_by(100), Err(v.len() - 1 - i));\n    }\n\n    assert_eq!(v.iter().rev().advance_by(v.len()), Ok(()));\n    assert_eq!(v.iter().rev().advance_by(100), Err(v.len()));\n}\n\n#[test]\nfn test_find_map() {\n    let xs: &[isize] = &[];\n    assert_eq!(xs.iter().find_map(half_if_even), None);\n    let xs: &[isize] = &[3, 5];\n    assert_eq!(xs.iter().find_map(half_if_even), None);\n    let xs: &[isize] = &[4, 5];\n    assert_eq!(xs.iter().find_map(half_if_even), Some(2));\n    let xs: &[isize] = &[3, 6];\n    assert_eq!(xs.iter().find_map(half_if_even), Some(3));\n\n    let xs: &[isize] = &[1, 2, 3, 4, 5, 6, 7];\n    let mut iter = xs.iter();\n    assert_eq!(iter.find_map(half_if_even), Some(1));\n    assert_eq!(iter.find_map(half_if_even), Some(2));\n    assert_eq!(iter.find_map(half_if_even), Some(3));\n    assert_eq!(iter.next(), Some(&7));\n\n    fn half_if_even(x: &isize) -> Option<isize> {\n        if x % 2 == 0 { Some(x / 2) } else { None }\n    }\n}\n\n#[test]\nfn test_iterator_len() {\n    let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..4].iter().count(), 4);\n    assert_eq!(v[..10].iter().count(), 10);\n    assert_eq!(v[..0].iter().count(), 0);\n}\n\n#[test]\nfn test_collect() {\n    let a = vec![1, 2, 3, 4, 5];\n    let b: Vec<isize> = a.iter().cloned().collect();\n    assert!(a == b);\n}\n"],[2964,"use core::iter::*;\n\n#[test]\nfn test_iterator_sum() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..4].iter().cloned().sum::<i32>(), 6);\n    assert_eq!(v.iter().cloned().sum::<i32>(), 55);\n    assert_eq!(v[..0].iter().cloned().sum::<i32>(), 0);\n}\n\n#[test]\nfn test_iterator_sum_result() {\n    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n    assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Ok(10));\n    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n    assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n\n    #[derive(PartialEq, Debug)]\n    struct S(Result<i32, ()>);\n\n    impl Sum<Result<i32, ()>> for S {\n        fn sum<I: Iterator<Item = Result<i32, ()>>>(mut iter: I) -> Self {\n            // takes the sum by repeatedly calling `next` on `iter`,\n            // thus testing that repeated calls to `ResultShunt::try_fold`\n            // produce the expected results\n            Self(iter.by_ref().sum())\n        }\n    }\n\n    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n    assert_eq!(v.iter().cloned().sum::<S>(), S(Ok(10)));\n    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n    assert_eq!(v.iter().cloned().sum::<S>(), S(Err(())));\n}\n\n#[test]\nfn test_iterator_sum_option() {\n    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), Some(10));\n    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), None);\n}\n\n#[test]\nfn test_iterator_product() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(v[..4].iter().cloned().product::<i32>(), 0);\n    assert_eq!(v[1..5].iter().cloned().product::<i32>(), 24);\n    assert_eq!(v[..0].iter().cloned().product::<i32>(), 1);\n}\n\n#[test]\nfn test_iterator_product_result() {\n    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n    assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Ok(24));\n    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n    assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Err(()));\n}\n\n#[test]\nfn test_iterator_product_option() {\n    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n    assert_eq!(v.iter().cloned().product::<Option<i32>>(), Some(24));\n    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n    assert_eq!(v.iter().cloned().product::<Option<i32>>(), None);\n}\n"],[2965,"use core::iter::*;\n\n#[test]\nfn test_steps_between() {\n    assert_eq!(Step::steps_between(&20_u8, &200_u8), Some(180_usize));\n    assert_eq!(Step::steps_between(&-20_i8, &80_i8), Some(100_usize));\n    assert_eq!(Step::steps_between(&-120_i8, &80_i8), Some(200_usize));\n    assert_eq!(Step::steps_between(&20_u32, &4_000_100_u32), Some(4_000_080_usize));\n    assert_eq!(Step::steps_between(&-20_i32, &80_i32), Some(100_usize));\n    assert_eq!(Step::steps_between(&-2_000_030_i32, &2_000_050_i32), Some(4_000_080_usize));\n\n    // Skip u64/i64 to avoid differences with 32-bit vs 64-bit platforms\n\n    assert_eq!(Step::steps_between(&20_u128, &200_u128), Some(180_usize));\n    assert_eq!(Step::steps_between(&-20_i128, &80_i128), Some(100_usize));\n    if cfg!(target_pointer_width = \"64\") {\n        assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_0009_u128), Some(usize::MAX));\n    }\n    assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_000a_u128), None);\n    assert_eq!(Step::steps_between(&10_i128, &0x1_0000_0000_0000_000a_i128), None);\n    assert_eq!(\n        Step::steps_between(&-0x1_0000_0000_0000_0000_i128, &0x1_0000_0000_0000_0000_i128,),\n        None,\n    );\n}\n\n#[test]\nfn test_step_forward() {\n    assert_eq!(Step::forward_checked(55_u8, 200_usize), Some(255_u8));\n    assert_eq!(Step::forward_checked(252_u8, 200_usize), None);\n    assert_eq!(Step::forward_checked(0_u8, 256_usize), None);\n    assert_eq!(Step::forward_checked(-110_i8, 200_usize), Some(90_i8));\n    assert_eq!(Step::forward_checked(-110_i8, 248_usize), None);\n    assert_eq!(Step::forward_checked(-126_i8, 256_usize), None);\n\n    assert_eq!(Step::forward_checked(35_u16, 100_usize), Some(135_u16));\n    assert_eq!(Step::forward_checked(35_u16, 65500_usize), Some(u16::MAX));\n    assert_eq!(Step::forward_checked(36_u16, 65500_usize), None);\n    assert_eq!(Step::forward_checked(-110_i16, 200_usize), Some(90_i16));\n    assert_eq!(Step::forward_checked(-20_030_i16, 50_050_usize), Some(30_020_i16));\n    assert_eq!(Step::forward_checked(-10_i16, 40_000_usize), None);\n    assert_eq!(Step::forward_checked(-10_i16, 70_000_usize), None);\n\n    assert_eq!(Step::forward_checked(10_u128, 70_000_usize), Some(70_010_u128));\n    assert_eq!(Step::forward_checked(10_i128, 70_030_usize), Some(70_040_i128));\n    assert_eq!(\n        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0xff_usize),\n        Some(u128::MAX),\n    );\n    assert_eq!(\n        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0x100_usize),\n        None\n    );\n    assert_eq!(\n        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0xff_usize),\n        Some(i128::MAX),\n    );\n    assert_eq!(\n        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n        None\n    );\n}\n\n#[test]\nfn test_step_backward() {\n    assert_eq!(Step::backward_checked(255_u8, 200_usize), Some(55_u8));\n    assert_eq!(Step::backward_checked(100_u8, 200_usize), None);\n    assert_eq!(Step::backward_checked(255_u8, 256_usize), None);\n    assert_eq!(Step::backward_checked(90_i8, 200_usize), Some(-110_i8));\n    assert_eq!(Step::backward_checked(110_i8, 248_usize), None);\n    assert_eq!(Step::backward_checked(127_i8, 256_usize), None);\n\n    assert_eq!(Step::backward_checked(135_u16, 100_usize), Some(35_u16));\n    assert_eq!(Step::backward_checked(u16::MAX, 65500_usize), Some(35_u16));\n    assert_eq!(Step::backward_checked(10_u16, 11_usize), None);\n    assert_eq!(Step::backward_checked(90_i16, 200_usize), Some(-110_i16));\n    assert_eq!(Step::backward_checked(30_020_i16, 50_050_usize), Some(-20_030_i16));\n    assert_eq!(Step::backward_checked(-10_i16, 40_000_usize), None);\n    assert_eq!(Step::backward_checked(-10_i16, 70_000_usize), None);\n\n    assert_eq!(Step::backward_checked(70_010_u128, 70_000_usize), Some(10_u128));\n    assert_eq!(Step::backward_checked(70_020_i128, 70_030_usize), Some(-10_i128));\n    assert_eq!(Step::backward_checked(10_u128, 7_usize), Some(3_u128));\n    assert_eq!(Step::backward_checked(10_u128, 11_usize), None);\n    assert_eq!(\n        Step::backward_checked(-0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n        Some(i128::MIN)\n    );\n}\n"],[2966,"//! Note\n//! ----\n//! You're probably viewing this file because you're adding a test (or you might\n//! just be browsing, in that case, hey there!).\n//!\n//! If you've made a test that happens to use one of DoubleEnded's methods, but\n//! it tests another adapter or trait, you should *add it to the adapter or\n//! trait's test file*.\n//!\n//! Some examples would be `adapters::cloned::test_cloned_try_folds` or\n//! `adapters::flat_map::test_double_ended_flat_map`, which use `try_fold` and\n//! `next_back`, but test their own adapter.\n\n#[test]\nfn test_iterator_rev_nth_back() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n    for i in 0..v.len() {\n        assert_eq!(v.iter().rev().nth_back(i).unwrap(), &v[i]);\n    }\n    assert_eq!(v.iter().rev().nth_back(v.len()), None);\n}\n\n#[test]\nfn test_iterator_rev_nth() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n    for i in 0..v.len() {\n        assert_eq!(v.iter().rev().nth(i).unwrap(), &v[v.len() - 1 - i]);\n    }\n    assert_eq!(v.iter().rev().nth(v.len()), None);\n}\n\n#[test]\nfn test_rev() {\n    let xs = [2, 4, 6, 8, 10, 12, 14, 16];\n    let mut it = xs.iter();\n    it.next();\n    it.next();\n    assert!(it.rev().cloned().collect::<Vec<isize>>() == vec![16, 14, 12, 10, 8, 6]);\n}\n\n#[test]\nfn test_rev_try_folds() {\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    assert_eq!((1..10).rev().try_fold(7, f), (1..10).try_rfold(7, f));\n    assert_eq!((1..10).rev().try_rfold(7, f), (1..10).try_fold(7, f));\n\n    let a = [10, 20, 30, 40, 100, 60, 70, 80, 90];\n    let mut iter = a.iter().rev();\n    assert_eq!(iter.try_fold(0_i8, |acc, &x| acc.checked_add(x)), None);\n    assert_eq!(iter.next(), Some(&70));\n    let mut iter = a.iter().rev();\n    assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n    assert_eq!(iter.next_back(), Some(&60));\n}\n\n#[test]\nfn test_rposition() {\n    fn f(xy: &(isize, char)) -> bool {\n        let (_x, y) = *xy;\n        y == 'b'\n    }\n    fn g(xy: &(isize, char)) -> bool {\n        let (_x, y) = *xy;\n        y == 'd'\n    }\n    let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n\n    assert_eq!(v.iter().rposition(f), Some(3));\n    assert!(v.iter().rposition(g).is_none());\n}\n\n#[test]\nfn test_rev_rposition() {\n    let v = [0, 0, 1, 1];\n    assert_eq!(v.iter().rev().rposition(|&x| x == 1), Some(1));\n}\n\n#[test]\n#[should_panic]\nfn test_rposition_panic() {\n    let v: [(Box<_>, Box<_>); 4] = [(box 0, box 0), (box 0, box 0), (box 0, box 0), (box 0, box 0)];\n    let mut i = 0;\n    v.iter().rposition(|_elt| {\n        if i == 2 {\n            panic!()\n        }\n        i += 1;\n        false\n    });\n}\n"],[2967,"use core::iter::*;\n\n#[test]\nfn test_iterator_flat_map() {\n    let xs = [0, 3, 6];\n    let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let it = xs.iter().flat_map(|&x| (x..).step_by(1).take(3));\n    let mut i = 0;\n    for x in it {\n        assert_eq!(x, ys[i]);\n        i += 1;\n    }\n    assert_eq!(i, ys.len());\n}\n\n/// Tests `FlatMap::fold` with items already picked off the front and back,\n/// to make sure all parts of the `FlatMap` are folded correctly.\n#[test]\nfn test_iterator_flat_map_fold() {\n    let xs = [0, 3, 6];\n    let ys = [1, 2, 3, 4, 5, 6, 7];\n    let mut it = xs.iter().flat_map(|&x| x..x + 3);\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.next_back(), Some(8));\n    let i = it.fold(0, |i, x| {\n        assert_eq!(x, ys[i]);\n        i + 1\n    });\n    assert_eq!(i, ys.len());\n\n    let mut it = xs.iter().flat_map(|&x| x..x + 3);\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.next_back(), Some(8));\n    let i = it.rfold(ys.len(), |i, x| {\n        assert_eq!(x, ys[i - 1]);\n        i - 1\n    });\n    assert_eq!(i, 0);\n}\n\n#[test]\nfn test_flat_map_try_folds() {\n    let f = &|acc, x| i32::checked_add(acc * 2 / 3, x);\n    let mr = &|x| (5 * x)..(5 * x + 5);\n    assert_eq!((0..10).flat_map(mr).try_fold(7, f), (0..50).try_fold(7, f));\n    assert_eq!((0..10).flat_map(mr).try_rfold(7, f), (0..50).try_rfold(7, f));\n    let mut iter = (0..10).flat_map(mr);\n    iter.next();\n    iter.next_back(); // have front and back iters in progress\n    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n\n    let mut iter = (0..10).flat_map(|x| (4 * x)..(4 * x + 4));\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.next(), Some(17));\n    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n    assert_eq!(iter.next_back(), Some(35));\n}\n\n#[test]\nfn test_double_ended_flat_map() {\n    let u = [0, 1];\n    let v = [5, 6, 7, 8];\n    let mut it = u.iter().flat_map(|x| &v[*x..v.len()]);\n    assert_eq!(it.next_back().unwrap(), &8);\n    assert_eq!(it.next().unwrap(), &5);\n    assert_eq!(it.next_back().unwrap(), &7);\n    assert_eq!(it.next_back().unwrap(), &6);\n    assert_eq!(it.next_back().unwrap(), &8);\n    assert_eq!(it.next().unwrap(), &6);\n    assert_eq!(it.next_back().unwrap(), &7);\n    assert_eq!(it.next_back(), None);\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next_back(), None);\n}\n"],[2968,"use core::iter::*;\n\n#[test]\nfn test_iterator_filter_count() {\n    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    assert_eq!(xs.iter().filter(|&&x| x % 2 == 0).count(), 5);\n}\n\n#[test]\nfn test_iterator_filter_fold() {\n    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let ys = [0, 2, 4, 6, 8];\n    let it = xs.iter().filter(|&&x| x % 2 == 0);\n    let i = it.fold(0, |i, &x| {\n        assert_eq!(x, ys[i]);\n        i + 1\n    });\n    assert_eq!(i, ys.len());\n\n    let it = xs.iter().filter(|&&x| x % 2 == 0);\n    let i = it.rfold(ys.len(), |i, &x| {\n        assert_eq!(x, ys[i - 1]);\n        i - 1\n    });\n    assert_eq!(i, 0);\n}\n\n#[test]\nfn test_filter_try_folds() {\n    fn p(&x: &i32) -> bool {\n        0 <= x && x < 10\n    }\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    assert_eq!((-10..20).filter(p).try_fold(7, f), (0..10).try_fold(7, f));\n    assert_eq!((-10..20).filter(p).try_rfold(7, f), (0..10).try_rfold(7, f));\n\n    let mut iter = (0..40).filter(|&x| x % 2 == 1);\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.next(), Some(25));\n    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n    assert_eq!(iter.next_back(), Some(31));\n}\n\n#[test]\nfn test_double_ended_filter() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut it = xs.iter().filter(|&x| *x & 1 == 0);\n    assert_eq!(it.next_back().unwrap(), &6);\n    assert_eq!(it.next_back().unwrap(), &4);\n    assert_eq!(it.next().unwrap(), &2);\n    assert_eq!(it.next_back(), None);\n}\n"],[2969,"use core::iter::*;\n\n#[test]\nfn test_cloned() {\n    let xs = [2, 4, 6, 8];\n\n    let mut it = xs.iter().cloned();\n    assert_eq!(it.len(), 4);\n    assert_eq!(it.next(), Some(2));\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.next(), Some(4));\n    assert_eq!(it.len(), 2);\n    assert_eq!(it.next_back(), Some(8));\n    assert_eq!(it.len(), 1);\n    assert_eq!(it.next_back(), Some(6));\n    assert_eq!(it.len(), 0);\n    assert_eq!(it.next_back(), None);\n}\n\n#[test]\nfn test_cloned_side_effects() {\n    let mut count = 0;\n    {\n        let iter = [1, 2, 3]\n            .iter()\n            .map(|x| {\n                count += 1;\n                x\n            })\n            .cloned()\n            .zip(&[1]);\n        for _ in iter {}\n    }\n    assert_eq!(count, 2);\n}\n\n#[test]\nfn test_cloned_try_folds() {\n    let a = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    let f_ref = &|acc, &x| i32::checked_add(2 * acc, x);\n    assert_eq!(a.iter().cloned().try_fold(7, f), a.iter().try_fold(7, f_ref));\n    assert_eq!(a.iter().cloned().try_rfold(7, f), a.iter().try_rfold(7, f_ref));\n\n    let a = [10, 20, 30, 40, 100, 60, 70, 80, 90];\n    let mut iter = a.iter().cloned();\n    assert_eq!(iter.try_fold(0_i8, |acc, x| acc.checked_add(x)), None);\n    assert_eq!(iter.next(), Some(60));\n    let mut iter = a.iter().cloned();\n    assert_eq!(iter.try_rfold(0_i8, |acc, x| acc.checked_add(x)), None);\n    assert_eq!(iter.next_back(), Some(70));\n}\n"],[2970,"use core::iter::*;\n\n#[test]\nfn test_filter_map() {\n    let it = (0..).step_by(1).take(10).filter_map(|x| if x % 2 == 0 { Some(x * x) } else { None });\n    assert_eq!(it.collect::<Vec<usize>>(), [0 * 0, 2 * 2, 4 * 4, 6 * 6, 8 * 8]);\n}\n\n#[test]\nfn test_filter_map_fold() {\n    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let ys = [0 * 0, 2 * 2, 4 * 4, 6 * 6, 8 * 8];\n    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x * x) } else { None });\n    let i = it.fold(0, |i, x| {\n        assert_eq!(x, ys[i]);\n        i + 1\n    });\n    assert_eq!(i, ys.len());\n\n    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x * x) } else { None });\n    let i = it.rfold(ys.len(), |i, x| {\n        assert_eq!(x, ys[i - 1]);\n        i - 1\n    });\n    assert_eq!(i, 0);\n}\n\n#[test]\nfn test_filter_map_try_folds() {\n    let mp = &|x| if 0 <= x && x < 10 { Some(x * 2) } else { None };\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    assert_eq!((-9..20).filter_map(mp).try_fold(7, f), (0..10).map(|x| 2 * x).try_fold(7, f));\n    assert_eq!((-9..20).filter_map(mp).try_rfold(7, f), (0..10).map(|x| 2 * x).try_rfold(7, f));\n\n    let mut iter = (0..40).filter_map(|x| if x % 2 == 1 { None } else { Some(x * 2 + 10) });\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.next(), Some(38));\n    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n    assert_eq!(iter.next_back(), Some(78));\n}\n\n#[test]\nfn test_double_ended_filter_map() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut it = xs.iter().filter_map(|&x| if x & 1 == 0 { Some(x * 2) } else { None });\n    assert_eq!(it.next_back().unwrap(), 12);\n    assert_eq!(it.next_back().unwrap(), 8);\n    assert_eq!(it.next().unwrap(), 4);\n    assert_eq!(it.next_back(), None);\n}\n"],[2971,"use core::iter::*;\n\n#[test]\nfn test_iterator_skip() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n    let ys = [13, 15, 16, 17, 19, 20, 30];\n    let mut it = xs.iter().skip(5);\n    let mut i = 0;\n    while let Some(&x) = it.next() {\n        assert_eq!(x, ys[i]);\n        i += 1;\n        assert_eq!(it.len(), xs.len() - 5 - i);\n    }\n    assert_eq!(i, ys.len());\n    assert_eq!(it.len(), 0);\n}\n\n#[test]\nfn test_iterator_skip_doubleended() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n    let mut it = xs.iter().rev().skip(5);\n    assert_eq!(it.next(), Some(&15));\n    assert_eq!(it.by_ref().rev().next(), Some(&0));\n    assert_eq!(it.next(), Some(&13));\n    assert_eq!(it.by_ref().rev().next(), Some(&1));\n    assert_eq!(it.next(), Some(&5));\n    assert_eq!(it.by_ref().rev().next(), Some(&2));\n    assert_eq!(it.next(), Some(&3));\n    assert_eq!(it.next(), None);\n    let mut it = xs.iter().rev().skip(5).rev();\n    assert_eq!(it.next(), Some(&0));\n    assert_eq!(it.rev().next(), Some(&15));\n    let mut it_base = xs.iter();\n    {\n        let mut it = it_base.by_ref().skip(5).rev();\n        assert_eq!(it.next(), Some(&30));\n        assert_eq!(it.next(), Some(&20));\n        assert_eq!(it.next(), Some(&19));\n        assert_eq!(it.next(), Some(&17));\n        assert_eq!(it.next(), Some(&16));\n        assert_eq!(it.next(), Some(&15));\n        assert_eq!(it.next(), Some(&13));\n        assert_eq!(it.next(), None);\n    }\n    // make sure the skipped parts have not been consumed\n    assert_eq!(it_base.next(), Some(&0));\n    assert_eq!(it_base.next(), Some(&1));\n    assert_eq!(it_base.next(), Some(&2));\n    assert_eq!(it_base.next(), Some(&3));\n    assert_eq!(it_base.next(), Some(&5));\n    assert_eq!(it_base.next(), None);\n    let it = xs.iter().skip(5).rev();\n    assert_eq!(it.last(), Some(&13));\n}\n\n#[test]\nfn test_iterator_skip_nth() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n\n    let mut it = xs.iter().skip(0);\n    assert_eq!(it.nth(0), Some(&0));\n    assert_eq!(it.nth(1), Some(&2));\n\n    let mut it = xs.iter().skip(5);\n    assert_eq!(it.nth(0), Some(&13));\n    assert_eq!(it.nth(1), Some(&16));\n\n    let mut it = xs.iter().skip(12);\n    assert_eq!(it.nth(0), None);\n}\n\n#[test]\nfn test_iterator_skip_count() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n\n    assert_eq!(xs.iter().skip(0).count(), 12);\n    assert_eq!(xs.iter().skip(1).count(), 11);\n    assert_eq!(xs.iter().skip(11).count(), 1);\n    assert_eq!(xs.iter().skip(12).count(), 0);\n    assert_eq!(xs.iter().skip(13).count(), 0);\n}\n\n#[test]\nfn test_iterator_skip_last() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n\n    assert_eq!(xs.iter().skip(0).last(), Some(&30));\n    assert_eq!(xs.iter().skip(1).last(), Some(&30));\n    assert_eq!(xs.iter().skip(11).last(), Some(&30));\n    assert_eq!(xs.iter().skip(12).last(), None);\n    assert_eq!(xs.iter().skip(13).last(), None);\n\n    let mut it = xs.iter().skip(5);\n    assert_eq!(it.next(), Some(&13));\n    assert_eq!(it.last(), Some(&30));\n}\n\n#[test]\nfn test_iterator_skip_fold() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n    let ys = [13, 15, 16, 17, 19, 20, 30];\n\n    let it = xs.iter().skip(5);\n    let i = it.fold(0, |i, &x| {\n        assert_eq!(x, ys[i]);\n        i + 1\n    });\n    assert_eq!(i, ys.len());\n\n    let mut it = xs.iter().skip(5);\n    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n    let i = it.fold(1, |i, &x| {\n        assert_eq!(x, ys[i]);\n        i + 1\n    });\n    assert_eq!(i, ys.len());\n\n    let it = xs.iter().skip(5);\n    let i = it.rfold(ys.len(), |i, &x| {\n        let i = i - 1;\n        assert_eq!(x, ys[i]);\n        i\n    });\n    assert_eq!(i, 0);\n\n    let mut it = xs.iter().skip(5);\n    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n    let i = it.rfold(ys.len(), |i, &x| {\n        let i = i - 1;\n        assert_eq!(x, ys[i]);\n        i\n    });\n    assert_eq!(i, 1);\n}\n\n#[test]\nfn test_skip_try_folds() {\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    assert_eq!((1..20).skip(9).try_fold(7, f), (10..20).try_fold(7, f));\n    assert_eq!((1..20).skip(9).try_rfold(7, f), (10..20).try_rfold(7, f));\n\n    let mut iter = (0..30).skip(10);\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.next(), Some(20));\n    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n    assert_eq!(iter.next_back(), Some(24));\n}\n\n#[test]\nfn test_skip_nth_back() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let mut it = xs.iter().skip(2);\n    assert_eq!(it.nth_back(0), Some(&5));\n    assert_eq!(it.nth_back(1), Some(&3));\n    assert_eq!(it.nth_back(0), Some(&2));\n    assert_eq!(it.nth_back(0), None);\n\n    let ys = [2, 3, 4, 5];\n    let mut ity = ys.iter();\n    let mut it = xs.iter().skip(2);\n    assert_eq!(it.nth_back(1), ity.nth_back(1));\n    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n    assert_eq!(it.nth_back(0), ity.nth_back(0));\n    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n    assert_eq!(it.nth_back(0), ity.nth_back(0));\n    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n    assert_eq!(it.nth_back(0), ity.nth_back(0));\n    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n\n    let mut it = xs.iter().skip(2);\n    assert_eq!(it.nth_back(4), None);\n    assert_eq!(it.nth_back(0), None);\n\n    let mut it = xs.iter();\n    it.by_ref().skip(2).nth_back(3);\n    assert_eq!(it.next_back(), Some(&1));\n\n    let mut it = xs.iter();\n    it.by_ref().skip(2).nth_back(10);\n    assert_eq!(it.next_back(), Some(&1));\n}\n"],[2972,"use super::*;\nuse core::iter::*;\n\n#[test]\nfn test_zip_nth() {\n    let xs = [0, 1, 2, 4, 5];\n    let ys = [10, 11, 12];\n\n    let mut it = xs.iter().zip(&ys);\n    assert_eq!(it.nth(0), Some((&0, &10)));\n    assert_eq!(it.nth(1), Some((&2, &12)));\n    assert_eq!(it.nth(0), None);\n\n    let mut it = xs.iter().zip(&ys);\n    assert_eq!(it.nth(3), None);\n\n    let mut it = ys.iter().zip(&xs);\n    assert_eq!(it.nth(3), None);\n}\n\n#[test]\nfn test_zip_nth_side_effects() {\n    let mut a = Vec::new();\n    let mut b = Vec::new();\n    let value = [1, 2, 3, 4, 5, 6]\n        .iter()\n        .cloned()\n        .map(|n| {\n            a.push(n);\n            n * 10\n        })\n        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n            b.push(n * 100);\n            n * 1000\n        }))\n        .skip(1)\n        .nth(3);\n    assert_eq!(value, Some((50, 6000)));\n    assert_eq!(a, vec![1, 2, 3, 4, 5]);\n    assert_eq!(b, vec![200, 300, 400, 500, 600]);\n}\n\n#[test]\nfn test_zip_next_back_side_effects() {\n    let mut a = Vec::new();\n    let mut b = Vec::new();\n    let mut iter = [1, 2, 3, 4, 5, 6]\n        .iter()\n        .cloned()\n        .map(|n| {\n            a.push(n);\n            n * 10\n        })\n        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n            b.push(n * 100);\n            n * 1000\n        }));\n\n    // The second iterator is one item longer, so `next_back` is called on it\n    // one more time.\n    assert_eq!(iter.next_back(), Some((60, 7000)));\n    assert_eq!(iter.next_back(), Some((50, 6000)));\n    assert_eq!(iter.next_back(), Some((40, 5000)));\n    assert_eq!(iter.next_back(), Some((30, 4000)));\n    assert_eq!(a, vec![6, 5, 4, 3]);\n    assert_eq!(b, vec![800, 700, 600, 500, 400]);\n}\n\n#[test]\nfn test_zip_nth_back_side_effects() {\n    let mut a = Vec::new();\n    let mut b = Vec::new();\n    let value = [1, 2, 3, 4, 5, 6]\n        .iter()\n        .cloned()\n        .map(|n| {\n            a.push(n);\n            n * 10\n        })\n        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n            b.push(n * 100);\n            n * 1000\n        }))\n        .nth_back(3);\n    assert_eq!(value, Some((30, 4000)));\n    assert_eq!(a, vec![6, 5, 4, 3]);\n    assert_eq!(b, vec![800, 700, 600, 500, 400]);\n}\n\n#[test]\nfn test_zip_next_back_side_effects_exhausted() {\n    let mut a = Vec::new();\n    let mut b = Vec::new();\n    let mut iter = [1, 2, 3, 4, 5, 6]\n        .iter()\n        .cloned()\n        .map(|n| {\n            a.push(n);\n            n * 10\n        })\n        .zip([2, 3, 4].iter().cloned().map(|n| {\n            b.push(n * 100);\n            n * 1000\n        }));\n\n    iter.next();\n    iter.next();\n    iter.next();\n    iter.next();\n    assert_eq!(iter.next_back(), None);\n    assert_eq!(a, vec![1, 2, 3, 4, 6, 5]);\n    assert_eq!(b, vec![200, 300, 400]);\n}\n\n#[test]\nfn test_zip_cloned_sideffectful() {\n    let xs = [CountClone::new(), CountClone::new(), CountClone::new(), CountClone::new()];\n    let ys = [CountClone::new(), CountClone::new()];\n\n    for _ in xs.iter().cloned().zip(ys.iter().cloned()) {}\n\n    assert_eq!(&xs, &[1, 1, 1, 0][..]);\n    assert_eq!(&ys, &[1, 1][..]);\n\n    let xs = [CountClone::new(), CountClone::new()];\n    let ys = [CountClone::new(), CountClone::new(), CountClone::new(), CountClone::new()];\n\n    for _ in xs.iter().cloned().zip(ys.iter().cloned()) {}\n\n    assert_eq!(&xs, &[1, 1][..]);\n    assert_eq!(&ys, &[1, 1, 0, 0][..]);\n}\n\n#[test]\nfn test_zip_map_sideffectful() {\n    let mut xs = [0; 6];\n    let mut ys = [0; 4];\n\n    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) {}\n\n    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n    assert_eq!(&ys, &[1, 1, 1, 1]);\n\n    let mut xs = [0; 4];\n    let mut ys = [0; 6];\n\n    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) {}\n\n    assert_eq!(&xs, &[1, 1, 1, 1]);\n    assert_eq!(&ys, &[1, 1, 1, 1, 0, 0]);\n}\n\n#[test]\nfn test_zip_map_rev_sideffectful() {\n    let mut xs = [0; 6];\n    let mut ys = [0; 4];\n\n    {\n        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n        it.next_back();\n    }\n    assert_eq!(&xs, &[0, 0, 0, 1, 1, 1]);\n    assert_eq!(&ys, &[0, 0, 0, 1]);\n\n    let mut xs = [0; 6];\n    let mut ys = [0; 4];\n\n    {\n        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n        (&mut it).take(5).count();\n        it.next_back();\n    }\n    assert_eq!(&xs, &[1, 1, 1, 1, 1, 1]);\n    assert_eq!(&ys, &[1, 1, 1, 1]);\n}\n\n#[test]\nfn test_zip_nested_sideffectful() {\n    let mut xs = [0; 6];\n    let ys = [0; 4];\n\n    {\n        // test that it has the side effect nested inside enumerate\n        let it = xs.iter_mut().map(|x| *x = 1).enumerate().zip(&ys);\n        it.count();\n    }\n    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n}\n\n#[test]\nfn test_zip_nth_back_side_effects_exhausted() {\n    let mut a = Vec::new();\n    let mut b = Vec::new();\n    let mut iter = [1, 2, 3, 4, 5, 6]\n        .iter()\n        .cloned()\n        .map(|n| {\n            a.push(n);\n            n * 10\n        })\n        .zip([2, 3, 4].iter().cloned().map(|n| {\n            b.push(n * 100);\n            n * 1000\n        }));\n\n    iter.next();\n    iter.next();\n    iter.next();\n    iter.next();\n    assert_eq!(iter.nth_back(0), None);\n    assert_eq!(a, vec![1, 2, 3, 4, 6, 5]);\n    assert_eq!(b, vec![200, 300, 400]);\n}\n\n#[test]\nfn test_zip_trusted_random_access_composition() {\n    let a = [0, 1, 2, 3, 4];\n    let b = a;\n    let c = a;\n\n    let a = a.iter().copied();\n    let b = b.iter().copied();\n    let mut c = c.iter().copied();\n    c.next();\n\n    let mut z1 = a.zip(b);\n    assert_eq!(z1.next().unwrap(), (0, 0));\n\n    let mut z2 = z1.zip(c);\n    fn assert_trusted_random_access<T: TrustedRandomAccess>(_a: &T) {}\n    assert_trusted_random_access(&z2);\n    assert_eq!(z2.next().unwrap(), ((1, 1), 1));\n}\n\n#[test]\n#[cfg(panic = \"unwind\")]\nfn test_zip_trusted_random_access_next_back_drop() {\n    use std::panic::catch_unwind;\n    use std::panic::AssertUnwindSafe;\n\n    let mut counter = 0;\n\n    let it = [42].iter().map(|e| {\n        let c = counter;\n        counter += 1;\n        if c == 0 {\n            panic!(\"bomb\");\n        }\n\n        e\n    });\n    let it2 = [(); 0].iter();\n    let mut zip = it.zip(it2);\n    catch_unwind(AssertUnwindSafe(|| {\n        zip.next_back();\n    }))\n    .unwrap_err();\n    assert!(zip.next().is_none());\n    assert_eq!(counter, 1);\n}\n\n#[test]\nfn test_double_ended_zip() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let ys = [1, 2, 3, 7];\n    let mut it = xs.iter().cloned().zip(ys);\n    assert_eq!(it.next(), Some((1, 1)));\n    assert_eq!(it.next(), Some((2, 2)));\n    assert_eq!(it.next_back(), Some((4, 7)));\n    assert_eq!(it.next_back(), Some((3, 3)));\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn test_issue_82282() {\n    fn overflowed_zip(arr: &[i32]) -> impl Iterator<Item = (i32, &())> {\n        static UNIT_EMPTY_ARR: [(); 0] = [];\n\n        let mapped = arr.into_iter().map(|i| *i);\n        let mut zipped = mapped.zip(UNIT_EMPTY_ARR.iter());\n        zipped.next();\n        zipped\n    }\n\n    let arr = [1, 2, 3];\n    let zip = overflowed_zip(&arr).zip(overflowed_zip(&arr));\n\n    assert_eq!(zip.size_hint(), (0, Some(0)));\n    for _ in zip {\n        panic!();\n    }\n}\n\n#[test]\nfn test_issue_82291() {\n    use std::cell::Cell;\n\n    let mut v1 = [()];\n    let v2 = [()];\n\n    let called = Cell::new(0);\n\n    let mut zip = v1\n        .iter_mut()\n        .map(|r| {\n            called.set(called.get() + 1);\n            r\n        })\n        .zip(&v2);\n\n    zip.next_back();\n    assert_eq!(called.get(), 1);\n    zip.next();\n    assert_eq!(called.get(), 1);\n}\n"],[2973,"use super::*;\nuse core::iter::*;\n\n#[test]\nfn test_iterator_peekable() {\n    let xs = vec![0, 1, 2, 3, 4, 5];\n\n    let mut it = xs.iter().cloned().peekable();\n    assert_eq!(it.len(), 6);\n    assert_eq!(it.peek().unwrap(), &0);\n    assert_eq!(it.len(), 6);\n    assert_eq!(it.next().unwrap(), 0);\n    assert_eq!(it.len(), 5);\n    assert_eq!(it.next().unwrap(), 1);\n    assert_eq!(it.len(), 4);\n    assert_eq!(it.next().unwrap(), 2);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.peek().unwrap(), &3);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.peek().unwrap(), &3);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.next().unwrap(), 3);\n    assert_eq!(it.len(), 2);\n    assert_eq!(it.next().unwrap(), 4);\n    assert_eq!(it.len(), 1);\n    assert_eq!(it.peek().unwrap(), &5);\n    assert_eq!(it.len(), 1);\n    assert_eq!(it.next().unwrap(), 5);\n    assert_eq!(it.len(), 0);\n    assert!(it.peek().is_none());\n    assert_eq!(it.len(), 0);\n    assert!(it.next().is_none());\n    assert_eq!(it.len(), 0);\n\n    let mut it = xs.iter().cloned().peekable();\n    assert_eq!(it.len(), 6);\n    assert_eq!(it.peek().unwrap(), &0);\n    assert_eq!(it.len(), 6);\n    assert_eq!(it.next_back().unwrap(), 5);\n    assert_eq!(it.len(), 5);\n    assert_eq!(it.next_back().unwrap(), 4);\n    assert_eq!(it.len(), 4);\n    assert_eq!(it.next_back().unwrap(), 3);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.peek().unwrap(), &0);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.peek().unwrap(), &0);\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.next_back().unwrap(), 2);\n    assert_eq!(it.len(), 2);\n    assert_eq!(it.next_back().unwrap(), 1);\n    assert_eq!(it.len(), 1);\n    assert_eq!(it.peek().unwrap(), &0);\n    assert_eq!(it.len(), 1);\n    assert_eq!(it.next_back().unwrap(), 0);\n    assert_eq!(it.len(), 0);\n    assert!(it.peek().is_none());\n    assert_eq!(it.len(), 0);\n    assert!(it.next_back().is_none());\n    assert_eq!(it.len(), 0);\n}\n\n#[test]\nfn test_iterator_peekable_count() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let ys = [10];\n    let zs: [i32; 0] = [];\n\n    assert_eq!(xs.iter().peekable().count(), 6);\n\n    let mut it = xs.iter().peekable();\n    assert_eq!(it.peek(), Some(&&0));\n    assert_eq!(it.count(), 6);\n\n    assert_eq!(ys.iter().peekable().count(), 1);\n\n    let mut it = ys.iter().peekable();\n    assert_eq!(it.peek(), Some(&&10));\n    assert_eq!(it.count(), 1);\n\n    assert_eq!(zs.iter().peekable().count(), 0);\n\n    let mut it = zs.iter().peekable();\n    assert_eq!(it.peek(), None);\n}\n\n#[test]\nfn test_iterator_peekable_nth() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let mut it = xs.iter().peekable();\n\n    assert_eq!(it.peek(), Some(&&0));\n    assert_eq!(it.nth(0), Some(&0));\n    assert_eq!(it.peek(), Some(&&1));\n    assert_eq!(it.nth(1), Some(&2));\n    assert_eq!(it.peek(), Some(&&3));\n    assert_eq!(it.nth(2), Some(&5));\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn test_iterator_peekable_last() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let ys = [0];\n\n    let mut it = xs.iter().peekable();\n    assert_eq!(it.peek(), Some(&&0));\n    assert_eq!(it.last(), Some(&5));\n\n    let mut it = ys.iter().peekable();\n    assert_eq!(it.peek(), Some(&&0));\n    assert_eq!(it.last(), Some(&0));\n\n    let mut it = ys.iter().peekable();\n    assert_eq!(it.next(), Some(&0));\n    assert_eq!(it.peek(), None);\n    assert_eq!(it.last(), None);\n}\n\n#[test]\nfn test_iterator_peekable_fold() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let mut it = xs.iter().peekable();\n    assert_eq!(it.peek(), Some(&&0));\n    let i = it.fold(0, |i, &x| {\n        assert_eq!(x, xs[i]);\n        i + 1\n    });\n    assert_eq!(i, xs.len());\n}\n\n#[test]\nfn test_iterator_peekable_rfold() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let mut it = xs.iter().peekable();\n    assert_eq!(it.peek(), Some(&&0));\n    let i = it.rfold(0, |i, &x| {\n        assert_eq!(x, xs[xs.len() - 1 - i]);\n        i + 1\n    });\n    assert_eq!(i, xs.len());\n}\n\n#[test]\nfn test_iterator_peekable_next_if_eq() {\n    // first, try on references\n    let xs = vec![\"Heart\", \"of\", \"Gold\"];\n    let mut it = xs.into_iter().peekable();\n    // try before `peek()`\n    assert_eq!(it.next_if_eq(&\"trillian\"), None);\n    assert_eq!(it.next_if_eq(&\"Heart\"), Some(\"Heart\"));\n    // try after peek()\n    assert_eq!(it.peek(), Some(&\"of\"));\n    assert_eq!(it.next_if_eq(&\"of\"), Some(\"of\"));\n    assert_eq!(it.next_if_eq(&\"zaphod\"), None);\n    // make sure `next()` still behaves\n    assert_eq!(it.next(), Some(\"Gold\"));\n\n    // make sure comparison works for owned values\n    let xs = vec![String::from(\"Ludicrous\"), \"speed\".into()];\n    let mut it = xs.into_iter().peekable();\n    // make sure basic functionality works\n    assert_eq!(it.next_if_eq(\"Ludicrous\"), Some(\"Ludicrous\".into()));\n    assert_eq!(it.next_if_eq(\"speed\"), Some(\"speed\".into()));\n    assert_eq!(it.next_if_eq(\"\"), None);\n}\n\n#[test]\nfn test_iterator_peekable_mut() {\n    let mut it = vec![1, 2, 3].into_iter().peekable();\n    if let Some(p) = it.peek_mut() {\n        if *p == 1 {\n            *p = 5;\n        }\n    }\n    assert_eq!(it.collect::<Vec<_>>(), vec![5, 2, 3]);\n}\n\n#[test]\nfn test_iterator_peekable_remember_peek_none_1() {\n    // Check that the loop using .peek() terminates\n    let data = [1, 2, 3];\n    let mut iter = CycleIter::new(&data).peekable();\n\n    let mut n = 0;\n    while let Some(_) = iter.next() {\n        let is_the_last = iter.peek().is_none();\n        assert_eq!(is_the_last, n == data.len() - 1);\n        n += 1;\n        if n > data.len() {\n            break;\n        }\n    }\n    assert_eq!(n, data.len());\n}\n\n#[test]\nfn test_iterator_peekable_remember_peek_none_2() {\n    let data = [0];\n    let mut iter = CycleIter::new(&data).peekable();\n    iter.next();\n    assert_eq!(iter.peek(), None);\n    assert_eq!(iter.last(), None);\n}\n\n#[test]\nfn test_iterator_peekable_remember_peek_none_3() {\n    let data = [0];\n    let mut iter = CycleIter::new(&data).peekable();\n    iter.peek();\n    assert_eq!(iter.nth(0), Some(&0));\n\n    let mut iter = CycleIter::new(&data).peekable();\n    iter.next();\n    assert_eq!(iter.peek(), None);\n    assert_eq!(iter.nth(0), None);\n}\n\n#[test]\nfn test_peek_try_folds() {\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n\n    assert_eq!((1..20).peekable().try_fold(7, f), (1..20).try_fold(7, f));\n    assert_eq!((1..20).peekable().try_rfold(7, f), (1..20).try_rfold(7, f));\n\n    let mut iter = (1..20).peekable();\n    assert_eq!(iter.peek(), Some(&1));\n    assert_eq!(iter.try_fold(7, f), (1..20).try_fold(7, f));\n\n    let mut iter = (1..20).peekable();\n    assert_eq!(iter.peek(), Some(&1));\n    assert_eq!(iter.try_rfold(7, f), (1..20).try_rfold(7, f));\n\n    let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n    assert_eq!(iter.peek(), Some(&100));\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.peek(), Some(&40));\n\n    let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n    assert_eq!(iter.peek(), Some(&100));\n    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n    assert_eq!(iter.peek(), Some(&100));\n    assert_eq!(iter.next_back(), Some(50));\n\n    let mut iter = (2..5).peekable();\n    assert_eq!(iter.peek(), Some(&2));\n    assert_eq!(iter.try_for_each(Err), Err(2));\n    assert_eq!(iter.peek(), Some(&3));\n    assert_eq!(iter.try_for_each(Err), Err(3));\n    assert_eq!(iter.peek(), Some(&4));\n    assert_eq!(iter.try_for_each(Err), Err(4));\n    assert_eq!(iter.peek(), None);\n    assert_eq!(iter.try_for_each(Err), Ok(()));\n\n    let mut iter = (2..5).peekable();\n    assert_eq!(iter.peek(), Some(&2));\n    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(4));\n    assert_eq!(iter.peek(), Some(&2));\n    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(3));\n    assert_eq!(iter.peek(), Some(&2));\n    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(2));\n    assert_eq!(iter.peek(), None);\n    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Ok(()));\n}\n\n#[test]\nfn test_peekable_non_fused() {\n    let mut iter = NonFused::new(empty::<i32>()).peekable();\n\n    assert_eq!(iter.peek(), None);\n    assert_eq!(iter.next_back(), None);\n}\n"],[2974,"use core::iter::*;\n\n#[test]\nfn test_iterator_take_while() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n    let ys = [0, 1, 2, 3, 5, 13];\n    let it = xs.iter().take_while(|&x| *x < 15);\n    let mut i = 0;\n    for x in it {\n        assert_eq!(*x, ys[i]);\n        i += 1;\n    }\n    assert_eq!(i, ys.len());\n}\n\n#[test]\nfn test_take_while_folds() {\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    assert_eq!((1..20).take_while(|&x| x != 10).try_fold(7, f), (1..10).try_fold(7, f));\n    let mut iter = (1..20).take_while(|&x| x != 10);\n    assert_eq!(iter.try_fold(0, |x, y| Some(x + y)), Some((1..10).sum()));\n    assert_eq!(iter.next(), None, \"flag should be set\");\n    let iter = (1..20).take_while(|&x| x != 10);\n    assert_eq!(iter.fold(0, |x, y| x + y), (1..10).sum());\n\n    let mut iter = (10..50).take_while(|&x| x != 40);\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.next(), Some(20));\n}\n"],[2975,"use core::iter::*;\n\n#[test]\nfn test_copied() {\n    let xs = [2, 4, 6, 8];\n\n    let mut it = xs.iter().copied();\n    assert_eq!(it.len(), 4);\n    assert_eq!(it.next(), Some(2));\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.next(), Some(4));\n    assert_eq!(it.len(), 2);\n    assert_eq!(it.next_back(), Some(8));\n    assert_eq!(it.len(), 1);\n    assert_eq!(it.next_back(), Some(6));\n    assert_eq!(it.len(), 0);\n    assert_eq!(it.next_back(), None);\n}\n"],[2976,"use super::*;\nuse core::iter::*;\n\n#[test]\nfn test_iterator_flatten() {\n    let xs = [0, 3, 6];\n    let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let it = xs.iter().map(|&x| (x..).step_by(1).take(3)).flatten();\n    let mut i = 0;\n    for x in it {\n        assert_eq!(x, ys[i]);\n        i += 1;\n    }\n    assert_eq!(i, ys.len());\n}\n\n/// Tests `Flatten::fold` with items already picked off the front and back,\n/// to make sure all parts of the `Flatten` are folded correctly.\n#[test]\nfn test_iterator_flatten_fold() {\n    let xs = [0, 3, 6];\n    let ys = [1, 2, 3, 4, 5, 6, 7];\n    let mut it = xs.iter().map(|&x| x..x + 3).flatten();\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.next_back(), Some(8));\n    let i = it.fold(0, |i, x| {\n        assert_eq!(x, ys[i]);\n        i + 1\n    });\n    assert_eq!(i, ys.len());\n\n    let mut it = xs.iter().map(|&x| x..x + 3).flatten();\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.next_back(), Some(8));\n    let i = it.rfold(ys.len(), |i, x| {\n        assert_eq!(x, ys[i - 1]);\n        i - 1\n    });\n    assert_eq!(i, 0);\n}\n\n#[test]\nfn test_flatten_try_folds() {\n    let f = &|acc, x| i32::checked_add(acc * 2 / 3, x);\n    let mr = &|x| (5 * x)..(5 * x + 5);\n    assert_eq!((0..10).map(mr).flatten().try_fold(7, f), (0..50).try_fold(7, f));\n    assert_eq!((0..10).map(mr).flatten().try_rfold(7, f), (0..50).try_rfold(7, f));\n    let mut iter = (0..10).map(mr).flatten();\n    iter.next();\n    iter.next_back(); // have front and back iters in progress\n    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n\n    let mut iter = (0..10).map(|x| (4 * x)..(4 * x + 4)).flatten();\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.next(), Some(17));\n    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n    assert_eq!(iter.next_back(), Some(35));\n}\n\n#[test]\nfn test_flatten_non_fused_outer() {\n    let mut iter = NonFused::new(once(0..2)).flatten();\n\n    assert_eq!(iter.next_back(), Some(1));\n    assert_eq!(iter.next(), Some(0));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.next(), None);\n\n    let mut iter = NonFused::new(once(0..2)).flatten();\n\n    assert_eq!(iter.next(), Some(0));\n    assert_eq!(iter.next_back(), Some(1));\n    assert_eq!(iter.next_back(), None);\n    assert_eq!(iter.next_back(), None);\n}\n\n#[test]\nfn test_flatten_non_fused_inner() {\n    let mut iter = once(0..1).chain(once(1..3)).flat_map(NonFused::new);\n\n    assert_eq!(iter.next_back(), Some(2));\n    assert_eq!(iter.next(), Some(0));\n    assert_eq!(iter.next(), Some(1));\n    assert_eq!(iter.next(), None);\n    assert_eq!(iter.next(), None);\n\n    let mut iter = once(0..1).chain(once(1..3)).flat_map(NonFused::new);\n\n    assert_eq!(iter.next(), Some(0));\n    assert_eq!(iter.next_back(), Some(2));\n    assert_eq!(iter.next_back(), Some(1));\n    assert_eq!(iter.next_back(), None);\n    assert_eq!(iter.next_back(), None);\n}\n\n#[test]\nfn test_double_ended_flatten() {\n    let u = [0, 1];\n    let v = [5, 6, 7, 8];\n    let mut it = u.iter().map(|x| &v[*x..v.len()]).flatten();\n    assert_eq!(it.next_back().unwrap(), &8);\n    assert_eq!(it.next().unwrap(), &5);\n    assert_eq!(it.next_back().unwrap(), &7);\n    assert_eq!(it.next_back().unwrap(), &6);\n    assert_eq!(it.next_back().unwrap(), &8);\n    assert_eq!(it.next().unwrap(), &6);\n    assert_eq!(it.next_back().unwrap(), &7);\n    assert_eq!(it.next_back(), None);\n    assert_eq!(it.next(), None);\n    assert_eq!(it.next_back(), None);\n}\n"],[2977,"use super::*;\nuse core::iter::*;\n\n#[test]\nfn test_iterator_chain() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let ys = [30, 40, 50, 60];\n    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n    let it = xs.iter().chain(&ys);\n    let mut i = 0;\n    for &x in it {\n        assert_eq!(x, expected[i]);\n        i += 1;\n    }\n    assert_eq!(i, expected.len());\n\n    let ys = (30..).step_by(10).take(4);\n    let it = xs.iter().cloned().chain(ys);\n    let mut i = 0;\n    for x in it {\n        assert_eq!(x, expected[i]);\n        i += 1;\n    }\n    assert_eq!(i, expected.len());\n}\n\n#[test]\nfn test_iterator_chain_advance_by() {\n    fn test_chain(xs: &[i32], ys: &[i32]) {\n        let len = xs.len() + ys.len();\n\n        for i in 0..xs.len() {\n            let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n            iter.advance_by(i).unwrap();\n            assert_eq!(iter.next(), Some(&xs[i]));\n            assert_eq!(iter.advance_by(100), Err(len - i - 1));\n        }\n\n        for i in 0..ys.len() {\n            let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n            iter.advance_by(xs.len() + i).unwrap();\n            assert_eq!(iter.next(), Some(&ys[i]));\n            assert_eq!(iter.advance_by(100), Err(ys.len() - i - 1));\n        }\n\n        let mut iter = xs.iter().chain(ys);\n        iter.advance_by(len).unwrap();\n        assert_eq!(iter.next(), None);\n\n        let mut iter = xs.iter().chain(ys);\n        assert_eq!(iter.advance_by(len + 1), Err(len));\n    }\n\n    test_chain(&[], &[]);\n    test_chain(&[], &[0, 1, 2, 3, 4, 5]);\n    test_chain(&[0, 1, 2, 3, 4, 5], &[]);\n    test_chain(&[0, 1, 2, 3, 4, 5], &[30, 40, 50, 60]);\n}\n\n#[test]\nfn test_iterator_chain_advance_back_by() {\n    fn test_chain(xs: &[i32], ys: &[i32]) {\n        let len = xs.len() + ys.len();\n\n        for i in 0..ys.len() {\n            let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n            iter.advance_back_by(i).unwrap();\n            assert_eq!(iter.next_back(), Some(&ys[ys.len() - i - 1]));\n            assert_eq!(iter.advance_back_by(100), Err(len - i - 1));\n        }\n\n        for i in 0..xs.len() {\n            let mut iter = Unfuse::new(xs).chain(Unfuse::new(ys));\n            iter.advance_back_by(ys.len() + i).unwrap();\n            assert_eq!(iter.next_back(), Some(&xs[xs.len() - i - 1]));\n            assert_eq!(iter.advance_back_by(100), Err(xs.len() - i - 1));\n        }\n\n        let mut iter = xs.iter().chain(ys);\n        iter.advance_back_by(len).unwrap();\n        assert_eq!(iter.next_back(), None);\n\n        let mut iter = xs.iter().chain(ys);\n        assert_eq!(iter.advance_back_by(len + 1), Err(len));\n    }\n\n    test_chain(&[], &[]);\n    test_chain(&[], &[0, 1, 2, 3, 4, 5]);\n    test_chain(&[0, 1, 2, 3, 4, 5], &[]);\n    test_chain(&[0, 1, 2, 3, 4, 5], &[30, 40, 50, 60]);\n}\n\n#[test]\nfn test_iterator_chain_nth() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let ys = [30, 40, 50, 60];\n    let zs = [];\n    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n    for (i, x) in expected.iter().enumerate() {\n        assert_eq!(Some(x), xs.iter().chain(&ys).nth(i));\n    }\n    assert_eq!(zs.iter().chain(&xs).nth(0), Some(&0));\n\n    let mut it = xs.iter().chain(&zs);\n    assert_eq!(it.nth(5), Some(&5));\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn test_iterator_chain_nth_back() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let ys = [30, 40, 50, 60];\n    let zs = [];\n    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n    for (i, x) in expected.iter().rev().enumerate() {\n        assert_eq!(Some(x), xs.iter().chain(&ys).nth_back(i));\n    }\n    assert_eq!(zs.iter().chain(&xs).nth_back(0), Some(&5));\n\n    let mut it = xs.iter().chain(&zs);\n    assert_eq!(it.nth_back(5), Some(&0));\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn test_iterator_chain_last() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let ys = [30, 40, 50, 60];\n    let zs = [];\n    assert_eq!(xs.iter().chain(&ys).last(), Some(&60));\n    assert_eq!(zs.iter().chain(&ys).last(), Some(&60));\n    assert_eq!(ys.iter().chain(&zs).last(), Some(&60));\n    assert_eq!(zs.iter().chain(&zs).last(), None);\n}\n\n#[test]\nfn test_iterator_chain_count() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let ys = [30, 40, 50, 60];\n    let zs = [];\n    assert_eq!(xs.iter().chain(&ys).count(), 10);\n    assert_eq!(zs.iter().chain(&ys).count(), 4);\n}\n\n#[test]\nfn test_iterator_chain_find() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let ys = [30, 40, 50, 60];\n    let mut iter = xs.iter().chain(&ys);\n    assert_eq!(iter.find(|&&i| i == 4), Some(&4));\n    assert_eq!(iter.next(), Some(&5));\n    assert_eq!(iter.find(|&&i| i == 40), Some(&40));\n    assert_eq!(iter.next(), Some(&50));\n    assert_eq!(iter.find(|&&i| i == 100), None);\n    assert_eq!(iter.next(), None);\n}\n\n#[test]\nfn test_iterator_chain_size_hint() {\n    // this chains an iterator of length 0 with an iterator of length 1,\n    // so after calling `.next()` once, the iterator is empty and the\n    // state is `ChainState::Back`. `.size_hint()` should now disregard\n    // the size hint of the left iterator\n    let mut iter = Toggle { is_empty: true }.chain(once(()));\n    assert_eq!(iter.next(), Some(()));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n\n    let mut iter = once(()).chain(Toggle { is_empty: true });\n    assert_eq!(iter.next_back(), Some(()));\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n}\n\n#[test]\nfn test_iterator_chain_unfused() {\n    // Chain shouldn't be fused in its second iterator, depending on direction\n    let mut iter = NonFused::new(empty()).chain(Toggle { is_empty: true });\n    assert!(iter.next().is_none());\n    assert!(iter.next().is_some());\n    assert!(iter.next().is_none());\n\n    let mut iter = Toggle { is_empty: true }.chain(NonFused::new(empty()));\n    assert!(iter.next_back().is_none());\n    assert!(iter.next_back().is_some());\n    assert!(iter.next_back().is_none());\n}\n\n#[test]\nfn test_chain_fold() {\n    let xs = [1, 2, 3];\n    let ys = [1, 2, 0];\n\n    let mut iter = xs.iter().chain(&ys);\n    iter.next();\n    let mut result = Vec::new();\n    iter.fold((), |(), &elt| result.push(elt));\n    assert_eq!(&[2, 3, 1, 2, 0], &result[..]);\n}\n\n#[test]\nfn test_chain_try_folds() {\n    let c = || (0..10).chain(10..20);\n\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    assert_eq!(c().try_fold(7, f), (0..20).try_fold(7, f));\n    assert_eq!(c().try_rfold(7, f), (0..20).rev().try_fold(7, f));\n\n    let mut iter = c();\n    assert_eq!(iter.position(|x| x == 5), Some(5));\n    assert_eq!(iter.next(), Some(6), \"stopped in front, state Both\");\n    assert_eq!(iter.position(|x| x == 13), Some(6));\n    assert_eq!(iter.next(), Some(14), \"stopped in back, state Back\");\n    assert_eq!(iter.try_fold(0, |acc, x| Some(acc + x)), Some((15..20).sum()));\n\n    let mut iter = c().rev(); // use rev to access try_rfold\n    assert_eq!(iter.position(|x| x == 15), Some(4));\n    assert_eq!(iter.next(), Some(14), \"stopped in back, state Both\");\n    assert_eq!(iter.position(|x| x == 5), Some(8));\n    assert_eq!(iter.next(), Some(4), \"stopped in front, state Front\");\n    assert_eq!(iter.try_fold(0, |acc, x| Some(acc + x)), Some((0..4).sum()));\n\n    let mut iter = c();\n    iter.by_ref().rev().nth(14); // skip the last 15, ending in state Front\n    assert_eq!(iter.try_fold(7, f), (0..5).try_fold(7, f));\n\n    let mut iter = c();\n    iter.nth(14); // skip the first 15, ending in state Back\n    assert_eq!(iter.try_rfold(7, f), (15..20).try_rfold(7, f));\n}\n\n#[test]\nfn test_double_ended_chain() {\n    let xs = [1, 2, 3, 4, 5];\n    let ys = [7, 9, 11];\n    let mut it = xs.iter().chain(&ys).rev();\n    assert_eq!(it.next().unwrap(), &11);\n    assert_eq!(it.next().unwrap(), &9);\n    assert_eq!(it.next_back().unwrap(), &1);\n    assert_eq!(it.next_back().unwrap(), &2);\n    assert_eq!(it.next_back().unwrap(), &3);\n    assert_eq!(it.next_back().unwrap(), &4);\n    assert_eq!(it.next_back().unwrap(), &5);\n    assert_eq!(it.next_back().unwrap(), &7);\n    assert_eq!(it.next_back(), None);\n\n    // test that .chain() is well behaved with an unfused iterator\n    struct CrazyIterator(bool);\n    impl CrazyIterator {\n        fn new() -> CrazyIterator {\n            CrazyIterator(false)\n        }\n    }\n    impl Iterator for CrazyIterator {\n        type Item = i32;\n        fn next(&mut self) -> Option<i32> {\n            if self.0 {\n                Some(99)\n            } else {\n                self.0 = true;\n                None\n            }\n        }\n    }\n\n    impl DoubleEndedIterator for CrazyIterator {\n        fn next_back(&mut self) -> Option<i32> {\n            self.next()\n        }\n    }\n\n    assert_eq!(CrazyIterator::new().chain(0..10).rev().last(), Some(0));\n    assert!((0..10).chain(CrazyIterator::new()).rev().any(|i| i == 0));\n}\n"],[2978,"use core::iter::*;\n\n#[test]\nfn test_cycle() {\n    let cycle_len = 3;\n    let it = (0..).step_by(1).take(cycle_len).cycle();\n    assert_eq!(it.size_hint(), (usize::MAX, None));\n    for (i, x) in it.take(100).enumerate() {\n        assert_eq!(i % cycle_len, x);\n    }\n\n    let mut it = (0..).step_by(1).take(0).cycle();\n    assert_eq!(it.size_hint(), (0, Some(0)));\n    assert_eq!(it.next(), None);\n\n    assert_eq!(empty::<i32>().cycle().fold(0, |acc, x| acc + x), 0);\n\n    assert_eq!(once(1).cycle().skip(1).take(4).fold(0, |acc, x| acc + x), 4);\n\n    assert_eq!((0..10).cycle().take(5).sum::<i32>(), 10);\n    assert_eq!((0..10).cycle().take(15).sum::<i32>(), 55);\n    assert_eq!((0..10).cycle().take(25).sum::<i32>(), 100);\n\n    let mut iter = (0..10).cycle();\n    iter.nth(14);\n    assert_eq!(iter.take(8).sum::<i32>(), 38);\n\n    let mut iter = (0..10).cycle();\n    iter.nth(9);\n    assert_eq!(iter.take(3).sum::<i32>(), 3);\n}\n"],[2979,"use core::iter::*;\n\n#[test]\nfn test_fuse_nth() {\n    let xs = [0, 1, 2];\n    let mut it = xs.iter();\n\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.nth(2), Some(&2));\n    assert_eq!(it.len(), 0);\n    assert_eq!(it.nth(2), None);\n    assert_eq!(it.len(), 0);\n}\n\n#[test]\nfn test_fuse_last() {\n    let xs = [0, 1, 2];\n    let it = xs.iter();\n\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.last(), Some(&2));\n}\n\n#[test]\nfn test_fuse_count() {\n    let xs = [0, 1, 2];\n    let it = xs.iter();\n\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.count(), 3);\n    // Can't check len now because count consumes.\n}\n\n#[test]\nfn test_fuse_fold() {\n    let xs = [0, 1, 2];\n    let it = xs.iter(); // `FusedIterator`\n    let i = it.fuse().fold(0, |i, &x| {\n        assert_eq!(x, xs[i]);\n        i + 1\n    });\n    assert_eq!(i, xs.len());\n\n    let it = xs.iter(); // `FusedIterator`\n    let i = it.fuse().rfold(xs.len(), |i, &x| {\n        assert_eq!(x, xs[i - 1]);\n        i - 1\n    });\n    assert_eq!(i, 0);\n\n    let it = xs.iter().scan((), |_, &x| Some(x)); // `!FusedIterator`\n    let i = it.fuse().fold(0, |i, x| {\n        assert_eq!(x, xs[i]);\n        i + 1\n    });\n    assert_eq!(i, xs.len());\n}\n\n#[test]\nfn test_fuse() {\n    let mut it = 0..3;\n    assert_eq!(it.len(), 3);\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.len(), 2);\n    assert_eq!(it.next(), Some(1));\n    assert_eq!(it.len(), 1);\n    assert_eq!(it.next(), Some(2));\n    assert_eq!(it.len(), 0);\n    assert_eq!(it.next(), None);\n    assert_eq!(it.len(), 0);\n    assert_eq!(it.next(), None);\n    assert_eq!(it.len(), 0);\n    assert_eq!(it.next(), None);\n    assert_eq!(it.len(), 0);\n}\n"],[2980,"use core::iter::*;\n\n#[test]\nfn test_iterator_step_by() {\n    // Identity\n    let mut it = (0..).step_by(1).take(3);\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.next(), Some(1));\n    assert_eq!(it.next(), Some(2));\n    assert_eq!(it.next(), None);\n\n    let mut it = (0..).step_by(3).take(4);\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.next(), Some(3));\n    assert_eq!(it.next(), Some(6));\n    assert_eq!(it.next(), Some(9));\n    assert_eq!(it.next(), None);\n\n    let mut it = (0..3).step_by(1);\n    assert_eq!(it.next_back(), Some(2));\n    assert_eq!(it.next_back(), Some(1));\n    assert_eq!(it.next_back(), Some(0));\n    assert_eq!(it.next_back(), None);\n\n    let mut it = (0..11).step_by(3);\n    assert_eq!(it.next_back(), Some(9));\n    assert_eq!(it.next_back(), Some(6));\n    assert_eq!(it.next_back(), Some(3));\n    assert_eq!(it.next_back(), Some(0));\n    assert_eq!(it.next_back(), None);\n}\n\n#[test]\nfn test_iterator_step_by_nth() {\n    let mut it = (0..16).step_by(5);\n    assert_eq!(it.nth(0), Some(0));\n    assert_eq!(it.nth(0), Some(5));\n    assert_eq!(it.nth(0), Some(10));\n    assert_eq!(it.nth(0), Some(15));\n    assert_eq!(it.nth(0), None);\n\n    let it = (0..18).step_by(5);\n    assert_eq!(it.clone().nth(0), Some(0));\n    assert_eq!(it.clone().nth(1), Some(5));\n    assert_eq!(it.clone().nth(2), Some(10));\n    assert_eq!(it.clone().nth(3), Some(15));\n    assert_eq!(it.clone().nth(4), None);\n    assert_eq!(it.clone().nth(42), None);\n}\n\n#[test]\nfn test_iterator_step_by_nth_overflow() {\n    #[cfg(target_pointer_width = \"8\")]\n    type Bigger = u16;\n    #[cfg(target_pointer_width = \"16\")]\n    type Bigger = u32;\n    #[cfg(target_pointer_width = \"32\")]\n    type Bigger = u64;\n    #[cfg(target_pointer_width = \"64\")]\n    type Bigger = u128;\n\n    #[derive(Clone)]\n    struct Test(Bigger);\n    impl Iterator for &mut Test {\n        type Item = i32;\n        fn next(&mut self) -> Option<Self::Item> {\n            Some(21)\n        }\n        fn nth(&mut self, n: usize) -> Option<Self::Item> {\n            self.0 += n as Bigger + 1;\n            Some(42)\n        }\n    }\n\n    let mut it = Test(0);\n    let root = usize::MAX >> (usize::BITS / 2);\n    let n = root + 20;\n    (&mut it).step_by(n).nth(n);\n    assert_eq!(it.0, n as Bigger * n as Bigger);\n\n    // large step\n    let mut it = Test(0);\n    (&mut it).step_by(usize::MAX).nth(5);\n    assert_eq!(it.0, (usize::MAX as Bigger) * 5);\n\n    // n + 1 overflows\n    let mut it = Test(0);\n    (&mut it).step_by(2).nth(usize::MAX);\n    assert_eq!(it.0, (usize::MAX as Bigger) * 2);\n\n    // n + 1 overflows\n    let mut it = Test(0);\n    (&mut it).step_by(1).nth(usize::MAX);\n    assert_eq!(it.0, (usize::MAX as Bigger) * 1);\n}\n\n#[test]\nfn test_iterator_step_by_nth_try_fold() {\n    let mut it = (0..).step_by(10);\n    assert_eq!(it.try_fold(0, i8::checked_add), None);\n    assert_eq!(it.next(), Some(60));\n    assert_eq!(it.try_fold(0, i8::checked_add), None);\n    assert_eq!(it.next(), Some(90));\n\n    let mut it = (100..).step_by(10);\n    assert_eq!(it.try_fold(50, i8::checked_add), None);\n    assert_eq!(it.next(), Some(110));\n\n    let mut it = (100..=100).step_by(10);\n    assert_eq!(it.next(), Some(100));\n    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n}\n\n#[test]\nfn test_iterator_step_by_nth_back() {\n    let mut it = (0..16).step_by(5);\n    assert_eq!(it.nth_back(0), Some(15));\n    assert_eq!(it.nth_back(0), Some(10));\n    assert_eq!(it.nth_back(0), Some(5));\n    assert_eq!(it.nth_back(0), Some(0));\n    assert_eq!(it.nth_back(0), None);\n\n    let mut it = (0..16).step_by(5);\n    assert_eq!(it.next(), Some(0)); // to set `first_take` to `false`\n    assert_eq!(it.nth_back(0), Some(15));\n    assert_eq!(it.nth_back(0), Some(10));\n    assert_eq!(it.nth_back(0), Some(5));\n    assert_eq!(it.nth_back(0), None);\n\n    let it = || (0..18).step_by(5);\n    assert_eq!(it().nth_back(0), Some(15));\n    assert_eq!(it().nth_back(1), Some(10));\n    assert_eq!(it().nth_back(2), Some(5));\n    assert_eq!(it().nth_back(3), Some(0));\n    assert_eq!(it().nth_back(4), None);\n    assert_eq!(it().nth_back(42), None);\n}\n\n#[test]\nfn test_iterator_step_by_nth_try_rfold() {\n    let mut it = (0..100).step_by(10);\n    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n    assert_eq!(it.next_back(), Some(70));\n    assert_eq!(it.next(), Some(0));\n    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n    assert_eq!(it.next_back(), Some(30));\n\n    let mut it = (0..100).step_by(10);\n    assert_eq!(it.try_rfold(50, i8::checked_add), None);\n    assert_eq!(it.next_back(), Some(80));\n\n    let mut it = (100..=100).step_by(10);\n    assert_eq!(it.next_back(), Some(100));\n    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n}\n\n#[test]\n#[should_panic]\nfn test_iterator_step_by_zero() {\n    let mut it = (0..).step_by(0);\n    it.next();\n}\n\n#[test]\nfn test_iterator_step_by_size_hint() {\n    struct StubSizeHint(usize, Option<usize>);\n    impl Iterator for StubSizeHint {\n        type Item = ();\n        fn next(&mut self) -> Option<()> {\n            self.0 -= 1;\n            if let Some(ref mut upper) = self.1 {\n                *upper -= 1;\n            }\n            Some(())\n        }\n        fn size_hint(&self) -> (usize, Option<usize>) {\n            (self.0, self.1)\n        }\n    }\n\n    // The two checks in each case are needed because the logic\n    // is different before the first call to `next()`.\n\n    let mut it = StubSizeHint(10, Some(10)).step_by(1);\n    assert_eq!(it.size_hint(), (10, Some(10)));\n    it.next();\n    assert_eq!(it.size_hint(), (9, Some(9)));\n\n    // exact multiple\n    let mut it = StubSizeHint(10, Some(10)).step_by(3);\n    assert_eq!(it.size_hint(), (4, Some(4)));\n    it.next();\n    assert_eq!(it.size_hint(), (3, Some(3)));\n\n    // larger base range, but not enough to get another element\n    let mut it = StubSizeHint(12, Some(12)).step_by(3);\n    assert_eq!(it.size_hint(), (4, Some(4)));\n    it.next();\n    assert_eq!(it.size_hint(), (3, Some(3)));\n\n    // smaller base range, so fewer resulting elements\n    let mut it = StubSizeHint(9, Some(9)).step_by(3);\n    assert_eq!(it.size_hint(), (3, Some(3)));\n    it.next();\n    assert_eq!(it.size_hint(), (2, Some(2)));\n\n    // infinite upper bound\n    let mut it = StubSizeHint(usize::MAX, None).step_by(1);\n    assert_eq!(it.size_hint(), (usize::MAX, None));\n    it.next();\n    assert_eq!(it.size_hint(), (usize::MAX - 1, None));\n\n    // still infinite with larger step\n    let mut it = StubSizeHint(7, None).step_by(3);\n    assert_eq!(it.size_hint(), (3, None));\n    it.next();\n    assert_eq!(it.size_hint(), (2, None));\n\n    // propagates ExactSizeIterator\n    let a = [1, 2, 3, 4, 5];\n    let it = a.iter().step_by(2);\n    assert_eq!(it.len(), 3);\n\n    // Cannot be TrustedLen as a step greater than one makes an iterator\n    // with (usize::MAX, None) no longer meet the safety requirements\n    trait TrustedLenCheck {\n        fn test(self) -> bool;\n    }\n    impl<T: Iterator> TrustedLenCheck for T {\n        default fn test(self) -> bool {\n            false\n        }\n    }\n    impl<T: TrustedLen> TrustedLenCheck for T {\n        fn test(self) -> bool {\n            true\n        }\n    }\n    assert!(TrustedLenCheck::test(a.iter()));\n    assert!(!TrustedLenCheck::test(a.iter().step_by(1)));\n}\n\n#[test]\nfn test_step_by_skip() {\n    assert_eq!((0..640).step_by(128).skip(1).collect::<Vec<_>>(), [128, 256, 384, 512]);\n    assert_eq!((0..=50).step_by(10).nth(3), Some(30));\n    assert_eq!((200..=255u8).step_by(10).nth(3), Some(230));\n}\n"],[2981,"use core::iter::*;\n\n#[test]\nfn test_iterator_enumerate() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let it = xs.iter().enumerate();\n    for (i, &x) in it {\n        assert_eq!(i, x);\n    }\n}\n\n#[test]\nfn test_iterator_enumerate_nth() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    for (i, &x) in xs.iter().enumerate() {\n        assert_eq!(i, x);\n    }\n\n    let mut it = xs.iter().enumerate();\n    while let Some((i, &x)) = it.nth(0) {\n        assert_eq!(i, x);\n    }\n\n    let mut it = xs.iter().enumerate();\n    while let Some((i, &x)) = it.nth(1) {\n        assert_eq!(i, x);\n    }\n\n    let (i, &x) = xs.iter().enumerate().nth(3).unwrap();\n    assert_eq!(i, x);\n    assert_eq!(i, 3);\n}\n\n#[test]\nfn test_iterator_enumerate_nth_back() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let mut it = xs.iter().enumerate();\n    while let Some((i, &x)) = it.nth_back(0) {\n        assert_eq!(i, x);\n    }\n\n    let mut it = xs.iter().enumerate();\n    while let Some((i, &x)) = it.nth_back(1) {\n        assert_eq!(i, x);\n    }\n\n    let (i, &x) = xs.iter().enumerate().nth_back(3).unwrap();\n    assert_eq!(i, x);\n    assert_eq!(i, 2);\n}\n\n#[test]\nfn test_iterator_enumerate_count() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    assert_eq!(xs.iter().enumerate().count(), 6);\n}\n\n#[test]\nfn test_iterator_enumerate_fold() {\n    let xs = [0, 1, 2, 3, 4, 5];\n    let mut it = xs.iter().enumerate();\n    // steal a couple to get an interesting offset\n    assert_eq!(it.next(), Some((0, &0)));\n    assert_eq!(it.next(), Some((1, &1)));\n    let i = it.fold(2, |i, (j, &x)| {\n        assert_eq!(i, j);\n        assert_eq!(x, xs[j]);\n        i + 1\n    });\n    assert_eq!(i, xs.len());\n\n    let mut it = xs.iter().enumerate();\n    assert_eq!(it.next(), Some((0, &0)));\n    let i = it.rfold(xs.len() - 1, |i, (j, &x)| {\n        assert_eq!(i, j);\n        assert_eq!(x, xs[j]);\n        i - 1\n    });\n    assert_eq!(i, 0);\n}\n\n#[test]\nfn test_enumerate_try_folds() {\n    let f = &|acc, (i, x)| usize::checked_add(2 * acc, x / (i + 1) + i);\n    assert_eq!((9..18).enumerate().try_fold(7, f), (0..9).map(|i| (i, i + 9)).try_fold(7, f));\n    assert_eq!((9..18).enumerate().try_rfold(7, f), (0..9).map(|i| (i, i + 9)).try_rfold(7, f));\n\n    let mut iter = (100..200).enumerate();\n    let f = &|acc, (i, x)| u8::checked_add(acc, u8::checked_div(x, i as u8 + 1)?);\n    assert_eq!(iter.try_fold(0, f), None);\n    assert_eq!(iter.next(), Some((7, 107)));\n    assert_eq!(iter.try_rfold(0, f), None);\n    assert_eq!(iter.next_back(), Some((11, 111)));\n}\n\n#[test]\nfn test_double_ended_enumerate() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut it = xs.iter().cloned().enumerate();\n    assert_eq!(it.next(), Some((0, 1)));\n    assert_eq!(it.next(), Some((1, 2)));\n    assert_eq!(it.next_back(), Some((5, 6)));\n    assert_eq!(it.next_back(), Some((4, 5)));\n    assert_eq!(it.next_back(), Some((3, 4)));\n    assert_eq!(it.next_back(), Some((2, 3)));\n    assert_eq!(it.next(), None);\n}\n"],[2982,"use core::iter::*;\n\n#[test]\nfn test_inspect() {\n    let xs = [1, 2, 3, 4];\n    let mut n = 0;\n\n    let ys = xs.iter().cloned().inspect(|_| n += 1).collect::<Vec<usize>>();\n\n    assert_eq!(n, xs.len());\n    assert_eq!(&xs[..], &ys[..]);\n}\n\n#[test]\nfn test_inspect_fold() {\n    let xs = [1, 2, 3, 4];\n    let mut n = 0;\n    {\n        let it = xs.iter().inspect(|_| n += 1);\n        let i = it.fold(0, |i, &x| {\n            assert_eq!(x, xs[i]);\n            i + 1\n        });\n        assert_eq!(i, xs.len());\n    }\n    assert_eq!(n, xs.len());\n\n    let mut n = 0;\n    {\n        let it = xs.iter().inspect(|_| n += 1);\n        let i = it.rfold(xs.len(), |i, &x| {\n            assert_eq!(x, xs[i - 1]);\n            i - 1\n        });\n        assert_eq!(i, 0);\n    }\n    assert_eq!(n, xs.len());\n}\n"],[2983,"use core::iter::*;\n\n#[test]\nfn test_iterator_scan() {\n    // test the type inference\n    fn add(old: &mut isize, new: &usize) -> Option<f64> {\n        *old += *new as isize;\n        Some(*old as f64)\n    }\n    let xs = [0, 1, 2, 3, 4];\n    let ys = [0f64, 1.0, 3.0, 6.0, 10.0];\n\n    let it = xs.iter().scan(0, add);\n    let mut i = 0;\n    for x in it {\n        assert_eq!(x, ys[i]);\n        i += 1;\n    }\n    assert_eq!(i, ys.len());\n}\n"],[2984,"use core::iter::*;\n\n#[test]\nfn test_iterator_take() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n    let ys = [0, 1, 2, 3, 5];\n\n    let mut it = xs.iter().take(ys.len());\n    let mut i = 0;\n    assert_eq!(it.len(), ys.len());\n    while let Some(&x) = it.next() {\n        assert_eq!(x, ys[i]);\n        i += 1;\n        assert_eq!(it.len(), ys.len() - i);\n    }\n    assert_eq!(i, ys.len());\n    assert_eq!(it.len(), 0);\n\n    let mut it = xs.iter().take(ys.len());\n    let mut i = 0;\n    assert_eq!(it.len(), ys.len());\n    while let Some(&x) = it.next_back() {\n        i += 1;\n        assert_eq!(x, ys[ys.len() - i]);\n        assert_eq!(it.len(), ys.len() - i);\n    }\n    assert_eq!(i, ys.len());\n    assert_eq!(it.len(), 0);\n}\n\n#[test]\nfn test_iterator_take_nth() {\n    let xs = [0, 1, 2, 4, 5];\n    let mut it = xs.iter();\n    {\n        let mut take = it.by_ref().take(3);\n        let mut i = 0;\n        while let Some(&x) = take.nth(0) {\n            assert_eq!(x, i);\n            i += 1;\n        }\n    }\n    assert_eq!(it.nth(1), Some(&5));\n    assert_eq!(it.nth(0), None);\n\n    let xs = [0, 1, 2, 3, 4];\n    let mut it = xs.iter().take(7);\n    let mut i = 1;\n    while let Some(&x) = it.nth(1) {\n        assert_eq!(x, i);\n        i += 2;\n    }\n}\n\n#[test]\nfn test_iterator_take_nth_back() {\n    let xs = [0, 1, 2, 4, 5];\n    let mut it = xs.iter();\n    {\n        let mut take = it.by_ref().take(3);\n        let mut i = 0;\n        while let Some(&x) = take.nth_back(0) {\n            i += 1;\n            assert_eq!(x, 3 - i);\n        }\n    }\n    assert_eq!(it.nth_back(0), None);\n\n    let xs = [0, 1, 2, 3, 4];\n    let mut it = xs.iter().take(7);\n    assert_eq!(it.nth_back(1), Some(&3));\n    assert_eq!(it.nth_back(1), Some(&1));\n    assert_eq!(it.nth_back(1), None);\n}\n\n#[test]\nfn test_iterator_take_short() {\n    let xs = [0, 1, 2, 3];\n\n    let mut it = xs.iter().take(5);\n    let mut i = 0;\n    assert_eq!(it.len(), xs.len());\n    while let Some(&x) = it.next() {\n        assert_eq!(x, xs[i]);\n        i += 1;\n        assert_eq!(it.len(), xs.len() - i);\n    }\n    assert_eq!(i, xs.len());\n    assert_eq!(it.len(), 0);\n\n    let mut it = xs.iter().take(5);\n    let mut i = 0;\n    assert_eq!(it.len(), xs.len());\n    while let Some(&x) = it.next_back() {\n        i += 1;\n        assert_eq!(x, xs[xs.len() - i]);\n        assert_eq!(it.len(), xs.len() - i);\n    }\n    assert_eq!(i, xs.len());\n    assert_eq!(it.len(), 0);\n}\n\n#[test]\nfn test_take_try_folds() {\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    assert_eq!((10..30).take(10).try_fold(7, f), (10..20).try_fold(7, f));\n    assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n\n    let mut iter = (10..30).take(20);\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.next(), Some(20));\n    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n    assert_eq!(iter.next_back(), Some(24));\n\n    let mut iter = (2..20).take(3);\n    assert_eq!(iter.try_for_each(Err), Err(2));\n    assert_eq!(iter.try_for_each(Err), Err(3));\n    assert_eq!(iter.try_for_each(Err), Err(4));\n    assert_eq!(iter.try_for_each(Err), Ok(()));\n\n    let mut iter = (2..20).take(3).rev();\n    assert_eq!(iter.try_for_each(Err), Err(4));\n    assert_eq!(iter.try_for_each(Err), Err(3));\n    assert_eq!(iter.try_for_each(Err), Err(2));\n    assert_eq!(iter.try_for_each(Err), Ok(()));\n}\n"],[2985,"use core::iter::*;\n\n#[test]\nfn test_intersperse() {\n    let v = std::iter::empty().intersperse(0u32).collect::<Vec<_>>();\n    assert_eq!(v, vec![]);\n\n    let v = std::iter::once(1).intersperse(0).collect::<Vec<_>>();\n    assert_eq!(v, vec![1]);\n\n    let xs = [\"a\", \"\", \"b\", \"c\"];\n    let v: Vec<&str> = xs.iter().map(|x| *x).intersperse(\", \").collect();\n    let text: String = v.concat();\n    assert_eq!(text, \"a, , b, c\".to_string());\n\n    let ys = [0, 1, 2, 3];\n    let mut it = ys[..0].iter().map(|x| *x).intersperse(1);\n    assert!(it.next() == None);\n}\n\n#[test]\nfn test_intersperse_size_hint() {\n    let iter = std::iter::empty::<i32>().intersperse(0);\n    assert_eq!(iter.size_hint(), (0, Some(0)));\n\n    let xs = [\"a\", \"\", \"b\", \"c\"];\n    let mut iter = xs.iter().map(|x| *x).intersperse(\", \");\n    assert_eq!(iter.size_hint(), (7, Some(7)));\n\n    assert_eq!(iter.next(), Some(\"a\"));\n    assert_eq!(iter.size_hint(), (6, Some(6)));\n    assert_eq!(iter.next(), Some(\", \"));\n    assert_eq!(iter.size_hint(), (5, Some(5)));\n\n    assert_eq!([].iter().intersperse(&()).size_hint(), (0, Some(0)));\n}\n\n#[test]\nfn test_fold_specialization_intersperse() {\n    let mut iter = (1..2).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..3).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n\n    let mut iter = (1..4).intersperse(0);\n    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n}\n\n#[test]\nfn test_try_fold_specialization_intersperse_ok() {\n    let mut iter = (1..2).intersperse(0);\n    iter.clone().try_for_each(|x| {\n        assert_eq!(Some(x), iter.next());\n        Some(())\n    });\n\n    let mut iter = (1..3).intersperse(0);\n    iter.clone().try_for_each(|x| {\n        assert_eq!(Some(x), iter.next());\n        Some(())\n    });\n\n    let mut iter = (1..4).intersperse(0);\n    iter.clone().try_for_each(|x| {\n        assert_eq!(Some(x), iter.next());\n        Some(())\n    });\n}\n\n#[test]\nfn test_intersperse_with() {\n    #[derive(PartialEq, Debug)]\n    struct NotClone {\n        u: u32,\n    }\n    let r = vec![NotClone { u: 0 }, NotClone { u: 1 }]\n        .into_iter()\n        .intersperse_with(|| NotClone { u: 2 })\n        .collect::<Vec<_>>();\n    assert_eq!(r, vec![NotClone { u: 0 }, NotClone { u: 2 }, NotClone { u: 1 }]);\n\n    let mut ctr = 100;\n    let separator = || {\n        ctr *= 2;\n        ctr\n    };\n    let r = (0..3).intersperse_with(separator).collect::<Vec<_>>();\n    assert_eq!(r, vec![0, 200, 1, 400, 2]);\n}\n\n#[test]\nfn test_intersperse_fold() {\n    let v = (1..4).intersperse(9).fold(Vec::new(), |mut acc, x| {\n        acc.push(x);\n        acc\n    });\n    assert_eq!(v.as_slice(), [1, 9, 2, 9, 3]);\n\n    let mut iter = (1..4).intersperse(9);\n    assert_eq!(iter.next(), Some(1));\n    let v = iter.fold(Vec::new(), |mut acc, x| {\n        acc.push(x);\n        acc\n    });\n    assert_eq!(v.as_slice(), [9, 2, 9, 3]);\n\n    struct NoneAtStart(i32); // Produces: None, Some(2), Some(3), None, ...\n    impl Iterator for NoneAtStart {\n        type Item = i32;\n        fn next(&mut self) -> Option<i32> {\n            self.0 += 1;\n            Some(self.0).filter(|i| i % 3 != 1)\n        }\n    }\n\n    let v = NoneAtStart(0).intersperse(1000).fold(0, |a, b| a + b);\n    assert_eq!(v, 0);\n}\n\n#[test]\nfn test_intersperse_collect_string() {\n    let contents = vec![1, 2, 3];\n\n    let contents_string = contents\n        .into_iter()\n        .map(|id| id.to_string())\n        .intersperse(\", \".to_owned())\n        .collect::<String>();\n    assert_eq!(contents_string, \"1, 2, 3\");\n}\n\n#[test]\nfn test_try_fold_specialization_intersperse_err() {\n    let orig_iter = [\"a\", \"b\"].iter().copied().intersperse(\"-\");\n\n    // Abort after the first item.\n    let mut iter = orig_iter.clone();\n    iter.try_for_each(|_| None::<()>);\n    assert_eq!(iter.next(), Some(\"-\"));\n    assert_eq!(iter.next(), Some(\"b\"));\n    assert_eq!(iter.next(), None);\n\n    // Abort after the second item.\n    let mut iter = orig_iter.clone();\n    iter.try_for_each(|item| if item == \"-\" { None } else { Some(()) });\n    assert_eq!(iter.next(), Some(\"b\"));\n    assert_eq!(iter.next(), None);\n\n    // Abort after the third item.\n    let mut iter = orig_iter.clone();\n    iter.try_for_each(|item| if item == \"b\" { None } else { Some(()) });\n    assert_eq!(iter.next(), None);\n}\n"],[2986,"mod chain;\nmod cloned;\nmod copied;\nmod cycle;\nmod enumerate;\nmod filter;\nmod filter_map;\nmod flat_map;\nmod flatten;\nmod fuse;\nmod inspect;\nmod intersperse;\nmod map;\nmod peekable;\nmod scan;\nmod skip;\nmod skip_while;\nmod step_by;\nmod take;\nmod take_while;\nmod zip;\n\nuse core::cell::Cell;\n\n/// An iterator that panics whenever `next` or next_back` is called\n/// after `None` has already been returned. This does not violate\n/// `Iterator`'s contract. Used to test that iterator adaptors don't\n/// poll their inner iterators after exhausting them.\npub struct NonFused<I> {\n    iter: I,\n    done: bool,\n}\n\nimpl<I> NonFused<I> {\n    pub fn new(iter: I) -> Self {\n        Self { iter, done: false }\n    }\n}\n\nimpl<I> Iterator for NonFused<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        assert!(!self.done, \"this iterator has already returned None\");\n        self.iter.next().or_else(|| {\n            self.done = true;\n            None\n        })\n    }\n}\n\nimpl<I> DoubleEndedIterator for NonFused<I>\nwhere\n    I: DoubleEndedIterator,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        assert!(!self.done, \"this iterator has already returned None\");\n        self.iter.next_back().or_else(|| {\n            self.done = true;\n            None\n        })\n    }\n}\n\n/// An iterator wrapper that panics whenever `next` or `next_back` is called\n/// after `None` has been returned.\npub struct Unfuse<I> {\n    iter: I,\n    exhausted: bool,\n}\n\nimpl<I> Unfuse<I> {\n    pub fn new<T>(iter: T) -> Self\n    where\n        T: IntoIterator<IntoIter = I>,\n    {\n        Self { iter: iter.into_iter(), exhausted: false }\n    }\n}\n\nimpl<I> Iterator for Unfuse<I>\nwhere\n    I: Iterator,\n{\n    type Item = I::Item;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        assert!(!self.exhausted);\n        let next = self.iter.next();\n        self.exhausted = next.is_none();\n        next\n    }\n}\n\nimpl<I> DoubleEndedIterator for Unfuse<I>\nwhere\n    I: DoubleEndedIterator,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        assert!(!self.exhausted);\n        let next = self.iter.next_back();\n        self.exhausted = next.is_none();\n        next\n    }\n}\n\npub struct Toggle {\n    is_empty: bool,\n}\n\nimpl Iterator for Toggle {\n    type Item = ();\n\n    // alternates between `None` and `Some(())`\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.is_empty {\n            self.is_empty = false;\n            None\n        } else {\n            self.is_empty = true;\n            Some(())\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.is_empty { (0, Some(0)) } else { (1, Some(1)) }\n    }\n}\n\nimpl DoubleEndedIterator for Toggle {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.next()\n    }\n}\n\n/// This is an iterator that follows the Iterator contract,\n/// but it is not fused. After having returned None once, it will start\n/// producing elements if .next() is called again.\npub struct CycleIter<'a, T> {\n    index: usize,\n    data: &'a [T],\n}\n\nimpl<'a, T> CycleIter<'a, T> {\n    pub fn new(data: &'a [T]) -> Self {\n        Self { index: 0, data }\n    }\n}\n\nimpl<'a, T> Iterator for CycleIter<'a, T> {\n    type Item = &'a T;\n    fn next(&mut self) -> Option<Self::Item> {\n        let elt = self.data.get(self.index);\n        self.index += 1;\n        self.index %= 1 + self.data.len();\n        elt\n    }\n}\n\n#[derive(Debug)]\nstruct CountClone(Cell<i32>);\n\nimpl CountClone {\n    pub fn new() -> Self {\n        Self(Cell::new(0))\n    }\n}\n\nimpl PartialEq<i32> for CountClone {\n    fn eq(&self, rhs: &i32) -> bool {\n        self.0.get() == *rhs\n    }\n}\n\nimpl Clone for CountClone {\n    fn clone(&self) -> Self {\n        let ret = CountClone(self.0.clone());\n        let n = self.0.get();\n        self.0.set(n + 1);\n        ret\n    }\n}\n"],[2987,"use core::iter::*;\n\n#[test]\nfn test_iterator_skip_while() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n    let ys = [15, 16, 17, 19];\n    let it = xs.iter().skip_while(|&x| *x < 15);\n    let mut i = 0;\n    for x in it {\n        assert_eq!(*x, ys[i]);\n        i += 1;\n    }\n    assert_eq!(i, ys.len());\n}\n\n#[test]\nfn test_iterator_skip_while_fold() {\n    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n    let ys = [15, 16, 17, 19];\n    let it = xs.iter().skip_while(|&x| *x < 15);\n    let i = it.fold(0, |i, &x| {\n        assert_eq!(x, ys[i]);\n        i + 1\n    });\n    assert_eq!(i, ys.len());\n\n    let mut it = xs.iter().skip_while(|&x| *x < 15);\n    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n    let i = it.fold(1, |i, &x| {\n        assert_eq!(x, ys[i]);\n        i + 1\n    });\n    assert_eq!(i, ys.len());\n}\n\n#[test]\nfn test_skip_while_try_fold() {\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    fn p(&x: &i32) -> bool {\n        (x % 10) <= 5\n    }\n    assert_eq!((1..20).skip_while(p).try_fold(7, f), (6..20).try_fold(7, f));\n    let mut iter = (1..20).skip_while(p);\n    assert_eq!(iter.nth(5), Some(11));\n    assert_eq!(iter.try_fold(7, f), (12..20).try_fold(7, f));\n\n    let mut iter = (0..50).skip_while(|&x| (x % 20) < 15);\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.next(), Some(23));\n}\n"],[2988,"use core::iter::*;\n\n#[test]\nfn test_map_try_folds() {\n    let f = &|acc, x| i32::checked_add(2 * acc, x);\n    assert_eq!((0..10).map(|x| x + 3).try_fold(7, f), (3..13).try_fold(7, f));\n    assert_eq!((0..10).map(|x| x + 3).try_rfold(7, f), (3..13).try_rfold(7, f));\n\n    let mut iter = (0..40).map(|x| x + 10);\n    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n    assert_eq!(iter.next(), Some(20));\n    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n    assert_eq!(iter.next_back(), Some(46));\n}\n\n#[test]\nfn test_double_ended_map() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut it = xs.iter().map(|&x| x * -1);\n    assert_eq!(it.next(), Some(-1));\n    assert_eq!(it.next(), Some(-2));\n    assert_eq!(it.next_back(), Some(-6));\n    assert_eq!(it.next_back(), Some(-5));\n    assert_eq!(it.next(), Some(-3));\n    assert_eq!(it.next_back(), Some(-4));\n    assert_eq!(it.next(), None);\n}\n"],[2989,"use core::cell::Cell;\nuse core::cmp::Ordering;\nuse core::result::Result::{Err, Ok};\n\n#[test]\nfn test_position() {\n    let b = [1, 2, 3, 5, 5];\n    assert_eq!(b.iter().position(|&v| v == 9), None);\n    assert_eq!(b.iter().position(|&v| v == 5), Some(3));\n    assert_eq!(b.iter().position(|&v| v == 3), Some(2));\n    assert_eq!(b.iter().position(|&v| v == 0), None);\n}\n\n#[test]\nfn test_rposition() {\n    let b = [1, 2, 3, 5, 5];\n    assert_eq!(b.iter().rposition(|&v| v == 9), None);\n    assert_eq!(b.iter().rposition(|&v| v == 5), Some(4));\n    assert_eq!(b.iter().rposition(|&v| v == 3), Some(2));\n    assert_eq!(b.iter().rposition(|&v| v == 0), None);\n}\n\n#[test]\nfn test_binary_search() {\n    let b: [i32; 0] = [];\n    assert_eq!(b.binary_search(&5), Err(0));\n\n    let b = [4];\n    assert_eq!(b.binary_search(&3), Err(0));\n    assert_eq!(b.binary_search(&4), Ok(0));\n    assert_eq!(b.binary_search(&5), Err(1));\n\n    let b = [1, 2, 4, 6, 8, 9];\n    assert_eq!(b.binary_search(&5), Err(3));\n    assert_eq!(b.binary_search(&6), Ok(3));\n    assert_eq!(b.binary_search(&7), Err(4));\n    assert_eq!(b.binary_search(&8), Ok(4));\n\n    let b = [1, 2, 4, 5, 6, 8];\n    assert_eq!(b.binary_search(&9), Err(6));\n\n    let b = [1, 2, 4, 6, 7, 8, 9];\n    assert_eq!(b.binary_search(&6), Ok(3));\n    assert_eq!(b.binary_search(&5), Err(3));\n    assert_eq!(b.binary_search(&8), Ok(5));\n\n    let b = [1, 2, 4, 5, 6, 8, 9];\n    assert_eq!(b.binary_search(&7), Err(5));\n    assert_eq!(b.binary_search(&0), Err(0));\n\n    let b = [1, 3, 3, 3, 7];\n    assert_eq!(b.binary_search(&0), Err(0));\n    assert_eq!(b.binary_search(&1), Ok(0));\n    assert_eq!(b.binary_search(&2), Err(1));\n    assert!(match b.binary_search(&3) {\n        Ok(1..=3) => true,\n        _ => false,\n    });\n    assert!(match b.binary_search(&3) {\n        Ok(1..=3) => true,\n        _ => false,\n    });\n    assert_eq!(b.binary_search(&4), Err(4));\n    assert_eq!(b.binary_search(&5), Err(4));\n    assert_eq!(b.binary_search(&6), Err(4));\n    assert_eq!(b.binary_search(&7), Ok(4));\n    assert_eq!(b.binary_search(&8), Err(5));\n\n    let b = [(); usize::MAX];\n    assert_eq!(b.binary_search(&()), Ok(usize::MAX / 2));\n}\n\n#[test]\nfn test_binary_search_by_overflow() {\n    let b = [(); usize::MAX];\n    assert_eq!(b.binary_search_by(|_| Ordering::Equal), Ok(usize::MAX / 2));\n    assert_eq!(b.binary_search_by(|_| Ordering::Greater), Err(0));\n    assert_eq!(b.binary_search_by(|_| Ordering::Less), Err(usize::MAX));\n}\n\n#[test]\n// Test implementation specific behavior when finding equivalent elements.\n// It is ok to break this test but when you do a crater run is highly advisable.\nfn test_binary_search_implementation_details() {\n    let b = [1, 1, 2, 2, 3, 3, 3];\n    assert_eq!(b.binary_search(&1), Ok(1));\n    assert_eq!(b.binary_search(&2), Ok(3));\n    assert_eq!(b.binary_search(&3), Ok(5));\n    let b = [1, 1, 1, 1, 1, 3, 3, 3, 3];\n    assert_eq!(b.binary_search(&1), Ok(4));\n    assert_eq!(b.binary_search(&3), Ok(7));\n    let b = [1, 1, 1, 1, 3, 3, 3, 3, 3];\n    assert_eq!(b.binary_search(&1), Ok(2));\n    assert_eq!(b.binary_search(&3), Ok(4));\n}\n\n#[test]\nfn test_partition_point() {\n    let b: [i32; 0] = [];\n    assert_eq!(b.partition_point(|&x| x < 5), 0);\n\n    let b = [4];\n    assert_eq!(b.partition_point(|&x| x < 3), 0);\n    assert_eq!(b.partition_point(|&x| x < 4), 0);\n    assert_eq!(b.partition_point(|&x| x < 5), 1);\n\n    let b = [1, 2, 4, 6, 8, 9];\n    assert_eq!(b.partition_point(|&x| x < 5), 3);\n    assert_eq!(b.partition_point(|&x| x < 6), 3);\n    assert_eq!(b.partition_point(|&x| x < 7), 4);\n    assert_eq!(b.partition_point(|&x| x < 8), 4);\n\n    let b = [1, 2, 4, 5, 6, 8];\n    assert_eq!(b.partition_point(|&x| x < 9), 6);\n\n    let b = [1, 2, 4, 6, 7, 8, 9];\n    assert_eq!(b.partition_point(|&x| x < 6), 3);\n    assert_eq!(b.partition_point(|&x| x < 5), 3);\n    assert_eq!(b.partition_point(|&x| x < 8), 5);\n\n    let b = [1, 2, 4, 5, 6, 8, 9];\n    assert_eq!(b.partition_point(|&x| x < 7), 5);\n    assert_eq!(b.partition_point(|&x| x < 0), 0);\n\n    let b = [1, 3, 3, 3, 7];\n    assert_eq!(b.partition_point(|&x| x < 0), 0);\n    assert_eq!(b.partition_point(|&x| x < 1), 0);\n    assert_eq!(b.partition_point(|&x| x < 2), 1);\n    assert_eq!(b.partition_point(|&x| x < 3), 1);\n    assert_eq!(b.partition_point(|&x| x < 4), 4);\n    assert_eq!(b.partition_point(|&x| x < 5), 4);\n    assert_eq!(b.partition_point(|&x| x < 6), 4);\n    assert_eq!(b.partition_point(|&x| x < 7), 4);\n    assert_eq!(b.partition_point(|&x| x < 8), 5);\n}\n\n#[test]\nfn test_iterator_nth() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n    for i in 0..v.len() {\n        assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n    }\n    assert_eq!(v.iter().nth(v.len()), None);\n\n    let mut iter = v.iter();\n    assert_eq!(iter.nth(2).unwrap(), &v[2]);\n    assert_eq!(iter.nth(1).unwrap(), &v[4]);\n}\n\n#[test]\nfn test_iterator_nth_back() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n    for i in 0..v.len() {\n        assert_eq!(v.iter().nth_back(i).unwrap(), &v[v.len() - i - 1]);\n    }\n    assert_eq!(v.iter().nth_back(v.len()), None);\n\n    let mut iter = v.iter();\n    assert_eq!(iter.nth_back(2).unwrap(), &v[2]);\n    assert_eq!(iter.nth_back(1).unwrap(), &v[0]);\n}\n\n#[test]\nfn test_iterator_last() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n    assert_eq!(v.iter().last().unwrap(), &4);\n    assert_eq!(v[..1].iter().last().unwrap(), &0);\n}\n\n#[test]\nfn test_iterator_count() {\n    let v: &[_] = &[0, 1, 2, 3, 4];\n    assert_eq!(v.iter().count(), 5);\n\n    let mut iter2 = v.iter();\n    iter2.next();\n    iter2.next();\n    assert_eq!(iter2.count(), 3);\n}\n\n#[test]\nfn test_chunks_count() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.chunks(3);\n    assert_eq!(c.count(), 2);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.chunks(2);\n    assert_eq!(c2.count(), 3);\n\n    let v3: &[i32] = &[];\n    let c3 = v3.chunks(2);\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_chunks_nth() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.chunks(2);\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[4, 5]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c2 = v2.chunks(3);\n    assert_eq!(c2.nth(1).unwrap(), &[3, 4]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_chunks_nth_back() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.chunks(2);\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n    assert_eq!(c.next(), None);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c2 = v2.chunks(3);\n    assert_eq!(c2.nth_back(1).unwrap(), &[0, 1, 2]);\n    assert_eq!(c2.next(), None);\n    assert_eq!(c2.next_back(), None);\n\n    let v3: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c3 = v3.chunks(10);\n    assert_eq!(c3.nth_back(0).unwrap(), &[0, 1, 2, 3, 4]);\n    assert_eq!(c3.next(), None);\n\n    let v4: &[i32] = &[0, 1, 2];\n    let mut c4 = v4.chunks(10);\n    assert_eq!(c4.nth_back(1_000_000_000usize), None);\n}\n\n#[test]\nfn test_chunks_last() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.chunks(2);\n    assert_eq!(c.last().unwrap()[1], 5);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.chunks(2);\n    assert_eq!(c2.last().unwrap()[0], 4);\n}\n\n#[test]\nfn test_chunks_zip() {\n    let v1: &[i32] = &[0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    let res = v1\n        .chunks(2)\n        .zip(v2.chunks(2))\n        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n        .collect::<Vec<_>>();\n    assert_eq!(res, vec![14, 22, 14]);\n}\n\n#[test]\nfn test_chunks_mut_count() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.chunks_mut(3);\n    assert_eq!(c.count(), 2);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.chunks_mut(2);\n    assert_eq!(c2.count(), 3);\n\n    let v3: &mut [i32] = &mut [];\n    let c3 = v3.chunks_mut(2);\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_chunks_mut_nth() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.chunks_mut(2);\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[4, 5]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let mut c2 = v2.chunks_mut(3);\n    assert_eq!(c2.nth(1).unwrap(), &[3, 4]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_chunks_mut_nth_back() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.chunks_mut(2);\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n\n    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let mut c1 = v1.chunks_mut(3);\n    assert_eq!(c1.nth_back(1).unwrap(), &[0, 1, 2]);\n    assert_eq!(c1.next(), None);\n\n    let v3: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let mut c3 = v3.chunks_mut(10);\n    assert_eq!(c3.nth_back(0).unwrap(), &[0, 1, 2, 3, 4]);\n    assert_eq!(c3.next(), None);\n\n    let v4: &mut [i32] = &mut [0, 1, 2];\n    let mut c4 = v4.chunks_mut(10);\n    assert_eq!(c4.nth_back(1_000_000_000usize), None);\n}\n\n#[test]\nfn test_chunks_mut_last() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.chunks_mut(2);\n    assert_eq!(c.last().unwrap(), &[4, 5]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.chunks_mut(2);\n    assert_eq!(c2.last().unwrap(), &[4]);\n}\n\n#[test]\nfn test_chunks_mut_zip() {\n    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    for (a, b) in v1.chunks_mut(2).zip(v2.chunks(2)) {\n        let sum = b.iter().sum::<i32>();\n        for v in a {\n            *v += sum;\n        }\n    }\n    assert_eq!(v1, [13, 14, 19, 20, 14]);\n}\n\n#[test]\nfn test_chunks_exact_count() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.chunks_exact(3);\n    assert_eq!(c.count(), 2);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.chunks_exact(2);\n    assert_eq!(c2.count(), 2);\n\n    let v3: &[i32] = &[];\n    let c3 = v3.chunks_exact(2);\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_chunks_exact_nth() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.chunks_exact(2);\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[4, 5]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n    let mut c2 = v2.chunks_exact(3);\n    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_chunks_exact_nth_back() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.chunks_exact(2);\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n    assert_eq!(c.next(), None);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c2 = v2.chunks_exact(3);\n    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n    assert_eq!(c2.next(), None);\n    assert_eq!(c2.next_back(), None);\n\n    let v3: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c3 = v3.chunks_exact(10);\n    assert_eq!(c3.nth_back(0), None);\n}\n\n#[test]\nfn test_chunks_exact_last() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.chunks_exact(2);\n    assert_eq!(c.last().unwrap(), &[4, 5]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.chunks_exact(2);\n    assert_eq!(c2.last().unwrap(), &[2, 3]);\n}\n\n#[test]\nfn test_chunks_exact_remainder() {\n    let v: &[i32] = &[0, 1, 2, 3, 4];\n    let c = v.chunks_exact(2);\n    assert_eq!(c.remainder(), &[4]);\n}\n\n#[test]\nfn test_chunks_exact_zip() {\n    let v1: &[i32] = &[0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    let res = v1\n        .chunks_exact(2)\n        .zip(v2.chunks_exact(2))\n        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n        .collect::<Vec<_>>();\n    assert_eq!(res, vec![14, 22]);\n}\n\n#[test]\nfn test_chunks_exact_mut_count() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.chunks_exact_mut(3);\n    assert_eq!(c.count(), 2);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.chunks_exact_mut(2);\n    assert_eq!(c2.count(), 2);\n\n    let v3: &mut [i32] = &mut [];\n    let c3 = v3.chunks_exact_mut(2);\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_chunks_exact_mut_nth() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.chunks_exact_mut(2);\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[4, 5]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n    let mut c2 = v2.chunks_exact_mut(3);\n    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_chunks_exact_mut_nth_back() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.chunks_exact_mut(2);\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n    assert_eq!(c.next(), None);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let mut c2 = v2.chunks_exact_mut(3);\n    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n    assert_eq!(c2.next(), None);\n    assert_eq!(c2.next_back(), None);\n\n    let v3: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let mut c3 = v3.chunks_exact_mut(10);\n    assert_eq!(c3.nth_back(0), None);\n}\n\n#[test]\nfn test_chunks_exact_mut_last() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.chunks_exact_mut(2);\n    assert_eq!(c.last().unwrap(), &[4, 5]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.chunks_exact_mut(2);\n    assert_eq!(c2.last().unwrap(), &[2, 3]);\n}\n\n#[test]\nfn test_chunks_exact_mut_remainder() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c = v.chunks_exact_mut(2);\n    assert_eq!(c.into_remainder(), &[4]);\n}\n\n#[test]\nfn test_chunks_exact_mut_zip() {\n    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    for (a, b) in v1.chunks_exact_mut(2).zip(v2.chunks_exact(2)) {\n        let sum = b.iter().sum::<i32>();\n        for v in a {\n            *v += sum;\n        }\n    }\n    assert_eq!(v1, [13, 14, 19, 20, 4]);\n}\n\n#[test]\nfn test_array_chunks_infer() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, -4];\n    let c = v.array_chunks();\n    for &[a, b, c] in c {\n        assert_eq!(a + b + c, 3);\n    }\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n    let total = v2.array_chunks().map(|&[a, b]| a * b).sum::<i32>();\n    assert_eq!(total, 2 * 3 + 4 * 5);\n}\n\n#[test]\nfn test_array_chunks_count() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.array_chunks::<3>();\n    assert_eq!(c.count(), 2);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.array_chunks::<2>();\n    assert_eq!(c2.count(), 2);\n\n    let v3: &[i32] = &[];\n    let c3 = v3.array_chunks::<2>();\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_array_chunks_nth() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.array_chunks::<2>();\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[4, 5]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n    let mut c2 = v2.array_chunks::<3>();\n    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_array_chunks_nth_back() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.array_chunks::<2>();\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n    assert_eq!(c.next(), None);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c2 = v2.array_chunks::<3>();\n    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n    assert_eq!(c2.next(), None);\n    assert_eq!(c2.next_back(), None);\n\n    let v3: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c3 = v3.array_chunks::<10>();\n    assert_eq!(c3.nth_back(0), None);\n}\n\n#[test]\nfn test_array_chunks_last() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.array_chunks::<2>();\n    assert_eq!(c.last().unwrap(), &[4, 5]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.array_chunks::<2>();\n    assert_eq!(c2.last().unwrap(), &[2, 3]);\n}\n\n#[test]\nfn test_array_chunks_remainder() {\n    let v: &[i32] = &[0, 1, 2, 3, 4];\n    let c = v.array_chunks::<2>();\n    assert_eq!(c.remainder(), &[4]);\n}\n\n#[test]\nfn test_array_chunks_zip() {\n    let v1: &[i32] = &[0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    let res = v1\n        .array_chunks::<2>()\n        .zip(v2.array_chunks::<2>())\n        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n        .collect::<Vec<_>>();\n    assert_eq!(res, vec![14, 22]);\n}\n\n#[test]\nfn test_array_chunks_mut_infer() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n    for a in v.array_chunks_mut() {\n        let sum = a.iter().sum::<i32>();\n        *a = [sum; 3];\n    }\n    assert_eq!(v, &[3, 3, 3, 12, 12, 12, 6]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n    v2.array_chunks_mut().for_each(|[a, b]| core::mem::swap(a, b));\n    assert_eq!(v2, &[1, 0, 3, 2, 5, 4, 6]);\n}\n\n#[test]\nfn test_array_chunks_mut_count() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.array_chunks_mut::<3>();\n    assert_eq!(c.count(), 2);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.array_chunks_mut::<2>();\n    assert_eq!(c2.count(), 2);\n\n    let v3: &mut [i32] = &mut [];\n    let c3 = v3.array_chunks_mut::<2>();\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_array_chunks_mut_nth() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.array_chunks_mut::<2>();\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[4, 5]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n    let mut c2 = v2.array_chunks_mut::<3>();\n    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_array_chunks_mut_nth_back() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.array_chunks_mut::<2>();\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n    assert_eq!(c.next(), None);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let mut c2 = v2.array_chunks_mut::<3>();\n    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n    assert_eq!(c2.next(), None);\n    assert_eq!(c2.next_back(), None);\n\n    let v3: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let mut c3 = v3.array_chunks_mut::<10>();\n    assert_eq!(c3.nth_back(0), None);\n}\n\n#[test]\nfn test_array_chunks_mut_last() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.array_chunks_mut::<2>();\n    assert_eq!(c.last().unwrap(), &[4, 5]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.array_chunks_mut::<2>();\n    assert_eq!(c2.last().unwrap(), &[2, 3]);\n}\n\n#[test]\nfn test_array_chunks_mut_remainder() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c = v.array_chunks_mut::<2>();\n    assert_eq!(c.into_remainder(), &[4]);\n}\n\n#[test]\nfn test_array_chunks_mut_zip() {\n    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    for (a, b) in v1.array_chunks_mut::<2>().zip(v2.array_chunks::<2>()) {\n        let sum = b.iter().sum::<i32>();\n        for v in a {\n            *v += sum;\n        }\n    }\n    assert_eq!(v1, [13, 14, 19, 20, 4]);\n}\n\n#[test]\nfn test_array_windows_infer() {\n    let v: &[i32] = &[0, 1, 0, 1];\n    assert_eq!(v.array_windows::<2>().count(), 3);\n    let c = v.array_windows();\n    for &[a, b] in c {\n        assert_eq!(a + b, 1);\n    }\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n    let total = v2.array_windows().map(|&[a, b, c]| a + b + c).sum::<i32>();\n    assert_eq!(total, 3 + 6 + 9 + 12 + 15);\n}\n\n#[test]\nfn test_array_windows_count() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.array_windows::<3>();\n    assert_eq!(c.count(), 4);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.array_windows::<6>();\n    assert_eq!(c2.count(), 0);\n\n    let v3: &[i32] = &[];\n    let c3 = v3.array_windows::<2>();\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_array_windows_nth() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let snd = v.array_windows::<4>().nth(1);\n    assert_eq!(snd, Some(&[1, 2, 3, 4]));\n    let mut arr_windows = v.array_windows::<2>();\n    assert_ne!(arr_windows.nth(0), arr_windows.nth(0));\n    let last = v.array_windows::<3>().last();\n    assert_eq!(last, Some(&[3, 4, 5]));\n}\n\n#[test]\nfn test_array_windows_nth_back() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let snd = v.array_windows::<4>().nth_back(1);\n    assert_eq!(snd, Some(&[1, 2, 3, 4]));\n    let mut arr_windows = v.array_windows::<2>();\n    assert_ne!(arr_windows.nth_back(0), arr_windows.nth_back(0));\n}\n\n#[test]\nfn test_rchunks_count() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.rchunks(3);\n    assert_eq!(c.count(), 2);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.rchunks(2);\n    assert_eq!(c2.count(), 3);\n\n    let v3: &[i32] = &[];\n    let c3 = v3.rchunks(2);\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_rchunks_nth() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.rchunks(2);\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c2 = v2.rchunks(3);\n    assert_eq!(c2.nth(1).unwrap(), &[0, 1]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_rchunks_nth_back() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.rchunks(2);\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c2 = v2.rchunks(3);\n    assert_eq!(c2.nth_back(1).unwrap(), &[2, 3, 4]);\n    assert_eq!(c2.next_back(), None);\n}\n\n#[test]\nfn test_rchunks_last() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.rchunks(2);\n    assert_eq!(c.last().unwrap()[1], 1);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.rchunks(2);\n    assert_eq!(c2.last().unwrap()[0], 0);\n}\n\n#[test]\nfn test_rchunks_zip() {\n    let v1: &[i32] = &[0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    let res = v1\n        .rchunks(2)\n        .zip(v2.rchunks(2))\n        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n        .collect::<Vec<_>>();\n    assert_eq!(res, vec![26, 18, 6]);\n}\n\n#[test]\nfn test_rchunks_mut_count() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.rchunks_mut(3);\n    assert_eq!(c.count(), 2);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.rchunks_mut(2);\n    assert_eq!(c2.count(), 3);\n\n    let v3: &mut [i32] = &mut [];\n    let c3 = v3.rchunks_mut(2);\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_rchunks_mut_nth() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.rchunks_mut(2);\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let mut c2 = v2.rchunks_mut(3);\n    assert_eq!(c2.nth(1).unwrap(), &[0, 1]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_rchunks_mut_nth_back() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.rchunks_mut(2);\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let mut c2 = v2.rchunks_mut(3);\n    assert_eq!(c2.nth_back(1).unwrap(), &[2, 3, 4]);\n    assert_eq!(c2.next_back(), None);\n}\n\n#[test]\nfn test_rchunks_mut_last() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.rchunks_mut(2);\n    assert_eq!(c.last().unwrap(), &[0, 1]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.rchunks_mut(2);\n    assert_eq!(c2.last().unwrap(), &[0]);\n}\n\n#[test]\nfn test_rchunks_mut_zip() {\n    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    for (a, b) in v1.rchunks_mut(2).zip(v2.rchunks(2)) {\n        let sum = b.iter().sum::<i32>();\n        for v in a {\n            *v += sum;\n        }\n    }\n    assert_eq!(v1, [6, 16, 17, 22, 23]);\n}\n\n#[test]\nfn test_rchunks_exact_count() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.rchunks_exact(3);\n    assert_eq!(c.count(), 2);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.rchunks_exact(2);\n    assert_eq!(c2.count(), 2);\n\n    let v3: &[i32] = &[];\n    let c3 = v3.rchunks_exact(2);\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_rchunks_exact_nth() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.rchunks_exact(2);\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n    let mut c2 = v2.rchunks_exact(3);\n    assert_eq!(c2.nth(1).unwrap(), &[1, 2, 3]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_rchunks_exact_nth_back() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.rchunks_exact(2);\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n    let mut c2 = v2.rchunks_exact(3);\n    assert_eq!(c2.nth_back(1).unwrap(), &[4, 5, 6]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_rchunks_exact_last() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.rchunks_exact(2);\n    assert_eq!(c.last().unwrap(), &[0, 1]);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.rchunks_exact(2);\n    assert_eq!(c2.last().unwrap(), &[1, 2]);\n}\n\n#[test]\nfn test_rchunks_exact_remainder() {\n    let v: &[i32] = &[0, 1, 2, 3, 4];\n    let c = v.rchunks_exact(2);\n    assert_eq!(c.remainder(), &[0]);\n}\n\n#[test]\nfn test_rchunks_exact_zip() {\n    let v1: &[i32] = &[0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    let res = v1\n        .rchunks_exact(2)\n        .zip(v2.rchunks_exact(2))\n        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n        .collect::<Vec<_>>();\n    assert_eq!(res, vec![26, 18]);\n}\n\n#[test]\nfn test_rchunks_exact_mut_count() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.rchunks_exact_mut(3);\n    assert_eq!(c.count(), 2);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.rchunks_exact_mut(2);\n    assert_eq!(c2.count(), 2);\n\n    let v3: &mut [i32] = &mut [];\n    let c3 = v3.rchunks_exact_mut(2);\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_rchunks_exact_mut_nth() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.rchunks_exact_mut(2);\n    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next().unwrap(), &[0, 1]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n    let mut c2 = v2.rchunks_exact_mut(3);\n    assert_eq!(c2.nth(1).unwrap(), &[1, 2, 3]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_rchunks_exact_mut_nth_back() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let mut c = v.rchunks_exact_mut(2);\n    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n    let mut c2 = v2.rchunks_exact_mut(3);\n    assert_eq!(c2.nth_back(1).unwrap(), &[4, 5, 6]);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_rchunks_exact_mut_last() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n    let c = v.rchunks_exact_mut(2);\n    assert_eq!(c.last().unwrap(), &[0, 1]);\n\n    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c2 = v2.rchunks_exact_mut(2);\n    assert_eq!(c2.last().unwrap(), &[1, 2]);\n}\n\n#[test]\nfn test_rchunks_exact_mut_remainder() {\n    let v: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let c = v.rchunks_exact_mut(2);\n    assert_eq!(c.into_remainder(), &[0]);\n}\n\n#[test]\nfn test_rchunks_exact_mut_zip() {\n    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    for (a, b) in v1.rchunks_exact_mut(2).zip(v2.rchunks_exact(2)) {\n        let sum = b.iter().sum::<i32>();\n        for v in a {\n            *v += sum;\n        }\n    }\n    assert_eq!(v1, [0, 16, 17, 22, 23]);\n}\n\n#[test]\nfn test_windows_count() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.windows(3);\n    assert_eq!(c.count(), 4);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.windows(6);\n    assert_eq!(c2.count(), 0);\n\n    let v3: &[i32] = &[];\n    let c3 = v3.windows(2);\n    assert_eq!(c3.count(), 0);\n}\n\n#[test]\nfn test_windows_nth() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.windows(2);\n    assert_eq!(c.nth(2).unwrap()[1], 3);\n    assert_eq!(c.next().unwrap()[0], 3);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c2 = v2.windows(4);\n    assert_eq!(c2.nth(1).unwrap()[1], 2);\n    assert_eq!(c2.next(), None);\n}\n\n#[test]\nfn test_windows_nth_back() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let mut c = v.windows(2);\n    assert_eq!(c.nth_back(2).unwrap()[0], 2);\n    assert_eq!(c.next_back().unwrap()[1], 2);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let mut c2 = v2.windows(4);\n    assert_eq!(c2.nth_back(1).unwrap()[1], 1);\n    assert_eq!(c2.next_back(), None);\n}\n\n#[test]\nfn test_windows_last() {\n    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n    let c = v.windows(2);\n    assert_eq!(c.last().unwrap()[1], 5);\n\n    let v2: &[i32] = &[0, 1, 2, 3, 4];\n    let c2 = v2.windows(2);\n    assert_eq!(c2.last().unwrap()[0], 3);\n}\n\n#[test]\nfn test_windows_zip() {\n    let v1: &[i32] = &[0, 1, 2, 3, 4];\n    let v2: &[i32] = &[6, 7, 8, 9, 10];\n\n    let res = v1\n        .windows(2)\n        .zip(v2.windows(2))\n        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n        .collect::<Vec<_>>();\n\n    assert_eq!(res, [14, 18, 22, 26]);\n}\n\n#[test]\n#[allow(const_err)]\nfn test_iter_ref_consistency() {\n    use std::fmt::Debug;\n\n    fn test<T: Copy + Debug + PartialEq>(x: T) {\n        let v: &[T] = &[x, x, x];\n        let v_ptrs: [*const T; 3] = match v {\n            [ref v1, ref v2, ref v3] => [v1 as *const _, v2 as *const _, v3 as *const _],\n            _ => unreachable!(),\n        };\n        let len = v.len();\n\n        // nth(i)\n        for i in 0..len {\n            assert_eq!(&v[i] as *const _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n            let nth = v.iter().nth(i).unwrap();\n            assert_eq!(nth as *const _, v_ptrs[i]);\n        }\n        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n\n        // stepping through with nth(0)\n        {\n            let mut it = v.iter();\n            for i in 0..len {\n                let next = it.nth(0).unwrap();\n                assert_eq!(next as *const _, v_ptrs[i]);\n            }\n            assert_eq!(it.nth(0), None);\n        }\n\n        // next()\n        {\n            let mut it = v.iter();\n            for i in 0..len {\n                let remaining = len - i;\n                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n\n                let next = it.next().unwrap();\n                assert_eq!(next as *const _, v_ptrs[i]);\n            }\n            assert_eq!(it.size_hint(), (0, Some(0)));\n            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n        }\n\n        // next_back()\n        {\n            let mut it = v.iter();\n            for i in 0..len {\n                let remaining = len - i;\n                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n\n                let prev = it.next_back().unwrap();\n                assert_eq!(prev as *const _, v_ptrs[remaining - 1]);\n            }\n            assert_eq!(it.size_hint(), (0, Some(0)));\n            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n        }\n    }\n\n    fn test_mut<T: Copy + Debug + PartialEq>(x: T) {\n        let v: &mut [T] = &mut [x, x, x];\n        let v_ptrs: [*mut T; 3] = match v {\n            [ref v1, ref v2, ref v3] => {\n                [v1 as *const _ as *mut _, v2 as *const _ as *mut _, v3 as *const _ as *mut _]\n            }\n            _ => unreachable!(),\n        };\n        let len = v.len();\n\n        // nth(i)\n        for i in 0..len {\n            assert_eq!(&mut v[i] as *mut _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n            let nth = v.iter_mut().nth(i).unwrap();\n            assert_eq!(nth as *mut _, v_ptrs[i]);\n        }\n        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n\n        // stepping through with nth(0)\n        {\n            let mut it = v.iter();\n            for i in 0..len {\n                let next = it.nth(0).unwrap();\n                assert_eq!(next as *const _, v_ptrs[i]);\n            }\n            assert_eq!(it.nth(0), None);\n        }\n\n        // next()\n        {\n            let mut it = v.iter_mut();\n            for i in 0..len {\n                let remaining = len - i;\n                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n\n                let next = it.next().unwrap();\n                assert_eq!(next as *mut _, v_ptrs[i]);\n            }\n            assert_eq!(it.size_hint(), (0, Some(0)));\n            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n        }\n\n        // next_back()\n        {\n            let mut it = v.iter_mut();\n            for i in 0..len {\n                let remaining = len - i;\n                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n\n                let prev = it.next_back().unwrap();\n                assert_eq!(prev as *mut _, v_ptrs[remaining - 1]);\n            }\n            assert_eq!(it.size_hint(), (0, Some(0)));\n            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n        }\n    }\n\n    // Make sure iterators and slice patterns yield consistent addresses for various types,\n    // including ZSTs.\n    test(0u32);\n    test(());\n    test([0u32; 0]); // ZST with alignment > 0\n    test_mut(0u32);\n    test_mut(());\n    test_mut([0u32; 0]); // ZST with alignment > 0\n}\n\n// The current implementation of SliceIndex fails to handle methods\n// orthogonally from range types; therefore, it is worth testing\n// all of the indexing operations on each input.\nmod slice_index {\n    // This checks all six indexing methods, given an input range that\n    // should succeed. (it is NOT suitable for testing invalid inputs)\n    macro_rules! assert_range_eq {\n        ($arr:expr, $range:expr, $expected:expr) => {\n            let mut arr = $arr;\n            let mut expected = $expected;\n            {\n                let s: &[_] = &arr;\n                let expected: &[_] = &expected;\n\n                assert_eq!(&s[$range], expected, \"(in assertion for: index)\");\n                assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n                unsafe {\n                    assert_eq!(\n                        s.get_unchecked($range),\n                        expected,\n                        \"(in assertion for: get_unchecked)\",\n                    );\n                }\n            }\n            {\n                let s: &mut [_] = &mut arr;\n                let expected: &mut [_] = &mut expected;\n\n                assert_eq!(&mut s[$range], expected, \"(in assertion for: index_mut)\",);\n                assert_eq!(\n                    s.get_mut($range),\n                    Some(&mut expected[..]),\n                    \"(in assertion for: get_mut)\",\n                );\n                unsafe {\n                    assert_eq!(\n                        s.get_unchecked_mut($range),\n                        expected,\n                        \"(in assertion for: get_unchecked_mut)\",\n                    );\n                }\n            }\n        };\n    }\n\n    // Make sure the macro can actually detect bugs,\n    // because if it can't, then what are we even doing here?\n    //\n    // (Be aware this only demonstrates the ability to detect bugs\n    //  in the FIRST method that panics, as the macro is not designed\n    //  to be used in `should_panic`)\n    #[test]\n    #[should_panic(expected = \"out of range\")]\n    fn assert_range_eq_can_fail_by_panic() {\n        assert_range_eq!([0, 1, 2], 0..5, [0, 1, 2]);\n    }\n\n    // (Be aware this only demonstrates the ability to detect bugs\n    //  in the FIRST method it calls, as the macro is not designed\n    //  to be used in `should_panic`)\n    #[test]\n    #[should_panic(expected = \"==\")]\n    fn assert_range_eq_can_fail_by_inequality() {\n        assert_range_eq!([0, 1, 2], 0..2, [0, 1, 2]);\n    }\n\n    // Test cases for bad index operations.\n    //\n    // This generates `should_panic` test cases for Index/IndexMut\n    // and `None` test cases for get/get_mut.\n    macro_rules! panic_cases {\n        ($(\n            // each test case needs a unique name to namespace the tests\n            in mod $case_name:ident {\n                data: $data:expr;\n\n                // optional:\n                //\n                // one or more similar inputs for which data[input] succeeds,\n                // and the corresponding output as an array.  This helps validate\n                // \"critical points\" where an input range straddles the boundary\n                // between valid and invalid.\n                // (such as the input `len..len`, which is just barely valid)\n                $(\n                    good: data[$good:expr] == $output:expr;\n                )*\n\n                bad: data[$bad:expr];\n                message: $expect_msg:expr;\n            }\n        )*) => {$(\n            mod $case_name {\n                #[allow(unused_imports)]\n                use core::ops::Bound;\n\n                #[test]\n                fn pass() {\n                    let mut v = $data;\n\n                    $( assert_range_eq!($data, $good, $output); )*\n\n                    {\n                        let v: &[_] = &v;\n                        assert_eq!(v.get($bad), None, \"(in None assertion for get)\");\n                    }\n\n                    {\n                        let v: &mut [_] = &mut v;\n                        assert_eq!(v.get_mut($bad), None, \"(in None assertion for get_mut)\");\n                    }\n                }\n\n                #[test]\n                #[should_panic(expected = $expect_msg)]\n                fn index_fail() {\n                    let v = $data;\n                    let v: &[_] = &v;\n                    let _v = &v[$bad];\n                }\n\n                #[test]\n                #[should_panic(expected = $expect_msg)]\n                fn index_mut_fail() {\n                    let mut v = $data;\n                    let v: &mut [_] = &mut v;\n                    let _v = &mut v[$bad];\n                }\n            }\n        )*};\n    }\n\n    #[test]\n    fn simple() {\n        let v = [0, 1, 2, 3, 4, 5];\n\n        assert_range_eq!(v, .., [0, 1, 2, 3, 4, 5]);\n        assert_range_eq!(v, ..2, [0, 1]);\n        assert_range_eq!(v, ..=1, [0, 1]);\n        assert_range_eq!(v, 2.., [2, 3, 4, 5]);\n        assert_range_eq!(v, 1..4, [1, 2, 3]);\n        assert_range_eq!(v, 1..=3, [1, 2, 3]);\n    }\n\n    panic_cases! {\n        in mod rangefrom_len {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[6..] == [];\n            bad: data[7..];\n            message: \"out of range\";\n        }\n\n        in mod rangeto_len {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[..6] == [0, 1, 2, 3, 4, 5];\n            bad: data[..7];\n            message: \"out of range\";\n        }\n\n        in mod rangetoinclusive_len {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[..=5] == [0, 1, 2, 3, 4, 5];\n            bad: data[..=6];\n            message: \"out of range\";\n        }\n\n        in mod rangeinclusive_len {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n            bad: data[0..=6];\n            message: \"out of range\";\n        }\n\n        in mod range_len_len {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[6..6] == [];\n            bad: data[7..7];\n            message: \"out of range\";\n        }\n\n        in mod rangeinclusive_len_len {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[6..=5] == [];\n            bad: data[7..=6];\n            message: \"out of range\";\n        }\n\n        in mod boundpair_len {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[(Bound::Included(6), Bound::Unbounded)] == [];\n            good: data[(Bound::Unbounded, Bound::Included(5))] == [0, 1, 2, 3, 4, 5];\n            good: data[(Bound::Unbounded, Bound::Excluded(6))] == [0, 1, 2, 3, 4, 5];\n            good: data[(Bound::Included(0), Bound::Included(5))] == [0, 1, 2, 3, 4, 5];\n            good: data[(Bound::Included(0), Bound::Excluded(6))] == [0, 1, 2, 3, 4, 5];\n            good: data[(Bound::Included(2), Bound::Excluded(4))] == [2, 3];\n            good: data[(Bound::Excluded(1), Bound::Included(4))] == [2, 3, 4];\n            good: data[(Bound::Excluded(5), Bound::Excluded(6))] == [];\n            good: data[(Bound::Included(6), Bound::Excluded(6))] == [];\n            good: data[(Bound::Excluded(5), Bound::Included(5))] == [];\n            good: data[(Bound::Included(6), Bound::Included(5))] == [];\n            bad: data[(Bound::Unbounded, Bound::Included(6))];\n            message: \"out of range\";\n        }\n    }\n\n    panic_cases! {\n        in mod rangeinclusive_exhausted {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n            good: data[{\n                let mut iter = 0..=5;\n                iter.by_ref().count(); // exhaust it\n                iter\n            }] == [];\n\n            // 0..=6 is out of range before exhaustion, so it\n            // stands to reason that it still would be after.\n            bad: data[{\n                let mut iter = 0..=6;\n                iter.by_ref().count(); // exhaust it\n                iter\n            }];\n            message: \"out of range\";\n        }\n    }\n\n    panic_cases! {\n        in mod range_neg_width {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[4..4] == [];\n            bad: data[4..3];\n            message: \"but ends at\";\n        }\n\n        in mod rangeinclusive_neg_width {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[4..=3] == [];\n            bad: data[4..=2];\n            message: \"but ends at\";\n        }\n\n        in mod boundpair_neg_width {\n            data: [0, 1, 2, 3, 4, 5];\n\n            good: data[(Bound::Included(4), Bound::Excluded(4))] == [];\n            bad: data[(Bound::Included(4), Bound::Excluded(3))];\n            message: \"but ends at\";\n        }\n    }\n\n    panic_cases! {\n        in mod rangeinclusive_overflow {\n            data: [0, 1];\n\n            // note: using 0 specifically ensures that the result of overflowing is 0..0,\n            //       so that `get` doesn't simply return None for the wrong reason.\n            bad: data[0 ..= usize::MAX];\n            message: \"maximum usize\";\n        }\n\n        in mod rangetoinclusive_overflow {\n            data: [0, 1];\n\n            bad: data[..= usize::MAX];\n            message: \"maximum usize\";\n        }\n\n        in mod boundpair_overflow_end {\n            data: [0; 1];\n\n            bad: data[(Bound::Unbounded, Bound::Included(usize::MAX))];\n            message: \"maximum usize\";\n        }\n\n        in mod boundpair_overflow_start {\n            data: [0; 1];\n\n            bad: data[(Bound::Excluded(usize::MAX), Bound::Unbounded)];\n            message: \"maximum usize\";\n        }\n    } // panic_cases!\n}\n\n#[test]\nfn test_find_rfind() {\n    let v = [0, 1, 2, 3, 4, 5];\n    let mut iter = v.iter();\n    let mut i = v.len();\n    while let Some(&elt) = iter.rfind(|_| true) {\n        i -= 1;\n        assert_eq!(elt, v[i]);\n    }\n    assert_eq!(i, 0);\n    assert_eq!(v.iter().rfind(|&&x| x <= 3), Some(&3));\n}\n\n#[test]\nfn test_iter_folds() {\n    let a = [1, 2, 3, 4, 5]; // len>4 so the unroll is used\n    assert_eq!(a.iter().fold(0, |acc, &x| 2 * acc + x), 57);\n    assert_eq!(a.iter().rfold(0, |acc, &x| 2 * acc + x), 129);\n    let fold = |acc: i32, &x| acc.checked_mul(2)?.checked_add(x);\n    assert_eq!(a.iter().try_fold(0, &fold), Some(57));\n    assert_eq!(a.iter().try_rfold(0, &fold), Some(129));\n\n    // short-circuiting try_fold, through other methods\n    let a = [0, 1, 2, 3, 5, 5, 5, 7, 8, 9];\n    let mut iter = a.iter();\n    assert_eq!(iter.position(|&x| x == 3), Some(3));\n    assert_eq!(iter.rfind(|&&x| x == 5), Some(&5));\n    assert_eq!(iter.len(), 2);\n}\n\n#[test]\nfn test_rotate_left() {\n    const N: usize = 600;\n    let a: &mut [_] = &mut [0; N];\n    for i in 0..N {\n        a[i] = i;\n    }\n\n    a.rotate_left(42);\n    let k = N - 42;\n\n    for i in 0..N {\n        assert_eq!(a[(i + k) % N], i);\n    }\n}\n\n#[test]\nfn test_rotate_right() {\n    const N: usize = 600;\n    let a: &mut [_] = &mut [0; N];\n    for i in 0..N {\n        a[i] = i;\n    }\n\n    a.rotate_right(42);\n\n    for i in 0..N {\n        assert_eq!(a[(i + 42) % N], i);\n    }\n}\n\n#[test]\n#[cfg_attr(miri, ignore)] // Miri is too slow\nfn brute_force_rotate_test_0() {\n    // In case of edge cases involving multiple algorithms\n    let n = 300;\n    for len in 0..n {\n        for s in 0..len {\n            let mut v = Vec::with_capacity(len);\n            for i in 0..len {\n                v.push(i);\n            }\n            v[..].rotate_right(s);\n            for i in 0..v.len() {\n                assert_eq!(v[i], v.len().wrapping_add(i.wrapping_sub(s)) % v.len());\n            }\n        }\n    }\n}\n\n#[test]\nfn brute_force_rotate_test_1() {\n    // `ptr_rotate` covers so many kinds of pointer usage, that this is just a good test for\n    // pointers in general. This uses a `[usize; 4]` to hit all algorithms without overwhelming miri\n    let n = 30;\n    for len in 0..n {\n        for s in 0..len {\n            let mut v: Vec<[usize; 4]> = Vec::with_capacity(len);\n            for i in 0..len {\n                v.push([i, 0, 0, 0]);\n            }\n            v[..].rotate_right(s);\n            for i in 0..v.len() {\n                assert_eq!(v[i][0], v.len().wrapping_add(i.wrapping_sub(s)) % v.len());\n            }\n        }\n    }\n}\n\n#[test]\n#[cfg(not(target_arch = \"wasm32\"))]\nfn sort_unstable() {\n    use core::cmp::Ordering::{Equal, Greater, Less};\n    use core::slice::heapsort;\n    use rand::{rngs::StdRng, seq::SliceRandom, Rng, SeedableRng};\n\n    // Miri is too slow (but still need to `chain` to make the types match)\n    let lens = if cfg!(miri) { (2..20).chain(0..0) } else { (2..25).chain(500..510) };\n    let rounds = if cfg!(miri) { 1 } else { 100 };\n\n    let mut v = [0; 600];\n    let mut tmp = [0; 600];\n    let mut rng = StdRng::from_entropy();\n\n    for len in lens {\n        let v = &mut v[0..len];\n        let tmp = &mut tmp[0..len];\n\n        for &modulus in &[5, 10, 100, 1000] {\n            for _ in 0..rounds {\n                for i in 0..len {\n                    v[i] = rng.gen::<i32>() % modulus;\n                }\n\n                // Sort in default order.\n                tmp.copy_from_slice(v);\n                tmp.sort_unstable();\n                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n\n                // Sort in ascending order.\n                tmp.copy_from_slice(v);\n                tmp.sort_unstable_by(|a, b| a.cmp(b));\n                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n\n                // Sort in descending order.\n                tmp.copy_from_slice(v);\n                tmp.sort_unstable_by(|a, b| b.cmp(a));\n                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n\n                // Test heapsort using `<` operator.\n                tmp.copy_from_slice(v);\n                heapsort(tmp, |a, b| a < b);\n                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n\n                // Test heapsort using `>` operator.\n                tmp.copy_from_slice(v);\n                heapsort(tmp, |a, b| a > b);\n                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n            }\n        }\n    }\n\n    // Sort using a completely random comparison function.\n    // This will reorder the elements *somehow*, but won't panic.\n    for i in 0..v.len() {\n        v[i] = i as i32;\n    }\n    v.sort_unstable_by(|_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n    v.sort_unstable();\n    for i in 0..v.len() {\n        assert_eq!(v[i], i as i32);\n    }\n\n    // Should not panic.\n    [0i32; 0].sort_unstable();\n    [(); 10].sort_unstable();\n    [(); 100].sort_unstable();\n\n    let mut v = [0xDEADBEEFu64];\n    v.sort_unstable();\n    assert!(v == [0xDEADBEEF]);\n}\n\n#[test]\n#[cfg(not(target_arch = \"wasm32\"))]\n#[cfg_attr(miri, ignore)] // Miri is too slow\nfn select_nth_unstable() {\n    use core::cmp::Ordering::{Equal, Greater, Less};\n    use rand::rngs::StdRng;\n    use rand::seq::SliceRandom;\n    use rand::{Rng, SeedableRng};\n\n    let mut rng = StdRng::from_entropy();\n\n    for len in (2..21).chain(500..501) {\n        let mut orig = vec![0; len];\n\n        for &modulus in &[5, 10, 1000] {\n            for _ in 0..10 {\n                for i in 0..len {\n                    orig[i] = rng.gen::<i32>() % modulus;\n                }\n\n                let v_sorted = {\n                    let mut v = orig.clone();\n                    v.sort();\n                    v\n                };\n\n                // Sort in default order.\n                for pivot in 0..len {\n                    let mut v = orig.clone();\n                    v.select_nth_unstable(pivot);\n\n                    assert_eq!(v_sorted[pivot], v[pivot]);\n                    for i in 0..pivot {\n                        for j in pivot..len {\n                            assert!(v[i] <= v[j]);\n                        }\n                    }\n                }\n\n                // Sort in ascending order.\n                for pivot in 0..len {\n                    let mut v = orig.clone();\n                    let (left, pivot, right) = v.select_nth_unstable_by(pivot, |a, b| a.cmp(b));\n\n                    assert_eq!(left.len() + right.len(), len - 1);\n\n                    for l in left {\n                        assert!(l <= pivot);\n                        for r in right.iter_mut() {\n                            assert!(l <= r);\n                            assert!(pivot <= r);\n                        }\n                    }\n                }\n\n                // Sort in descending order.\n                let sort_descending_comparator = |a: &i32, b: &i32| b.cmp(a);\n                let v_sorted_descending = {\n                    let mut v = orig.clone();\n                    v.sort_by(sort_descending_comparator);\n                    v\n                };\n\n                for pivot in 0..len {\n                    let mut v = orig.clone();\n                    v.select_nth_unstable_by(pivot, sort_descending_comparator);\n\n                    assert_eq!(v_sorted_descending[pivot], v[pivot]);\n                    for i in 0..pivot {\n                        for j in pivot..len {\n                            assert!(v[j] <= v[i]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Sort at index using a completely random comparison function.\n    // This will reorder the elements *somehow*, but won't panic.\n    let mut v = [0; 500];\n    for i in 0..v.len() {\n        v[i] = i as i32;\n    }\n\n    for pivot in 0..v.len() {\n        v.select_nth_unstable_by(pivot, |_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n        v.sort();\n        for i in 0..v.len() {\n            assert_eq!(v[i], i as i32);\n        }\n    }\n\n    // Should not panic.\n    [(); 10].select_nth_unstable(0);\n    [(); 10].select_nth_unstable(5);\n    [(); 10].select_nth_unstable(9);\n    [(); 100].select_nth_unstable(0);\n    [(); 100].select_nth_unstable(50);\n    [(); 100].select_nth_unstable(99);\n\n    let mut v = [0xDEADBEEFu64];\n    v.select_nth_unstable(0);\n    assert!(v == [0xDEADBEEF]);\n}\n\n#[test]\n#[should_panic(expected = \"index 0 greater than length of slice\")]\nfn select_nth_unstable_zero_length() {\n    [0i32; 0].select_nth_unstable(0);\n}\n\n#[test]\n#[should_panic(expected = \"index 20 greater than length of slice\")]\nfn select_nth_unstable_past_length() {\n    [0i32; 10].select_nth_unstable(20);\n}\n\npub mod memchr {\n    use core::slice::memchr::{memchr, memrchr};\n\n    // test fallback implementations on all platforms\n    #[test]\n    fn matches_one() {\n        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n    }\n\n    #[test]\n    fn matches_begin() {\n        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n    }\n\n    #[test]\n    fn matches_end() {\n        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n    }\n\n    #[test]\n    fn matches_nul() {\n        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n    }\n\n    #[test]\n    fn matches_past_nul() {\n        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n    }\n\n    #[test]\n    fn no_match_empty() {\n        assert_eq!(None, memchr(b'a', b\"\"));\n    }\n\n    #[test]\n    fn no_match() {\n        assert_eq!(None, memchr(b'a', b\"xyz\"));\n    }\n\n    #[test]\n    fn matches_one_reversed() {\n        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n    }\n\n    #[test]\n    fn matches_begin_reversed() {\n        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n    }\n\n    #[test]\n    fn matches_end_reversed() {\n        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n    }\n\n    #[test]\n    fn matches_nul_reversed() {\n        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n    }\n\n    #[test]\n    fn matches_past_nul_reversed() {\n        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n    }\n\n    #[test]\n    fn no_match_empty_reversed() {\n        assert_eq!(None, memrchr(b'a', b\"\"));\n    }\n\n    #[test]\n    fn no_match_reversed() {\n        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n    }\n\n    #[test]\n    fn each_alignment_reversed() {\n        let mut data = [1u8; 64];\n        let needle = 2;\n        let pos = 40;\n        data[pos] = needle;\n        for start in 0..16 {\n            assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n        }\n    }\n}\n\n#[test]\nfn test_align_to_simple() {\n    let bytes = [1u8, 2, 3, 4, 5, 6, 7];\n    let (prefix, aligned, suffix) = unsafe { bytes.align_to::<u16>() };\n    assert_eq!(aligned.len(), 3);\n    assert!(prefix == [1] || suffix == [7]);\n    let expect1 = [1 << 8 | 2, 3 << 8 | 4, 5 << 8 | 6];\n    let expect2 = [1 | 2 << 8, 3 | 4 << 8, 5 | 6 << 8];\n    let expect3 = [2 << 8 | 3, 4 << 8 | 5, 6 << 8 | 7];\n    let expect4 = [2 | 3 << 8, 4 | 5 << 8, 6 | 7 << 8];\n    assert!(\n        aligned == expect1 || aligned == expect2 || aligned == expect3 || aligned == expect4,\n        \"aligned={:?} expected={:?} || {:?} || {:?} || {:?}\",\n        aligned,\n        expect1,\n        expect2,\n        expect3,\n        expect4\n    );\n}\n\n#[test]\nfn test_align_to_zst() {\n    let bytes = [1, 2, 3, 4, 5, 6, 7];\n    let (prefix, aligned, suffix) = unsafe { bytes.align_to::<()>() };\n    assert_eq!(aligned.len(), 0);\n    assert!(prefix == [1, 2, 3, 4, 5, 6, 7] || suffix == [1, 2, 3, 4, 5, 6, 7]);\n}\n\n#[test]\nfn test_align_to_non_trivial() {\n    #[repr(align(8))]\n    struct U64(u64, u64);\n    #[repr(align(8))]\n    struct U64U64U32(u64, u64, u32);\n    let data = [\n        U64(1, 2),\n        U64(3, 4),\n        U64(5, 6),\n        U64(7, 8),\n        U64(9, 10),\n        U64(11, 12),\n        U64(13, 14),\n        U64(15, 16),\n    ];\n    let (prefix, aligned, suffix) = unsafe { data.align_to::<U64U64U32>() };\n    assert_eq!(aligned.len(), 4);\n    assert_eq!(prefix.len() + suffix.len(), 2);\n}\n\n#[test]\nfn test_align_to_empty_mid() {\n    use core::mem;\n\n    // Make sure that we do not create empty unaligned slices for the mid part, even when the\n    // overall slice is too short to contain an aligned address.\n    let bytes = [1, 2, 3, 4, 5, 6, 7];\n    type Chunk = u32;\n    for offset in 0..4 {\n        let (_, mid, _) = unsafe { bytes[offset..offset + 1].align_to::<Chunk>() };\n        assert_eq!(mid.as_ptr() as usize % mem::align_of::<Chunk>(), 0);\n    }\n}\n\n#[test]\nfn test_align_to_mut_aliasing() {\n    let mut val = [1u8, 2, 3, 4, 5];\n    // `align_to_mut` used to create `mid` in a way that there was some intermediate\n    // incorrect aliasing, invalidating the resulting `mid` slice.\n    let (begin, mid, end) = unsafe { val.align_to_mut::<[u8; 2]>() };\n    assert!(begin.len() == 0);\n    assert!(end.len() == 1);\n    mid[0] = mid[1];\n    assert_eq!(val, [3, 4, 3, 4, 5])\n}\n\n#[test]\nfn test_slice_partition_dedup_by() {\n    let mut slice: [i32; 9] = [1, -1, 2, 3, 1, -5, 5, -2, 2];\n\n    let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.abs() == b.abs());\n\n    assert_eq!(dedup, [1, 2, 3, 1, -5, -2]);\n    assert_eq!(duplicates, [5, -1, 2]);\n}\n\n#[test]\nfn test_slice_partition_dedup_empty() {\n    let mut slice: [i32; 0] = [];\n\n    let (dedup, duplicates) = slice.partition_dedup();\n\n    assert_eq!(dedup, []);\n    assert_eq!(duplicates, []);\n}\n\n#[test]\nfn test_slice_partition_dedup_one() {\n    let mut slice = [12];\n\n    let (dedup, duplicates) = slice.partition_dedup();\n\n    assert_eq!(dedup, [12]);\n    assert_eq!(duplicates, []);\n}\n\n#[test]\nfn test_slice_partition_dedup_multiple_ident() {\n    let mut slice = [12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11];\n\n    let (dedup, duplicates) = slice.partition_dedup();\n\n    assert_eq!(dedup, [12, 11]);\n    assert_eq!(duplicates, [12, 12, 12, 12, 11, 11, 11, 11, 11]);\n}\n\n#[test]\nfn test_slice_partition_dedup_partialeq() {\n    #[derive(Debug)]\n    struct Foo(i32, i32);\n\n    impl PartialEq for Foo {\n        fn eq(&self, other: &Foo) -> bool {\n            self.0 == other.0\n        }\n    }\n\n    let mut slice = [Foo(0, 1), Foo(0, 5), Foo(1, 7), Foo(1, 9)];\n\n    let (dedup, duplicates) = slice.partition_dedup();\n\n    assert_eq!(dedup, [Foo(0, 1), Foo(1, 7)]);\n    assert_eq!(duplicates, [Foo(0, 5), Foo(1, 9)]);\n}\n\n#[test]\nfn test_copy_within() {\n    // Start to end, with a RangeTo.\n    let mut bytes = *b\"Hello, World!\";\n    bytes.copy_within(..3, 10);\n    assert_eq!(&bytes, b\"Hello, WorHel\");\n\n    // End to start, with a RangeFrom.\n    let mut bytes = *b\"Hello, World!\";\n    bytes.copy_within(10.., 0);\n    assert_eq!(&bytes, b\"ld!lo, World!\");\n\n    // Overlapping, with a RangeInclusive.\n    let mut bytes = *b\"Hello, World!\";\n    bytes.copy_within(0..=11, 1);\n    assert_eq!(&bytes, b\"HHello, World\");\n\n    // Whole slice, with a RangeFull.\n    let mut bytes = *b\"Hello, World!\";\n    bytes.copy_within(.., 0);\n    assert_eq!(&bytes, b\"Hello, World!\");\n\n    // Ensure that copying at the end of slice won't cause UB.\n    let mut bytes = *b\"Hello, World!\";\n    bytes.copy_within(13..13, 5);\n    assert_eq!(&bytes, b\"Hello, World!\");\n    bytes.copy_within(5..5, 13);\n    assert_eq!(&bytes, b\"Hello, World!\");\n}\n\n#[test]\n#[should_panic(expected = \"range end index 14 out of range for slice of length 13\")]\nfn test_copy_within_panics_src_too_long() {\n    let mut bytes = *b\"Hello, World!\";\n    // The length is only 13, so 14 is out of bounds.\n    bytes.copy_within(10..14, 0);\n}\n\n#[test]\n#[should_panic(expected = \"dest is out of bounds\")]\nfn test_copy_within_panics_dest_too_long() {\n    let mut bytes = *b\"Hello, World!\";\n    // The length is only 13, so a slice of length 4 starting at index 10 is out of bounds.\n    bytes.copy_within(0..4, 10);\n}\n\n#[test]\n#[should_panic(expected = \"slice index starts at 2 but ends at 1\")]\nfn test_copy_within_panics_src_inverted() {\n    let mut bytes = *b\"Hello, World!\";\n    // 2 is greater than 1, so this range is invalid.\n    bytes.copy_within(2..1, 0);\n}\n#[test]\n#[should_panic(expected = \"attempted to index slice up to maximum usize\")]\nfn test_copy_within_panics_src_out_of_bounds() {\n    let mut bytes = *b\"Hello, World!\";\n    // an inclusive range ending at usize::MAX would make src_end overflow\n    bytes.copy_within(usize::MAX..=usize::MAX, 0);\n}\n\n#[test]\nfn test_is_sorted() {\n    let empty: [i32; 0] = [];\n\n    assert!([1, 2, 2, 9].is_sorted());\n    assert!(![1, 3, 2].is_sorted());\n    assert!([0].is_sorted());\n    assert!(empty.is_sorted());\n    assert!(![0.0, 1.0, f32::NAN].is_sorted());\n    assert!([-2, -1, 0, 3].is_sorted());\n    assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n    assert!(![\"c\", \"bb\", \"aaa\"].is_sorted());\n    assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n}\n\n#[test]\nfn test_slice_run_destructors() {\n    // Make sure that destructors get run on slice literals\n    struct Foo<'a> {\n        x: &'a Cell<isize>,\n    }\n\n    impl<'a> Drop for Foo<'a> {\n        fn drop(&mut self) {\n            self.x.set(self.x.get() + 1);\n        }\n    }\n\n    fn foo(x: &Cell<isize>) -> Foo<'_> {\n        Foo { x }\n    }\n\n    let x = &Cell::new(0);\n\n    {\n        let l = &[foo(x)];\n        assert_eq!(l[0].x.get(), 0);\n    }\n\n    assert_eq!(x.get(), 1);\n}\n"],[2990,"use core::intrinsics::discriminant_value;\nuse core::ops::ControlFlow;\n\n#[test]\nfn control_flow_discriminants_match_result() {\n    // This isn't stable surface area, but helps keep `?` cheap between them,\n    // even if LLVM can't always take advantage of it right now.\n    // (Sadly Result and Option are inconsistent, so ControlFlow can't match both.)\n\n    assert_eq!(\n        discriminant_value(&ControlFlow::<i32, i32>::Break(3)),\n        discriminant_value(&Result::<i32, i32>::Err(3)),\n    );\n    assert_eq!(\n        discriminant_value(&ControlFlow::<i32, i32>::Continue(3)),\n        discriminant_value(&Result::<i32, i32>::Ok(3)),\n    );\n}\n"],[2991,"use core::convert::TryFrom;\nuse core::num::{\n    IntErrorKind, NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize,\n    NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize,\n};\nuse core::option::Option::{self, None, Some};\nuse std::mem::size_of;\n\n#[test]\nfn test_create_nonzero_instance() {\n    let _a = unsafe { NonZeroU32::new_unchecked(21) };\n}\n\n#[test]\nfn test_size_nonzero_in_option() {\n    assert_eq!(size_of::<NonZeroU32>(), size_of::<Option<NonZeroU32>>());\n    assert_eq!(size_of::<NonZeroI32>(), size_of::<Option<NonZeroI32>>());\n}\n\n#[test]\nfn test_match_on_nonzero_option() {\n    let a = Some(unsafe { NonZeroU32::new_unchecked(42) });\n    match a {\n        Some(val) => assert_eq!(val.get(), 42),\n        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\"),\n    }\n\n    match unsafe { Some(NonZeroU32::new_unchecked(43)) } {\n        Some(val) => assert_eq!(val.get(), 43),\n        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\"),\n    }\n}\n\n#[test]\nfn test_match_option_empty_vec() {\n    let a: Option<Vec<isize>> = Some(vec![]);\n    match a {\n        None => panic!(\"unexpected None while matching on Some(vec![])\"),\n        _ => {}\n    }\n}\n\n#[test]\nfn test_match_option_vec() {\n    let a = Some(vec![1, 2, 3, 4]);\n    match a {\n        Some(v) => assert_eq!(v, [1, 2, 3, 4]),\n        None => panic!(\"unexpected None while matching on Some(vec![1, 2, 3, 4])\"),\n    }\n}\n\n#[test]\nfn test_match_option_rc() {\n    use std::rc::Rc;\n\n    let five = Rc::new(5);\n    match Some(five) {\n        Some(r) => assert_eq!(*r, 5),\n        None => panic!(\"unexpected None while matching on Some(Rc::new(5))\"),\n    }\n}\n\n#[test]\nfn test_match_option_arc() {\n    use std::sync::Arc;\n\n    let five = Arc::new(5);\n    match Some(five) {\n        Some(a) => assert_eq!(*a, 5),\n        None => panic!(\"unexpected None while matching on Some(Arc::new(5))\"),\n    }\n}\n\n#[test]\nfn test_match_option_empty_string() {\n    let a = Some(String::new());\n    match a {\n        None => panic!(\"unexpected None while matching on Some(String::new())\"),\n        _ => {}\n    }\n}\n\n#[test]\nfn test_match_option_string() {\n    let five = \"Five\".to_string();\n    match Some(five) {\n        Some(s) => assert_eq!(s, \"Five\"),\n        None => panic!(\"{}\", \"unexpected None while matching on Some(String { ... })\"),\n    }\n}\n\nmod atom {\n    use core::num::NonZeroU32;\n\n    #[derive(PartialEq, Eq)]\n    pub struct Atom {\n        index: NonZeroU32, // private\n    }\n    pub const FOO_ATOM: Atom = Atom { index: unsafe { NonZeroU32::new_unchecked(7) } };\n}\n\nmacro_rules! atom {\n    (\"foo\") => {\n        atom::FOO_ATOM\n    };\n}\n\n#[test]\nfn test_match_nonzero_const_pattern() {\n    match atom!(\"foo\") {\n        // Using as a pattern is supported by the compiler:\n        atom!(\"foo\") => {}\n        _ => panic!(\"Expected the const item as a pattern to match.\"),\n    }\n}\n\n#[test]\nfn test_from_nonzero() {\n    let nz = NonZeroU32::new(1).unwrap();\n    let num: u32 = nz.into();\n    assert_eq!(num, 1u32);\n}\n\n#[test]\nfn test_from_signed_nonzero() {\n    let nz = NonZeroI32::new(1).unwrap();\n    let num: i32 = nz.into();\n    assert_eq!(num, 1i32);\n}\n\n#[test]\nfn test_from_str() {\n    assert_eq!(\"123\".parse::<NonZeroU8>(), Ok(NonZeroU8::new(123).unwrap()));\n    assert_eq!(\"0\".parse::<NonZeroU8>().err().map(|e| e.kind().clone()), Some(IntErrorKind::Zero));\n    assert_eq!(\n        \"-1\".parse::<NonZeroU8>().err().map(|e| e.kind().clone()),\n        Some(IntErrorKind::InvalidDigit)\n    );\n    assert_eq!(\n        \"-129\".parse::<NonZeroI8>().err().map(|e| e.kind().clone()),\n        Some(IntErrorKind::NegOverflow)\n    );\n    assert_eq!(\n        \"257\".parse::<NonZeroU8>().err().map(|e| e.kind().clone()),\n        Some(IntErrorKind::PosOverflow)\n    );\n}\n\n#[test]\nfn test_nonzero_bitor() {\n    let nz_alt = NonZeroU8::new(0b1010_1010).unwrap();\n    let nz_low = NonZeroU8::new(0b0000_1111).unwrap();\n\n    let both_nz: NonZeroU8 = nz_alt | nz_low;\n    assert_eq!(both_nz.get(), 0b1010_1111);\n\n    let rhs_int: NonZeroU8 = nz_low | 0b1100_0000u8;\n    assert_eq!(rhs_int.get(), 0b1100_1111);\n\n    let rhs_zero: NonZeroU8 = nz_alt | 0u8;\n    assert_eq!(rhs_zero.get(), 0b1010_1010);\n\n    let lhs_int: NonZeroU8 = 0b0110_0110u8 | nz_alt;\n    assert_eq!(lhs_int.get(), 0b1110_1110);\n\n    let lhs_zero: NonZeroU8 = 0u8 | nz_low;\n    assert_eq!(lhs_zero.get(), 0b0000_1111);\n}\n\n#[test]\nfn test_nonzero_bitor_assign() {\n    let mut target = NonZeroU8::new(0b1010_1010).unwrap();\n\n    target |= NonZeroU8::new(0b0000_1111).unwrap();\n    assert_eq!(target.get(), 0b1010_1111);\n\n    target |= 0b0001_0000;\n    assert_eq!(target.get(), 0b1011_1111);\n\n    target |= 0;\n    assert_eq!(target.get(), 0b1011_1111);\n}\n\n#[test]\nfn test_nonzero_from_int_on_success() {\n    assert_eq!(NonZeroU8::try_from(5), Ok(NonZeroU8::new(5).unwrap()));\n    assert_eq!(NonZeroU32::try_from(5), Ok(NonZeroU32::new(5).unwrap()));\n\n    assert_eq!(NonZeroI8::try_from(-5), Ok(NonZeroI8::new(-5).unwrap()));\n    assert_eq!(NonZeroI32::try_from(-5), Ok(NonZeroI32::new(-5).unwrap()));\n}\n\n#[test]\nfn test_nonzero_from_int_on_err() {\n    assert!(NonZeroU8::try_from(0).is_err());\n    assert!(NonZeroU32::try_from(0).is_err());\n\n    assert!(NonZeroI8::try_from(0).is_err());\n    assert!(NonZeroI32::try_from(0).is_err());\n}\n\n#[test]\nfn nonzero_const() {\n    // test that the methods of `NonZeroX>` are usable in a const context\n    // Note: only tests NonZero8\n\n    const NONZERO: NonZeroU8 = unsafe { NonZeroU8::new_unchecked(5) };\n\n    const GET: u8 = NONZERO.get();\n    assert_eq!(GET, 5);\n\n    const ZERO: Option<NonZeroU8> = NonZeroU8::new(0);\n    assert!(ZERO.is_none());\n\n    const ONE: Option<NonZeroU8> = NonZeroU8::new(1);\n    assert!(ONE.is_some());\n}\n\n#[test]\nfn nonzero_leading_zeros() {\n    assert_eq!(NonZeroU8::new(1).unwrap().leading_zeros(), 7);\n    assert_eq!(NonZeroI8::new(1).unwrap().leading_zeros(), 7);\n    assert_eq!(NonZeroU16::new(1).unwrap().leading_zeros(), 15);\n    assert_eq!(NonZeroI16::new(1).unwrap().leading_zeros(), 15);\n    assert_eq!(NonZeroU32::new(1).unwrap().leading_zeros(), 31);\n    assert_eq!(NonZeroI32::new(1).unwrap().leading_zeros(), 31);\n    assert_eq!(NonZeroU64::new(1).unwrap().leading_zeros(), 63);\n    assert_eq!(NonZeroI64::new(1).unwrap().leading_zeros(), 63);\n    assert_eq!(NonZeroU128::new(1).unwrap().leading_zeros(), 127);\n    assert_eq!(NonZeroI128::new(1).unwrap().leading_zeros(), 127);\n    assert_eq!(NonZeroUsize::new(1).unwrap().leading_zeros(), usize::BITS - 1);\n    assert_eq!(NonZeroIsize::new(1).unwrap().leading_zeros(), usize::BITS - 1);\n\n    assert_eq!(NonZeroU8::new(u8::MAX >> 2).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroI8::new((u8::MAX >> 2) as i8).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroU16::new(u16::MAX >> 2).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroI16::new((u16::MAX >> 2) as i16).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroU32::new(u32::MAX >> 2).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroI32::new((u32::MAX >> 2) as i32).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroU64::new(u64::MAX >> 2).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroI64::new((u64::MAX >> 2) as i64).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroU128::new(u128::MAX >> 2).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroI128::new((u128::MAX >> 2) as i128).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroUsize::new(usize::MAX >> 2).unwrap().leading_zeros(), 2);\n    assert_eq!(NonZeroIsize::new((usize::MAX >> 2) as isize).unwrap().leading_zeros(), 2);\n\n    assert_eq!(NonZeroU8::new(u8::MAX).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroI8::new(-1i8).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroU16::new(u16::MAX).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroI16::new(-1i16).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroU32::new(u32::MAX).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroI32::new(-1i32).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroU64::new(u64::MAX).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroI64::new(-1i64).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroU128::new(u128::MAX).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroI128::new(-1i128).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroUsize::new(usize::MAX).unwrap().leading_zeros(), 0);\n    assert_eq!(NonZeroIsize::new(-1isize).unwrap().leading_zeros(), 0);\n\n    const LEADING_ZEROS: u32 = NonZeroU16::new(1).unwrap().leading_zeros();\n    assert_eq!(LEADING_ZEROS, 15);\n}\n\n#[test]\nfn nonzero_trailing_zeros() {\n    assert_eq!(NonZeroU8::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroI8::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroU16::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroI16::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroU32::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroI32::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroU64::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroI64::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroU128::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroI128::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroUsize::new(1).unwrap().trailing_zeros(), 0);\n    assert_eq!(NonZeroIsize::new(1).unwrap().trailing_zeros(), 0);\n\n    assert_eq!(NonZeroU8::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroI8::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroU16::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroI16::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroU32::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroI32::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroU64::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroI64::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroU128::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroI128::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroUsize::new(1 << 2).unwrap().trailing_zeros(), 2);\n    assert_eq!(NonZeroIsize::new(1 << 2).unwrap().trailing_zeros(), 2);\n\n    assert_eq!(NonZeroU8::new(1 << 7).unwrap().trailing_zeros(), 7);\n    assert_eq!(NonZeroI8::new(1 << 7).unwrap().trailing_zeros(), 7);\n    assert_eq!(NonZeroU16::new(1 << 15).unwrap().trailing_zeros(), 15);\n    assert_eq!(NonZeroI16::new(1 << 15).unwrap().trailing_zeros(), 15);\n    assert_eq!(NonZeroU32::new(1 << 31).unwrap().trailing_zeros(), 31);\n    assert_eq!(NonZeroI32::new(1 << 31).unwrap().trailing_zeros(), 31);\n    assert_eq!(NonZeroU64::new(1 << 63).unwrap().trailing_zeros(), 63);\n    assert_eq!(NonZeroI64::new(1 << 63).unwrap().trailing_zeros(), 63);\n    assert_eq!(NonZeroU128::new(1 << 127).unwrap().trailing_zeros(), 127);\n    assert_eq!(NonZeroI128::new(1 << 127).unwrap().trailing_zeros(), 127);\n\n    assert_eq!(\n        NonZeroUsize::new(1 << (usize::BITS - 1)).unwrap().trailing_zeros(),\n        usize::BITS - 1\n    );\n    assert_eq!(\n        NonZeroIsize::new(1 << (usize::BITS - 1)).unwrap().trailing_zeros(),\n        usize::BITS - 1\n    );\n\n    const TRAILING_ZEROS: u32 = NonZeroU16::new(1 << 2).unwrap().trailing_zeros();\n    assert_eq!(TRAILING_ZEROS, 2);\n}\n\n#[test]\nfn test_nonzero_uint_div() {\n    let nz = NonZeroU32::new(1).unwrap();\n\n    let x: u32 = 42u32 / nz;\n    assert_eq!(x, 42u32);\n}\n\n#[test]\nfn test_nonzero_uint_rem() {\n    let nz = NonZeroU32::new(10).unwrap();\n\n    let x: u32 = 42u32 % nz;\n    assert_eq!(x, 2u32);\n}\n"],[2992,"use core::str::lossy::*;\n\n#[test]\nfn chunks() {\n    let mut iter = Utf8Lossy::from_bytes(b\"hello\").chunks();\n    assert_eq!(Some(Utf8LossyChunk { valid: \"hello\", broken: b\"\" }), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = Utf8Lossy::from_bytes(\"ศไทย中华Việt Nam\".as_bytes()).chunks();\n    assert_eq!(Some(Utf8LossyChunk { valid: \"ศไทย中华Việt Nam\", broken: b\"\" }), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC2 There\\xFF Goodbye\").chunks();\n    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC2\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xFF\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\" }), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").chunks();\n    assert_eq!(Some(Utf8LossyChunk { valid: \"Hello\", broken: b\"\\xC0\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \" There\", broken: b\"\\xE6\\x83\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \" Goodbye\", broken: b\"\" }), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = Utf8Lossy::from_bytes(b\"\\xF5foo\\xF5\\x80bar\").chunks();\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF5\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF5\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\" }), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = Utf8Lossy::from_bytes(b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\").chunks();\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF1\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF1\\x80\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF1\\x80\\x80\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\" }), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = Utf8Lossy::from_bytes(b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\").chunks();\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF4\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xF4\\x80\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\\xF4\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"baz\", broken: b\"\" }), iter.next());\n    assert_eq!(None, iter.next());\n\n    let mut iter = Utf8Lossy::from_bytes(b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\").chunks();\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xF0\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\\u{10000}bar\", broken: b\"\" }), iter.next());\n    assert_eq!(None, iter.next());\n\n    // surrogates\n    let mut iter = Utf8Lossy::from_bytes(b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\").chunks();\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xED\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xA0\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\x80\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"foo\", broken: b\"\\xED\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"\", broken: b\"\\xBF\" }), iter.next());\n    assert_eq!(Some(Utf8LossyChunk { valid: \"bar\", broken: b\"\" }), iter.next());\n    assert_eq!(None, iter.next());\n}\n\n#[test]\nfn display() {\n    assert_eq!(\n        \"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\",\n        &Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").to_string()\n    );\n}\n\n#[test]\nfn debug() {\n    assert_eq!(\n        \"\\\"Hello\\\\xc0\\\\x80 There\\\\xe6\\\\x83 Goodbye\\\\u{10d4ea}\\\"\",\n        &format!(\n            \"{:?}\",\n            Utf8Lossy::from_bytes(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\\xf4\\x8d\\x93\\xaa\")\n        )\n    );\n}\n"],[2993,"mod sip;\n\nuse std::default::Default;\nuse std::hash::{Hash, Hasher};\nuse std::rc::Rc;\n\nstruct MyHasher {\n    hash: u64,\n}\n\nimpl Default for MyHasher {\n    fn default() -> MyHasher {\n        MyHasher { hash: 0 }\n    }\n}\n\nimpl Hasher for MyHasher {\n    fn write(&mut self, buf: &[u8]) {\n        for byte in buf {\n            self.hash += *byte as u64;\n        }\n    }\n    fn finish(&self) -> u64 {\n        self.hash\n    }\n}\n\n#[test]\nfn test_writer_hasher() {\n    fn hash<T: Hash>(t: &T) -> u64 {\n        let mut s = MyHasher { hash: 0 };\n        t.hash(&mut s);\n        s.finish()\n    }\n\n    assert_eq!(hash(&()), 0);\n\n    assert_eq!(hash(&5_u8), 5);\n    assert_eq!(hash(&5_u16), 5);\n    assert_eq!(hash(&5_u32), 5);\n    assert_eq!(hash(&5_u64), 5);\n    assert_eq!(hash(&5_usize), 5);\n\n    assert_eq!(hash(&5_i8), 5);\n    assert_eq!(hash(&5_i16), 5);\n    assert_eq!(hash(&5_i32), 5);\n    assert_eq!(hash(&5_i64), 5);\n    assert_eq!(hash(&5_isize), 5);\n\n    assert_eq!(hash(&false), 0);\n    assert_eq!(hash(&true), 1);\n\n    assert_eq!(hash(&'a'), 97);\n\n    let s: &str = \"a\";\n    assert_eq!(hash(&s), 97 + 0xFF);\n    let s: Box<str> = String::from(\"a\").into_boxed_str();\n    assert_eq!(hash(&s), 97 + 0xFF);\n    let s: Rc<&str> = Rc::new(\"a\");\n    assert_eq!(hash(&s), 97 + 0xFF);\n    let cs: &[u8] = &[1, 2, 3];\n    assert_eq!(hash(&cs), 9);\n    let cs: Box<[u8]> = Box::new([1, 2, 3]);\n    assert_eq!(hash(&cs), 9);\n    let cs: Rc<[u8]> = Rc::new([1, 2, 3]);\n    assert_eq!(hash(&cs), 9);\n\n    let ptr = 5_usize as *const i32;\n    assert_eq!(hash(&ptr), 5);\n\n    let ptr = 5_usize as *mut i32;\n    assert_eq!(hash(&ptr), 5);\n\n    if cfg!(miri) {\n        // Miri cannot hash pointers\n        return;\n    }\n\n    let cs: &mut [u8] = &mut [1, 2, 3];\n    let ptr = cs.as_ptr();\n    let slice_ptr = cs as *const [u8];\n    assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n\n    let slice_ptr = cs as *mut [u8];\n    assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n}\n\nstruct Custom {\n    hash: u64,\n}\nstruct CustomHasher {\n    output: u64,\n}\n\nimpl Hasher for CustomHasher {\n    fn finish(&self) -> u64 {\n        self.output\n    }\n    fn write(&mut self, _: &[u8]) {\n        panic!()\n    }\n    fn write_u64(&mut self, data: u64) {\n        self.output = data;\n    }\n}\n\nimpl Default for CustomHasher {\n    fn default() -> CustomHasher {\n        CustomHasher { output: 0 }\n    }\n}\n\nimpl Hash for Custom {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        state.write_u64(self.hash);\n    }\n}\n\n#[test]\nfn test_custom_state() {\n    fn hash<T: Hash>(t: &T) -> u64 {\n        let mut c = CustomHasher { output: 0 };\n        t.hash(&mut c);\n        c.finish()\n    }\n\n    assert_eq!(hash(&Custom { hash: 5 }), 5);\n}\n\n// FIXME: Instantiated functions with i128 in the signature is not supported in Emscripten.\n// See https://github.com/kripken/emscripten-fastcomp/issues/169\n#[cfg(not(target_os = \"emscripten\"))]\n#[test]\nfn test_indirect_hasher() {\n    let mut hasher = MyHasher { hash: 0 };\n    {\n        let mut indirect_hasher: &mut dyn Hasher = &mut hasher;\n        5u32.hash(&mut indirect_hasher);\n    }\n    assert_eq!(hasher.hash, 5);\n}\n"],[2994,"#![allow(deprecated)]\n\nuse core::hash::{Hash, Hasher};\nuse core::hash::{SipHasher, SipHasher13};\nuse core::{mem, slice};\n\n// Hash just the bytes of the slice, without length prefix\nstruct Bytes<'a>(&'a [u8]);\n\nimpl<'a> Hash for Bytes<'a> {\n    #[allow(unused_must_use)]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        let Bytes(v) = *self;\n        state.write(v);\n    }\n}\n\nmacro_rules! u8to64_le {\n    ($buf:expr, $i:expr) => {\n        $buf[0 + $i] as u64\n            | ($buf[1 + $i] as u64) << 8\n            | ($buf[2 + $i] as u64) << 16\n            | ($buf[3 + $i] as u64) << 24\n            | ($buf[4 + $i] as u64) << 32\n            | ($buf[5 + $i] as u64) << 40\n            | ($buf[6 + $i] as u64) << 48\n            | ($buf[7 + $i] as u64) << 56\n    };\n    ($buf:expr, $i:expr, $len:expr) => {{\n        let mut t = 0;\n        let mut out = 0;\n        while t < $len {\n            out |= ($buf[t + $i] as u64) << t * 8;\n            t += 1;\n        }\n        out\n    }};\n}\n\nfn hash_with<H: Hasher, T: Hash>(mut st: H, x: &T) -> u64 {\n    x.hash(&mut st);\n    st.finish()\n}\n\nfn hash<T: Hash>(x: &T) -> u64 {\n    hash_with(SipHasher::new(), x)\n}\n\n#[test]\n#[allow(unused_must_use)]\nfn test_siphash_1_3() {\n    let vecs: [[u8; 8]; 64] = [\n        [0xdc, 0xc4, 0x0f, 0x05, 0x58, 0x01, 0xac, 0xab],\n        [0x93, 0xca, 0x57, 0x7d, 0xf3, 0x9b, 0xf4, 0xc9],\n        [0x4d, 0xd4, 0xc7, 0x4d, 0x02, 0x9b, 0xcb, 0x82],\n        [0xfb, 0xf7, 0xdd, 0xe7, 0xb8, 0x0a, 0xf8, 0x8b],\n        [0x28, 0x83, 0xd3, 0x88, 0x60, 0x57, 0x75, 0xcf],\n        [0x67, 0x3b, 0x53, 0x49, 0x2f, 0xd5, 0xf9, 0xde],\n        [0xa7, 0x22, 0x9f, 0xc5, 0x50, 0x2b, 0x0d, 0xc5],\n        [0x40, 0x11, 0xb1, 0x9b, 0x98, 0x7d, 0x92, 0xd3],\n        [0x8e, 0x9a, 0x29, 0x8d, 0x11, 0x95, 0x90, 0x36],\n        [0xe4, 0x3d, 0x06, 0x6c, 0xb3, 0x8e, 0xa4, 0x25],\n        [0x7f, 0x09, 0xff, 0x92, 0xee, 0x85, 0xde, 0x79],\n        [0x52, 0xc3, 0x4d, 0xf9, 0xc1, 0x18, 0xc1, 0x70],\n        [0xa2, 0xd9, 0xb4, 0x57, 0xb1, 0x84, 0xa3, 0x78],\n        [0xa7, 0xff, 0x29, 0x12, 0x0c, 0x76, 0x6f, 0x30],\n        [0x34, 0x5d, 0xf9, 0xc0, 0x11, 0xa1, 0x5a, 0x60],\n        [0x56, 0x99, 0x51, 0x2a, 0x6d, 0xd8, 0x20, 0xd3],\n        [0x66, 0x8b, 0x90, 0x7d, 0x1a, 0xdd, 0x4f, 0xcc],\n        [0x0c, 0xd8, 0xdb, 0x63, 0x90, 0x68, 0xf2, 0x9c],\n        [0x3e, 0xe6, 0x73, 0xb4, 0x9c, 0x38, 0xfc, 0x8f],\n        [0x1c, 0x7d, 0x29, 0x8d, 0xe5, 0x9d, 0x1f, 0xf2],\n        [0x40, 0xe0, 0xcc, 0xa6, 0x46, 0x2f, 0xdc, 0xc0],\n        [0x44, 0xf8, 0x45, 0x2b, 0xfe, 0xab, 0x92, 0xb9],\n        [0x2e, 0x87, 0x20, 0xa3, 0x9b, 0x7b, 0xfe, 0x7f],\n        [0x23, 0xc1, 0xe6, 0xda, 0x7f, 0x0e, 0x5a, 0x52],\n        [0x8c, 0x9c, 0x34, 0x67, 0xb2, 0xae, 0x64, 0xf4],\n        [0x79, 0x09, 0x5b, 0x70, 0x28, 0x59, 0xcd, 0x45],\n        [0xa5, 0x13, 0x99, 0xca, 0xe3, 0x35, 0x3e, 0x3a],\n        [0x35, 0x3b, 0xde, 0x4a, 0x4e, 0xc7, 0x1d, 0xa9],\n        [0x0d, 0xd0, 0x6c, 0xef, 0x02, 0xed, 0x0b, 0xfb],\n        [0xf4, 0xe1, 0xb1, 0x4a, 0xb4, 0x3c, 0xd9, 0x88],\n        [0x63, 0xe6, 0xc5, 0x43, 0xd6, 0x11, 0x0f, 0x54],\n        [0xbc, 0xd1, 0x21, 0x8c, 0x1f, 0xdd, 0x70, 0x23],\n        [0x0d, 0xb6, 0xa7, 0x16, 0x6c, 0x7b, 0x15, 0x81],\n        [0xbf, 0xf9, 0x8f, 0x7a, 0xe5, 0xb9, 0x54, 0x4d],\n        [0x3e, 0x75, 0x2a, 0x1f, 0x78, 0x12, 0x9f, 0x75],\n        [0x91, 0x6b, 0x18, 0xbf, 0xbe, 0xa3, 0xa1, 0xce],\n        [0x06, 0x62, 0xa2, 0xad, 0xd3, 0x08, 0xf5, 0x2c],\n        [0x57, 0x30, 0xc3, 0xa3, 0x2d, 0x1c, 0x10, 0xb6],\n        [0xa1, 0x36, 0x3a, 0xae, 0x96, 0x74, 0xf4, 0xb3],\n        [0x92, 0x83, 0x10, 0x7b, 0x54, 0x57, 0x6b, 0x62],\n        [0x31, 0x15, 0xe4, 0x99, 0x32, 0x36, 0xd2, 0xc1],\n        [0x44, 0xd9, 0x1a, 0x3f, 0x92, 0xc1, 0x7c, 0x66],\n        [0x25, 0x88, 0x13, 0xc8, 0xfe, 0x4f, 0x70, 0x65],\n        [0xa6, 0x49, 0x89, 0xc2, 0xd1, 0x80, 0xf2, 0x24],\n        [0x6b, 0x87, 0xf8, 0xfa, 0xed, 0x1c, 0xca, 0xc2],\n        [0x96, 0x21, 0x04, 0x9f, 0xfc, 0x4b, 0x16, 0xc2],\n        [0x23, 0xd6, 0xb1, 0x68, 0x93, 0x9c, 0x6e, 0xa1],\n        [0xfd, 0x14, 0x51, 0x8b, 0x9c, 0x16, 0xfb, 0x49],\n        [0x46, 0x4c, 0x07, 0xdf, 0xf8, 0x43, 0x31, 0x9f],\n        [0xb3, 0x86, 0xcc, 0x12, 0x24, 0xaf, 0xfd, 0xc6],\n        [0x8f, 0x09, 0x52, 0x0a, 0xd1, 0x49, 0xaf, 0x7e],\n        [0x9a, 0x2f, 0x29, 0x9d, 0x55, 0x13, 0xf3, 0x1c],\n        [0x12, 0x1f, 0xf4, 0xa2, 0xdd, 0x30, 0x4a, 0xc4],\n        [0xd0, 0x1e, 0xa7, 0x43, 0x89, 0xe9, 0xfa, 0x36],\n        [0xe6, 0xbc, 0xf0, 0x73, 0x4c, 0xb3, 0x8f, 0x31],\n        [0x80, 0xe9, 0xa7, 0x70, 0x36, 0xbf, 0x7a, 0xa2],\n        [0x75, 0x6d, 0x3c, 0x24, 0xdb, 0xc0, 0xbc, 0xb4],\n        [0x13, 0x15, 0xb7, 0xfd, 0x52, 0xd8, 0xf8, 0x23],\n        [0x08, 0x8a, 0x7d, 0xa6, 0x4d, 0x5f, 0x03, 0x8f],\n        [0x48, 0xf1, 0xe8, 0xb7, 0xe5, 0xd0, 0x9c, 0xd8],\n        [0xee, 0x44, 0xa6, 0xf7, 0xbc, 0xe6, 0xf4, 0xf6],\n        [0xf2, 0x37, 0x18, 0x0f, 0xd8, 0x9a, 0xc5, 0xae],\n        [0xe0, 0x94, 0x66, 0x4b, 0x15, 0xf6, 0xb2, 0xc3],\n        [0xa8, 0xb3, 0xbb, 0xb7, 0x62, 0x90, 0x19, 0x9d],\n    ];\n\n    let k0 = 0x_07_06_05_04_03_02_01_00;\n    let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n    let mut buf = Vec::new();\n    let mut t = 0;\n    let mut state_inc = SipHasher13::new_with_keys(k0, k1);\n\n    while t < 64 {\n        let vec = u8to64_le!(vecs[t], 0);\n        let out = hash_with(SipHasher13::new_with_keys(k0, k1), &Bytes(&buf));\n        assert_eq!(vec, out);\n\n        let full = hash_with(SipHasher13::new_with_keys(k0, k1), &Bytes(&buf));\n        let i = state_inc.finish();\n\n        assert_eq!(full, i);\n        assert_eq!(full, vec);\n\n        buf.push(t as u8);\n        Hasher::write(&mut state_inc, &[t as u8]);\n\n        t += 1;\n    }\n}\n\n#[test]\n#[allow(unused_must_use)]\nfn test_siphash_2_4() {\n    let vecs: [[u8; 8]; 64] = [\n        [0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72],\n        [0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74],\n        [0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d],\n        [0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85],\n        [0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf],\n        [0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18],\n        [0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb],\n        [0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab],\n        [0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93],\n        [0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e],\n        [0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a],\n        [0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4],\n        [0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75],\n        [0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14],\n        [0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7],\n        [0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1],\n        [0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f],\n        [0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69],\n        [0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b],\n        [0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb],\n        [0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe],\n        [0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0],\n        [0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93],\n        [0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8],\n        [0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8],\n        [0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc],\n        [0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17],\n        [0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f],\n        [0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde],\n        [0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6],\n        [0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad],\n        [0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32],\n        [0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71],\n        [0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7],\n        [0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12],\n        [0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15],\n        [0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31],\n        [0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02],\n        [0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca],\n        [0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a],\n        [0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e],\n        [0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad],\n        [0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18],\n        [0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4],\n        [0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9],\n        [0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9],\n        [0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb],\n        [0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0],\n        [0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6],\n        [0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7],\n        [0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee],\n        [0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1],\n        [0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a],\n        [0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81],\n        [0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f],\n        [0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24],\n        [0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7],\n        [0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea],\n        [0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60],\n        [0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66],\n        [0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c],\n        [0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f],\n        [0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5],\n        [0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95],\n    ];\n\n    let k0 = 0x_07_06_05_04_03_02_01_00;\n    let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n    let mut buf = Vec::new();\n    let mut t = 0;\n    let mut state_inc = SipHasher::new_with_keys(k0, k1);\n\n    while t < 64 {\n        let vec = u8to64_le!(vecs[t], 0);\n        let out = hash_with(SipHasher::new_with_keys(k0, k1), &Bytes(&buf));\n        assert_eq!(vec, out);\n\n        let full = hash_with(SipHasher::new_with_keys(k0, k1), &Bytes(&buf));\n        let i = state_inc.finish();\n\n        assert_eq!(full, i);\n        assert_eq!(full, vec);\n\n        buf.push(t as u8);\n        Hasher::write(&mut state_inc, &[t as u8]);\n\n        t += 1;\n    }\n}\n\n#[test]\n#[cfg(target_pointer_width = \"32\")]\nfn test_hash_usize() {\n    let val = 0xdeadbeef_deadbeef_u64;\n    assert_ne!(hash(&(val as u64)), hash(&(val as usize)));\n    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n}\n\n#[test]\n#[cfg(target_pointer_width = \"64\")]\nfn test_hash_usize() {\n    let val = 0xdeadbeef_deadbeef_u64;\n    assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n    assert_ne!(hash(&(val as u32)), hash(&(val as usize)));\n}\n\n#[test]\nfn test_hash_idempotent() {\n    let val64 = 0xdeadbeef_deadbeef_u64;\n    assert_eq!(hash(&val64), hash(&val64));\n    let val32 = 0xdeadbeef_u32;\n    assert_eq!(hash(&val32), hash(&val32));\n}\n\n#[test]\nfn test_hash_no_bytes_dropped_64() {\n    let val = 0xdeadbeef_deadbeef_u64;\n\n    assert_ne!(hash(&val), hash(&zero_byte(val, 0)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 1)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 2)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 3)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 4)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 5)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 6)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 7)));\n\n    fn zero_byte(val: u64, byte: usize) -> u64 {\n        assert!(byte < 8);\n        val & !(0xff << (byte * 8))\n    }\n}\n\n#[test]\nfn test_hash_no_bytes_dropped_32() {\n    let val = 0xdeadbeef_u32;\n\n    assert_ne!(hash(&val), hash(&zero_byte(val, 0)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 1)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 2)));\n    assert_ne!(hash(&val), hash(&zero_byte(val, 3)));\n\n    fn zero_byte(val: u32, byte: usize) -> u32 {\n        assert!(byte < 4);\n        val & !(0xff << (byte * 8))\n    }\n}\n\n#[test]\nfn test_hash_no_concat_alias() {\n    let s = (\"aa\", \"bb\");\n    let t = (\"aabb\", \"\");\n    let u = (\"a\", \"abb\");\n\n    assert_ne!(s, t);\n    assert_ne!(t, u);\n    assert_ne!(hash(&s), hash(&t));\n    assert_ne!(hash(&s), hash(&u));\n\n    let u = [1, 0, 0, 0];\n    let v = (&u[..1], &u[1..3], &u[3..]);\n    let w = (&u[..], &u[4..4], &u[4..4]);\n\n    assert_ne!(v, w);\n    assert_ne!(hash(&v), hash(&w));\n}\n\n#[test]\nfn test_write_short_works() {\n    let test_usize = 0xd0c0b0a0usize;\n    let mut h1 = SipHasher::new();\n    h1.write_usize(test_usize);\n    h1.write(b\"bytes\");\n    h1.write(b\"string\");\n    h1.write_u8(0xFFu8);\n    h1.write_u8(0x01u8);\n    let mut h2 = SipHasher::new();\n    h2.write(unsafe {\n        slice::from_raw_parts(&test_usize as *const _ as *const u8, mem::size_of::<usize>())\n    });\n    h2.write(b\"bytes\");\n    h2.write(b\"string\");\n    h2.write(&[0xFFu8, 0x01u8]);\n    assert_eq!(h1.finish(), h2.finish());\n}\n"],[2995,"use core::pin::Pin;\n\n#[test]\nfn pin_const() {\n    // test that the methods of `Pin` are usable in a const context\n\n    const POINTER: &'static usize = &2;\n\n    const PINNED: Pin<&'static usize> = Pin::new(POINTER);\n    const PINNED_UNCHECKED: Pin<&'static usize> = unsafe { Pin::new_unchecked(POINTER) };\n    assert_eq!(PINNED_UNCHECKED, PINNED);\n\n    const INNER: &'static usize = Pin::into_inner(PINNED);\n    assert_eq!(INNER, POINTER);\n\n    const INNER_UNCHECKED: &'static usize = unsafe { Pin::into_inner_unchecked(PINNED) };\n    assert_eq!(INNER_UNCHECKED, POINTER);\n\n    const REF: &'static usize = PINNED.get_ref();\n    assert_eq!(REF, POINTER);\n\n    // Note: `pin_mut_const` tests that the methods of `Pin<&mut T>` are usable in a const context.\n    // A const fn is used because `&mut` is not (yet) usable in constants.\n    const fn pin_mut_const() {\n        let _ = Pin::new(&mut 2).into_ref();\n        let _ = Pin::new(&mut 2).get_mut();\n        let _ = unsafe { Pin::new(&mut 2).get_unchecked_mut() };\n    }\n\n    pin_mut_const();\n}\n"],[2996,"use core::sync::atomic::Ordering::SeqCst;\nuse core::sync::atomic::*;\n\n#[test]\nfn bool_() {\n    let a = AtomicBool::new(false);\n    assert_eq!(a.compare_exchange(false, true, SeqCst, SeqCst), Ok(false));\n    assert_eq!(a.compare_exchange(false, true, SeqCst, SeqCst), Err(true));\n\n    a.store(false, SeqCst);\n    assert_eq!(a.compare_exchange(false, true, SeqCst, SeqCst), Ok(false));\n}\n\n#[test]\nfn bool_and() {\n    let a = AtomicBool::new(true);\n    assert_eq!(a.fetch_and(false, SeqCst), true);\n    assert_eq!(a.load(SeqCst), false);\n}\n\n#[test]\nfn bool_nand() {\n    let a = AtomicBool::new(false);\n    assert_eq!(a.fetch_nand(false, SeqCst), false);\n    assert_eq!(a.load(SeqCst), true);\n    assert_eq!(a.fetch_nand(false, SeqCst), true);\n    assert_eq!(a.load(SeqCst), true);\n    assert_eq!(a.fetch_nand(true, SeqCst), true);\n    assert_eq!(a.load(SeqCst), false);\n    assert_eq!(a.fetch_nand(true, SeqCst), false);\n    assert_eq!(a.load(SeqCst), true);\n}\n\n#[test]\nfn uint_and() {\n    let x = AtomicUsize::new(0xf731);\n    assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n}\n\n#[test]\nfn uint_nand() {\n    let x = AtomicUsize::new(0xf731);\n    assert_eq!(x.fetch_nand(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), !(0xf731 & 0x137f));\n}\n\n#[test]\nfn uint_or() {\n    let x = AtomicUsize::new(0xf731);\n    assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n}\n\n#[test]\nfn uint_xor() {\n    let x = AtomicUsize::new(0xf731);\n    assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n}\n\n#[test]\n#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\nfn uint_min() {\n    let x = AtomicUsize::new(0xf731);\n    assert_eq!(x.fetch_min(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0x137f);\n    assert_eq!(x.fetch_min(0xf731, SeqCst), 0x137f);\n    assert_eq!(x.load(SeqCst), 0x137f);\n}\n\n#[test]\n#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\nfn uint_max() {\n    let x = AtomicUsize::new(0x137f);\n    assert_eq!(x.fetch_max(0xf731, SeqCst), 0x137f);\n    assert_eq!(x.load(SeqCst), 0xf731);\n    assert_eq!(x.fetch_max(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0xf731);\n}\n\n#[test]\nfn int_and() {\n    let x = AtomicIsize::new(0xf731);\n    assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n}\n\n#[test]\nfn int_nand() {\n    let x = AtomicIsize::new(0xf731);\n    assert_eq!(x.fetch_nand(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), !(0xf731 & 0x137f));\n}\n\n#[test]\nfn int_or() {\n    let x = AtomicIsize::new(0xf731);\n    assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n}\n\n#[test]\nfn int_xor() {\n    let x = AtomicIsize::new(0xf731);\n    assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n}\n\n#[test]\n#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\nfn int_min() {\n    let x = AtomicIsize::new(0xf731);\n    assert_eq!(x.fetch_min(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0x137f);\n    assert_eq!(x.fetch_min(0xf731, SeqCst), 0x137f);\n    assert_eq!(x.load(SeqCst), 0x137f);\n}\n\n#[test]\n#[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\nfn int_max() {\n    let x = AtomicIsize::new(0x137f);\n    assert_eq!(x.fetch_max(0xf731, SeqCst), 0x137f);\n    assert_eq!(x.load(SeqCst), 0xf731);\n    assert_eq!(x.fetch_max(0x137f, SeqCst), 0xf731);\n    assert_eq!(x.load(SeqCst), 0xf731);\n}\n\nstatic S_FALSE: AtomicBool = AtomicBool::new(false);\nstatic S_TRUE: AtomicBool = AtomicBool::new(true);\nstatic S_INT: AtomicIsize = AtomicIsize::new(0);\nstatic S_UINT: AtomicUsize = AtomicUsize::new(0);\n\n#[test]\nfn static_init() {\n    // Note that we're not really testing the mutability here but it's important\n    // on Android at the moment (#49775)\n    assert!(!S_FALSE.swap(true, SeqCst));\n    assert!(S_TRUE.swap(false, SeqCst));\n    assert!(S_INT.fetch_add(1, SeqCst) == 0);\n    assert!(S_UINT.fetch_add(1, SeqCst) == 0);\n}\n\n#[test]\nfn atomic_access_bool() {\n    static mut ATOMIC: AtomicBool = AtomicBool::new(false);\n\n    unsafe {\n        assert_eq!(*ATOMIC.get_mut(), false);\n        ATOMIC.store(true, SeqCst);\n        assert_eq!(*ATOMIC.get_mut(), true);\n        ATOMIC.fetch_or(false, SeqCst);\n        assert_eq!(*ATOMIC.get_mut(), true);\n        ATOMIC.fetch_and(false, SeqCst);\n        assert_eq!(*ATOMIC.get_mut(), false);\n        ATOMIC.fetch_nand(true, SeqCst);\n        assert_eq!(*ATOMIC.get_mut(), true);\n        ATOMIC.fetch_xor(true, SeqCst);\n        assert_eq!(*ATOMIC.get_mut(), false);\n    }\n}\n\n#[test]\nfn atomic_alignment() {\n    use std::mem::{align_of, size_of};\n\n    #[cfg(target_has_atomic = \"8\")]\n    assert_eq!(align_of::<AtomicBool>(), size_of::<AtomicBool>());\n    #[cfg(target_has_atomic = \"ptr\")]\n    assert_eq!(align_of::<AtomicPtr<u8>>(), size_of::<AtomicPtr<u8>>());\n    #[cfg(target_has_atomic = \"8\")]\n    assert_eq!(align_of::<AtomicU8>(), size_of::<AtomicU8>());\n    #[cfg(target_has_atomic = \"8\")]\n    assert_eq!(align_of::<AtomicI8>(), size_of::<AtomicI8>());\n    #[cfg(target_has_atomic = \"16\")]\n    assert_eq!(align_of::<AtomicU16>(), size_of::<AtomicU16>());\n    #[cfg(target_has_atomic = \"16\")]\n    assert_eq!(align_of::<AtomicI16>(), size_of::<AtomicI16>());\n    #[cfg(target_has_atomic = \"32\")]\n    assert_eq!(align_of::<AtomicU32>(), size_of::<AtomicU32>());\n    #[cfg(target_has_atomic = \"32\")]\n    assert_eq!(align_of::<AtomicI32>(), size_of::<AtomicI32>());\n    #[cfg(target_has_atomic = \"64\")]\n    assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n    #[cfg(target_has_atomic = \"64\")]\n    assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n    #[cfg(target_has_atomic = \"128\")]\n    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n    #[cfg(target_has_atomic = \"128\")]\n    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n    #[cfg(target_has_atomic = \"ptr\")]\n    assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n    #[cfg(target_has_atomic = \"ptr\")]\n    assert_eq!(align_of::<AtomicIsize>(), size_of::<AtomicIsize>());\n}\n\n#[test]\nfn atomic_compare_exchange() {\n    use Ordering::*;\n\n    static ATOMIC: AtomicIsize = AtomicIsize::new(0);\n\n    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n}\n"],[2997,"use core::time::Duration;\n\n#[test]\nfn creation() {\n    assert_ne!(Duration::from_secs(1), Duration::from_secs(0));\n    assert_eq!(Duration::from_secs(1) + Duration::from_secs(2), Duration::from_secs(3));\n    assert_eq!(\n        Duration::from_millis(10) + Duration::from_secs(4),\n        Duration::new(4, 10 * 1_000_000)\n    );\n    assert_eq!(Duration::from_millis(4000), Duration::new(4, 0));\n}\n\n#[test]\n#[should_panic]\nfn new_overflow() {\n    let _ = Duration::new(u64::MAX, 1_000_000_000);\n}\n\n#[test]\nfn secs() {\n    assert_eq!(Duration::new(0, 0).as_secs(), 0);\n    assert_eq!(Duration::new(0, 500_000_005).as_secs(), 0);\n    assert_eq!(Duration::new(0, 1_050_000_001).as_secs(), 1);\n    assert_eq!(Duration::from_secs(1).as_secs(), 1);\n    assert_eq!(Duration::from_millis(999).as_secs(), 0);\n    assert_eq!(Duration::from_millis(1001).as_secs(), 1);\n    assert_eq!(Duration::from_micros(999_999).as_secs(), 0);\n    assert_eq!(Duration::from_micros(1_000_001).as_secs(), 1);\n    assert_eq!(Duration::from_nanos(999_999_999).as_secs(), 0);\n    assert_eq!(Duration::from_nanos(1_000_000_001).as_secs(), 1);\n}\n\n#[test]\nfn millis() {\n    assert_eq!(Duration::new(0, 0).subsec_millis(), 0);\n    assert_eq!(Duration::new(0, 500_000_005).subsec_millis(), 500);\n    assert_eq!(Duration::new(0, 1_050_000_001).subsec_millis(), 50);\n    assert_eq!(Duration::from_secs(1).subsec_millis(), 0);\n    assert_eq!(Duration::from_millis(999).subsec_millis(), 999);\n    assert_eq!(Duration::from_millis(1001).subsec_millis(), 1);\n    assert_eq!(Duration::from_micros(999_999).subsec_millis(), 999);\n    assert_eq!(Duration::from_micros(1_001_000).subsec_millis(), 1);\n    assert_eq!(Duration::from_nanos(999_999_999).subsec_millis(), 999);\n    assert_eq!(Duration::from_nanos(1_001_000_000).subsec_millis(), 1);\n}\n\n#[test]\nfn micros() {\n    assert_eq!(Duration::new(0, 0).subsec_micros(), 0);\n    assert_eq!(Duration::new(0, 500_000_005).subsec_micros(), 500_000);\n    assert_eq!(Duration::new(0, 1_050_000_001).subsec_micros(), 50_000);\n    assert_eq!(Duration::from_secs(1).subsec_micros(), 0);\n    assert_eq!(Duration::from_millis(999).subsec_micros(), 999_000);\n    assert_eq!(Duration::from_millis(1001).subsec_micros(), 1_000);\n    assert_eq!(Duration::from_micros(999_999).subsec_micros(), 999_999);\n    assert_eq!(Duration::from_micros(1_000_001).subsec_micros(), 1);\n    assert_eq!(Duration::from_nanos(999_999_999).subsec_micros(), 999_999);\n    assert_eq!(Duration::from_nanos(1_000_001_000).subsec_micros(), 1);\n}\n\n#[test]\nfn nanos() {\n    assert_eq!(Duration::new(0, 0).subsec_nanos(), 0);\n    assert_eq!(Duration::new(0, 5).subsec_nanos(), 5);\n    assert_eq!(Duration::new(0, 1_000_000_001).subsec_nanos(), 1);\n    assert_eq!(Duration::from_secs(1).subsec_nanos(), 0);\n    assert_eq!(Duration::from_millis(999).subsec_nanos(), 999_000_000);\n    assert_eq!(Duration::from_millis(1001).subsec_nanos(), 1_000_000);\n    assert_eq!(Duration::from_micros(999_999).subsec_nanos(), 999_999_000);\n    assert_eq!(Duration::from_micros(1_000_001).subsec_nanos(), 1000);\n    assert_eq!(Duration::from_nanos(999_999_999).subsec_nanos(), 999_999_999);\n    assert_eq!(Duration::from_nanos(1_000_000_001).subsec_nanos(), 1);\n}\n\n#[test]\nfn add() {\n    assert_eq!(Duration::new(0, 0) + Duration::new(0, 1), Duration::new(0, 1));\n    assert_eq!(Duration::new(0, 500_000_000) + Duration::new(0, 500_000_001), Duration::new(1, 1));\n}\n\n#[test]\nfn checked_add() {\n    assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)), Some(Duration::new(0, 1)));\n    assert_eq!(\n        Duration::new(0, 500_000_000).checked_add(Duration::new(0, 500_000_001)),\n        Some(Duration::new(1, 1))\n    );\n    assert_eq!(Duration::new(1, 0).checked_add(Duration::new(u64::MAX, 0)), None);\n}\n\n#[test]\nfn saturating_add() {\n    assert_eq!(Duration::new(0, 0).saturating_add(Duration::new(0, 1)), Duration::new(0, 1));\n    assert_eq!(\n        Duration::new(0, 500_000_000).saturating_add(Duration::new(0, 500_000_001)),\n        Duration::new(1, 1)\n    );\n    assert_eq!(Duration::new(1, 0).saturating_add(Duration::new(u64::MAX, 0)), Duration::MAX);\n}\n\n#[test]\nfn sub() {\n    assert_eq!(Duration::new(0, 1) - Duration::new(0, 0), Duration::new(0, 1));\n    assert_eq!(Duration::new(0, 500_000_001) - Duration::new(0, 500_000_000), Duration::new(0, 1));\n    assert_eq!(Duration::new(1, 0) - Duration::new(0, 1), Duration::new(0, 999_999_999));\n}\n\n#[test]\nfn checked_sub() {\n    assert_eq!(Duration::NANOSECOND.checked_sub(Duration::ZERO), Some(Duration::NANOSECOND));\n    assert_eq!(\n        Duration::SECOND.checked_sub(Duration::NANOSECOND),\n        Some(Duration::new(0, 999_999_999))\n    );\n    assert_eq!(Duration::ZERO.checked_sub(Duration::NANOSECOND), None);\n    assert_eq!(Duration::ZERO.checked_sub(Duration::SECOND), None);\n}\n\n#[test]\nfn saturating_sub() {\n    assert_eq!(Duration::NANOSECOND.saturating_sub(Duration::ZERO), Duration::NANOSECOND);\n    assert_eq!(\n        Duration::SECOND.saturating_sub(Duration::NANOSECOND),\n        Duration::new(0, 999_999_999)\n    );\n    assert_eq!(Duration::ZERO.saturating_sub(Duration::NANOSECOND), Duration::ZERO);\n    assert_eq!(Duration::ZERO.saturating_sub(Duration::SECOND), Duration::ZERO);\n}\n\n#[test]\n#[should_panic]\nfn sub_bad1() {\n    let _ = Duration::new(0, 0) - Duration::new(0, 1);\n}\n\n#[test]\n#[should_panic]\nfn sub_bad2() {\n    let _ = Duration::new(0, 0) - Duration::new(1, 0);\n}\n\n#[test]\nfn mul() {\n    assert_eq!(Duration::new(0, 1) * 2, Duration::new(0, 2));\n    assert_eq!(Duration::new(1, 1) * 3, Duration::new(3, 3));\n    assert_eq!(Duration::new(0, 500_000_001) * 4, Duration::new(2, 4));\n    assert_eq!(Duration::new(0, 500_000_001) * 4000, Duration::new(2000, 4000));\n}\n\n#[test]\nfn checked_mul() {\n    assert_eq!(Duration::new(0, 1).checked_mul(2), Some(Duration::new(0, 2)));\n    assert_eq!(Duration::new(1, 1).checked_mul(3), Some(Duration::new(3, 3)));\n    assert_eq!(Duration::new(0, 500_000_001).checked_mul(4), Some(Duration::new(2, 4)));\n    assert_eq!(Duration::new(0, 500_000_001).checked_mul(4000), Some(Duration::new(2000, 4000)));\n    assert_eq!(Duration::new(u64::MAX - 1, 0).checked_mul(2), None);\n}\n\n#[test]\nfn saturating_mul() {\n    assert_eq!(Duration::new(0, 1).saturating_mul(2), Duration::new(0, 2));\n    assert_eq!(Duration::new(1, 1).saturating_mul(3), Duration::new(3, 3));\n    assert_eq!(Duration::new(0, 500_000_001).saturating_mul(4), Duration::new(2, 4));\n    assert_eq!(Duration::new(0, 500_000_001).saturating_mul(4000), Duration::new(2000, 4000));\n    assert_eq!(Duration::new(u64::MAX - 1, 0).saturating_mul(2), Duration::MAX);\n}\n\n#[test]\nfn div() {\n    assert_eq!(Duration::new(0, 1) / 2, Duration::new(0, 0));\n    assert_eq!(Duration::new(1, 1) / 3, Duration::new(0, 333_333_333));\n    assert_eq!(Duration::new(99, 999_999_000) / 100, Duration::new(0, 999_999_990));\n}\n\n#[test]\nfn checked_div() {\n    assert_eq!(Duration::new(2, 0).checked_div(2), Some(Duration::new(1, 0)));\n    assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n    assert_eq!(Duration::new(2, 0).checked_div(0), None);\n}\n\n#[test]\nfn correct_sum() {\n    let durations = [\n        Duration::new(1, 999_999_999),\n        Duration::new(2, 999_999_999),\n        Duration::new(0, 999_999_999),\n        Duration::new(0, 999_999_999),\n        Duration::new(0, 999_999_999),\n        Duration::new(5, 0),\n    ];\n    let sum = durations.iter().sum::<Duration>();\n    assert_eq!(sum, Duration::new(1 + 2 + 5 + 4, 1_000_000_000 - 5));\n}\n\n#[test]\nfn debug_formatting_extreme_values() {\n    assert_eq!(\n        format!(\"{:?}\", Duration::new(18_446_744_073_709_551_615, 123_456_789)),\n        \"18446744073709551615.123456789s\"\n    );\n}\n\n#[test]\nfn debug_formatting_secs() {\n    assert_eq!(format!(\"{:?}\", Duration::new(7, 000_000_000)), \"7s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(7, 100_000_000)), \"7.1s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(7, 000_010_000)), \"7.00001s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(7, 000_000_001)), \"7.000000001s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(7, 123_456_789)), \"7.123456789s\");\n\n    assert_eq!(format!(\"{:?}\", Duration::new(88, 000_000_000)), \"88s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(88, 100_000_000)), \"88.1s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(88, 000_010_000)), \"88.00001s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(88, 000_000_001)), \"88.000000001s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(88, 123_456_789)), \"88.123456789s\");\n\n    assert_eq!(format!(\"{:?}\", Duration::new(999, 000_000_000)), \"999s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(999, 100_000_000)), \"999.1s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(999, 000_010_000)), \"999.00001s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(999, 000_000_001)), \"999.000000001s\");\n    assert_eq!(format!(\"{:?}\", Duration::new(999, 123_456_789)), \"999.123456789s\");\n}\n\n#[test]\nfn debug_formatting_millis() {\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_000_000)), \"7ms\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_100_000)), \"7.1ms\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_000_001)), \"7.000001ms\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_123_456)), \"7.123456ms\");\n\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_000_000)), \"88ms\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_100_000)), \"88.1ms\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_000_001)), \"88.000001ms\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_123_456)), \"88.123456ms\");\n\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_000_000)), \"999ms\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_100_000)), \"999.1ms\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_000_001)), \"999.000001ms\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_123_456)), \"999.123456ms\");\n}\n\n#[test]\nfn debug_formatting_micros() {\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_000)), \"7µs\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_100)), \"7.1µs\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_001)), \"7.001µs\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 7_123)), \"7.123µs\");\n\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_000)), \"88µs\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_100)), \"88.1µs\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_001)), \"88.001µs\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 88_123)), \"88.123µs\");\n\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_000)), \"999µs\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_100)), \"999.1µs\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_001)), \"999.001µs\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 999_123)), \"999.123µs\");\n}\n\n#[test]\nfn debug_formatting_nanos() {\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 0)), \"0ns\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 1)), \"1ns\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 88)), \"88ns\");\n    assert_eq!(format!(\"{:?}\", Duration::new(0, 999)), \"999ns\");\n}\n\n#[test]\nfn debug_formatting_precision_zero() {\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 0)), \"0ns\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 123)), \"123ns\");\n\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_001)), \"1µs\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_499)), \"1µs\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_500)), \"2µs\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_999)), \"2µs\");\n\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_000_001)), \"1ms\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_499_999)), \"1ms\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_500_000)), \"2ms\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(0, 1_999_999)), \"2ms\");\n\n    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 000_000_001)), \"1s\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 499_999_999)), \"1s\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 500_000_000)), \"2s\");\n    assert_eq!(format!(\"{:.0?}\", Duration::new(1, 999_999_999)), \"2s\");\n}\n\n#[test]\nfn debug_formatting_precision_two() {\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 0)), \"0.00ns\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 123)), \"123.00ns\");\n\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_000)), \"1.00µs\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_001)), \"7.00µs\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_100)), \"7.10µs\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_109)), \"7.11µs\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 7_199)), \"7.20µs\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_999)), \"2.00µs\");\n\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_000_000)), \"1.00ms\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 3_001_000)), \"3.00ms\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 3_100_000)), \"3.10ms\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(0, 1_999_999)), \"2.00ms\");\n\n    assert_eq!(format!(\"{:.2?}\", Duration::new(1, 000_000_000)), \"1.00s\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(4, 001_000_000)), \"4.00s\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(2, 100_000_000)), \"2.10s\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(2, 104_990_000)), \"2.10s\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(2, 105_000_000)), \"2.11s\");\n    assert_eq!(format!(\"{:.2?}\", Duration::new(8, 999_999_999)), \"9.00s\");\n}\n\n#[test]\nfn debug_formatting_precision_high() {\n    assert_eq!(format!(\"{:.5?}\", Duration::new(0, 23_678)), \"23.67800µs\");\n\n    assert_eq!(format!(\"{:.9?}\", Duration::new(1, 000_000_000)), \"1.000000000s\");\n    assert_eq!(format!(\"{:.10?}\", Duration::new(4, 001_000_000)), \"4.0010000000s\");\n    assert_eq!(format!(\"{:.20?}\", Duration::new(4, 001_000_000)), \"4.00100000000000000000s\");\n}\n\n#[test]\nfn duration_const() {\n    // test that the methods of `Duration` are usable in a const context\n\n    const DURATION: Duration = Duration::new(0, 123_456_789);\n\n    const SUB_SEC_MILLIS: u32 = DURATION.subsec_millis();\n    assert_eq!(SUB_SEC_MILLIS, 123);\n\n    const SUB_SEC_MICROS: u32 = DURATION.subsec_micros();\n    assert_eq!(SUB_SEC_MICROS, 123_456);\n\n    const SUB_SEC_NANOS: u32 = DURATION.subsec_nanos();\n    assert_eq!(SUB_SEC_NANOS, 123_456_789);\n\n    const IS_ZERO: bool = Duration::ZERO.is_zero();\n    assert!(IS_ZERO);\n\n    const SECONDS: u64 = Duration::SECOND.as_secs();\n    assert_eq!(SECONDS, 1);\n\n    const FROM_SECONDS: Duration = Duration::from_secs(1);\n    assert_eq!(FROM_SECONDS, Duration::SECOND);\n\n    const SECONDS_F32: f32 = Duration::SECOND.as_secs_f32();\n    assert_eq!(SECONDS_F32, 1.0);\n\n    const FROM_SECONDS_F32: Duration = Duration::from_secs_f32(1.0);\n    assert_eq!(FROM_SECONDS_F32, Duration::SECOND);\n\n    const SECONDS_F64: f64 = Duration::SECOND.as_secs_f64();\n    assert_eq!(SECONDS_F64, 1.0);\n\n    const FROM_SECONDS_F64: Duration = Duration::from_secs_f64(1.0);\n    assert_eq!(FROM_SECONDS_F64, Duration::SECOND);\n\n    const MILLIS: u128 = Duration::SECOND.as_millis();\n    assert_eq!(MILLIS, 1_000);\n\n    const FROM_MILLIS: Duration = Duration::from_millis(1_000);\n    assert_eq!(FROM_MILLIS, Duration::SECOND);\n\n    const MICROS: u128 = Duration::SECOND.as_micros();\n    assert_eq!(MICROS, 1_000_000);\n\n    const FROM_MICROS: Duration = Duration::from_micros(1_000_000);\n    assert_eq!(FROM_MICROS, Duration::SECOND);\n\n    const NANOS: u128 = Duration::SECOND.as_nanos();\n    assert_eq!(NANOS, 1_000_000_000);\n\n    const FROM_NANOS: Duration = Duration::from_nanos(1_000_000_000);\n    assert_eq!(FROM_NANOS, Duration::SECOND);\n\n    const MAX: Duration = Duration::new(u64::MAX, 999_999_999);\n\n    const CHECKED_ADD: Option<Duration> = MAX.checked_add(Duration::SECOND);\n    assert_eq!(CHECKED_ADD, None);\n\n    const CHECKED_SUB: Option<Duration> = Duration::ZERO.checked_sub(Duration::SECOND);\n    assert_eq!(CHECKED_SUB, None);\n\n    const CHECKED_MUL: Option<Duration> = Duration::SECOND.checked_mul(1);\n    assert_eq!(CHECKED_MUL, Some(Duration::SECOND));\n\n    const MUL_F32: Duration = Duration::SECOND.mul_f32(1.0);\n    assert_eq!(MUL_F32, Duration::SECOND);\n\n    const MUL_F64: Duration = Duration::SECOND.mul_f64(1.0);\n    assert_eq!(MUL_F64, Duration::SECOND);\n\n    const CHECKED_DIV: Option<Duration> = Duration::SECOND.checked_div(1);\n    assert_eq!(CHECKED_DIV, Some(Duration::SECOND));\n\n    const DIV_F32: Duration = Duration::SECOND.div_f32(1.0);\n    assert_eq!(DIV_F32, Duration::SECOND);\n\n    const DIV_F64: Duration = Duration::SECOND.div_f64(1.0);\n    assert_eq!(DIV_F64, Duration::SECOND);\n\n    const DIV_DURATION_F32: f32 = Duration::SECOND.div_duration_f32(Duration::SECOND);\n    assert_eq!(DIV_DURATION_F32, 1.0);\n\n    const DIV_DURATION_F64: f64 = Duration::SECOND.div_duration_f64(Duration::SECOND);\n    assert_eq!(DIV_DURATION_F64, 1.0);\n\n    const SATURATING_ADD: Duration = MAX.saturating_add(Duration::SECOND);\n    assert_eq!(SATURATING_ADD, MAX);\n\n    const SATURATING_SUB: Duration = Duration::ZERO.saturating_sub(Duration::SECOND);\n    assert_eq!(SATURATING_SUB, Duration::ZERO);\n\n    const SATURATING_MUL: Duration = MAX.saturating_mul(2);\n    assert_eq!(SATURATING_MUL, MAX);\n}\n"],[2998,"use core::any::*;\n\n#[derive(PartialEq, Debug)]\nstruct Test;\n\nstatic TEST: &'static str = \"Test\";\n\n#[test]\nfn any_referenced() {\n    let (a, b, c) = (&5 as &dyn Any, &TEST as &dyn Any, &Test as &dyn Any);\n\n    assert!(a.is::<i32>());\n    assert!(!b.is::<i32>());\n    assert!(!c.is::<i32>());\n\n    assert!(!a.is::<&'static str>());\n    assert!(b.is::<&'static str>());\n    assert!(!c.is::<&'static str>());\n\n    assert!(!a.is::<Test>());\n    assert!(!b.is::<Test>());\n    assert!(c.is::<Test>());\n}\n\n#[test]\nfn any_owning() {\n    let (a, b, c) =\n        (box 5_usize as Box<dyn Any>, box TEST as Box<dyn Any>, box Test as Box<dyn Any>);\n\n    assert!(a.is::<usize>());\n    assert!(!b.is::<usize>());\n    assert!(!c.is::<usize>());\n\n    assert!(!a.is::<&'static str>());\n    assert!(b.is::<&'static str>());\n    assert!(!c.is::<&'static str>());\n\n    assert!(!a.is::<Test>());\n    assert!(!b.is::<Test>());\n    assert!(c.is::<Test>());\n}\n\n#[test]\nfn any_downcast_ref() {\n    let a = &5_usize as &dyn Any;\n\n    match a.downcast_ref::<usize>() {\n        Some(&5) => {}\n        x => panic!(\"Unexpected value {:?}\", x),\n    }\n\n    match a.downcast_ref::<Test>() {\n        None => {}\n        x => panic!(\"Unexpected value {:?}\", x),\n    }\n}\n\n#[test]\nfn any_downcast_mut() {\n    let mut a = 5_usize;\n    let mut b: Box<_> = box 7_usize;\n\n    let a_r = &mut a as &mut dyn Any;\n    let tmp: &mut usize = &mut *b;\n    let b_r = tmp as &mut dyn Any;\n\n    match a_r.downcast_mut::<usize>() {\n        Some(x) => {\n            assert_eq!(*x, 5);\n            *x = 612;\n        }\n        x => panic!(\"Unexpected value {:?}\", x),\n    }\n\n    match b_r.downcast_mut::<usize>() {\n        Some(x) => {\n            assert_eq!(*x, 7);\n            *x = 413;\n        }\n        x => panic!(\"Unexpected value {:?}\", x),\n    }\n\n    match a_r.downcast_mut::<Test>() {\n        None => (),\n        x => panic!(\"Unexpected value {:?}\", x),\n    }\n\n    match b_r.downcast_mut::<Test>() {\n        None => (),\n        x => panic!(\"Unexpected value {:?}\", x),\n    }\n\n    match a_r.downcast_mut::<usize>() {\n        Some(&mut 612) => {}\n        x => panic!(\"Unexpected value {:?}\", x),\n    }\n\n    match b_r.downcast_mut::<usize>() {\n        Some(&mut 413) => {}\n        x => panic!(\"Unexpected value {:?}\", x),\n    }\n}\n\n#[test]\nfn any_fixed_vec() {\n    let test = [0_usize; 8];\n    let test = &test as &dyn Any;\n    assert!(test.is::<[usize; 8]>());\n    assert!(!test.is::<[usize; 10]>());\n}\n\n#[test]\nfn any_unsized() {\n    fn is_any<T: Any + ?Sized>() {}\n    is_any::<[i32]>();\n}\n\n#[test]\nfn distinct_type_names() {\n    // https://github.com/rust-lang/rust/issues/84666\n\n    struct Velocity(f32, f32);\n\n    fn type_name_of_val<T>(_: T) -> &'static str {\n        type_name::<T>()\n    }\n\n    assert_ne!(type_name_of_val(Velocity), type_name_of_val(Velocity(0.0, -9.8)),);\n}\n"],[2999,"use core::cell::Cell;\nuse core::clone::Clone;\nuse core::mem;\nuse core::ops::DerefMut;\nuse core::option::*;\n\n#[test]\nfn test_get_ptr() {\n    unsafe {\n        let x: Box<_> = box 0;\n        let addr_x: *const isize = mem::transmute(&*x);\n        let opt = Some(x);\n        let y = opt.unwrap();\n        let addr_y: *const isize = mem::transmute(&*y);\n        assert_eq!(addr_x, addr_y);\n    }\n}\n\n#[test]\nfn test_get_str() {\n    let x = \"test\".to_string();\n    let addr_x = x.as_ptr();\n    let opt = Some(x);\n    let y = opt.unwrap();\n    let addr_y = y.as_ptr();\n    assert_eq!(addr_x, addr_y);\n}\n\n#[test]\nfn test_get_resource() {\n    use core::cell::RefCell;\n    use std::rc::Rc;\n\n    struct R {\n        i: Rc<RefCell<isize>>,\n    }\n\n    impl Drop for R {\n        fn drop(&mut self) {\n            let ii = &*self.i;\n            let i = *ii.borrow();\n            *ii.borrow_mut() = i + 1;\n        }\n    }\n\n    fn r(i: Rc<RefCell<isize>>) -> R {\n        R { i }\n    }\n\n    let i = Rc::new(RefCell::new(0));\n    {\n        let x = r(i.clone());\n        let opt = Some(x);\n        let _y = opt.unwrap();\n    }\n    assert_eq!(*i.borrow(), 1);\n}\n\n#[test]\nfn test_option_dance() {\n    let x = Some(());\n    let mut y = Some(5);\n    let mut y2 = 0;\n    for _x in x {\n        y2 = y.take().unwrap();\n    }\n    assert_eq!(y2, 5);\n    assert!(y.is_none());\n}\n\n#[test]\n#[should_panic]\nfn test_option_too_much_dance() {\n    struct A;\n    let mut y = Some(A);\n    let _y2 = y.take().unwrap();\n    let _y3 = y.take().unwrap();\n}\n\n#[test]\nfn test_and() {\n    let x: Option<isize> = Some(1);\n    assert_eq!(x.and(Some(2)), Some(2));\n    assert_eq!(x.and(None::<isize>), None);\n\n    let x: Option<isize> = None;\n    assert_eq!(x.and(Some(2)), None);\n    assert_eq!(x.and(None::<isize>), None);\n}\n\n#[test]\nfn test_and_then() {\n    let x: Option<isize> = Some(1);\n    assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n    assert_eq!(x.and_then(|_| None::<isize>), None);\n\n    let x: Option<isize> = None;\n    assert_eq!(x.and_then(|x| Some(x + 1)), None);\n    assert_eq!(x.and_then(|_| None::<isize>), None);\n}\n\n#[test]\nfn test_or() {\n    let x: Option<isize> = Some(1);\n    assert_eq!(x.or(Some(2)), Some(1));\n    assert_eq!(x.or(None), Some(1));\n\n    let x: Option<isize> = None;\n    assert_eq!(x.or(Some(2)), Some(2));\n    assert_eq!(x.or(None), None);\n}\n\n#[test]\nfn test_or_else() {\n    let x: Option<isize> = Some(1);\n    assert_eq!(x.or_else(|| Some(2)), Some(1));\n    assert_eq!(x.or_else(|| None), Some(1));\n\n    let x: Option<isize> = None;\n    assert_eq!(x.or_else(|| Some(2)), Some(2));\n    assert_eq!(x.or_else(|| None), None);\n}\n\n#[test]\nfn test_unwrap() {\n    assert_eq!(Some(1).unwrap(), 1);\n    let s = Some(\"hello\".to_string()).unwrap();\n    assert_eq!(s, \"hello\");\n}\n\n#[test]\n#[should_panic]\nfn test_unwrap_panic1() {\n    let x: Option<isize> = None;\n    x.unwrap();\n}\n\n#[test]\n#[should_panic]\nfn test_unwrap_panic2() {\n    let x: Option<String> = None;\n    x.unwrap();\n}\n\n#[test]\nfn test_unwrap_or() {\n    let x: Option<isize> = Some(1);\n    assert_eq!(x.unwrap_or(2), 1);\n\n    let x: Option<isize> = None;\n    assert_eq!(x.unwrap_or(2), 2);\n}\n\n#[test]\nfn test_unwrap_or_else() {\n    let x: Option<isize> = Some(1);\n    assert_eq!(x.unwrap_or_else(|| 2), 1);\n\n    let x: Option<isize> = None;\n    assert_eq!(x.unwrap_or_else(|| 2), 2);\n}\n\n#[test]\nfn test_unwrap_unchecked() {\n    assert_eq!(unsafe { Some(1).unwrap_unchecked() }, 1);\n    let s = unsafe { Some(\"hello\".to_string()).unwrap_unchecked() };\n    assert_eq!(s, \"hello\");\n}\n\n#[test]\nfn test_iter() {\n    let val = 5;\n\n    let x = Some(val);\n    let mut it = x.iter();\n\n    assert_eq!(it.size_hint(), (1, Some(1)));\n    assert_eq!(it.next(), Some(&val));\n    assert_eq!(it.size_hint(), (0, Some(0)));\n    assert!(it.next().is_none());\n\n    let mut it = (&x).into_iter();\n    assert_eq!(it.next(), Some(&val));\n}\n\n#[test]\nfn test_mut_iter() {\n    let mut val = 5;\n    let new_val = 11;\n\n    let mut x = Some(val);\n    {\n        let mut it = x.iter_mut();\n\n        assert_eq!(it.size_hint(), (1, Some(1)));\n\n        match it.next() {\n            Some(interior) => {\n                assert_eq!(*interior, val);\n                *interior = new_val;\n            }\n            None => assert!(false),\n        }\n\n        assert_eq!(it.size_hint(), (0, Some(0)));\n        assert!(it.next().is_none());\n    }\n    assert_eq!(x, Some(new_val));\n\n    let mut y = Some(val);\n    let mut it = (&mut y).into_iter();\n    assert_eq!(it.next(), Some(&mut val));\n}\n\n#[test]\nfn test_ord() {\n    let small = Some(1.0f64);\n    let big = Some(5.0f64);\n    let nan = Some(0.0f64 / 0.0);\n    assert!(!(nan < big));\n    assert!(!(nan > big));\n    assert!(small < big);\n    assert!(None < big);\n    assert!(big > None);\n}\n\n#[test]\nfn test_collect() {\n    let v: Option<Vec<isize>> = (0..0).map(|_| Some(0)).collect();\n    assert!(v == Some(vec![]));\n\n    let v: Option<Vec<isize>> = (0..3).map(|x| Some(x)).collect();\n    assert!(v == Some(vec![0, 1, 2]));\n\n    let v: Option<Vec<isize>> = (0..3).map(|x| if x > 1 { None } else { Some(x) }).collect();\n    assert!(v == None);\n\n    // test that it does not take more elements than it needs\n    let mut functions: [Box<dyn Fn() -> Option<()>>; 3] =\n        [box || Some(()), box || None, box || panic!()];\n\n    let v: Option<Vec<()>> = functions.iter_mut().map(|f| (*f)()).collect();\n\n    assert!(v == None);\n}\n\n#[test]\nfn test_copied() {\n    let val = 1;\n    let val_ref = &val;\n    let opt_none: Option<&'static u32> = None;\n    let opt_ref = Some(&val);\n    let opt_ref_ref = Some(&val_ref);\n\n    // None works\n    assert_eq!(opt_none.clone(), None);\n    assert_eq!(opt_none.copied(), None);\n\n    // Immutable ref works\n    assert_eq!(opt_ref.clone(), Some(&val));\n    assert_eq!(opt_ref.copied(), Some(1));\n\n    // Double Immutable ref works\n    assert_eq!(opt_ref_ref.clone(), Some(&val_ref));\n    assert_eq!(opt_ref_ref.clone().copied(), Some(&val));\n    assert_eq!(opt_ref_ref.copied().copied(), Some(1));\n}\n\n#[test]\nfn test_cloned() {\n    let val = 1;\n    let val_ref = &val;\n    let opt_none: Option<&'static u32> = None;\n    let opt_ref = Some(&val);\n    let opt_ref_ref = Some(&val_ref);\n\n    // None works\n    assert_eq!(opt_none.clone(), None);\n    assert_eq!(opt_none.cloned(), None);\n\n    // Immutable ref works\n    assert_eq!(opt_ref.clone(), Some(&val));\n    assert_eq!(opt_ref.cloned(), Some(1));\n\n    // Double Immutable ref works\n    assert_eq!(opt_ref_ref.clone(), Some(&val_ref));\n    assert_eq!(opt_ref_ref.clone().cloned(), Some(&val));\n    assert_eq!(opt_ref_ref.cloned().cloned(), Some(1));\n}\n\n#[test]\nfn test_try() {\n    fn try_option_some() -> Option<u8> {\n        let val = Some(1)?;\n        Some(val)\n    }\n    assert_eq!(try_option_some(), Some(1));\n\n    fn try_option_none() -> Option<u8> {\n        let val = None?;\n        Some(val)\n    }\n    assert_eq!(try_option_none(), None);\n}\n\n#[test]\nfn test_option_as_deref() {\n    // Some: &Option<T: Deref>::Some(T) -> Option<&T::Deref::Target>::Some(&*T)\n    let ref_option = &Some(&42);\n    assert_eq!(ref_option.as_deref(), Some(&42));\n\n    let ref_option = &Some(String::from(\"a result\"));\n    assert_eq!(ref_option.as_deref(), Some(\"a result\"));\n\n    let ref_option = &Some(vec![1, 2, 3, 4, 5]);\n    assert_eq!(ref_option.as_deref(), Some([1, 2, 3, 4, 5].as_slice()));\n\n    // None: &Option<T: Deref>>::None -> None\n    let ref_option: &Option<&i32> = &None;\n    assert_eq!(ref_option.as_deref(), None);\n}\n\n#[test]\nfn test_option_as_deref_mut() {\n    // Some: &mut Option<T: Deref>::Some(T) -> Option<&mut T::Deref::Target>::Some(&mut *T)\n    let mut val = 42;\n    let ref_option = &mut Some(&mut val);\n    assert_eq!(ref_option.as_deref_mut(), Some(&mut 42));\n\n    let ref_option = &mut Some(String::from(\"a result\"));\n    assert_eq!(ref_option.as_deref_mut(), Some(String::from(\"a result\").deref_mut()));\n\n    let ref_option = &mut Some(vec![1, 2, 3, 4, 5]);\n    assert_eq!(ref_option.as_deref_mut(), Some([1, 2, 3, 4, 5].as_mut_slice()));\n\n    // None: &mut Option<T: Deref>>::None -> None\n    let ref_option: &mut Option<&mut i32> = &mut None;\n    assert_eq!(ref_option.as_deref_mut(), None);\n}\n\n#[test]\nfn test_replace() {\n    let mut x = Some(2);\n    let old = x.replace(5);\n\n    assert_eq!(x, Some(5));\n    assert_eq!(old, Some(2));\n\n    let mut x = None;\n    let old = x.replace(3);\n\n    assert_eq!(x, Some(3));\n    assert_eq!(old, None);\n}\n\n#[test]\nfn option_const() {\n    // test that the methods of `Option` are usable in a const context\n\n    const OPTION: Option<usize> = Some(32);\n\n    const REF: Option<&usize> = OPTION.as_ref();\n    assert_eq!(REF, Some(&32));\n\n    const IS_SOME: bool = OPTION.is_some();\n    assert!(IS_SOME);\n\n    const IS_NONE: bool = OPTION.is_none();\n    assert!(!IS_NONE);\n}\n\n#[test]\nfn test_unwrap_drop() {\n    struct Dtor<'a> {\n        x: &'a Cell<isize>,\n    }\n\n    impl<'a> std::ops::Drop for Dtor<'a> {\n        fn drop(&mut self) {\n            self.x.set(self.x.get() - 1);\n        }\n    }\n\n    fn unwrap<T>(o: Option<T>) -> T {\n        match o {\n            Some(v) => v,\n            None => panic!(),\n        }\n    }\n\n    let x = &Cell::new(1);\n\n    {\n        let b = Some(Dtor { x });\n        let _c = unwrap(b);\n    }\n\n    assert_eq!(x.get(), 0);\n}\n\n#[test]\npub fn option_ext() {\n    let thing = \"{{ f }}\";\n    let f = thing.find(\"{{\");\n\n    if f.is_none() {\n        println!(\"None!\");\n    }\n}\n"],[3000,"use core::task::Poll;\n\n#[test]\nfn poll_const() {\n    // test that the methods of `Poll` are usable in a const context\n\n    const POLL: Poll<usize> = Poll::Pending;\n\n    const IS_READY: bool = POLL.is_ready();\n    assert!(!IS_READY);\n\n    const IS_PENDING: bool = POLL.is_pending();\n    assert!(IS_PENDING);\n}\n"],[3001,"// All `str` tests live in liballoc/tests\n"],[3002,"use core::ops::*;\nuse test::Bencher;\n\n// Overhead of dtors\n\nstruct HasDtor {\n    _x: isize,\n}\n\nimpl Drop for HasDtor {\n    fn drop(&mut self) {}\n}\n\n#[bench]\nfn alloc_obj_with_dtor(b: &mut Bencher) {\n    b.iter(|| {\n        HasDtor { _x: 10 };\n    })\n}\n"],[3003,"mod is_ascii;\n\n// Lower-case ASCII 'a' is the first byte that has its highest bit set\n// after wrap-adding 0x1F:\n//\n//     b'a' + 0x1F == 0x80 == 0b1000_0000\n//     b'z' + 0x1F == 0x98 == 0b1001_1000\n//\n// Lower-case ASCII 'z' is the last byte that has its highest bit unset\n// after wrap-adding 0x05:\n//\n//     b'a' + 0x05 == 0x66 == 0b0110_0110\n//     b'z' + 0x05 == 0x7F == 0b0111_1111\n//\n// … except for 0xFB to 0xFF, but those are in the range of bytes\n// that have the highest bit unset again after adding 0x1F.\n//\n// So `(byte + 0x1f) & !(byte + 5)` has its highest bit set\n// iff `byte` is a lower-case ASCII letter.\n//\n// Lower-case ASCII letters all have the 0x20 bit set.\n// (Two positions right of 0x80, the highest bit.)\n// Unsetting that bit produces the same letter, in upper-case.\n//\n// Therefore:\nfn branchless_to_ascii_upper_case(byte: u8) -> u8 {\n    byte & !((byte.wrapping_add(0x1f) & !byte.wrapping_add(0x05) & 0x80) >> 2)\n}\n\nmacro_rules! benches {\n    ($( fn $name: ident($arg: ident: &mut [u8]) $body: block )+ @iter $( $is_: ident, )+) => {\n        benches! {@\n            $( fn $name($arg: &mut [u8]) $body )+\n            $( fn $is_(bytes: &mut [u8]) { bytes.iter().all(u8::$is_) } )+\n        }\n    };\n\n    (@$( fn $name: ident($arg: ident: &mut [u8]) $body: block )+) => {\n        benches!(mod short SHORT $($name $arg $body)+);\n        benches!(mod medium MEDIUM $($name $arg $body)+);\n        benches!(mod long LONG $($name $arg $body)+);\n    };\n\n    (mod $mod_name: ident $input: ident $($name: ident $arg: ident $body: block)+) => {\n        mod $mod_name {\n            use super::*;\n\n            $(\n                #[bench]\n                fn $name(bencher: &mut Bencher) {\n                    bencher.bytes = $input.len() as u64;\n                    bencher.iter(|| {\n                        let mut vec = $input.as_bytes().to_vec();\n                        {\n                            let $arg = &mut vec[..];\n                            black_box($body);\n                        }\n                        vec\n                    })\n                }\n            )+\n        }\n    }\n}\n\nuse test::black_box;\nuse test::Bencher;\n\nconst ASCII_CASE_MASK: u8 = 0b0010_0000;\n\nbenches! {\n    fn case00_alloc_only(_bytes: &mut [u8]) {}\n\n    fn case01_black_box_read_each_byte(bytes: &mut [u8]) {\n        for byte in bytes {\n            black_box(*byte);\n        }\n    }\n\n    fn case02_lookup_table(bytes: &mut [u8]) {\n        for byte in bytes {\n            *byte = ASCII_UPPERCASE_MAP[*byte as usize]\n        }\n    }\n\n    fn case03_branch_and_subtract(bytes: &mut [u8]) {\n        for byte in bytes {\n            *byte = if b'a' <= *byte && *byte <= b'z' {\n                *byte - b'a' + b'A'\n            } else {\n                *byte\n            }\n        }\n    }\n\n    fn case04_branch_and_mask(bytes: &mut [u8]) {\n        for byte in bytes {\n            *byte = if b'a' <= *byte && *byte <= b'z' {\n                *byte & !0x20\n            } else {\n                *byte\n            }\n        }\n    }\n\n    fn case05_branchless(bytes: &mut [u8]) {\n        for byte in bytes {\n            *byte = branchless_to_ascii_upper_case(*byte)\n        }\n    }\n\n    fn case06_libcore(bytes: &mut [u8]) {\n        bytes.make_ascii_uppercase()\n    }\n\n    fn case07_fake_simd_u32(bytes: &mut [u8]) {\n        // SAFETY: transmuting a sequence of `u8` to `u32` is always fine\n        let (before, aligned, after) = unsafe {\n            bytes.align_to_mut::<u32>()\n        };\n        for byte in before {\n            *byte = branchless_to_ascii_upper_case(*byte)\n        }\n        for word in aligned {\n            // FIXME: this is incorrect for some byte values:\n            // addition within a byte can carry/overflow into the next byte.\n            // Test case: b\"\\xFFz  \"\n            *word &= !(\n                (\n                    word.wrapping_add(0x1f1f1f1f) &\n                    !word.wrapping_add(0x05050505) &\n                    0x80808080\n                ) >> 2\n            )\n        }\n        for byte in after {\n            *byte = branchless_to_ascii_upper_case(*byte)\n        }\n    }\n\n    fn case08_fake_simd_u64(bytes: &mut [u8]) {\n        // SAFETY: transmuting a sequence of `u8` to `u64` is always fine\n        let (before, aligned, after) = unsafe {\n            bytes.align_to_mut::<u64>()\n        };\n        for byte in before {\n            *byte = branchless_to_ascii_upper_case(*byte)\n        }\n        for word in aligned {\n            // FIXME: like above, this is incorrect for some byte values.\n            *word &= !(\n                (\n                    word.wrapping_add(0x1f1f1f1f_1f1f1f1f) &\n                    !word.wrapping_add(0x05050505_05050505) &\n                    0x80808080_80808080\n                ) >> 2\n            )\n        }\n        for byte in after {\n            *byte = branchless_to_ascii_upper_case(*byte)\n        }\n    }\n\n    fn case09_mask_mult_bool_branchy_lookup_table(bytes: &mut [u8]) {\n        fn is_ascii_lowercase(b: u8) -> bool {\n            if b >= 0x80 { return false }\n            match ASCII_CHARACTER_CLASS[b as usize] {\n                L | Lx => true,\n                _ => false,\n            }\n        }\n        for byte in bytes {\n            *byte &= !(0x20 * (is_ascii_lowercase(*byte) as u8))\n        }\n    }\n\n    fn case10_mask_mult_bool_lookup_table(bytes: &mut [u8]) {\n        fn is_ascii_lowercase(b: u8) -> bool {\n            match ASCII_CHARACTER_CLASS[b as usize] {\n                L | Lx => true,\n                _ => false\n            }\n        }\n        for byte in bytes {\n            *byte &= !(0x20 * (is_ascii_lowercase(*byte) as u8))\n        }\n    }\n\n    fn case11_mask_mult_bool_match_range(bytes: &mut [u8]) {\n        fn is_ascii_lowercase(b: u8) -> bool {\n            match b {\n                b'a'..=b'z' => true,\n                _ => false\n            }\n        }\n        for byte in bytes {\n            *byte &= !(0x20 * (is_ascii_lowercase(*byte) as u8))\n        }\n    }\n\n    fn case12_mask_shifted_bool_match_range(bytes: &mut [u8]) {\n        fn is_ascii_lowercase(b: u8) -> bool {\n            match b {\n                b'a'..=b'z' => true,\n                _ => false\n            }\n        }\n        for byte in bytes {\n            *byte &= !((is_ascii_lowercase(*byte) as u8) * ASCII_CASE_MASK)\n        }\n    }\n\n    fn case13_subtract_shifted_bool_match_range(bytes: &mut [u8]) {\n        fn is_ascii_lowercase(b: u8) -> bool {\n            match b {\n                b'a'..=b'z' => true,\n                _ => false\n            }\n        }\n        for byte in bytes {\n            *byte -= (is_ascii_lowercase(*byte) as u8) * ASCII_CASE_MASK\n        }\n    }\n\n    fn case14_subtract_multiplied_bool_match_range(bytes: &mut [u8]) {\n        fn is_ascii_lowercase(b: u8) -> bool {\n            match b {\n                b'a'..=b'z' => true,\n                _ => false\n            }\n        }\n        for byte in bytes {\n            *byte -= (b'a' - b'A') * is_ascii_lowercase(*byte) as u8\n        }\n    }\n\n    @iter\n\n    is_ascii,\n    is_ascii_alphabetic,\n    is_ascii_uppercase,\n    is_ascii_lowercase,\n    is_ascii_alphanumeric,\n    is_ascii_digit,\n    is_ascii_hexdigit,\n    is_ascii_punctuation,\n    is_ascii_graphic,\n    is_ascii_whitespace,\n    is_ascii_control,\n}\n\nmacro_rules! repeat {\n    ($s: expr) => {\n        concat!($s, $s, $s, $s, $s, $s, $s, $s, $s, $s)\n    };\n}\n\nconst SHORT: &str = \"Alice's\";\nconst MEDIUM: &str = \"Alice's Adventures in Wonderland\";\nconst LONG: &str = repeat!(\n    r#\"\n    La Guida di Bragia, a Ballad Opera for the Marionette Theatre (around 1850)\n    Alice's Adventures in Wonderland (1865)\n    Phantasmagoria and Other Poems (1869)\n    Through the Looking-Glass, and What Alice Found There\n        (includes \"Jabberwocky\" and \"The Walrus and the Carpenter\") (1871)\n    The Hunting of the Snark (1876)\n    Rhyme? And Reason? (1883) – shares some contents with the 1869 collection,\n        including the long poem \"Phantasmagoria\"\n    A Tangled Tale (1885)\n    Sylvie and Bruno (1889)\n    Sylvie and Bruno Concluded (1893)\n    Pillow Problems (1893)\n    What the Tortoise Said to Achilles (1895)\n    Three Sunsets and Other Poems (1898)\n    The Manlet (1903)[106]\n\"#\n);\n\n#[rustfmt::skip]\nconst ASCII_UPPERCASE_MAP: [u8; 256] = [\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n    b'`',\n\n          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n    b'X', b'Y', b'Z',\n\n                      b'{', b'|', b'}', b'~', 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n];\n\nenum AsciiCharacterClass {\n    C,  // control\n    Cw, // control whitespace\n    W,  // whitespace\n    D,  // digit\n    L,  // lowercase\n    Lx, // lowercase hex digit\n    U,  // uppercase\n    Ux, // uppercase hex digit\n    P,  // punctuation\n    N,  // Non-ASCII\n}\nuse self::AsciiCharacterClass::*;\n\n#[rustfmt::skip]\nstatic ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 256] = [\n//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n];\n"],[3004,"use test::black_box;\nuse test::Bencher;\n\n#[bench]\nfn starts_with_char(b: &mut Bencher) {\n    let text = black_box(\"kdjsfhlakfhlsghlkvcnljknfqiunvcijqenwodind\");\n    b.iter(|| {\n        for _ in 0..1024 {\n            black_box(text.starts_with('k'));\n        }\n    })\n}\n\n#[bench]\nfn starts_with_str(b: &mut Bencher) {\n    let text = black_box(\"kdjsfhlakfhlsghlkvcnljknfqiunvcijqenwodind\");\n    b.iter(|| {\n        for _ in 0..1024 {\n            black_box(text.starts_with(\"k\"));\n        }\n    })\n}\n\n#[bench]\nfn ends_with_char(b: &mut Bencher) {\n    let text = black_box(\"kdjsfhlakfhlsghlkvcnljknfqiunvcijqenwodind\");\n    b.iter(|| {\n        for _ in 0..1024 {\n            black_box(text.ends_with('k'));\n        }\n    })\n}\n\n#[bench]\nfn ends_with_str(b: &mut Bencher) {\n    let text = black_box(\"kdjsfhlakfhlsghlkvcnljknfqiunvcijqenwodind\");\n    b.iter(|| {\n        for _ in 0..1024 {\n            black_box(text.ends_with(\"k\"));\n        }\n    })\n}\n"],[3005,"// wasm32 does not support benches (no time).\n#![cfg(not(target_arch = \"wasm32\"))]\n#![feature(flt2dec)]\n#![feature(test)]\n\nextern crate test;\n\nmod any;\nmod ascii;\nmod char;\nmod fmt;\nmod hash;\nmod iter;\nmod num;\nmod ops;\nmod pattern;\nmod slice;\n"],[3006,"mod strategy {\n    mod dragon;\n    mod grisu;\n}\n\nuse core::num::flt2dec::MAX_SIG_DIGITS;\nuse core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\nuse std::io::Write;\nuse std::vec::Vec;\nuse test::Bencher;\n\npub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n    match decode(v).1 {\n        FullDecoded::Finite(decoded) => decoded,\n        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded),\n    }\n}\n\n#[bench]\nfn bench_small_shortest(b: &mut Bencher) {\n    let mut buf = Vec::with_capacity(20);\n\n    b.iter(|| {\n        buf.clear();\n        write!(&mut buf, \"{}\", 3.1415926f64).unwrap()\n    });\n}\n\n#[bench]\nfn bench_big_shortest(b: &mut Bencher) {\n    let mut buf = Vec::with_capacity(300);\n\n    b.iter(|| {\n        buf.clear();\n        write!(&mut buf, \"{}\", f64::MAX).unwrap()\n    });\n}\n"],[3007,"use super::super::*;\nuse core::num::flt2dec::strategy::grisu::*;\nuse std::mem::MaybeUninit;\nuse test::Bencher;\n\npub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n    match decode(v).1 {\n        FullDecoded::Finite(decoded) => decoded,\n        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded),\n    }\n}\n\n#[bench]\nfn bench_small_shortest(b: &mut Bencher) {\n    let decoded = decode_finite(3.141592f64);\n    let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n    b.iter(|| {\n        format_shortest(&decoded, &mut buf);\n    });\n}\n\n#[bench]\nfn bench_big_shortest(b: &mut Bencher) {\n    let decoded = decode_finite(f64::MAX);\n    let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n    b.iter(|| {\n        format_shortest(&decoded, &mut buf);\n    });\n}\n\n#[bench]\nfn bench_small_exact_3(b: &mut Bencher) {\n    let decoded = decode_finite(3.141592f64);\n    let mut buf = [MaybeUninit::new(0); 3];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_big_exact_3(b: &mut Bencher) {\n    let decoded = decode_finite(f64::MAX);\n    let mut buf = [MaybeUninit::new(0); 3];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_small_exact_12(b: &mut Bencher) {\n    let decoded = decode_finite(3.141592f64);\n    let mut buf = [MaybeUninit::new(0); 12];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_big_exact_12(b: &mut Bencher) {\n    let decoded = decode_finite(f64::MAX);\n    let mut buf = [MaybeUninit::new(0); 12];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_small_exact_inf(b: &mut Bencher) {\n    let decoded = decode_finite(3.141592f64);\n    let mut buf = [MaybeUninit::new(0); 1024];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_big_exact_inf(b: &mut Bencher) {\n    let decoded = decode_finite(f64::MAX);\n    let mut buf = [MaybeUninit::new(0); 1024];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n"],[3008,"use super::super::*;\nuse core::num::flt2dec::strategy::dragon::*;\nuse std::mem::MaybeUninit;\nuse test::Bencher;\n\n#[bench]\nfn bench_small_shortest(b: &mut Bencher) {\n    let decoded = decode_finite(3.141592f64);\n    let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n    b.iter(|| {\n        format_shortest(&decoded, &mut buf);\n    });\n}\n\n#[bench]\nfn bench_big_shortest(b: &mut Bencher) {\n    let decoded = decode_finite(f64::MAX);\n    let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n    b.iter(|| {\n        format_shortest(&decoded, &mut buf);\n    });\n}\n\n#[bench]\nfn bench_small_exact_3(b: &mut Bencher) {\n    let decoded = decode_finite(3.141592f64);\n    let mut buf = [MaybeUninit::new(0); 3];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_big_exact_3(b: &mut Bencher) {\n    let decoded = decode_finite(f64::MAX);\n    let mut buf = [MaybeUninit::new(0); 3];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_small_exact_12(b: &mut Bencher) {\n    let decoded = decode_finite(3.141592f64);\n    let mut buf = [MaybeUninit::new(0); 12];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_big_exact_12(b: &mut Bencher) {\n    let decoded = decode_finite(f64::MAX);\n    let mut buf = [MaybeUninit::new(0); 12];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_small_exact_inf(b: &mut Bencher) {\n    let decoded = decode_finite(3.141592f64);\n    let mut buf = [MaybeUninit::new(0); 1024];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n\n#[bench]\nfn bench_big_exact_inf(b: &mut Bencher) {\n    let decoded = decode_finite(f64::MAX);\n    let mut buf = [MaybeUninit::new(0); 1024];\n    b.iter(|| {\n        format_exact(&decoded, &mut buf, i16::MIN);\n    });\n}\n"],[3009,"mod dec2flt;\nmod flt2dec;\n\nuse std::str::FromStr;\nuse test::Bencher;\n\nconst ASCII_NUMBERS: [&str; 19] = [\n    \"0\",\n    \"1\",\n    \"2\",\n    \"43\",\n    \"765\",\n    \"76567\",\n    \"987245987\",\n    \"-4aa32\",\n    \"1786235\",\n    \"8723095\",\n    \"f##5s\",\n    \"83638730\",\n    \"-2345\",\n    \"562aa43\",\n    \"-1\",\n    \"-0\",\n    \"abc\",\n    \"xyz\",\n    \"c0ffee\",\n];\n\nmacro_rules! from_str_bench {\n    ($mac:ident, $t:ty) => {\n        #[bench]\n        fn $mac(b: &mut Bencher) {\n            b.iter(|| {\n                ASCII_NUMBERS\n                    .iter()\n                    .cycle()\n                    .take(5_000)\n                    .filter_map(|s| <$t>::from_str(s).ok())\n                    .max()\n            })\n        }\n    };\n}\n\nmacro_rules! from_str_radix_bench {\n    ($mac:ident, $t:ty, $radix:expr) => {\n        #[bench]\n        fn $mac(b: &mut Bencher) {\n            b.iter(|| {\n                ASCII_NUMBERS\n                    .iter()\n                    .cycle()\n                    .take(5_000)\n                    .filter_map(|s| <$t>::from_str_radix(s, $radix).ok())\n                    .max()\n            })\n        }\n    };\n}\n\nfrom_str_bench!(bench_u8_from_str, u8);\nfrom_str_radix_bench!(bench_u8_from_str_radix_2, u8, 2);\nfrom_str_radix_bench!(bench_u8_from_str_radix_10, u8, 10);\nfrom_str_radix_bench!(bench_u8_from_str_radix_16, u8, 16);\nfrom_str_radix_bench!(bench_u8_from_str_radix_36, u8, 36);\n\nfrom_str_bench!(bench_u16_from_str, u16);\nfrom_str_radix_bench!(bench_u16_from_str_radix_2, u16, 2);\nfrom_str_radix_bench!(bench_u16_from_str_radix_10, u16, 10);\nfrom_str_radix_bench!(bench_u16_from_str_radix_16, u16, 16);\nfrom_str_radix_bench!(bench_u16_from_str_radix_36, u16, 36);\n\nfrom_str_bench!(bench_u32_from_str, u32);\nfrom_str_radix_bench!(bench_u32_from_str_radix_2, u32, 2);\nfrom_str_radix_bench!(bench_u32_from_str_radix_10, u32, 10);\nfrom_str_radix_bench!(bench_u32_from_str_radix_16, u32, 16);\nfrom_str_radix_bench!(bench_u32_from_str_radix_36, u32, 36);\n\nfrom_str_bench!(bench_u64_from_str, u64);\nfrom_str_radix_bench!(bench_u64_from_str_radix_2, u64, 2);\nfrom_str_radix_bench!(bench_u64_from_str_radix_10, u64, 10);\nfrom_str_radix_bench!(bench_u64_from_str_radix_16, u64, 16);\nfrom_str_radix_bench!(bench_u64_from_str_radix_36, u64, 36);\n\nfrom_str_bench!(bench_i8_from_str, i8);\nfrom_str_radix_bench!(bench_i8_from_str_radix_2, i8, 2);\nfrom_str_radix_bench!(bench_i8_from_str_radix_10, i8, 10);\nfrom_str_radix_bench!(bench_i8_from_str_radix_16, i8, 16);\nfrom_str_radix_bench!(bench_i8_from_str_radix_36, i8, 36);\n\nfrom_str_bench!(bench_i16_from_str, i16);\nfrom_str_radix_bench!(bench_i16_from_str_radix_2, i16, 2);\nfrom_str_radix_bench!(bench_i16_from_str_radix_10, i16, 10);\nfrom_str_radix_bench!(bench_i16_from_str_radix_16, i16, 16);\nfrom_str_radix_bench!(bench_i16_from_str_radix_36, i16, 36);\n\nfrom_str_bench!(bench_i32_from_str, i32);\nfrom_str_radix_bench!(bench_i32_from_str_radix_2, i32, 2);\nfrom_str_radix_bench!(bench_i32_from_str_radix_10, i32, 10);\nfrom_str_radix_bench!(bench_i32_from_str_radix_16, i32, 16);\nfrom_str_radix_bench!(bench_i32_from_str_radix_36, i32, 36);\n\nfrom_str_bench!(bench_i64_from_str, i64);\nfrom_str_radix_bench!(bench_i64_from_str_radix_2, i64, 2);\nfrom_str_radix_bench!(bench_i64_from_str_radix_10, i64, 10);\nfrom_str_radix_bench!(bench_i64_from_str_radix_16, i64, 16);\nfrom_str_radix_bench!(bench_i64_from_str_radix_36, i64, 36);\n"],[3010,"use test::Bencher;\n\n#[bench]\nfn bench_0(b: &mut Bencher) {\n    b.iter(|| \"0.0\".parse::<f64>());\n}\n\n#[bench]\nfn bench_42(b: &mut Bencher) {\n    b.iter(|| \"42\".parse::<f64>());\n}\n\n#[bench]\nfn bench_huge_int(b: &mut Bencher) {\n    // 2^128 - 1\n    b.iter(|| \"170141183460469231731687303715884105727\".parse::<f64>());\n}\n\n#[bench]\nfn bench_short_decimal(b: &mut Bencher) {\n    b.iter(|| \"1234.5678\".parse::<f64>());\n}\n\n#[bench]\nfn bench_pi_long(b: &mut Bencher) {\n    b.iter(|| \"3.14159265358979323846264338327950288\".parse::<f64>());\n}\n\n#[bench]\nfn bench_pi_short(b: &mut Bencher) {\n    b.iter(|| \"3.141592653589793\".parse::<f64>())\n}\n\n#[bench]\nfn bench_1e150(b: &mut Bencher) {\n    b.iter(|| \"1e150\".parse::<f64>());\n}\n\n#[bench]\nfn bench_long_decimal_and_exp(b: &mut Bencher) {\n    b.iter(|| \"727501488517303786137132964064381141071e-123\".parse::<f64>());\n}\n\n#[bench]\nfn bench_min_subnormal(b: &mut Bencher) {\n    b.iter(|| \"5e-324\".parse::<f64>());\n}\n\n#[bench]\nfn bench_min_normal(b: &mut Bencher) {\n    b.iter(|| \"2.2250738585072014e-308\".parse::<f64>());\n}\n\n#[bench]\nfn bench_max(b: &mut Bencher) {\n    b.iter(|| \"1.7976931348623157e308\".parse::<f64>());\n}\n"],[3011,"use std::fmt::{self, Write as FmtWrite};\nuse std::io::{self, Write as IoWrite};\nuse test::Bencher;\n\n#[bench]\nfn write_vec_value(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = Vec::new();\n        for _ in 0..1000 {\n            mem.write_all(\"abc\".as_bytes()).unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_vec_ref(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = Vec::new();\n        let wr = &mut mem as &mut dyn io::Write;\n        for _ in 0..1000 {\n            wr.write_all(\"abc\".as_bytes()).unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_vec_macro1(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = Vec::new();\n        let wr = &mut mem as &mut dyn io::Write;\n        for _ in 0..1000 {\n            write!(wr, \"abc\").unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_vec_macro2(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = Vec::new();\n        let wr = &mut mem as &mut dyn io::Write;\n        for _ in 0..1000 {\n            write!(wr, \"{}\", \"abc\").unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_vec_macro_debug(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = Vec::new();\n        let wr = &mut mem as &mut dyn io::Write;\n        for _ in 0..1000 {\n            write!(wr, \"{:?}\", \"☃\").unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_str_value(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = String::new();\n        for _ in 0..1000 {\n            mem.write_str(\"abc\").unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_str_ref(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = String::new();\n        let wr = &mut mem as &mut dyn fmt::Write;\n        for _ in 0..1000 {\n            wr.write_str(\"abc\").unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_str_macro1(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = String::new();\n        for _ in 0..1000 {\n            write!(mem, \"abc\").unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_str_macro2(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = String::new();\n        let wr = &mut mem as &mut dyn fmt::Write;\n        for _ in 0..1000 {\n            write!(wr, \"{}\", \"abc\").unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_str_macro_debug(bh: &mut Bencher) {\n    bh.iter(|| {\n        let mut mem = String::new();\n        let wr = &mut mem as &mut dyn fmt::Write;\n        for _ in 0..1000 {\n            write!(wr, \"{:?}\", \"☃\").unwrap();\n        }\n    });\n}\n\n#[bench]\nfn write_u128_max(bh: &mut Bencher) {\n    bh.iter(|| {\n        test::black_box(format!(\"{}\", u128::MAX));\n    });\n}\n\n#[bench]\nfn write_u128_min(bh: &mut Bencher) {\n    bh.iter(|| {\n        let s = format!(\"{}\", 0u128);\n        test::black_box(s);\n    });\n}\n\n#[bench]\nfn write_u64_max(bh: &mut Bencher) {\n    bh.iter(|| {\n        test::black_box(format!(\"{}\", u64::MAX));\n    });\n}\n\n#[bench]\nfn write_u64_min(bh: &mut Bencher) {\n    bh.iter(|| {\n        test::black_box(format!(\"{}\", 0u64));\n    });\n}\n"],[3012,"mod methods;\n"],[3013,"use test::Bencher;\n\nconst CHARS: [char; 9] = ['0', 'x', '2', '5', 'A', 'f', '7', '8', '9'];\nconst RADIX: [u32; 5] = [2, 8, 10, 16, 32];\n\n#[bench]\nfn bench_to_digit_radix_2(b: &mut Bencher) {\n    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(2)).min())\n}\n\n#[bench]\nfn bench_to_digit_radix_10(b: &mut Bencher) {\n    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(10)).min())\n}\n\n#[bench]\nfn bench_to_digit_radix_16(b: &mut Bencher) {\n    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(16)).min())\n}\n\n#[bench]\nfn bench_to_digit_radix_36(b: &mut Bencher) {\n    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(36)).min())\n}\n\n#[bench]\nfn bench_to_digit_radix_var(b: &mut Bencher) {\n    b.iter(|| {\n        CHARS\n            .iter()\n            .cycle()\n            .zip(RADIX.iter().cycle())\n            .take(10_000)\n            .map(|(c, radix)| c.to_digit(*radix))\n            .min()\n    })\n}\n\n#[bench]\nfn bench_to_ascii_uppercase(b: &mut Bencher) {\n    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_ascii_uppercase()).min())\n}\n\n#[bench]\nfn bench_to_ascii_lowercase(b: &mut Bencher) {\n    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_ascii_lowercase()).min())\n}\n\n#[bench]\nfn bench_ascii_mix_to_uppercase(b: &mut Bencher) {\n    b.iter(|| (0..=255).cycle().take(10_000).map(|b| char::from(b).to_uppercase()).count())\n}\n\n#[bench]\nfn bench_ascii_mix_to_lowercase(b: &mut Bencher) {\n    b.iter(|| (0..=255).cycle().take(10_000).map(|b| char::from(b).to_lowercase()).count())\n}\n\n#[bench]\nfn bench_ascii_char_to_uppercase(b: &mut Bencher) {\n    b.iter(|| (0..=127).cycle().take(10_000).map(|b| char::from(b).to_uppercase()).count())\n}\n\n#[bench]\nfn bench_ascii_char_to_lowercase(b: &mut Bencher) {\n    b.iter(|| (0..=127).cycle().take(10_000).map(|b| char::from(b).to_lowercase()).count())\n}\n\n#[bench]\nfn bench_non_ascii_char_to_uppercase(b: &mut Bencher) {\n    b.iter(|| (128..=255).cycle().take(10_000).map(|b| char::from(b).to_uppercase()).count())\n}\n\n#[bench]\nfn bench_non_ascii_char_to_lowercase(b: &mut Bencher) {\n    b.iter(|| (128..=255).cycle().take(10_000).map(|b| char::from(b).to_lowercase()).count())\n}\n"],[3014,"use core::iter::*;\nuse test::{black_box, Bencher};\n\n#[bench]\nfn bench_rposition(b: &mut Bencher) {\n    let it: Vec<usize> = (0..300).collect();\n    b.iter(|| {\n        it.iter().rposition(|&x| x <= 150);\n    });\n}\n\n#[bench]\nfn bench_skip_while(b: &mut Bencher) {\n    b.iter(|| {\n        let it = 0..100;\n        let mut sum = 0;\n        it.skip_while(|&x| {\n            sum += x;\n            sum < 4000\n        })\n        .all(|_| true);\n    });\n}\n\n#[bench]\nfn bench_multiple_take(b: &mut Bencher) {\n    let mut it = (0..42).cycle();\n    b.iter(|| {\n        let n = it.next().unwrap();\n        for _ in 0..n {\n            it.clone().take(it.next().unwrap()).all(|_| true);\n        }\n    });\n}\n\nfn scatter(x: i32) -> i32 {\n    (x * 31) % 127\n}\n\n#[bench]\nfn bench_max_by_key(b: &mut Bencher) {\n    b.iter(|| {\n        let it = 0..100;\n        it.map(black_box).max_by_key(|&x| scatter(x))\n    })\n}\n\n// https://www.reddit.com/r/rust/comments/31syce/using_iterators_to_find_the_index_of_the_min_or/\n#[bench]\nfn bench_max_by_key2(b: &mut Bencher) {\n    fn max_index_iter(array: &[i32]) -> usize {\n        array.iter().enumerate().max_by_key(|&(_, item)| item).unwrap().0\n    }\n\n    let mut data = vec![0; 1638];\n    data[514] = 9999;\n\n    b.iter(|| max_index_iter(&data));\n}\n\n#[bench]\nfn bench_max(b: &mut Bencher) {\n    b.iter(|| {\n        let it = 0..100;\n        it.map(black_box).map(scatter).max()\n    })\n}\n\npub fn copy_zip(xs: &[u8], ys: &mut [u8]) {\n    for (a, b) in ys.iter_mut().zip(xs) {\n        *a = *b;\n    }\n}\n\npub fn add_zip(xs: &[f32], ys: &mut [f32]) {\n    for (a, b) in ys.iter_mut().zip(xs) {\n        *a += *b;\n    }\n}\n\n#[bench]\nfn bench_zip_copy(b: &mut Bencher) {\n    let source = vec![0u8; 16 * 1024];\n    let mut dst = black_box(vec![0u8; 16 * 1024]);\n    b.iter(|| copy_zip(&source, &mut dst))\n}\n\n#[bench]\nfn bench_zip_add(b: &mut Bencher) {\n    let source = vec![1.; 16 * 1024];\n    let mut dst = vec![0.; 16 * 1024];\n    b.iter(|| add_zip(&source, &mut dst));\n}\n\n/// `Iterator::for_each` implemented as a plain loop.\nfn for_each_loop<I, F>(iter: I, mut f: F)\nwhere\n    I: Iterator,\n    F: FnMut(I::Item),\n{\n    for item in iter {\n        f(item);\n    }\n}\n\n/// `Iterator::for_each` implemented with `fold` for internal iteration.\n/// (except when `by_ref()` effectively disables that optimization.)\nfn for_each_fold<I, F>(iter: I, mut f: F)\nwhere\n    I: Iterator,\n    F: FnMut(I::Item),\n{\n    iter.fold((), move |(), item| f(item));\n}\n\n#[bench]\nfn bench_for_each_chain_loop(b: &mut Bencher) {\n    b.iter(|| {\n        let mut acc = 0;\n        let iter = (0i64..1000000).chain(0..1000000).map(black_box);\n        for_each_loop(iter, |x| acc += x);\n        acc\n    });\n}\n\n#[bench]\nfn bench_for_each_chain_fold(b: &mut Bencher) {\n    b.iter(|| {\n        let mut acc = 0;\n        let iter = (0i64..1000000).chain(0..1000000).map(black_box);\n        for_each_fold(iter, |x| acc += x);\n        acc\n    });\n}\n\n#[bench]\nfn bench_for_each_chain_ref_fold(b: &mut Bencher) {\n    b.iter(|| {\n        let mut acc = 0;\n        let mut iter = (0i64..1000000).chain(0..1000000).map(black_box);\n        for_each_fold(iter.by_ref(), |x| acc += x);\n        acc\n    });\n}\n\n/// Helper to benchmark `sum` for iterators taken by value which\n/// can optimize `fold`, and by reference which cannot.\nmacro_rules! bench_sums {\n    ($bench_sum:ident, $bench_ref_sum:ident, $iter:expr) => {\n        #[bench]\n        fn $bench_sum(b: &mut Bencher) {\n            b.iter(|| -> i64 { $iter.map(black_box).sum() });\n        }\n\n        #[bench]\n        fn $bench_ref_sum(b: &mut Bencher) {\n            b.iter(|| -> i64 { $iter.map(black_box).by_ref().sum() });\n        }\n    };\n}\n\nbench_sums! {\n    bench_flat_map_sum,\n    bench_flat_map_ref_sum,\n    (0i64..1000).flat_map(|x| x..x+1000)\n}\n\nbench_sums! {\n    bench_flat_map_chain_sum,\n    bench_flat_map_chain_ref_sum,\n    (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n}\n\nbench_sums! {\n    bench_enumerate_sum,\n    bench_enumerate_ref_sum,\n    (0i64..1000000).enumerate().map(|(i, x)| x * i as i64)\n}\n\nbench_sums! {\n    bench_enumerate_chain_sum,\n    bench_enumerate_chain_ref_sum,\n    (0i64..1000000).chain(0..1000000).enumerate().map(|(i, x)| x * i as i64)\n}\n\nbench_sums! {\n    bench_filter_sum,\n    bench_filter_ref_sum,\n    (0i64..1000000).filter(|x| x % 3 == 0)\n}\n\nbench_sums! {\n    bench_filter_chain_sum,\n    bench_filter_chain_ref_sum,\n    (0i64..1000000).chain(0..1000000).filter(|x| x % 3 == 0)\n}\n\nbench_sums! {\n    bench_filter_map_sum,\n    bench_filter_map_ref_sum,\n    (0i64..1000000).filter_map(|x| x.checked_mul(x))\n}\n\nbench_sums! {\n    bench_filter_map_chain_sum,\n    bench_filter_map_chain_ref_sum,\n    (0i64..1000000).chain(0..1000000).filter_map(|x| x.checked_mul(x))\n}\n\nbench_sums! {\n    bench_fuse_sum,\n    bench_fuse_ref_sum,\n    (0i64..1000000).fuse()\n}\n\nbench_sums! {\n    bench_fuse_chain_sum,\n    bench_fuse_chain_ref_sum,\n    (0i64..1000000).chain(0..1000000).fuse()\n}\n\nbench_sums! {\n    bench_inspect_sum,\n    bench_inspect_ref_sum,\n    (0i64..1000000).inspect(|_| {})\n}\n\nbench_sums! {\n    bench_inspect_chain_sum,\n    bench_inspect_chain_ref_sum,\n    (0i64..1000000).chain(0..1000000).inspect(|_| {})\n}\n\nbench_sums! {\n    bench_peekable_sum,\n    bench_peekable_ref_sum,\n    (0i64..1000000).peekable()\n}\n\nbench_sums! {\n    bench_peekable_chain_sum,\n    bench_peekable_chain_ref_sum,\n    (0i64..1000000).chain(0..1000000).peekable()\n}\n\nbench_sums! {\n    bench_skip_sum,\n    bench_skip_ref_sum,\n    (0i64..1000000).skip(1000)\n}\n\nbench_sums! {\n    bench_skip_chain_sum,\n    bench_skip_chain_ref_sum,\n    (0i64..1000000).chain(0..1000000).skip(1000)\n}\n\nbench_sums! {\n    bench_skip_while_sum,\n    bench_skip_while_ref_sum,\n    (0i64..1000000).skip_while(|&x| x < 1000)\n}\n\nbench_sums! {\n    bench_skip_while_chain_sum,\n    bench_skip_while_chain_ref_sum,\n    (0i64..1000000).chain(0..1000000).skip_while(|&x| x < 1000)\n}\n\nbench_sums! {\n    bench_take_while_chain_sum,\n    bench_take_while_chain_ref_sum,\n    (0i64..1000000).chain(1000000..).take_while(|&x| x < 1111111)\n}\n\nbench_sums! {\n    bench_cycle_take_sum,\n    bench_cycle_take_ref_sum,\n    (0..10000).cycle().take(1000000)\n}\n\nbench_sums! {\n    bench_cycle_skip_take_sum,\n    bench_cycle_skip_take_ref_sum,\n    (0..100000).cycle().skip(1000000).take(1000000)\n}\n\nbench_sums! {\n    bench_cycle_take_skip_sum,\n    bench_cycle_take_skip_ref_sum,\n    (0..100000).cycle().take(1000000).skip(100000)\n}\n\nbench_sums! {\n    bench_skip_cycle_skip_zip_add_sum,\n    bench_skip_cycle_skip_zip_add_ref_sum,\n    (0..100000).skip(100).cycle().skip(100)\n      .zip((0..100000).cycle().skip(10))\n      .map(|(a,b)| a+b)\n      .skip(100000)\n      .take(1000000)\n}\n\n// Checks whether Skip<Zip<A,B>> is as fast as Zip<Skip<A>, Skip<B>>, from\n// https://users.rust-lang.org/t/performance-difference-between-iterator-zip-and-skip-order/15743\n#[bench]\nfn bench_zip_then_skip(b: &mut Bencher) {\n    let v: Vec<_> = (0..100_000).collect();\n    let t: Vec<_> = (0..100_000).collect();\n\n    b.iter(|| {\n        let s = v\n            .iter()\n            .zip(t.iter())\n            .skip(10000)\n            .take_while(|t| *t.0 < 10100)\n            .map(|(a, b)| *a + *b)\n            .sum::<u64>();\n        assert_eq!(s, 2009900);\n    });\n}\n#[bench]\nfn bench_skip_then_zip(b: &mut Bencher) {\n    let v: Vec<_> = (0..100_000).collect();\n    let t: Vec<_> = (0..100_000).collect();\n\n    b.iter(|| {\n        let s = v\n            .iter()\n            .skip(10000)\n            .zip(t.iter().skip(10000))\n            .take_while(|t| *t.0 < 10100)\n            .map(|(a, b)| *a + *b)\n            .sum::<u64>();\n        assert_eq!(s, 2009900);\n    });\n}\n\n#[bench]\nfn bench_filter_count(b: &mut Bencher) {\n    b.iter(|| (0i64..1000000).map(black_box).filter(|x| x % 3 == 0).count())\n}\n\n#[bench]\nfn bench_filter_ref_count(b: &mut Bencher) {\n    b.iter(|| (0i64..1000000).map(black_box).by_ref().filter(|x| x % 3 == 0).count())\n}\n\n#[bench]\nfn bench_filter_chain_count(b: &mut Bencher) {\n    b.iter(|| (0i64..1000000).chain(0..1000000).map(black_box).filter(|x| x % 3 == 0).count())\n}\n\n#[bench]\nfn bench_filter_chain_ref_count(b: &mut Bencher) {\n    b.iter(|| {\n        (0i64..1000000).chain(0..1000000).map(black_box).by_ref().filter(|x| x % 3 == 0).count()\n    })\n}\n\n#[bench]\nfn bench_partial_cmp(b: &mut Bencher) {\n    b.iter(|| (0..100000).map(black_box).partial_cmp((0..100000).map(black_box)))\n}\n\n#[bench]\nfn bench_lt(b: &mut Bencher) {\n    b.iter(|| (0..100000).map(black_box).lt((0..100000).map(black_box)))\n}\n"],[3015,"use super::{LONG, MEDIUM, SHORT};\nuse test::black_box;\nuse test::Bencher;\n\nmacro_rules! benches {\n    ($( fn $name: ident($arg: ident: &[u8]) $body: block )+) => {\n        benches!(mod short SHORT[..] $($name $arg $body)+);\n        benches!(mod medium MEDIUM[..] $($name $arg $body)+);\n        benches!(mod long LONG[..] $($name $arg $body)+);\n        // Ensure we benchmark cases where the functions are called with strings\n        // that are not perfectly aligned or have a length which is not a\n        // multiple of size_of::<usize>() (or both)\n        benches!(mod unaligned_head MEDIUM[1..] $($name $arg $body)+);\n        benches!(mod unaligned_tail MEDIUM[..(MEDIUM.len() - 1)] $($name $arg $body)+);\n        benches!(mod unaligned_both MEDIUM[1..(MEDIUM.len() - 1)] $($name $arg $body)+);\n    };\n\n    (mod $mod_name: ident $input: ident [$range: expr] $($name: ident $arg: ident $body: block)+) => {\n        mod $mod_name {\n            use super::*;\n            $(\n                #[bench]\n                fn $name(bencher: &mut Bencher) {\n                    bencher.bytes = $input[$range].len() as u64;\n                    let mut vec = $input.as_bytes().to_vec();\n                    bencher.iter(|| {\n                        let $arg: &[u8] = &black_box(&mut vec)[$range];\n                        black_box($body)\n                    })\n                }\n            )+\n        }\n    };\n}\n\nbenches! {\n    fn case00_libcore(bytes: &[u8]) {\n        bytes.is_ascii()\n    }\n\n    fn case01_iter_all(bytes: &[u8]) {\n        bytes.iter().all(|b| b.is_ascii())\n    }\n\n    fn case02_align_to(bytes: &[u8]) {\n        is_ascii_align_to(bytes)\n    }\n\n    fn case03_align_to_unrolled(bytes: &[u8]) {\n        is_ascii_align_to_unrolled(bytes)\n    }\n}\n\n// These are separate since it's easier to debug errors if they don't go through\n// macro expansion first.\nfn is_ascii_align_to(bytes: &[u8]) -> bool {\n    if bytes.len() < core::mem::size_of::<usize>() {\n        return bytes.iter().all(|b| b.is_ascii());\n    }\n    // SAFETY: transmuting a sequence of `u8` to `usize` is always fine\n    let (head, body, tail) = unsafe { bytes.align_to::<usize>() };\n    head.iter().all(|b| b.is_ascii())\n        && body.iter().all(|w| !contains_nonascii(*w))\n        && tail.iter().all(|b| b.is_ascii())\n}\n\nfn is_ascii_align_to_unrolled(bytes: &[u8]) -> bool {\n    if bytes.len() < core::mem::size_of::<usize>() {\n        return bytes.iter().all(|b| b.is_ascii());\n    }\n    // SAFETY: transmuting a sequence of `u8` to `[usize; 2]` is always fine\n    let (head, body, tail) = unsafe { bytes.align_to::<[usize; 2]>() };\n    head.iter().all(|b| b.is_ascii())\n        && body.iter().all(|w| !contains_nonascii(w[0] | w[1]))\n        && tail.iter().all(|b| b.is_ascii())\n}\n\n#[inline]\nfn contains_nonascii(v: usize) -> bool {\n    const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n    (NONASCII_MASK & v) != 0\n}\n"],[3016,"use core::any::*;\nuse test::{black_box, Bencher};\n\n#[bench]\nfn bench_downcast_ref(b: &mut Bencher) {\n    b.iter(|| {\n        let mut x = 0;\n        let mut y = &mut x as &mut dyn Any;\n        black_box(&mut y);\n        black_box(y.downcast_ref::<isize>() == Some(&0));\n    });\n}\n"],[3017,"use test::black_box;\nuse test::Bencher;\n\nenum Cache {\n    L1,\n    L2,\n    L3,\n}\n\nimpl Cache {\n    fn size(&self) -> usize {\n        match self {\n            Cache::L1 => 1000,      // 8kb\n            Cache::L2 => 10_000,    // 80kb\n            Cache::L3 => 1_000_000, // 8Mb\n        }\n    }\n}\n\nfn binary_search<F>(b: &mut Bencher, cache: Cache, mapper: F)\nwhere\n    F: Fn(usize) -> usize,\n{\n    let size = cache.size();\n    let v = (0..size).map(&mapper).collect::<Vec<_>>();\n    let mut r = 0usize;\n    b.iter(move || {\n        // LCG constants from https://en.wikipedia.org/wiki/Numerical_Recipes.\n        r = r.wrapping_mul(1664525).wrapping_add(1013904223);\n        // Lookup the whole range to get 50% hits and 50% misses.\n        let i = mapper(r % size);\n        black_box(v.binary_search(&i).is_ok());\n    });\n}\n\nfn binary_search_worst_case(b: &mut Bencher, cache: Cache) {\n    let size = cache.size();\n\n    let mut v = vec![0; size];\n    let i = 1;\n    v[size - 1] = i;\n    b.iter(move || {\n        black_box(v.binary_search(&i).is_ok());\n    });\n}\n\n#[bench]\nfn binary_search_l1(b: &mut Bencher) {\n    binary_search(b, Cache::L1, |i| i * 2);\n}\n\n#[bench]\nfn binary_search_l2(b: &mut Bencher) {\n    binary_search(b, Cache::L2, |i| i * 2);\n}\n\n#[bench]\nfn binary_search_l3(b: &mut Bencher) {\n    binary_search(b, Cache::L3, |i| i * 2);\n}\n\n#[bench]\nfn binary_search_l1_with_dups(b: &mut Bencher) {\n    binary_search(b, Cache::L1, |i| i / 16 * 16);\n}\n\n#[bench]\nfn binary_search_l2_with_dups(b: &mut Bencher) {\n    binary_search(b, Cache::L2, |i| i / 16 * 16);\n}\n\n#[bench]\nfn binary_search_l3_with_dups(b: &mut Bencher) {\n    binary_search(b, Cache::L3, |i| i / 16 * 16);\n}\n\n#[bench]\nfn binary_search_l1_worst_case(b: &mut Bencher) {\n    binary_search_worst_case(b, Cache::L1);\n}\n\n#[bench]\nfn binary_search_l2_worst_case(b: &mut Bencher) {\n    binary_search_worst_case(b, Cache::L2);\n}\n\n#[bench]\nfn binary_search_l3_worst_case(b: &mut Bencher) {\n    binary_search_worst_case(b, Cache::L3);\n}\n\nmacro_rules! rotate {\n    ($fn:ident, $n:expr, $mapper:expr) => {\n        #[bench]\n        fn $fn(b: &mut Bencher) {\n            let mut x = (0usize..$n).map(&$mapper).collect::<Vec<_>>();\n            b.iter(|| {\n                for s in 0..x.len() {\n                    x[..].rotate_right(s);\n                }\n                black_box(x[0].clone())\n            })\n        }\n    };\n}\n\n#[derive(Clone)]\nstruct Rgb(u8, u8, u8);\n\nrotate!(rotate_u8, 32, |i| i as u8);\nrotate!(rotate_rgb, 32, |i| Rgb(i as u8, (i as u8).wrapping_add(7), (i as u8).wrapping_add(42)));\nrotate!(rotate_usize, 32, |i| i);\nrotate!(rotate_16_usize_4, 16, |i| [i; 4]);\nrotate!(rotate_16_usize_5, 16, |i| [i; 5]);\nrotate!(rotate_64_usize_4, 64, |i| [i; 4]);\nrotate!(rotate_64_usize_5, 64, |i| [i; 5]);\n\n#[bench]\nfn fill_byte_sized(b: &mut Bencher) {\n    #[derive(Copy, Clone)]\n    struct NewType(u8);\n\n    let mut ary = [NewType(0); 1024];\n\n    b.iter(|| {\n        let slice = &mut ary[..];\n        black_box(slice.fill(black_box(NewType(42))));\n    });\n}\n"],[3018,"#![allow(deprecated)]\n\nuse core::hash::*;\nuse test::{black_box, Bencher};\n\nfn hash_bytes<H: Hasher>(mut s: H, x: &[u8]) -> u64 {\n    Hasher::write(&mut s, x);\n    s.finish()\n}\n\nfn hash_with<H: Hasher, T: Hash>(mut st: H, x: &T) -> u64 {\n    x.hash(&mut st);\n    st.finish()\n}\n\nfn hash<T: Hash>(x: &T) -> u64 {\n    hash_with(SipHasher::new(), x)\n}\n\n#[bench]\nfn bench_str_under_8_bytes(b: &mut Bencher) {\n    let s = \"foo\";\n    b.iter(|| {\n        assert_eq!(hash(&s), 16262950014981195938);\n    })\n}\n\n#[bench]\nfn bench_str_of_8_bytes(b: &mut Bencher) {\n    let s = \"foobar78\";\n    b.iter(|| {\n        assert_eq!(hash(&s), 4898293253460910787);\n    })\n}\n\n#[bench]\nfn bench_str_over_8_bytes(b: &mut Bencher) {\n    let s = \"foobarbaz0\";\n    b.iter(|| {\n        assert_eq!(hash(&s), 10581415515220175264);\n    })\n}\n\n#[bench]\nfn bench_long_str(b: &mut Bencher) {\n    let s = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor \\\n             incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud \\\n             exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute \\\n             irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla \\\n             pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \\\n             officia deserunt mollit anim id est laborum.\";\n    b.iter(|| {\n        assert_eq!(hash(&s), 17717065544121360093);\n    })\n}\n\n#[bench]\nfn bench_u32(b: &mut Bencher) {\n    let u = 162629500u32;\n    let u = black_box(u);\n    b.iter(|| hash(&u));\n    b.bytes = 8;\n}\n\n#[bench]\nfn bench_u32_keyed(b: &mut Bencher) {\n    let u = 162629500u32;\n    let u = black_box(u);\n    let k1 = black_box(0x1);\n    let k2 = black_box(0x2);\n    b.iter(|| hash_with(SipHasher::new_with_keys(k1, k2), &u));\n    b.bytes = 8;\n}\n\n#[bench]\nfn bench_u64(b: &mut Bencher) {\n    let u = 16262950014981195938u64;\n    let u = black_box(u);\n    b.iter(|| hash(&u));\n    b.bytes = 8;\n}\n\n#[bench]\nfn bench_bytes_4(b: &mut Bencher) {\n    let data = black_box([b' '; 4]);\n    b.iter(|| hash_bytes(SipHasher::default(), &data));\n    b.bytes = 4;\n}\n\n#[bench]\nfn bench_bytes_7(b: &mut Bencher) {\n    let data = black_box([b' '; 7]);\n    b.iter(|| hash_bytes(SipHasher::default(), &data));\n    b.bytes = 7;\n}\n\n#[bench]\nfn bench_bytes_8(b: &mut Bencher) {\n    let data = black_box([b' '; 8]);\n    b.iter(|| hash_bytes(SipHasher::default(), &data));\n    b.bytes = 8;\n}\n\n#[bench]\nfn bench_bytes_a_16(b: &mut Bencher) {\n    let data = black_box([b' '; 16]);\n    b.iter(|| hash_bytes(SipHasher::default(), &data));\n    b.bytes = 16;\n}\n\n#[bench]\nfn bench_bytes_b_32(b: &mut Bencher) {\n    let data = black_box([b' '; 32]);\n    b.iter(|| hash_bytes(SipHasher::default(), &data));\n    b.bytes = 32;\n}\n\n#[bench]\nfn bench_bytes_c_128(b: &mut Bencher) {\n    let data = black_box([b' '; 128]);\n    b.iter(|| hash_bytes(SipHasher::default(), &data));\n    b.bytes = 128;\n}\n"],[3019,"mod sip;\n"]]}}