{"files_changed":[["2408","//! Support for \"weak linkage\" to symbols on Unix\n//!\n//! Some I/O operations we do in libstd require newer versions of OSes but we\n//! need to maintain binary compatibility with older releases for now. In order\n//! to use the new functionality when available we use this module for\n//! detection.\n//!\n//! One option to use here is weak linkage, but that is unfortunately only\n//! really workable on Linux. Hence, use dlsym to get the symbol value at\n//! runtime. This is also done for compatibility with older versions of glibc,\n//! and to avoid creating dependencies on GLIBC_PRIVATE symbols. It assumes that\n//! we've been dynamically linked to the library the symbol comes from, but that\n//! is currently always the case for things like libpthread/libc.\n//!\n//! A long time ago this used weak linkage for the __pthread_get_minstack\n//! symbol, but that caused Debian to detect an unnecessarily strict versioned\n//! dependency on libc6 (#23628).\n\n// There are a variety of `#[cfg]`s controlling which targets are involved in\n// each instance of `weak!` and `syscall!`. Rather than trying to unify all of\n// that, we'll just allow that some unix targets don't use this module at all.\n#![allow(dead_code, unused_macros)]\n\nuse crate::ffi::CStr;\nuse crate::marker;\nuse crate::mem;\nuse crate::sync::atomic::{self, AtomicUsize, Ordering};\n\nmacro_rules! weak {\n    (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n        static $name: crate::sys::weak::Weak<unsafe extern \"C\" fn($($t),*) -> $ret> =\n            crate::sys::weak::Weak::new(concat!(stringify!($name), '\\0'));\n    )\n}\n\npub struct Weak<F> {\n    name: &'static str,\n    addr: AtomicUsize,\n    _marker: marker::PhantomData<F>,\n}\n\nimpl<F> Weak<F> {\n    pub const fn new(name: &'static str) -> Weak<F> {\n        Weak { name, addr: AtomicUsize::new(1), _marker: marker::PhantomData }\n    }\n\n    pub fn get(&self) -> Option<F> {\n        assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n        unsafe {\n            // Relaxed is fine here because we fence before reading through the\n            // pointer (see the comment below).\n            match self.addr.load(Ordering::Relaxed) {\n                1 => self.initialize(),\n                0 => None,\n                addr => {\n                    let func = mem::transmute_copy::<usize, F>(&addr);\n                    // The caller is presumably going to read through this value\n                    // (by calling the function we've dlsymed). This means we'd\n                    // need to have loaded it with at least C11's consume\n                    // ordering in order to be guaranteed that the data we read\n                    // from the pointer isn't from before the pointer was\n                    // stored. Rust has no equivalent to memory_order_consume,\n                    // so we use an acquire fence (sorry, ARM).\n                    //\n                    // Now, in practice this likely isn't needed even on CPUs\n                    // where relaxed and consume mean different things. The\n                    // symbols we're loading are probably present (or not) at\n                    // init, and even if they aren't the runtime dynamic loader\n                    // is extremely likely have sufficient barriers internally\n                    // (possibly implicitly, for example the ones provided by\n                    // invoking `mprotect`).\n                    //\n                    // That said, none of that's *guaranteed*, and so we fence.\n                    atomic::fence(Ordering::Acquire);\n                    Some(func)\n                }\n            }\n        }\n    }\n\n    // Cold because it should only happen during first-time initalization.\n    #[cold]\n    unsafe fn initialize(&self) -> Option<F> {\n        let val = fetch(self.name);\n        // This synchronizes with the acquire fence in `get`.\n        self.addr.store(val, Ordering::Release);\n\n        match val {\n            0 => None,\n            addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n        }\n    }\n}\n\nunsafe fn fetch(name: &str) -> usize {\n    let name = match CStr::from_bytes_with_nul(name.as_bytes()) {\n        Ok(cstr) => cstr,\n        Err(..) => return 0,\n    };\n    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n}\n\n#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\nmacro_rules! syscall {\n    (fn $name:ident($($arg_name:ident: $t:ty),*) -> $ret:ty) => (\n        unsafe fn $name($($arg_name: $t),*) -> $ret {\n            use super::os;\n\n            weak! { fn $name($($t),*) -> $ret }\n\n            if let Some(fun) = $name.get() {\n                fun($($arg_name),*)\n            } else {\n                os::set_errno(libc::ENOSYS);\n                -1\n            }\n        }\n    )\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\nmacro_rules! syscall {\n    (fn $name:ident($($arg_name:ident: $t:ty),*) -> $ret:ty) => (\n        unsafe fn $name($($arg_name:$t),*) -> $ret {\n            // This looks like a hack, but concat_idents only accepts idents\n            // (not paths).\n            use libc::*;\n\n            weak! { fn $name($($t),*) -> $ret }\n\n            // Use a weak symbol from libc when possible, allowing `LD_PRELOAD`\n            // interposition, but if it's not found just use a raw syscall.\n            if let Some(fun) = $name.get() {\n                fun($($arg_name),*)\n            } else {\n                syscall(\n                    concat_idents!(SYS_, $name),\n                    $($arg_name),*\n                ) as $ret\n            }\n        }\n    )\n}\n"],["2409","use super::{FileDesc, IoSlice};\nuse core::mem::ManuallyDrop;\n\n#[test]\nfn limit_vector_count() {\n    let stdout = ManuallyDrop::new(unsafe { FileDesc { fd: 1 } });\n    let bufs = (0..1500).map(|_| IoSlice::new(&[])).collect::<Vec<_>>();\n    assert!(stdout.write_vectored(&bufs).is_ok());\n}\n"],["2410","#![cfg(any(\n    target_os = \"linux\",\n    target_os = \"android\",\n    all(target_os = \"emscripten\", target_feature = \"atomics\")\n))]\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\nuse crate::convert::TryInto;\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\nuse crate::ptr::null;\nuse crate::sync::atomic::AtomicI32;\nuse crate::time::Duration;\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\npub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n    let timespec = timeout.and_then(|d| {\n        Some(libc::timespec {\n            // Sleep forever if the timeout is longer than fits in a timespec.\n            tv_sec: d.as_secs().try_into().ok()?,\n            // This conversion never truncates, as subsec_nanos is always <1e9.\n            tv_nsec: d.subsec_nanos() as _,\n        })\n    });\n    unsafe {\n        libc::syscall(\n            libc::SYS_futex,\n            futex as *const AtomicI32,\n            libc::FUTEX_WAIT | libc::FUTEX_PRIVATE_FLAG,\n            expected,\n            timespec.as_ref().map_or(null(), |d| d as *const libc::timespec),\n        );\n    }\n}\n\n#[cfg(target_os = \"emscripten\")]\npub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n    extern \"C\" {\n        fn emscripten_futex_wait(\n            addr: *const AtomicI32,\n            val: libc::c_uint,\n            max_wait_ms: libc::c_double,\n        ) -> libc::c_int;\n    }\n\n    unsafe {\n        emscripten_futex_wait(\n            futex as *const AtomicI32,\n            // `val` is declared unsigned to match the Emscripten headers, but since it's used as\n            // an opaque value, we can ignore the meaning of signed vs. unsigned and cast here.\n            expected as libc::c_uint,\n            timeout.map_or(crate::f64::INFINITY, |d| d.as_secs_f64() * 1000.0),\n        );\n    }\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\npub fn futex_wake(futex: &AtomicI32) {\n    unsafe {\n        libc::syscall(\n            libc::SYS_futex,\n            futex as *const AtomicI32,\n            libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n            1,\n        );\n    }\n}\n\n#[cfg(target_os = \"emscripten\")]\npub fn futex_wake(futex: &AtomicI32) {\n    extern \"C\" {\n        fn emscripten_futex_wake(addr: *const AtomicI32, count: libc::c_int) -> libc::c_int;\n    }\n\n    unsafe {\n        emscripten_futex_wake(futex as *const AtomicI32, 1);\n    }\n}\n"],["2411","use super::*;\n\n#[test]\nfn test_glibc_version() {\n    // This mostly just tests that the weak linkage doesn't panic wildly...\n    glibc_version();\n}\n\n#[test]\nfn test_parse_glibc_version() {\n    let cases = [\n        (\"0.0\", Some((0, 0))),\n        (\"01.+2\", Some((1, 2))),\n        (\"3.4.5.six\", Some((3, 4))),\n        (\"1\", None),\n        (\"1.-2\", None),\n        (\"1.foo\", None),\n        (\"foo.1\", None),\n    ];\n    for &(version_str, parsed) in cases.iter() {\n        assert_eq!(parsed, parse_glibc_version(version_str));\n    }\n}\n"],["2412","#![cfg(target_thread_local)]\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n\n//! Provides thread-local destructors without an associated \"key\", which\n//! can be more efficient.\n\n// Since what appears to be glibc 2.18 this symbol has been shipped which\n// GCC and clang both use to invoke destructors in thread_local globals, so\n// let's do the same!\n//\n// Note, however, that we run on lots older linuxes, as well as cross\n// compiling from a newer linux to an older linux, so we also have a\n// fallback implementation to use as well.\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"fuchsia\",\n    target_os = \"redox\",\n    target_os = \"emscripten\"\n))]\npub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    use crate::mem;\n    use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n\n    extern \"C\" {\n        #[linkage = \"extern_weak\"]\n        static __dso_handle: *mut u8;\n        #[linkage = \"extern_weak\"]\n        static __cxa_thread_atexit_impl: *const libc::c_void;\n    }\n    if !__cxa_thread_atexit_impl.is_null() {\n        type F = unsafe extern \"C\" fn(\n            dtor: unsafe extern \"C\" fn(*mut u8),\n            arg: *mut u8,\n            dso_handle: *mut u8,\n        ) -> libc::c_int;\n        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)(\n            dtor,\n            t,\n            &__dso_handle as *const _ as *mut _,\n        );\n        return;\n    }\n    register_dtor_fallback(t, dtor);\n}\n\n// This implementation is very similar to register_dtor_fallback in\n// sys_common/thread_local.rs. The main difference is that we want to hook into\n// macOS's analog of the above linux function, _tlv_atexit. OSX will run the\n// registered dtors before any TLS slots get freed, and when the main thread\n// exits.\n//\n// Unfortunately, calling _tlv_atexit while tls dtors are running is UB. The\n// workaround below is to register, via _tlv_atexit, a custom DTOR list once per\n// thread. thread_local dtors are pushed to the DTOR list without calling\n// _tlv_atexit.\n#[cfg(target_os = \"macos\")]\npub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    use crate::cell::Cell;\n    use crate::ptr;\n\n    #[thread_local]\n    static REGISTERED: Cell<bool> = Cell::new(false);\n    if !REGISTERED.get() {\n        _tlv_atexit(run_dtors, ptr::null_mut());\n        REGISTERED.set(true);\n    }\n\n    type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n\n    #[thread_local]\n    static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n    if DTORS.get().is_null() {\n        let v: Box<List> = box Vec::new();\n        DTORS.set(Box::into_raw(v));\n    }\n\n    extern \"C\" {\n        fn _tlv_atexit(dtor: unsafe extern \"C\" fn(*mut u8), arg: *mut u8);\n    }\n\n    let list: &mut List = &mut *DTORS.get();\n    list.push((t, dtor));\n\n    unsafe extern \"C\" fn run_dtors(_: *mut u8) {\n        let mut ptr = DTORS.replace(ptr::null_mut());\n        while !ptr.is_null() {\n            let list = Box::from_raw(ptr);\n            for (ptr, dtor) in list.into_iter() {\n                dtor(ptr);\n            }\n            ptr = DTORS.replace(ptr::null_mut());\n        }\n    }\n}\n\n#[cfg(target_os = \"vxworks\")]\npub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n    register_dtor_fallback(t, dtor);\n}\n"],["2413","//! This module contains specializations that can offload `io::copy()` operations on file descriptor\n//! containing types (`File`, `TcpStream`, etc.) to more efficient syscalls than `read(2)` and `write(2)`.\n//!\n//! Specialization is only applied to wholly std-owned types so that user code can't observe\n//! that the `Read` and `Write` traits are not used.\n//!\n//! Since a copy operation involves a reader and writer side where each can consist of different types\n//! and also involve generic wrappers (e.g. `Take`, `BufReader`) it is not practical to specialize\n//! a single method on all possible combinations.\n//!\n//! Instead readers and writers are handled separately by the `CopyRead` and `CopyWrite` specialization\n//! traits and then specialized on by the `Copier::copy` method.\n//!\n//! `Copier` uses the specialization traits to unpack the underlying file descriptors and\n//! additional prerequisites and constraints imposed by the wrapper types.\n//!\n//! Once it has obtained all necessary pieces and brought any wrapper types into a state where they\n//! can be safely bypassed it will attempt to use the `copy_file_range(2)`,\n//! `sendfile(2)` or `splice(2)` syscalls to move data directly between file descriptors.\n//! Since those syscalls have requirements that cannot be fully checked in advance and\n//! gathering additional information about file descriptors would require additional syscalls\n//! anyway it simply attempts to use them one after another (guided by inaccurate hints) to\n//! figure out which one works and and falls back to the generic read-write copy loop if none of them\n//! does.\n//! Once a working syscall is found for a pair of file descriptors it will be called in a loop\n//! until the copy operation is completed.\n//!\n//! Advantages of using these syscalls:\n//!\n//! * fewer context switches since reads and writes are coalesced into a single syscall\n//!   and more bytes are transferred per syscall. This translates to higher throughput\n//!   and fewer CPU cycles, at least for sufficiently large transfers to amortize the initial probing.\n//! * `copy_file_range` creates reflink copies on CoW filesystems, thus moving less data and\n//!   consuming less disk space\n//! * `sendfile` and `splice` can perform zero-copy IO under some circumstances while\n//!   a naive copy loop would move every byte through the CPU.\n//!\n//! Drawbacks:\n//!\n//! * copy operations smaller than the default buffer size can under some circumstances, especially\n//!   on older kernels, incur more syscalls than the naive approach would. As mentioned above\n//!   the syscall selection is guided by hints to minimize this possibility but they are not perfect.\n//! * optimizations only apply to std types. If a user adds a custom wrapper type, e.g. to report\n//!   progress, they can hit a performance cliff.\n//! * complexity\n\nuse crate::cmp::min;\nuse crate::convert::TryInto;\nuse crate::fs::{File, Metadata};\nuse crate::io::copy::generic_copy;\nuse crate::io::{\n    BufRead, BufReader, BufWriter, Error, Read, Result, StderrLock, StdinLock, StdoutLock, Take,\n    Write,\n};\nuse crate::mem::ManuallyDrop;\nuse crate::net::TcpStream;\nuse crate::os::unix::fs::FileTypeExt;\nuse crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\nuse crate::os::unix::net::UnixStream;\nuse crate::process::{ChildStderr, ChildStdin, ChildStdout};\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicBool, AtomicU8, Ordering};\nuse crate::sys::cvt;\nuse libc::{EBADF, EINVAL, ENOSYS, EOPNOTSUPP, EOVERFLOW, EPERM, EXDEV};\n\n#[cfg(test)]\nmod tests;\n\npub(crate) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n    read: &mut R,\n    write: &mut W,\n) -> Result<u64> {\n    let copier = Copier { read, write };\n    SpecCopy::copy(copier)\n}\n\n/// This type represents either the inferred `FileType` of a `RawFd` based on the source\n/// type from which it was extracted or the actual metadata\n///\n/// The methods on this type only provide hints, due to `AsRawFd` and `FromRawFd` the inferred\n/// type may be wrong.\nenum FdMeta {\n    /// We obtained the FD from a type that can contain any type of `FileType` and queried the metadata\n    /// because it is cheaper than probing all possible syscalls (reader side)\n    Metadata(Metadata),\n    Socket,\n    Pipe,\n    /// We don't have any metadata, e.g. because the original type was `File` which can represent\n    /// any `FileType` and we did not query the metadata either since it did not seem beneficial\n    /// (writer side)\n    NoneObtained,\n}\n\nimpl FdMeta {\n    fn maybe_fifo(&self) -> bool {\n        match self {\n            FdMeta::Metadata(meta) => meta.file_type().is_fifo(),\n            FdMeta::Socket => false,\n            FdMeta::Pipe => true,\n            FdMeta::NoneObtained => true,\n        }\n    }\n\n    fn potential_sendfile_source(&self) -> bool {\n        match self {\n            // procfs erronously shows 0 length on non-empty readable files.\n            // and if a file is truly empty then a `read` syscall will determine that and skip the write syscall\n            // thus there would be benefit from attempting sendfile\n            FdMeta::Metadata(meta)\n                if meta.file_type().is_file() && meta.len() > 0\n                    || meta.file_type().is_block_device() =>\n            {\n                true\n            }\n            _ => false,\n        }\n    }\n\n    fn copy_file_range_candidate(&self) -> bool {\n        match self {\n            // copy_file_range will fail on empty procfs files. `read` can determine whether EOF has been reached\n            // without extra cost and skip the write, thus there is no benefit in attempting copy_file_range\n            FdMeta::Metadata(meta) if meta.is_file() && meta.len() > 0 => true,\n            FdMeta::NoneObtained => true,\n            _ => false,\n        }\n    }\n}\n\nstruct CopyParams(FdMeta, Option<RawFd>);\n\nstruct Copier<'a, 'b, R: Read + ?Sized, W: Write + ?Sized> {\n    read: &'a mut R,\n    write: &'b mut W,\n}\n\ntrait SpecCopy {\n    fn copy(self) -> Result<u64>;\n}\n\nimpl<R: Read + ?Sized, W: Write + ?Sized> SpecCopy for Copier<'_, '_, R, W> {\n    default fn copy(self) -> Result<u64> {\n        generic_copy(self.read, self.write)\n    }\n}\n\nimpl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n    fn copy(self) -> Result<u64> {\n        let (reader, writer) = (self.read, self.write);\n        let r_cfg = reader.properties();\n        let w_cfg = writer.properties();\n\n        // before direct operations on file descriptors ensure that all source and sink buffers are empty\n        let mut flush = || -> crate::io::Result<u64> {\n            let bytes = reader.drain_to(writer, u64::MAX)?;\n            // BufWriter buffered bytes have already been accounted for in earlier write() calls\n            writer.flush()?;\n            Ok(bytes)\n        };\n\n        let mut written = 0u64;\n\n        if let (CopyParams(input_meta, Some(readfd)), CopyParams(output_meta, Some(writefd))) =\n            (r_cfg, w_cfg)\n        {\n            written += flush()?;\n            let max_write = reader.min_limit();\n\n            if input_meta.copy_file_range_candidate() && output_meta.copy_file_range_candidate() {\n                let result = copy_regular_files(readfd, writefd, max_write);\n                result.update_take(reader);\n\n                match result {\n                    CopyResult::Ended(bytes_copied) => return Ok(bytes_copied + written),\n                    CopyResult::Error(e, _) => return Err(e),\n                    CopyResult::Fallback(bytes) => written += bytes,\n                }\n            }\n\n            // on modern kernels sendfile can copy from any mmapable type (some but not all regular files and block devices)\n            // to any writable file descriptor. On older kernels the writer side can only be a socket.\n            // So we just try and fallback if needed.\n            // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n            // fall back to the generic copy loop.\n            if input_meta.potential_sendfile_source() {\n                let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n                result.update_take(reader);\n\n                match result {\n                    CopyResult::Ended(bytes_copied) => return Ok(bytes_copied + written),\n                    CopyResult::Error(e, _) => return Err(e),\n                    CopyResult::Fallback(bytes) => written += bytes,\n                }\n            }\n\n            if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n                let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n                result.update_take(reader);\n\n                match result {\n                    CopyResult::Ended(bytes_copied) => return Ok(bytes_copied + written),\n                    CopyResult::Error(e, _) => return Err(e),\n                    CopyResult::Fallback(0) => { /* use the fallback below */ }\n                    CopyResult::Fallback(_) => {\n                        unreachable!(\"splice should not return > 0 bytes on the fallback path\")\n                    }\n                }\n            }\n        }\n\n        // fallback if none of the more specialized syscalls wants to work with these file descriptors\n        match generic_copy(reader, writer) {\n            Ok(bytes) => Ok(bytes + written),\n            err => err,\n        }\n    }\n}\n\n#[rustc_specialization_trait]\ntrait CopyRead: Read {\n    /// Implementations that contain buffers (i.e. `BufReader`) must transfer data from their internal\n    /// buffers into `writer` until either the buffers are emptied or `limit` bytes have been\n    /// transferred, whichever occurs sooner.\n    /// If nested buffers are present the outer buffers must be drained first.\n    ///\n    /// This is necessary to directly bypass the wrapper types while preserving the data order\n    /// when operating directly on the underlying file descriptors.\n    fn drain_to<W: Write>(&mut self, _writer: &mut W, _limit: u64) -> Result<u64> {\n        Ok(0)\n    }\n\n    /// Updates `Take` wrappers to remove the number of bytes copied.\n    fn taken(&mut self, _bytes: u64) {}\n\n    /// The minimum of the limit of all `Take<_>` wrappers, `u64::MAX` otherwise.\n    /// This method does not account for data `BufReader` buffers and would underreport\n    /// the limit of a `Take<BufReader<Take<_>>>` type. Thus its result is only valid\n    /// after draining the buffers via `drain_to`.\n    fn min_limit(&self) -> u64 {\n        u64::MAX\n    }\n\n    /// Extracts the file descriptor and hints/metadata, delegating through wrappers if necessary.\n    fn properties(&self) -> CopyParams;\n}\n\n#[rustc_specialization_trait]\ntrait CopyWrite: Write {\n    /// Extracts the file descriptor and hints/metadata, delegating through wrappers if necessary.\n    fn properties(&self) -> CopyParams;\n}\n\nimpl<T> CopyRead for &mut T\nwhere\n    T: CopyRead,\n{\n    fn drain_to<W: Write>(&mut self, writer: &mut W, limit: u64) -> Result<u64> {\n        (**self).drain_to(writer, limit)\n    }\n\n    fn taken(&mut self, bytes: u64) {\n        (**self).taken(bytes);\n    }\n\n    fn min_limit(&self) -> u64 {\n        (**self).min_limit()\n    }\n\n    fn properties(&self) -> CopyParams {\n        (**self).properties()\n    }\n}\n\nimpl<T> CopyWrite for &mut T\nwhere\n    T: CopyWrite,\n{\n    fn properties(&self) -> CopyParams {\n        (**self).properties()\n    }\n}\n\nimpl CopyRead for File {\n    fn properties(&self) -> CopyParams {\n        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for &File {\n    fn properties(&self) -> CopyParams {\n        CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for File {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for &File {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for TcpStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for &TcpStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for TcpStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for &TcpStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for UnixStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for &UnixStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for UnixStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for &UnixStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for ChildStdin {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for ChildStdout {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for ChildStderr {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for StdinLock<'_> {\n    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n        let buf_reader = self.as_mut_buf();\n        let buf = buf_reader.buffer();\n        let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n        let bytes_drained = buf.len();\n        writer.write_all(buf)?;\n        buf_reader.consume(bytes_drained);\n\n        Ok(bytes_drained as u64)\n    }\n\n    fn properties(&self) -> CopyParams {\n        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for StdoutLock<'_> {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for StderrLock<'_> {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n    }\n}\n\nimpl<T: CopyRead> CopyRead for Take<T> {\n    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n        let local_limit = self.limit();\n        let combined_limit = min(outer_limit, local_limit);\n        let bytes_drained = self.get_mut().drain_to(writer, combined_limit)?;\n        // update limit since read() was bypassed\n        self.set_limit(local_limit - bytes_drained);\n\n        Ok(bytes_drained)\n    }\n\n    fn taken(&mut self, bytes: u64) {\n        self.set_limit(self.limit() - bytes);\n        self.get_mut().taken(bytes);\n    }\n\n    fn min_limit(&self) -> u64 {\n        min(Take::limit(self), self.get_ref().min_limit())\n    }\n\n    fn properties(&self) -> CopyParams {\n        self.get_ref().properties()\n    }\n}\n\nimpl<T: CopyRead> CopyRead for BufReader<T> {\n    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n        let buf = self.buffer();\n        let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n        let bytes = buf.len();\n        writer.write_all(buf)?;\n        self.consume(bytes);\n\n        let remaining = outer_limit - bytes as u64;\n\n        // in case of nested bufreaders we also need to drain the ones closer to the source\n        let inner_bytes = self.get_mut().drain_to(writer, remaining)?;\n\n        Ok(bytes as u64 + inner_bytes)\n    }\n\n    fn taken(&mut self, bytes: u64) {\n        self.get_mut().taken(bytes);\n    }\n\n    fn min_limit(&self) -> u64 {\n        self.get_ref().min_limit()\n    }\n\n    fn properties(&self) -> CopyParams {\n        self.get_ref().properties()\n    }\n}\n\nimpl<T: CopyWrite> CopyWrite for BufWriter<T> {\n    fn properties(&self) -> CopyParams {\n        self.get_ref().properties()\n    }\n}\n\nfn fd_to_meta<T: AsRawFd>(fd: &T) -> FdMeta {\n    let fd = fd.as_raw_fd();\n    let file: ManuallyDrop<File> = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });\n    match file.metadata() {\n        Ok(meta) => FdMeta::Metadata(meta),\n        Err(_) => FdMeta::NoneObtained,\n    }\n}\n\npub(super) enum CopyResult {\n    Ended(u64),\n    Error(Error, u64),\n    Fallback(u64),\n}\n\nimpl CopyResult {\n    fn update_take(&self, reader: &mut impl CopyRead) {\n        match *self {\n            CopyResult::Fallback(bytes)\n            | CopyResult::Ended(bytes)\n            | CopyResult::Error(_, bytes) => reader.taken(bytes),\n        }\n    }\n}\n\n/// Invalid file descriptor.\n///\n/// Valid file descriptors are guaranteed to be positive numbers (see `open()` manpage)\n/// while negative values are used to indicate errors.\n/// Thus -1 will never be overlap with a valid open file.\nconst INVALID_FD: RawFd = -1;\n\n/// Linux-specific implementation that will attempt to use copy_file_range for copy offloading.\n/// As the name says, it only works on regular files.\n///\n/// Callers must handle fallback to a generic copy loop.\n/// `Fallback` may indicate non-zero number of bytes already written\n/// if one of the files' cursor +`max_len` would exceed u64::MAX (`EOVERFLOW`).\npub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n    use crate::cmp;\n\n    const NOT_PROBED: u8 = 0;\n    const UNAVAILABLE: u8 = 1;\n    const AVAILABLE: u8 = 2;\n\n    // Kernel prior to 4.5 don't have copy_file_range\n    // We store the availability in a global to avoid unnecessary syscalls\n    static HAS_COPY_FILE_RANGE: AtomicU8 = AtomicU8::new(NOT_PROBED);\n\n    syscall! {\n        fn copy_file_range(\n            fd_in: libc::c_int,\n            off_in: *mut libc::loff_t,\n            fd_out: libc::c_int,\n            off_out: *mut libc::loff_t,\n            len: libc::size_t,\n            flags: libc::c_uint\n        ) -> libc::ssize_t\n    }\n\n    match HAS_COPY_FILE_RANGE.load(Ordering::Relaxed) {\n        NOT_PROBED => {\n            // EPERM can indicate seccomp filters or an immutable file.\n            // To distinguish these cases we probe with invalid file descriptors which should result in EBADF if the syscall is supported\n            // and some other error (ENOSYS or EPERM) if it's not available\n            let result = unsafe {\n                cvt(copy_file_range(INVALID_FD, ptr::null_mut(), INVALID_FD, ptr::null_mut(), 1, 0))\n            };\n\n            if matches!(result.map_err(|e| e.raw_os_error()), Err(Some(EBADF))) {\n                HAS_COPY_FILE_RANGE.store(AVAILABLE, Ordering::Relaxed);\n            } else {\n                HAS_COPY_FILE_RANGE.store(UNAVAILABLE, Ordering::Relaxed);\n                return CopyResult::Fallback(0);\n            }\n        }\n        UNAVAILABLE => return CopyResult::Fallback(0),\n        _ => {}\n    };\n\n    let mut written = 0u64;\n    while written < max_len {\n        let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n        // cap to 1GB chunks in case u64::MAX is passed as max_len and the file has a non-zero seek position\n        // this allows us to copy large chunks without hitting EOVERFLOW,\n        // unless someone sets a file offset close to u64::MAX - 1GB, in which case a fallback would be required\n        let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x4000_0000usize);\n        let copy_result = unsafe {\n            // We actually don't have to adjust the offsets,\n            // because copy_file_range adjusts the file offset automatically\n            cvt(copy_file_range(reader, ptr::null_mut(), writer, ptr::null_mut(), bytes_to_copy, 0))\n        };\n\n        match copy_result {\n            Ok(0) if written == 0 => {\n                // fallback to work around several kernel bugs where copy_file_range will fail to\n                // copy any bytes and return 0 instead of an error if\n                // - reading virtual files from the proc filesystem which appear to have 0 size\n                //   but are not empty. noted in coreutils to affect kernels at least up to 5.6.19.\n                // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n                return CopyResult::Fallback(0);\n            }\n            Ok(0) => return CopyResult::Ended(written), // reached EOF\n            Ok(ret) => written += ret as u64,\n            Err(err) => {\n                return match err.raw_os_error() {\n                    // when file offset + max_length > u64::MAX\n                    Some(EOVERFLOW) => CopyResult::Fallback(written),\n                    Some(ENOSYS | EXDEV | EINVAL | EPERM | EOPNOTSUPP | EBADF) => {\n                        // Try fallback io::copy if either:\n                        // - Kernel version is < 4.5 (ENOSYS¹)\n                        // - Files are mounted on different fs (EXDEV)\n                        // - copy_file_range is broken in various ways on RHEL/CentOS 7 (EOPNOTSUPP)\n                        // - copy_file_range file is immutable or syscall is blocked by seccomp¹ (EPERM)\n                        // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n                        // - the writer fd was opened with O_APPEND (EBADF²)\n                        //\n                        // ¹ these cases should be detected by the initial probe but we handle them here\n                        //   anyway in case syscall interception changes during runtime\n                        // ² actually invalid file descriptors would cause this too, but in that case\n                        //   the fallback code path is expected to encounter the same error again\n                        assert_eq!(written, 0);\n                        CopyResult::Fallback(0)\n                    }\n                    _ => CopyResult::Error(err, written),\n                };\n            }\n        }\n    }\n    CopyResult::Ended(written)\n}\n\n#[derive(PartialEq)]\nenum SpliceMode {\n    Sendfile,\n    Splice,\n}\n\n/// performs splice or sendfile between file descriptors\n/// Does _not_ fall back to a generic copy loop.\nfn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) -> CopyResult {\n    static HAS_SENDFILE: AtomicBool = AtomicBool::new(true);\n    static HAS_SPLICE: AtomicBool = AtomicBool::new(true);\n\n    syscall! {\n        fn splice(\n            srcfd: libc::c_int,\n            src_offset: *const i64,\n            dstfd: libc::c_int,\n            dst_offset: *const i64,\n            len: libc::size_t,\n            flags: libc::c_int\n        ) -> libc::ssize_t\n    }\n\n    match mode {\n        SpliceMode::Sendfile if !HAS_SENDFILE.load(Ordering::Relaxed) => {\n            return CopyResult::Fallback(0);\n        }\n        SpliceMode::Splice if !HAS_SPLICE.load(Ordering::Relaxed) => {\n            return CopyResult::Fallback(0);\n        }\n        _ => (),\n    }\n\n    let mut written = 0u64;\n    while written < len {\n        // according to its manpage that's the maximum size sendfile() will copy per invocation\n        let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n\n        let result = match mode {\n            SpliceMode::Sendfile => {\n                cvt(unsafe { libc::sendfile(writer, reader, ptr::null_mut(), chunk_size) })\n            }\n            SpliceMode::Splice => cvt(unsafe {\n                splice(reader, ptr::null_mut(), writer, ptr::null_mut(), chunk_size, 0)\n            }),\n        };\n\n        match result {\n            Ok(0) => break, // EOF\n            Ok(ret) => written += ret as u64,\n            Err(err) => {\n                return match err.raw_os_error() {\n                    Some(ENOSYS | EPERM) => {\n                        // syscall not supported (ENOSYS)\n                        // syscall is disallowed, e.g. by seccomp (EPERM)\n                        match mode {\n                            SpliceMode::Sendfile => HAS_SENDFILE.store(false, Ordering::Relaxed),\n                            SpliceMode::Splice => HAS_SPLICE.store(false, Ordering::Relaxed),\n                        }\n                        assert_eq!(written, 0);\n                        CopyResult::Fallback(0)\n                    }\n                    Some(EINVAL) => {\n                        // splice/sendfile do not support this particular file descriptor (EINVAL)\n                        assert_eq!(written, 0);\n                        CopyResult::Fallback(0)\n                    }\n                    Some(os_err) if mode == SpliceMode::Sendfile && os_err == EOVERFLOW => {\n                        CopyResult::Fallback(written)\n                    }\n                    _ => CopyResult::Error(err, written),\n                };\n            }\n        }\n    }\n    CopyResult::Ended(written)\n}\n"],["2414","use crate::cell::UnsafeCell;\nuse crate::mem::MaybeUninit;\nuse crate::sys::cvt_nz;\n\npub struct Mutex {\n    inner: UnsafeCell<libc::pthread_mutex_t>,\n}\n\npub type MovableMutex = Box<Mutex>;\n\n#[inline]\npub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n    m.inner.get()\n}\n\nunsafe impl Send for Mutex {}\nunsafe impl Sync for Mutex {}\n\n#[allow(dead_code)] // sys isn't exported yet\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        // Might be moved to a different address, so it is better to avoid\n        // initialization of potentially opaque OS data before it landed.\n        // Be very careful using this newly constructed `Mutex`, reentrant\n        // locking is undefined behavior until `init` is called!\n        Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n    }\n    #[inline]\n    pub unsafe fn init(&mut self) {\n        // Issue #33770\n        //\n        // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n        // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n        // try to re-lock it from the same thread when you already hold a lock\n        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html).\n        // This is the case even if PTHREAD_MUTEX_DEFAULT == PTHREAD_MUTEX_NORMAL\n        // (https://github.com/rust-lang/rust/issues/33770#issuecomment-220847521) -- in that\n        // case, `pthread_mutexattr_settype(PTHREAD_MUTEX_DEFAULT)` will of course be the same\n        // as setting it to `PTHREAD_MUTEX_NORMAL`, but not setting any mode will result in\n        // a Mutex where re-locking is UB.\n        //\n        // In practice, glibc takes advantage of this undefined behavior to\n        // implement hardware lock elision, which uses hardware transactional\n        // memory to avoid acquiring the lock. While a transaction is in\n        // progress, the lock appears to be unlocked. This isn't a problem for\n        // other threads since the transactional memory will abort if a conflict\n        // is detected, however no abort is generated when re-locking from the\n        // same thread.\n        //\n        // Since locking the same mutex twice will result in two aliasing &mut\n        // references, we instead create the mutex with type\n        // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n        // re-lock it from the same thread, thus avoiding undefined behavior.\n        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n        let attr = PthreadMutexAttr(&mut attr);\n        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL))\n            .unwrap();\n        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n    }\n    #[inline]\n    pub unsafe fn lock(&self) {\n        let r = libc::pthread_mutex_lock(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let r = libc::pthread_mutex_unlock(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        libc::pthread_mutex_trylock(self.inner.get()) == 0\n    }\n    #[inline]\n    #[cfg(not(target_os = \"dragonfly\"))]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_mutex_destroy(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    #[cfg(target_os = \"dragonfly\")]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_mutex_destroy(self.inner.get());\n        // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n        // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n        // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n        // this behaviour no longer occurs.\n        debug_assert!(r == 0 || r == libc::EINVAL);\n    }\n}\n\npub struct ReentrantMutex {\n    inner: UnsafeCell<libc::pthread_mutex_t>,\n}\n\nunsafe impl Send for ReentrantMutex {}\nunsafe impl Sync for ReentrantMutex {}\n\nimpl ReentrantMutex {\n    pub const unsafe fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n    }\n\n    pub unsafe fn init(&self) {\n        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n        let attr = PthreadMutexAttr(&mut attr);\n        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE))\n            .unwrap();\n        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n    }\n\n    pub unsafe fn lock(&self) {\n        let result = libc::pthread_mutex_lock(self.inner.get());\n        debug_assert_eq!(result, 0);\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        libc::pthread_mutex_trylock(self.inner.get()) == 0\n    }\n\n    pub unsafe fn unlock(&self) {\n        let result = libc::pthread_mutex_unlock(self.inner.get());\n        debug_assert_eq!(result, 0);\n    }\n\n    pub unsafe fn destroy(&self) {\n        let result = libc::pthread_mutex_destroy(self.inner.get());\n        debug_assert_eq!(result, 0);\n    }\n}\n\nstruct PthreadMutexAttr<'a>(&'a mut MaybeUninit<libc::pthread_mutexattr_t>);\n\nimpl Drop for PthreadMutexAttr<'_> {\n    fn drop(&mut self) {\n        unsafe {\n            let result = libc::pthread_mutexattr_destroy(self.0.as_mut_ptr());\n            debug_assert_eq!(result, 0);\n        }\n    }\n}\n"],["2415","#![cfg_attr(test, allow(dead_code))]\n\nuse self::imp::{drop_handler, make_handler};\n\npub use self::imp::cleanup;\npub use self::imp::init;\n\npub struct Handler {\n    _data: *mut libc::c_void,\n}\n\nimpl Handler {\n    pub unsafe fn new() -> Handler {\n        make_handler()\n    }\n\n    fn null() -> Handler {\n        Handler { _data: crate::ptr::null_mut() }\n    }\n}\n\nimpl Drop for Handler {\n    fn drop(&mut self) {\n        unsafe {\n            drop_handler(self);\n        }\n    }\n}\n\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"macos\",\n    target_os = \"dragonfly\",\n    target_os = \"freebsd\",\n    target_os = \"solaris\",\n    target_os = \"illumos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\"\n))]\nmod imp {\n    use super::Handler;\n    use crate::io;\n    use crate::mem;\n    use crate::ptr;\n    use crate::thread;\n\n    use libc::MAP_FAILED;\n    use libc::{mmap, munmap};\n    use libc::{sigaction, sighandler_t, SA_ONSTACK, SA_SIGINFO, SIGBUS, SIG_DFL};\n    use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n    use libc::{MAP_ANON, MAP_PRIVATE, PROT_NONE, PROT_READ, PROT_WRITE, SIGSEGV};\n\n    use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n    use crate::sys::unix::os::page_size;\n    use crate::sys_common::thread_info;\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n        #[repr(C)]\n        struct siginfo_t {\n            a: [libc::c_int; 3], // si_signo, si_errno, si_code\n            si_addr: *mut libc::c_void,\n        }\n\n        (*(info as *const siginfo_t)).si_addr as usize\n    }\n\n    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n        (*info).si_addr as usize\n    }\n\n    // Signal handler for the SIGSEGV and SIGBUS handlers. We've got guard pages\n    // (unmapped pages) at the end of every thread's stack, so if a thread ends\n    // up running into the guard page it'll trigger this handler. We want to\n    // detect these cases and print out a helpful error saying that the stack\n    // has overflowed. All other signals, however, should go back to what they\n    // were originally supposed to do.\n    //\n    // This handler currently exists purely to print an informative message\n    // whenever a thread overflows its stack. We then abort to exit and\n    // indicate a crash, but to avoid a misleading SIGSEGV that might lead\n    // users to believe that unsafe code has accessed an invalid pointer; the\n    // SIGSEGV encountered when overflowing the stack is expected and\n    // well-defined.\n    //\n    // If this is not a stack overflow, the handler un-registers itself and\n    // then returns (to allow the original signal to be delivered again).\n    // Returning from this kind of signal handler is technically not defined\n    // to work when reading the POSIX spec strictly, but in practice it turns\n    // out many large systems and all implementations allow returning from a\n    // signal handler to work. For a more detailed explanation see the\n    // comments on #26458.\n    unsafe extern \"C\" fn signal_handler(\n        signum: libc::c_int,\n        info: *mut libc::siginfo_t,\n        _data: *mut libc::c_void,\n    ) {\n        let guard = thread_info::stack_guard().unwrap_or(0..0);\n        let addr = siginfo_si_addr(info);\n\n        // If the faulting address is within the guard page, then we print a\n        // message saying so and abort.\n        if guard.start <= addr && addr < guard.end {\n            rtprintpanic!(\n                \"\\nthread '{}' has overflowed its stack\\n\",\n                thread::current().name().unwrap_or(\"<unknown>\")\n            );\n            rtabort!(\"stack overflow\");\n        } else {\n            // Unregister ourselves by reverting back to the default behavior.\n            let mut action: sigaction = mem::zeroed();\n            action.sa_sigaction = SIG_DFL;\n            sigaction(signum, &action, ptr::null_mut());\n\n            // See comment above for why this function returns.\n        }\n    }\n\n    static MAIN_ALTSTACK: AtomicPtr<libc::c_void> = AtomicPtr::new(ptr::null_mut());\n    static NEED_ALTSTACK: AtomicBool = AtomicBool::new(false);\n\n    pub unsafe fn init() {\n        let mut action: sigaction = mem::zeroed();\n        for &signal in &[SIGSEGV, SIGBUS] {\n            sigaction(signal, ptr::null_mut(), &mut action);\n            // Configure our signal handler if one is not already set.\n            if action.sa_sigaction == SIG_DFL {\n                action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n                action.sa_sigaction = signal_handler as sighandler_t;\n                sigaction(signal, &action, ptr::null_mut());\n                NEED_ALTSTACK.store(true, Ordering::Relaxed);\n            }\n        }\n\n        let handler = make_handler();\n        MAIN_ALTSTACK.store(handler._data, Ordering::Relaxed);\n        mem::forget(handler);\n    }\n\n    pub unsafe fn cleanup() {\n        Handler { _data: MAIN_ALTSTACK.load(Ordering::Relaxed) };\n    }\n\n    unsafe fn get_stackp() -> *mut libc::c_void {\n        let stackp = mmap(\n            ptr::null_mut(),\n            SIGSTKSZ + page_size(),\n            PROT_READ | PROT_WRITE,\n            MAP_PRIVATE | MAP_ANON,\n            -1,\n            0,\n        );\n        if stackp == MAP_FAILED {\n            panic!(\"failed to allocate an alternative stack: {}\", io::Error::last_os_error());\n        }\n        let guard_result = libc::mprotect(stackp, page_size(), PROT_NONE);\n        if guard_result != 0 {\n            panic!(\"failed to set up alternative stack guard page: {}\", io::Error::last_os_error());\n        }\n        stackp.add(page_size())\n    }\n\n    #[cfg(any(\n        target_os = \"linux\",\n        target_os = \"macos\",\n        target_os = \"freebsd\",\n        target_os = \"netbsd\",\n        target_os = \"openbsd\",\n        target_os = \"solaris\",\n        target_os = \"illumos\"\n    ))]\n    unsafe fn get_stack() -> libc::stack_t {\n        libc::stack_t { ss_sp: get_stackp(), ss_flags: 0, ss_size: SIGSTKSZ }\n    }\n\n    #[cfg(target_os = \"dragonfly\")]\n    unsafe fn get_stack() -> libc::stack_t {\n        libc::stack_t { ss_sp: get_stackp() as *mut i8, ss_flags: 0, ss_size: SIGSTKSZ }\n    }\n\n    pub unsafe fn make_handler() -> Handler {\n        if !NEED_ALTSTACK.load(Ordering::Relaxed) {\n            return Handler::null();\n        }\n        let mut stack = mem::zeroed();\n        sigaltstack(ptr::null(), &mut stack);\n        // Configure alternate signal stack, if one is not already set.\n        if stack.ss_flags & SS_DISABLE != 0 {\n            stack = get_stack();\n            sigaltstack(&stack, ptr::null_mut());\n            Handler { _data: stack.ss_sp as *mut libc::c_void }\n        } else {\n            Handler::null()\n        }\n    }\n\n    pub unsafe fn drop_handler(handler: &mut Handler) {\n        if !handler._data.is_null() {\n            let stack = libc::stack_t {\n                ss_sp: ptr::null_mut(),\n                ss_flags: SS_DISABLE,\n                // Workaround for bug in macOS implementation of sigaltstack\n                // UNIX2003 which returns ENOMEM when disabling a stack while\n                // passing ss_size smaller than MINSIGSTKSZ. According to POSIX\n                // both ss_sp and ss_size should be ignored in this case.\n                ss_size: SIGSTKSZ,\n            };\n            sigaltstack(&stack, ptr::null_mut());\n            // We know from `get_stackp` that the alternate stack we installed is part of a mapping\n            // that started one page earlier, so walk back a page and unmap from there.\n            munmap(handler._data.sub(page_size()), SIGSTKSZ + page_size());\n        }\n    }\n}\n\n#[cfg(not(any(\n    target_os = \"linux\",\n    target_os = \"macos\",\n    target_os = \"dragonfly\",\n    target_os = \"freebsd\",\n    target_os = \"solaris\",\n    target_os = \"illumos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n)))]\nmod imp {\n    pub unsafe fn init() {}\n\n    pub unsafe fn cleanup() {}\n\n    pub unsafe fn make_handler() -> super::Handler {\n        super::Handler::null()\n    }\n\n    pub unsafe fn drop_handler(_handler: &mut super::Handler) {}\n}\n"],["2416","macro_rules! unimpl {\n    () => {\n        return Err(io::Error::new_const(\n            io::ErrorKind::Unsupported,\n            &\"No networking available on L4Re.\",\n        ));\n    };\n}\n\npub mod net {\n    #![allow(warnings)]\n    use crate::convert::TryFrom;\n    use crate::fmt;\n    use crate::io::{self, IoSlice, IoSliceMut};\n    use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n    use crate::sys::fd::FileDesc;\n    use crate::sys_common::{AsInner, FromInner, IntoInner};\n    use crate::time::Duration;\n\n    #[allow(unused_extern_crates)]\n    pub extern crate libc as netc;\n\n    pub struct Socket(FileDesc);\n    impl Socket {\n        pub fn new(_: &SocketAddr, _: libc::c_int) -> io::Result<Socket> {\n            unimpl!();\n        }\n\n        pub fn new_raw(_: libc::c_int, _: libc::c_int) -> io::Result<Socket> {\n            unimpl!();\n        }\n\n        pub fn new_pair(_: libc::c_int, _: libc::c_int) -> io::Result<(Socket, Socket)> {\n            unimpl!();\n        }\n\n        pub fn connect_timeout(&self, _: &SocketAddr, _: Duration) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn accept(\n            &self,\n            _: *mut libc::sockaddr,\n            _: *mut libc::socklen_t,\n        ) -> io::Result<Socket> {\n            unimpl!();\n        }\n\n        pub fn duplicate(&self) -> io::Result<Socket> {\n            unimpl!();\n        }\n\n        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn is_read_vectored(&self) -> bool {\n            unimpl!();\n        }\n\n        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn is_write_vectored(&self) -> bool {\n            unimpl!();\n        }\n\n        pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn timeout(&self, _: libc::c_int) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn nodelay(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n            unimpl!();\n        }\n    }\n\n    impl AsInner<libc::c_int> for Socket {\n        fn as_inner(&self) -> &libc::c_int {\n            self.0.as_inner()\n        }\n    }\n\n    impl FromInner<libc::c_int> for Socket {\n        fn from_inner(fd: libc::c_int) -> Socket {\n            Socket(FileDesc::new(fd))\n        }\n    }\n\n    impl IntoInner<libc::c_int> for Socket {\n        fn into_inner(self) -> libc::c_int {\n            self.0.into_raw()\n        }\n    }\n\n    pub struct TcpStream {\n        inner: Socket,\n    }\n\n    impl TcpStream {\n        pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n            unimpl!();\n        }\n\n        pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n            unimpl!();\n        }\n\n        pub fn socket(&self) -> &Socket {\n            &self.inner\n        }\n\n        pub fn into_socket(self) -> Socket {\n            self.inner\n        }\n\n        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn is_read_vectored(&self) -> bool {\n            unimpl!();\n        }\n\n        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn is_write_vectored(&self) -> bool {\n            unimpl!();\n        }\n\n        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn duplicate(&self) -> io::Result<TcpStream> {\n            unimpl!();\n        }\n\n        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn nodelay(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn ttl(&self) -> io::Result<u32> {\n            unimpl!();\n        }\n\n        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n            unimpl!();\n        }\n\n        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n    }\n\n    impl FromInner<Socket> for TcpStream {\n        fn from_inner(socket: Socket) -> TcpStream {\n            TcpStream { inner: socket }\n        }\n    }\n\n    impl fmt::Debug for TcpStream {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"No networking support available on L4Re\")\n        }\n    }\n\n    pub struct TcpListener {\n        inner: Socket,\n    }\n\n    impl TcpListener {\n        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n            unimpl!();\n        }\n\n        pub fn socket(&self) -> &Socket {\n            &self.inner\n        }\n\n        pub fn into_socket(self) -> Socket {\n            self.inner\n        }\n\n        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn duplicate(&self) -> io::Result<TcpListener> {\n            unimpl!();\n        }\n\n        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn ttl(&self) -> io::Result<u32> {\n            unimpl!();\n        }\n\n        pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn only_v6(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n            unimpl!();\n        }\n\n        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n    }\n\n    impl FromInner<Socket> for TcpListener {\n        fn from_inner(socket: Socket) -> TcpListener {\n            TcpListener { inner: socket }\n        }\n    }\n\n    impl fmt::Debug for TcpListener {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"No networking support available on L4Re.\")\n        }\n    }\n\n    pub struct UdpSocket {\n        inner: Socket,\n    }\n\n    impl UdpSocket {\n        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n            unimpl!();\n        }\n\n        pub fn socket(&self) -> &Socket {\n            &self.inner\n        }\n\n        pub fn into_socket(self) -> Socket {\n            self.inner\n        }\n\n        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn duplicate(&self) -> io::Result<UdpSocket> {\n            unimpl!();\n        }\n\n        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn broadcast(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n            unimpl!();\n        }\n\n        pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn ttl(&self) -> io::Result<u32> {\n            unimpl!();\n        }\n\n        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n            unimpl!();\n        }\n\n        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n            unimpl!();\n        }\n    }\n\n    impl FromInner<Socket> for UdpSocket {\n        fn from_inner(socket: Socket) -> UdpSocket {\n            UdpSocket { inner: socket }\n        }\n    }\n\n    impl fmt::Debug for UdpSocket {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"No networking support on L4Re available.\")\n        }\n    }\n\n    pub struct LookupHost {\n        original: *mut libc::addrinfo,\n        cur: *mut libc::addrinfo,\n    }\n\n    impl Iterator for LookupHost {\n        type Item = SocketAddr;\n        fn next(&mut self) -> Option<SocketAddr> {\n            None\n        }\n    }\n\n    impl LookupHost {\n        pub fn port(&self) -> u16 {\n            unimpl!();\n        }\n    }\n\n    unsafe impl Sync for LookupHost {}\n    unsafe impl Send for LookupHost {}\n\n    impl TryFrom<&str> for LookupHost {\n        type Error = io::Error;\n\n        fn try_from(_v: &str) -> io::Result<LookupHost> {\n            unimpl!();\n        }\n    }\n\n    impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n        type Error = io::Error;\n\n        fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n            unimpl!();\n        }\n    }\n}\n"],["2417","use crate::cmp::Ordering;\nuse crate::time::Duration;\n\nuse core::hash::{Hash, Hasher};\n\npub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\nuse crate::convert::TryInto;\n\nconst NSEC_PER_SEC: u64 = 1_000_000_000;\n\n#[derive(Copy, Clone)]\nstruct Timespec {\n    t: libc::timespec,\n}\n\nimpl Timespec {\n    const fn zero() -> Timespec {\n        Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } }\n    }\n\n    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n        if self >= other {\n            // NOTE(eddyb) two aspects of this `if`-`else` are required for LLVM\n            // to optimize it into a branchless form (see also #75545):\n            //\n            // 1. `self.t.tv_sec - other.t.tv_sec` shows up as a common expression\n            //    in both branches, i.e. the `else` must have its `- 1`\n            //    subtraction after the common one, not interleaved with it\n            //    (it used to be `self.t.tv_sec - 1 - other.t.tv_sec`)\n            //\n            // 2. the `Duration::new` call (or any other additional complexity)\n            //    is outside of the `if`-`else`, not duplicated in both branches\n            //\n            // Ideally this code could be rearranged such that it more\n            // directly expresses the lower-cost behavior we want from it.\n            let (secs, nsec) = if self.t.tv_nsec >= other.t.tv_nsec {\n                ((self.t.tv_sec - other.t.tv_sec) as u64, (self.t.tv_nsec - other.t.tv_nsec) as u32)\n            } else {\n                (\n                    (self.t.tv_sec - other.t.tv_sec - 1) as u64,\n                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n                )\n            };\n\n            Ok(Duration::new(secs, nsec))\n        } else {\n            match other.sub_timespec(self) {\n                Ok(d) => Err(d),\n                Err(d) => Ok(d),\n            }\n        }\n    }\n\n    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n        let mut secs = other\n            .as_secs()\n            .try_into() // <- target type would be `libc::time_t`\n            .ok()\n            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n\n        // Nano calculations can't overflow because nanos are <1B which fit\n        // in a u32.\n        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n        if nsec >= NSEC_PER_SEC as u32 {\n            nsec -= NSEC_PER_SEC as u32;\n            secs = secs.checked_add(1)?;\n        }\n        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n    }\n\n    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n        let mut secs = other\n            .as_secs()\n            .try_into() // <- target type would be `libc::time_t`\n            .ok()\n            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n\n        // Similar to above, nanos can't overflow.\n        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n        if nsec < 0 {\n            nsec += NSEC_PER_SEC as i32;\n            secs = secs.checked_sub(1)?;\n        }\n        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n    }\n}\n\nimpl PartialEq for Timespec {\n    fn eq(&self, other: &Timespec) -> bool {\n        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n    }\n}\n\nimpl Eq for Timespec {}\n\nimpl PartialOrd for Timespec {\n    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Timespec {\n    fn cmp(&self, other: &Timespec) -> Ordering {\n        let me = (self.t.tv_sec, self.t.tv_nsec);\n        let other = (other.t.tv_sec, other.t.tv_nsec);\n        me.cmp(&other)\n    }\n}\n\nimpl Hash for Timespec {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.t.tv_sec.hash(state);\n        self.t.tv_nsec.hash(state);\n    }\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\nmod inner {\n    use crate::fmt;\n    use crate::sync::atomic::{AtomicU64, Ordering};\n    use crate::sys::cvt;\n    use crate::sys_common::mul_div_u64;\n    use crate::time::Duration;\n\n    use super::Timespec;\n    use super::NSEC_PER_SEC;\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n    pub struct Instant {\n        t: u64,\n    }\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct SystemTime {\n        t: Timespec,\n    }\n\n    pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n\n    #[repr(C)]\n    #[derive(Copy, Clone)]\n    struct mach_timebase_info {\n        numer: u32,\n        denom: u32,\n    }\n    type mach_timebase_info_t = *mut mach_timebase_info;\n    type kern_return_t = libc::c_int;\n\n    impl Instant {\n        pub fn now() -> Instant {\n            extern \"C\" {\n                fn mach_absolute_time() -> u64;\n            }\n            Instant { t: unsafe { mach_absolute_time() } }\n        }\n\n        pub const fn zero() -> Instant {\n            Instant { t: 0 }\n        }\n\n        pub fn actually_monotonic() -> bool {\n            true\n        }\n\n        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n            let diff = self.t.checked_sub(other.t)?;\n            let info = info();\n            let nanos = mul_div_u64(diff, info.numer as u64, info.denom as u64);\n            Some(Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32))\n        }\n\n        pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n            Some(Instant { t: self.t.checked_add(checked_dur2intervals(other)?)? })\n        }\n\n        pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n            Some(Instant { t: self.t.checked_sub(checked_dur2intervals(other)?)? })\n        }\n    }\n\n    impl SystemTime {\n        pub fn now() -> SystemTime {\n            use crate::ptr;\n\n            let mut s = libc::timeval { tv_sec: 0, tv_usec: 0 };\n            cvt(unsafe { libc::gettimeofday(&mut s, ptr::null_mut()) }).unwrap();\n            return SystemTime::from(s);\n        }\n\n        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n            self.t.sub_timespec(&other.t)\n        }\n\n        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n            Some(SystemTime { t: self.t.checked_add_duration(other)? })\n        }\n\n        pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n            Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n        }\n    }\n\n    impl From<libc::timeval> for SystemTime {\n        fn from(t: libc::timeval) -> SystemTime {\n            SystemTime::from(libc::timespec {\n                tv_sec: t.tv_sec,\n                tv_nsec: (t.tv_usec * 1000) as libc::c_long,\n            })\n        }\n    }\n\n    impl From<libc::timespec> for SystemTime {\n        fn from(t: libc::timespec) -> SystemTime {\n            SystemTime { t: Timespec { t } }\n        }\n    }\n\n    impl fmt::Debug for SystemTime {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"SystemTime\")\n                .field(\"tv_sec\", &self.t.t.tv_sec)\n                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n                .finish()\n        }\n    }\n\n    fn checked_dur2intervals(dur: &Duration) -> Option<u64> {\n        let nanos =\n            dur.as_secs().checked_mul(NSEC_PER_SEC)?.checked_add(dur.subsec_nanos() as u64)?;\n        let info = info();\n        Some(mul_div_u64(nanos, info.denom as u64, info.numer as u64))\n    }\n\n    fn info() -> mach_timebase_info {\n        // INFO_BITS conceptually is an `Option<mach_timebase_info>`. We can do\n        // this in 64 bits because we know 0 is never a valid value for the\n        // `denom` field.\n        //\n        // Encoding this as a single `AtomicU64` allows us to use `Relaxed`\n        // operations, as we are only interested in the effects on a single\n        // memory location.\n        static INFO_BITS: AtomicU64 = AtomicU64::new(0);\n\n        // If a previous thread has initialized `INFO_BITS`, use it.\n        let info_bits = INFO_BITS.load(Ordering::Relaxed);\n        if info_bits != 0 {\n            return info_from_bits(info_bits);\n        }\n\n        // ... otherwise learn for ourselves ...\n        extern \"C\" {\n            fn mach_timebase_info(info: mach_timebase_info_t) -> kern_return_t;\n        }\n\n        let mut info = info_from_bits(0);\n        unsafe {\n            mach_timebase_info(&mut info);\n        }\n        INFO_BITS.store(info_to_bits(info), Ordering::Relaxed);\n        info\n    }\n\n    #[inline]\n    fn info_to_bits(info: mach_timebase_info) -> u64 {\n        ((info.denom as u64) << 32) | (info.numer as u64)\n    }\n\n    #[inline]\n    fn info_from_bits(bits: u64) -> mach_timebase_info {\n        mach_timebase_info { numer: bits as u32, denom: (bits >> 32) as u32 }\n    }\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\nmod inner {\n    use crate::fmt;\n    use crate::sys::cvt;\n    use crate::time::Duration;\n\n    use super::Timespec;\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct Instant {\n        t: Timespec,\n    }\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct SystemTime {\n        t: Timespec,\n    }\n\n    pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n\n    impl Instant {\n        pub fn now() -> Instant {\n            Instant { t: now(libc::CLOCK_MONOTONIC) }\n        }\n\n        pub const fn zero() -> Instant {\n            Instant { t: Timespec::zero() }\n        }\n\n        pub fn actually_monotonic() -> bool {\n            (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86_64\"))\n                || (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86\"))\n                || cfg!(target_os = \"fuchsia\")\n        }\n\n        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n            self.t.sub_timespec(&other.t).ok()\n        }\n\n        pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n            Some(Instant { t: self.t.checked_add_duration(other)? })\n        }\n\n        pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n            Some(Instant { t: self.t.checked_sub_duration(other)? })\n        }\n    }\n\n    impl fmt::Debug for Instant {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"Instant\")\n                .field(\"tv_sec\", &self.t.t.tv_sec)\n                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n                .finish()\n        }\n    }\n\n    impl SystemTime {\n        pub fn now() -> SystemTime {\n            SystemTime { t: now(libc::CLOCK_REALTIME) }\n        }\n\n        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n            self.t.sub_timespec(&other.t)\n        }\n\n        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n            Some(SystemTime { t: self.t.checked_add_duration(other)? })\n        }\n\n        pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n            Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n        }\n    }\n\n    impl From<libc::timespec> for SystemTime {\n        fn from(t: libc::timespec) -> SystemTime {\n            SystemTime { t: Timespec { t } }\n        }\n    }\n\n    impl fmt::Debug for SystemTime {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"SystemTime\")\n                .field(\"tv_sec\", &self.t.t.tv_sec)\n                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n                .finish()\n        }\n    }\n\n    #[cfg(not(target_os = \"dragonfly\"))]\n    pub type clock_t = libc::c_int;\n    #[cfg(target_os = \"dragonfly\")]\n    pub type clock_t = libc::c_ulong;\n\n    fn now(clock: clock_t) -> Timespec {\n        let mut t = Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } };\n        cvt(unsafe { libc::clock_gettime(clock, &mut t.t) }).unwrap();\n        t\n    }\n}\n"],["2418","//! Global initialization and retrieval of command line arguments.\n//!\n//! On some platforms these are stored during runtime startup,\n//! and on some they are retrieved from the system on demand.\n\n#![allow(dead_code)] // runtime init functions not used during testing\n\nuse crate::ffi::OsString;\nuse crate::fmt;\nuse crate::vec;\n\n/// One-time global initialization.\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    imp::init(argc, argv)\n}\n\n/// One-time global cleanup.\npub unsafe fn cleanup() {\n    imp::cleanup()\n}\n\n/// Returns the command line arguments\npub fn args() -> Args {\n    imp::args()\n}\n\npub struct Args {\n    iter: vec::IntoIter<OsString>,\n}\n\nimpl !Send for Args {}\nimpl !Sync for Args {}\n\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.iter.as_slice().fmt(f)\n    }\n}\n\nimpl Iterator for Args {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}\n\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<OsString> {\n        self.iter.next_back()\n    }\n}\n\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"android\",\n    target_os = \"freebsd\",\n    target_os = \"dragonfly\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n    target_os = \"solaris\",\n    target_os = \"illumos\",\n    target_os = \"emscripten\",\n    target_os = \"haiku\",\n    target_os = \"l4re\",\n    target_os = \"fuchsia\",\n    target_os = \"redox\",\n    target_os = \"vxworks\"\n))]\nmod imp {\n    use super::Args;\n    use crate::ffi::{CStr, OsString};\n    use crate::os::unix::prelude::*;\n    use crate::ptr;\n    use crate::sync::atomic::{AtomicIsize, AtomicPtr, Ordering};\n\n    use crate::sys_common::mutex::StaticMutex;\n\n    static ARGC: AtomicIsize = AtomicIsize::new(0);\n    static ARGV: AtomicPtr<*const u8> = AtomicPtr::new(ptr::null_mut());\n    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n    // acquire this mutex reentrantly!\n    static LOCK: StaticMutex = StaticMutex::new();\n\n    unsafe fn really_init(argc: isize, argv: *const *const u8) {\n        let _guard = LOCK.lock();\n        ARGC.store(argc, Ordering::Relaxed);\n        ARGV.store(argv as *mut _, Ordering::Relaxed);\n    }\n\n    #[inline(always)]\n    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n        // On Linux-GNU, we rely on `ARGV_INIT_ARRAY` below to initialize\n        // `ARGC` and `ARGV`. But in Miri that does not actually happen so we\n        // still initialize here.\n        #[cfg(any(miri, not(all(target_os = \"linux\", target_env = \"gnu\"))))]\n        really_init(_argc, _argv);\n    }\n\n    /// glibc passes argc, argv, and envp to functions in .init_array, as a non-standard extension.\n    /// This allows `std::env::args` to work even in a `cdylib`, as it does on macOS and Windows.\n    #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n    #[used]\n    #[link_section = \".init_array.00099\"]\n    static ARGV_INIT_ARRAY: extern \"C\" fn(\n        crate::os::raw::c_int,\n        *const *const u8,\n        *const *const u8,\n    ) = {\n        extern \"C\" fn init_wrapper(\n            argc: crate::os::raw::c_int,\n            argv: *const *const u8,\n            _envp: *const *const u8,\n        ) {\n            unsafe {\n                really_init(argc as isize, argv);\n            }\n        }\n        init_wrapper\n    };\n\n    pub unsafe fn cleanup() {\n        let _guard = LOCK.lock();\n        ARGC.store(0, Ordering::Relaxed);\n        ARGV.store(ptr::null_mut(), Ordering::Relaxed);\n    }\n\n    pub fn args() -> Args {\n        Args { iter: clone().into_iter() }\n    }\n\n    fn clone() -> Vec<OsString> {\n        unsafe {\n            let _guard = LOCK.lock();\n            let argc = ARGC.load(Ordering::Relaxed);\n            let argv = ARGV.load(Ordering::Relaxed);\n            (0..argc)\n                .map(|i| {\n                    let cstr = CStr::from_ptr(*argv.offset(i) as *const libc::c_char);\n                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n                })\n                .collect()\n        }\n    }\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\nmod imp {\n    use super::Args;\n    use crate::ffi::CStr;\n\n    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n\n    pub fn cleanup() {}\n\n    #[cfg(target_os = \"macos\")]\n    pub fn args() -> Args {\n        use crate::os::unix::prelude::*;\n        extern \"C\" {\n            // These functions are in crt_externs.h.\n            fn _NSGetArgc() -> *mut libc::c_int;\n            fn _NSGetArgv() -> *mut *mut *mut libc::c_char;\n        }\n\n        let vec = unsafe {\n            let (argc, argv) =\n                (*_NSGetArgc() as isize, *_NSGetArgv() as *const *const libc::c_char);\n            (0..argc as isize)\n                .map(|i| {\n                    let bytes = CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec();\n                    OsStringExt::from_vec(bytes)\n                })\n                .collect::<Vec<_>>()\n        };\n        Args { iter: vec.into_iter() }\n    }\n\n    // As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n    // and use underscores in their names - they're most probably\n    // are considered private and therefore should be avoided\n    // Here is another way to get arguments using Objective C\n    // runtime\n    //\n    // In general it looks like:\n    // res = Vec::new()\n    // let args = [[NSProcessInfo processInfo] arguments]\n    // for i in (0..[args count])\n    //      res.push([args objectAtIndex:i])\n    // res\n    #[cfg(target_os = \"ios\")]\n    pub fn args() -> Args {\n        use crate::ffi::OsString;\n        use crate::mem;\n        use crate::str;\n\n        extern \"C\" {\n            fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n            fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n        }\n\n        #[cfg(target_arch = \"aarch64\")]\n        extern \"C\" {\n            fn objc_msgSend(obj: NsId, sel: Sel) -> NsId;\n            #[allow(clashing_extern_declarations)]\n            #[link_name = \"objc_msgSend\"]\n            fn objc_msgSend_ul(obj: NsId, sel: Sel, i: libc::c_ulong) -> NsId;\n        }\n\n        #[cfg(not(target_arch = \"aarch64\"))]\n        extern \"C\" {\n            fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n            #[allow(clashing_extern_declarations)]\n            #[link_name = \"objc_msgSend\"]\n            fn objc_msgSend_ul(obj: NsId, sel: Sel, ...) -> NsId;\n        }\n\n        type Sel = *const libc::c_void;\n        type NsId = *const libc::c_void;\n\n        let mut res = Vec::new();\n\n        unsafe {\n            let process_info_sel = sel_registerName(\"processInfo\\0\".as_ptr());\n            let arguments_sel = sel_registerName(\"arguments\\0\".as_ptr());\n            let utf8_sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n            let count_sel = sel_registerName(\"count\\0\".as_ptr());\n            let object_at_sel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n\n            let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n            let info = objc_msgSend(klass, process_info_sel);\n            let args = objc_msgSend(info, arguments_sel);\n\n            let cnt: usize = mem::transmute(objc_msgSend(args, count_sel));\n            for i in 0..cnt {\n                let tmp = objc_msgSend_ul(args, object_at_sel, i as libc::c_ulong);\n                let utf_c_str: *const libc::c_char = mem::transmute(objc_msgSend(tmp, utf8_sel));\n                let bytes = CStr::from_ptr(utf_c_str).to_bytes();\n                res.push(OsString::from(str::from_utf8(bytes).unwrap()))\n            }\n        }\n\n        Args { iter: res.into_iter() }\n    }\n}\n"],["2419","use crate::mem;\nuse crate::slice;\n\npub fn hashmap_random_keys() -> (u64, u64) {\n    let mut v = (0, 0);\n    unsafe {\n        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8, mem::size_of_val(&v));\n        imp::fill_bytes(view);\n    }\n    v\n}\n\n#[cfg(all(\n    unix,\n    not(target_os = \"macos\"),\n    not(target_os = \"ios\"),\n    not(target_os = \"openbsd\"),\n    not(target_os = \"freebsd\"),\n    not(target_os = \"netbsd\"),\n    not(target_os = \"fuchsia\"),\n    not(target_os = \"redox\"),\n    not(target_os = \"vxworks\")\n))]\nmod imp {\n    use crate::fs::File;\n    use crate::io::Read;\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    fn getrandom(buf: &mut [u8]) -> libc::ssize_t {\n        // A weak symbol allows interposition, e.g. for perf measurements that want to\n        // disable randomness for consistency. Otherwise, we'll try a raw syscall.\n        // (`getrandom` was added in glibc 2.25, musl 1.1.20, android API level 28)\n        syscall! {\n            fn getrandom(\n                buffer: *mut libc::c_void,\n                length: libc::size_t,\n                flags: libc::c_uint\n            ) -> libc::ssize_t\n        }\n\n        unsafe { getrandom(buf.as_mut_ptr().cast(), buf.len(), libc::GRND_NONBLOCK) }\n    }\n\n    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n    fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool {\n        false\n    }\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n        use crate::sync::atomic::{AtomicBool, Ordering};\n        use crate::sys::os::errno;\n\n        static GETRANDOM_UNAVAILABLE: AtomicBool = AtomicBool::new(false);\n        if GETRANDOM_UNAVAILABLE.load(Ordering::Relaxed) {\n            return false;\n        }\n\n        let mut read = 0;\n        while read < v.len() {\n            let result = getrandom(&mut v[read..]);\n            if result == -1 {\n                let err = errno() as libc::c_int;\n                if err == libc::EINTR {\n                    continue;\n                } else if err == libc::ENOSYS || err == libc::EPERM {\n                    // Fall back to reading /dev/urandom if `getrandom` is not\n                    // supported on the current kernel.\n                    //\n                    // Also fall back in case it is disabled by something like\n                    // seccomp or inside of virtual machines.\n                    GETRANDOM_UNAVAILABLE.store(true, Ordering::Relaxed);\n                    return false;\n                } else if err == libc::EAGAIN {\n                    return false;\n                } else {\n                    panic!(\"unexpected getrandom error: {}\", err);\n                }\n            } else {\n                read += result as usize;\n            }\n        }\n        true\n    }\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        // getrandom_fill_bytes here can fail if getrandom() returns EAGAIN,\n        // meaning it would have blocked because the non-blocking pool (urandom)\n        // has not initialized in the kernel yet due to a lack of entropy. The\n        // fallback we do here is to avoid blocking applications which could\n        // depend on this call without ever knowing they do and don't have a\n        // work around. The PRNG of /dev/urandom will still be used but over a\n        // possibly predictable entropy pool.\n        if getrandom_fill_bytes(v) {\n            return;\n        }\n\n        // getrandom failed because it is permanently or temporarily (because\n        // of missing entropy) unavailable. Open /dev/urandom, read from it,\n        // and close it again.\n        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nmod imp {\n    use crate::fs::File;\n    use crate::io::Read;\n    use crate::sys::os::errno;\n    use libc::{c_int, c_void, size_t};\n\n    fn getentropy_fill_bytes(v: &mut [u8]) -> bool {\n        weak!(fn getentropy(*mut c_void, size_t) -> c_int);\n\n        getentropy\n            .get()\n            .map(|f| {\n                // getentropy(2) permits a maximum buffer size of 256 bytes\n                for s in v.chunks_mut(256) {\n                    let ret = unsafe { f(s.as_mut_ptr() as *mut c_void, s.len()) };\n                    if ret == -1 {\n                        panic!(\"unexpected getentropy error: {}\", errno());\n                    }\n                }\n                true\n            })\n            .unwrap_or(false)\n    }\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        if getentropy_fill_bytes(v) {\n            return;\n        }\n\n        // for older macos which doesn't support getentropy\n        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n    }\n}\n\n#[cfg(target_os = \"openbsd\")]\nmod imp {\n    use crate::sys::os::errno;\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        // getentropy(2) permits a maximum buffer size of 256 bytes\n        for s in v.chunks_mut(256) {\n            let ret = unsafe { libc::getentropy(s.as_mut_ptr() as *mut libc::c_void, s.len()) };\n            if ret == -1 {\n                panic!(\"unexpected getentropy error: {}\", errno());\n            }\n        }\n    }\n}\n\n// On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n// `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n// from `/dev/random` and which runs on its own thread accessed via GCD.\n// This seems needlessly heavyweight for the purposes of generating two u64s\n// once per thread in `hashmap_random_keys`. Therefore `SecRandomCopyBytes` is\n// only used on iOS where direct access to `/dev/urandom` is blocked by the\n// sandbox.\n#[cfg(target_os = \"ios\")]\nmod imp {\n    use crate::io;\n    use crate::ptr;\n    use libc::{c_int, size_t};\n\n    enum SecRandom {}\n\n    #[allow(non_upper_case_globals)]\n    const kSecRandomDefault: *const SecRandom = ptr::null();\n\n    extern \"C\" {\n        fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n    }\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n        if ret == -1 {\n            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n        }\n    }\n}\n\n#[cfg(any(target_os = \"freebsd\", target_os = \"netbsd\"))]\nmod imp {\n    use crate::ptr;\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        let mib = [libc::CTL_KERN, libc::KERN_ARND];\n        // kern.arandom permits a maximum buffer size of 256 bytes\n        for s in v.chunks_mut(256) {\n            let mut s_len = s.len();\n            let ret = unsafe {\n                libc::sysctl(\n                    mib.as_ptr(),\n                    mib.len() as libc::c_uint,\n                    s.as_mut_ptr() as *mut _,\n                    &mut s_len,\n                    ptr::null(),\n                    0,\n                )\n            };\n            if ret == -1 || s_len != s.len() {\n                panic!(\n                    \"kern.arandom sysctl failed! (returned {}, s.len() {}, oldlenp {})\",\n                    ret,\n                    s.len(),\n                    s_len\n                );\n            }\n        }\n    }\n}\n\n#[cfg(target_os = \"fuchsia\")]\nmod imp {\n    #[link(name = \"zircon\")]\n    extern \"C\" {\n        fn zx_cprng_draw(buffer: *mut u8, len: usize);\n    }\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        unsafe { zx_cprng_draw(v.as_mut_ptr(), v.len()) }\n    }\n}\n\n#[cfg(target_os = \"redox\")]\nmod imp {\n    use crate::fs::File;\n    use crate::io::Read;\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        // Open rand:, read from it, and close it again.\n        let mut file = File::open(\"rand:\").expect(\"failed to open rand:\");\n        file.read_exact(v).expect(\"failed to read rand:\")\n    }\n}\n\n#[cfg(target_os = \"vxworks\")]\nmod imp {\n    use crate::io;\n    use core::sync::atomic::{AtomicBool, Ordering::Relaxed};\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        static RNG_INIT: AtomicBool = AtomicBool::new(false);\n        while !RNG_INIT.load(Relaxed) {\n            let ret = unsafe { libc::randSecure() };\n            if ret < 0 {\n                panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n            } else if ret > 0 {\n                RNG_INIT.store(true, Relaxed);\n                break;\n            }\n            unsafe { libc::usleep(10) };\n        }\n        let ret = unsafe {\n            libc::randABytes(v.as_mut_ptr() as *mut libc::c_uchar, v.len() as libc::c_int)\n        };\n        if ret < 0 {\n            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n        }\n    }\n}\n"],["2420","use crate::marker::PhantomData;\nuse crate::slice;\n\nuse libc::{c_void, iovec};\n\n#[derive(Copy, Clone)]\n#[repr(transparent)]\npub struct IoSlice<'a> {\n    vec: iovec,\n    _p: PhantomData<&'a [u8]>,\n}\n\nimpl<'a> IoSlice<'a> {\n    #[inline]\n    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n        IoSlice {\n            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },\n            _p: PhantomData,\n        }\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        if self.vec.iov_len < n {\n            panic!(\"advancing IoSlice beyond its length\");\n        }\n\n        unsafe {\n            self.vec.iov_len -= n;\n            self.vec.iov_base = self.vec.iov_base.add(n);\n        }\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n    }\n}\n\n#[repr(transparent)]\npub struct IoSliceMut<'a> {\n    vec: iovec,\n    _p: PhantomData<&'a mut [u8]>,\n}\n\nimpl<'a> IoSliceMut<'a> {\n    #[inline]\n    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n        IoSliceMut {\n            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },\n            _p: PhantomData,\n        }\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        if self.vec.iov_len < n {\n            panic!(\"advancing IoSliceMut beyond its length\");\n        }\n\n        unsafe {\n            self.vec.iov_len -= n;\n            self.vec.iov_base = self.vec.iov_base.add(n);\n        }\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n    }\n\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n    }\n}\n"],["2421","use crate::cell::UnsafeCell;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\n\npub struct RWLock {\n    inner: UnsafeCell<libc::pthread_rwlock_t>,\n    write_locked: UnsafeCell<bool>, // guarded by the `inner` RwLock\n    num_readers: AtomicUsize,\n}\n\npub type MovableRWLock = Box<RWLock>;\n\nunsafe impl Send for RWLock {}\nunsafe impl Sync for RWLock {}\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock {\n            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n            write_locked: UnsafeCell::new(false),\n            num_readers: AtomicUsize::new(0),\n        }\n    }\n    #[inline]\n    pub unsafe fn read(&self) {\n        let r = libc::pthread_rwlock_rdlock(self.inner.get());\n\n        // According to POSIX, when a thread tries to acquire this read lock\n        // while it already holds the write lock\n        // (or vice versa, or tries to acquire the write lock twice),\n        // \"the call shall either deadlock or return [EDEADLK]\"\n        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html,\n        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_rdlock.html).\n        // So, in principle, all we have to do here is check `r == 0` to be sure we properly\n        // got the lock.\n        //\n        // However, (at least) glibc before version 2.25 does not conform to this spec,\n        // and can return `r == 0` even when this thread already holds the write lock.\n        // We thus check for this situation ourselves and panic when detecting that a thread\n        // got the write lock more than once, or got a read and a write lock.\n        if r == libc::EAGAIN {\n            panic!(\"rwlock maximum reader count exceeded\");\n        } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n            // data races.\n            if r == 0 {\n                // `pthread_rwlock_rdlock` succeeded when it should not have.\n                self.raw_unlock();\n            }\n            panic!(\"rwlock read lock would result in deadlock\");\n        } else {\n            // According to POSIX, for a properly initialized rwlock this can only\n            // return EAGAIN or EDEADLK or 0. We rely on that.\n            debug_assert_eq!(r, 0);\n            self.num_readers.fetch_add(1, Ordering::Relaxed);\n        }\n    }\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n        if r == 0 {\n            if *self.write_locked.get() {\n                // `pthread_rwlock_tryrdlock` succeeded when it should not have.\n                self.raw_unlock();\n                false\n            } else {\n                self.num_readers.fetch_add(1, Ordering::Relaxed);\n                true\n            }\n        } else {\n            false\n        }\n    }\n    #[inline]\n    pub unsafe fn write(&self) {\n        let r = libc::pthread_rwlock_wrlock(self.inner.get());\n        // See comments above for why we check for EDEADLK and write_locked. For the same reason,\n        // we also need to check that there are no readers (tracked in `num_readers`).\n        if r == libc::EDEADLK\n            || (r == 0 && *self.write_locked.get())\n            || self.num_readers.load(Ordering::Relaxed) != 0\n        {\n            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n            // data races.\n            if r == 0 {\n                // `pthread_rwlock_wrlock` succeeded when it should not have.\n                self.raw_unlock();\n            }\n            panic!(\"rwlock write lock would result in deadlock\");\n        } else {\n            // According to POSIX, for a properly initialized rwlock this can only\n            // return EDEADLK or 0. We rely on that.\n            debug_assert_eq!(r, 0);\n        }\n        *self.write_locked.get() = true;\n    }\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n        if r == 0 {\n            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n                // `pthread_rwlock_trywrlock` succeeded when it should not have.\n                self.raw_unlock();\n                false\n            } else {\n                *self.write_locked.get() = true;\n                true\n            }\n        } else {\n            false\n        }\n    }\n    #[inline]\n    unsafe fn raw_unlock(&self) {\n        let r = libc::pthread_rwlock_unlock(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        debug_assert!(!*self.write_locked.get());\n        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n        self.raw_unlock();\n    }\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n        debug_assert!(*self.write_locked.get());\n        *self.write_locked.get() = false;\n        self.raw_unlock();\n    }\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_rwlock_destroy(self.inner.get());\n        // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n        // rwlock that was just initialized with\n        // libc::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n        // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n        if cfg!(target_os = \"dragonfly\") {\n            debug_assert!(r == 0 || r == libc::EINVAL);\n        } else {\n            debug_assert_eq!(r, 0);\n        }\n    }\n}\n"],["2422","use crate::cell::UnsafeCell;\nuse crate::sys::mutex::{self, Mutex};\nuse crate::time::Duration;\n\npub struct Condvar {\n    inner: UnsafeCell<libc::pthread_cond_t>,\n}\n\npub type MovableCondvar = Box<Condvar>;\n\nunsafe impl Send for Condvar {}\nunsafe impl Sync for Condvar {}\n\nconst TIMESPEC_MAX: libc::timespec =\n    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n\nfn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n}\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        // Might be moved and address is changing it is better to avoid\n        // initialization of potentially opaque OS data before it landed\n        Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n    }\n\n    #[cfg(any(\n        target_os = \"macos\",\n        target_os = \"ios\",\n        target_os = \"l4re\",\n        target_os = \"android\",\n        target_os = \"redox\"\n    ))]\n    pub unsafe fn init(&mut self) {}\n\n    #[cfg(not(any(\n        target_os = \"macos\",\n        target_os = \"ios\",\n        target_os = \"l4re\",\n        target_os = \"android\",\n        target_os = \"redox\"\n    )))]\n    pub unsafe fn init(&mut self) {\n        use crate::mem::MaybeUninit;\n        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n        assert_eq!(r, 0);\n        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n        assert_eq!(r, 0);\n        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n        assert_eq!(r, 0);\n        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n        assert_eq!(r, 0);\n    }\n\n    #[inline]\n    pub unsafe fn notify_one(&self) {\n        let r = libc::pthread_cond_signal(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n\n    #[inline]\n    pub unsafe fn notify_all(&self) {\n        let r = libc::pthread_cond_broadcast(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n\n    #[inline]\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n        let r = libc::pthread_cond_wait(self.inner.get(), mutex::raw(mutex));\n        debug_assert_eq!(r, 0);\n    }\n\n    // This implementation is used on systems that support pthread_condattr_setclock\n    // where we configure condition variable to use monotonic clock (instead of\n    // default system clock). This approach avoids all problems that result\n    // from changes made to the system time.\n    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\")))]\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n        use crate::mem;\n\n        let mut now: libc::timespec = mem::zeroed();\n        let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n        assert_eq!(r, 0);\n\n        // Nanosecond calculations can't overflow because both values are below 1e9.\n        let nsec = dur.subsec_nanos() + now.tv_nsec as u32;\n\n        let sec = saturating_cast_to_time_t(dur.as_secs())\n            .checked_add((nsec / 1_000_000_000) as libc::time_t)\n            .and_then(|s| s.checked_add(now.tv_sec));\n        let nsec = nsec % 1_000_000_000;\n\n        let timeout =\n            sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n\n        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n        assert!(r == libc::ETIMEDOUT || r == 0);\n        r == 0\n    }\n\n    // This implementation is modeled after libcxx's condition_variable\n    // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n    // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n        use crate::ptr;\n        use crate::time::Instant;\n\n        // 1000 years\n        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n\n        if dur > max_dur {\n            // OSX implementation of `pthread_cond_timedwait` is buggy\n            // with super long durations. When duration is greater than\n            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n            // in macOS Sierra return error 316.\n            //\n            // This program demonstrates the issue:\n            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n            //\n            // To work around this issue, and possible bugs of other OSes, timeout\n            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n            // because of spurious wakeups.\n\n            dur = max_dur;\n        }\n\n        // First, figure out what time it currently is, in both system and\n        // stable time.  pthread_cond_timedwait uses system time, but we want to\n        // report timeout based on stable time.\n        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n        let stable_now = Instant::now();\n        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n        debug_assert_eq!(r, 0);\n\n        let nsec = dur.subsec_nanos() as libc::c_long + (sys_now.tv_usec * 1000) as libc::c_long;\n        let extra = (nsec / 1_000_000_000) as libc::time_t;\n        let nsec = nsec % 1_000_000_000;\n        let seconds = saturating_cast_to_time_t(dur.as_secs());\n\n        let timeout = sys_now\n            .tv_sec\n            .checked_add(extra)\n            .and_then(|s| s.checked_add(seconds))\n            .map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec })\n            .unwrap_or(TIMESPEC_MAX);\n\n        // And wait!\n        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n        debug_assert!(r == libc::ETIMEDOUT || r == 0);\n\n        // ETIMEDOUT is not a totally reliable method of determining timeout due\n        // to clock shifts, so do the check ourselves\n        stable_now.elapsed() < dur\n    }\n\n    #[inline]\n    #[cfg(not(target_os = \"dragonfly\"))]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_cond_destroy(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n\n    #[inline]\n    #[cfg(target_os = \"dragonfly\")]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_cond_destroy(self.inner.get());\n        // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n        // a condvar that was just initialized with\n        // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n        // pthread_cond_init() is called, this behaviour no longer occurs.\n        debug_assert!(r == 0 || r == libc::EINVAL);\n    }\n}\n"],["2423","use crate::io::{self, IoSlice, IoSliceMut};\nuse crate::mem;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::{cvt, cvt_r};\n\n////////////////////////////////////////////////////////////////////////////////\n// Anonymous pipes\n////////////////////////////////////////////////////////////////////////////////\n\npub struct AnonPipe(FileDesc);\n\npub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n    let mut fds = [0; 2];\n\n    // The only known way right now to create atomically set the CLOEXEC flag is\n    // to use the `pipe2` syscall. This was added to Linux in 2.6.27, glibc 2.9\n    // and musl 0.9.3, and some other targets also have it.\n    cfg_if::cfg_if! {\n        if #[cfg(any(\n            target_os = \"dragonfly\",\n            target_os = \"freebsd\",\n            target_os = \"linux\",\n            target_os = \"netbsd\",\n            target_os = \"openbsd\",\n            target_os = \"redox\"\n        ))] {\n            cvt(unsafe { libc::pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) })?;\n            Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))))\n        } else {\n            cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n\n            let fd0 = FileDesc::new(fds[0]);\n            let fd1 = FileDesc::new(fds[1]);\n            fd0.set_cloexec()?;\n            fd1.set_cloexec()?;\n            Ok((AnonPipe(fd0), AnonPipe(fd1)))\n        }\n    }\n}\n\nimpl AnonPipe {\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.0.is_read_vectored()\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    pub fn fd(&self) -> &FileDesc {\n        &self.0\n    }\n    pub fn into_fd(self) -> FileDesc {\n        self.0\n    }\n}\n\npub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n    // Set both pipes into nonblocking mode as we're gonna be reading from both\n    // in the `select` loop below, and we wouldn't want one to block the other!\n    let p1 = p1.into_fd();\n    let p2 = p2.into_fd();\n    p1.set_nonblocking(true)?;\n    p2.set_nonblocking(true)?;\n\n    let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n    fds[0].fd = p1.raw();\n    fds[0].events = libc::POLLIN;\n    fds[1].fd = p2.raw();\n    fds[1].events = libc::POLLIN;\n    loop {\n        // wait for either pipe to become readable using `poll`\n        cvt_r(|| unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) })?;\n\n        if fds[0].revents != 0 && read(&p1, v1)? {\n            p2.set_nonblocking(false)?;\n            return p2.read_to_end(v2).map(drop);\n        }\n        if fds[1].revents != 0 && read(&p2, v2)? {\n            p1.set_nonblocking(false)?;\n            return p1.read_to_end(v1).map(drop);\n        }\n    }\n\n    // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n    // EAGAIN. If we hit EOF, then this will happen because the underlying\n    // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n    // this case we flip the other fd back into blocking mode and read\n    // whatever's leftover on that file descriptor.\n    fn read(fd: &FileDesc, dst: &mut Vec<u8>) -> Result<bool, io::Error> {\n        match fd.read_to_end(dst) {\n            Ok(_) => Ok(true),\n            Err(e) => {\n                if e.raw_os_error() == Some(libc::EWOULDBLOCK)\n                    || e.raw_os_error() == Some(libc::EAGAIN)\n                {\n                    Ok(false)\n                } else {\n                    Err(e)\n                }\n            }\n        }\n    }\n}\n"],["2424","use crate::alloc::{GlobalAlloc, Layout, System};\nuse crate::ptr;\nuse crate::sys::common::alloc::{realloc_fallback, MIN_ALIGN};\n\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        // jemalloc provides alignment less than MIN_ALIGN for small allocations.\n        // So only rely on MIN_ALIGN if size >= align.\n        // Also see <https://github.com/rust-lang/rust/issues/45955> and\n        // <https://github.com/rust-lang/rust/issues/62251#issuecomment-507580914>.\n        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n            libc::malloc(layout.size()) as *mut u8\n        } else {\n            #[cfg(target_os = \"macos\")]\n            {\n                if layout.align() > (1 << 31) {\n                    return ptr::null_mut();\n                }\n            }\n            aligned_malloc(&layout)\n        }\n    }\n\n    #[inline]\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        // See the comment above in `alloc` for why this check looks the way it does.\n        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n            libc::calloc(layout.size(), 1) as *mut u8\n        } else {\n            let ptr = self.alloc(layout);\n            if !ptr.is_null() {\n                ptr::write_bytes(ptr, 0, layout.size());\n            }\n            ptr\n        }\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n        libc::free(ptr as *mut libc::c_void)\n    }\n\n    #[inline]\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n        } else {\n            realloc_fallback(self, ptr, layout, new_size)\n        }\n    }\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(any(\n        target_os = \"android\",\n        target_os = \"illumos\",\n        target_os = \"redox\",\n        target_os = \"solaris\"\n    ))] {\n        #[inline]\n        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n            // On android we currently target API level 9 which unfortunately\n            // doesn't have the `posix_memalign` API used below. Instead we use\n            // `memalign`, but this unfortunately has the property on some systems\n            // where the memory returned cannot be deallocated by `free`!\n            //\n            // Upon closer inspection, however, this appears to work just fine with\n            // Android, so for this platform we should be fine to call `memalign`\n            // (which is present in API level 9). Some helpful references could\n            // possibly be chromium using memalign [1], attempts at documenting that\n            // memalign + free is ok [2] [3], or the current source of chromium\n            // which still uses memalign on android [4].\n            //\n            // [1]: https://codereview.chromium.org/10796020/\n            // [2]: https://code.google.com/p/android/issues/detail?id=35391\n            // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n            // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n            //                                       /memory/aligned_memory.cc\n            libc::memalign(layout.align(), layout.size()) as *mut u8\n        }\n    } else if #[cfg(target_os = \"wasi\")] {\n        #[inline]\n        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n            libc::aligned_alloc(layout.align(), layout.size()) as *mut u8\n        }\n    } else {\n        #[inline]\n        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n            let mut out = ptr::null_mut();\n            // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n            // Since these are all powers of 2, we can just use max.\n            let align = layout.align().max(crate::mem::size_of::<usize>());\n            let ret = libc::posix_memalign(&mut out, align, layout.size());\n            if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n        }\n    }\n}\n"],["2425","// Original implementation taken from rust-memchr.\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\npub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    let p = unsafe {\n        libc::memchr(\n            haystack.as_ptr() as *const libc::c_void,\n            needle as libc::c_int,\n            haystack.len(),\n        )\n    };\n    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n}\n\npub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    #[cfg(target_os = \"linux\")]\n    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n        if haystack.is_empty() {\n            return None;\n        }\n        let p = unsafe {\n            libc::memrchr(\n                haystack.as_ptr() as *const libc::c_void,\n                needle as libc::c_int,\n                haystack.len(),\n            )\n        };\n        if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n        core::slice::memchr::memrchr(needle, haystack)\n    }\n\n    memrchr_specific(needle, haystack)\n}\n"],["2426","use super::*;\n\nuse crate::ffi::OsStr;\nuse crate::mem;\nuse crate::ptr;\nuse crate::sys::cvt;\n\nmacro_rules! t {\n    ($e:expr) => {\n        match $e {\n            Ok(t) => t,\n            Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n        }\n    };\n}\n\n#[test]\n#[cfg_attr(\n    any(\n        // See #14232 for more information, but it appears that signal delivery to a\n        // newly spawned process may just be raced in the macOS, so to prevent this\n        // test from being flaky we ignore it on macOS.\n        target_os = \"macos\",\n        // When run under our current QEMU emulation test suite this test fails,\n        // although the reason isn't very clear as to why. For now this test is\n        // ignored there.\n        target_arch = \"arm\",\n        target_arch = \"aarch64\",\n        target_arch = \"riscv64\",\n    ),\n    ignore\n)]\nfn test_process_mask() {\n    unsafe {\n        // Test to make sure that a signal mask does not get inherited.\n        let mut cmd = Command::new(OsStr::new(\"cat\"));\n\n        let mut set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n        let mut old_set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n        t!(cvt(sigemptyset(set.as_mut_ptr())));\n        t!(cvt(sigaddset(set.as_mut_ptr(), libc::SIGINT)));\n        t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), old_set.as_mut_ptr())));\n\n        cmd.stdin(Stdio::MakePipe);\n        cmd.stdout(Stdio::MakePipe);\n\n        let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n        let stdin_write = pipes.stdin.take().unwrap();\n        let stdout_read = pipes.stdout.take().unwrap();\n\n        t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(), ptr::null_mut())));\n\n        t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n        // We need to wait until SIGINT is definitely delivered. The\n        // easiest way is to write something to cat, and try to read it\n        // back: if SIGINT is unmasked, it'll get delivered when cat is\n        // next scheduled.\n        let _ = stdin_write.write(b\"Hello\");\n        drop(stdin_write);\n\n        // Either EOF or failure (EPIPE) is okay.\n        let mut buf = [0; 5];\n        if let Ok(ret) = stdout_read.read(&mut buf) {\n            assert_eq!(ret, 0);\n        }\n\n        t!(cat.wait());\n    }\n}\n"],["2427","#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\nuse crate::os::unix::prelude::*;\n\nuse crate::collections::BTreeMap;\nuse crate::ffi::{CStr, CString, OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::path::Path;\nuse crate::ptr;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::fs::File;\nuse crate::sys::pipe::{self, AnonPipe};\nuse crate::sys_common::process::{CommandEnv, CommandEnvs};\n\n#[cfg(not(target_os = \"fuchsia\"))]\nuse crate::sys::fs::OpenOptions;\n\nuse libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"fuchsia\")] {\n        // fuchsia doesn't have /dev/null\n    } else if #[cfg(target_os = \"redox\")] {\n        const DEV_NULL: &str = \"null:\\0\";\n    } else if #[cfg(target_os = \"vxworks\")] {\n        const DEV_NULL: &str = \"/null\\0\";\n    } else {\n        const DEV_NULL: &str = \"/dev/null\\0\";\n    }\n}\n\n// Android with api less than 21 define sig* functions inline, so it is not\n// available for dynamic link. Implementing sigemptyset and sigaddset allow us\n// to support older Android version (independent of libc version).\n// The following implementations are based on https://git.io/vSkNf\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"android\")] {\n        pub unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n            set.write_bytes(0u8, 1);\n            return 0;\n        }\n        #[allow(dead_code)]\n        pub unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n            use crate::{slice, mem};\n\n            let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n            let bit = (signum - 1) as usize;\n            raw[bit / 8] |= 1 << (bit % 8);\n            return 0;\n        }\n    } else if #[cfg(not(target_os = \"vxworks\"))] {\n        pub use libc::{sigemptyset, sigaddset};\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\npub struct Command {\n    program: CString,\n    args: Vec<CString>,\n    /// Exactly what will be passed to `execvp`.\n    ///\n    /// First element is a pointer to `program`, followed by pointers to\n    /// `args`, followed by a `null`. Be careful when modifying `program` or\n    /// `args` to properly update this as well.\n    argv: Argv,\n    env: CommandEnv,\n\n    cwd: Option<CString>,\n    uid: Option<uid_t>,\n    gid: Option<gid_t>,\n    saw_nul: bool,\n    closures: Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>>,\n    groups: Option<Box<[gid_t]>>,\n    stdin: Option<Stdio>,\n    stdout: Option<Stdio>,\n    stderr: Option<Stdio>,\n}\n\n// Create a new type for argv, so that we can make it `Send` and `Sync`\nstruct Argv(Vec<*const c_char>);\n\n// It is safe to make `Argv` `Send` and `Sync`, because it contains\n// pointers to memory owned by `Command.args`\nunsafe impl Send for Argv {}\nunsafe impl Sync for Argv {}\n\n// passed back to std::process with the pipes connected to the child, if any\n// were requested\npub struct StdioPipes {\n    pub stdin: Option<AnonPipe>,\n    pub stdout: Option<AnonPipe>,\n    pub stderr: Option<AnonPipe>,\n}\n\n// passed to do_exec() with configuration of what the child stdio should look\n// like\npub struct ChildPipes {\n    pub stdin: ChildStdio,\n    pub stdout: ChildStdio,\n    pub stderr: ChildStdio,\n}\n\npub enum ChildStdio {\n    Inherit,\n    Explicit(c_int),\n    Owned(FileDesc),\n\n    // On Fuchsia, null stdio is the default, so we simply don't specify\n    // any actions at the time of spawning.\n    #[cfg(target_os = \"fuchsia\")]\n    Null,\n}\n\npub enum Stdio {\n    Inherit,\n    Null,\n    MakePipe,\n    Fd(FileDesc),\n}\n\nimpl Command {\n    pub fn new(program: &OsStr) -> Command {\n        let mut saw_nul = false;\n        let program = os2c(program, &mut saw_nul);\n        Command {\n            argv: Argv(vec![program.as_ptr(), ptr::null()]),\n            args: vec![program.clone()],\n            program,\n            env: Default::default(),\n            cwd: None,\n            uid: None,\n            gid: None,\n            saw_nul,\n            closures: Vec::new(),\n            groups: None,\n            stdin: None,\n            stdout: None,\n            stderr: None,\n        }\n    }\n\n    pub fn set_arg_0(&mut self, arg: &OsStr) {\n        // Set a new arg0\n        let arg = os2c(arg, &mut self.saw_nul);\n        debug_assert!(self.argv.0.len() > 1);\n        self.argv.0[0] = arg.as_ptr();\n        self.args[0] = arg;\n    }\n\n    pub fn arg(&mut self, arg: &OsStr) {\n        // Overwrite the trailing null pointer in `argv` and then add a new null\n        // pointer.\n        let arg = os2c(arg, &mut self.saw_nul);\n        self.argv.0[self.args.len()] = arg.as_ptr();\n        self.argv.0.push(ptr::null());\n\n        // Also make sure we keep track of the owned value to schedule a\n        // destructor for this memory.\n        self.args.push(arg);\n    }\n\n    pub fn cwd(&mut self, dir: &OsStr) {\n        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n    }\n    pub fn uid(&mut self, id: uid_t) {\n        self.uid = Some(id);\n    }\n    pub fn gid(&mut self, id: gid_t) {\n        self.gid = Some(id);\n    }\n    pub fn groups(&mut self, groups: &[gid_t]) {\n        self.groups = Some(Box::from(groups));\n    }\n\n    pub fn saw_nul(&self) -> bool {\n        self.saw_nul\n    }\n\n    pub fn get_program(&self) -> &OsStr {\n        OsStr::from_bytes(self.program.as_bytes())\n    }\n\n    pub fn get_args(&self) -> CommandArgs<'_> {\n        let mut iter = self.args.iter();\n        iter.next();\n        CommandArgs { iter }\n    }\n\n    pub fn get_envs(&self) -> CommandEnvs<'_> {\n        self.env.iter()\n    }\n\n    pub fn get_current_dir(&self) -> Option<&Path> {\n        self.cwd.as_ref().map(|cs| Path::new(OsStr::from_bytes(cs.as_bytes())))\n    }\n\n    pub fn get_argv(&self) -> &Vec<*const c_char> {\n        &self.argv.0\n    }\n\n    pub fn get_program_cstr(&self) -> &CStr {\n        &*self.program\n    }\n\n    #[allow(dead_code)]\n    pub fn get_cwd(&self) -> &Option<CString> {\n        &self.cwd\n    }\n    #[allow(dead_code)]\n    pub fn get_uid(&self) -> Option<uid_t> {\n        self.uid\n    }\n    #[allow(dead_code)]\n    pub fn get_gid(&self) -> Option<gid_t> {\n        self.gid\n    }\n    #[allow(dead_code)]\n    pub fn get_groups(&self) -> Option<&[gid_t]> {\n        self.groups.as_deref()\n    }\n\n    pub fn get_closures(&mut self) -> &mut Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>> {\n        &mut self.closures\n    }\n\n    pub unsafe fn pre_exec(&mut self, f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n        self.closures.push(f);\n    }\n\n    pub fn stdin(&mut self, stdin: Stdio) {\n        self.stdin = Some(stdin);\n    }\n\n    pub fn stdout(&mut self, stdout: Stdio) {\n        self.stdout = Some(stdout);\n    }\n\n    pub fn stderr(&mut self, stderr: Stdio) {\n        self.stderr = Some(stderr);\n    }\n\n    pub fn env_mut(&mut self) -> &mut CommandEnv {\n        &mut self.env\n    }\n\n    pub fn capture_env(&mut self) -> Option<CStringArray> {\n        let maybe_env = self.env.capture_if_changed();\n        maybe_env.map(|env| construct_envp(env, &mut self.saw_nul))\n    }\n\n    #[allow(dead_code)]\n    pub fn env_saw_path(&self) -> bool {\n        self.env.have_changed_path()\n    }\n\n    #[allow(dead_code)]\n    pub fn program_is_path(&self) -> bool {\n        self.program.to_bytes().contains(&b'/')\n    }\n\n    pub fn setup_io(\n        &self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(StdioPipes, ChildPipes)> {\n        let null = Stdio::Null;\n        let default_stdin = if needs_stdin { &default } else { &null };\n        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n        let stdout = self.stdout.as_ref().unwrap_or(&default);\n        let stderr = self.stderr.as_ref().unwrap_or(&default);\n        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n        Ok((ours, theirs))\n    }\n}\n\nfn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n        *saw_nul = true;\n        CString::new(\"<string-with-nul>\").unwrap()\n    })\n}\n\n// Helper type to manage ownership of the strings within a C-style array.\npub struct CStringArray {\n    items: Vec<CString>,\n    ptrs: Vec<*const c_char>,\n}\n\nimpl CStringArray {\n    pub fn with_capacity(capacity: usize) -> Self {\n        let mut result = CStringArray {\n            items: Vec::with_capacity(capacity),\n            ptrs: Vec::with_capacity(capacity + 1),\n        };\n        result.ptrs.push(ptr::null());\n        result\n    }\n    pub fn push(&mut self, item: CString) {\n        let l = self.ptrs.len();\n        self.ptrs[l - 1] = item.as_ptr();\n        self.ptrs.push(ptr::null());\n        self.items.push(item);\n    }\n    pub fn as_ptr(&self) -> *const *const c_char {\n        self.ptrs.as_ptr()\n    }\n}\n\nfn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStringArray {\n    let mut result = CStringArray::with_capacity(env.len());\n    for (mut k, v) in env {\n        // Reserve additional space for '=' and null terminator\n        k.reserve_exact(v.len() + 2);\n        k.push(\"=\");\n        k.push(&v);\n\n        // Add the new entry into the array\n        if let Ok(item) = CString::new(k.into_vec()) {\n            result.push(item);\n        } else {\n            *saw_nul = true;\n        }\n    }\n\n    result\n}\n\nimpl Stdio {\n    pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n        match *self {\n            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n\n            // Make sure that the source descriptors are not an stdio\n            // descriptor, otherwise the order which we set the child's\n            // descriptors may blow away a descriptor which we are hoping to\n            // save. For example, suppose we want the child's stderr to be the\n            // parent's stdout, and the child's stdout to be the parent's\n            // stderr. No matter which we dup first, the second will get\n            // overwritten prematurely.\n            Stdio::Fd(ref fd) => {\n                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n                } else {\n                    Ok((ChildStdio::Explicit(fd.raw()), None))\n                }\n            }\n\n            Stdio::MakePipe => {\n                let (reader, writer) = pipe::anon_pipe()?;\n                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n            }\n\n            #[cfg(not(target_os = \"fuchsia\"))]\n            Stdio::Null => {\n                let mut opts = OpenOptions::new();\n                opts.read(readable);\n                opts.write(!readable);\n                let path = unsafe { CStr::from_ptr(DEV_NULL.as_ptr() as *const _) };\n                let fd = File::open_c(&path, &opts)?;\n                Ok((ChildStdio::Owned(fd.into_fd()), None))\n            }\n\n            #[cfg(target_os = \"fuchsia\")]\n            Stdio::Null => Ok((ChildStdio::Null, None)),\n        }\n    }\n}\n\nimpl From<AnonPipe> for Stdio {\n    fn from(pipe: AnonPipe) -> Stdio {\n        Stdio::Fd(pipe.into_fd())\n    }\n}\n\nimpl From<File> for Stdio {\n    fn from(file: File) -> Stdio {\n        Stdio::Fd(file.into_fd())\n    }\n}\n\nimpl ChildStdio {\n    pub fn fd(&self) -> Option<c_int> {\n        match *self {\n            ChildStdio::Inherit => None,\n            ChildStdio::Explicit(fd) => Some(fd),\n            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n\n            #[cfg(target_os = \"fuchsia\")]\n            ChildStdio::Null => None,\n        }\n    }\n}\n\nimpl fmt::Debug for Command {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.program != self.args[0] {\n            write!(f, \"[{:?}] \", self.program)?;\n        }\n        write!(f, \"{:?}\", self.args[0])?;\n\n        for arg in &self.args[1..] {\n            write!(f, \" {:?}\", arg)?;\n        }\n        Ok(())\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitCode(u8);\n\nimpl ExitCode {\n    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n\n    #[inline]\n    pub fn as_i32(&self) -> i32 {\n        self.0 as i32\n    }\n}\n\npub struct CommandArgs<'a> {\n    iter: crate::slice::Iter<'a, CString>,\n}\n\nimpl<'a> Iterator for CommandArgs<'a> {\n    type Item = &'a OsStr;\n    fn next(&mut self) -> Option<&'a OsStr> {\n        self.iter.next().map(|cs| OsStr::from_bytes(cs.as_bytes()))\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<'a> ExactSizeIterator for CommandArgs<'a> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\nimpl<'a> fmt::Debug for CommandArgs<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter.clone()).finish()\n    }\n}\n"],["2428","use crate::os::unix::process::{CommandExt, ExitStatusExt};\nuse crate::panic::catch_unwind;\nuse crate::process::Command;\n\n// Many of the other aspects of this situation, including heap alloc concurrency\n// safety etc., are tested in src/test/ui/process/process-panic-after-fork.rs\n\n#[test]\nfn exitstatus_display_tests() {\n    // In practice this is the same on every Unix.\n    // If some weird platform turns out to be different, and this test fails, use #[cfg].\n    use crate::os::unix::process::ExitStatusExt;\n    use crate::process::ExitStatus;\n\n    let t = |v, s| assert_eq!(s, format!(\"{}\", <ExitStatus as ExitStatusExt>::from_raw(v)));\n\n    t(0x0000f, \"signal: 15\");\n    t(0x0008b, \"signal: 11 (core dumped)\");\n    t(0x00000, \"exit status: 0\");\n    t(0x0ff00, \"exit status: 255\");\n\n    // On MacOS, 0x0137f is WIFCONTINUED, not WIFSTOPPED.  Probably *BSD is similar.\n    //   https://github.com/rust-lang/rust/pull/82749#issuecomment-790525956\n    // The purpose of this test is to test our string formatting, not our understanding of the wait\n    // status magic numbers.  So restrict these to Linux.\n    if cfg!(target_os = \"linux\") {\n        t(0x0137f, \"stopped (not terminated) by signal: 19\");\n        t(0x0ffff, \"continued (WIFCONTINUED)\");\n    }\n\n    // Testing \"unrecognised wait status\" is hard because the wait.h macros typically\n    // assume that the value came from wait and isn't mad.  With the glibc I have here\n    // this works:\n    if cfg!(all(target_os = \"linux\", target_env = \"gnu\")) {\n        t(0x000ff, \"unrecognised wait status: 255 0xff\");\n    }\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn test_command_fork_no_unwind() {\n    let got = catch_unwind(|| {\n        let mut c = Command::new(\"echo\");\n        c.arg(\"hi\");\n        unsafe {\n            c.pre_exec(|| panic!(\"{}\", \"crash now!\"));\n        }\n        let st = c.status().expect(\"failed to get command status\");\n        dbg!(st);\n        st\n    });\n    dbg!(&got);\n    let status = got.expect(\"panic unexpectedly propagated\");\n    dbg!(status);\n    let signal = status.signal().expect(\"expected child process to die of signal\");\n    assert!(signal == libc::SIGABRT || signal == libc::SIGILL || signal == libc::SIGTRAP);\n}\n"],["2429","use crate::convert::{TryFrom, TryInto};\nuse crate::fmt;\nuse crate::io;\nuse crate::mem;\nuse crate::num::{NonZeroI32, NonZeroI64};\nuse crate::ptr;\n\nuse crate::sys::process::process_common::*;\nuse crate::sys::process::zircon::{zx_handle_t, Handle};\n\nuse libc::{c_int, size_t};\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Command {\n    pub fn spawn(\n        &mut self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            ));\n        }\n\n        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n\n        let process_handle = unsafe { self.do_exec(theirs, envp.as_ref())? };\n\n        Ok((Process { handle: Handle::new(process_handle) }, ours))\n    }\n\n    pub fn exec(&mut self, default: Stdio) -> io::Error {\n        if self.saw_nul() {\n            return io::Error::new_const(\n                io::ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            );\n        }\n\n        match self.setup_io(default, true) {\n            Ok((_, _)) => {\n                // FIXME: This is tough because we don't support the exec syscalls\n                unimplemented!();\n            }\n            Err(e) => e,\n        }\n    }\n\n    unsafe fn do_exec(\n        &mut self,\n        stdio: ChildPipes,\n        maybe_envp: Option<&CStringArray>,\n    ) -> io::Result<zx_handle_t> {\n        use crate::sys::process::zircon::*;\n\n        let envp = match maybe_envp {\n            // None means to clone the current environment, which is done in the\n            // flags below.\n            None => ptr::null(),\n            Some(envp) => envp.as_ptr(),\n        };\n\n        let make_action = |local_io: &ChildStdio, target_fd| -> io::Result<fdio_spawn_action_t> {\n            if let Some(local_fd) = local_io.fd() {\n                Ok(fdio_spawn_action_t {\n                    action: FDIO_SPAWN_ACTION_TRANSFER_FD,\n                    local_fd,\n                    target_fd,\n                    ..Default::default()\n                })\n            } else {\n                if let ChildStdio::Null = local_io {\n                    // acts as no-op\n                    return Ok(Default::default());\n                }\n\n                let mut handle = ZX_HANDLE_INVALID;\n                let status = fdio_fd_clone(target_fd, &mut handle);\n                if status == ERR_INVALID_ARGS || status == ERR_NOT_SUPPORTED {\n                    // This descriptor is closed; skip it rather than generating an\n                    // error.\n                    return Ok(Default::default());\n                }\n                zx_cvt(status)?;\n\n                let mut cloned_fd = 0;\n                zx_cvt(fdio_fd_create(handle, &mut cloned_fd))?;\n\n                Ok(fdio_spawn_action_t {\n                    action: FDIO_SPAWN_ACTION_TRANSFER_FD,\n                    local_fd: cloned_fd as i32,\n                    target_fd,\n                    ..Default::default()\n                })\n            }\n        };\n\n        // Clone stdin, stdout, and stderr\n        let action1 = make_action(&stdio.stdin, 0)?;\n        let action2 = make_action(&stdio.stdout, 1)?;\n        let action3 = make_action(&stdio.stderr, 2)?;\n        let actions = [action1, action2, action3];\n\n        // We don't want FileDesc::drop to be called on any stdio. fdio_spawn_etc\n        // always consumes transferred file descriptors.\n        mem::forget(stdio);\n\n        for callback in self.get_closures().iter_mut() {\n            callback()?;\n        }\n\n        let mut process_handle: zx_handle_t = 0;\n        zx_cvt(fdio_spawn_etc(\n            ZX_HANDLE_INVALID,\n            FDIO_SPAWN_CLONE_JOB\n                | FDIO_SPAWN_CLONE_LDSVC\n                | FDIO_SPAWN_CLONE_NAMESPACE\n                | FDIO_SPAWN_CLONE_ENVIRON // this is ignored when envp is non-null\n                | FDIO_SPAWN_CLONE_UTC_CLOCK,\n            self.get_program_cstr().as_ptr(),\n            self.get_argv().as_ptr(),\n            envp,\n            actions.len() as size_t,\n            actions.as_ptr(),\n            &mut process_handle,\n            ptr::null_mut(),\n        ))?;\n        // FIXME: See if we want to do something with that err_msg\n\n        Ok(process_handle)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Processes\n////////////////////////////////////////////////////////////////////////////////\n\npub struct Process {\n    handle: Handle,\n}\n\nimpl Process {\n    pub fn id(&self) -> u32 {\n        self.handle.raw() as u32\n    }\n\n    pub fn kill(&mut self) -> io::Result<()> {\n        use crate::sys::process::zircon::*;\n\n        unsafe {\n            zx_cvt(zx_task_kill(self.handle.raw()))?;\n        }\n\n        Ok(())\n    }\n\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        use crate::default::Default;\n        use crate::sys::process::zircon::*;\n\n        let mut proc_info: zx_info_process_t = Default::default();\n        let mut actual: size_t = 0;\n        let mut avail: size_t = 0;\n\n        unsafe {\n            zx_cvt(zx_object_wait_one(\n                self.handle.raw(),\n                ZX_TASK_TERMINATED,\n                ZX_TIME_INFINITE,\n                ptr::null_mut(),\n            ))?;\n            zx_cvt(zx_object_get_info(\n                self.handle.raw(),\n                ZX_INFO_PROCESS,\n                &mut proc_info as *mut _ as *mut libc::c_void,\n                mem::size_of::<zx_info_process_t>(),\n                &mut actual,\n                &mut avail,\n            ))?;\n        }\n        if actual != 1 {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidData,\n                &\"Failed to get exit status of process\",\n            ));\n        }\n        Ok(ExitStatus(proc_info.return_code))\n    }\n\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        use crate::default::Default;\n        use crate::sys::process::zircon::*;\n\n        let mut proc_info: zx_info_process_t = Default::default();\n        let mut actual: size_t = 0;\n        let mut avail: size_t = 0;\n\n        unsafe {\n            let status =\n                zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED, 0, ptr::null_mut());\n            match status {\n                0 => {} // Success\n                x if x == ERR_TIMED_OUT => {\n                    return Ok(None);\n                }\n                _ => {\n                    panic!(\"Failed to wait on process handle: {}\", status);\n                }\n            }\n            zx_cvt(zx_object_get_info(\n                self.handle.raw(),\n                ZX_INFO_PROCESS,\n                &mut proc_info as *mut _ as *mut libc::c_void,\n                mem::size_of::<zx_info_process_t>(),\n                &mut actual,\n                &mut avail,\n            ))?;\n        }\n        if actual != 1 {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidData,\n                &\"Failed to get exit status of process\",\n            ));\n        }\n        Ok(Some(ExitStatus(proc_info.return_code)))\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatus(i64);\n\nimpl ExitStatus {\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        match NonZeroI64::try_from(self.0) {\n            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n            /* was zero, couldn't convert */ Err(_) => Ok(()),\n        }\n    }\n\n    pub fn code(&self) -> Option<i32> {\n        // FIXME: support extracting return code as an i64\n        self.0.try_into().ok()\n    }\n\n    pub fn signal(&self) -> Option<i32> {\n        None\n    }\n\n    // FIXME: The actually-Unix implementation in process_unix.rs uses WSTOPSIG, WCOREDUMP et al.\n    // I infer from the implementation of `success`, `code` and `signal` above that these are not\n    // available on Fuchsia.\n    //\n    // It does not appear that Fuchsia is Unix-like enough to implement ExitStatus (or indeed many\n    // other things from std::os::unix) properly.  This veneer is always going to be a bodge.  So\n    // while I don't know if these implementations are actually correct, I think they will do for\n    // now at least.\n    pub fn core_dumped(&self) -> bool {\n        false\n    }\n    pub fn stopped_signal(&self) -> Option<i32> {\n        None\n    }\n    pub fn continued(&self) -> bool {\n        false\n    }\n\n    pub fn into_raw(&self) -> c_int {\n        // We don't know what someone who calls into_raw() will do with this value, but it should\n        // have the conventional Unix representation.  Despite the fact that this is not\n        // standardised in SuS or POSIX, all Unix systems encode the signal and exit status the\n        // same way.  (Ie the WIFEXITED, WEXITSTATUS etc. macros have identical behaviour on every\n        // Unix.)\n        //\n        // The caller of `std::os::unix::into_raw` is probably wanting a Unix exit status, and may\n        // do their own shifting and masking, or even pass the status to another computer running a\n        // different Unix variant.\n        //\n        // The other view would be to say that the caller on Fuchsia ought to know that `into_raw`\n        // will give a raw Fuchsia status (whatever that is - I don't know, personally).  That is\n        // not possible here becaause we must return a c_int because that's what Unix (including\n        // SuS and POSIX) say a wait status is, but Fuchsia apparently uses a u64, so it won't\n        // necessarily fit.\n        //\n        // It seems to me that that the right answer would be to provide std::os::fuchsia with its\n        // own ExitStatusExt, rather that trying to provide a not very convincing imitation of\n        // Unix.  Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia.  But\n        // fixing this up that is beyond the scope of my efforts now.\n        let exit_status_as_if_unix: u8 = self.0.try_into().expect(\"Fuchsia process return code bigger than 8 bits, but std::os::unix::ExitStatusExt::into_raw() was called to try to convert the value into a traditional Unix-style wait status, which cannot represent values greater than 255.\");\n        let wait_status_as_if_unix = (exit_status_as_if_unix as c_int) << 8;\n        wait_status_as_if_unix\n    }\n}\n\n/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\nimpl From<c_int> for ExitStatus {\n    fn from(a: c_int) -> ExitStatus {\n        ExitStatus(a as i64)\n    }\n}\n\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"exit code: {}\", self.0)\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatusError(NonZeroI64);\n\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        ExitStatus(self.0.into())\n    }\n}\n\nimpl ExitStatusError {\n    pub fn code(self) -> Option<NonZeroI32> {\n        // fixme: affected by the same bug as ExitStatus::code()\n        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n    }\n}\n"],["2430","#![allow(non_camel_case_types, unused)]\n\nuse crate::convert::TryInto;\nuse crate::io;\nuse crate::mem::MaybeUninit;\nuse crate::os::raw::c_char;\n\nuse libc::{c_int, c_void, size_t};\n\npub type zx_handle_t = u32;\npub type zx_vaddr_t = usize;\npub type zx_rights_t = u32;\npub type zx_status_t = i32;\n\npub const ZX_HANDLE_INVALID: zx_handle_t = 0;\n\npub type zx_time_t = i64;\npub const ZX_TIME_INFINITE: zx_time_t = i64::MAX;\n\npub type zx_signals_t = u32;\n\npub const ZX_OBJECT_SIGNAL_3: zx_signals_t = 1 << 3;\n\npub const ZX_TASK_TERMINATED: zx_signals_t = ZX_OBJECT_SIGNAL_3;\n\npub const ZX_RIGHT_SAME_RIGHTS: zx_rights_t = 1 << 31;\n\npub type zx_object_info_topic_t = u32;\n\npub const ZX_INFO_PROCESS: zx_object_info_topic_t = 3;\n\npub fn zx_cvt<T>(t: T) -> io::Result<T>\nwhere\n    T: TryInto<zx_status_t> + Copy,\n{\n    if let Ok(status) = TryInto::try_into(t) {\n        if status < 0 { Err(io::Error::from_raw_os_error(status)) } else { Ok(t) }\n    } else {\n        Err(io::Error::last_os_error())\n    }\n}\n\n// Safe wrapper around zx_handle_t\npub struct Handle {\n    raw: zx_handle_t,\n}\n\nimpl Handle {\n    pub fn new(raw: zx_handle_t) -> Handle {\n        Handle { raw }\n    }\n\n    pub fn raw(&self) -> zx_handle_t {\n        self.raw\n    }\n}\n\nimpl Drop for Handle {\n    fn drop(&mut self) {\n        unsafe {\n            zx_cvt(zx_handle_close(self.raw)).expect(\"Failed to close zx_handle_t\");\n        }\n    }\n}\n\n// Returned for topic ZX_INFO_PROCESS\n#[derive(Default)]\n#[repr(C)]\npub struct zx_info_process_t {\n    pub return_code: i64,\n    pub started: bool,\n    pub exited: bool,\n    pub debugger_attached: bool,\n}\n\nextern \"C\" {\n    pub fn zx_job_default() -> zx_handle_t;\n\n    pub fn zx_task_kill(handle: zx_handle_t) -> zx_status_t;\n\n    pub fn zx_handle_close(handle: zx_handle_t) -> zx_status_t;\n\n    pub fn zx_handle_duplicate(\n        handle: zx_handle_t,\n        rights: zx_rights_t,\n        out: *const zx_handle_t,\n    ) -> zx_handle_t;\n\n    pub fn zx_object_wait_one(\n        handle: zx_handle_t,\n        signals: zx_signals_t,\n        timeout: zx_time_t,\n        pending: *mut zx_signals_t,\n    ) -> zx_status_t;\n\n    pub fn zx_object_get_info(\n        handle: zx_handle_t,\n        topic: u32,\n        buffer: *mut c_void,\n        buffer_size: size_t,\n        actual_size: *mut size_t,\n        avail: *mut size_t,\n    ) -> zx_status_t;\n}\n\n#[derive(Default)]\n#[repr(C)]\npub struct fdio_spawn_action_t {\n    pub action: u32,\n    pub reserved0: u32,\n    pub local_fd: i32,\n    pub target_fd: i32,\n    pub reserved1: u64,\n}\n\nextern \"C\" {\n    pub fn fdio_spawn_etc(\n        job: zx_handle_t,\n        flags: u32,\n        path: *const c_char,\n        argv: *const *const c_char,\n        envp: *const *const c_char,\n        action_count: size_t,\n        actions: *const fdio_spawn_action_t,\n        process: *mut zx_handle_t,\n        err_msg: *mut c_char,\n    ) -> zx_status_t;\n\n    pub fn fdio_fd_clone(fd: c_int, out_handle: *mut zx_handle_t) -> zx_status_t;\n    pub fn fdio_fd_create(handle: zx_handle_t, fd: *mut c_int) -> zx_status_t;\n}\n\n// fdio_spawn_etc flags\n\npub const FDIO_SPAWN_CLONE_JOB: u32 = 0x0001;\npub const FDIO_SPAWN_CLONE_LDSVC: u32 = 0x0002;\npub const FDIO_SPAWN_CLONE_NAMESPACE: u32 = 0x0004;\npub const FDIO_SPAWN_CLONE_STDIO: u32 = 0x0008;\npub const FDIO_SPAWN_CLONE_ENVIRON: u32 = 0x0010;\npub const FDIO_SPAWN_CLONE_UTC_CLOCK: u32 = 0x0020;\npub const FDIO_SPAWN_CLONE_ALL: u32 = 0xFFFF;\n\n// fdio_spawn_etc actions\n\npub const FDIO_SPAWN_ACTION_CLONE_FD: u32 = 0x0001;\npub const FDIO_SPAWN_ACTION_TRANSFER_FD: u32 = 0x0002;\n\n// Errors\n\n#[allow(unused)]\npub const ERR_INTERNAL: zx_status_t = -1;\n\n// ERR_NOT_SUPPORTED: The operation is not implemented, supported,\n// or enabled.\n#[allow(unused)]\npub const ERR_NOT_SUPPORTED: zx_status_t = -2;\n\n// ERR_NO_RESOURCES: The system was not able to allocate some resource\n// needed for the operation.\n#[allow(unused)]\npub const ERR_NO_RESOURCES: zx_status_t = -3;\n\n// ERR_NO_MEMORY: The system was not able to allocate memory needed\n// for the operation.\n#[allow(unused)]\npub const ERR_NO_MEMORY: zx_status_t = -4;\n\n// ERR_CALL_FAILED: The second phase of zx_channel_call(; did not complete\n// successfully.\n#[allow(unused)]\npub const ERR_CALL_FAILED: zx_status_t = -5;\n\n// ERR_INTERRUPTED_RETRY: The system call was interrupted, but should be\n// retried.  This should not be seen outside of the VDSO.\n#[allow(unused)]\npub const ERR_INTERRUPTED_RETRY: zx_status_t = -6;\n\n// ======= Parameter errors =======\n// ERR_INVALID_ARGS: an argument is invalid, ex. null pointer\n#[allow(unused)]\npub const ERR_INVALID_ARGS: zx_status_t = -10;\n\n// ERR_BAD_HANDLE: A specified handle value does not refer to a handle.\n#[allow(unused)]\npub const ERR_BAD_HANDLE: zx_status_t = -11;\n\n// ERR_WRONG_TYPE: The subject of the operation is the wrong type to\n// perform the operation.\n// Example: Attempting a message_read on a thread handle.\n#[allow(unused)]\npub const ERR_WRONG_TYPE: zx_status_t = -12;\n\n// ERR_BAD_SYSCALL: The specified syscall number is invalid.\n#[allow(unused)]\npub const ERR_BAD_SYSCALL: zx_status_t = -13;\n\n// ERR_OUT_OF_RANGE: An argument is outside the valid range for this\n// operation.\n#[allow(unused)]\npub const ERR_OUT_OF_RANGE: zx_status_t = -14;\n\n// ERR_BUFFER_TOO_SMALL: A caller provided buffer is too small for\n// this operation.\n#[allow(unused)]\npub const ERR_BUFFER_TOO_SMALL: zx_status_t = -15;\n\n// ======= Precondition or state errors =======\n// ERR_BAD_STATE: operation failed because the current state of the\n// object does not allow it, or a precondition of the operation is\n// not satisfied\n#[allow(unused)]\npub const ERR_BAD_STATE: zx_status_t = -20;\n\n// ERR_TIMED_OUT: The time limit for the operation elapsed before\n// the operation completed.\n#[allow(unused)]\npub const ERR_TIMED_OUT: zx_status_t = -21;\n\n// ERR_SHOULD_WAIT: The operation cannot be performed currently but\n// potentially could succeed if the caller waits for a prerequisite\n// to be satisfied, for example waiting for a handle to be readable\n// or writable.\n// Example: Attempting to read from a message pipe that has no\n// messages waiting but has an open remote will return ERR_SHOULD_WAIT.\n// Attempting to read from a message pipe that has no messages waiting\n// and has a closed remote end will return ERR_REMOTE_CLOSED.\n#[allow(unused)]\npub const ERR_SHOULD_WAIT: zx_status_t = -22;\n\n// ERR_CANCELED: The in-progress operation (e.g., a wait) has been\n// // canceled.\n#[allow(unused)]\npub const ERR_CANCELED: zx_status_t = -23;\n\n// ERR_PEER_CLOSED: The operation failed because the remote end\n// of the subject of the operation was closed.\n#[allow(unused)]\npub const ERR_PEER_CLOSED: zx_status_t = -24;\n\n// ERR_NOT_FOUND: The requested entity is not found.\n#[allow(unused)]\npub const ERR_NOT_FOUND: zx_status_t = -25;\n\n// ERR_ALREADY_EXISTS: An object with the specified identifier\n// already exists.\n// Example: Attempting to create a file when a file already exists\n// with that name.\n#[allow(unused)]\npub const ERR_ALREADY_EXISTS: zx_status_t = -26;\n\n// ERR_ALREADY_BOUND: The operation failed because the named entity\n// is already owned or controlled by another entity. The operation\n// could succeed later if the current owner releases the entity.\n#[allow(unused)]\npub const ERR_ALREADY_BOUND: zx_status_t = -27;\n\n// ERR_UNAVAILABLE: The subject of the operation is currently unable\n// to perform the operation.\n// Note: This is used when there's no direct way for the caller to\n// observe when the subject will be able to perform the operation\n// and should thus retry.\n#[allow(unused)]\npub const ERR_UNAVAILABLE: zx_status_t = -28;\n\n// ======= Permission check errors =======\n// ERR_ACCESS_DENIED: The caller did not have permission to perform\n// the specified operation.\n#[allow(unused)]\npub const ERR_ACCESS_DENIED: zx_status_t = -30;\n\n// ======= Input-output errors =======\n// ERR_IO: Otherwise unspecified error occurred during I/O.\n#[allow(unused)]\npub const ERR_IO: zx_status_t = -40;\n\n// ERR_REFUSED: The entity the I/O operation is being performed on\n// rejected the operation.\n// Example: an I2C device NAK'ing a transaction or a disk controller\n// rejecting an invalid command.\n#[allow(unused)]\npub const ERR_IO_REFUSED: zx_status_t = -41;\n\n// ERR_IO_DATA_INTEGRITY: The data in the operation failed an integrity\n// check and is possibly corrupted.\n// Example: CRC or Parity error.\n#[allow(unused)]\npub const ERR_IO_DATA_INTEGRITY: zx_status_t = -42;\n\n// ERR_IO_DATA_LOSS: The data in the operation is currently unavailable\n// and may be permanently lost.\n// Example: A disk block is irrecoverably damaged.\n#[allow(unused)]\npub const ERR_IO_DATA_LOSS: zx_status_t = -43;\n\n// Filesystem specific errors\n#[allow(unused)]\npub const ERR_BAD_PATH: zx_status_t = -50;\n#[allow(unused)]\npub const ERR_NOT_DIR: zx_status_t = -51;\n#[allow(unused)]\npub const ERR_NOT_FILE: zx_status_t = -52;\n// ERR_FILE_BIG: A file exceeds a filesystem-specific size limit.\n#[allow(unused)]\npub const ERR_FILE_BIG: zx_status_t = -53;\n// ERR_NO_SPACE: Filesystem or device space is exhausted.\n#[allow(unused)]\npub const ERR_NO_SPACE: zx_status_t = -54;\n"],["2431","pub use self::process_common::{Command, CommandArgs, ExitCode, Stdio, StdioPipes};\npub use self::process_inner::{ExitStatus, ExitStatusError, Process};\npub use crate::ffi::OsString as EnvKey;\npub use crate::sys_common::process::CommandEnvs;\n\nmod process_common;\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"fuchsia\")] {\n        #[path = \"process_fuchsia.rs\"]\n        mod process_inner;\n        mod zircon;\n    } else if #[cfg(target_os = \"vxworks\")] {\n        #[path = \"process_vxworks.rs\"]\n        mod process_inner;\n    } else {\n        #[path = \"process_unix.rs\"]\n        mod process_inner;\n    }\n}\n"],["2432","use crate::convert::{TryFrom, TryInto};\nuse crate::fmt;\nuse crate::io::{self, Error, ErrorKind};\nuse crate::mem;\nuse crate::num::NonZeroI32;\nuse crate::os::raw::NonZero_c_int;\nuse crate::ptr;\nuse crate::sys;\nuse crate::sys::cvt;\nuse crate::sys::process::process_common::*;\n\n#[cfg(target_os = \"vxworks\")]\nuse libc::RTP_ID as pid_t;\n\n#[cfg(not(target_os = \"vxworks\"))]\nuse libc::{c_int, gid_t, pid_t, uid_t};\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Command {\n    pub fn spawn(\n        &mut self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        const CLOEXEC_MSG_FOOTER: [u8; 4] = *b\"NOEX\";\n\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return Err(io::Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            ));\n        }\n\n        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n\n        if let Some(ret) = self.posix_spawn(&theirs, envp.as_ref())? {\n            return Ok((ret, ours));\n        }\n\n        let (input, output) = sys::pipe::anon_pipe()?;\n\n        // Whatever happens after the fork is almost for sure going to touch or\n        // look at the environment in one way or another (PATH in `execvp` or\n        // accessing the `environ` pointer ourselves). Make sure no other thread\n        // is accessing the environment when we do the fork itself.\n        //\n        // Note that as soon as we're done with the fork there's no need to hold\n        // a lock any more because the parent won't do anything and the child is\n        // in its own process. Thus the parent drops the lock guard while the child\n        // forgets it to avoid unlocking it on a new thread, which would be invalid.\n        let (env_lock, pid) = unsafe { (sys::os::env_read_lock(), cvt(libc::fork())?) };\n\n        if pid == 0 {\n            crate::panic::always_abort();\n            mem::forget(env_lock);\n            drop(input);\n            let Err(err) = unsafe { self.do_exec(theirs, envp.as_ref()) };\n            let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n            let errno = errno.to_be_bytes();\n            let bytes = [\n                errno[0],\n                errno[1],\n                errno[2],\n                errno[3],\n                CLOEXEC_MSG_FOOTER[0],\n                CLOEXEC_MSG_FOOTER[1],\n                CLOEXEC_MSG_FOOTER[2],\n                CLOEXEC_MSG_FOOTER[3],\n            ];\n            // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n            // we want to be sure we *don't* run at_exit destructors as\n            // we're being torn down regardless\n            rtassert!(output.write(&bytes).is_ok());\n            unsafe { libc::_exit(1) }\n        }\n\n        drop(env_lock);\n        drop(output);\n\n        let mut p = Process { pid, status: None };\n        let mut bytes = [0; 8];\n\n        // loop to handle EINTR\n        loop {\n            match input.read(&mut bytes) {\n                Ok(0) => return Ok((p, ours)),\n                Ok(8) => {\n                    let (errno, footer) = bytes.split_at(4);\n                    assert_eq!(\n                        CLOEXEC_MSG_FOOTER, footer,\n                        \"Validation on the CLOEXEC pipe failed: {:?}\",\n                        bytes\n                    );\n                    let errno = i32::from_be_bytes(errno.try_into().unwrap());\n                    assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                    return Err(Error::from_raw_os_error(errno));\n                }\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => {\n                    assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n                }\n                Ok(..) => {\n                    // pipe I/O up to PIPE_BUF bytes should be atomic\n                    assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                    panic!(\"short read on the CLOEXEC pipe\")\n                }\n            }\n        }\n    }\n\n    pub fn exec(&mut self, default: Stdio) -> io::Error {\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return io::Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            );\n        }\n\n        match self.setup_io(default, true) {\n            Ok((_, theirs)) => {\n                unsafe {\n                    // Similar to when forking, we want to ensure that access to\n                    // the environment is synchronized, so make sure to grab the\n                    // environment lock before we try to exec.\n                    let _lock = sys::os::env_read_lock();\n\n                    let Err(e) = self.do_exec(theirs, envp.as_ref());\n                    e\n                }\n            }\n            Err(e) => e,\n        }\n    }\n\n    // And at this point we've reached a special time in the life of the\n    // child. The child must now be considered hamstrung and unable to\n    // do anything other than syscalls really. Consider the following\n    // scenario:\n    //\n    //      1. Thread A of process 1 grabs the malloc() mutex\n    //      2. Thread B of process 1 forks(), creating thread C\n    //      3. Thread C of process 2 then attempts to malloc()\n    //      4. The memory of process 2 is the same as the memory of\n    //         process 1, so the mutex is locked.\n    //\n    // This situation looks a lot like deadlock, right? It turns out\n    // that this is what pthread_atfork() takes care of, which is\n    // presumably implemented across platforms. The first thing that\n    // threads to *before* forking is to do things like grab the malloc\n    // mutex, and then after the fork they unlock it.\n    //\n    // Despite this information, libnative's spawn has been witnessed to\n    // deadlock on both macOS and FreeBSD. I'm not entirely sure why, but\n    // all collected backtraces point at malloc/free traffic in the\n    // child spawned process.\n    //\n    // For this reason, the block of code below should contain 0\n    // invocations of either malloc of free (or their related friends).\n    //\n    // As an example of not having malloc/free traffic, we don't close\n    // this file descriptor by dropping the FileDesc (which contains an\n    // allocation). Instead we just close it manually. This will never\n    // have the drop glue anyway because this code never returns (the\n    // child will either exec() or invoke libc::exit)\n    unsafe fn do_exec(\n        &mut self,\n        stdio: ChildPipes,\n        maybe_envp: Option<&CStringArray>,\n    ) -> Result<!, io::Error> {\n        use crate::sys::{self, cvt_r};\n\n        if let Some(fd) = stdio.stdin.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO))?;\n        }\n        if let Some(fd) = stdio.stdout.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO))?;\n        }\n        if let Some(fd) = stdio.stderr.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n        }\n\n        #[cfg(not(target_os = \"l4re\"))]\n        {\n            if let Some(_g) = self.get_groups() {\n                //FIXME: Redox kernel does not support setgroups yet\n                #[cfg(not(target_os = \"redox\"))]\n                cvt(libc::setgroups(_g.len().try_into().unwrap(), _g.as_ptr()))?;\n            }\n            if let Some(u) = self.get_gid() {\n                cvt(libc::setgid(u as gid_t))?;\n            }\n            if let Some(u) = self.get_uid() {\n                // When dropping privileges from root, the `setgroups` call\n                // will remove any extraneous groups. We only drop groups\n                // if the current uid is 0 and we weren't given an explicit\n                // set of groups. If we don't call this, then even though our\n                // uid has dropped, we may still have groups that enable us to\n                // do super-user things.\n                //FIXME: Redox kernel does not support setgroups yet\n                #[cfg(not(target_os = \"redox\"))]\n                if libc::getuid() == 0 && self.get_groups().is_none() {\n                    cvt(libc::setgroups(0, ptr::null()))?;\n                }\n                cvt(libc::setuid(u as uid_t))?;\n            }\n        }\n        if let Some(ref cwd) = *self.get_cwd() {\n            cvt(libc::chdir(cwd.as_ptr()))?;\n        }\n\n        // emscripten has no signal support.\n        #[cfg(not(target_os = \"emscripten\"))]\n        {\n            use crate::mem::MaybeUninit;\n            // Reset signal handling so the child process starts in a\n            // standardized state. libstd ignores SIGPIPE, and signal-handling\n            // libraries often set a mask. Child processes inherit ignored\n            // signals and the signal mask from their parent, but most\n            // UNIX programs do not reset these things on their own, so we\n            // need to clean things up now to avoid confusing the program\n            // we're about to run.\n            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n            cvt(sigemptyset(set.as_mut_ptr()))?;\n            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), ptr::null_mut()))?;\n            let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n            if ret == libc::SIG_ERR {\n                return Err(io::Error::last_os_error());\n            }\n        }\n\n        for callback in self.get_closures().iter_mut() {\n            callback()?;\n        }\n\n        // Although we're performing an exec here we may also return with an\n        // error from this function (without actually exec'ing) in which case we\n        // want to be sure to restore the global environment back to what it\n        // once was, ensuring that our temporary override, when free'd, doesn't\n        // corrupt our process's environment.\n        let mut _reset = None;\n        if let Some(envp) = maybe_envp {\n            struct Reset(*const *const libc::c_char);\n\n            impl Drop for Reset {\n                fn drop(&mut self) {\n                    unsafe {\n                        *sys::os::environ() = self.0;\n                    }\n                }\n            }\n\n            _reset = Some(Reset(*sys::os::environ()));\n            *sys::os::environ() = envp.as_ptr();\n        }\n\n        libc::execvp(self.get_program_cstr().as_ptr(), self.get_argv().as_ptr());\n        Err(io::Error::last_os_error())\n    }\n\n    #[cfg(not(any(\n        target_os = \"macos\",\n        target_os = \"freebsd\",\n        all(target_os = \"linux\", target_env = \"gnu\"),\n        all(target_os = \"linux\", target_env = \"musl\"),\n    )))]\n    fn posix_spawn(\n        &mut self,\n        _: &ChildPipes,\n        _: Option<&CStringArray>,\n    ) -> io::Result<Option<Process>> {\n        Ok(None)\n    }\n\n    // Only support platforms for which posix_spawn() can return ENOENT\n    // directly.\n    #[cfg(any(\n        target_os = \"macos\",\n        target_os = \"freebsd\",\n        all(target_os = \"linux\", target_env = \"gnu\"),\n        all(target_os = \"linux\", target_env = \"musl\"),\n    ))]\n    fn posix_spawn(\n        &mut self,\n        stdio: &ChildPipes,\n        envp: Option<&CStringArray>,\n    ) -> io::Result<Option<Process>> {\n        use crate::mem::MaybeUninit;\n        use crate::sys::{self, cvt_nz};\n\n        if self.get_gid().is_some()\n            || self.get_uid().is_some()\n            || (self.env_saw_path() && !self.program_is_path())\n            || !self.get_closures().is_empty()\n            || self.get_groups().is_some()\n        {\n            return Ok(None);\n        }\n\n        // Only glibc 2.24+ posix_spawn() supports returning ENOENT directly.\n        #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n        {\n            if let Some(version) = sys::os::glibc_version() {\n                if version < (2, 24) {\n                    return Ok(None);\n                }\n            } else {\n                return Ok(None);\n            }\n        }\n\n        // Solaris, glibc 2.29+, and musl 1.24+ can set a new working directory,\n        // and maybe others will gain this non-POSIX function too. We'll check\n        // for this weak symbol as soon as it's needed, so we can return early\n        // otherwise to do a manual chdir before exec.\n        weak! {\n            fn posix_spawn_file_actions_addchdir_np(\n                *mut libc::posix_spawn_file_actions_t,\n                *const libc::c_char\n            ) -> libc::c_int\n        }\n        let addchdir = match self.get_cwd() {\n            Some(cwd) => {\n                if cfg!(target_os = \"macos\") {\n                    // There is a bug in macOS where a relative executable\n                    // path like \"../myprogram\" will cause `posix_spawn` to\n                    // successfully launch the program, but erroneously return\n                    // ENOENT when used with posix_spawn_file_actions_addchdir_np\n                    // which was introduced in macOS 10.15.\n                    return Ok(None);\n                }\n                match posix_spawn_file_actions_addchdir_np.get() {\n                    Some(f) => Some((f, cwd)),\n                    None => return Ok(None),\n                }\n            }\n            None => None,\n        };\n\n        let mut p = Process { pid: 0, status: None };\n\n        struct PosixSpawnFileActions<'a>(&'a mut MaybeUninit<libc::posix_spawn_file_actions_t>);\n\n        impl Drop for PosixSpawnFileActions<'_> {\n            fn drop(&mut self) {\n                unsafe {\n                    libc::posix_spawn_file_actions_destroy(self.0.as_mut_ptr());\n                }\n            }\n        }\n\n        struct PosixSpawnattr<'a>(&'a mut MaybeUninit<libc::posix_spawnattr_t>);\n\n        impl Drop for PosixSpawnattr<'_> {\n            fn drop(&mut self) {\n                unsafe {\n                    libc::posix_spawnattr_destroy(self.0.as_mut_ptr());\n                }\n            }\n        }\n\n        unsafe {\n            let mut attrs = MaybeUninit::uninit();\n            cvt_nz(libc::posix_spawnattr_init(attrs.as_mut_ptr()))?;\n            let attrs = PosixSpawnattr(&mut attrs);\n\n            let mut file_actions = MaybeUninit::uninit();\n            cvt_nz(libc::posix_spawn_file_actions_init(file_actions.as_mut_ptr()))?;\n            let file_actions = PosixSpawnFileActions(&mut file_actions);\n\n            if let Some(fd) = stdio.stdin.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDIN_FILENO,\n                ))?;\n            }\n            if let Some(fd) = stdio.stdout.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDOUT_FILENO,\n                ))?;\n            }\n            if let Some(fd) = stdio.stderr.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDERR_FILENO,\n                ))?;\n            }\n            if let Some((f, cwd)) = addchdir {\n                cvt_nz(f(file_actions.0.as_mut_ptr(), cwd.as_ptr()))?;\n            }\n\n            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n            cvt(sigemptyset(set.as_mut_ptr()))?;\n            cvt_nz(libc::posix_spawnattr_setsigmask(attrs.0.as_mut_ptr(), set.as_ptr()))?;\n            cvt(sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n            cvt_nz(libc::posix_spawnattr_setsigdefault(attrs.0.as_mut_ptr(), set.as_ptr()))?;\n\n            let flags = libc::POSIX_SPAWN_SETSIGDEF | libc::POSIX_SPAWN_SETSIGMASK;\n            cvt_nz(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n\n            // Make sure we synchronize access to the global `environ` resource\n            let _env_lock = sys::os::env_read_lock();\n            let envp = envp.map(|c| c.as_ptr()).unwrap_or_else(|| *sys::os::environ() as *const _);\n            cvt_nz(libc::posix_spawnp(\n                &mut p.pid,\n                self.get_program_cstr().as_ptr(),\n                file_actions.0.as_ptr(),\n                attrs.0.as_ptr(),\n                self.get_argv().as_ptr() as *const _,\n                envp as *const _,\n            ))?;\n            Ok(Some(p))\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Processes\n////////////////////////////////////////////////////////////////////////////////\n\n/// The unique ID of the process (this should never be negative).\npub struct Process {\n    pid: pid_t,\n    status: Option<ExitStatus>,\n}\n\nimpl Process {\n    pub fn id(&self) -> u32 {\n        self.pid as u32\n    }\n\n    pub fn kill(&mut self) -> io::Result<()> {\n        // If we've already waited on this process then the pid can be recycled\n        // and used for another process, and we probably shouldn't be killing\n        // random processes, so just return an error.\n        if self.status.is_some() {\n            Err(Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"invalid argument: can't kill an exited process\",\n            ))\n        } else {\n            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)\n        }\n    }\n\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        use crate::sys::cvt_r;\n        if let Some(status) = self.status {\n            return Ok(status);\n        }\n        let mut status = 0 as c_int;\n        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n        self.status = Some(ExitStatus::new(status));\n        Ok(ExitStatus::new(status))\n    }\n\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        if let Some(status) = self.status {\n            return Ok(Some(status));\n        }\n        let mut status = 0 as c_int;\n        let pid = cvt(unsafe { libc::waitpid(self.pid, &mut status, libc::WNOHANG) })?;\n        if pid == 0 {\n            Ok(None)\n        } else {\n            self.status = Some(ExitStatus::new(status));\n            Ok(Some(ExitStatus::new(status)))\n        }\n    }\n}\n\n/// Unix exit statuses\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatus(c_int);\n\nimpl ExitStatus {\n    pub fn new(status: c_int) -> ExitStatus {\n        ExitStatus(status)\n    }\n\n    fn exited(&self) -> bool {\n        libc::WIFEXITED(self.0)\n    }\n\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n        // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n        // true for a platform pretending to be Unix, the tests (our doctests, and also\n        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n        match NonZero_c_int::try_from(self.0) {\n            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n            /* was zero, couldn't convert */ Err(_) => Ok(()),\n        }\n    }\n\n    pub fn code(&self) -> Option<i32> {\n        if self.exited() { Some(libc::WEXITSTATUS(self.0)) } else { None }\n    }\n\n    pub fn signal(&self) -> Option<i32> {\n        if libc::WIFSIGNALED(self.0) { Some(libc::WTERMSIG(self.0)) } else { None }\n    }\n\n    pub fn core_dumped(&self) -> bool {\n        libc::WIFSIGNALED(self.0) && libc::WCOREDUMP(self.0)\n    }\n\n    pub fn stopped_signal(&self) -> Option<i32> {\n        if libc::WIFSTOPPED(self.0) { Some(libc::WSTOPSIG(self.0)) } else { None }\n    }\n\n    pub fn continued(&self) -> bool {\n        libc::WIFCONTINUED(self.0)\n    }\n\n    pub fn into_raw(&self) -> c_int {\n        self.0\n    }\n}\n\n/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\nimpl From<c_int> for ExitStatus {\n    fn from(a: c_int) -> ExitStatus {\n        ExitStatus(a)\n    }\n}\n\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(code) = self.code() {\n            write!(f, \"exit status: {}\", code)\n        } else if let Some(signal) = self.signal() {\n            if self.core_dumped() {\n                write!(f, \"signal: {} (core dumped)\", signal)\n            } else {\n                write!(f, \"signal: {}\", signal)\n            }\n        } else if let Some(signal) = self.stopped_signal() {\n            write!(f, \"stopped (not terminated) by signal: {}\", signal)\n        } else if self.continued() {\n            write!(f, \"continued (WIFCONTINUED)\")\n        } else {\n            write!(f, \"unrecognised wait status: {} {:#x}\", self.0, self.0)\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatusError(NonZero_c_int);\n\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        ExitStatus(self.0.into())\n    }\n}\n\nimpl ExitStatusError {\n    pub fn code(self) -> Option<NonZeroI32> {\n        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n    }\n}\n\n#[cfg(test)]\n#[path = \"process_unix/tests.rs\"]\nmod tests;\n"],["2433","use crate::convert::{TryFrom, TryInto};\nuse crate::fmt;\nuse crate::io::{self, Error, ErrorKind};\nuse crate::num::NonZeroI32;\nuse crate::os::raw::NonZero_c_int;\nuse crate::sys;\nuse crate::sys::cvt;\nuse crate::sys::process::process_common::*;\nuse crate::sys_common::thread;\nuse libc::RTP_ID;\nuse libc::{self, c_char, c_int};\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Command {\n    pub fn spawn(\n        &mut self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        use crate::sys::cvt_r;\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return Err(io::Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            ));\n        }\n        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n        let mut p = Process { pid: 0, status: None };\n\n        unsafe {\n            macro_rules! t {\n                ($e:expr) => {\n                    match $e {\n                        Ok(e) => e,\n                        Err(e) => return Err(e.into()),\n                    }\n                };\n            }\n\n            let mut orig_stdin = libc::STDIN_FILENO;\n            let mut orig_stdout = libc::STDOUT_FILENO;\n            let mut orig_stderr = libc::STDERR_FILENO;\n\n            if let Some(fd) = theirs.stdin.fd() {\n                orig_stdin = t!(cvt_r(|| libc::dup(libc::STDIN_FILENO)));\n                t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n            }\n            if let Some(fd) = theirs.stdout.fd() {\n                orig_stdout = t!(cvt_r(|| libc::dup(libc::STDOUT_FILENO)));\n                t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n            }\n            if let Some(fd) = theirs.stderr.fd() {\n                orig_stderr = t!(cvt_r(|| libc::dup(libc::STDERR_FILENO)));\n                t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n            }\n\n            if let Some(ref cwd) = *self.get_cwd() {\n                t!(cvt(libc::chdir(cwd.as_ptr())));\n            }\n\n            // pre_exec closures are ignored on VxWorks\n            let _ = self.get_closures();\n\n            let c_envp = envp\n                .as_ref()\n                .map(|c| c.as_ptr())\n                .unwrap_or_else(|| *sys::os::environ() as *const _);\n            let stack_size = thread::min_stack();\n\n            // ensure that access to the environment is synchronized\n            let _lock = sys::os::env_read_lock();\n\n            let ret = libc::rtpSpawn(\n                self.get_program_cstr().as_ptr(),\n                self.get_argv().as_ptr() as *mut *const c_char, // argv\n                c_envp as *mut *const c_char,\n                100 as c_int, // initial priority\n                stack_size,   // initial stack size.\n                0,            // options\n                0,            // task options\n            );\n\n            // Because FileDesc was not used, each duplicated file descriptor\n            // needs to be closed manually\n            if orig_stdin != libc::STDIN_FILENO {\n                t!(cvt_r(|| libc::dup2(orig_stdin, libc::STDIN_FILENO)));\n                libc::close(orig_stdin);\n            }\n            if orig_stdout != libc::STDOUT_FILENO {\n                t!(cvt_r(|| libc::dup2(orig_stdout, libc::STDOUT_FILENO)));\n                libc::close(orig_stdout);\n            }\n            if orig_stderr != libc::STDERR_FILENO {\n                t!(cvt_r(|| libc::dup2(orig_stderr, libc::STDERR_FILENO)));\n                libc::close(orig_stderr);\n            }\n\n            if ret != libc::RTP_ID_ERROR {\n                p.pid = ret;\n                Ok((p, ours))\n            } else {\n                Err(io::Error::last_os_error())\n            }\n        }\n    }\n\n    pub fn exec(&mut self, default: Stdio) -> io::Error {\n        let ret = Command::spawn(self, default, false);\n        match ret {\n            Ok(t) => unsafe {\n                let mut status = 0 as c_int;\n                libc::waitpid(t.0.pid, &mut status, 0);\n                libc::exit(0);\n            },\n            Err(e) => e,\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Processes\n////////////////////////////////////////////////////////////////////////////////\n\n/// The unique id of the process (this should never be negative).\npub struct Process {\n    pid: RTP_ID,\n    status: Option<ExitStatus>,\n}\n\nimpl Process {\n    pub fn id(&self) -> u32 {\n        self.pid as u32\n    }\n\n    pub fn kill(&mut self) -> io::Result<()> {\n        // If we've already waited on this process then the pid can be recycled\n        // and used for another process, and we probably shouldn't be killing\n        // random processes, so just return an error.\n        if self.status.is_some() {\n            Err(Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"invalid argument: can't kill an exited process\",\n            ))\n        } else {\n            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)\n        }\n    }\n\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        use crate::sys::cvt_r;\n        if let Some(status) = self.status {\n            return Ok(status);\n        }\n        let mut status = 0 as c_int;\n        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n        self.status = Some(ExitStatus::new(status));\n        Ok(ExitStatus::new(status))\n    }\n\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        if let Some(status) = self.status {\n            return Ok(Some(status));\n        }\n        let mut status = 0 as c_int;\n        let pid = cvt(unsafe { libc::waitpid(self.pid, &mut status, libc::WNOHANG) })?;\n        if pid == 0 {\n            Ok(None)\n        } else {\n            self.status = Some(ExitStatus::new(status));\n            Ok(Some(ExitStatus::new(status)))\n        }\n    }\n}\n\n/// Unix exit statuses\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatus(c_int);\n\nimpl ExitStatus {\n    pub fn new(status: c_int) -> ExitStatus {\n        ExitStatus(status)\n    }\n\n    fn exited(&self) -> bool {\n        libc::WIFEXITED(self.0)\n    }\n\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n        // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n        // true for a platform pretending to be Unix, the tests (our doctests, and also\n        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n        match NonZero_c_int::try_from(self.0) {\n            Ok(failure) => Err(ExitStatusError(failure)),\n            Err(_) => Ok(()),\n        }\n    }\n\n    pub fn code(&self) -> Option<i32> {\n        if self.exited() { Some(libc::WEXITSTATUS(self.0)) } else { None }\n    }\n\n    pub fn signal(&self) -> Option<i32> {\n        if !self.exited() { Some(libc::WTERMSIG(self.0)) } else { None }\n    }\n\n    pub fn core_dumped(&self) -> bool {\n        // This method is not yet properly implemented on VxWorks\n        false\n    }\n\n    pub fn stopped_signal(&self) -> Option<i32> {\n        if libc::WIFSTOPPED(self.0) { Some(libc::WSTOPSIG(self.0)) } else { None }\n    }\n\n    pub fn continued(&self) -> bool {\n        // This method is not yet properly implemented on VxWorks\n        false\n    }\n\n    pub fn into_raw(&self) -> c_int {\n        self.0\n    }\n}\n\n/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\nimpl From<c_int> for ExitStatus {\n    fn from(a: c_int) -> ExitStatus {\n        ExitStatus(a)\n    }\n}\n\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(code) = self.code() {\n            write!(f, \"exit code: {}\", code)\n        } else {\n            let signal = self.signal().unwrap();\n            write!(f, \"signal: {}\", signal)\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatusError(NonZero_c_int);\n\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        ExitStatus(self.0.into())\n    }\n}\n\nimpl ExitStatusError {\n    pub fn code(self) -> Option<NonZeroI32> {\n        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n    }\n}\n"],["2434","use crate::io::{self, IoSlice, IoSliceMut};\nuse crate::mem::ManuallyDrop;\nuse crate::sys::fd::FileDesc;\n\npub struct Stdin(());\npub struct Stdout(());\npub struct Stderr(());\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin(())\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDIN_FILENO)).read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDIN_FILENO)).read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout(())\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDOUT_FILENO)).write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDOUT_FILENO)).write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr(())\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDERR_FILENO)).write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDERR_FILENO)).write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\npub fn is_ebadf(err: &io::Error) -> bool {\n    err.raw_os_error() == Some(libc::EBADF as i32)\n}\n\npub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n\npub fn panic_output() -> Option<impl io::Write> {\n    Some(Stderr::new())\n}\n"],["2435","#![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::cmp;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\nuse crate::mem;\nuse crate::sys::cvt;\nuse crate::sys_common::AsInner;\n\nuse libc::{c_int, c_void};\n\n#[derive(Debug)]\n#[rustc_layout_scalar_valid_range_start(0)]\n// libstd/os/raw/mod.rs assures me that every libstd-supported platform has a\n// 32-bit c_int. Below is -2, in two's complement, but that only works out\n// because c_int is 32 bits.\n#[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\npub struct FileDesc {\n    fd: c_int,\n}\n\n// The maximum read limit on most POSIX-like systems is `SSIZE_MAX`,\n// with the man page quoting that if the count of bytes to read is\n// greater than `SSIZE_MAX` the result is \"unspecified\".\n//\n// On macOS, however, apparently the 64-bit libc is either buggy or\n// intentionally showing odd behavior by rejecting any read with a size\n// larger than or equal to INT_MAX. To handle both of these the read\n// size is capped on both platforms.\n#[cfg(target_os = \"macos\")]\nconst READ_LIMIT: usize = c_int::MAX as usize - 1;\n#[cfg(not(target_os = \"macos\"))]\nconst READ_LIMIT: usize = libc::ssize_t::MAX as usize;\n\n#[cfg(any(\n    target_os = \"dragonfly\",\n    target_os = \"freebsd\",\n    target_os = \"ios\",\n    target_os = \"macos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n))]\nconst fn max_iov() -> usize {\n    libc::IOV_MAX as usize\n}\n\n#[cfg(any(target_os = \"android\", target_os = \"emscripten\", target_os = \"linux\"))]\nconst fn max_iov() -> usize {\n    libc::UIO_MAXIOV as usize\n}\n\n#[cfg(not(any(\n    target_os = \"android\",\n    target_os = \"dragonfly\",\n    target_os = \"emscripten\",\n    target_os = \"freebsd\",\n    target_os = \"ios\",\n    target_os = \"linux\",\n    target_os = \"macos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n)))]\nconst fn max_iov() -> usize {\n    16 // The minimum value required by POSIX.\n}\n\nimpl FileDesc {\n    pub fn new(fd: c_int) -> FileDesc {\n        assert_ne!(fd, -1i32);\n        // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n        unsafe { FileDesc { fd } }\n    }\n\n    pub fn raw(&self) -> c_int {\n        self.fd\n    }\n\n    /// Extracts the actual file descriptor without closing it.\n    pub fn into_raw(self) -> c_int {\n        let fd = self.fd;\n        mem::forget(self);\n        fd\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), READ_LIMIT))\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::readv(\n                self.fd,\n                bufs.as_ptr() as *const libc::iovec,\n                cmp::min(bufs.len(), max_iov()) as c_int,\n            )\n        })?;\n        Ok(ret as usize)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        let mut me = self;\n        (&mut me).read_to_end(buf)\n    }\n\n    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n        #[cfg(target_os = \"android\")]\n        use super::android::cvt_pread64;\n\n        #[cfg(not(target_os = \"android\"))]\n        unsafe fn cvt_pread64(\n            fd: c_int,\n            buf: *mut c_void,\n            count: usize,\n            offset: i64,\n        ) -> io::Result<isize> {\n            #[cfg(not(target_os = \"linux\"))]\n            use libc::pread as pread64;\n            #[cfg(target_os = \"linux\")]\n            use libc::pread64;\n            cvt(pread64(fd, buf, count, offset))\n        }\n\n        unsafe {\n            cvt_pread64(\n                self.fd,\n                buf.as_mut_ptr() as *mut c_void,\n                cmp::min(buf.len(), READ_LIMIT),\n                offset as i64,\n            )\n            .map(|n| n as usize)\n        }\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), READ_LIMIT))\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::writev(\n                self.fd,\n                bufs.as_ptr() as *const libc::iovec,\n                cmp::min(bufs.len(), max_iov()) as c_int,\n            )\n        })?;\n        Ok(ret as usize)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n        #[cfg(target_os = \"android\")]\n        use super::android::cvt_pwrite64;\n\n        #[cfg(not(target_os = \"android\"))]\n        unsafe fn cvt_pwrite64(\n            fd: c_int,\n            buf: *const c_void,\n            count: usize,\n            offset: i64,\n        ) -> io::Result<isize> {\n            #[cfg(not(target_os = \"linux\"))]\n            use libc::pwrite as pwrite64;\n            #[cfg(target_os = \"linux\")]\n            use libc::pwrite64;\n            cvt(pwrite64(fd, buf, count, offset))\n        }\n\n        unsafe {\n            cvt_pwrite64(\n                self.fd,\n                buf.as_ptr() as *const c_void,\n                cmp::min(buf.len(), READ_LIMIT),\n                offset as i64,\n            )\n            .map(|n| n as usize)\n        }\n    }\n\n    #[cfg(target_os = \"linux\")]\n    pub fn get_cloexec(&self) -> io::Result<bool> {\n        unsafe { Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n    }\n\n    #[cfg(not(any(\n        target_env = \"newlib\",\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"emscripten\",\n        target_os = \"fuchsia\",\n        target_os = \"l4re\",\n        target_os = \"linux\",\n        target_os = \"haiku\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    )))]\n    pub fn set_cloexec(&self) -> io::Result<()> {\n        unsafe {\n            cvt(libc::ioctl(self.fd, libc::FIOCLEX))?;\n            Ok(())\n        }\n    }\n    #[cfg(any(\n        target_env = \"newlib\",\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"emscripten\",\n        target_os = \"fuchsia\",\n        target_os = \"l4re\",\n        target_os = \"linux\",\n        target_os = \"haiku\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    ))]\n    pub fn set_cloexec(&self) -> io::Result<()> {\n        unsafe {\n            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n            let new = previous | libc::FD_CLOEXEC;\n            if new != previous {\n                cvt(libc::fcntl(self.fd, libc::F_SETFD, new))?;\n            }\n            Ok(())\n        }\n    }\n\n    #[cfg(target_os = \"linux\")]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        unsafe {\n            let v = nonblocking as c_int;\n            cvt(libc::ioctl(self.fd, libc::FIONBIO, &v))?;\n            Ok(())\n        }\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        unsafe {\n            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFL))?;\n            let new = if nonblocking {\n                previous | libc::O_NONBLOCK\n            } else {\n                previous & !libc::O_NONBLOCK\n            };\n            if new != previous {\n                cvt(libc::fcntl(self.fd, libc::F_SETFL, new))?;\n            }\n            Ok(())\n        }\n    }\n\n    pub fn duplicate(&self) -> io::Result<FileDesc> {\n        // We want to atomically duplicate this file descriptor and set the\n        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n        // is a POSIX flag that was added to Linux in 2.6.24.\n        let fd = cvt(unsafe { libc::fcntl(self.raw(), libc::F_DUPFD_CLOEXEC, 0) })?;\n        Ok(FileDesc::new(fd))\n    }\n}\n\nimpl<'a> Read for &'a FileDesc {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\n\nimpl AsInner<c_int> for FileDesc {\n    fn as_inner(&self) -> &c_int {\n        &self.fd\n    }\n}\n\nimpl Drop for FileDesc {\n    fn drop(&mut self) {\n        // Note that errors are ignored when closing a file descriptor. The\n        // reason for this is that if an error occurs we don't actually know if\n        // the file descriptor was closed or not, and if we retried (for\n        // something like EINTR), we might close another valid file descriptor\n        // opened after we closed ours.\n        let _ = unsafe { libc::close(self.fd) };\n    }\n}\n"],["2436","use crate::ffi::OsStr;\nuse crate::path::Prefix;\n\n#[inline]\npub fn is_sep_byte(b: u8) -> bool {\n    b == b'/'\n}\n\n#[inline]\npub fn is_verbatim_sep(b: u8) -> bool {\n    b == b'/'\n}\n\npub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n    None\n}\n\npub const MAIN_SEP_STR: &str = \"/\";\npub const MAIN_SEP: char = '/';\n"],["2437","//! Android ABI-compatibility module\n//!\n//! The ABI of Android has changed quite a bit over time, and libstd attempts to\n//! be both forwards and backwards compatible as much as possible. We want to\n//! always work with the most recent version of Android, but we also want to\n//! work with older versions of Android for whenever projects need to.\n//!\n//! Our current minimum supported Android version is `android-9`, e.g., Android\n//! with API level 9. We then in theory want to work on that and all future\n//! versions of Android!\n//!\n//! Some of the detection here is done at runtime via `dlopen` and\n//! introspection. Other times no detection is performed at all and we just\n//! provide a fallback implementation as some versions of Android we support\n//! don't have the function.\n//!\n//! You'll find more details below about why each compatibility shim is needed.\n\n#![cfg(target_os = \"android\")]\n\nuse libc::{c_int, c_void, sighandler_t, size_t, ssize_t};\nuse libc::{ftruncate, pread, pwrite};\n\nuse super::{cvt, cvt_r};\nuse crate::io;\n\n// The `log2` and `log2f` functions apparently appeared in android-18, or at\n// least you can see they're not present in the android-17 header [1] and they\n// are present in android-18 [2].\n//\n// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n//                                       /android-17/arch-arm/usr/include/math.h\n// [2]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n//                                       /android-18/arch-arm/usr/include/math.h\n//\n// Note that these shims are likely less precise than directly calling `log2`,\n// but hopefully that should be enough for now...\n//\n// Note that mathematically, for any arbitrary `y`:\n//\n//      log_2(x) = log_y(x) / log_y(2)\n//               = log_y(x) / (1 / log_2(y))\n//               = log_y(x) * log_2(y)\n//\n// Hence because `ln` (log_e) is available on all Android we just choose `y = e`\n// and get:\n//\n//      log_2(x) = ln(x) * log_2(e)\n\n#[cfg(not(test))]\npub fn log2f32(f: f32) -> f32 {\n    f.ln() * crate::f32::consts::LOG2_E\n}\n\n#[cfg(not(test))]\npub fn log2f64(f: f64) -> f64 {\n    f.ln() * crate::f64::consts::LOG2_E\n}\n\n// Back in the day [1] the `signal` function was just an inline wrapper\n// around `bsd_signal`, but starting in API level android-20 the `signal`\n// symbols was introduced [2]. Finally, in android-21 the API `bsd_signal` was\n// removed [3].\n//\n// Basically this means that if we want to be binary compatible with multiple\n// Android releases (oldest being 9 and newest being 21) then we need to check\n// for both symbols and not actually link against either.\n//\n// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n//                                       /android-18/arch-arm/usr/include/signal.h\n// [2]: https://chromium.googlesource.com/android_tools/+/fbd420/ndk_experimental\n//                                       /platforms/android-20/arch-arm\n//                                       /usr/include/signal.h\n// [3]: https://chromium.googlesource.com/android_tools/+/20ee6d/ndk/platforms\n//                                       /android-21/arch-arm/usr/include/signal.h\npub unsafe fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t {\n    weak!(fn signal(c_int, sighandler_t) -> sighandler_t);\n    weak!(fn bsd_signal(c_int, sighandler_t) -> sighandler_t);\n\n    let f = signal.get().or_else(|| bsd_signal.get());\n    let f = f.expect(\"neither `signal` nor `bsd_signal` symbols found\");\n    f(signum, handler)\n}\n\n// The `ftruncate64` symbol apparently appeared in android-12, so we do some\n// dynamic detection to see if we can figure out whether `ftruncate64` exists.\n//\n// If it doesn't we just fall back to `ftruncate`, generating an error for\n// too-large values.\n#[cfg(target_pointer_width = \"32\")]\npub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n    weak!(fn ftruncate64(c_int, i64) -> c_int);\n\n    unsafe {\n        match ftruncate64.get() {\n            Some(f) => cvt_r(|| f(fd, size as i64)).map(drop),\n            None => {\n                if size > i32::MAX as u64 {\n                    Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot truncate >2GB\"))\n                } else {\n                    cvt_r(|| ftruncate(fd, size as i32)).map(drop)\n                }\n            }\n        }\n    }\n}\n\n#[cfg(target_pointer_width = \"64\")]\npub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n    unsafe { cvt_r(|| ftruncate(fd, size as i64)).map(drop) }\n}\n\n#[cfg(target_pointer_width = \"32\")]\npub unsafe fn cvt_pread64(\n    fd: c_int,\n    buf: *mut c_void,\n    count: size_t,\n    offset: i64,\n) -> io::Result<ssize_t> {\n    use crate::convert::TryInto;\n    weak!(fn pread64(c_int, *mut c_void, size_t, i64) -> ssize_t);\n    pread64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n        if let Ok(o) = offset.try_into() {\n            cvt(pread(fd, buf, count, o))\n        } else {\n            Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot pread >2GB\"))\n        }\n    })\n}\n\n#[cfg(target_pointer_width = \"32\")]\npub unsafe fn cvt_pwrite64(\n    fd: c_int,\n    buf: *const c_void,\n    count: size_t,\n    offset: i64,\n) -> io::Result<ssize_t> {\n    use crate::convert::TryInto;\n    weak!(fn pwrite64(c_int, *const c_void, size_t, i64) -> ssize_t);\n    pwrite64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n        if let Ok(o) = offset.try_into() {\n            cvt(pwrite(fd, buf, count, o))\n        } else {\n            Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot pwrite >2GB\"))\n        }\n    })\n}\n\n#[cfg(target_pointer_width = \"64\")]\npub unsafe fn cvt_pread64(\n    fd: c_int,\n    buf: *mut c_void,\n    count: size_t,\n    offset: i64,\n) -> io::Result<ssize_t> {\n    cvt(pread(fd, buf, count, offset))\n}\n\n#[cfg(target_pointer_width = \"64\")]\npub unsafe fn cvt_pwrite64(\n    fd: c_int,\n    buf: *const c_void,\n    count: size_t,\n    offset: i64,\n) -> io::Result<ssize_t> {\n    cvt(pwrite(fd, buf, count, offset))\n}\n"],["2438","//! Implementation of `std::os` functionality for unix systems\n\n#![allow(unused_imports)] // lots of cfg code here\n\n#[cfg(all(test, target_env = \"gnu\"))]\nmod tests;\n\nuse crate::os::unix::prelude::*;\n\nuse crate::error::Error as StdError;\nuse crate::ffi::{CStr, CString, OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::iter;\nuse crate::mem;\nuse crate::path::{self, PathBuf};\nuse crate::ptr;\nuse crate::slice;\nuse crate::str;\nuse crate::sys::cvt;\nuse crate::sys::fd;\nuse crate::sys::memchr;\nuse crate::sys_common::rwlock::{StaticRWLock, StaticRWLockReadGuard};\nuse crate::vec;\n\nuse libc::{c_char, c_int, c_void};\n\nconst TMPBUF_SZ: usize = 128;\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"redox\")] {\n        const PATH_SEPARATOR: u8 = b';';\n    } else {\n        const PATH_SEPARATOR: u8 = b':';\n    }\n}\n\nextern \"C\" {\n    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\n    #[cfg_attr(\n        any(\n            target_os = \"linux\",\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"l4re\"\n        ),\n        link_name = \"__errno_location\"\n    )]\n    #[cfg_attr(\n        any(\n            target_os = \"netbsd\",\n            target_os = \"openbsd\",\n            target_os = \"android\",\n            target_os = \"redox\",\n            target_env = \"newlib\"\n        ),\n        link_name = \"__errno\"\n    )]\n    #[cfg_attr(any(target_os = \"solaris\", target_os = \"illumos\"), link_name = \"___errno\")]\n    #[cfg_attr(\n        any(target_os = \"macos\", target_os = \"ios\", target_os = \"freebsd\"),\n        link_name = \"__error\"\n    )]\n    #[cfg_attr(target_os = \"haiku\", link_name = \"_errnop\")]\n    fn errno_location() -> *mut c_int;\n}\n\n/// Returns the platform-specific value of errno\n#[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\npub fn errno() -> i32 {\n    unsafe { (*errno_location()) as i32 }\n}\n\n/// Sets the platform-specific value of errno\n#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\"), not(target_os = \"vxworks\")))] // needed for readdir and syscall!\n#[allow(dead_code)] // but not all target cfgs actually end up using it\npub fn set_errno(e: i32) {\n    unsafe { *errno_location() = e as c_int }\n}\n\n#[cfg(target_os = \"vxworks\")]\npub fn errno() -> i32 {\n    unsafe { libc::errnoGet() }\n}\n\n#[cfg(target_os = \"dragonfly\")]\npub fn errno() -> i32 {\n    extern \"C\" {\n        #[thread_local]\n        static errno: c_int;\n    }\n\n    unsafe { errno as i32 }\n}\n\n#[cfg(target_os = \"dragonfly\")]\npub fn set_errno(e: i32) {\n    extern \"C\" {\n        #[thread_local]\n        static mut errno: c_int;\n    }\n\n    unsafe {\n        errno = e;\n    }\n}\n\n/// Gets a detailed string description for the given error number.\npub fn error_string(errno: i32) -> String {\n    extern \"C\" {\n        #[cfg_attr(any(target_os = \"linux\", target_env = \"newlib\"), link_name = \"__xpg_strerror_r\")]\n        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t) -> c_int;\n    }\n\n    let mut buf = [0 as c_char; TMPBUF_SZ];\n\n    let p = buf.as_mut_ptr();\n    unsafe {\n        if strerror_r(errno as c_int, p, buf.len()) < 0 {\n            panic!(\"strerror_r failure\");\n        }\n\n        let p = p as *const _;\n        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n    }\n}\n\npub fn getcwd() -> io::Result<PathBuf> {\n    let mut buf = Vec::with_capacity(512);\n    loop {\n        unsafe {\n            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n            if !libc::getcwd(ptr, buf.capacity()).is_null() {\n                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n                buf.set_len(len);\n                buf.shrink_to_fit();\n                return Ok(PathBuf::from(OsString::from_vec(buf)));\n            } else {\n                let error = io::Error::last_os_error();\n                if error.raw_os_error() != Some(libc::ERANGE) {\n                    return Err(error);\n                }\n            }\n\n            // Trigger the internal buffer resizing logic of `Vec` by requiring\n            // more space than the current capacity.\n            let cap = buf.capacity();\n            buf.set_len(cap);\n            buf.reserve(1);\n        }\n    }\n}\n\npub fn chdir(p: &path::Path) -> io::Result<()> {\n    let p: &OsStr = p.as_ref();\n    let p = CString::new(p.as_bytes())?;\n    if unsafe { libc::chdir(p.as_ptr()) } != 0 {\n        return Err(io::Error::last_os_error());\n    }\n    Ok(())\n}\n\npub struct SplitPaths<'a> {\n    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>, fn(&'a [u8]) -> PathBuf>,\n}\n\npub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {\n    fn bytes_to_path(b: &[u8]) -> PathBuf {\n        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n    }\n    fn is_separator(b: &u8) -> bool {\n        *b == PATH_SEPARATOR\n    }\n    let unparsed = unparsed.as_bytes();\n    SplitPaths {\n        iter: unparsed\n            .split(is_separator as fn(&u8) -> bool)\n            .map(bytes_to_path as fn(&[u8]) -> PathBuf),\n    }\n}\n\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[derive(Debug)]\npub struct JoinPathsError;\n\npub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: Iterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n    let mut joined = Vec::new();\n\n    for (i, path) in paths.enumerate() {\n        let path = path.as_ref().as_bytes();\n        if i > 0 {\n            joined.push(PATH_SEPARATOR)\n        }\n        if path.contains(&PATH_SEPARATOR) {\n            return Err(JoinPathsError);\n        }\n        joined.extend_from_slice(path);\n    }\n    Ok(OsStringExt::from_vec(joined))\n}\n\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"path segment contains separator `{}`\", char::from(PATH_SEPARATOR))\n    }\n}\n\nimpl StdError for JoinPathsError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"failed to join paths\"\n    }\n}\n\n#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    unsafe {\n        let mut mib = [\n            libc::CTL_KERN as c_int,\n            libc::KERN_PROC as c_int,\n            libc::KERN_PROC_PATHNAME as c_int,\n            -1 as c_int,\n        ];\n        let mut sz = 0;\n        cvt(libc::sysctl(\n            mib.as_mut_ptr(),\n            mib.len() as libc::c_uint,\n            ptr::null_mut(),\n            &mut sz,\n            ptr::null_mut(),\n            0,\n        ))?;\n        if sz == 0 {\n            return Err(io::Error::last_os_error());\n        }\n        let mut v: Vec<u8> = Vec::with_capacity(sz);\n        cvt(libc::sysctl(\n            mib.as_mut_ptr(),\n            mib.len() as libc::c_uint,\n            v.as_mut_ptr() as *mut libc::c_void,\n            &mut sz,\n            ptr::null_mut(),\n            0,\n        ))?;\n        if sz == 0 {\n            return Err(io::Error::last_os_error());\n        }\n        v.set_len(sz - 1); // chop off trailing NUL\n        Ok(PathBuf::from(OsString::from_vec(v)))\n    }\n}\n\n#[cfg(target_os = \"netbsd\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    fn sysctl() -> io::Result<PathBuf> {\n        unsafe {\n            let mib = [libc::CTL_KERN, libc::KERN_PROC_ARGS, -1, libc::KERN_PROC_PATHNAME];\n            let mut path_len: usize = 0;\n            cvt(libc::sysctl(\n                mib.as_ptr(),\n                mib.len() as libc::c_uint,\n                ptr::null_mut(),\n                &mut path_len,\n                ptr::null(),\n                0,\n            ))?;\n            if path_len <= 1 {\n                return Err(io::Error::new_const(\n                    io::ErrorKind::Other,\n                    &\"KERN_PROC_PATHNAME sysctl returned zero-length string\",\n                ));\n            }\n            let mut path: Vec<u8> = Vec::with_capacity(path_len);\n            cvt(libc::sysctl(\n                mib.as_ptr(),\n                mib.len() as libc::c_uint,\n                path.as_ptr() as *mut libc::c_void,\n                &mut path_len,\n                ptr::null(),\n                0,\n            ))?;\n            path.set_len(path_len - 1); // chop off NUL\n            Ok(PathBuf::from(OsString::from_vec(path)))\n        }\n    }\n    fn procfs() -> io::Result<PathBuf> {\n        let curproc_exe = path::Path::new(\"/proc/curproc/exe\");\n        if curproc_exe.is_file() {\n            return crate::fs::read_link(curproc_exe);\n        }\n        Err(io::Error::new_const(\n            io::ErrorKind::Other,\n            &\"/proc/curproc/exe doesn't point to regular file.\",\n        ))\n    }\n    sysctl().or_else(|_| procfs())\n}\n\n#[cfg(target_os = \"openbsd\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    unsafe {\n        let mut mib = [libc::CTL_KERN, libc::KERN_PROC_ARGS, libc::getpid(), libc::KERN_PROC_ARGV];\n        let mib = mib.as_mut_ptr();\n        let mut argv_len = 0;\n        cvt(libc::sysctl(mib, 4, ptr::null_mut(), &mut argv_len, ptr::null_mut(), 0))?;\n        let mut argv = Vec::<*const libc::c_char>::with_capacity(argv_len as usize);\n        cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _, &mut argv_len, ptr::null_mut(), 0))?;\n        argv.set_len(argv_len as usize);\n        if argv[0].is_null() {\n            return Err(io::Error::new_const(io::ErrorKind::Other, &\"no current exe available\"));\n        }\n        let argv0 = CStr::from_ptr(argv[0]).to_bytes();\n        if argv0[0] == b'.' || argv0.iter().any(|b| *b == b'/') {\n            crate::fs::canonicalize(OsStr::from_bytes(argv0))\n        } else {\n            Ok(PathBuf::from(OsStr::from_bytes(argv0)))\n        }\n    }\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"emscripten\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    match crate::fs::read_link(\"/proc/self/exe\") {\n        Err(ref e) if e.kind() == io::ErrorKind::NotFound => Err(io::Error::new_const(\n            io::ErrorKind::Other,\n            &\"no /proc/self/exe available. Is /proc mounted?\",\n        )),\n        other => other,\n    }\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    extern \"C\" {\n        fn _NSGetExecutablePath(buf: *mut libc::c_char, bufsize: *mut u32) -> libc::c_int;\n    }\n    unsafe {\n        let mut sz: u32 = 0;\n        _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n        if sz == 0 {\n            return Err(io::Error::last_os_error());\n        }\n        let mut v: Vec<u8> = Vec::with_capacity(sz as usize);\n        let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n        if err != 0 {\n            return Err(io::Error::last_os_error());\n        }\n        v.set_len(sz as usize - 1); // chop off trailing NUL\n        Ok(PathBuf::from(OsString::from_vec(v)))\n    }\n}\n\n#[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    extern \"C\" {\n        fn getexecname() -> *const c_char;\n    }\n    unsafe {\n        let path = getexecname();\n        if path.is_null() {\n            Err(io::Error::last_os_error())\n        } else {\n            let filename = CStr::from_ptr(path).to_bytes();\n            let path = PathBuf::from(<OsStr as OsStrExt>::from_bytes(filename));\n\n            // Prepend a current working directory to the path if\n            // it doesn't contain an absolute pathname.\n            if filename[0] == b'/' { Ok(path) } else { getcwd().map(|cwd| cwd.join(path)) }\n        }\n    }\n}\n\n#[cfg(target_os = \"haiku\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    // Use Haiku's image info functions\n    #[repr(C)]\n    struct image_info {\n        id: i32,\n        type_: i32,\n        sequence: i32,\n        init_order: i32,\n        init_routine: *mut libc::c_void, // function pointer\n        term_routine: *mut libc::c_void, // function pointer\n        device: libc::dev_t,\n        node: libc::ino_t,\n        name: [libc::c_char; 1024], // MAXPATHLEN\n        text: *mut libc::c_void,\n        data: *mut libc::c_void,\n        text_size: i32,\n        data_size: i32,\n        api_version: i32,\n        abi: i32,\n    }\n\n    unsafe {\n        extern \"C\" {\n            fn _get_next_image_info(\n                team_id: i32,\n                cookie: *mut i32,\n                info: *mut image_info,\n                size: i32,\n            ) -> i32;\n        }\n\n        let mut info: image_info = mem::zeroed();\n        let mut cookie: i32 = 0;\n        // the executable can be found at team id 0\n        let result =\n            _get_next_image_info(0, &mut cookie, &mut info, mem::size_of::<image_info>() as i32);\n        if result != 0 {\n            use crate::io::ErrorKind;\n            Err(io::Error::new_const(ErrorKind::Other, &\"Error getting executable path\"))\n        } else {\n            let name = CStr::from_ptr(info.name.as_ptr()).to_bytes();\n            Ok(PathBuf::from(OsStr::from_bytes(name)))\n        }\n    }\n}\n\n#[cfg(target_os = \"redox\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    crate::fs::read_to_string(\"sys:exe\").map(PathBuf::from)\n}\n\n#[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    use crate::io::ErrorKind;\n    Err(io::Error::new_const(ErrorKind::Unsupported, &\"Not yet implemented!\"))\n}\n\n#[cfg(target_os = \"vxworks\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    #[cfg(test)]\n    use realstd::env;\n\n    #[cfg(not(test))]\n    use crate::env;\n\n    let exe_path = env::args().next().unwrap();\n    let path = path::Path::new(&exe_path);\n    path.canonicalize()\n}\n\npub struct Env {\n    iter: vec::IntoIter<(OsString, OsString)>,\n}\n\nimpl !Send for Env {}\nimpl !Sync for Env {}\n\nimpl Iterator for Env {\n    type Item = (OsString, OsString);\n    fn next(&mut self) -> Option<(OsString, OsString)> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[cfg(target_os = \"macos\")]\npub unsafe fn environ() -> *mut *const *const c_char {\n    extern \"C\" {\n        fn _NSGetEnviron() -> *mut *const *const c_char;\n    }\n    _NSGetEnviron()\n}\n\n#[cfg(not(target_os = \"macos\"))]\npub unsafe fn environ() -> *mut *const *const c_char {\n    extern \"C\" {\n        static mut environ: *const *const c_char;\n    }\n    ptr::addr_of_mut!(environ)\n}\n\nstatic ENV_LOCK: StaticRWLock = StaticRWLock::new();\n\npub fn env_read_lock() -> StaticRWLockReadGuard {\n    ENV_LOCK.read()\n}\n\n/// Returns a vector of (variable, value) byte-vector pairs for all the\n/// environment variables of the current process.\npub fn env() -> Env {\n    unsafe {\n        let _guard = env_read_lock();\n        let mut environ = *environ();\n        let mut result = Vec::new();\n        if !environ.is_null() {\n            while !(*environ).is_null() {\n                if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n                    result.push(key_value);\n                }\n                environ = environ.add(1);\n            }\n        }\n        return Env { iter: result.into_iter() };\n    }\n\n    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n        // Strategy (copied from glibc): Variable name and value are separated\n        // by an ASCII equals sign '='. Since a variable name must not be\n        // empty, allow variable names starting with an equals sign. Skip all\n        // malformed lines.\n        if input.is_empty() {\n            return None;\n        }\n        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n        pos.map(|p| {\n            (\n                OsStringExt::from_vec(input[..p].to_vec()),\n                OsStringExt::from_vec(input[p + 1..].to_vec()),\n            )\n        })\n    }\n}\n\npub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n    // environment variables with a nul byte can't be set, so their value is\n    // always None as well\n    let k = CString::new(k.as_bytes())?;\n    unsafe {\n        let _guard = env_read_lock();\n        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n        let ret = if s.is_null() {\n            None\n        } else {\n            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n        };\n        Ok(ret)\n    }\n}\n\npub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n    let k = CString::new(k.as_bytes())?;\n    let v = CString::new(v.as_bytes())?;\n\n    unsafe {\n        let _guard = ENV_LOCK.write();\n        cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n    }\n}\n\npub fn unsetenv(n: &OsStr) -> io::Result<()> {\n    let nbuf = CString::new(n.as_bytes())?;\n\n    unsafe {\n        let _guard = ENV_LOCK.write();\n        cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n    }\n}\n\npub fn page_size() -> usize {\n    unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }\n}\n\npub fn temp_dir() -> PathBuf {\n    crate::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| {\n        if cfg!(target_os = \"android\") {\n            PathBuf::from(\"/data/local/tmp\")\n        } else {\n            PathBuf::from(\"/tmp\")\n        }\n    })\n}\n\npub fn home_dir() -> Option<PathBuf> {\n    return crate::env::var_os(\"HOME\").or_else(|| unsafe { fallback() }).map(PathBuf::from);\n\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"ios\",\n        target_os = \"emscripten\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    ))]\n    unsafe fn fallback() -> Option<OsString> {\n        None\n    }\n    #[cfg(not(any(\n        target_os = \"android\",\n        target_os = \"ios\",\n        target_os = \"emscripten\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    )))]\n    unsafe fn fallback() -> Option<OsString> {\n        let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {\n            n if n < 0 => 512 as usize,\n            n => n as usize,\n        };\n        let mut buf = Vec::with_capacity(amt);\n        let mut passwd: libc::passwd = mem::zeroed();\n        let mut result = ptr::null_mut();\n        match libc::getpwuid_r(\n            libc::getuid(),\n            &mut passwd,\n            buf.as_mut_ptr(),\n            buf.capacity(),\n            &mut result,\n        ) {\n            0 if !result.is_null() => {\n                let ptr = passwd.pw_dir as *const _;\n                let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n                Some(OsStringExt::from_vec(bytes))\n            }\n            _ => None,\n        }\n    }\n}\n\npub fn exit(code: i32) -> ! {\n    unsafe { libc::exit(code as c_int) }\n}\n\npub fn getpid() -> u32 {\n    unsafe { libc::getpid() as u32 }\n}\n\npub fn getppid() -> u32 {\n    unsafe { libc::getppid() as u32 }\n}\n\n#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\npub fn glibc_version() -> Option<(usize, usize)> {\n    if let Some(Ok(version_str)) = glibc_version_cstr().map(CStr::to_str) {\n        parse_glibc_version(version_str)\n    } else {\n        None\n    }\n}\n\n#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\nfn glibc_version_cstr() -> Option<&'static CStr> {\n    weak! {\n        fn gnu_get_libc_version() -> *const libc::c_char\n    }\n    if let Some(f) = gnu_get_libc_version.get() {\n        unsafe { Some(CStr::from_ptr(f())) }\n    } else {\n        None\n    }\n}\n\n// Returns Some((major, minor)) if the string is a valid \"x.y\" version,\n// ignoring any extra dot-separated parts. Otherwise return None.\n#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\nfn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n    let mut parsed_ints = version.split('.').map(str::parse::<usize>).fuse();\n    match (parsed_ints.next(), parsed_ints.next()) {\n        (Some(Ok(major)), Some(Ok(minor))) => Some((major, minor)),\n        _ => None,\n    }\n}\n"],["2439","use crate::cmp;\nuse crate::ffi::CStr;\nuse crate::io;\nuse crate::mem;\nuse crate::num::NonZeroUsize;\nuse crate::ptr;\nuse crate::sys::{os, stack_overflow};\nuse crate::time::Duration;\n\n#[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\")))]\npub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n#[cfg(target_os = \"l4re\")]\npub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n#[cfg(target_os = \"vxworks\")]\npub const DEFAULT_MIN_STACK_SIZE: usize = 256 * 1024;\n\npub struct Thread {\n    id: libc::pthread_t,\n}\n\n// Some platforms may have pthread_t as a pointer in which case we still want\n// a thread to be Send/Sync\nunsafe impl Send for Thread {}\nunsafe impl Sync for Thread {}\n\nimpl Thread {\n    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        let p = Box::into_raw(box p);\n        let mut native: libc::pthread_t = mem::zeroed();\n        let mut attr: libc::pthread_attr_t = mem::zeroed();\n        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n\n        let stack_size = cmp::max(stack, min_stack_size(&attr));\n\n        match libc::pthread_attr_setstacksize(&mut attr, stack_size) {\n            0 => {}\n            n => {\n                assert_eq!(n, libc::EINVAL);\n                // EINVAL means |stack_size| is either too small or not a\n                // multiple of the system page size.  Because it's definitely\n                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                // Round up to the nearest page and try again.\n                let page_size = os::page_size();\n                let stack_size =\n                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n            }\n        };\n\n        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n        // Note: if the thread creation fails and this assert fails, then p will\n        // be leaked. However, an alternative design could cause double-free\n        // which is clearly worse.\n        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n\n        return if ret != 0 {\n            // The thread failed to start and as a result p was not consumed. Therefore, it is\n            // safe to reconstruct the box so that it gets deallocated.\n            drop(Box::from_raw(p));\n            Err(io::Error::from_raw_os_error(ret))\n        } else {\n            Ok(Thread { id: native })\n        };\n\n        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n            unsafe {\n                // Next, set up our stack overflow handler which may get triggered if we run\n                // out of stack.\n                let _handler = stack_overflow::Handler::new();\n                // Finally, let's run some code.\n                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n            }\n            ptr::null_mut()\n        }\n    }\n\n    pub fn yield_now() {\n        let ret = unsafe { libc::sched_yield() };\n        debug_assert_eq!(ret, 0);\n    }\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    pub fn set_name(name: &CStr) {\n        const PR_SET_NAME: libc::c_int = 15;\n        // pthread wrapper only appeared in glibc 2.12, so we use syscall\n        // directly.\n        unsafe {\n            libc::prctl(PR_SET_NAME, name.as_ptr() as libc::c_ulong, 0, 0, 0);\n        }\n    }\n\n    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"openbsd\"))]\n    pub fn set_name(name: &CStr) {\n        unsafe {\n            libc::pthread_set_name_np(libc::pthread_self(), name.as_ptr());\n        }\n    }\n\n    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n    pub fn set_name(name: &CStr) {\n        unsafe {\n            libc::pthread_setname_np(name.as_ptr());\n        }\n    }\n\n    #[cfg(target_os = \"netbsd\")]\n    pub fn set_name(name: &CStr) {\n        use crate::ffi::CString;\n        let cname = CString::new(&b\"%s\"[..]).unwrap();\n        unsafe {\n            libc::pthread_setname_np(\n                libc::pthread_self(),\n                cname.as_ptr(),\n                name.as_ptr() as *mut libc::c_void,\n            );\n        }\n    }\n\n    #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\n    pub fn set_name(name: &CStr) {\n        weak! {\n            fn pthread_setname_np(\n                libc::pthread_t, *const libc::c_char\n            ) -> libc::c_int\n        }\n\n        if let Some(f) = pthread_setname_np.get() {\n            unsafe {\n                f(libc::pthread_self(), name.as_ptr());\n            }\n        }\n    }\n\n    #[cfg(any(\n        target_env = \"newlib\",\n        target_os = \"haiku\",\n        target_os = \"l4re\",\n        target_os = \"emscripten\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    ))]\n    pub fn set_name(_name: &CStr) {\n        // Newlib, Haiku, Emscripten, and VxWorks have no way to set a thread name.\n    }\n    #[cfg(target_os = \"fuchsia\")]\n    pub fn set_name(_name: &CStr) {\n        // FIXME: determine whether Fuchsia has a way to set a thread name.\n    }\n\n    pub fn sleep(dur: Duration) {\n        let mut secs = dur.as_secs();\n        let mut nsecs = dur.subsec_nanos() as _;\n\n        // If we're awoken with a signal then the return value will be -1 and\n        // nanosleep will fill in `ts` with the remaining time.\n        unsafe {\n            while secs > 0 || nsecs > 0 {\n                let mut ts = libc::timespec {\n                    tv_sec: cmp::min(libc::time_t::MAX as u64, secs) as libc::time_t,\n                    tv_nsec: nsecs,\n                };\n                secs -= ts.tv_sec as u64;\n                let ts_ptr = &mut ts as *mut _;\n                if libc::nanosleep(ts_ptr, ts_ptr) == -1 {\n                    assert_eq!(os::errno(), libc::EINTR);\n                    secs += ts.tv_sec as u64;\n                    nsecs = ts.tv_nsec;\n                } else {\n                    nsecs = 0;\n                }\n            }\n        }\n    }\n\n    pub fn join(self) {\n        unsafe {\n            let ret = libc::pthread_join(self.id, ptr::null_mut());\n            mem::forget(self);\n            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n        }\n    }\n\n    pub fn id(&self) -> libc::pthread_t {\n        self.id\n    }\n\n    pub fn into_id(self) -> libc::pthread_t {\n        let id = self.id;\n        mem::forget(self);\n        id\n    }\n}\n\nimpl Drop for Thread {\n    fn drop(&mut self) {\n        let ret = unsafe { libc::pthread_detach(self.id) };\n        debug_assert_eq!(ret, 0);\n    }\n}\n\npub fn available_concurrency() -> io::Result<NonZeroUsize> {\n    cfg_if::cfg_if! {\n        if #[cfg(any(\n            target_os = \"android\",\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"ios\",\n            target_os = \"linux\",\n            target_os = \"macos\",\n            target_os = \"solaris\",\n            target_os = \"illumos\",\n        ))] {\n            match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n                -1 => Err(io::Error::last_os_error()),\n                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) }),\n            }\n        } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n            use crate::ptr;\n\n            let mut cpus: libc::c_uint = 0;\n            let mut cpus_size = crate::mem::size_of_val(&cpus);\n\n            unsafe {\n                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n            }\n\n            // Fallback approach in case of errors or no hardware threads.\n            if cpus < 1 {\n                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n                let res = unsafe {\n                    libc::sysctl(\n                        mib.as_mut_ptr(),\n                        2,\n                        &mut cpus as *mut _ as *mut _,\n                        &mut cpus_size as *mut _ as *mut _,\n                        ptr::null_mut(),\n                        0,\n                    )\n                };\n\n                // Handle errors if any.\n                if res == -1 {\n                    return Err(io::Error::last_os_error());\n                } else if cpus == 0 {\n                    return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n                }\n            }\n            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n        } else if #[cfg(target_os = \"openbsd\")] {\n            use crate::ptr;\n\n            let mut cpus: libc::c_uint = 0;\n            let mut cpus_size = crate::mem::size_of_val(&cpus);\n            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n\n            let res = unsafe {\n                libc::sysctl(\n                    mib.as_mut_ptr(),\n                    2,\n                    &mut cpus as *mut _ as *mut _,\n                    &mut cpus_size as *mut _ as *mut _,\n                    ptr::null_mut(),\n                    0,\n                )\n            };\n\n            // Handle errors if any.\n            if res == -1 {\n                return Err(io::Error::last_os_error());\n            } else if cpus == 0 {\n                return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n            }\n\n            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n        } else {\n            // FIXME: implement on vxWorks, Redox, Haiku, l4re\n            Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Getting the number of hardware threads is not supported on the target platform\"))\n        }\n    }\n}\n\n#[cfg(all(\n    not(target_os = \"linux\"),\n    not(target_os = \"freebsd\"),\n    not(target_os = \"macos\"),\n    not(target_os = \"netbsd\"),\n    not(target_os = \"openbsd\"),\n    not(target_os = \"solaris\")\n))]\n#[cfg_attr(test, allow(dead_code))]\npub mod guard {\n    use crate::ops::Range;\n    pub type Guard = Range<usize>;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"freebsd\",\n    target_os = \"macos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n    target_os = \"solaris\"\n))]\n#[cfg_attr(test, allow(dead_code))]\npub mod guard {\n    use libc::{mmap, mprotect};\n    use libc::{MAP_ANON, MAP_FAILED, MAP_FIXED, MAP_PRIVATE, PROT_NONE, PROT_READ, PROT_WRITE};\n\n    use crate::io;\n    use crate::ops::Range;\n    use crate::sync::atomic::{AtomicUsize, Ordering};\n    use crate::sys::os;\n\n    // This is initialized in init() and only read from after\n    static PAGE_SIZE: AtomicUsize = AtomicUsize::new(0);\n\n    pub type Guard = Range<usize>;\n\n    #[cfg(target_os = \"solaris\")]\n    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n        let mut current_stack: libc::stack_t = crate::mem::zeroed();\n        assert_eq!(libc::stack_getbounds(&mut current_stack), 0);\n        Some(current_stack.ss_sp)\n    }\n\n    #[cfg(target_os = \"macos\")]\n    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n        let th = libc::pthread_self();\n        let stackaddr =\n            libc::pthread_get_stackaddr_np(th) as usize - libc::pthread_get_stacksize_np(th);\n        Some(stackaddr as *mut libc::c_void)\n    }\n\n    #[cfg(target_os = \"openbsd\")]\n    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n        let mut current_stack: libc::stack_t = crate::mem::zeroed();\n        assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(), &mut current_stack), 0);\n\n        let stackaddr = if libc::pthread_main_np() == 1 {\n            // main thread\n            current_stack.ss_sp as usize - current_stack.ss_size + PAGE_SIZE.load(Ordering::Relaxed)\n        } else {\n            // new thread\n            current_stack.ss_sp as usize - current_stack.ss_size\n        };\n        Some(stackaddr as *mut libc::c_void)\n    }\n\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"freebsd\",\n        target_os = \"linux\",\n        target_os = \"netbsd\",\n        target_os = \"l4re\"\n    ))]\n    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n        let mut ret = None;\n        let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n        #[cfg(target_os = \"freebsd\")]\n        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n        #[cfg(target_os = \"freebsd\")]\n        let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n        #[cfg(not(target_os = \"freebsd\"))]\n        let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n        if e == 0 {\n            let mut stackaddr = crate::ptr::null_mut();\n            let mut stacksize = 0;\n            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize), 0);\n            ret = Some(stackaddr);\n        }\n        if e == 0 || cfg!(target_os = \"freebsd\") {\n            assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n        }\n        ret\n    }\n\n    // Precondition: PAGE_SIZE is initialized.\n    unsafe fn get_stack_start_aligned() -> Option<*mut libc::c_void> {\n        let page_size = PAGE_SIZE.load(Ordering::Relaxed);\n        assert!(page_size != 0);\n        let stackaddr = get_stack_start()?;\n\n        // Ensure stackaddr is page aligned! A parent process might\n        // have reset RLIMIT_STACK to be non-page aligned. The\n        // pthread_attr_getstack() reports the usable stack area\n        // stackaddr < stackaddr + stacksize, so if stackaddr is not\n        // page-aligned, calculate the fix such that stackaddr <\n        // new_page_aligned_stackaddr < stackaddr + stacksize\n        let remainder = (stackaddr as usize) % page_size;\n        Some(if remainder == 0 {\n            stackaddr\n        } else {\n            ((stackaddr as usize) + page_size - remainder) as *mut libc::c_void\n        })\n    }\n\n    pub unsafe fn init() -> Option<Guard> {\n        let page_size = os::page_size();\n        PAGE_SIZE.store(page_size, Ordering::Relaxed);\n\n        if cfg!(all(target_os = \"linux\", not(target_env = \"musl\"))) {\n            // Linux doesn't allocate the whole stack right away, and\n            // the kernel has its own stack-guard mechanism to fault\n            // when growing too close to an existing mapping.  If we map\n            // our own guard, then the kernel starts enforcing a rather\n            // large gap above that, rendering much of the possible\n            // stack space useless.  See #43052.\n            //\n            // Instead, we'll just note where we expect rlimit to start\n            // faulting, so our handler can report \"stack overflow\", and\n            // trust that the kernel's own stack guard will work.\n            let stackaddr = get_stack_start_aligned()?;\n            let stackaddr = stackaddr as usize;\n            Some(stackaddr - page_size..stackaddr)\n        } else if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n            // For the main thread, the musl's pthread_attr_getstack\n            // returns the current stack size, rather than maximum size\n            // it can eventually grow to. It cannot be used to determine\n            // the position of kernel's stack guard.\n            None\n        } else if cfg!(target_os = \"freebsd\") {\n            // FreeBSD's stack autogrows, and optionally includes a guard page\n            // at the bottom.  If we try to remap the bottom of the stack\n            // ourselves, FreeBSD's guard page moves upwards.  So we'll just use\n            // the builtin guard page.\n            let stackaddr = get_stack_start_aligned()?;\n            let guardaddr = stackaddr as usize;\n            // Technically the number of guard pages is tunable and controlled\n            // by the security.bsd.stack_guard_page sysctl, but there are\n            // few reasons to change it from the default.  The default value has\n            // been 1 ever since FreeBSD 11.1 and 10.4.\n            const GUARD_PAGES: usize = 1;\n            let guard = guardaddr..guardaddr + GUARD_PAGES * page_size;\n            Some(guard)\n        } else {\n            // Reallocate the last page of the stack.\n            // This ensures SIGBUS will be raised on\n            // stack overflow.\n            // Systems which enforce strict PAX MPROTECT do not allow\n            // to mprotect() a mapping with less restrictive permissions\n            // than the initial mmap() used, so we mmap() here with\n            // read/write permissions and only then mprotect() it to\n            // no permissions at all. See issue #50313.\n            let stackaddr = get_stack_start_aligned()?;\n            let result = mmap(\n                stackaddr,\n                page_size,\n                PROT_READ | PROT_WRITE,\n                MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n                -1,\n                0,\n            );\n            if result != stackaddr || result == MAP_FAILED {\n                panic!(\"failed to allocate a guard page: {}\", io::Error::last_os_error());\n            }\n\n            let result = mprotect(stackaddr, page_size, PROT_NONE);\n            if result != 0 {\n                panic!(\"failed to protect the guard page: {}\", io::Error::last_os_error());\n            }\n\n            let guardaddr = stackaddr as usize;\n\n            Some(guardaddr..guardaddr + page_size)\n        }\n    }\n\n    #[cfg(any(target_os = \"macos\", target_os = \"openbsd\", target_os = \"solaris\"))]\n    pub unsafe fn current() -> Option<Guard> {\n        let stackaddr = get_stack_start()? as usize;\n        Some(stackaddr - PAGE_SIZE.load(Ordering::Relaxed)..stackaddr)\n    }\n\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"freebsd\",\n        target_os = \"linux\",\n        target_os = \"netbsd\",\n        target_os = \"l4re\"\n    ))]\n    pub unsafe fn current() -> Option<Guard> {\n        let mut ret = None;\n        let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n        #[cfg(target_os = \"freebsd\")]\n        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n        #[cfg(target_os = \"freebsd\")]\n        let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n        #[cfg(not(target_os = \"freebsd\"))]\n        let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n        if e == 0 {\n            let mut guardsize = 0;\n            assert_eq!(libc::pthread_attr_getguardsize(&attr, &mut guardsize), 0);\n            if guardsize == 0 {\n                if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n                    // musl versions before 1.1.19 always reported guard\n                    // size obtained from pthread_attr_get_np as zero.\n                    // Use page size as a fallback.\n                    guardsize = PAGE_SIZE.load(Ordering::Relaxed);\n                } else {\n                    panic!(\"there is no guard page\");\n                }\n            }\n            let mut stackaddr = crate::ptr::null_mut();\n            let mut size = 0;\n            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n\n            let stackaddr = stackaddr as usize;\n            ret = if cfg!(any(target_os = \"freebsd\", target_os = \"netbsd\")) {\n                Some(stackaddr - guardsize..stackaddr)\n            } else if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n                Some(stackaddr - guardsize..stackaddr)\n            } else if cfg!(all(target_os = \"linux\", target_env = \"gnu\")) {\n                // glibc used to include the guard area within the stack, as noted in the BUGS\n                // section of `man pthread_attr_getguardsize`.  This has been corrected starting\n                // with glibc 2.27, and in some distro backports, so the guard is now placed at the\n                // end (below) the stack.  There's no easy way for us to know which we have at\n                // runtime, so we'll just match any fault in the range right above or below the\n                // stack base to call that fault a stack overflow.\n                Some(stackaddr - guardsize..stackaddr + guardsize)\n            } else {\n                Some(stackaddr..stackaddr + guardsize)\n            };\n        }\n        if e == 0 || cfg!(target_os = \"freebsd\") {\n            assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n        }\n        ret\n    }\n}\n\n// glibc >= 2.15 has a __pthread_get_minstack() function that returns\n// PTHREAD_STACK_MIN plus bytes needed for thread-local storage.\n// We need that information to avoid blowing up when a small stack\n// is created in an application with big thread-local storage requirements.\n// See #6233 for rationale and details.\n#[cfg(target_os = \"linux\")]\n#[allow(deprecated)]\nfn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n    weak!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -> libc::size_t);\n\n    match __pthread_get_minstack.get() {\n        None => libc::PTHREAD_STACK_MIN,\n        Some(f) => unsafe { f(attr) },\n    }\n}\n\n// No point in looking up __pthread_get_minstack() on non-glibc\n// platforms.\n#[cfg(all(not(target_os = \"linux\"), not(target_os = \"netbsd\")))]\nfn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n    libc::PTHREAD_STACK_MIN\n}\n\n#[cfg(target_os = \"netbsd\")]\nfn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n    2048 // just a guess\n}\n"],["2440","use crate::os::unix::prelude::*;\n\nuse crate::ffi::{CStr, CString, OsStr, OsString};\nuse crate::fmt;\nuse crate::io::{self, Error, IoSlice, IoSliceMut, SeekFrom};\nuse crate::mem;\nuse crate::path::{Path, PathBuf};\nuse crate::ptr;\nuse crate::sync::Arc;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::time::SystemTime;\nuse crate::sys::{cvt, cvt_r};\nuse crate::sys_common::{AsInner, FromInner};\n\nuse libc::{c_int, mode_t};\n\n#[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\nuse libc::dirfd;\n#[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\nuse libc::fstatat64;\n#[cfg(not(any(\n    target_os = \"linux\",\n    target_os = \"emscripten\",\n    target_os = \"solaris\",\n    target_os = \"illumos\",\n    target_os = \"l4re\",\n    target_os = \"fuchsia\",\n    target_os = \"redox\"\n)))]\nuse libc::readdir_r as readdir64_r;\n#[cfg(target_os = \"android\")]\nuse libc::{\n    dirent as dirent64, fstat as fstat64, fstatat as fstatat64, lseek64, lstat as lstat64,\n    open as open64, stat as stat64,\n};\n#[cfg(not(any(\n    target_os = \"linux\",\n    target_os = \"emscripten\",\n    target_os = \"l4re\",\n    target_os = \"android\"\n)))]\nuse libc::{\n    dirent as dirent64, fstat as fstat64, ftruncate as ftruncate64, lseek as lseek64,\n    lstat as lstat64, off_t as off64_t, open as open64, stat as stat64,\n};\n#[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"l4re\"))]\nuse libc::{\n    dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, readdir64_r, stat64,\n};\n\npub use crate::sys_common::fs::{remove_dir_all, try_exists};\n\npub struct File(FileDesc);\n\n// FIXME: This should be available on Linux with all `target_env`.\n// But currently only glibc exposes `statx` fn and structs.\n// We don't want to import unverified raw C structs here directly.\n// https://github.com/rust-lang/rust/pull/67774\nmacro_rules! cfg_has_statx {\n    ({ $($then_tt:tt)* } else { $($else_tt:tt)* }) => {\n        cfg_if::cfg_if! {\n            if #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))] {\n                $($then_tt)*\n            } else {\n                $($else_tt)*\n            }\n        }\n    };\n    ($($block_inner:tt)*) => {\n        #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n        {\n            $($block_inner)*\n        }\n    };\n}\n\ncfg_has_statx! {{\n    #[derive(Clone)]\n    pub struct FileAttr {\n        stat: stat64,\n        statx_extra_fields: Option<StatxExtraFields>,\n    }\n\n    #[derive(Clone)]\n    struct StatxExtraFields {\n        // This is needed to check if btime is supported by the filesystem.\n        stx_mask: u32,\n        stx_btime: libc::statx_timestamp,\n    }\n\n    // We prefer `statx` on Linux if available, which contains file creation time.\n    // Default `stat64` contains no creation time.\n    unsafe fn try_statx(\n        fd: c_int,\n        path: *const libc::c_char,\n        flags: i32,\n        mask: u32,\n    ) -> Option<io::Result<FileAttr>> {\n        use crate::sync::atomic::{AtomicU8, Ordering};\n\n        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n        // We store the availability in global to avoid unnecessary syscalls.\n        // 0: Unknown\n        // 1: Not available\n        // 2: Available\n        static STATX_STATE: AtomicU8 = AtomicU8::new(0);\n        syscall! {\n            fn statx(\n                fd: c_int,\n                pathname: *const libc::c_char,\n                flags: c_int,\n                mask: libc::c_uint,\n                statxbuf: *mut libc::statx\n            ) -> c_int\n        }\n\n        match STATX_STATE.load(Ordering::Relaxed) {\n            0 => {\n                // It is a trick to call `statx` with null pointers to check if the syscall\n                // is available. According to the manual, it is expected to fail with EFAULT.\n                // We do this mainly for performance, since it is nearly hundreds times\n                // faster than a normal successful call.\n                let err = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n                    .err()\n                    .and_then(|e| e.raw_os_error());\n                // We don't check `err == Some(libc::ENOSYS)` because the syscall may be limited\n                // and returns `EPERM`. Listing all possible errors seems not a good idea.\n                // See: https://github.com/rust-lang/rust/issues/65662\n                if err != Some(libc::EFAULT) {\n                    STATX_STATE.store(1, Ordering::Relaxed);\n                    return None;\n                }\n                STATX_STATE.store(2, Ordering::Relaxed);\n            }\n            1 => return None,\n            _ => {}\n        }\n\n        let mut buf: libc::statx = mem::zeroed();\n        if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n            return Some(Err(err));\n        }\n\n        // We cannot fill `stat64` exhaustively because of private padding fields.\n        let mut stat: stat64 = mem::zeroed();\n        // `c_ulong` on gnu-mips, `dev_t` otherwise\n        stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n        stat.st_ino = buf.stx_ino as libc::ino64_t;\n        stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n        stat.st_mode = buf.stx_mode as libc::mode_t;\n        stat.st_uid = buf.stx_uid as libc::uid_t;\n        stat.st_gid = buf.stx_gid as libc::gid_t;\n        stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n        stat.st_size = buf.stx_size as off64_t;\n        stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n        stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n        stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n        // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n        stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n        stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n        stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n        stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n        stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n\n        let extra = StatxExtraFields {\n            stx_mask: buf.stx_mask,\n            stx_btime: buf.stx_btime,\n        };\n\n        Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n    }\n\n} else {\n    #[derive(Clone)]\n    pub struct FileAttr {\n        stat: stat64,\n    }\n}}\n\n// all DirEntry's will have a reference to this struct\nstruct InnerReadDir {\n    dirp: Dir,\n    root: PathBuf,\n}\n\npub struct ReadDir {\n    inner: Arc<InnerReadDir>,\n    #[cfg(not(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n    )))]\n    end_of_stream: bool,\n}\n\nstruct Dir(*mut libc::DIR);\n\nunsafe impl Send for Dir {}\nunsafe impl Sync for Dir {}\n\npub struct DirEntry {\n    entry: dirent64,\n    dir: Arc<InnerReadDir>,\n    // We need to store an owned copy of the entry name\n    // on Solaris and Fuchsia because a) it uses a zero-length\n    // array to store the name, b) its lifetime between readdir\n    // calls is not guaranteed.\n    #[cfg(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\"\n    ))]\n    name: Box<[u8]>,\n}\n\n#[derive(Clone, Debug)]\npub struct OpenOptions {\n    // generic\n    read: bool,\n    write: bool,\n    append: bool,\n    truncate: bool,\n    create: bool,\n    create_new: bool,\n    // system-specific\n    custom_flags: i32,\n    mode: mode_t,\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct FilePermissions {\n    mode: mode_t,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\npub struct FileType {\n    mode: mode_t,\n}\n\n#[derive(Debug)]\npub struct DirBuilder {\n    mode: mode_t,\n}\n\ncfg_has_statx! {{\n    impl FileAttr {\n        fn from_stat64(stat: stat64) -> Self {\n            Self { stat, statx_extra_fields: None }\n        }\n    }\n} else {\n    impl FileAttr {\n        fn from_stat64(stat: stat64) -> Self {\n            Self { stat }\n        }\n    }\n}}\n\nimpl FileAttr {\n    pub fn size(&self) -> u64 {\n        self.stat.st_size as u64\n    }\n    pub fn perm(&self) -> FilePermissions {\n        FilePermissions { mode: (self.stat.st_mode as mode_t) }\n    }\n\n    pub fn file_type(&self) -> FileType {\n        FileType { mode: self.stat.st_mode as mode_t }\n    }\n}\n\n#[cfg(target_os = \"netbsd\")]\nimpl FileAttr {\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_mtime as libc::time_t,\n            tv_nsec: self.stat.st_mtimensec as libc::c_long,\n        }))\n    }\n\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_atime as libc::time_t,\n            tv_nsec: self.stat.st_atimensec as libc::c_long,\n        }))\n    }\n\n    pub fn created(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_birthtime as libc::time_t,\n            tv_nsec: self.stat.st_birthtimensec as libc::c_long,\n        }))\n    }\n}\n\n#[cfg(not(target_os = \"netbsd\"))]\nimpl FileAttr {\n    #[cfg(not(target_os = \"vxworks\"))]\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_mtime as libc::time_t,\n            tv_nsec: self.stat.st_mtime_nsec as _,\n        }))\n    }\n\n    #[cfg(target_os = \"vxworks\")]\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_mtime as libc::time_t,\n            tv_nsec: 0,\n        }))\n    }\n\n    #[cfg(not(target_os = \"vxworks\"))]\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_atime as libc::time_t,\n            tv_nsec: self.stat.st_atime_nsec as _,\n        }))\n    }\n\n    #[cfg(target_os = \"vxworks\")]\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_atime as libc::time_t,\n            tv_nsec: 0,\n        }))\n    }\n\n    #[cfg(any(\n        target_os = \"freebsd\",\n        target_os = \"openbsd\",\n        target_os = \"macos\",\n        target_os = \"ios\"\n    ))]\n    pub fn created(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_birthtime as libc::time_t,\n            tv_nsec: self.stat.st_birthtime_nsec as libc::c_long,\n        }))\n    }\n\n    #[cfg(not(any(\n        target_os = \"freebsd\",\n        target_os = \"openbsd\",\n        target_os = \"macos\",\n        target_os = \"ios\"\n    )))]\n    pub fn created(&self) -> io::Result<SystemTime> {\n        cfg_has_statx! {\n            if let Some(ext) = &self.statx_extra_fields {\n                return if (ext.stx_mask & libc::STATX_BTIME) != 0 {\n                    Ok(SystemTime::from(libc::timespec {\n                        tv_sec: ext.stx_btime.tv_sec as libc::time_t,\n                        tv_nsec: ext.stx_btime.tv_nsec as _,\n                    }))\n                } else {\n                    Err(io::Error::new_const(\n                        io::ErrorKind::Other,\n                        &\"creation time is not available for the filesystem\",\n                    ))\n                };\n            }\n        }\n\n        Err(io::Error::new_const(\n            io::ErrorKind::Unsupported,\n            &\"creation time is not available on this platform \\\n                            currently\",\n        ))\n    }\n}\n\nimpl AsInner<stat64> for FileAttr {\n    fn as_inner(&self) -> &stat64 {\n        &self.stat\n    }\n}\n\nimpl FilePermissions {\n    pub fn readonly(&self) -> bool {\n        // check if any class (owner, group, others) has write permission\n        self.mode & 0o222 == 0\n    }\n\n    pub fn set_readonly(&mut self, readonly: bool) {\n        if readonly {\n            // remove write permission for all classes; equivalent to `chmod a-w <file>`\n            self.mode &= !0o222;\n        } else {\n            // add write permission for all classes; equivalent to `chmod a+w <file>`\n            self.mode |= 0o222;\n        }\n    }\n    pub fn mode(&self) -> u32 {\n        self.mode as u32\n    }\n}\n\nimpl FileType {\n    pub fn is_dir(&self) -> bool {\n        self.is(libc::S_IFDIR)\n    }\n    pub fn is_file(&self) -> bool {\n        self.is(libc::S_IFREG)\n    }\n    pub fn is_symlink(&self) -> bool {\n        self.is(libc::S_IFLNK)\n    }\n\n    pub fn is(&self, mode: mode_t) -> bool {\n        self.mode & libc::S_IFMT == mode\n    }\n}\n\nimpl FromInner<u32> for FilePermissions {\n    fn from_inner(mode: u32) -> FilePermissions {\n        FilePermissions { mode: mode as mode_t }\n    }\n}\n\nimpl fmt::Debug for ReadDir {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n        // Thus the result will be e g 'ReadDir(\"/home\")'\n        fmt::Debug::fmt(&*self.inner.root, f)\n    }\n}\n\nimpl Iterator for ReadDir {\n    type Item = io::Result<DirEntry>;\n\n    #[cfg(any(\n        target_os = \"solaris\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n        target_os = \"illumos\"\n    ))]\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        use crate::slice;\n\n        unsafe {\n            loop {\n                // Although readdir_r(3) would be a correct function to use here because\n                // of the thread safety, on Illumos and Fuchsia the readdir(3C) function\n                // is safe to use in threaded applications and it is generally preferred\n                // over the readdir_r(3C) function.\n                super::os::set_errno(0);\n                let entry_ptr = libc::readdir(self.inner.dirp.0);\n                if entry_ptr.is_null() {\n                    // null can mean either the end is reached or an error occurred.\n                    // So we had to clear errno beforehand to check for an error now.\n                    return match super::os::errno() {\n                        0 => None,\n                        e => Some(Err(Error::from_raw_os_error(e))),\n                    };\n                }\n\n                let name = (*entry_ptr).d_name.as_ptr();\n                let namelen = libc::strlen(name) as usize;\n\n                let ret = DirEntry {\n                    entry: *entry_ptr,\n                    name: slice::from_raw_parts(name as *const u8, namelen as usize)\n                        .to_owned()\n                        .into_boxed_slice(),\n                    dir: Arc::clone(&self.inner),\n                };\n                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n                    return Some(Ok(ret));\n                }\n            }\n        }\n    }\n\n    #[cfg(not(any(\n        target_os = \"solaris\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n        target_os = \"illumos\"\n    )))]\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        if self.end_of_stream {\n            return None;\n        }\n\n        unsafe {\n            let mut ret = DirEntry { entry: mem::zeroed(), dir: Arc::clone(&self.inner) };\n            let mut entry_ptr = ptr::null_mut();\n            loop {\n                if readdir64_r(self.inner.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n                    if entry_ptr.is_null() {\n                        // We encountered an error (which will be returned in this iteration), but\n                        // we also reached the end of the directory stream. The `end_of_stream`\n                        // flag is enabled to make sure that we return `None` in the next iteration\n                        // (instead of looping forever)\n                        self.end_of_stream = true;\n                    }\n                    return Some(Err(Error::last_os_error()));\n                }\n                if entry_ptr.is_null() {\n                    return None;\n                }\n                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n                    return Some(Ok(ret));\n                }\n            }\n        }\n    }\n}\n\nimpl Drop for Dir {\n    fn drop(&mut self) {\n        let r = unsafe { libc::closedir(self.0) };\n        debug_assert_eq!(r, 0);\n    }\n}\n\nimpl DirEntry {\n    pub fn path(&self) -> PathBuf {\n        self.dir.root.join(OsStr::from_bytes(self.name_bytes()))\n    }\n\n    pub fn file_name(&self) -> OsString {\n        OsStr::from_bytes(self.name_bytes()).to_os_string()\n    }\n\n    #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n    pub fn metadata(&self) -> io::Result<FileAttr> {\n        let fd = cvt(unsafe { dirfd(self.dir.dirp.0) })?;\n        let name = self.entry.d_name.as_ptr();\n\n        cfg_has_statx! {\n            if let Some(ret) = unsafe { try_statx(\n                fd,\n                name,\n                libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n                libc::STATX_ALL,\n            ) } {\n                return ret;\n            }\n        }\n\n        let mut stat: stat64 = unsafe { mem::zeroed() };\n        cvt(unsafe { fstatat64(fd, name, &mut stat, libc::AT_SYMLINK_NOFOLLOW) })?;\n        Ok(FileAttr::from_stat64(stat))\n    }\n\n    #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\")))]\n    pub fn metadata(&self) -> io::Result<FileAttr> {\n        lstat(&self.path())\n    }\n\n    #[cfg(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"haiku\",\n        target_os = \"vxworks\"\n    ))]\n    pub fn file_type(&self) -> io::Result<FileType> {\n        lstat(&self.path()).map(|m| m.file_type())\n    }\n\n    #[cfg(not(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"haiku\",\n        target_os = \"vxworks\"\n    )))]\n    pub fn file_type(&self) -> io::Result<FileType> {\n        match self.entry.d_type {\n            libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n            libc::DT_FIFO => Ok(FileType { mode: libc::S_IFIFO }),\n            libc::DT_LNK => Ok(FileType { mode: libc::S_IFLNK }),\n            libc::DT_REG => Ok(FileType { mode: libc::S_IFREG }),\n            libc::DT_SOCK => Ok(FileType { mode: libc::S_IFSOCK }),\n            libc::DT_DIR => Ok(FileType { mode: libc::S_IFDIR }),\n            libc::DT_BLK => Ok(FileType { mode: libc::S_IFBLK }),\n            _ => lstat(&self.path()).map(|m| m.file_type()),\n        }\n    }\n\n    #[cfg(any(\n        target_os = \"macos\",\n        target_os = \"ios\",\n        target_os = \"linux\",\n        target_os = \"emscripten\",\n        target_os = \"android\",\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"haiku\",\n        target_os = \"l4re\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    ))]\n    pub fn ino(&self) -> u64 {\n        self.entry.d_ino as u64\n    }\n\n    #[cfg(any(\n        target_os = \"freebsd\",\n        target_os = \"openbsd\",\n        target_os = \"netbsd\",\n        target_os = \"dragonfly\"\n    ))]\n    pub fn ino(&self) -> u64 {\n        self.entry.d_fileno as u64\n    }\n\n    #[cfg(any(\n        target_os = \"macos\",\n        target_os = \"ios\",\n        target_os = \"netbsd\",\n        target_os = \"openbsd\",\n        target_os = \"freebsd\",\n        target_os = \"dragonfly\"\n    ))]\n    fn name_bytes(&self) -> &[u8] {\n        use crate::slice;\n        unsafe {\n            slice::from_raw_parts(\n                self.entry.d_name.as_ptr() as *const u8,\n                self.entry.d_namlen as usize,\n            )\n        }\n    }\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"linux\",\n        target_os = \"emscripten\",\n        target_os = \"l4re\",\n        target_os = \"haiku\",\n        target_os = \"vxworks\"\n    ))]\n    fn name_bytes(&self) -> &[u8] {\n        unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes() }\n    }\n    #[cfg(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\"\n    ))]\n    fn name_bytes(&self) -> &[u8] {\n        &*self.name\n    }\n}\n\nimpl OpenOptions {\n    pub fn new() -> OpenOptions {\n        OpenOptions {\n            // generic\n            read: false,\n            write: false,\n            append: false,\n            truncate: false,\n            create: false,\n            create_new: false,\n            // system-specific\n            custom_flags: 0,\n            mode: 0o666,\n        }\n    }\n\n    pub fn read(&mut self, read: bool) {\n        self.read = read;\n    }\n    pub fn write(&mut self, write: bool) {\n        self.write = write;\n    }\n    pub fn append(&mut self, append: bool) {\n        self.append = append;\n    }\n    pub fn truncate(&mut self, truncate: bool) {\n        self.truncate = truncate;\n    }\n    pub fn create(&mut self, create: bool) {\n        self.create = create;\n    }\n    pub fn create_new(&mut self, create_new: bool) {\n        self.create_new = create_new;\n    }\n\n    pub fn custom_flags(&mut self, flags: i32) {\n        self.custom_flags = flags;\n    }\n    pub fn mode(&mut self, mode: u32) {\n        self.mode = mode as mode_t;\n    }\n\n    fn get_access_mode(&self) -> io::Result<c_int> {\n        match (self.read, self.write, self.append) {\n            (true, false, false) => Ok(libc::O_RDONLY),\n            (false, true, false) => Ok(libc::O_WRONLY),\n            (true, true, false) => Ok(libc::O_RDWR),\n            (false, _, true) => Ok(libc::O_WRONLY | libc::O_APPEND),\n            (true, _, true) => Ok(libc::O_RDWR | libc::O_APPEND),\n            (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n        }\n    }\n\n    fn get_creation_mode(&self) -> io::Result<c_int> {\n        match (self.write, self.append) {\n            (true, false) => {}\n            (false, false) => {\n                if self.truncate || self.create || self.create_new {\n                    return Err(Error::from_raw_os_error(libc::EINVAL));\n                }\n            }\n            (_, true) => {\n                if self.truncate && !self.create_new {\n                    return Err(Error::from_raw_os_error(libc::EINVAL));\n                }\n            }\n        }\n\n        Ok(match (self.create, self.truncate, self.create_new) {\n            (false, false, false) => 0,\n            (true, false, false) => libc::O_CREAT,\n            (false, true, false) => libc::O_TRUNC,\n            (true, true, false) => libc::O_CREAT | libc::O_TRUNC,\n            (_, _, true) => libc::O_CREAT | libc::O_EXCL,\n        })\n    }\n}\n\nimpl File {\n    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n        let path = cstr(path)?;\n        File::open_c(&path, opts)\n    }\n\n    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n        let flags = libc::O_CLOEXEC\n            | opts.get_access_mode()?\n            | opts.get_creation_mode()?\n            | (opts.custom_flags as c_int & !libc::O_ACCMODE);\n        // The third argument of `open64` is documented to have type `mode_t`. On\n        // some platforms (like macOS, where `open64` is actually `open`), `mode_t` is `u16`.\n        // However, since this is a variadic function, C integer promotion rules mean that on\n        // the ABI level, this still gets passed as `c_int` (aka `u32` on Unix platforms).\n        let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;\n        Ok(File(FileDesc::new(fd)))\n    }\n\n    pub fn file_attr(&self) -> io::Result<FileAttr> {\n        let fd = self.0.raw();\n\n        cfg_has_statx! {\n            if let Some(ret) = unsafe { try_statx(\n                fd,\n                b\"\\0\" as *const _ as *const libc::c_char,\n                libc::AT_EMPTY_PATH | libc::AT_STATX_SYNC_AS_STAT,\n                libc::STATX_ALL,\n            ) } {\n                return ret;\n            }\n        }\n\n        let mut stat: stat64 = unsafe { mem::zeroed() };\n        cvt(unsafe { fstat64(fd, &mut stat) })?;\n        Ok(FileAttr::from_stat64(stat))\n    }\n\n    pub fn fsync(&self) -> io::Result<()> {\n        cvt_r(|| unsafe { os_fsync(self.0.raw()) })?;\n        return Ok(());\n\n        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n        unsafe fn os_fsync(fd: c_int) -> c_int {\n            libc::fcntl(fd, libc::F_FULLFSYNC)\n        }\n        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n        unsafe fn os_fsync(fd: c_int) -> c_int {\n            libc::fsync(fd)\n        }\n    }\n\n    pub fn datasync(&self) -> io::Result<()> {\n        cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n        return Ok(());\n\n        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n        unsafe fn os_datasync(fd: c_int) -> c_int {\n            libc::fcntl(fd, libc::F_FULLFSYNC)\n        }\n        #[cfg(any(\n            target_os = \"freebsd\",\n            target_os = \"linux\",\n            target_os = \"android\",\n            target_os = \"netbsd\",\n            target_os = \"openbsd\"\n        ))]\n        unsafe fn os_datasync(fd: c_int) -> c_int {\n            libc::fdatasync(fd)\n        }\n        #[cfg(not(any(\n            target_os = \"android\",\n            target_os = \"freebsd\",\n            target_os = \"ios\",\n            target_os = \"linux\",\n            target_os = \"macos\",\n            target_os = \"netbsd\",\n            target_os = \"openbsd\"\n        )))]\n        unsafe fn os_datasync(fd: c_int) -> c_int {\n            libc::fsync(fd)\n        }\n    }\n\n    pub fn truncate(&self, size: u64) -> io::Result<()> {\n        #[cfg(target_os = \"android\")]\n        return crate::sys::android::ftruncate64(self.0.raw(), size);\n\n        #[cfg(not(target_os = \"android\"))]\n        {\n            use crate::convert::TryInto;\n            let size: off64_t =\n                size.try_into().map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;\n            cvt_r(|| unsafe { ftruncate64(self.0.raw(), size) }).map(drop)\n        }\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.0.is_read_vectored()\n    }\n\n    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n        self.0.read_at(buf, offset)\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n        self.0.write_at(buf, offset)\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        Ok(())\n    }\n\n    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n        let (whence, pos) = match pos {\n            // Casting to `i64` is fine, too large values will end up as\n            // negative which will cause an error in `lseek64`.\n            SeekFrom::Start(off) => (libc::SEEK_SET, off as i64),\n            SeekFrom::End(off) => (libc::SEEK_END, off),\n            SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n        };\n        let n = cvt(unsafe { lseek64(self.0.raw(), pos, whence) })?;\n        Ok(n as u64)\n    }\n\n    pub fn duplicate(&self) -> io::Result<File> {\n        self.0.duplicate().map(File)\n    }\n\n    pub fn fd(&self) -> &FileDesc {\n        &self.0\n    }\n\n    pub fn into_fd(self) -> FileDesc {\n        self.0\n    }\n\n    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n        cvt_r(|| unsafe { libc::fchmod(self.0.raw(), perm.mode) })?;\n        Ok(())\n    }\n}\n\nimpl DirBuilder {\n    pub fn new() -> DirBuilder {\n        DirBuilder { mode: 0o777 }\n    }\n\n    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n        let p = cstr(p)?;\n        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;\n        Ok(())\n    }\n\n    pub fn set_mode(&mut self, mode: u32) {\n        self.mode = mode as mode_t;\n    }\n}\n\nfn cstr(path: &Path) -> io::Result<CString> {\n    Ok(CString::new(path.as_os_str().as_bytes())?)\n}\n\nimpl FromInner<c_int> for File {\n    fn from_inner(fd: c_int) -> File {\n        File(FileDesc::new(fd))\n    }\n}\n\nimpl fmt::Debug for File {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        #[cfg(target_os = \"linux\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let mut p = PathBuf::from(\"/proc/self/fd\");\n            p.push(&fd.to_string());\n            readlink(&p).ok()\n        }\n\n        #[cfg(target_os = \"macos\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            // FIXME: The use of PATH_MAX is generally not encouraged, but it\n            // is inevitable in this case because macOS defines `fcntl` with\n            // `F_GETPATH` in terms of `MAXPATHLEN`, and there are no\n            // alternatives. If a better method is invented, it should be used\n            // instead.\n            let mut buf = vec![0; libc::PATH_MAX as usize];\n            let n = unsafe { libc::fcntl(fd, libc::F_GETPATH, buf.as_ptr()) };\n            if n == -1 {\n                return None;\n            }\n            let l = buf.iter().position(|&c| c == 0).unwrap();\n            buf.truncate(l as usize);\n            buf.shrink_to_fit();\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(target_os = \"vxworks\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let mut buf = vec![0; libc::PATH_MAX as usize];\n            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n            if n == -1 {\n                return None;\n            }\n            let l = buf.iter().position(|&c| c == 0).unwrap();\n            buf.truncate(l as usize);\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n        fn get_path(_fd: c_int) -> Option<PathBuf> {\n            // FIXME(#24570): implement this for other Unix platforms\n            None\n        }\n\n        #[cfg(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\"))]\n        fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n            let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n            if mode == -1 {\n                return None;\n            }\n            match mode & libc::O_ACCMODE {\n                libc::O_RDONLY => Some((true, false)),\n                libc::O_RDWR => Some((true, true)),\n                libc::O_WRONLY => Some((false, true)),\n                _ => None,\n            }\n        }\n\n        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n        fn get_mode(_fd: c_int) -> Option<(bool, bool)> {\n            // FIXME(#24570): implement this for other Unix platforms\n            None\n        }\n\n        let fd = self.0.raw();\n        let mut b = f.debug_struct(\"File\");\n        b.field(\"fd\", &fd);\n        if let Some(path) = get_path(fd) {\n            b.field(\"path\", &path);\n        }\n        if let Some((read, write)) = get_mode(fd) {\n            b.field(\"read\", &read).field(\"write\", &write);\n        }\n        b.finish()\n    }\n}\n\npub fn readdir(p: &Path) -> io::Result<ReadDir> {\n    let root = p.to_path_buf();\n    let p = cstr(p)?;\n    unsafe {\n        let ptr = libc::opendir(p.as_ptr());\n        if ptr.is_null() {\n            Err(Error::last_os_error())\n        } else {\n            let inner = InnerReadDir { dirp: Dir(ptr), root };\n            Ok(ReadDir {\n                inner: Arc::new(inner),\n                #[cfg(not(any(\n                    target_os = \"solaris\",\n                    target_os = \"illumos\",\n                    target_os = \"fuchsia\",\n                    target_os = \"redox\",\n                )))]\n                end_of_stream: false,\n            })\n        }\n    }\n}\n\npub fn unlink(p: &Path) -> io::Result<()> {\n    let p = cstr(p)?;\n    cvt(unsafe { libc::unlink(p.as_ptr()) })?;\n    Ok(())\n}\n\npub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n    let old = cstr(old)?;\n    let new = cstr(new)?;\n    cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })?;\n    Ok(())\n}\n\npub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n    let p = cstr(p)?;\n    cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) })?;\n    Ok(())\n}\n\npub fn rmdir(p: &Path) -> io::Result<()> {\n    let p = cstr(p)?;\n    cvt(unsafe { libc::rmdir(p.as_ptr()) })?;\n    Ok(())\n}\n\npub fn readlink(p: &Path) -> io::Result<PathBuf> {\n    let c_path = cstr(p)?;\n    let p = c_path.as_ptr();\n\n    let mut buf = Vec::with_capacity(256);\n\n    loop {\n        let buf_read =\n            cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })? as usize;\n\n        unsafe {\n            buf.set_len(buf_read);\n        }\n\n        if buf_read != buf.capacity() {\n            buf.shrink_to_fit();\n\n            return Ok(PathBuf::from(OsString::from_vec(buf)));\n        }\n\n        // Trigger the internal buffer resizing logic of `Vec` by requiring\n        // more space than the current capacity. The length is guaranteed to be\n        // the same as the capacity due to the if statement above.\n        buf.reserve(1);\n    }\n}\n\npub fn symlink(original: &Path, link: &Path) -> io::Result<()> {\n    let original = cstr(original)?;\n    let link = cstr(link)?;\n    cvt(unsafe { libc::symlink(original.as_ptr(), link.as_ptr()) })?;\n    Ok(())\n}\n\npub fn link(original: &Path, link: &Path) -> io::Result<()> {\n    let original = cstr(original)?;\n    let link = cstr(link)?;\n    cfg_if::cfg_if! {\n        if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\"))] {\n            // VxWorks, Redox, and old versions of Android lack `linkat`, so use\n            // `link` instead. POSIX leaves it implementation-defined whether\n            // `link` follows symlinks, so rely on the `symlink_hard_link` test\n            // in library/std/src/fs/tests.rs to check the behavior.\n            cvt(unsafe { libc::link(original.as_ptr(), link.as_ptr()) })?;\n        } else {\n            // Use `linkat` with `AT_FDCWD` instead of `link` as `linkat` gives\n            // us a flag to specify how symlinks should be handled. Pass 0 as\n            // the flags argument, meaning don't follow symlinks.\n            cvt(unsafe { libc::linkat(libc::AT_FDCWD, original.as_ptr(), libc::AT_FDCWD, link.as_ptr(), 0) })?;\n        }\n    }\n    Ok(())\n}\n\npub fn stat(p: &Path) -> io::Result<FileAttr> {\n    let p = cstr(p)?;\n\n    cfg_has_statx! {\n        if let Some(ret) = unsafe { try_statx(\n            libc::AT_FDCWD,\n            p.as_ptr(),\n            libc::AT_STATX_SYNC_AS_STAT,\n            libc::STATX_ALL,\n        ) } {\n            return ret;\n        }\n    }\n\n    let mut stat: stat64 = unsafe { mem::zeroed() };\n    cvt(unsafe { stat64(p.as_ptr(), &mut stat) })?;\n    Ok(FileAttr::from_stat64(stat))\n}\n\npub fn lstat(p: &Path) -> io::Result<FileAttr> {\n    let p = cstr(p)?;\n\n    cfg_has_statx! {\n        if let Some(ret) = unsafe { try_statx(\n            libc::AT_FDCWD,\n            p.as_ptr(),\n            libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n            libc::STATX_ALL,\n        ) } {\n            return ret;\n        }\n    }\n\n    let mut stat: stat64 = unsafe { mem::zeroed() };\n    cvt(unsafe { lstat64(p.as_ptr(), &mut stat) })?;\n    Ok(FileAttr::from_stat64(stat))\n}\n\npub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n    let path = CString::new(p.as_os_str().as_bytes())?;\n    let buf;\n    unsafe {\n        let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n        if r.is_null() {\n            return Err(io::Error::last_os_error());\n        }\n        buf = CStr::from_ptr(r).to_bytes().to_vec();\n        libc::free(r as *mut _);\n    }\n    Ok(PathBuf::from(OsString::from_vec(buf)))\n}\n\nfn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n    use crate::fs::File;\n    use crate::sys_common::fs::NOT_FILE_ERROR;\n\n    let reader = File::open(from)?;\n    let metadata = reader.metadata()?;\n    if !metadata.is_file() {\n        return Err(NOT_FILE_ERROR);\n    }\n    Ok((reader, metadata))\n}\n\nfn open_to_and_set_permissions(\n    to: &Path,\n    reader_metadata: crate::fs::Metadata,\n) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n    use crate::fs::OpenOptions;\n    use crate::os::unix::fs::{OpenOptionsExt, PermissionsExt};\n\n    let perm = reader_metadata.permissions();\n    let writer = OpenOptions::new()\n        // create the file with the correct mode right away\n        .mode(perm.mode())\n        .write(true)\n        .create(true)\n        .truncate(true)\n        .open(to)?;\n    let writer_metadata = writer.metadata()?;\n    if writer_metadata.is_file() {\n        // Set the correct file permissions, in case the file already existed.\n        // Don't set the permissions on already existing non-files like\n        // pipes/FIFOs or device nodes.\n        writer.set_permissions(perm)?;\n    }\n    Ok((writer, writer_metadata))\n}\n\n#[cfg(not(any(\n    target_os = \"linux\",\n    target_os = \"android\",\n    target_os = \"macos\",\n    target_os = \"ios\"\n)))]\npub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n    let (mut reader, reader_metadata) = open_from(from)?;\n    let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n\n    io::copy(&mut reader, &mut writer)\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\npub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n    let (mut reader, reader_metadata) = open_from(from)?;\n    let max_len = u64::MAX;\n    let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n\n    use super::kernel_copy::{copy_regular_files, CopyResult};\n\n    match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {\n        CopyResult::Ended(bytes) => Ok(bytes),\n        CopyResult::Error(e, _) => Err(e),\n        CopyResult::Fallback(written) => match io::copy::generic_copy(&mut reader, &mut writer) {\n            Ok(bytes) => Ok(bytes + written),\n            Err(e) => Err(e),\n        },\n    }\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\npub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n    use crate::sync::atomic::{AtomicBool, Ordering};\n\n    const COPYFILE_ACL: u32 = 1 << 0;\n    const COPYFILE_STAT: u32 = 1 << 1;\n    const COPYFILE_XATTR: u32 = 1 << 2;\n    const COPYFILE_DATA: u32 = 1 << 3;\n\n    const COPYFILE_SECURITY: u32 = COPYFILE_STAT | COPYFILE_ACL;\n    const COPYFILE_METADATA: u32 = COPYFILE_SECURITY | COPYFILE_XATTR;\n    const COPYFILE_ALL: u32 = COPYFILE_METADATA | COPYFILE_DATA;\n\n    const COPYFILE_STATE_COPIED: u32 = 8;\n\n    #[allow(non_camel_case_types)]\n    type copyfile_state_t = *mut libc::c_void;\n    #[allow(non_camel_case_types)]\n    type copyfile_flags_t = u32;\n\n    extern \"C\" {\n        fn fcopyfile(\n            from: libc::c_int,\n            to: libc::c_int,\n            state: copyfile_state_t,\n            flags: copyfile_flags_t,\n        ) -> libc::c_int;\n        fn copyfile_state_alloc() -> copyfile_state_t;\n        fn copyfile_state_free(state: copyfile_state_t) -> libc::c_int;\n        fn copyfile_state_get(\n            state: copyfile_state_t,\n            flag: u32,\n            dst: *mut libc::c_void,\n        ) -> libc::c_int;\n    }\n\n    struct FreeOnDrop(copyfile_state_t);\n    impl Drop for FreeOnDrop {\n        fn drop(&mut self) {\n            // The code below ensures that `FreeOnDrop` is never a null pointer\n            unsafe {\n                // `copyfile_state_free` returns -1 if the `to` or `from` files\n                // cannot be closed. However, this is not considered this an\n                // error.\n                copyfile_state_free(self.0);\n            }\n        }\n    }\n\n    // MacOS prior to 10.12 don't support `fclonefileat`\n    // We store the availability in a global to avoid unnecessary syscalls\n    static HAS_FCLONEFILEAT: AtomicBool = AtomicBool::new(true);\n    syscall! {\n        fn fclonefileat(\n            srcfd: libc::c_int,\n            dst_dirfd: libc::c_int,\n            dst: *const libc::c_char,\n            flags: libc::c_int\n        ) -> libc::c_int\n    }\n\n    let (reader, reader_metadata) = open_from(from)?;\n\n    // Opportunistically attempt to create a copy-on-write clone of `from`\n    // using `fclonefileat`.\n    if HAS_FCLONEFILEAT.load(Ordering::Relaxed) {\n        let to = cstr(to)?;\n        let clonefile_result =\n            cvt(unsafe { fclonefileat(reader.as_raw_fd(), libc::AT_FDCWD, to.as_ptr(), 0) });\n        match clonefile_result {\n            Ok(_) => return Ok(reader_metadata.len()),\n            Err(err) => match err.raw_os_error() {\n                // `fclonefileat` will fail on non-APFS volumes, if the\n                // destination already exists, or if the source and destination\n                // are on different devices. In all these cases `fcopyfile`\n                // should succeed.\n                Some(libc::ENOTSUP) | Some(libc::EEXIST) | Some(libc::EXDEV) => (),\n                Some(libc::ENOSYS) => HAS_FCLONEFILEAT.store(false, Ordering::Relaxed),\n                _ => return Err(err),\n            },\n        }\n    }\n\n    // Fall back to using `fcopyfile` if `fclonefileat` does not succeed.\n    let (writer, writer_metadata) = open_to_and_set_permissions(to, reader_metadata)?;\n\n    // We ensure that `FreeOnDrop` never contains a null pointer so it is\n    // always safe to call `copyfile_state_free`\n    let state = unsafe {\n        let state = copyfile_state_alloc();\n        if state.is_null() {\n            return Err(crate::io::Error::last_os_error());\n        }\n        FreeOnDrop(state)\n    };\n\n    let flags = if writer_metadata.is_file() { COPYFILE_ALL } else { COPYFILE_DATA };\n\n    cvt(unsafe { fcopyfile(reader.as_raw_fd(), writer.as_raw_fd(), state.0, flags) })?;\n\n    let mut bytes_copied: libc::off_t = 0;\n    cvt(unsafe {\n        copyfile_state_get(\n            state.0,\n            COPYFILE_STATE_COPIED,\n            &mut bytes_copied as *mut libc::off_t as *mut libc::c_void,\n        )\n    })?;\n    Ok(bytes_copied as u64)\n}\n\n#[cfg(not(any(target_os = \"fuchsia\", target_os = \"vxworks\")))]\npub fn chroot(dir: &Path) -> io::Result<()> {\n    let dir = cstr(dir)?;\n    cvt(unsafe { libc::chroot(dir.as_ptr()) })?;\n    Ok(())\n}\n"],["2441","use crate::collections::HashMap;\nuse crate::error::Error as StdError;\nuse crate::ffi::{CStr, OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::marker::PhantomData;\nuse crate::os::unix::ffi::OsStringExt;\nuse crate::path::{self, PathBuf};\nuse crate::str;\nuse crate::sync::Mutex;\nuse crate::sys::hermit::abi;\nuse crate::sys::memchr;\nuse crate::sys::unsupported;\nuse crate::vec;\n\npub fn errno() -> i32 {\n    0\n}\n\npub fn error_string(_errno: i32) -> String {\n    \"operation successful\".to_string()\n}\n\npub fn getcwd() -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub fn chdir(_: &path::Path) -> io::Result<()> {\n    unsupported()\n}\n\npub struct SplitPaths<'a>(!, PhantomData<&'a ()>);\n\npub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {\n    panic!(\"unsupported\")\n}\n\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> {\n        self.0\n    }\n}\n\n#[derive(Debug)]\npub struct JoinPathsError;\n\npub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: Iterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n    Err(JoinPathsError)\n}\n\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"not supported on hermit yet\".fmt(f)\n    }\n}\n\nimpl StdError for JoinPathsError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"not supported on hermit yet\"\n    }\n}\n\npub fn current_exe() -> io::Result<PathBuf> {\n    unsupported()\n}\n\nstatic mut ENV: Option<Mutex<HashMap<OsString, OsString>>> = None;\n\npub fn init_environment(env: *const *const i8) {\n    unsafe {\n        ENV = Some(Mutex::new(HashMap::new()));\n\n        if env.is_null() {\n            return;\n        }\n\n        let mut guard = ENV.as_ref().unwrap().lock().unwrap();\n        let mut environ = env;\n        while !(*environ).is_null() {\n            if let Some((key, value)) = parse(CStr::from_ptr(*environ).to_bytes()) {\n                guard.insert(key, value);\n            }\n            environ = environ.add(1);\n        }\n    }\n\n    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n        // Strategy (copied from glibc): Variable name and value are separated\n        // by an ASCII equals sign '='. Since a variable name must not be\n        // empty, allow variable names starting with an equals sign. Skip all\n        // malformed lines.\n        if input.is_empty() {\n            return None;\n        }\n        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n        pos.map(|p| {\n            (\n                OsStringExt::from_vec(input[..p].to_vec()),\n                OsStringExt::from_vec(input[p + 1..].to_vec()),\n            )\n        })\n    }\n}\n\npub struct Env {\n    iter: vec::IntoIter<(OsString, OsString)>,\n}\n\nimpl !Send for Env {}\nimpl !Sync for Env {}\n\nimpl Iterator for Env {\n    type Item = (OsString, OsString);\n    fn next(&mut self) -> Option<(OsString, OsString)> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n/// Returns a vector of (variable, value) byte-vector pairs for all the\n/// environment variables of the current process.\npub fn env() -> Env {\n    unsafe {\n        let guard = ENV.as_ref().unwrap().lock().unwrap();\n        let mut result = Vec::new();\n\n        for (key, value) in guard.iter() {\n            result.push((key.clone(), value.clone()));\n        }\n\n        return Env { iter: result.into_iter() };\n    }\n}\n\npub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n    unsafe {\n        match ENV.as_ref().unwrap().lock().unwrap().get_mut(k) {\n            Some(value) => Ok(Some(value.clone())),\n            None => Ok(None),\n        }\n    }\n}\n\npub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n    unsafe {\n        let (k, v) = (k.to_owned(), v.to_owned());\n        ENV.as_ref().unwrap().lock().unwrap().insert(k, v);\n    }\n    Ok(())\n}\n\npub fn unsetenv(k: &OsStr) -> io::Result<()> {\n    unsafe {\n        ENV.as_ref().unwrap().lock().unwrap().remove(k);\n    }\n    Ok(())\n}\n\npub fn temp_dir() -> PathBuf {\n    panic!(\"no filesystem on hermit\")\n}\n\npub fn home_dir() -> Option<PathBuf> {\n    None\n}\n\npub fn exit(code: i32) -> ! {\n    unsafe {\n        abi::exit(code);\n    }\n}\n\npub fn getpid() -> u32 {\n    unsafe { abi::getpid() }\n}\n"],["2442","use crate::ffi::{CStr, CString, OsString};\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\nuse crate::io::{self, Error, ErrorKind};\nuse crate::io::{IoSlice, IoSliceMut, SeekFrom};\nuse crate::os::unix::ffi::OsStrExt;\nuse crate::path::{Path, PathBuf};\nuse crate::sys::cvt;\nuse crate::sys::hermit::abi;\nuse crate::sys::hermit::abi::{O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY};\nuse crate::sys::hermit::fd::FileDesc;\nuse crate::sys::time::SystemTime;\nuse crate::sys::unsupported;\n\npub use crate::sys_common::fs::{copy, try_exists};\n//pub use crate::sys_common::fs::remove_dir_all;\n\nfn cstr(path: &Path) -> io::Result<CString> {\n    Ok(CString::new(path.as_os_str().as_bytes())?)\n}\n\n#[derive(Debug)]\npub struct File(FileDesc);\n\npub struct FileAttr(!);\n\npub struct ReadDir(!);\n\npub struct DirEntry(!);\n\n#[derive(Clone, Debug)]\npub struct OpenOptions {\n    // generic\n    read: bool,\n    write: bool,\n    append: bool,\n    truncate: bool,\n    create: bool,\n    create_new: bool,\n    // system-specific\n    mode: i32,\n}\n\npub struct FilePermissions(!);\n\npub struct FileType(!);\n\n#[derive(Debug)]\npub struct DirBuilder {}\n\nimpl FileAttr {\n    pub fn size(&self) -> u64 {\n        self.0\n    }\n\n    pub fn perm(&self) -> FilePermissions {\n        self.0\n    }\n\n    pub fn file_type(&self) -> FileType {\n        self.0\n    }\n\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        self.0\n    }\n\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        self.0\n    }\n\n    pub fn created(&self) -> io::Result<SystemTime> {\n        self.0\n    }\n}\n\nimpl Clone for FileAttr {\n    fn clone(&self) -> FileAttr {\n        self.0\n    }\n}\n\nimpl FilePermissions {\n    pub fn readonly(&self) -> bool {\n        self.0\n    }\n\n    pub fn set_readonly(&mut self, _readonly: bool) {\n        self.0\n    }\n}\n\nimpl Clone for FilePermissions {\n    fn clone(&self) -> FilePermissions {\n        self.0\n    }\n}\n\nimpl PartialEq for FilePermissions {\n    fn eq(&self, _other: &FilePermissions) -> bool {\n        self.0\n    }\n}\n\nimpl Eq for FilePermissions {}\n\nimpl fmt::Debug for FilePermissions {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl FileType {\n    pub fn is_dir(&self) -> bool {\n        self.0\n    }\n\n    pub fn is_file(&self) -> bool {\n        self.0\n    }\n\n    pub fn is_symlink(&self) -> bool {\n        self.0\n    }\n}\n\nimpl Clone for FileType {\n    fn clone(&self) -> FileType {\n        self.0\n    }\n}\n\nimpl Copy for FileType {}\n\nimpl PartialEq for FileType {\n    fn eq(&self, _other: &FileType) -> bool {\n        self.0\n    }\n}\n\nimpl Eq for FileType {}\n\nimpl Hash for FileType {\n    fn hash<H: Hasher>(&self, _h: &mut H) {\n        self.0\n    }\n}\n\nimpl fmt::Debug for FileType {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl fmt::Debug for ReadDir {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl Iterator for ReadDir {\n    type Item = io::Result<DirEntry>;\n\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        self.0\n    }\n}\n\nimpl DirEntry {\n    pub fn path(&self) -> PathBuf {\n        self.0\n    }\n\n    pub fn file_name(&self) -> OsString {\n        self.0\n    }\n\n    pub fn metadata(&self) -> io::Result<FileAttr> {\n        self.0\n    }\n\n    pub fn file_type(&self) -> io::Result<FileType> {\n        self.0\n    }\n}\n\nimpl OpenOptions {\n    pub fn new() -> OpenOptions {\n        OpenOptions {\n            // generic\n            read: false,\n            write: false,\n            append: false,\n            truncate: false,\n            create: false,\n            create_new: false,\n            // system-specific\n            mode: 0x777,\n        }\n    }\n\n    pub fn read(&mut self, read: bool) {\n        self.read = read;\n    }\n    pub fn write(&mut self, write: bool) {\n        self.write = write;\n    }\n    pub fn append(&mut self, append: bool) {\n        self.append = append;\n    }\n    pub fn truncate(&mut self, truncate: bool) {\n        self.truncate = truncate;\n    }\n    pub fn create(&mut self, create: bool) {\n        self.create = create;\n    }\n    pub fn create_new(&mut self, create_new: bool) {\n        self.create_new = create_new;\n    }\n\n    fn get_access_mode(&self) -> io::Result<i32> {\n        match (self.read, self.write, self.append) {\n            (true, false, false) => Ok(O_RDONLY),\n            (false, true, false) => Ok(O_WRONLY),\n            (true, true, false) => Ok(O_RDWR),\n            (false, _, true) => Ok(O_WRONLY | O_APPEND),\n            (true, _, true) => Ok(O_RDWR | O_APPEND),\n            (false, false, false) => {\n                Err(io::Error::new_const(ErrorKind::InvalidInput, &\"invalid access mode\"))\n            }\n        }\n    }\n\n    fn get_creation_mode(&self) -> io::Result<i32> {\n        match (self.write, self.append) {\n            (true, false) => {}\n            (false, false) => {\n                if self.truncate || self.create || self.create_new {\n                    return Err(io::Error::new_const(\n                        ErrorKind::InvalidInput,\n                        &\"invalid creation mode\",\n                    ));\n                }\n            }\n            (_, true) => {\n                if self.truncate && !self.create_new {\n                    return Err(io::Error::new_const(\n                        ErrorKind::InvalidInput,\n                        &\"invalid creation mode\",\n                    ));\n                }\n            }\n        }\n\n        Ok(match (self.create, self.truncate, self.create_new) {\n            (false, false, false) => 0,\n            (true, false, false) => O_CREAT,\n            (false, true, false) => O_TRUNC,\n            (true, true, false) => O_CREAT | O_TRUNC,\n            (_, _, true) => O_CREAT | O_EXCL,\n        })\n    }\n}\n\nimpl File {\n    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n        let path = cstr(path)?;\n        File::open_c(&path, opts)\n    }\n\n    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n        let mut flags = opts.get_access_mode()?;\n        flags = flags | opts.get_creation_mode()?;\n\n        let mode;\n        if flags & O_CREAT == O_CREAT {\n            mode = opts.mode;\n        } else {\n            mode = 0;\n        }\n\n        let fd = unsafe { cvt(abi::open(path.as_ptr(), flags, mode))? };\n        Ok(File(FileDesc::new(fd as i32)))\n    }\n\n    pub fn file_attr(&self) -> io::Result<FileAttr> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn fsync(&self) -> io::Result<()> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn datasync(&self) -> io::Result<()> {\n        self.fsync()\n    }\n\n    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        crate::io::default_read_vectored(|buf| self.read(buf), bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        false\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        crate::io::default_write_vectored(|buf| self.write(buf), bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        false\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        Ok(())\n    }\n\n    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn duplicate(&self) -> io::Result<File> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n        Err(Error::from_raw_os_error(22))\n    }\n}\n\nimpl DirBuilder {\n    pub fn new() -> DirBuilder {\n        DirBuilder {}\n    }\n\n    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n        unsupported()\n    }\n}\n\npub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n    unsupported()\n}\n\npub fn unlink(path: &Path) -> io::Result<()> {\n    let name = cstr(path)?;\n    let _ = unsafe { cvt(abi::unlink(name.as_ptr()))? };\n    Ok(())\n}\n\npub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n    match perm.0 {}\n}\n\npub fn rmdir(_p: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n    //unsupported()\n    Ok(())\n}\n\npub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn stat(_p: &Path) -> io::Result<FileAttr> {\n    unsupported()\n}\n\npub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n    unsupported()\n}\n\npub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n    unsupported()\n}\n"],["2443","#![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n\nuse crate::io::{self, Read};\nuse crate::mem;\nuse crate::sys::cvt;\nuse crate::sys::hermit::abi;\nuse crate::sys::unsupported;\nuse crate::sys_common::AsInner;\n\n#[derive(Debug)]\npub struct FileDesc {\n    fd: i32,\n}\n\nimpl FileDesc {\n    pub fn new(fd: i32) -> FileDesc {\n        FileDesc { fd }\n    }\n\n    pub fn raw(&self) -> i32 {\n        self.fd\n    }\n\n    /// Extracts the actual file descriptor without closing it.\n    pub fn into_raw(self) -> i32 {\n        let fd = self.fd;\n        mem::forget(self);\n        fd\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        let result = unsafe { abi::read(self.fd, buf.as_mut_ptr(), buf.len()) };\n        cvt(result as i32)\n    }\n\n    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        let mut me = self;\n        (&mut me).read_to_end(buf)\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        let result = unsafe { abi::write(self.fd, buf.as_ptr(), buf.len()) };\n        cvt(result as i32)\n    }\n\n    pub fn duplicate(&self) -> io::Result<FileDesc> {\n        self.duplicate_path(&[])\n    }\n    pub fn duplicate_path(&self, _path: &[u8]) -> io::Result<FileDesc> {\n        unsupported()\n    }\n\n    pub fn nonblocking(&self) -> io::Result<bool> {\n        Ok(false)\n    }\n\n    pub fn set_cloexec(&self) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn set_nonblocking(&self, _nonblocking: bool) -> io::Result<()> {\n        unsupported()\n    }\n}\n\nimpl<'a> Read for &'a FileDesc {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n}\n\nimpl AsInner<i32> for FileDesc {\n    fn as_inner(&self) -> &i32 {\n        &self.fd\n    }\n}\n\nimpl Drop for FileDesc {\n    fn drop(&mut self) {\n        // Note that errors are ignored when closing a file descriptor. The\n        // reason for this is that if an error occurs we don't actually know if\n        // the file descriptor was closed or not, and if we retried (for\n        // something like EINTR), we might close another valid file descriptor\n        // (opened after we closed ours.\n        let _ = unsafe { abi::close(self.fd) };\n    }\n}\n"],["2444","use crate::alloc::{GlobalAlloc, Layout, System};\nuse crate::ptr;\nuse crate::sys::hermit::abi;\n\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        abi::malloc(layout.size(), layout.align())\n    }\n\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        let addr = abi::malloc(layout.size(), layout.align());\n\n        if !addr.is_null() {\n            ptr::write_bytes(addr, 0x00, layout.size());\n        }\n\n        addr\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n        abi::free(ptr, layout.size(), layout.align())\n    }\n\n    #[inline]\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        abi::realloc(ptr, layout.size(), layout.align(), new_size)\n    }\n}\n"],["2445","use crate::convert::TryFrom;\nuse crate::fmt;\nuse crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\nuse crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\nuse crate::str;\nuse crate::sync::Arc;\nuse crate::sys::hermit::abi;\nuse crate::sys::hermit::abi::IpAddress::{Ipv4, Ipv6};\nuse crate::sys::unsupported;\nuse crate::sys_common::AsInner;\nuse crate::time::Duration;\n\n/// Checks whether the HermitCore's socket interface has been started already, and\n/// if not, starts it.\npub fn init() -> io::Result<()> {\n    if abi::network_init() < 0 {\n        return Err(io::Error::new_const(\n            ErrorKind::Other,\n            &\"Unable to initialize network interface\",\n        ));\n    }\n\n    Ok(())\n}\n\n#[derive(Debug, Clone)]\npub struct Socket(abi::Handle);\n\nimpl AsInner<abi::Handle> for Socket {\n    fn as_inner(&self) -> &abi::Handle {\n        &self.0\n    }\n}\n\nimpl Drop for Socket {\n    fn drop(&mut self) {\n        let _ = abi::tcpstream::close(self.0);\n    }\n}\n\n// Arc is used to count the number of used sockets.\n// Only if all sockets are released, the drop\n// method will close the socket.\n#[derive(Clone)]\npub struct TcpStream(Arc<Socket>);\n\nimpl TcpStream {\n    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n        let addr = addr?;\n\n        match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n            _ => Err(io::Error::new_const(\n                ErrorKind::Other,\n                &\"Unable to initiate a connection on a socket\",\n            )),\n        }\n    }\n\n    pub fn connect_timeout(saddr: &SocketAddr, duration: Duration) -> io::Result<TcpStream> {\n        match abi::tcpstream::connect(\n            saddr.ip().to_string().as_bytes(),\n            saddr.port(),\n            Some(duration.as_millis() as u64),\n        ) {\n            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n            _ => Err(io::Error::new_const(\n                ErrorKind::Other,\n                &\"Unable to initiate a connection on a socket\",\n            )),\n        }\n    }\n\n    pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n        abi::tcpstream::set_read_timeout(*self.0.as_inner(), duration.map(|d| d.as_millis() as u64))\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"Unable to set timeout value\"))\n    }\n\n    pub fn set_write_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n        abi::tcpstream::set_write_timeout(\n            *self.0.as_inner(),\n            duration.map(|d| d.as_millis() as u64),\n        )\n        .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"Unable to set timeout value\"))\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner()).map_err(|_| {\n            io::Error::new_const(ErrorKind::Other, &\"Unable to determine timeout value\")\n        })?;\n\n        Ok(duration.map(|d| Duration::from_millis(d)))\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner()).map_err(|_| {\n            io::Error::new_const(ErrorKind::Other, &\"Unable to determine timeout value\")\n        })?;\n\n        Ok(duration.map(|d| Duration::from_millis(d)))\n    }\n\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n        abi::tcpstream::peek(*self.0.as_inner(), buf)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"set_nodelay failed\"))\n    }\n\n    pub fn read(&self, buffer: &mut [u8]) -> io::Result<usize> {\n        self.read_vectored(&mut [IoSliceMut::new(buffer)])\n    }\n\n    pub fn read_vectored(&self, ioslice: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut size: usize = 0;\n\n        for i in ioslice.iter_mut() {\n            let ret = abi::tcpstream::read(*self.0.as_inner(), &mut i[0..])\n                .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"Unable to read on socket\"))?;\n\n            if ret != 0 {\n                size += ret;\n            }\n        }\n\n        Ok(size)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn write(&self, buffer: &[u8]) -> io::Result<usize> {\n        self.write_vectored(&[IoSlice::new(buffer)])\n    }\n\n    pub fn write_vectored(&self, ioslice: &[IoSlice<'_>]) -> io::Result<usize> {\n        let mut size: usize = 0;\n\n        for i in ioslice.iter() {\n            size += abi::tcpstream::write(*self.0.as_inner(), i).map_err(|_| {\n                io::Error::new_const(ErrorKind::Other, &\"Unable to write on socket\")\n            })?;\n        }\n\n        Ok(size)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        let (ipaddr, port) = abi::tcpstream::peer_addr(*self.0.as_inner())\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"peer_addr failed\"))?;\n\n        let saddr = match ipaddr {\n            Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n            _ => {\n                return Err(io::Error::new_const(ErrorKind::Other, &\"peer_addr failed\"));\n            }\n        };\n\n        Ok(saddr)\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        unsupported()\n    }\n\n    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to shutdown socket\"))\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpStream> {\n        Ok(self.clone())\n    }\n\n    pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n        abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"set_nodelay failed\"))\n    }\n\n    pub fn nodelay(&self) -> io::Result<bool> {\n        abi::tcpstream::nodelay(*self.0.as_inner())\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"nodelay failed\"))\n    }\n\n    pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n        abi::tcpstream::set_tll(*self.0.as_inner(), tll)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to set TTL\"))\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        abi::tcpstream::get_tll(*self.0.as_inner())\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to get TTL\"))\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        unsupported()\n    }\n\n    pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n        abi::tcpstream::set_nonblocking(*self.0.as_inner(), mode)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to set blocking mode\"))\n    }\n}\n\nimpl fmt::Debug for TcpStream {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        Ok(())\n    }\n}\n\n#[derive(Clone)]\npub struct TcpListener(SocketAddr);\n\nimpl TcpListener {\n    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n        let addr = addr?;\n\n        Ok(TcpListener(*addr))\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        Ok(self.0)\n    }\n\n    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n        let (handle, ipaddr, port) = abi::tcplistener::accept(self.0.port())\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"accept failed\"))?;\n        let saddr = match ipaddr {\n            Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n            _ => {\n                return Err(io::Error::new_const(ErrorKind::Other, &\"accept failed\"));\n            }\n        };\n\n        Ok((TcpStream(Arc::new(Socket(handle))), saddr))\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpListener> {\n        Ok(self.clone())\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        unsupported()\n    }\n\n    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn only_v6(&self) -> io::Result<bool> {\n        unsupported()\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        unsupported()\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n}\n\nimpl fmt::Debug for TcpListener {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        Ok(())\n    }\n}\n\npub struct UdpSocket(abi::Handle);\n\nimpl UdpSocket {\n    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n        unsupported()\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        unsupported()\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        unsupported()\n    }\n\n    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        unsupported()\n    }\n\n    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        unsupported()\n    }\n\n    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n        unsupported()\n    }\n\n    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n        unsupported()\n    }\n\n    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        unsupported()\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        unsupported()\n    }\n\n    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn broadcast(&self) -> io::Result<bool> {\n        unsupported()\n    }\n\n    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n        unsupported()\n    }\n\n    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n        unsupported()\n    }\n\n    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n        unsupported()\n    }\n\n    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        unsupported()\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        unsupported()\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n        unsupported()\n    }\n\n    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n        unsupported()\n    }\n\n    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n        unsupported()\n    }\n\n    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n        unsupported()\n    }\n}\n\nimpl fmt::Debug for UdpSocket {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        Ok(())\n    }\n}\n\npub struct LookupHost(!);\n\nimpl LookupHost {\n    pub fn port(&self) -> u16 {\n        self.0\n    }\n}\n\nimpl Iterator for LookupHost {\n    type Item = SocketAddr;\n    fn next(&mut self) -> Option<SocketAddr> {\n        self.0\n    }\n}\n\nimpl TryFrom<&str> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from(_v: &str) -> io::Result<LookupHost> {\n        unsupported()\n    }\n}\n\nimpl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n        unsupported()\n    }\n}\n\n#[allow(nonstandard_style)]\npub mod netc {\n    pub const AF_INET: u8 = 0;\n    pub const AF_INET6: u8 = 1;\n    pub type sa_family_t = u8;\n\n    #[derive(Copy, Clone)]\n    pub struct in_addr {\n        pub s_addr: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in {\n        pub sin_family: sa_family_t,\n        pub sin_port: u16,\n        pub sin_addr: in_addr,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct in6_addr {\n        pub s6_addr: [u8; 16],\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in6 {\n        pub sin6_family: sa_family_t,\n        pub sin6_port: u16,\n        pub sin6_addr: in6_addr,\n        pub sin6_flowinfo: u32,\n        pub sin6_scope_id: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr {}\n\n    pub type socklen_t = usize;\n}\n"],["2446","//! System bindings for HermitCore\n//!\n//! This module contains the facade (aka platform-specific) implementations of\n//! OS level functionality for HermitCore.\n//!\n//! This is all super highly experimental and not actually intended for\n//! wide/production use yet, it's still all in the experimental category. This\n//! will likely change over time.\n//!\n//! Currently all functions here are basically stubs that immediately return\n//! errors. The hope is that with a portability lint we can turn actually just\n//! remove all this and just omit parts of the standard library if we're\n//! compiling for wasm. That way it's a compile time error for something that's\n//! guaranteed to be a runtime error!\n\n#![allow(unsafe_op_in_unsafe_fn)]\n\nuse crate::intrinsics;\nuse crate::os::raw::c_char;\n\npub mod alloc;\npub mod args;\n#[path = \"../unix/cmath.rs\"]\npub mod cmath;\npub mod condvar;\npub mod env;\npub mod fd;\npub mod fs;\n#[path = \"../unsupported/io.rs\"]\npub mod io;\npub mod memchr;\npub mod mutex;\npub mod net;\npub mod os;\n#[path = \"../unix/path.rs\"]\npub mod path;\n#[path = \"../unsupported/pipe.rs\"]\npub mod pipe;\n#[path = \"../unsupported/process.rs\"]\npub mod process;\npub mod rwlock;\npub mod stdio;\npub mod thread;\npub mod thread_local_dtor;\n#[path = \"../unsupported/thread_local_key.rs\"]\npub mod thread_local_key;\npub mod time;\n\nuse crate::io::ErrorKind;\npub use crate::sys_common::os_str_bytes as os_str;\n\n#[allow(unused_extern_crates)]\npub extern crate hermit_abi as abi;\n\npub fn unsupported<T>() -> crate::io::Result<T> {\n    Err(unsupported_err())\n}\n\npub fn unsupported_err() -> crate::io::Error {\n    crate::io::Error::new_const(\n        crate::io::ErrorKind::Unsupported,\n        &\"operation not supported on HermitCore yet\",\n    )\n}\n\npub unsafe fn strlen(start: *const c_char) -> usize {\n    let mut str = start;\n\n    while *str != 0 {\n        str = str.offset(1);\n    }\n\n    (str as usize) - (start as usize)\n}\n\n#[no_mangle]\npub extern \"C\" fn floor(x: f64) -> f64 {\n    unsafe { intrinsics::floorf64(x) }\n}\n\npub fn abort_internal() -> ! {\n    unsafe {\n        abi::abort();\n    }\n}\n\n// FIXME: just a workaround to test the system\npub fn hashmap_random_keys() -> (u64, u64) {\n    (1, 2)\n}\n\n// This function is needed by the panic runtime. The symbol is named in\n// pre-link args for the target specification, so keep that in sync.\n#[cfg(not(test))]\n#[no_mangle]\n// NB. used by both libunwind and libpanic_abort\npub extern \"C\" fn __rust_abort() {\n    abort_internal();\n}\n\n// SAFETY: must be called only once during runtime initialization.\n// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    let _ = net::init();\n    args::init(argc, argv);\n}\n\n// SAFETY: must be called only once during runtime cleanup.\n// NOTE: this is not guaranteed to run, for example when the program aborts.\npub unsafe fn cleanup() {\n    args::cleanup();\n}\n\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn runtime_entry(\n    argc: i32,\n    argv: *const *const c_char,\n    env: *const *const c_char,\n) -> ! {\n    use crate::sys::hermit::thread_local_dtor::run_dtors;\n    extern \"C\" {\n        fn main(argc: isize, argv: *const *const c_char) -> i32;\n    }\n\n    // initialize environment\n    os::init_environment(env as *const *const i8);\n\n    let result = main(argc as isize, argv);\n\n    run_dtors();\n    abi::exit(result);\n}\n\npub fn decode_error_kind(errno: i32) -> ErrorKind {\n    match errno {\n        x if x == 13 as i32 => ErrorKind::PermissionDenied,\n        x if x == 98 as i32 => ErrorKind::AddrInUse,\n        x if x == 99 as i32 => ErrorKind::AddrNotAvailable,\n        x if x == 11 as i32 => ErrorKind::WouldBlock,\n        x if x == 103 as i32 => ErrorKind::ConnectionAborted,\n        x if x == 111 as i32 => ErrorKind::ConnectionRefused,\n        x if x == 104 as i32 => ErrorKind::ConnectionReset,\n        x if x == 17 as i32 => ErrorKind::AlreadyExists,\n        x if x == 4 as i32 => ErrorKind::Interrupted,\n        x if x == 22 as i32 => ErrorKind::InvalidInput,\n        x if x == 2 as i32 => ErrorKind::NotFound,\n        x if x == 107 as i32 => ErrorKind::NotConnected,\n        x if x == 1 as i32 => ErrorKind::PermissionDenied,\n        x if x == 32 as i32 => ErrorKind::BrokenPipe,\n        x if x == 110 as i32 => ErrorKind::TimedOut,\n        _ => ErrorKind::Other,\n    }\n}\n\npub fn cvt(result: i32) -> crate::io::Result<usize> {\n    if result < 0 { Err(crate::io::Error::from_raw_os_error(-result)) } else { Ok(result as usize) }\n}\n"],["2447","pub mod os {\n    pub const FAMILY: &str = \"\";\n    pub const OS: &str = \"hermit\";\n    pub const DLL_PREFIX: &str = \"\";\n    pub const DLL_SUFFIX: &str = \"\";\n    pub const DLL_EXTENSION: &str = \"\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n"],["2448","#![allow(dead_code)]\n\nuse crate::cmp::Ordering;\nuse crate::convert::TryInto;\nuse crate::sys::hermit::abi;\nuse crate::sys::hermit::abi::timespec;\nuse crate::sys::hermit::abi::{CLOCK_MONOTONIC, CLOCK_REALTIME, NSEC_PER_SEC};\nuse crate::time::Duration;\nuse core::hash::{Hash, Hasher};\n\n#[derive(Copy, Clone, Debug)]\nstruct Timespec {\n    t: timespec,\n}\n\nimpl Timespec {\n    const fn zero() -> Timespec {\n        Timespec { t: timespec { tv_sec: 0, tv_nsec: 0 } }\n    }\n\n    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n        if self >= other {\n            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n                Duration::new(\n                    (self.t.tv_sec - other.t.tv_sec) as u64,\n                    (self.t.tv_nsec - other.t.tv_nsec) as u32,\n                )\n            } else {\n                Duration::new(\n                    (self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n                )\n            })\n        } else {\n            match other.sub_timespec(self) {\n                Ok(d) => Err(d),\n                Err(d) => Ok(d),\n            }\n        }\n    }\n\n    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n        let mut secs = other\n            .as_secs()\n            .try_into() // <- target type would be `libc::time_t`\n            .ok()\n            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n\n        // Nano calculations can't overflow because nanos are <1B which fit\n        // in a u32.\n        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n        if nsec >= NSEC_PER_SEC as u32 {\n            nsec -= NSEC_PER_SEC as u32;\n            secs = secs.checked_add(1)?;\n        }\n        Some(Timespec { t: timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n    }\n\n    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n        let mut secs = other\n            .as_secs()\n            .try_into() // <- target type would be `libc::time_t`\n            .ok()\n            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n\n        // Similar to above, nanos can't overflow.\n        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n        if nsec < 0 {\n            nsec += NSEC_PER_SEC as i32;\n            secs = secs.checked_sub(1)?;\n        }\n        Some(Timespec { t: timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n    }\n}\n\nimpl PartialEq for Timespec {\n    fn eq(&self, other: &Timespec) -> bool {\n        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n    }\n}\n\nimpl Eq for Timespec {}\n\nimpl PartialOrd for Timespec {\n    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Timespec {\n    fn cmp(&self, other: &Timespec) -> Ordering {\n        let me = (self.t.tv_sec, self.t.tv_nsec);\n        let other = (other.t.tv_sec, other.t.tv_nsec);\n        me.cmp(&other)\n    }\n}\n\nimpl Hash for Timespec {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.t.tv_sec.hash(state);\n        self.t.tv_nsec.hash(state);\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\npub struct Instant {\n    t: Timespec,\n}\n\nimpl Instant {\n    pub fn now() -> Instant {\n        let mut time: Timespec = Timespec::zero();\n        let _ = unsafe { abi::clock_gettime(CLOCK_MONOTONIC, &mut time.t as *mut timespec) };\n\n        Instant { t: time }\n    }\n\n    pub const fn zero() -> Instant {\n        Instant { t: Timespec::zero() }\n    }\n\n    pub fn actually_monotonic() -> bool {\n        true\n    }\n\n    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n        self.t.sub_timespec(&other.t).ok()\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant { t: self.t.checked_add_duration(other)? })\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant { t: self.t.checked_sub_duration(other)? })\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub struct SystemTime {\n    t: Timespec,\n}\n\npub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n\nimpl SystemTime {\n    pub fn now() -> SystemTime {\n        let mut time: Timespec = Timespec::zero();\n        let _ = unsafe { abi::clock_gettime(CLOCK_REALTIME, &mut time.t as *mut timespec) };\n\n        SystemTime { t: time }\n    }\n\n    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n        self.t.sub_timespec(&other.t)\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime { t: self.t.checked_add_duration(other)? })\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n    }\n}\n"],["2449","use crate::ffi::OsString;\nuse crate::fmt;\nuse crate::vec;\n\n/// One-time global initialization.\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    imp::init(argc, argv)\n}\n\n/// One-time global cleanup.\npub unsafe fn cleanup() {\n    imp::cleanup()\n}\n\n/// Returns the command line arguments\npub fn args() -> Args {\n    imp::args()\n}\n\npub struct Args {\n    iter: vec::IntoIter<OsString>,\n}\n\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.iter.as_slice().fmt(f)\n    }\n}\n\nimpl !Send for Args {}\nimpl !Sync for Args {}\n\nimpl Iterator for Args {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}\n\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<OsString> {\n        self.iter.next_back()\n    }\n}\n\nmod imp {\n    use super::Args;\n    use crate::ffi::{CStr, OsString};\n    use crate::os::unix::ffi::OsStringExt;\n    use crate::ptr;\n\n    use crate::sys_common::mutex::StaticMutex;\n\n    static mut ARGC: isize = 0;\n    static mut ARGV: *const *const u8 = ptr::null();\n    static LOCK: StaticMutex = StaticMutex::new();\n\n    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n        let _guard = LOCK.lock();\n        ARGC = argc;\n        ARGV = argv;\n    }\n\n    pub unsafe fn cleanup() {\n        let _guard = LOCK.lock();\n        ARGC = 0;\n        ARGV = ptr::null();\n    }\n\n    pub fn args() -> Args {\n        Args { iter: clone().into_iter() }\n    }\n\n    fn clone() -> Vec<OsString> {\n        unsafe {\n            let _guard = LOCK.lock();\n            (0..ARGC)\n                .map(|i| {\n                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const i8);\n                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n                })\n                .collect()\n        }\n    }\n}\n"],["2450","use crate::io;\nuse crate::io::{IoSlice, IoSliceMut};\nuse crate::sys::hermit::abi;\n\npub struct Stdin;\npub struct Stdout;\npub struct Stderr;\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, data: &mut [u8]) -> io::Result<usize> {\n        self.read_vectored(&mut [IoSliceMut::new(data)])\n    }\n\n    fn read_vectored(&mut self, _data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        Ok(0)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        let len;\n\n        unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n\n        if len < 0 {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stdout is not able to print\"))\n        } else {\n            Ok(len as usize)\n        }\n    }\n\n    fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n        let len;\n\n        unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n\n        if len < 0 {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stdout is not able to print\"))\n        } else {\n            Ok(len as usize)\n        }\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        let len;\n\n        unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n\n        if len < 0 {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stderr is not able to print\"))\n        } else {\n            Ok(len as usize)\n        }\n    }\n\n    fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n        let len;\n\n        unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n\n        if len < 0 {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stderr is not able to print\"))\n        } else {\n            Ok(len as usize)\n        }\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\npub const STDIN_BUF_SIZE: usize = 0;\n\npub fn is_ebadf(_err: &io::Error) -> bool {\n    true\n}\n\npub fn panic_output() -> Option<impl io::Write> {\n    Some(Stderr::new())\n}\n"],["2451","#![cfg(target_thread_local)]\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n\n// Simplify dtor registration by using a list of destructors.\n// The this solution works like the implementation of macOS and\n// doesn't additional OS support\n\nuse crate::cell::Cell;\nuse crate::ptr;\n\n#[thread_local]\nstatic DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n\ntype List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n\npub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    if DTORS.get().is_null() {\n        let v: Box<List> = box Vec::new();\n        DTORS.set(Box::into_raw(v));\n    }\n\n    let list: &mut List = &mut *DTORS.get();\n    list.push((t, dtor));\n}\n\n// every thread call this function to run through all possible destructors\npub unsafe fn run_dtors() {\n    let mut ptr = DTORS.replace(ptr::null_mut());\n    while !ptr.is_null() {\n        let list = Box::from_raw(ptr);\n        for (ptr, dtor) in list.into_iter() {\n            dtor(ptr);\n        }\n        ptr = DTORS.replace(ptr::null_mut());\n    }\n}\n"],["2452","use crate::cell::UnsafeCell;\nuse crate::sys::condvar::Condvar;\nuse crate::sys::mutex::Mutex;\n\npub struct RWLock {\n    lock: Mutex,\n    cond: Condvar,\n    state: UnsafeCell<State>,\n}\n\npub type MovableRWLock = Box<RWLock>;\n\nenum State {\n    Unlocked,\n    Reading(usize),\n    Writing,\n}\n\nunsafe impl Send for RWLock {}\nunsafe impl Sync for RWLock {}\n\n// This rwlock implementation is a relatively simple implementation which has a\n// condition variable for readers/writers as well as a mutex protecting the\n// internal state of the lock. A current downside of the implementation is that\n// unlocking the lock will notify *all* waiters rather than just readers or just\n// writers. This can cause lots of \"thundering stampede\" problems. While\n// hopefully correct this implementation is very likely to want to be changed in\n// the future.\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock { lock: Mutex::new(), cond: Condvar::new(), state: UnsafeCell::new(State::Unlocked) }\n    }\n\n    #[inline]\n    pub unsafe fn read(&self) {\n        self.lock.lock();\n        while !(*self.state.get()).inc_readers() {\n            self.cond.wait(&self.lock);\n        }\n        self.lock.unlock();\n    }\n\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        self.lock.lock();\n        let ok = (*self.state.get()).inc_readers();\n        self.lock.unlock();\n        return ok;\n    }\n\n    #[inline]\n    pub unsafe fn write(&self) {\n        self.lock.lock();\n        while !(*self.state.get()).inc_writers() {\n            self.cond.wait(&self.lock);\n        }\n        self.lock.unlock();\n    }\n\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        self.lock.lock();\n        let ok = (*self.state.get()).inc_writers();\n        self.lock.unlock();\n        return ok;\n    }\n\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        self.lock.lock();\n        let notify = (*self.state.get()).dec_readers();\n        self.lock.unlock();\n        if notify {\n            // FIXME: should only wake up one of these some of the time\n            self.cond.notify_all();\n        }\n    }\n\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        self.lock.lock();\n        (*self.state.get()).dec_writers();\n        self.lock.unlock();\n        // FIXME: should only wake up one of these some of the time\n        self.cond.notify_all();\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        self.lock.destroy();\n        self.cond.destroy();\n    }\n}\n\nimpl State {\n    fn inc_readers(&mut self) -> bool {\n        match *self {\n            State::Unlocked => {\n                *self = State::Reading(1);\n                true\n            }\n            State::Reading(ref mut cnt) => {\n                *cnt += 1;\n                true\n            }\n            State::Writing => false,\n        }\n    }\n\n    fn inc_writers(&mut self) -> bool {\n        match *self {\n            State::Unlocked => {\n                *self = State::Writing;\n                true\n            }\n            State::Reading(_) | State::Writing => false,\n        }\n    }\n\n    fn dec_readers(&mut self) -> bool {\n        let zero = match *self {\n            State::Reading(ref mut cnt) => {\n                *cnt -= 1;\n                *cnt == 0\n            }\n            State::Unlocked | State::Writing => invalid(),\n        };\n        if zero {\n            *self = State::Unlocked;\n        }\n        zero\n    }\n\n    fn dec_writers(&mut self) {\n        match *self {\n            State::Writing => {}\n            State::Unlocked | State::Reading(_) => invalid(),\n        }\n        *self = State::Unlocked;\n    }\n}\n\nfn invalid() -> ! {\n    panic!(\"inconsistent rwlock\");\n}\n"],["2453","use crate::ffi::c_void;\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nuse crate::sys::hermit::abi;\nuse crate::sys::mutex::Mutex;\nuse crate::time::Duration;\n\n// The implementation is inspired by Andrew D. Birrell's paper\n// \"Implementing Condition Variables with Semaphores\"\n\npub struct Condvar {\n    counter: AtomicUsize,\n    sem1: *const c_void,\n    sem2: *const c_void,\n}\n\npub type MovableCondvar = Box<Condvar>;\n\nunsafe impl Send for Condvar {}\nunsafe impl Sync for Condvar {}\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        Condvar { counter: AtomicUsize::new(0), sem1: ptr::null(), sem2: ptr::null() }\n    }\n\n    pub unsafe fn init(&mut self) {\n        let _ = abi::sem_init(&mut self.sem1 as *mut *const c_void, 0);\n        let _ = abi::sem_init(&mut self.sem2 as *mut *const c_void, 0);\n    }\n\n    pub unsafe fn notify_one(&self) {\n        if self.counter.load(SeqCst) > 0 {\n            self.counter.fetch_sub(1, SeqCst);\n            abi::sem_post(self.sem1);\n            abi::sem_timedwait(self.sem2, 0);\n        }\n    }\n\n    pub unsafe fn notify_all(&self) {\n        let counter = self.counter.swap(0, SeqCst);\n        for _ in 0..counter {\n            abi::sem_post(self.sem1);\n        }\n        for _ in 0..counter {\n            abi::sem_timedwait(self.sem2, 0);\n        }\n    }\n\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n        self.counter.fetch_add(1, SeqCst);\n        mutex.unlock();\n        abi::sem_timedwait(self.sem1, 0);\n        abi::sem_post(self.sem2);\n        mutex.lock();\n    }\n\n    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n        panic!(\"wait_timeout not supported on hermit\");\n    }\n\n    pub unsafe fn destroy(&self) {\n        let _ = abi::sem_destroy(self.sem1);\n        let _ = abi::sem_destroy(self.sem2);\n    }\n}\n"],["2454","pub use core::slice::memchr::{memchr, memrchr};\n"],["2455","use crate::cell::UnsafeCell;\nuse crate::collections::VecDeque;\nuse crate::ffi::c_void;\nuse crate::hint;\nuse crate::ops::{Deref, DerefMut, Drop};\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sys::hermit::abi;\n\n/// This type provides a lock based on busy waiting to realize mutual exclusion\n///\n/// # Description\n///\n/// This structure behaves a lot like a common mutex. There are some differences:\n///\n/// - By using busy waiting, it can be used outside the runtime.\n/// - It is a so called ticket lock and is completely fair.\n#[cfg_attr(target_arch = \"x86_64\", repr(align(128)))]\n#[cfg_attr(not(target_arch = \"x86_64\"), repr(align(64)))]\nstruct Spinlock<T: ?Sized> {\n    queue: AtomicUsize,\n    dequeue: AtomicUsize,\n    data: UnsafeCell<T>,\n}\n\nunsafe impl<T: ?Sized + Send> Sync for Spinlock<T> {}\nunsafe impl<T: ?Sized + Send> Send for Spinlock<T> {}\n\n/// A guard to which the protected data can be accessed\n///\n/// When the guard falls out of scope it will release the lock.\nstruct SpinlockGuard<'a, T: ?Sized + 'a> {\n    dequeue: &'a AtomicUsize,\n    data: &'a mut T,\n}\n\nimpl<T> Spinlock<T> {\n    pub const fn new(user_data: T) -> Spinlock<T> {\n        Spinlock {\n            queue: AtomicUsize::new(0),\n            dequeue: AtomicUsize::new(1),\n            data: UnsafeCell::new(user_data),\n        }\n    }\n\n    #[inline]\n    fn obtain_lock(&self) {\n        let ticket = self.queue.fetch_add(1, Ordering::SeqCst) + 1;\n        while self.dequeue.load(Ordering::SeqCst) != ticket {\n            hint::spin_loop();\n        }\n    }\n\n    #[inline]\n    pub unsafe fn lock(&self) -> SpinlockGuard<'_, T> {\n        self.obtain_lock();\n        SpinlockGuard { dequeue: &self.dequeue, data: &mut *self.data.get() }\n    }\n}\n\nimpl<T: ?Sized + Default> Default for Spinlock<T> {\n    fn default() -> Spinlock<T> {\n        Spinlock::new(Default::default())\n    }\n}\n\nimpl<'a, T: ?Sized> Deref for SpinlockGuard<'a, T> {\n    type Target = T;\n    fn deref(&self) -> &T {\n        &*self.data\n    }\n}\n\nimpl<'a, T: ?Sized> DerefMut for SpinlockGuard<'a, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        &mut *self.data\n    }\n}\n\nimpl<'a, T: ?Sized> Drop for SpinlockGuard<'a, T> {\n    /// The dropping of the SpinlockGuard will release the lock it was created from.\n    fn drop(&mut self) {\n        self.dequeue.fetch_add(1, Ordering::SeqCst);\n    }\n}\n\n/// Realize a priority queue for tasks\nstruct PriorityQueue {\n    queues: [Option<VecDeque<abi::Tid>>; abi::NO_PRIORITIES],\n    prio_bitmap: u64,\n}\n\nimpl PriorityQueue {\n    pub const fn new() -> PriorityQueue {\n        PriorityQueue {\n            queues: [\n                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n                None, None, None,\n            ],\n            prio_bitmap: 0,\n        }\n    }\n\n    /// Add a task id by its priority to the queue\n    pub fn push(&mut self, prio: abi::Priority, id: abi::Tid) {\n        let i: usize = prio.into().into();\n        self.prio_bitmap |= (1 << i) as u64;\n        if let Some(queue) = &mut self.queues[i] {\n            queue.push_back(id);\n        } else {\n            let mut queue = VecDeque::new();\n            queue.push_back(id);\n            self.queues[i] = Some(queue);\n        }\n    }\n\n    fn pop_from_queue(&mut self, queue_index: usize) -> Option<abi::Tid> {\n        if let Some(queue) = &mut self.queues[queue_index] {\n            let id = queue.pop_front();\n\n            if queue.is_empty() {\n                self.prio_bitmap &= !(1 << queue_index as u64);\n            }\n\n            id\n        } else {\n            None\n        }\n    }\n\n    /// Pop the task handle with the highest priority from the queue\n    pub fn pop(&mut self) -> Option<abi::Tid> {\n        for i in 0..abi::NO_PRIORITIES {\n            if self.prio_bitmap & (1 << i) != 0 {\n                return self.pop_from_queue(i);\n            }\n        }\n\n        None\n    }\n}\n\nstruct MutexInner {\n    locked: bool,\n    blocked_task: PriorityQueue,\n}\n\nimpl MutexInner {\n    pub const fn new() -> MutexInner {\n        MutexInner { locked: false, blocked_task: PriorityQueue::new() }\n    }\n}\n\npub struct Mutex {\n    inner: Spinlock<MutexInner>,\n}\n\npub type MovableMutex = Box<Mutex>;\n\nunsafe impl Send for Mutex {}\nunsafe impl Sync for Mutex {}\n\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        Mutex { inner: Spinlock::new(MutexInner::new()) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {\n        self.inner = Spinlock::new(MutexInner::new());\n    }\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        loop {\n            let mut guard = self.inner.lock();\n            if guard.locked == false {\n                guard.locked = true;\n                return;\n            } else {\n                let prio = abi::get_priority();\n                let id = abi::getpid();\n\n                guard.blocked_task.push(prio, id);\n                abi::block_current_task();\n                drop(guard);\n                abi::yield_now();\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let mut guard = self.inner.lock();\n        guard.locked = false;\n        if let Some(tid) = guard.blocked_task.pop() {\n            abi::wakeup_task(tid);\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        let mut guard = self.inner.lock();\n        if guard.locked == false {\n            guard.locked = true;\n        }\n        guard.locked\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n\npub struct ReentrantMutex {\n    inner: *const c_void,\n}\n\nimpl ReentrantMutex {\n    pub const unsafe fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex { inner: ptr::null() }\n    }\n\n    #[inline]\n    pub unsafe fn init(&self) {\n        let _ = abi::recmutex_init(&self.inner as *const *const c_void as *mut _);\n    }\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        let _ = abi::recmutex_lock(self.inner);\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let _ = abi::recmutex_unlock(self.inner);\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        let _ = abi::recmutex_destroy(self.inner);\n    }\n}\n"],["2456","#![allow(dead_code)]\n\nuse super::unsupported;\nuse crate::ffi::CStr;\nuse crate::io;\nuse crate::mem;\nuse crate::num::NonZeroUsize;\nuse crate::sys::hermit::abi;\nuse crate::sys::hermit::thread_local_dtor::run_dtors;\nuse crate::time::Duration;\n\npub type Tid = abi::Tid;\n\npub struct Thread {\n    tid: Tid,\n}\n\nunsafe impl Send for Thread {}\nunsafe impl Sync for Thread {}\n\npub const DEFAULT_MIN_STACK_SIZE: usize = 1 << 20;\n\nimpl Thread {\n    pub unsafe fn new_with_coreid(\n        stack: usize,\n        p: Box<dyn FnOnce()>,\n        core_id: isize,\n    ) -> io::Result<Thread> {\n        let p = Box::into_raw(box p);\n        let tid = abi::spawn2(\n            thread_start,\n            p as usize,\n            abi::Priority::into(abi::NORMAL_PRIO),\n            stack,\n            core_id,\n        );\n\n        return if tid == 0 {\n            // The thread failed to start and as a result p was not consumed. Therefore, it is\n            // safe to reconstruct the box so that it gets deallocated.\n            drop(Box::from_raw(p));\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Unable to create thread!\"))\n        } else {\n            Ok(Thread { tid: tid })\n        };\n\n        extern \"C\" fn thread_start(main: usize) {\n            unsafe {\n                // Finally, let's run some code.\n                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n\n                // run all destructors\n                run_dtors();\n            }\n        }\n    }\n\n    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        Thread::new_with_coreid(stack, p, -1 /* = no specific core */)\n    }\n\n    #[inline]\n    pub fn yield_now() {\n        unsafe {\n            abi::yield_now();\n        }\n    }\n\n    #[inline]\n    pub fn set_name(_name: &CStr) {\n        // nope\n    }\n\n    #[inline]\n    pub fn sleep(dur: Duration) {\n        unsafe {\n            abi::usleep(dur.as_micros() as u64);\n        }\n    }\n\n    pub fn join(self) {\n        unsafe {\n            let _ = abi::join(self.tid);\n        }\n    }\n\n    #[inline]\n    pub fn id(&self) -> Tid {\n        self.tid\n    }\n\n    #[inline]\n    pub fn into_id(self) -> Tid {\n        let id = self.tid;\n        mem::forget(self);\n        id\n    }\n}\n\npub fn available_concurrency() -> io::Result<NonZeroUsize> {\n    unsupported()\n}\n\npub mod guard {\n    pub type Guard = !;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n"],["2457","use crate::mem;\n\n#[derive(Copy, Clone)]\npub struct IoSlice<'a>(&'a [u8]);\n\nimpl<'a> IoSlice<'a> {\n    #[inline]\n    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n        IoSlice(buf)\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        self.0 = &self.0[n..]\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        self.0\n    }\n}\n\npub struct IoSliceMut<'a>(&'a mut [u8]);\n\nimpl<'a> IoSliceMut<'a> {\n    #[inline]\n    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n        IoSliceMut(buf)\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        let slice = mem::replace(&mut self.0, &mut []);\n        let (_, remaining) = slice.split_at_mut(n);\n        self.0 = remaining;\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        self.0\n    }\n\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n        self.0\n    }\n}\n"],["2458","pub mod os {\n    pub const FAMILY: &str = \"\";\n    pub const OS: &str = \"\";\n    pub const DLL_PREFIX: &str = \"\";\n    pub const DLL_SUFFIX: &str = \"\";\n    pub const DLL_EXTENSION: &str = \"\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n"],["2459","#![deny(unsafe_op_in_unsafe_fn)]\n\npub mod alloc;\npub mod args;\n#[path = \"../unix/cmath.rs\"]\npub mod cmath;\npub mod condvar;\npub mod env;\npub mod fs;\npub mod io;\npub mod mutex;\npub mod net;\npub mod os;\n#[path = \"../unix/path.rs\"]\npub mod path;\npub mod pipe;\npub mod process;\npub mod rwlock;\npub mod stdio;\npub mod thread;\n#[cfg(target_thread_local)]\npub mod thread_local_dtor;\npub mod thread_local_key;\npub mod time;\n\nmod common;\npub use common::*;\n"],["2460","use crate::convert::TryFrom;\nuse crate::fmt;\nuse crate::io::{self, IoSlice, IoSliceMut};\nuse crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\nuse crate::sys::unsupported;\nuse crate::time::Duration;\n\npub struct TcpStream(!);\n\nimpl TcpStream {\n    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n        unsupported()\n    }\n\n    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n        unsupported()\n    }\n\n    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0\n    }\n\n    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn is_read_vectored(&self) -> bool {\n        self.0\n    }\n\n    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn is_write_vectored(&self) -> bool {\n        self.0\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        self.0\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        self.0\n    }\n\n    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpStream> {\n        self.0\n    }\n\n    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn nodelay(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        self.0\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.0\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n}\n\nimpl fmt::Debug for TcpStream {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\npub struct TcpListener(!);\n\nimpl TcpListener {\n    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n        unsupported()\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        self.0\n    }\n\n    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n        self.0\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpListener> {\n        self.0\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        self.0\n    }\n\n    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn only_v6(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.0\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n}\n\nimpl fmt::Debug for TcpListener {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\npub struct UdpSocket(!);\n\nimpl UdpSocket {\n    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n        unsupported()\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        self.0\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        self.0\n    }\n\n    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.0\n    }\n\n    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.0\n    }\n\n    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n        self.0\n    }\n\n    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0\n    }\n\n    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn broadcast(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n        self.0\n    }\n\n    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        self.0\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.0\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n        self.0\n    }\n}\n\nimpl fmt::Debug for UdpSocket {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\npub struct LookupHost(!);\n\nimpl LookupHost {\n    pub fn port(&self) -> u16 {\n        self.0\n    }\n}\n\nimpl Iterator for LookupHost {\n    type Item = SocketAddr;\n    fn next(&mut self) -> Option<SocketAddr> {\n        self.0\n    }\n}\n\nimpl TryFrom<&str> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from(_v: &str) -> io::Result<LookupHost> {\n        unsupported()\n    }\n}\n\nimpl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n        unsupported()\n    }\n}\n\n#[allow(nonstandard_style)]\npub mod netc {\n    pub const AF_INET: u8 = 0;\n    pub const AF_INET6: u8 = 1;\n    pub type sa_family_t = u8;\n\n    #[derive(Copy, Clone)]\n    pub struct in_addr {\n        pub s_addr: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in {\n        pub sin_family: sa_family_t,\n        pub sin_port: u16,\n        pub sin_addr: in_addr,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct in6_addr {\n        pub s6_addr: [u8; 16],\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in6 {\n        pub sin6_family: sa_family_t,\n        pub sin6_port: u16,\n        pub sin6_addr: in6_addr,\n        pub sin6_flowinfo: u32,\n        pub sin6_scope_id: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr {}\n\n    pub type socklen_t = usize;\n}\n"],["2461","#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n\npub unsafe fn register_dtor(_t: *mut u8, _dtor: unsafe extern \"C\" fn(*mut u8)) {\n    // FIXME: right now there is no concept of \"thread exit\", but this is likely\n    // going to show up at some point in the form of an exported symbol that the\n    // wasm runtime is going to be expected to call. For now we basically just\n    // ignore the arguments, but if such a function starts to exist it will\n    // likely look like the OSX implementation in `unix/fast_thread_local.rs`\n}\n"],["2462","pub type Key = usize;\n\n#[inline]\npub unsafe fn create(_dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n    panic!(\"should not be used on this target\");\n}\n\n#[inline]\npub unsafe fn set(_key: Key, _value: *mut u8) {\n    panic!(\"should not be used on this target\");\n}\n\n#[inline]\npub unsafe fn get(_key: Key) -> *mut u8 {\n    panic!(\"should not be used on this target\");\n}\n\n#[inline]\npub unsafe fn destroy(_key: Key) {\n    panic!(\"should not be used on this target\");\n}\n\n#[inline]\npub fn requires_synchronized_create() -> bool {\n    panic!(\"should not be used on this target\");\n}\n"],["2463","use crate::cell::Cell;\n\npub struct Mutex {\n    // This platform has no threads, so we can use a Cell here.\n    locked: Cell<bool>,\n}\n\npub type MovableMutex = Mutex;\n\nunsafe impl Send for Mutex {}\nunsafe impl Sync for Mutex {} // no threads on this platform\n\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        Mutex { locked: Cell::new(false) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {}\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        assert_eq!(self.locked.replace(true), false, \"cannot recursively acquire mutex\");\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        self.locked.set(false);\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        self.locked.replace(true) == false\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n\n// All empty stubs because this platform does not yet support threads, so lock\n// acquisition always succeeds.\npub struct ReentrantMutex {}\n\nimpl ReentrantMutex {\n    pub const unsafe fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex {}\n    }\n\n    pub unsafe fn init(&self) {}\n\n    pub unsafe fn lock(&self) {}\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        true\n    }\n\n    pub unsafe fn unlock(&self) {}\n\n    pub unsafe fn destroy(&self) {}\n}\n"],["2464","use crate::ffi::OsString;\nuse crate::fmt;\n\npub struct Args {}\n\npub fn args() -> Args {\n    Args {}\n}\n\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().finish()\n    }\n}\n\nimpl Iterator for Args {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> {\n        None\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, Some(0))\n    }\n}\n\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize {\n        0\n    }\n}\n\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<OsString> {\n        None\n    }\n}\n"],["2465","use crate::time::Duration;\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\npub struct Instant(Duration);\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\npub struct SystemTime(Duration);\n\npub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n\nimpl Instant {\n    pub fn now() -> Instant {\n        panic!(\"time not implemented on this platform\")\n    }\n\n    pub const fn zero() -> Instant {\n        Instant(Duration::from_secs(0))\n    }\n\n    pub fn actually_monotonic() -> bool {\n        false\n    }\n\n    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n        self.0.checked_sub(other.0)\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant(self.0.checked_add(*other)?))\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant(self.0.checked_sub(*other)?))\n    }\n}\n\nimpl SystemTime {\n    pub fn now() -> SystemTime {\n        panic!(\"time not implemented on this platform\")\n    }\n\n    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n        self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime(self.0.checked_add(*other)?))\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime(self.0.checked_sub(*other)?))\n    }\n}\n"],["2466","use crate::alloc::{GlobalAlloc, Layout, System};\n\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, _layout: Layout) -> *mut u8 {\n        0 as *mut u8\n    }\n\n    #[inline]\n    unsafe fn alloc_zeroed(&self, _layout: Layout) -> *mut u8 {\n        0 as *mut u8\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n\n    #[inline]\n    unsafe fn realloc(&self, _ptr: *mut u8, _layout: Layout, _new_size: usize) -> *mut u8 {\n        0 as *mut u8\n    }\n}\n"],["2467","use crate::ffi::OsString;\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\nuse crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\nuse crate::path::{Path, PathBuf};\nuse crate::sys::time::SystemTime;\nuse crate::sys::unsupported;\n\npub struct File(!);\n\npub struct FileAttr(!);\n\npub struct ReadDir(!);\n\npub struct DirEntry(!);\n\n#[derive(Clone, Debug)]\npub struct OpenOptions {}\n\npub struct FilePermissions(!);\n\npub struct FileType(!);\n\n#[derive(Debug)]\npub struct DirBuilder {}\n\nimpl FileAttr {\n    pub fn size(&self) -> u64 {\n        self.0\n    }\n\n    pub fn perm(&self) -> FilePermissions {\n        self.0\n    }\n\n    pub fn file_type(&self) -> FileType {\n        self.0\n    }\n\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        self.0\n    }\n\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        self.0\n    }\n\n    pub fn created(&self) -> io::Result<SystemTime> {\n        self.0\n    }\n}\n\nimpl Clone for FileAttr {\n    fn clone(&self) -> FileAttr {\n        self.0\n    }\n}\n\nimpl FilePermissions {\n    pub fn readonly(&self) -> bool {\n        self.0\n    }\n\n    pub fn set_readonly(&mut self, _readonly: bool) {\n        self.0\n    }\n}\n\nimpl Clone for FilePermissions {\n    fn clone(&self) -> FilePermissions {\n        self.0\n    }\n}\n\nimpl PartialEq for FilePermissions {\n    fn eq(&self, _other: &FilePermissions) -> bool {\n        self.0\n    }\n}\n\nimpl Eq for FilePermissions {}\n\nimpl fmt::Debug for FilePermissions {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl FileType {\n    pub fn is_dir(&self) -> bool {\n        self.0\n    }\n\n    pub fn is_file(&self) -> bool {\n        self.0\n    }\n\n    pub fn is_symlink(&self) -> bool {\n        self.0\n    }\n}\n\nimpl Clone for FileType {\n    fn clone(&self) -> FileType {\n        self.0\n    }\n}\n\nimpl Copy for FileType {}\n\nimpl PartialEq for FileType {\n    fn eq(&self, _other: &FileType) -> bool {\n        self.0\n    }\n}\n\nimpl Eq for FileType {}\n\nimpl Hash for FileType {\n    fn hash<H: Hasher>(&self, _h: &mut H) {\n        self.0\n    }\n}\n\nimpl fmt::Debug for FileType {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl fmt::Debug for ReadDir {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl Iterator for ReadDir {\n    type Item = io::Result<DirEntry>;\n\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        self.0\n    }\n}\n\nimpl DirEntry {\n    pub fn path(&self) -> PathBuf {\n        self.0\n    }\n\n    pub fn file_name(&self) -> OsString {\n        self.0\n    }\n\n    pub fn metadata(&self) -> io::Result<FileAttr> {\n        self.0\n    }\n\n    pub fn file_type(&self) -> io::Result<FileType> {\n        self.0\n    }\n}\n\nimpl OpenOptions {\n    pub fn new() -> OpenOptions {\n        OpenOptions {}\n    }\n\n    pub fn read(&mut self, _read: bool) {}\n    pub fn write(&mut self, _write: bool) {}\n    pub fn append(&mut self, _append: bool) {}\n    pub fn truncate(&mut self, _truncate: bool) {}\n    pub fn create(&mut self, _create: bool) {}\n    pub fn create_new(&mut self, _create_new: bool) {}\n}\n\nimpl File {\n    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {\n        unsupported()\n    }\n\n    pub fn file_attr(&self) -> io::Result<FileAttr> {\n        self.0\n    }\n\n    pub fn fsync(&self) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn datasync(&self) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn is_read_vectored(&self) -> bool {\n        self.0\n    }\n\n    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn is_write_vectored(&self) -> bool {\n        self.0\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n        self.0\n    }\n\n    pub fn duplicate(&self) -> io::Result<File> {\n        self.0\n    }\n\n    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n        self.0\n    }\n}\n\nimpl DirBuilder {\n    pub fn new() -> DirBuilder {\n        DirBuilder {}\n    }\n\n    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n        unsupported()\n    }\n}\n\nimpl fmt::Debug for File {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\npub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n    unsupported()\n}\n\npub fn unlink(_p: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n    match perm.0 {}\n}\n\npub fn rmdir(_p: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn try_exists(_path: &Path) -> io::Result<bool> {\n    unsupported()\n}\n\npub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn stat(_p: &Path) -> io::Result<FileAttr> {\n    unsupported()\n}\n\npub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n    unsupported()\n}\n\npub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {\n    unsupported()\n}\n"],["2468","use super::unsupported;\nuse crate::error::Error as StdError;\nuse crate::ffi::{OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::marker::PhantomData;\nuse crate::path::{self, PathBuf};\n\npub fn errno() -> i32 {\n    0\n}\n\npub fn error_string(_errno: i32) -> String {\n    \"operation successful\".to_string()\n}\n\npub fn getcwd() -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub fn chdir(_: &path::Path) -> io::Result<()> {\n    unsupported()\n}\n\npub struct SplitPaths<'a>(!, PhantomData<&'a ()>);\n\npub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {\n    panic!(\"unsupported\")\n}\n\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> {\n        self.0\n    }\n}\n\n#[derive(Debug)]\npub struct JoinPathsError;\n\npub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: Iterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n    Err(JoinPathsError)\n}\n\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"not supported on this platform yet\".fmt(f)\n    }\n}\n\nimpl StdError for JoinPathsError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"not supported on this platform yet\"\n    }\n}\n\npub fn current_exe() -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub struct Env(!);\n\nimpl Iterator for Env {\n    type Item = (OsString, OsString);\n    fn next(&mut self) -> Option<(OsString, OsString)> {\n        self.0\n    }\n}\n\npub fn env() -> Env {\n    panic!(\"not supported on this platform\")\n}\n\npub fn getenv(_: &OsStr) -> io::Result<Option<OsString>> {\n    Ok(None)\n}\n\npub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n    Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"cannot set env vars on this platform\"))\n}\n\npub fn unsetenv(_: &OsStr) -> io::Result<()> {\n    Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"cannot unset env vars on this platform\"))\n}\n\npub fn temp_dir() -> PathBuf {\n    panic!(\"no filesystem on this platform\")\n}\n\npub fn home_dir() -> Option<PathBuf> {\n    None\n}\n\npub fn exit(_code: i32) -> ! {\n    crate::intrinsics::abort()\n}\n\npub fn getpid() -> u32 {\n    panic!(\"no pids on this platform\")\n}\n"],["2469","use crate::cell::Cell;\n\npub struct RWLock {\n    // This platform has no threads, so we can use a Cell here.\n    mode: Cell<isize>,\n}\n\npub type MovableRWLock = RWLock;\n\nunsafe impl Send for RWLock {}\nunsafe impl Sync for RWLock {} // no threads on this platform\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock { mode: Cell::new(0) }\n    }\n\n    #[inline]\n    pub unsafe fn read(&self) {\n        let m = self.mode.get();\n        if m >= 0 {\n            self.mode.set(m + 1);\n        } else {\n            rtabort!(\"rwlock locked for writing\");\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        let m = self.mode.get();\n        if m >= 0 {\n            self.mode.set(m + 1);\n            true\n        } else {\n            false\n        }\n    }\n\n    #[inline]\n    pub unsafe fn write(&self) {\n        if self.mode.replace(-1) != 0 {\n            rtabort!(\"rwlock locked for reading\")\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        if self.mode.get() == 0 {\n            self.mode.set(-1);\n            true\n        } else {\n            false\n        }\n    }\n\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        self.mode.set(self.mode.get() - 1);\n    }\n\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        assert_eq!(self.mode.replace(0), -1);\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n"],["2470","use crate::io::{self, IoSlice, IoSliceMut};\n\npub struct AnonPipe(!);\n\nimpl AnonPipe {\n    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn is_read_vectored(&self) -> bool {\n        self.0\n    }\n\n    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn is_write_vectored(&self) -> bool {\n        self.0\n    }\n\n    pub fn diverge(&self) -> ! {\n        self.0\n    }\n}\n\npub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n    match p1.0 {}\n}\n"],["2471","use crate::io as std_io;\n\npub mod memchr {\n    pub use core::slice::memchr::{memchr, memrchr};\n}\n\npub use crate::sys_common::os_str_bytes as os_str;\n\n// This is not necessarily correct. May want to consider making it part of the\n// spec definition?\nuse crate::os::raw::c_char;\n\n// SAFETY: must be called only once during runtime initialization.\n// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\npub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n\n// SAFETY: must be called only once during runtime cleanup.\n// NOTE: this is not guaranteed to run, for example when the program aborts.\npub unsafe fn cleanup() {}\n\npub fn unsupported<T>() -> std_io::Result<T> {\n    Err(unsupported_err())\n}\n\npub fn unsupported_err() -> std_io::Error {\n    std_io::Error::new_const(\n        std_io::ErrorKind::Unsupported,\n        &\"operation not supported on this platform\",\n    )\n}\n\npub fn decode_error_kind(_code: i32) -> crate::io::ErrorKind {\n    crate::io::ErrorKind::Other\n}\n\npub fn abort_internal() -> ! {\n    core::intrinsics::abort();\n}\n\npub fn hashmap_random_keys() -> (u64, u64) {\n    (1, 2)\n}\n\npub unsafe fn strlen(mut s: *const c_char) -> usize {\n    // SAFETY: The caller must guarantee `s` points to a valid 0-terminated string.\n    unsafe {\n        let mut n = 0;\n        while *s != 0 {\n            n += 1;\n            s = s.offset(1);\n        }\n        n\n    }\n}\n"],["2472","use super::unsupported;\nuse crate::ffi::CStr;\nuse crate::io;\nuse crate::num::NonZeroUsize;\nuse crate::time::Duration;\n\npub struct Thread(!);\n\npub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n\nimpl Thread {\n    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        unsupported()\n    }\n\n    pub fn yield_now() {\n        // do nothing\n    }\n\n    pub fn set_name(_name: &CStr) {\n        // nope\n    }\n\n    pub fn sleep(_dur: Duration) {\n        panic!(\"can't sleep\");\n    }\n\n    pub fn join(self) {\n        self.0\n    }\n}\n\npub fn available_concurrency() -> io::Result<NonZeroUsize> {\n    unsupported()\n}\n\npub mod guard {\n    pub type Guard = !;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n"],["2473","use crate::ffi::OsStr;\nuse crate::fmt;\nuse crate::io;\nuse crate::marker::PhantomData;\nuse crate::num::NonZeroI32;\nuse crate::path::Path;\nuse crate::sys::fs::File;\nuse crate::sys::pipe::AnonPipe;\nuse crate::sys::unsupported;\nuse crate::sys_common::process::{CommandEnv, CommandEnvs};\n\npub use crate::ffi::OsString as EnvKey;\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\npub struct Command {\n    env: CommandEnv,\n}\n\n// passed back to std::process with the pipes connected to the child, if any\n// were requested\npub struct StdioPipes {\n    pub stdin: Option<AnonPipe>,\n    pub stdout: Option<AnonPipe>,\n    pub stderr: Option<AnonPipe>,\n}\n\npub enum Stdio {\n    Inherit,\n    Null,\n    MakePipe,\n}\n\nimpl Command {\n    pub fn new(_program: &OsStr) -> Command {\n        Command { env: Default::default() }\n    }\n\n    pub fn arg(&mut self, _arg: &OsStr) {}\n\n    pub fn env_mut(&mut self) -> &mut CommandEnv {\n        &mut self.env\n    }\n\n    pub fn cwd(&mut self, _dir: &OsStr) {}\n\n    pub fn stdin(&mut self, _stdin: Stdio) {}\n\n    pub fn stdout(&mut self, _stdout: Stdio) {}\n\n    pub fn stderr(&mut self, _stderr: Stdio) {}\n\n    pub fn get_program(&self) -> &OsStr {\n        panic!(\"unsupported\")\n    }\n\n    pub fn get_args(&self) -> CommandArgs<'_> {\n        CommandArgs { _p: PhantomData }\n    }\n\n    pub fn get_envs(&self) -> CommandEnvs<'_> {\n        self.env.iter()\n    }\n\n    pub fn get_current_dir(&self) -> Option<&Path> {\n        None\n    }\n\n    pub fn spawn(\n        &mut self,\n        _default: Stdio,\n        _needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        unsupported()\n    }\n}\n\nimpl From<AnonPipe> for Stdio {\n    fn from(pipe: AnonPipe) -> Stdio {\n        pipe.diverge()\n    }\n}\n\nimpl From<File> for Stdio {\n    fn from(_file: File) -> Stdio {\n        panic!(\"unsupported\")\n    }\n}\n\nimpl fmt::Debug for Command {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        Ok(())\n    }\n}\n\npub struct ExitStatus(!);\n\nimpl ExitStatus {\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        self.0\n    }\n\n    pub fn code(&self) -> Option<i32> {\n        self.0\n    }\n}\n\nimpl Clone for ExitStatus {\n    fn clone(&self) -> ExitStatus {\n        self.0\n    }\n}\n\nimpl Copy for ExitStatus {}\n\nimpl PartialEq for ExitStatus {\n    fn eq(&self, _other: &ExitStatus) -> bool {\n        self.0\n    }\n}\n\nimpl Eq for ExitStatus {}\n\nimpl fmt::Debug for ExitStatus {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatusError(ExitStatus);\n\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        self.0.0\n    }\n}\n\nimpl ExitStatusError {\n    pub fn code(self) -> Option<NonZeroI32> {\n        self.0.0\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitCode(bool);\n\nimpl ExitCode {\n    pub const SUCCESS: ExitCode = ExitCode(false);\n    pub const FAILURE: ExitCode = ExitCode(true);\n\n    pub fn as_i32(&self) -> i32 {\n        self.0 as i32\n    }\n}\n\npub struct Process(!);\n\nimpl Process {\n    pub fn id(&self) -> u32 {\n        self.0\n    }\n\n    pub fn kill(&mut self) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        self.0\n    }\n\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        self.0\n    }\n}\n\npub struct CommandArgs<'a> {\n    _p: PhantomData<&'a ()>,\n}\n\nimpl<'a> Iterator for CommandArgs<'a> {\n    type Item = &'a OsStr;\n    fn next(&mut self) -> Option<&'a OsStr> {\n        None\n    }\n}\n\nimpl<'a> ExactSizeIterator for CommandArgs<'a> {}\n\nimpl<'a> fmt::Debug for CommandArgs<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().finish()\n    }\n}\n"],["2474","use crate::sys::mutex::Mutex;\nuse crate::time::Duration;\n\npub struct Condvar {}\n\npub type MovableCondvar = Condvar;\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        Condvar {}\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {}\n\n    #[inline]\n    pub unsafe fn notify_one(&self) {}\n\n    #[inline]\n    pub unsafe fn notify_all(&self) {}\n\n    pub unsafe fn wait(&self, _mutex: &Mutex) {\n        panic!(\"condvar wait not supported\")\n    }\n\n    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n        panic!(\"condvar wait not supported\");\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n"],["2475","use crate::io;\n\npub struct Stdin;\npub struct Stdout;\npub struct Stderr;\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n        Ok(0)\n    }\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\npub const STDIN_BUF_SIZE: usize = 0;\n\npub fn is_ebadf(_err: &io::Error) -> bool {\n    true\n}\n\npub fn panic_output() -> Option<Vec<u8>> {\n    None\n}\n"],["2476","#![cfg_attr(test, allow(dead_code))] // why is this necessary?\nuse super::unsupported;\nuse crate::ffi::CStr;\nuse crate::io;\nuse crate::num::NonZeroUsize;\nuse crate::time::Duration;\n\nuse super::abi::usercalls;\n\npub struct Thread(task_queue::JoinHandle);\n\npub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n\npub use self::task_queue::JoinNotifier;\n\nmod task_queue {\n    use super::wait_notify;\n    use crate::sync::{Mutex, MutexGuard, Once};\n\n    pub type JoinHandle = wait_notify::Waiter;\n\n    pub struct JoinNotifier(Option<wait_notify::Notifier>);\n\n    impl Drop for JoinNotifier {\n        fn drop(&mut self) {\n            self.0.take().unwrap().notify();\n        }\n    }\n\n    pub(super) struct Task {\n        p: Box<dyn FnOnce()>,\n        done: JoinNotifier,\n    }\n\n    impl Task {\n        pub(super) fn new(p: Box<dyn FnOnce()>) -> (Task, JoinHandle) {\n            let (done, recv) = wait_notify::new();\n            let done = JoinNotifier(Some(done));\n            (Task { p, done }, recv)\n        }\n\n        pub(super) fn run(self) -> JoinNotifier {\n            (self.p)();\n            self.done\n        }\n    }\n\n    #[cfg_attr(test, linkage = \"available_externally\")]\n    #[export_name = \"_ZN16__rust_internals3std3sys3sgx6thread15TASK_QUEUE_INITE\"]\n    static TASK_QUEUE_INIT: Once = Once::new();\n    #[cfg_attr(test, linkage = \"available_externally\")]\n    #[export_name = \"_ZN16__rust_internals3std3sys3sgx6thread10TASK_QUEUEE\"]\n    static mut TASK_QUEUE: Option<Mutex<Vec<Task>>> = None;\n\n    pub(super) fn lock() -> MutexGuard<'static, Vec<Task>> {\n        unsafe {\n            TASK_QUEUE_INIT.call_once(|| TASK_QUEUE = Some(Default::default()));\n            TASK_QUEUE.as_ref().unwrap().lock().unwrap()\n        }\n    }\n}\n\n/// This module provides a synchronization primitive that does not use thread\n/// local variables. This is needed for signaling that a thread has finished\n/// execution. The signal is sent once all TLS destructors have finished at\n/// which point no new thread locals should be created.\npub mod wait_notify {\n    use super::super::waitqueue::{SpinMutex, WaitQueue, WaitVariable};\n    use crate::sync::Arc;\n\n    pub struct Notifier(Arc<SpinMutex<WaitVariable<bool>>>);\n\n    impl Notifier {\n        /// Notify the waiter. The waiter is either notified right away (if\n        /// currently blocked in `Waiter::wait()`) or later when it calls the\n        /// `Waiter::wait()` method.\n        pub fn notify(self) {\n            let mut guard = self.0.lock();\n            *guard.lock_var_mut() = true;\n            let _ = WaitQueue::notify_one(guard);\n        }\n    }\n\n    pub struct Waiter(Arc<SpinMutex<WaitVariable<bool>>>);\n\n    impl Waiter {\n        /// Wait for a notification. If `Notifier::notify()` has already been\n        /// called, this will return immediately, otherwise the current thread\n        /// is blocked until notified.\n        pub fn wait(self) {\n            let guard = self.0.lock();\n            if *guard.lock_var() {\n                return;\n            }\n            WaitQueue::wait(guard, || {});\n        }\n    }\n\n    pub fn new() -> (Notifier, Waiter) {\n        let inner = Arc::new(SpinMutex::new(WaitVariable::new(false)));\n        (Notifier(inner.clone()), Waiter(inner))\n    }\n}\n\nimpl Thread {\n    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n    pub unsafe fn new(_stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        let mut queue_lock = task_queue::lock();\n        unsafe { usercalls::launch_thread()? };\n        let (task, handle) = task_queue::Task::new(p);\n        queue_lock.push(task);\n        Ok(Thread(handle))\n    }\n\n    pub(super) fn entry() -> JoinNotifier {\n        let mut pending_tasks = task_queue::lock();\n        let task = rtunwrap!(Some, pending_tasks.pop());\n        drop(pending_tasks); // make sure to not hold the task queue lock longer than necessary\n        task.run()\n    }\n\n    pub fn yield_now() {\n        let wait_error = rtunwrap!(Err, usercalls::wait(0, usercalls::raw::WAIT_NO));\n        rtassert!(wait_error.kind() == io::ErrorKind::WouldBlock);\n    }\n\n    pub fn set_name(_name: &CStr) {\n        // FIXME: could store this pointer in TLS somewhere\n    }\n\n    pub fn sleep(dur: Duration) {\n        usercalls::wait_timeout(0, dur, || true);\n    }\n\n    pub fn join(self) {\n        self.0.wait();\n    }\n}\n\npub fn available_concurrency() -> io::Result<NonZeroUsize> {\n    unsupported()\n}\n\npub mod guard {\n    pub type Guard = !;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n"],["2477","use crate::alloc::{GlobalAlloc, Layout, System};\nuse crate::ptr;\nuse crate::sys::sgx::abi::mem as sgx_mem;\nuse core::sync::atomic::{AtomicBool, Ordering};\n\nuse super::waitqueue::SpinMutex;\n\n// Using a SpinMutex because we never want to exit the enclave waiting for the\n// allocator.\n//\n// The current allocator here is the `dlmalloc` crate which we've got included\n// in the rust-lang/rust repository as a submodule. The crate is a port of\n// dlmalloc.c from C to Rust.\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx5alloc8DLMALLOCE\"]\nstatic DLMALLOC: SpinMutex<dlmalloc::Dlmalloc<Sgx>> =\n    SpinMutex::new(dlmalloc::Dlmalloc::new_with_allocator(Sgx {}));\n\nstruct Sgx;\n\nunsafe impl dlmalloc::Allocator for Sgx {\n    /// Allocs system resources\n    fn alloc(&self, _size: usize) -> (*mut u8, usize, u32) {\n        static INIT: AtomicBool = AtomicBool::new(false);\n\n        // No ordering requirement since this function is protected by the global lock.\n        if !INIT.swap(true, Ordering::Relaxed) {\n            (sgx_mem::heap_base() as _, sgx_mem::heap_size(), 0)\n        } else {\n            (ptr::null_mut(), 0, 0)\n        }\n    }\n\n    fn remap(&self, _ptr: *mut u8, _oldsize: usize, _newsize: usize, _can_move: bool) -> *mut u8 {\n        ptr::null_mut()\n    }\n\n    fn free_part(&self, _ptr: *mut u8, _oldsize: usize, _newsize: usize) -> bool {\n        false\n    }\n\n    fn free(&self, _ptr: *mut u8, _size: usize) -> bool {\n        return false;\n    }\n\n    fn can_release_part(&self, _flags: u32) -> bool {\n        false\n    }\n\n    fn allocates_zeros(&self) -> bool {\n        false\n    }\n\n    fn page_size(&self) -> usize {\n        0x1000\n    }\n}\n\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: the caller must uphold the safety contract for `malloc`\n        unsafe { DLMALLOC.lock().malloc(layout.size(), layout.align()) }\n    }\n\n    #[inline]\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: the caller must uphold the safety contract for `malloc`\n        unsafe { DLMALLOC.lock().calloc(layout.size(), layout.align()) }\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n        // SAFETY: the caller must uphold the safety contract for `malloc`\n        unsafe { DLMALLOC.lock().free(ptr, layout.size(), layout.align()) }\n    }\n\n    #[inline]\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        // SAFETY: the caller must uphold the safety contract for `malloc`\n        unsafe { DLMALLOC.lock().realloc(ptr, layout.size(), layout.align(), new_size) }\n    }\n}\n\n// The following functions are needed by libunwind. These symbols are named\n// in pre-link args for the target specification, so keep that in sync.\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_c_alloc(size: usize, align: usize) -> *mut u8 {\n    unsafe { crate::alloc::alloc(Layout::from_size_align_unchecked(size, align)) }\n}\n\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_c_dealloc(ptr: *mut u8, size: usize, align: usize) {\n    unsafe { crate::alloc::dealloc(ptr, Layout::from_size_align_unchecked(size, align)) }\n}\n"],["2478","use crate::ffi::OsStr;\nuse crate::path::Prefix;\n\n#[inline]\npub fn is_sep_byte(b: u8) -> bool {\n    b == b'/'\n}\n\n#[inline]\npub fn is_verbatim_sep(b: u8) -> bool {\n    b == b'/'\n}\n\npub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n    None\n}\n\npub const MAIN_SEP_STR: &str = \"/\";\npub const MAIN_SEP: char = '/';\n"],["2479","pub use core::slice::memchr::{memchr, memrchr};\n"],["2480","use fortanix_sgx_abi as abi;\n\nuse crate::io;\n#[cfg(not(test))]\nuse crate::slice;\n#[cfg(not(test))]\nuse crate::str;\nuse crate::sys::fd::FileDesc;\n\npub struct Stdin(());\npub struct Stdout(());\npub struct Stderr(());\n\nfn with_std_fd<F: FnOnce(&FileDesc) -> R, R>(fd: abi::Fd, f: F) -> R {\n    let fd = FileDesc::new(fd);\n    let ret = f(&fd);\n    fd.into_raw();\n    ret\n}\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin(())\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        with_std_fd(abi::FD_STDIN, |fd| fd.read(buf))\n    }\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout(())\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        with_std_fd(abi::FD_STDOUT, |fd| fd.write(buf))\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        with_std_fd(abi::FD_STDOUT, |fd| fd.flush())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr(())\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        with_std_fd(abi::FD_STDERR, |fd| fd.write(buf))\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        with_std_fd(abi::FD_STDERR, |fd| fd.flush())\n    }\n}\n\npub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n\npub fn is_ebadf(err: &io::Error) -> bool {\n    // FIXME: Rust normally maps Unix EBADF to `Other`\n    err.raw_os_error() == Some(abi::Error::BrokenPipe as _)\n}\n\npub fn panic_output() -> Option<impl io::Write> {\n    super::abi::panic::SgxPanicOutput::new()\n}\n\n// This function is needed by libunwind. The symbol is named in pre-link args\n// for the target specification, so keep that in sync.\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n    if s < 0 {\n        return;\n    }\n    let buf = unsafe { slice::from_raw_parts(m as *const u8, s as _) };\n    if let Ok(s) = str::from_utf8(&buf[..buf.iter().position(|&b| b == 0).unwrap_or(buf.len())]) {\n        eprint!(\"{}\", s);\n    }\n}\n"],["2481","#[cfg(test)]\nmod tests;\n\nuse crate::num::NonZeroUsize;\n\nuse super::waitqueue::{\n    try_lock_or_false, NotifiedTcs, SpinMutex, SpinMutexGuard, WaitQueue, WaitVariable,\n};\nuse crate::mem;\n\npub struct RWLock {\n    readers: SpinMutex<WaitVariable<Option<NonZeroUsize>>>,\n    writer: SpinMutex<WaitVariable<bool>>,\n}\n\npub type MovableRWLock = Box<RWLock>;\n\n// Check at compile time that RWLock size matches C definition (see test_c_rwlock_initializer below)\n//\n// # Safety\n// Never called, as it is a compile time check.\n#[allow(dead_code)]\nunsafe fn rw_lock_size_assert(r: RWLock) {\n    unsafe { mem::transmute::<RWLock, [u8; 144]>(r) };\n}\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock {\n            readers: SpinMutex::new(WaitVariable::new(None)),\n            writer: SpinMutex::new(WaitVariable::new(false)),\n        }\n    }\n\n    #[inline]\n    pub unsafe fn read(&self) {\n        let mut rguard = self.readers.lock();\n        let wguard = self.writer.lock();\n        if *wguard.lock_var() || !wguard.queue_empty() {\n            // Another thread has or is waiting for the write lock, wait\n            drop(wguard);\n            WaitQueue::wait(rguard, || {});\n        // Another thread has passed the lock to us\n        } else {\n            // No waiting writers, acquire the read lock\n            *rguard.lock_var_mut() =\n                NonZeroUsize::new(rguard.lock_var().map_or(0, |n| n.get()) + 1);\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        let mut rguard = try_lock_or_false!(self.readers);\n        let wguard = try_lock_or_false!(self.writer);\n        if *wguard.lock_var() || !wguard.queue_empty() {\n            // Another thread has or is waiting for the write lock\n            false\n        } else {\n            // No waiting writers, acquire the read lock\n            *rguard.lock_var_mut() =\n                NonZeroUsize::new(rguard.lock_var().map_or(0, |n| n.get()) + 1);\n            true\n        }\n    }\n\n    #[inline]\n    pub unsafe fn write(&self) {\n        let rguard = self.readers.lock();\n        let mut wguard = self.writer.lock();\n        if *wguard.lock_var() || rguard.lock_var().is_some() {\n            // Another thread has the lock, wait\n            drop(rguard);\n            WaitQueue::wait(wguard, || {});\n        // Another thread has passed the lock to us\n        } else {\n            // We are just now obtaining the lock\n            *wguard.lock_var_mut() = true;\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        let rguard = try_lock_or_false!(self.readers);\n        let mut wguard = try_lock_or_false!(self.writer);\n        if *wguard.lock_var() || rguard.lock_var().is_some() {\n            // Another thread has the lock\n            false\n        } else {\n            // We are just now obtaining the lock\n            *wguard.lock_var_mut() = true;\n            true\n        }\n    }\n\n    #[inline]\n    unsafe fn __read_unlock(\n        &self,\n        mut rguard: SpinMutexGuard<'_, WaitVariable<Option<NonZeroUsize>>>,\n        wguard: SpinMutexGuard<'_, WaitVariable<bool>>,\n    ) {\n        *rguard.lock_var_mut() = NonZeroUsize::new(rguard.lock_var().unwrap().get() - 1);\n        if rguard.lock_var().is_some() {\n            // There are other active readers\n        } else {\n            if let Ok(mut wguard) = WaitQueue::notify_one(wguard) {\n                // A writer was waiting, pass the lock\n                *wguard.lock_var_mut() = true;\n                wguard.drop_after(rguard);\n            } else {\n                // No writers were waiting, the lock is released\n                rtassert!(rguard.queue_empty());\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        let rguard = self.readers.lock();\n        let wguard = self.writer.lock();\n        unsafe { self.__read_unlock(rguard, wguard) };\n    }\n\n    #[inline]\n    unsafe fn __write_unlock(\n        &self,\n        rguard: SpinMutexGuard<'_, WaitVariable<Option<NonZeroUsize>>>,\n        wguard: SpinMutexGuard<'_, WaitVariable<bool>>,\n    ) {\n        match WaitQueue::notify_one(wguard) {\n            Err(mut wguard) => {\n                // No writers waiting, release the write lock\n                *wguard.lock_var_mut() = false;\n                if let Ok(mut rguard) = WaitQueue::notify_all(rguard) {\n                    // One or more readers were waiting, pass the lock to them\n                    if let NotifiedTcs::All { count } = rguard.notified_tcs() {\n                        *rguard.lock_var_mut() = Some(count)\n                    } else {\n                        unreachable!() // called notify_all\n                    }\n                    rguard.drop_after(wguard);\n                } else {\n                    // No readers waiting, the lock is released\n                }\n            }\n            Ok(wguard) => {\n                // There was a thread waiting for write, just pass the lock\n                wguard.drop_after(rguard);\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        let rguard = self.readers.lock();\n        let wguard = self.writer.lock();\n        unsafe { self.__write_unlock(rguard, wguard) };\n    }\n\n    // only used by __rust_rwlock_unlock below\n    #[inline]\n    #[cfg_attr(test, allow(dead_code))]\n    unsafe fn unlock(&self) {\n        let rguard = self.readers.lock();\n        let wguard = self.writer.lock();\n        if *wguard.lock_var() == true {\n            unsafe { self.__write_unlock(rguard, wguard) };\n        } else {\n            unsafe { self.__read_unlock(rguard, wguard) };\n        }\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n\n// The following functions are needed by libunwind. These symbols are named\n// in pre-link args for the target specification, so keep that in sync.\n#[cfg(not(test))]\nconst EINVAL: i32 = 22;\n\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_rwlock_rdlock(p: *mut RWLock) -> i32 {\n    if p.is_null() {\n        return EINVAL;\n    }\n    unsafe { (*p).read() };\n    return 0;\n}\n\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_rwlock_wrlock(p: *mut RWLock) -> i32 {\n    if p.is_null() {\n        return EINVAL;\n    }\n    unsafe { (*p).write() };\n    return 0;\n}\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RWLock) -> i32 {\n    if p.is_null() {\n        return EINVAL;\n    }\n    unsafe { (*p).unlock() };\n    return 0;\n}\n"],["2482","//! System bindings for the Fortanix SGX platform\n//!\n//! This module contains the facade (aka platform-specific) implementations of\n//! OS level functionality for Fortanix SGX.\n#![deny(unsafe_op_in_unsafe_fn)]\n\nuse crate::io::ErrorKind;\nuse crate::os::raw::c_char;\nuse crate::sync::atomic::{AtomicBool, Ordering};\n\npub mod abi;\nmod waitqueue;\n\npub mod alloc;\npub mod args;\n#[path = \"../unix/cmath.rs\"]\npub mod cmath;\npub mod condvar;\npub mod env;\npub mod fd;\n#[path = \"../unsupported/fs.rs\"]\npub mod fs;\n#[path = \"../unsupported/io.rs\"]\npub mod io;\npub mod memchr;\npub mod mutex;\npub mod net;\npub mod os;\npub mod path;\n#[path = \"../unsupported/pipe.rs\"]\npub mod pipe;\n#[path = \"../unsupported/process.rs\"]\npub mod process;\npub mod rwlock;\npub mod stdio;\npub mod thread;\npub mod thread_local_key;\npub mod time;\n\npub use crate::sys_common::os_str_bytes as os_str;\n\n// SAFETY: must be called only once during runtime initialization.\n// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    unsafe {\n        args::init(argc, argv);\n    }\n}\n\n// SAFETY: must be called only once during runtime cleanup.\n// NOTE: this is not guaranteed to run, for example when the program aborts.\npub unsafe fn cleanup() {}\n\n/// This function is used to implement functionality that simply doesn't exist.\n/// Programs relying on this functionality will need to deal with the error.\npub fn unsupported<T>() -> crate::io::Result<T> {\n    Err(unsupported_err())\n}\n\npub fn unsupported_err() -> crate::io::Error {\n    crate::io::Error::new_const(ErrorKind::Unsupported, &\"operation not supported on SGX yet\")\n}\n\n/// This function is used to implement various functions that doesn't exist,\n/// but the lack of which might not be reason for error. If no error is\n/// returned, the program might very well be able to function normally. This is\n/// what happens when `SGX_INEFFECTIVE_ERROR` is set to `true`. If it is\n/// `false`, the behavior is the same as `unsupported`.\npub fn sgx_ineffective<T>(v: T) -> crate::io::Result<T> {\n    static SGX_INEFFECTIVE_ERROR: AtomicBool = AtomicBool::new(false);\n    if SGX_INEFFECTIVE_ERROR.load(Ordering::Relaxed) {\n        Err(crate::io::Error::new_const(\n            ErrorKind::Other,\n            &\"operation can't be trusted to have any effect on SGX\",\n        ))\n    } else {\n        Ok(v)\n    }\n}\n\npub fn decode_error_kind(code: i32) -> ErrorKind {\n    use fortanix_sgx_abi::Error;\n\n    // FIXME: not sure how to make sure all variants of Error are covered\n    if code == Error::NotFound as _ {\n        ErrorKind::NotFound\n    } else if code == Error::PermissionDenied as _ {\n        ErrorKind::PermissionDenied\n    } else if code == Error::ConnectionRefused as _ {\n        ErrorKind::ConnectionRefused\n    } else if code == Error::ConnectionReset as _ {\n        ErrorKind::ConnectionReset\n    } else if code == Error::ConnectionAborted as _ {\n        ErrorKind::ConnectionAborted\n    } else if code == Error::NotConnected as _ {\n        ErrorKind::NotConnected\n    } else if code == Error::AddrInUse as _ {\n        ErrorKind::AddrInUse\n    } else if code == Error::AddrNotAvailable as _ {\n        ErrorKind::AddrNotAvailable\n    } else if code == Error::BrokenPipe as _ {\n        ErrorKind::BrokenPipe\n    } else if code == Error::AlreadyExists as _ {\n        ErrorKind::AlreadyExists\n    } else if code == Error::WouldBlock as _ {\n        ErrorKind::WouldBlock\n    } else if code == Error::InvalidInput as _ {\n        ErrorKind::InvalidInput\n    } else if code == Error::InvalidData as _ {\n        ErrorKind::InvalidData\n    } else if code == Error::TimedOut as _ {\n        ErrorKind::TimedOut\n    } else if code == Error::WriteZero as _ {\n        ErrorKind::WriteZero\n    } else if code == Error::Interrupted as _ {\n        ErrorKind::Interrupted\n    } else if code == Error::Other as _ {\n        ErrorKind::Other\n    } else if code == Error::UnexpectedEof as _ {\n        ErrorKind::UnexpectedEof\n    } else {\n        ErrorKind::Other\n    }\n}\n\npub unsafe fn strlen(mut s: *const c_char) -> usize {\n    let mut n = 0;\n    while unsafe { *s } != 0 {\n        n += 1;\n        s = unsafe { s.offset(1) };\n    }\n    return n;\n}\n\npub fn abort_internal() -> ! {\n    abi::usercalls::exit(true)\n}\n\n// This function is needed by the panic runtime. The symbol is named in\n// pre-link args for the target specification, so keep that in sync.\n#[cfg(not(test))]\n#[no_mangle]\n// NB. used by both libunwind and libpanic_abort\npub extern \"C\" fn __rust_abort() {\n    abort_internal();\n}\n\npub mod rand {\n    pub fn rdrand64() -> u64 {\n        unsafe {\n            let mut ret: u64 = 0;\n            for _ in 0..10 {\n                if crate::arch::x86_64::_rdrand64_step(&mut ret) == 1 {\n                    return ret;\n                }\n            }\n            rtabort!(\"Failed to obtain random data\");\n        }\n    }\n}\n\npub fn hashmap_random_keys() -> (u64, u64) {\n    (self::rand::rdrand64(), self::rand::rdrand64())\n}\n\npub use crate::sys_common::{AsInner, FromInner, IntoInner};\n\npub trait TryIntoInner<Inner>: Sized {\n    fn try_into_inner(self) -> Result<Inner, Self>;\n}\n"],["2483","use crate::convert::TryFrom;\nuse crate::error;\nuse crate::fmt;\nuse crate::io::{self, IoSlice, IoSliceMut};\nuse crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr, ToSocketAddrs};\nuse crate::sync::Arc;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::{sgx_ineffective, unsupported, AsInner, FromInner, IntoInner, TryIntoInner};\nuse crate::time::Duration;\n\nuse super::abi::usercalls;\n\nconst DEFAULT_FAKE_TTL: u32 = 64;\n\n#[derive(Debug, Clone)]\npub struct Socket {\n    inner: Arc<FileDesc>,\n    local_addr: Option<String>,\n}\n\nimpl Socket {\n    fn new(fd: usercalls::raw::Fd, local_addr: String) -> Socket {\n        Socket { inner: Arc::new(FileDesc::new(fd)), local_addr: Some(local_addr) }\n    }\n}\n\nimpl AsInner<FileDesc> for Socket {\n    fn as_inner(&self) -> &FileDesc {\n        &self.inner\n    }\n}\n\nimpl TryIntoInner<FileDesc> for Socket {\n    fn try_into_inner(self) -> Result<FileDesc, Socket> {\n        let Socket { inner, local_addr } = self;\n        Arc::try_unwrap(inner).map_err(|inner| Socket { inner, local_addr })\n    }\n}\n\nimpl FromInner<(FileDesc, Option<String>)> for Socket {\n    fn from_inner((inner, local_addr): (FileDesc, Option<String>)) -> Socket {\n        Socket { inner: Arc::new(inner), local_addr }\n    }\n}\n\n#[derive(Clone)]\npub struct TcpStream {\n    inner: Socket,\n    peer_addr: Option<String>,\n}\n\nimpl fmt::Debug for TcpStream {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut res = f.debug_struct(\"TcpStream\");\n\n        if let Some(ref addr) = self.inner.local_addr {\n            res.field(\"addr\", addr);\n        }\n\n        if let Some(ref peer) = self.peer_addr {\n            res.field(\"peer\", peer);\n        }\n\n        res.field(\"fd\", &self.inner.inner.as_inner()).finish()\n    }\n}\n\nfn io_err_to_addr(result: io::Result<&SocketAddr>) -> io::Result<String> {\n    match result {\n        Ok(saddr) => Ok(saddr.to_string()),\n        // need to downcast twice because io::Error::into_inner doesn't return the original\n        // value if the conversion fails\n        Err(e) => {\n            if e.get_ref().and_then(|e| e.downcast_ref::<NonIpSockAddr>()).is_some() {\n                Ok(e.into_inner().unwrap().downcast::<NonIpSockAddr>().unwrap().host)\n            } else {\n                Err(e)\n            }\n        }\n    }\n}\n\nfn addr_to_sockaddr(addr: &Option<String>) -> io::Result<SocketAddr> {\n    addr.as_ref()\n        .ok_or(io::ErrorKind::AddrNotAvailable)?\n        .to_socket_addrs()\n        // unwrap OK: if an iterator is returned, we're guaranteed to get exactly one entry\n        .map(|mut it| it.next().unwrap())\n}\n\nimpl TcpStream {\n    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n        let addr = io_err_to_addr(addr)?;\n        let (fd, local_addr, peer_addr) = usercalls::connect_stream(&addr)?;\n        Ok(TcpStream { inner: Socket::new(fd, local_addr), peer_addr: Some(peer_addr) })\n    }\n\n    pub fn connect_timeout(addr: &SocketAddr, dur: Duration) -> io::Result<TcpStream> {\n        if dur == Duration::default() {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidInput,\n                &\"cannot set a 0 duration timeout\",\n            ));\n        }\n        Self::connect(Ok(addr)) // FIXME: ignoring timeout\n    }\n\n    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        match dur {\n            Some(dur) if dur == Duration::default() => {\n                return Err(io::Error::new_const(\n                    io::ErrorKind::InvalidInput,\n                    &\"cannot set a 0 duration timeout\",\n                ));\n            }\n            _ => sgx_ineffective(()),\n        }\n    }\n\n    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        match dur {\n            Some(dur) if dur == Duration::default() => {\n                return Err(io::Error::new_const(\n                    io::ErrorKind::InvalidInput,\n                    &\"cannot set a 0 duration timeout\",\n                ));\n            }\n            _ => sgx_ineffective(()),\n        }\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        sgx_ineffective(None)\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        sgx_ineffective(None)\n    }\n\n    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n        Ok(0)\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.inner.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.inner.inner.is_read_vectored()\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.inner.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.inner.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.inner.inner.is_write_vectored()\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        addr_to_sockaddr(&self.peer_addr)\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        addr_to_sockaddr(&self.inner.local_addr)\n    }\n\n    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpStream> {\n        Ok(self.clone())\n    }\n\n    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn nodelay(&self) -> io::Result<bool> {\n        sgx_ineffective(false)\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        sgx_ineffective(DEFAULT_FAKE_TTL)\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        Ok(None)\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n}\n\nimpl AsInner<Socket> for TcpStream {\n    fn as_inner(&self) -> &Socket {\n        &self.inner\n    }\n}\n\n// `Inner` includes `peer_addr` so that a `TcpStream` maybe correctly\n// reconstructed if `Socket::try_into_inner` fails.\nimpl IntoInner<(Socket, Option<String>)> for TcpStream {\n    fn into_inner(self) -> (Socket, Option<String>) {\n        (self.inner, self.peer_addr)\n    }\n}\n\nimpl FromInner<(Socket, Option<String>)> for TcpStream {\n    fn from_inner((inner, peer_addr): (Socket, Option<String>)) -> TcpStream {\n        TcpStream { inner, peer_addr }\n    }\n}\n\n#[derive(Clone)]\npub struct TcpListener {\n    inner: Socket,\n}\n\nimpl fmt::Debug for TcpListener {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut res = f.debug_struct(\"TcpListener\");\n\n        if let Some(ref addr) = self.inner.local_addr {\n            res.field(\"addr\", addr);\n        }\n\n        res.field(\"fd\", &self.inner.inner.as_inner()).finish()\n    }\n}\n\nimpl TcpListener {\n    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n        let addr = io_err_to_addr(addr)?;\n        let (fd, local_addr) = usercalls::bind_stream(&addr)?;\n        Ok(TcpListener { inner: Socket::new(fd, local_addr) })\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        addr_to_sockaddr(&self.inner.local_addr)\n    }\n\n    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n        let (fd, local_addr, peer_addr) = usercalls::accept_stream(self.inner.inner.raw())?;\n        let peer_addr = Some(peer_addr);\n        let ret_peer = addr_to_sockaddr(&peer_addr).unwrap_or_else(|_| ([0; 4], 0).into());\n        Ok((TcpStream { inner: Socket::new(fd, local_addr), peer_addr }, ret_peer))\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpListener> {\n        Ok(self.clone())\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        sgx_ineffective(DEFAULT_FAKE_TTL)\n    }\n\n    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn only_v6(&self) -> io::Result<bool> {\n        sgx_ineffective(false)\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        Ok(None)\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n}\n\nimpl AsInner<Socket> for TcpListener {\n    fn as_inner(&self) -> &Socket {\n        &self.inner\n    }\n}\n\nimpl IntoInner<Socket> for TcpListener {\n    fn into_inner(self) -> Socket {\n        self.inner\n    }\n}\n\nimpl FromInner<Socket> for TcpListener {\n    fn from_inner(inner: Socket) -> TcpListener {\n        TcpListener { inner }\n    }\n}\n\npub struct UdpSocket(!);\n\nimpl UdpSocket {\n    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n        unsupported()\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        self.0\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        self.0\n    }\n\n    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.0\n    }\n\n    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.0\n    }\n\n    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n        self.0\n    }\n\n    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0\n    }\n\n    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn broadcast(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n        self.0\n    }\n\n    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        self.0\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.0\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n        self.0\n    }\n}\n\nimpl fmt::Debug for UdpSocket {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\n#[derive(Debug)]\npub struct NonIpSockAddr {\n    host: String,\n}\n\nimpl error::Error for NonIpSockAddr {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"Failed to convert address to SocketAddr\"\n    }\n}\n\nimpl fmt::Display for NonIpSockAddr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Failed to convert address to SocketAddr: {}\", self.host)\n    }\n}\n\npub struct LookupHost(!);\n\nimpl LookupHost {\n    fn new(host: String) -> io::Result<LookupHost> {\n        Err(io::Error::new(io::ErrorKind::Other, NonIpSockAddr { host }))\n    }\n\n    pub fn port(&self) -> u16 {\n        self.0\n    }\n}\n\nimpl Iterator for LookupHost {\n    type Item = SocketAddr;\n    fn next(&mut self) -> Option<SocketAddr> {\n        self.0\n    }\n}\n\nimpl TryFrom<&str> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from(v: &str) -> io::Result<LookupHost> {\n        LookupHost::new(v.to_owned())\n    }\n}\n\nimpl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n        LookupHost::new(format!(\"{}:{}\", host, port))\n    }\n}\n\n#[allow(bad_style)]\npub mod netc {\n    pub const AF_INET: u8 = 0;\n    pub const AF_INET6: u8 = 1;\n    pub type sa_family_t = u8;\n\n    #[derive(Copy, Clone)]\n    pub struct in_addr {\n        pub s_addr: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in {\n        pub sin_family: sa_family_t,\n        pub sin_port: u16,\n        pub sin_addr: in_addr,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct in6_addr {\n        pub s6_addr: [u8; 16],\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in6 {\n        pub sin6_family: sa_family_t,\n        pub sin6_port: u16,\n        pub sin6_addr: in6_addr,\n        pub sin6_flowinfo: u32,\n        pub sin6_scope_id: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr {}\n\n    pub type socklen_t = usize;\n}\n"],["2484","use super::abi::tls::{Key as AbiKey, Tls};\n\npub type Key = usize;\n\n#[inline]\npub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n    Tls::create(dtor).as_usize()\n}\n\n#[inline]\npub unsafe fn set(key: Key, value: *mut u8) {\n    Tls::set(AbiKey::from_usize(key), value)\n}\n\n#[inline]\npub unsafe fn get(key: Key) -> *mut u8 {\n    Tls::get(AbiKey::from_usize(key))\n}\n\n#[inline]\npub unsafe fn destroy(key: Key) {\n    Tls::destroy(AbiKey::from_usize(key))\n}\n\n#[inline]\npub fn requires_synchronized_create() -> bool {\n    false\n}\n"],["2485","pub mod os {\n    pub const FAMILY: &str = \"\";\n    pub const OS: &str = \"\";\n    pub const DLL_PREFIX: &str = \"\";\n    pub const DLL_SUFFIX: &str = \".sgxs\";\n    pub const DLL_EXTENSION: &str = \"sgxs\";\n    pub const EXE_SUFFIX: &str = \".sgxs\";\n    pub const EXE_EXTENSION: &str = \"sgxs\";\n}\n"],["2486","use fortanix_sgx_abi::{Error, RESULT_SUCCESS};\n\nuse crate::collections::HashMap;\nuse crate::error::Error as StdError;\nuse crate::ffi::{OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::marker::PhantomData;\nuse crate::path::{self, PathBuf};\nuse crate::str;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sync::Mutex;\nuse crate::sync::Once;\nuse crate::sys::{decode_error_kind, sgx_ineffective, unsupported};\nuse crate::vec;\n\npub fn errno() -> i32 {\n    RESULT_SUCCESS\n}\n\npub fn error_string(errno: i32) -> String {\n    if errno == RESULT_SUCCESS {\n        \"operation successful\".into()\n    } else if ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&errno) {\n        format!(\"user-specified error {:08x}\", errno)\n    } else {\n        decode_error_kind(errno).as_str().into()\n    }\n}\n\npub fn getcwd() -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub fn chdir(_: &path::Path) -> io::Result<()> {\n    sgx_ineffective(())\n}\n\npub struct SplitPaths<'a>(!, PhantomData<&'a ()>);\n\npub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {\n    panic!(\"unsupported\")\n}\n\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> {\n        self.0\n    }\n}\n\n#[derive(Debug)]\npub struct JoinPathsError;\n\npub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: Iterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n    Err(JoinPathsError)\n}\n\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"not supported in SGX yet\".fmt(f)\n    }\n}\n\nimpl StdError for JoinPathsError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"not supported in SGX yet\"\n    }\n}\n\npub fn current_exe() -> io::Result<PathBuf> {\n    unsupported()\n}\n\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx2os3ENVE\"]\nstatic ENV: AtomicUsize = AtomicUsize::new(0);\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx2os8ENV_INITE\"]\nstatic ENV_INIT: Once = Once::new();\ntype EnvStore = Mutex<HashMap<OsString, OsString>>;\n\nfn get_env_store() -> Option<&'static EnvStore> {\n    unsafe { (ENV.load(Ordering::Relaxed) as *const EnvStore).as_ref() }\n}\n\nfn create_env_store() -> &'static EnvStore {\n    ENV_INIT.call_once(|| {\n        ENV.store(Box::into_raw(Box::new(EnvStore::default())) as _, Ordering::Relaxed)\n    });\n    unsafe { &*(ENV.load(Ordering::Relaxed) as *const EnvStore) }\n}\n\npub type Env = vec::IntoIter<(OsString, OsString)>;\n\npub fn env() -> Env {\n    let clone_to_vec = |map: &HashMap<OsString, OsString>| -> Vec<_> {\n        map.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n    };\n\n    get_env_store().map(|env| clone_to_vec(&env.lock().unwrap())).unwrap_or_default().into_iter()\n}\n\npub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n    Ok(get_env_store().and_then(|s| s.lock().unwrap().get(k).cloned()))\n}\n\npub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n    let (k, v) = (k.to_owned(), v.to_owned());\n    create_env_store().lock().unwrap().insert(k, v);\n    Ok(())\n}\n\npub fn unsetenv(k: &OsStr) -> io::Result<()> {\n    if let Some(env) = get_env_store() {\n        env.lock().unwrap().remove(k);\n    }\n    Ok(())\n}\n\npub fn temp_dir() -> PathBuf {\n    panic!(\"no filesystem in SGX\")\n}\n\npub fn home_dir() -> Option<PathBuf> {\n    None\n}\n\npub fn exit(code: i32) -> ! {\n    super::abi::exit_with_code(code as _)\n}\n\npub fn getpid() -> u32 {\n    panic!(\"no pids in SGX\")\n}\n"],["2487","use fortanix_sgx_abi::Fd;\n\nuse super::abi::usercalls;\nuse crate::io::{self, IoSlice, IoSliceMut};\nuse crate::mem;\nuse crate::sys::{AsInner, FromInner, IntoInner};\n\n#[derive(Debug)]\npub struct FileDesc {\n    fd: Fd,\n}\n\nimpl FileDesc {\n    pub fn new(fd: Fd) -> FileDesc {\n        FileDesc { fd: fd }\n    }\n\n    pub fn raw(&self) -> Fd {\n        self.fd\n    }\n\n    /// Extracts the actual file descriptor without closing it.\n    pub fn into_raw(self) -> Fd {\n        let fd = self.fd;\n        mem::forget(self);\n        fd\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        usercalls::read(self.fd, &mut [IoSliceMut::new(buf)])\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        usercalls::read(self.fd, bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        usercalls::write(self.fd, &[IoSlice::new(buf)])\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        usercalls::write(self.fd, bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        usercalls::flush(self.fd)\n    }\n}\n\nimpl AsInner<Fd> for FileDesc {\n    fn as_inner(&self) -> &Fd {\n        &self.fd\n    }\n}\n\nimpl IntoInner<Fd> for FileDesc {\n    fn into_inner(self) -> Fd {\n        let fd = self.fd;\n        mem::forget(self);\n        fd\n    }\n}\n\nimpl FromInner<Fd> for FileDesc {\n    fn from_inner(fd: Fd) -> FileDesc {\n        FileDesc { fd }\n    }\n}\n\nimpl Drop for FileDesc {\n    fn drop(&mut self) {\n        usercalls::close(self.fd)\n    }\n}\n"],["2488","use crate::sys::mutex::Mutex;\nuse crate::time::Duration;\n\nuse super::waitqueue::{SpinMutex, WaitQueue, WaitVariable};\n\npub struct Condvar {\n    inner: SpinMutex<WaitVariable<()>>,\n}\n\npub type MovableCondvar = Box<Condvar>;\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        Condvar { inner: SpinMutex::new(WaitVariable::new(())) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {}\n\n    #[inline]\n    pub unsafe fn notify_one(&self) {\n        let _ = WaitQueue::notify_one(self.inner.lock());\n    }\n\n    #[inline]\n    pub unsafe fn notify_all(&self) {\n        let _ = WaitQueue::notify_all(self.inner.lock());\n    }\n\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n        let guard = self.inner.lock();\n        WaitQueue::wait(guard, || unsafe { mutex.unlock() });\n        unsafe { mutex.lock() }\n    }\n\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n        let success = WaitQueue::wait_timeout(&self.inner, dur, || unsafe { mutex.unlock() });\n        unsafe { mutex.lock() };\n        success\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n"],["2489","use super::abi::usercalls;\nuse crate::time::Duration;\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\npub struct Instant(Duration);\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\npub struct SystemTime(Duration);\n\npub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n\nimpl Instant {\n    pub fn now() -> Instant {\n        Instant(usercalls::insecure_time())\n    }\n\n    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n        self.0.checked_sub(other.0)\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant(self.0.checked_add(*other)?))\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant(self.0.checked_sub(*other)?))\n    }\n\n    pub fn actually_monotonic() -> bool {\n        false\n    }\n\n    pub const fn zero() -> Instant {\n        Instant(Duration::from_secs(0))\n    }\n}\n\nimpl SystemTime {\n    pub fn now() -> SystemTime {\n        SystemTime(usercalls::insecure_time())\n    }\n\n    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n        self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime(self.0.checked_add(*other)?))\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime(self.0.checked_sub(*other)?))\n    }\n}\n"],["2490","//! A doubly-linked list where callers are in charge of memory allocation\n//! of the nodes in the list.\n\n#[cfg(test)]\nmod tests;\n\nuse crate::mem;\nuse crate::ptr::NonNull;\n\npub struct UnsafeListEntry<T> {\n    next: NonNull<UnsafeListEntry<T>>,\n    prev: NonNull<UnsafeListEntry<T>>,\n    value: Option<T>,\n}\n\nimpl<T> UnsafeListEntry<T> {\n    fn dummy() -> Self {\n        UnsafeListEntry { next: NonNull::dangling(), prev: NonNull::dangling(), value: None }\n    }\n\n    pub fn new(value: T) -> Self {\n        UnsafeListEntry { value: Some(value), ..Self::dummy() }\n    }\n}\n\npub struct UnsafeList<T> {\n    head_tail: NonNull<UnsafeListEntry<T>>,\n    head_tail_entry: Option<UnsafeListEntry<T>>,\n}\n\nimpl<T> UnsafeList<T> {\n    pub const fn new() -> Self {\n        unsafe { UnsafeList { head_tail: NonNull::new_unchecked(1 as _), head_tail_entry: None } }\n    }\n\n    /// # Safety\n    unsafe fn init(&mut self) {\n        if self.head_tail_entry.is_none() {\n            self.head_tail_entry = Some(UnsafeListEntry::dummy());\n            // SAFETY: `head_tail_entry` must be non-null, which it is because we assign it above.\n            self.head_tail =\n                unsafe { NonNull::new_unchecked(self.head_tail_entry.as_mut().unwrap()) };\n            // SAFETY: `self.head_tail` must meet all requirements for a mutable reference.\n            unsafe { self.head_tail.as_mut() }.next = self.head_tail;\n            unsafe { self.head_tail.as_mut() }.prev = self.head_tail;\n        }\n    }\n\n    pub fn is_empty(&self) -> bool {\n        if self.head_tail_entry.is_some() {\n            let first = unsafe { self.head_tail.as_ref() }.next;\n            if first == self.head_tail {\n                // ,-------> /---------\\ next ---,\n                // |         |head_tail|         |\n                // `--- prev \\---------/ <-------`\n                // SAFETY: `self.head_tail` must meet all requirements for a reference.\n                unsafe { rtassert!(self.head_tail.as_ref().prev == first) };\n                true\n            } else {\n                false\n            }\n        } else {\n            true\n        }\n    }\n\n    /// Pushes an entry onto the back of the list.\n    ///\n    /// # Safety\n    ///\n    /// The entry must remain allocated until the entry is removed from the\n    /// list AND the caller who popped is done using the entry. Special\n    /// care must be taken in the caller of `push` to ensure unwinding does\n    /// not destroy the stack frame containing the entry.\n    pub unsafe fn push<'a>(&mut self, entry: &'a mut UnsafeListEntry<T>) -> &'a T {\n        unsafe { self.init() };\n\n        // BEFORE:\n        //     /---------\\ next ---> /---------\\\n        // ... |prev_tail|           |head_tail| ...\n        //     \\---------/ <--- prev \\---------/\n        //\n        // AFTER:\n        //     /---------\\ next ---> /-----\\ next ---> /---------\\\n        // ... |prev_tail|           |entry|           |head_tail| ...\n        //     \\---------/ <--- prev \\-----/ <--- prev \\---------/\n        let mut entry = unsafe { NonNull::new_unchecked(entry) };\n        let mut prev_tail = mem::replace(&mut unsafe { self.head_tail.as_mut() }.prev, entry);\n        // SAFETY: `entry` must meet all requirements for a mutable reference.\n        unsafe { entry.as_mut() }.prev = prev_tail;\n        unsafe { entry.as_mut() }.next = self.head_tail;\n        // SAFETY: `prev_tail` must meet all requirements for a mutable reference.\n        unsafe { prev_tail.as_mut() }.next = entry;\n        // unwrap ok: always `Some` on non-dummy entries\n        unsafe { (*entry.as_ptr()).value.as_ref() }.unwrap()\n    }\n\n    /// Pops an entry from the front of the list.\n    ///\n    /// # Safety\n    ///\n    /// The caller must make sure to synchronize ending the borrow of the\n    /// return value and deallocation of the containing entry.\n    pub unsafe fn pop<'a>(&mut self) -> Option<&'a T> {\n        unsafe { self.init() };\n\n        if self.is_empty() {\n            None\n        } else {\n            // BEFORE:\n            //     /---------\\ next ---> /-----\\ next ---> /------\\\n            // ... |head_tail|           |first|           |second| ...\n            //     \\---------/ <--- prev \\-----/ <--- prev \\------/\n            //\n            // AFTER:\n            //     /---------\\ next ---> /------\\\n            // ... |head_tail|           |second| ...\n            //     \\---------/ <--- prev \\------/\n            let mut first = unsafe { self.head_tail.as_mut() }.next;\n            let mut second = unsafe { first.as_mut() }.next;\n            unsafe { self.head_tail.as_mut() }.next = second;\n            unsafe { second.as_mut() }.prev = self.head_tail;\n            unsafe { first.as_mut() }.next = NonNull::dangling();\n            unsafe { first.as_mut() }.prev = NonNull::dangling();\n            // unwrap ok: always `Some` on non-dummy entries\n            Some(unsafe { (*first.as_ptr()).value.as_ref() }.unwrap())\n        }\n    }\n\n    /// Removes an entry from the list.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that `entry` has been pushed onto `self`\n    /// prior to this call and has not moved since then.\n    pub unsafe fn remove(&mut self, entry: &mut UnsafeListEntry<T>) {\n        rtassert!(!self.is_empty());\n        // BEFORE:\n        //     /----\\ next ---> /-----\\ next ---> /----\\\n        // ... |prev|           |entry|           |next| ...\n        //     \\----/ <--- prev \\-----/ <--- prev \\----/\n        //\n        // AFTER:\n        //     /----\\ next ---> /----\\\n        // ... |prev|           |next| ...\n        //     \\----/ <--- prev \\----/\n        let mut prev = entry.prev;\n        let mut next = entry.next;\n        // SAFETY: `prev` and `next` must meet all requirements for a mutable reference.entry\n        unsafe { prev.as_mut() }.next = next;\n        unsafe { next.as_mut() }.prev = prev;\n        entry.next = NonNull::dangling();\n        entry.prev = NonNull::dangling();\n    }\n}\n"],["2491","//! Trivial spinlock-based implementation of `sync::Mutex`.\n// FIXME: Perhaps use Intel TSX to avoid locking?\n\n#[cfg(test)]\nmod tests;\n\nuse crate::cell::UnsafeCell;\nuse crate::hint;\nuse crate::ops::{Deref, DerefMut};\nuse crate::sync::atomic::{AtomicBool, Ordering};\n\n#[derive(Default)]\npub struct SpinMutex<T> {\n    value: UnsafeCell<T>,\n    lock: AtomicBool,\n}\n\nunsafe impl<T: Send> Send for SpinMutex<T> {}\nunsafe impl<T: Send> Sync for SpinMutex<T> {}\n\npub struct SpinMutexGuard<'a, T: 'a> {\n    mutex: &'a SpinMutex<T>,\n}\n\nimpl<'a, T> !Send for SpinMutexGuard<'a, T> {}\nunsafe impl<'a, T: Sync> Sync for SpinMutexGuard<'a, T> {}\n\nimpl<T> SpinMutex<T> {\n    pub const fn new(value: T) -> Self {\n        SpinMutex { value: UnsafeCell::new(value), lock: AtomicBool::new(false) }\n    }\n\n    #[inline(always)]\n    pub fn lock(&self) -> SpinMutexGuard<'_, T> {\n        loop {\n            match self.try_lock() {\n                None => {\n                    while self.lock.load(Ordering::Relaxed) {\n                        hint::spin_loop()\n                    }\n                }\n                Some(guard) => return guard,\n            }\n        }\n    }\n\n    #[inline(always)]\n    pub fn try_lock(&self) -> Option<SpinMutexGuard<'_, T>> {\n        if self.lock.compare_exchange(false, true, Ordering::Acquire, Ordering::Acquire).is_ok() {\n            Some(SpinMutexGuard { mutex: self })\n        } else {\n            None\n        }\n    }\n}\n\n/// Lock the Mutex or return false.\npub macro try_lock_or_false($e:expr) {\n    if let Some(v) = $e.try_lock() { v } else { return false }\n}\n\nimpl<'a, T> Deref for SpinMutexGuard<'a, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        unsafe { &*self.mutex.value.get() }\n    }\n}\n\nimpl<'a, T> DerefMut for SpinMutexGuard<'a, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        unsafe { &mut *self.mutex.value.get() }\n    }\n}\n\nimpl<'a, T> Drop for SpinMutexGuard<'a, T> {\n    fn drop(&mut self) {\n        self.mutex.lock.store(false, Ordering::Release)\n    }\n}\n"],["2492","use super::*;\nuse crate::cell::Cell;\n\n/// # Safety\n/// List must be valid.\nunsafe fn assert_empty<T>(list: &mut UnsafeList<T>) {\n    assert!(unsafe { list.pop() }.is_none(), \"assertion failed: list is not empty\");\n}\n\n#[test]\nfn init_empty() {\n    unsafe {\n        assert_empty(&mut UnsafeList::<i32>::new());\n    }\n}\n\n#[test]\nfn push_pop() {\n    unsafe {\n        let mut node = UnsafeListEntry::new(1234);\n        let mut list = UnsafeList::new();\n        assert_eq!(list.push(&mut node), &1234);\n        assert_eq!(list.pop().unwrap(), &1234);\n        assert_empty(&mut list);\n    }\n}\n\n#[test]\nfn push_remove() {\n    unsafe {\n        let mut node = UnsafeListEntry::new(1234);\n        let mut list = UnsafeList::new();\n        assert_eq!(list.push(&mut node), &1234);\n        list.remove(&mut node);\n        assert_empty(&mut list);\n    }\n}\n\n#[test]\nfn push_remove_pop() {\n    unsafe {\n        let mut node1 = UnsafeListEntry::new(11);\n        let mut node2 = UnsafeListEntry::new(12);\n        let mut node3 = UnsafeListEntry::new(13);\n        let mut node4 = UnsafeListEntry::new(14);\n        let mut node5 = UnsafeListEntry::new(15);\n        let mut list = UnsafeList::new();\n        assert_eq!(list.push(&mut node1), &11);\n        assert_eq!(list.push(&mut node2), &12);\n        assert_eq!(list.push(&mut node3), &13);\n        assert_eq!(list.push(&mut node4), &14);\n        assert_eq!(list.push(&mut node5), &15);\n\n        list.remove(&mut node1);\n        assert_eq!(list.pop().unwrap(), &12);\n        list.remove(&mut node3);\n        assert_eq!(list.pop().unwrap(), &14);\n        list.remove(&mut node5);\n        assert_empty(&mut list);\n\n        assert_eq!(list.push(&mut node1), &11);\n        assert_eq!(list.pop().unwrap(), &11);\n        assert_empty(&mut list);\n\n        assert_eq!(list.push(&mut node3), &13);\n        assert_eq!(list.push(&mut node4), &14);\n        list.remove(&mut node3);\n        list.remove(&mut node4);\n        assert_empty(&mut list);\n    }\n}\n\n#[test]\nfn complex_pushes_pops() {\n    unsafe {\n        let mut node1 = UnsafeListEntry::new(1234);\n        let mut node2 = UnsafeListEntry::new(4567);\n        let mut node3 = UnsafeListEntry::new(9999);\n        let mut node4 = UnsafeListEntry::new(8642);\n        let mut list = UnsafeList::new();\n        list.push(&mut node1);\n        list.push(&mut node2);\n        assert_eq!(list.pop().unwrap(), &1234);\n        list.push(&mut node3);\n        assert_eq!(list.pop().unwrap(), &4567);\n        assert_eq!(list.pop().unwrap(), &9999);\n        assert_empty(&mut list);\n        list.push(&mut node4);\n        assert_eq!(list.pop().unwrap(), &8642);\n        assert_empty(&mut list);\n    }\n}\n\n#[test]\nfn cell() {\n    unsafe {\n        let mut node = UnsafeListEntry::new(Cell::new(0));\n        let mut list = UnsafeList::new();\n        let noderef = list.push(&mut node);\n        assert_eq!(noderef.get(), 0);\n        list.pop().unwrap().set(1);\n        assert_empty(&mut list);\n        assert_eq!(noderef.get(), 1);\n    }\n}\n"],["2493","#![allow(deprecated)]\n\nuse super::*;\nuse crate::sync::Arc;\nuse crate::thread;\nuse crate::time::Duration;\n\n#[test]\nfn sleep() {\n    let mutex = Arc::new(SpinMutex::<i32>::default());\n    let mutex2 = mutex.clone();\n    let guard = mutex.lock();\n    let t1 = thread::spawn(move || {\n        *mutex2.lock() = 1;\n    });\n\n    thread::sleep(Duration::from_millis(50));\n\n    assert_eq!(*guard, 0);\n    drop(guard);\n    t1.join().unwrap();\n    assert_eq!(*mutex.lock(), 1);\n}\n"],["2494","use super::*;\nuse crate::sync::Arc;\nuse crate::thread;\n\n#[test]\nfn queue() {\n    let wq = Arc::new(SpinMutex::<WaitVariable<()>>::default());\n    let wq2 = wq.clone();\n\n    let locked = wq.lock();\n\n    let t1 = thread::spawn(move || {\n        // if we obtain the lock, the main thread should be waiting\n        assert!(WaitQueue::notify_one(wq2.lock()).is_ok());\n    });\n\n    WaitQueue::wait(locked, || {});\n\n    t1.join().unwrap();\n}\n"],["2495","//! A simple queue implementation for synchronization primitives.\n//!\n//! This queue is used to implement condition variable and mutexes.\n//!\n//! Users of this API are expected to use the `WaitVariable<T>` type. Since\n//! that type is not `Sync`, it needs to be protected by e.g., a `SpinMutex` to\n//! allow shared access.\n//!\n//! Since userspace may send spurious wake-ups, the wakeup event state is\n//! recorded in the enclave. The wakeup event state is protected by a spinlock.\n//! The queue and associated wait state are stored in a `WaitVariable`.\n\n#[cfg(test)]\nmod tests;\n\nmod spin_mutex;\nmod unsafe_list;\n\nuse crate::num::NonZeroUsize;\nuse crate::ops::{Deref, DerefMut};\nuse crate::time::Duration;\n\nuse super::abi::thread;\nuse super::abi::usercalls;\nuse fortanix_sgx_abi::{Tcs, EV_UNPARK, WAIT_INDEFINITE};\n\npub use self::spin_mutex::{try_lock_or_false, SpinMutex, SpinMutexGuard};\nuse self::unsafe_list::{UnsafeList, UnsafeListEntry};\n\n/// An queue entry in a `WaitQueue`.\nstruct WaitEntry {\n    /// TCS address of the thread that is waiting\n    tcs: Tcs,\n    /// Whether this thread has been notified to be awoken\n    wake: bool,\n}\n\n/// Data stored with a `WaitQueue` alongside it. This ensures accesses to the\n/// queue and the data are synchronized, since the type itself is not `Sync`.\n///\n/// Consumers of this API should use a synchronization primitive for shared\n/// access, such as `SpinMutex`.\n#[derive(Default)]\npub struct WaitVariable<T> {\n    queue: WaitQueue,\n    lock: T,\n}\n\nimpl<T> WaitVariable<T> {\n    pub const fn new(var: T) -> Self {\n        WaitVariable { queue: WaitQueue::new(), lock: var }\n    }\n\n    pub fn queue_empty(&self) -> bool {\n        self.queue.is_empty()\n    }\n\n    pub fn lock_var(&self) -> &T {\n        &self.lock\n    }\n\n    pub fn lock_var_mut(&mut self) -> &mut T {\n        &mut self.lock\n    }\n}\n\n#[derive(Copy, Clone)]\npub enum NotifiedTcs {\n    Single(Tcs),\n    All { count: NonZeroUsize },\n}\n\n/// An RAII guard that will notify a set of target threads as well as unlock\n/// a mutex on drop.\npub struct WaitGuard<'a, T: 'a> {\n    mutex_guard: Option<SpinMutexGuard<'a, WaitVariable<T>>>,\n    notified_tcs: NotifiedTcs,\n}\n\n/// A queue of threads that are waiting on some synchronization primitive.\n///\n/// `UnsafeList` entries are allocated on the waiting thread's stack. This\n/// avoids any global locking that might happen in the heap allocator. This is\n/// safe because the waiting thread will not return from that stack frame until\n/// after it is notified. The notifying thread ensures to clean up any\n/// references to the list entries before sending the wakeup event.\npub struct WaitQueue {\n    // We use an inner Mutex here to protect the data in the face of spurious\n    // wakeups.\n    inner: UnsafeList<SpinMutex<WaitEntry>>,\n}\nunsafe impl Send for WaitQueue {}\n\nimpl Default for WaitQueue {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<'a, T> WaitGuard<'a, T> {\n    /// Returns which TCSes will be notified when this guard drops.\n    pub fn notified_tcs(&self) -> NotifiedTcs {\n        self.notified_tcs\n    }\n\n    /// Drop this `WaitGuard`, after dropping another `guard`.\n    pub fn drop_after<U>(self, guard: U) {\n        drop(guard);\n        drop(self);\n    }\n}\n\nimpl<'a, T> Deref for WaitGuard<'a, T> {\n    type Target = SpinMutexGuard<'a, WaitVariable<T>>;\n\n    fn deref(&self) -> &Self::Target {\n        self.mutex_guard.as_ref().unwrap()\n    }\n}\n\nimpl<'a, T> DerefMut for WaitGuard<'a, T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        self.mutex_guard.as_mut().unwrap()\n    }\n}\n\nimpl<'a, T> Drop for WaitGuard<'a, T> {\n    fn drop(&mut self) {\n        drop(self.mutex_guard.take());\n        let target_tcs = match self.notified_tcs {\n            NotifiedTcs::Single(tcs) => Some(tcs),\n            NotifiedTcs::All { .. } => None,\n        };\n        rtunwrap!(Ok, usercalls::send(EV_UNPARK, target_tcs));\n    }\n}\n\nimpl WaitQueue {\n    pub const fn new() -> Self {\n        WaitQueue { inner: UnsafeList::new() }\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.inner.is_empty()\n    }\n\n    /// Adds the calling thread to the `WaitVariable`'s wait queue, then wait\n    /// until a wakeup event.\n    ///\n    /// This function does not return until this thread has been awoken.\n    pub fn wait<T, F: FnOnce()>(mut guard: SpinMutexGuard<'_, WaitVariable<T>>, before_wait: F) {\n        // very unsafe: check requirements of UnsafeList::push\n        unsafe {\n            let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n                tcs: thread::current(),\n                wake: false,\n            }));\n            let entry = guard.queue.inner.push(&mut entry);\n            drop(guard);\n            before_wait();\n            while !entry.lock().wake {\n                // don't panic, this would invalidate `entry` during unwinding\n                let eventset = rtunwrap!(Ok, usercalls::wait(EV_UNPARK, WAIT_INDEFINITE));\n                rtassert!(eventset & EV_UNPARK == EV_UNPARK);\n            }\n        }\n    }\n\n    /// Adds the calling thread to the `WaitVariable`'s wait queue, then wait\n    /// until a wakeup event or timeout. If event was observed, returns true.\n    /// If not, it will remove the calling thread from the wait queue.\n    pub fn wait_timeout<T, F: FnOnce()>(\n        lock: &SpinMutex<WaitVariable<T>>,\n        timeout: Duration,\n        before_wait: F,\n    ) -> bool {\n        // very unsafe: check requirements of UnsafeList::push\n        unsafe {\n            let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n                tcs: thread::current(),\n                wake: false,\n            }));\n            let entry_lock = lock.lock().queue.inner.push(&mut entry);\n            before_wait();\n            usercalls::wait_timeout(EV_UNPARK, timeout, || entry_lock.lock().wake);\n            // acquire the wait queue's lock first to avoid deadlock.\n            let mut guard = lock.lock();\n            let success = entry_lock.lock().wake;\n            if !success {\n                // nobody is waking us up, so remove our entry from the wait queue.\n                guard.queue.inner.remove(&mut entry);\n            }\n            success\n        }\n    }\n\n    /// Either find the next waiter on the wait queue, or return the mutex\n    /// guard unchanged.\n    ///\n    /// If a waiter is found, a `WaitGuard` is returned which will notify the\n    /// waiter when it is dropped.\n    pub fn notify_one<T>(\n        mut guard: SpinMutexGuard<'_, WaitVariable<T>>,\n    ) -> Result<WaitGuard<'_, T>, SpinMutexGuard<'_, WaitVariable<T>>> {\n        unsafe {\n            if let Some(entry) = guard.queue.inner.pop() {\n                let mut entry_guard = entry.lock();\n                let tcs = entry_guard.tcs;\n                entry_guard.wake = true;\n                drop(entry);\n                Ok(WaitGuard { mutex_guard: Some(guard), notified_tcs: NotifiedTcs::Single(tcs) })\n            } else {\n                Err(guard)\n            }\n        }\n    }\n\n    /// Either find any and all waiters on the wait queue, or return the mutex\n    /// guard unchanged.\n    ///\n    /// If at least one waiter is found, a `WaitGuard` is returned which will\n    /// notify all waiters when it is dropped.\n    pub fn notify_all<T>(\n        mut guard: SpinMutexGuard<'_, WaitVariable<T>>,\n    ) -> Result<WaitGuard<'_, T>, SpinMutexGuard<'_, WaitVariable<T>>> {\n        unsafe {\n            let mut count = 0;\n            while let Some(entry) = guard.queue.inner.pop() {\n                count += 1;\n                let mut entry_guard = entry.lock();\n                entry_guard.wake = true;\n            }\n            if let Some(count) = NonZeroUsize::new(count) {\n                Ok(WaitGuard { mutex_guard: Some(guard), notified_tcs: NotifiedTcs::All { count } })\n            } else {\n                Err(guard)\n            }\n        }\n    }\n}\n"],["2496","use super::abi::usercalls::{alloc, raw::ByteBuffer};\nuse crate::ffi::OsString;\nuse crate::fmt;\nuse crate::slice;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sys::os_str::Buf;\nuse crate::sys_common::FromInner;\n\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx4args4ARGSE\"]\nstatic ARGS: AtomicUsize = AtomicUsize::new(0);\ntype ArgsStore = Vec<OsString>;\n\n#[cfg_attr(test, allow(dead_code))]\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    if argc != 0 {\n        let args = unsafe { alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _) };\n        let args = args\n            .iter()\n            .map(|a| OsString::from_inner(Buf { inner: a.copy_user_buffer() }))\n            .collect::<ArgsStore>();\n        ARGS.store(Box::into_raw(Box::new(args)) as _, Ordering::Relaxed);\n    }\n}\n\npub fn args() -> Args {\n    let args = unsafe { (ARGS.load(Ordering::Relaxed) as *const ArgsStore).as_ref() };\n    if let Some(args) = args { Args(args.iter()) } else { Args([].iter()) }\n}\n\npub struct Args(slice::Iter<'static, OsString>);\n\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.as_slice().fmt(f)\n    }\n}\n\nimpl Iterator for Args {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> {\n        self.0.next().cloned()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n}\n\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<OsString> {\n        self.0.next_back().cloned()\n    }\n}\n"],["2497","use fortanix_sgx_abi::Tcs;\n\nuse super::abi::thread;\n\nuse super::waitqueue::{try_lock_or_false, NotifiedTcs, SpinMutex, WaitQueue, WaitVariable};\n\npub struct Mutex {\n    inner: SpinMutex<WaitVariable<bool>>,\n}\n\npub type MovableMutex = Mutex;\n\n// Implementation according to “Operating Systems: Three Easy Pieces”, chapter 28\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        Mutex { inner: SpinMutex::new(WaitVariable::new(false)) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {}\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        let mut guard = self.inner.lock();\n        if *guard.lock_var() {\n            // Another thread has the lock, wait\n            WaitQueue::wait(guard, || {})\n        // Another thread has passed the lock to us\n        } else {\n            // We are just now obtaining the lock\n            *guard.lock_var_mut() = true;\n        }\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let guard = self.inner.lock();\n        if let Err(mut guard) = WaitQueue::notify_one(guard) {\n            // No other waiters, unlock\n            *guard.lock_var_mut() = false;\n        } else {\n            // There was a thread waiting, just pass the lock\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        let mut guard = try_lock_or_false!(self.inner);\n        if *guard.lock_var() {\n            // Another thread has the lock\n            false\n        } else {\n            // We are just now obtaining the lock\n            *guard.lock_var_mut() = true;\n            true\n        }\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n\nstruct ReentrantLock {\n    owner: Option<Tcs>,\n    count: usize,\n}\n\npub struct ReentrantMutex {\n    inner: SpinMutex<WaitVariable<ReentrantLock>>,\n}\n\nimpl ReentrantMutex {\n    pub const fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex {\n            inner: SpinMutex::new(WaitVariable::new(ReentrantLock { owner: None, count: 0 })),\n        }\n    }\n\n    #[inline]\n    pub unsafe fn init(&self) {}\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        let mut guard = self.inner.lock();\n        match guard.lock_var().owner {\n            Some(tcs) if tcs != thread::current() => {\n                // Another thread has the lock, wait\n                WaitQueue::wait(guard, || {});\n                // Another thread has passed the lock to us\n            }\n            _ => {\n                // We are just now obtaining the lock\n                guard.lock_var_mut().owner = Some(thread::current());\n                guard.lock_var_mut().count += 1;\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let mut guard = self.inner.lock();\n        if guard.lock_var().count > 1 {\n            guard.lock_var_mut().count -= 1;\n        } else {\n            match WaitQueue::notify_one(guard) {\n                Err(mut guard) => {\n                    // No other waiters, unlock\n                    guard.lock_var_mut().count = 0;\n                    guard.lock_var_mut().owner = None;\n                }\n                Ok(mut guard) => {\n                    // There was a thread waiting, just pass the lock\n                    if let NotifiedTcs::Single(tcs) = guard.notified_tcs() {\n                        guard.lock_var_mut().owner = Some(tcs)\n                    } else {\n                        unreachable!() // called notify_one\n                    }\n                }\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        let mut guard = try_lock_or_false!(self.inner);\n        match guard.lock_var().owner {\n            Some(tcs) if tcs != thread::current() => {\n                // Another thread has the lock\n                false\n            }\n            _ => {\n                // We are just now obtaining the lock\n                guard.lock_var_mut().owner = Some(thread::current());\n                guard.lock_var_mut().count += 1;\n                true\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n"],["2498","use super::*;\n\n// Verify that the byte pattern libunwind uses to initialize an RWLock is\n// equivalent to the value of RWLock::new(). If the value changes,\n// `src/UnwindRustSgx.h` in libunwind needs to be changed too.\n#[test]\nfn test_c_rwlock_initializer() {\n    #[rustfmt::skip]\n    const C_RWLOCK_INIT: &[u8] = &[\n        /* 0x00 */ 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x10 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x20 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x30 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x40 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x50 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x60 */ 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x70 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x80 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    ];\n\n    // For the test to work, we need the padding/unused bytes in RWLock to be\n    // initialized as 0. In practice, this is the case with statics.\n    static RUST_RWLOCK_INIT: RWLock = RWLock::new();\n\n    unsafe {\n        // If the assertion fails, that not necessarily an issue with the value\n        // of C_RWLOCK_INIT. It might just be an issue with the way padding\n        // bytes are initialized in the test code.\n        assert_eq!(&crate::mem::transmute_copy::<_, [u8; 144]>(&RUST_RWLOCK_INIT), C_RWLOCK_INIT);\n    };\n}\n"],["2499","#![allow(unused)]\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub use fortanix_sgx_abi::*;\n\nuse crate::num::NonZeroU64;\nuse crate::ptr::NonNull;\n\n#[repr(C)]\nstruct UsercallReturn(u64, u64);\n\nextern \"C\" {\n    fn usercall(nr: NonZeroU64, p1: u64, p2: u64, abort: u64, p3: u64, p4: u64) -> UsercallReturn;\n}\n\n/// Performs the raw usercall operation as defined in the ABI calling convention.\n///\n/// # Safety\n///\n/// The caller must ensure to pass parameters appropriate for the usercall `nr`\n/// and to observe all requirements specified in the ABI.\n///\n/// # Panics\n///\n/// Panics if `nr` is `0`.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n#[inline]\npub unsafe fn do_usercall(\n    nr: NonZeroU64,\n    p1: u64,\n    p2: u64,\n    p3: u64,\n    p4: u64,\n    abort: bool,\n) -> (u64, u64) {\n    let UsercallReturn(a, b) = unsafe { usercall(nr, p1, p2, abort as _, p3, p4) };\n    (a, b)\n}\n\ntype Register = u64;\n\ntrait RegisterArgument {\n    fn from_register(_: Register) -> Self;\n    fn into_register(self) -> Register;\n}\n\ntrait ReturnValue {\n    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self;\n}\n\nmacro_rules! define_usercalls {\n    ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:tt)*; )*) => {\n        /// Usercall numbers as per the ABI.\n        #[repr(u64)]\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n        #[allow(missing_docs, non_camel_case_types)]\n        #[non_exhaustive]\n        pub enum Usercalls {\n            #[doc(hidden)]\n            __enclave_usercalls_invalid = 0,\n            $($f,)*\n        }\n\n        $(enclave_usercalls_internal_define_usercalls!(def fn $f($($n: $t),*) $(-> $r)*);)*\n    };\n}\n\nmacro_rules! define_ra {\n    (< $i:ident > $t:ty) => {\n        impl<$i> RegisterArgument for $t {\n            fn from_register(a: Register) -> Self {\n                a as _\n            }\n            fn into_register(self) -> Register {\n                self as _\n            }\n        }\n    };\n    ($i:ty as $t:ty) => {\n        impl RegisterArgument for $t {\n            fn from_register(a: Register) -> Self {\n                a as $i as _\n            }\n            fn into_register(self) -> Register {\n                self as $i as _\n            }\n        }\n    };\n    ($t:ty) => {\n        impl RegisterArgument for $t {\n            fn from_register(a: Register) -> Self {\n                a as _\n            }\n            fn into_register(self) -> Register {\n                self as _\n            }\n        }\n    };\n}\n\ndefine_ra!(Register);\ndefine_ra!(i64);\ndefine_ra!(u32);\ndefine_ra!(u32 as i32);\ndefine_ra!(u16);\ndefine_ra!(u16 as i16);\ndefine_ra!(u8);\ndefine_ra!(u8 as i8);\ndefine_ra!(usize);\ndefine_ra!(usize as isize);\ndefine_ra!(<T> *const T);\ndefine_ra!(<T> *mut T);\n\nimpl RegisterArgument for bool {\n    fn from_register(a: Register) -> bool {\n        if a != 0 { true } else { false }\n    }\n    fn into_register(self) -> Register {\n        self as _\n    }\n}\n\nimpl<T: RegisterArgument> RegisterArgument for Option<NonNull<T>> {\n    fn from_register(a: Register) -> Option<NonNull<T>> {\n        NonNull::new(a as _)\n    }\n    fn into_register(self) -> Register {\n        self.map_or(0 as _, NonNull::as_ptr) as _\n    }\n}\n\nimpl ReturnValue for ! {\n    fn from_registers(call: &'static str, _regs: (Register, Register)) -> Self {\n        rtabort!(\"Usercall {}: did not expect to be re-entered\", call);\n    }\n}\n\nimpl ReturnValue for () {\n    fn from_registers(call: &'static str, usercall_retval: (Register, Register)) -> Self {\n        rtassert!(usercall_retval.0 == 0);\n        rtassert!(usercall_retval.1 == 0);\n        ()\n    }\n}\n\nimpl<T: RegisterArgument> ReturnValue for T {\n    fn from_registers(call: &'static str, usercall_retval: (Register, Register)) -> Self {\n        rtassert!(usercall_retval.1 == 0);\n        T::from_register(usercall_retval.0)\n    }\n}\n\nimpl<T: RegisterArgument, U: RegisterArgument> ReturnValue for (T, U) {\n    fn from_registers(_call: &'static str, regs: (Register, Register)) -> Self {\n        (T::from_register(regs.0), U::from_register(regs.1))\n    }\n}\n\nmacro_rules! return_type_is_abort {\n    (!) => {\n        true\n    };\n    ($r:ty) => {\n        false\n    };\n}\n\n// In this macro: using `$r:tt` because `$r:ty` doesn't match ! in `return_type_is_abort`\nmacro_rules! enclave_usercalls_internal_define_usercalls {\n    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty,\n                     $n3:ident: $t3:ty, $n4:ident: $t4:ty) -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    RegisterArgument::into_register($n1),\n                    RegisterArgument::into_register($n2),\n                    RegisterArgument::into_register($n3),\n                    RegisterArgument::into_register($n4),\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty, $n3:ident: $t3:ty) -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    RegisterArgument::into_register($n1),\n                    RegisterArgument::into_register($n2),\n                    RegisterArgument::into_register($n3),\n                    0,\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty) -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    RegisterArgument::into_register($n1),\n                    RegisterArgument::into_register($n2),\n                    0,0,\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident($n1:ident: $t1:ty) -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f($n1: $t1) -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    RegisterArgument::into_register($n1),\n                    0,0,0,\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident() -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f() -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    0,0,0,0,\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident($($n:ident: $t:ty),*)) => (\n        enclave_usercalls_internal_define_usercalls!(def fn $f($($n: $t),*) -> ());\n    );\n}\n\ninvoke_with_usercalls!(define_usercalls);\n"],["2500","#![allow(unused)]\n\nuse crate::cell::UnsafeCell;\nuse crate::mem;\nuse crate::ops::{CoerceUnsized, Deref, DerefMut, Index, IndexMut};\nuse crate::ptr::{self, NonNull};\nuse crate::slice;\nuse crate::slice::SliceIndex;\n\nuse super::super::mem::is_user_range;\nuse fortanix_sgx_abi::*;\n\n/// A type that can be safely read from or written to userspace.\n///\n/// Non-exhaustive list of specific requirements for reading and writing:\n/// * **Type is `Copy`** (and therefore also not `Drop`). Copies will be\n///   created when copying from/to userspace. Destructors will not be called.\n/// * **No references or Rust-style owned pointers** (`Vec`, `Arc`, etc.). When\n///   reading from userspace, references into enclave memory must not be\n///   created. Also, only enclave memory is considered managed by the Rust\n///   compiler's static analysis. When reading from userspace, there can be no\n///   guarantee that the value correctly adheres to the expectations of the\n///   type. When writing to userspace, memory addresses of data in enclave\n///   memory must not be leaked for confidentiality reasons. `User` and\n///   `UserRef` are also not allowed for the same reasons.\n/// * **No fat pointers.** When reading from userspace, the size or vtable\n///   pointer could be automatically interpreted and used by the code. When\n///   writing to userspace, memory addresses of data in enclave memory (such\n///   as vtable pointers) must not be leaked for confidentiality reasons.\n///\n/// Non-exhaustive list of specific requirements for reading from userspace:\n/// * **Any bit pattern is valid** for this type (no `enum`s). There can be no\n///   guarantee that the value correctly adheres to the expectations of the\n///   type, so any value must be valid for this type.\n///\n/// Non-exhaustive list of specific requirements for writing to userspace:\n/// * **No pointers to enclave memory.** Memory addresses of data in enclave\n///   memory must not be leaked for confidentiality reasons.\n/// * **No internal padding.** Padding might contain previously-initialized\n///   secret data stored at that memory location and must not be leaked for\n///   confidentiality reasons.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub unsafe trait UserSafeSized: Copy + Sized {}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl UserSafeSized for u8 {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl<T> UserSafeSized for FifoDescriptor<T> {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl UserSafeSized for ByteBuffer {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl UserSafeSized for Usercall {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl UserSafeSized for Return {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl<T: UserSafeSized> UserSafeSized for [T; 2] {}\n\n/// A type that can be represented in memory as one or more `UserSafeSized`s.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub unsafe trait UserSafe {\n    /// Equivalent to `mem::align_of::<Self>`.\n    fn align_of() -> usize;\n\n    /// Construct a pointer to `Self` given a memory range in user space.\n    ///\n    /// N.B., this takes a size, not a length!\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure the memory range is in user memory, is the\n    /// correct size and is correctly aligned and points to the right type.\n    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self;\n\n    /// Construct a pointer to `Self` given a memory range.\n    ///\n    /// N.B., this takes a size, not a length!\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure the memory range points to the correct type.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if:\n    ///\n    /// * the pointer is not aligned.\n    /// * the pointer is null.\n    /// * the pointed-to range does not fit in the address space.\n    /// * the pointed-to range is not in user memory.\n    unsafe fn from_raw_sized(ptr: *mut u8, size: usize) -> NonNull<Self> {\n        assert!(ptr.wrapping_add(size) >= ptr);\n        // SAFETY: The caller has guaranteed the pointer is valid\n        let ret = unsafe { Self::from_raw_sized_unchecked(ptr, size) };\n        unsafe {\n            Self::check_ptr(ret);\n            NonNull::new_unchecked(ret as _)\n        }\n    }\n\n    /// Checks if a pointer may point to `Self` in user memory.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure the memory range points to the correct type and\n    /// length (if this is a slice).\n    ///\n    /// # Panics\n    ///\n    /// This function panics if:\n    ///\n    /// * the pointer is not aligned.\n    /// * the pointer is null.\n    /// * the pointed-to range is not in user memory.\n    unsafe fn check_ptr(ptr: *const Self) {\n        let is_aligned = |p| -> bool { 0 == (p as usize) & (Self::align_of() - 1) };\n\n        assert!(is_aligned(ptr as *const u8));\n        assert!(is_user_range(ptr as _, mem::size_of_val(unsafe { &*ptr })));\n        assert!(!ptr.is_null());\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl<T: UserSafeSized> UserSafe for T {\n    fn align_of() -> usize {\n        mem::align_of::<T>()\n    }\n\n    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self {\n        assert_eq!(size, mem::size_of::<T>());\n        ptr as _\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl<T: UserSafeSized> UserSafe for [T] {\n    fn align_of() -> usize {\n        mem::align_of::<T>()\n    }\n\n    /// # Safety\n    /// Behavior is undefined if any of these conditions are violated:\n    /// * `ptr` must be [valid] for writes of `size` many bytes, and it must be\n    ///   properly aligned.\n    ///\n    /// [valid]: core::ptr#safety\n    /// # Panics\n    ///\n    /// This function panics if:\n    ///\n    /// * the element size is not a factor of the size\n    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self {\n        let elem_size = mem::size_of::<T>();\n        assert_eq!(size % elem_size, 0);\n        let len = size / elem_size;\n        // SAFETY: The caller must uphold the safety contract for `from_raw_sized_unchecked`\n        unsafe { slice::from_raw_parts_mut(ptr as _, len) }\n    }\n}\n\n/// A reference to some type in userspace memory. `&UserRef<T>` is equivalent\n/// to `&T` in enclave memory. Access to the memory is only allowed by copying\n/// to avoid TOCTTOU issues. After copying, code should make sure to completely\n/// check the value before use.\n///\n/// It is also possible to obtain a mutable reference `&mut UserRef<T>`. Unlike\n/// regular mutable references, these are not exclusive. Userspace may always\n/// write to the backing memory at any time, so it can't be assumed that there\n/// the pointed-to memory is uniquely borrowed. The two different reference types\n/// are used solely to indicate intent: a mutable reference is for writing to\n/// user memory, an immutable reference for reading from user memory.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub struct UserRef<T: ?Sized>(UnsafeCell<T>);\n/// An owned type in userspace memory. `User<T>` is equivalent to `Box<T>` in\n/// enclave memory. Access to the memory is only allowed by copying to avoid\n/// TOCTTOU issues. The user memory will be freed when the value is dropped.\n/// After copying, code should make sure to completely check the value before\n/// use.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub struct User<T: UserSafe + ?Sized>(NonNull<UserRef<T>>);\n\ntrait NewUserRef<T: ?Sized> {\n    unsafe fn new_userref(v: T) -> Self;\n}\n\nimpl<T: ?Sized> NewUserRef<*mut T> for NonNull<UserRef<T>> {\n    unsafe fn new_userref(v: *mut T) -> Self {\n        // SAFETY: The caller has guaranteed the pointer is valid\n        unsafe { NonNull::new_unchecked(v as _) }\n    }\n}\n\nimpl<T: ?Sized> NewUserRef<NonNull<T>> for NonNull<UserRef<T>> {\n    unsafe fn new_userref(v: NonNull<T>) -> Self {\n        // SAFETY: The caller has guaranteed the pointer is valid\n        unsafe { NonNull::new_userref(v.as_ptr()) }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> User<T>\nwhere\n    T: UserSafe,\n{\n    // This function returns memory that is practically uninitialized, but is\n    // not considered \"unspecified\" or \"undefined\" for purposes of an\n    // optimizing compiler. This is achieved by returning a pointer from\n    // from outside as obtained by `super::alloc`.\n    fn new_uninit_bytes(size: usize) -> Self {\n        unsafe {\n            // Mustn't call alloc with size 0.\n            let ptr = if size > 0 {\n                rtunwrap!(Ok, super::alloc(size, T::align_of())) as _\n            } else {\n                T::align_of() as _ // dangling pointer ok for size 0\n            };\n            if let Ok(v) = crate::panic::catch_unwind(|| T::from_raw_sized(ptr, size)) {\n                User(NonNull::new_userref(v))\n            } else {\n                rtabort!(\"Got invalid pointer from alloc() usercall\")\n            }\n        }\n    }\n\n    /// Copies `val` into freshly allocated space in user memory.\n    pub fn new_from_enclave(val: &T) -> Self {\n        unsafe {\n            let ret = Self::new_uninit_bytes(mem::size_of_val(val));\n            ptr::copy(\n                val as *const T as *const u8,\n                ret.0.as_ptr() as *mut u8,\n                mem::size_of_val(val),\n            );\n            ret\n        }\n    }\n\n    /// Creates an owned `User<T>` from a raw pointer.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `T`, is freeable with the `free`\n    /// usercall and the alignment of `T`, and is uniquely owned.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n        // SAFETY: the caller must uphold the safety contract for `from_raw`.\n        unsafe { T::check_ptr(ptr) };\n        User(unsafe { NonNull::new_userref(ptr) })\n    }\n\n    /// Converts this value into a raw pointer. The value will no longer be\n    /// automatically freed.\n    pub fn into_raw(self) -> *mut T {\n        let ret = self.0;\n        mem::forget(self);\n        ret.as_ptr() as _\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T> User<T>\nwhere\n    T: UserSafe,\n{\n    /// Allocate space for `T` in user memory.\n    pub fn uninitialized() -> Self {\n        Self::new_uninit_bytes(mem::size_of::<T>())\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T> User<[T]>\nwhere\n    [T]: UserSafe,\n{\n    /// Allocate space for a `[T]` of `n` elements in user memory.\n    pub fn uninitialized(n: usize) -> Self {\n        Self::new_uninit_bytes(n * mem::size_of::<T>())\n    }\n\n    /// Creates an owned `User<[T]>` from a raw thin pointer and a slice length.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `len` elements of `T`, is\n    /// freeable with the `free` usercall and the alignment of `T`, and is\n    /// uniquely owned.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range does not fit in the address space\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self {\n        User(unsafe {\n            NonNull::new_userref(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()))\n        })\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> UserRef<T>\nwhere\n    T: UserSafe,\n{\n    /// Creates a `&UserRef<[T]>` from a raw pointer.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `T`.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_ptr<'a>(ptr: *const T) -> &'a Self {\n        // SAFETY: The caller must uphold the safety contract for `from_ptr`.\n        unsafe { T::check_ptr(ptr) };\n        unsafe { &*(ptr as *const Self) }\n    }\n\n    /// Creates a `&mut UserRef<[T]>` from a raw pointer. See the struct\n    /// documentation for the nuances regarding a `&mut UserRef<T>`.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `T`.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_mut_ptr<'a>(ptr: *mut T) -> &'a mut Self {\n        // SAFETY: The caller must uphold the safety contract for `from_mut_ptr`.\n        unsafe { T::check_ptr(ptr) };\n        unsafe { &mut *(ptr as *mut Self) }\n    }\n\n    /// Copies `val` into user memory.\n    ///\n    /// # Panics\n    /// This function panics if the destination doesn't have the same size as\n    /// the source. This can happen for dynamically-sized types such as slices.\n    pub fn copy_from_enclave(&mut self, val: &T) {\n        unsafe {\n            assert_eq!(mem::size_of_val(val), mem::size_of_val(&*self.0.get()));\n            ptr::copy(\n                val as *const T as *const u8,\n                self.0.get() as *mut T as *mut u8,\n                mem::size_of_val(val),\n            );\n        }\n    }\n\n    /// Copies the value from user memory and place it into `dest`.\n    ///\n    /// # Panics\n    /// This function panics if the destination doesn't have the same size as\n    /// the source. This can happen for dynamically-sized types such as slices.\n    pub fn copy_to_enclave(&self, dest: &mut T) {\n        unsafe {\n            assert_eq!(mem::size_of_val(dest), mem::size_of_val(&*self.0.get()));\n            ptr::copy(\n                self.0.get() as *const T as *const u8,\n                dest as *mut T as *mut u8,\n                mem::size_of_val(dest),\n            );\n        }\n    }\n\n    /// Obtain a raw pointer from this reference.\n    pub fn as_raw_ptr(&self) -> *const T {\n        self as *const _ as _\n    }\n\n    /// Obtain a raw pointer from this reference.\n    pub fn as_raw_mut_ptr(&mut self) -> *mut T {\n        self as *mut _ as _\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T> UserRef<T>\nwhere\n    T: UserSafe,\n{\n    /// Copies the value from user memory into enclave memory.\n    pub fn to_enclave(&self) -> T {\n        unsafe { ptr::read(self.0.get()) }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T> UserRef<[T]>\nwhere\n    [T]: UserSafe,\n{\n    /// Creates a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `n` elements of `T`.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range does not fit in the address space\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_raw_parts<'a>(ptr: *const T, len: usize) -> &'a Self {\n        // SAFETY: The caller must uphold the safety contract for `from_raw_parts`.\n        unsafe {\n            &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *const Self)\n        }\n    }\n\n    /// Creates a `&mut UserRef<[T]>` from a raw thin pointer and a slice length.\n    /// See the struct documentation for the nuances regarding a\n    /// `&mut UserRef<T>`.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `n` elements of `T`.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range does not fit in the address space\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n        // SAFETY: The caller must uphold the safety contract for `from_raw_parts_mut`.\n        unsafe {\n            &mut *(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n        }\n    }\n\n    /// Obtain a raw pointer to the first element of this user slice.\n    pub fn as_ptr(&self) -> *const T {\n        self.0.get() as _\n    }\n\n    /// Obtain a raw pointer to the first element of this user slice.\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n        self.0.get() as _\n    }\n\n    /// Obtain the number of elements in this user slice.\n    pub fn len(&self) -> usize {\n        unsafe { (*self.0.get()).len() }\n    }\n\n    /// Copies the value from user memory and place it into `dest`. Afterwards,\n    /// `dest` will contain exactly `self.len()` elements.\n    ///\n    /// # Panics\n    /// This function panics if the destination doesn't have the same size as\n    /// the source. This can happen for dynamically-sized types such as slices.\n    pub fn copy_to_enclave_vec(&self, dest: &mut Vec<T>) {\n        if let Some(missing) = self.len().checked_sub(dest.capacity()) {\n            dest.reserve(missing)\n        }\n        // SAFETY: We reserve enough space above.\n        unsafe { dest.set_len(self.len()) };\n        self.copy_to_enclave(&mut dest[..]);\n    }\n\n    /// Copies the value from user memory into a vector in enclave memory.\n    pub fn to_enclave(&self) -> Vec<T> {\n        let mut ret = Vec::with_capacity(self.len());\n        self.copy_to_enclave_vec(&mut ret);\n        ret\n    }\n\n    /// Returns an iterator over the slice.\n    pub fn iter(&self) -> Iter<'_, T>\n    where\n        T: UserSafe, // FIXME: should be implied by [T]: UserSafe?\n    {\n        unsafe { Iter((&*self.as_raw_ptr()).iter()) }\n    }\n\n    /// Returns an iterator that allows modifying each value.\n    pub fn iter_mut(&mut self) -> IterMut<'_, T>\n    where\n        T: UserSafe, // FIXME: should be implied by [T]: UserSafe?\n    {\n        unsafe { IterMut((&mut *self.as_raw_mut_ptr()).iter_mut()) }\n    }\n}\n\n/// Immutable user slice iterator\n///\n/// This struct is created by the `iter` method on `UserRef<[T]>`.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub struct Iter<'a, T: 'a + UserSafe>(slice::Iter<'a, T>);\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n    type Item = &'a UserRef<T>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe { self.0.next().map(|e| UserRef::from_ptr(e)) }\n    }\n}\n\n/// Mutable user slice iterator\n///\n/// This struct is created by the `iter_mut` method on `UserRef<[T]>`.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub struct IterMut<'a, T: 'a + UserSafe>(slice::IterMut<'a, T>);\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n    type Item = &'a mut UserRef<T>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe { self.0.next().map(|e| UserRef::from_mut_ptr(e)) }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> Deref for User<T>\nwhere\n    T: UserSafe,\n{\n    type Target = UserRef<T>;\n\n    fn deref(&self) -> &Self::Target {\n        unsafe { &*self.0.as_ptr() }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> DerefMut for User<T>\nwhere\n    T: UserSafe,\n{\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        unsafe { &mut *self.0.as_ptr() }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> Drop for User<T>\nwhere\n    T: UserSafe,\n{\n    fn drop(&mut self) {\n        unsafe {\n            let ptr = (*self.0.as_ptr()).0.get();\n            super::free(ptr as _, mem::size_of_val(&mut *ptr), T::align_of());\n        }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: CoerceUnsized<U>, U> CoerceUnsized<UserRef<U>> for UserRef<T> {}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T, I> Index<I> for UserRef<[T]>\nwhere\n    [T]: UserSafe,\n    I: SliceIndex<[T], Output: UserSafe>,\n{\n    type Output = UserRef<I::Output>;\n\n    #[inline]\n    fn index(&self, index: I) -> &UserRef<I::Output> {\n        unsafe {\n            if let Some(slice) = index.get(&*self.as_raw_ptr()) {\n                UserRef::from_ptr(slice)\n            } else {\n                rtabort!(\"index out of range for user slice\");\n            }\n        }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T, I> IndexMut<I> for UserRef<[T]>\nwhere\n    [T]: UserSafe,\n    I: SliceIndex<[T], Output: UserSafe>,\n{\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n        unsafe {\n            if let Some(slice) = index.get_mut(&mut *self.as_raw_mut_ptr()) {\n                UserRef::from_mut_ptr(slice)\n            } else {\n                rtabort!(\"index out of range for user slice\");\n            }\n        }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl UserRef<super::raw::ByteBuffer> {\n    /// Copies the user memory range pointed to by the user `ByteBuffer` to\n    /// enclave memory.\n    ///\n    /// # Panics\n    /// This function panics if, in the user `ByteBuffer`:\n    ///\n    /// * The pointer is null\n    /// * The pointed-to range does not fit in the address space\n    /// * The pointed-to range is not in user memory\n    pub fn copy_user_buffer(&self) -> Vec<u8> {\n        unsafe {\n            let buf = self.to_enclave();\n            if buf.len > 0 {\n                User::from_raw_parts(buf.data as _, buf.len).to_enclave()\n            } else {\n                // Mustn't look at `data` or call `free` if `len` is `0`.\n                Vec::with_capacity(0)\n            }\n        }\n    }\n}\n"],["2501","use crate::cmp;\nuse crate::convert::TryFrom;\nuse crate::io::{Error as IoError, ErrorKind, IoSlice, IoSliceMut, Result as IoResult};\nuse crate::sys::rand::rdrand64;\nuse crate::time::{Duration, Instant};\n\npub(crate) mod alloc;\n#[macro_use]\npub(crate) mod raw;\n\nuse self::raw::*;\n\n/// Usercall `read`. See the ABI documentation for more information.\n///\n/// This will do a single `read` usercall and scatter the read data among\n/// `bufs`. To read to a single buffer, just pass a slice of length one.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn read(fd: Fd, bufs: &mut [IoSliceMut<'_>]) -> IoResult<usize> {\n    unsafe {\n        let total_len = bufs.iter().fold(0usize, |sum, buf| sum.saturating_add(buf.len()));\n        let mut userbuf = alloc::User::<[u8]>::uninitialized(total_len);\n        let ret_len = raw::read(fd, userbuf.as_mut_ptr(), userbuf.len()).from_sgx_result()?;\n        let userbuf = &userbuf[..ret_len];\n        let mut index = 0;\n        for buf in bufs {\n            let end = cmp::min(index + buf.len(), userbuf.len());\n            if let Some(buflen) = end.checked_sub(index) {\n                userbuf[index..end].copy_to_enclave(&mut buf[..buflen]);\n                index += buf.len();\n            } else {\n                break;\n            }\n        }\n        Ok(userbuf.len())\n    }\n}\n\n/// Usercall `read_alloc`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn read_alloc(fd: Fd) -> IoResult<Vec<u8>> {\n    unsafe {\n        let userbuf = ByteBuffer { data: crate::ptr::null_mut(), len: 0 };\n        let mut userbuf = alloc::User::new_from_enclave(&userbuf);\n        raw::read_alloc(fd, userbuf.as_raw_mut_ptr()).from_sgx_result()?;\n        Ok(userbuf.copy_user_buffer())\n    }\n}\n\n/// Usercall `write`. See the ABI documentation for more information.\n///\n/// This will do a single `write` usercall and gather the written data from\n/// `bufs`. To write from a single buffer, just pass a slice of length one.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn write(fd: Fd, bufs: &[IoSlice<'_>]) -> IoResult<usize> {\n    unsafe {\n        let total_len = bufs.iter().fold(0usize, |sum, buf| sum.saturating_add(buf.len()));\n        let mut userbuf = alloc::User::<[u8]>::uninitialized(total_len);\n        let mut index = 0;\n        for buf in bufs {\n            let end = cmp::min(index + buf.len(), userbuf.len());\n            if let Some(buflen) = end.checked_sub(index) {\n                userbuf[index..end].copy_from_enclave(&buf[..buflen]);\n                index += buf.len();\n            } else {\n                break;\n            }\n        }\n        raw::write(fd, userbuf.as_ptr(), userbuf.len()).from_sgx_result()\n    }\n}\n\n/// Usercall `flush`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn flush(fd: Fd) -> IoResult<()> {\n    unsafe { raw::flush(fd).from_sgx_result() }\n}\n\n/// Usercall `close`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn close(fd: Fd) {\n    unsafe { raw::close(fd) }\n}\n\nfn string_from_bytebuffer(buf: &alloc::UserRef<ByteBuffer>, usercall: &str, arg: &str) -> String {\n    String::from_utf8(buf.copy_user_buffer())\n        .unwrap_or_else(|_| rtabort!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n}\n\n/// Usercall `bind_stream`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n    unsafe {\n        let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n        let mut local = alloc::User::<ByteBuffer>::uninitialized();\n        let fd = raw::bind_stream(addr_user.as_ptr(), addr_user.len(), local.as_raw_mut_ptr())\n            .from_sgx_result()?;\n        let local = string_from_bytebuffer(&local, \"bind_stream\", \"local_addr\");\n        Ok((fd, local))\n    }\n}\n\n/// Usercall `accept_stream`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n    unsafe {\n        let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n        let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n        // without forcing coercion?\n        let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n        let fd = raw::accept_stream(fd, local.as_raw_mut_ptr(), peer.as_raw_mut_ptr())\n            .from_sgx_result()?;\n        let local = string_from_bytebuffer(&local, \"accept_stream\", \"local_addr\");\n        let peer = string_from_bytebuffer(&peer, \"accept_stream\", \"peer_addr\");\n        Ok((fd, local, peer))\n    }\n}\n\n/// Usercall `connect_stream`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n    unsafe {\n        let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n        let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n        let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n        // without forcing coercion?\n        let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n        let fd = raw::connect_stream(\n            addr_user.as_ptr(),\n            addr_user.len(),\n            local.as_raw_mut_ptr(),\n            peer.as_raw_mut_ptr(),\n        )\n        .from_sgx_result()?;\n        let local = string_from_bytebuffer(&local, \"connect_stream\", \"local_addr\");\n        let peer = string_from_bytebuffer(&peer, \"connect_stream\", \"peer_addr\");\n        Ok((fd, local, peer))\n    }\n}\n\n/// Usercall `launch_thread`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub unsafe fn launch_thread() -> IoResult<()> {\n    // SAFETY: The caller must uphold the safety contract for `launch_thread`.\n    unsafe { raw::launch_thread().from_sgx_result() }\n}\n\n/// Usercall `exit`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn exit(panic: bool) -> ! {\n    unsafe { raw::exit(panic) }\n}\n\n/// Usercall `wait`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn wait(event_mask: u64, mut timeout: u64) -> IoResult<u64> {\n    if timeout != WAIT_NO && timeout != WAIT_INDEFINITE {\n        // We don't want people to rely on accuracy of timeouts to make\n        // security decisions in an SGX enclave. That's why we add a random\n        // amount not exceeding +/- 10% to the timeout value to discourage\n        // people from relying on accuracy of timeouts while providing a way\n        // to make things work in other cases. Note that in the SGX threat\n        // model the enclave runner which is serving the wait usercall is not\n        // trusted to ensure accurate timeouts.\n        if let Ok(timeout_signed) = i64::try_from(timeout) {\n            let tenth = timeout_signed / 10;\n            let deviation = (rdrand64() as i64).checked_rem(tenth).unwrap_or(0);\n            timeout = timeout_signed.saturating_add(deviation) as _;\n        }\n    }\n    unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n}\n\n/// This function makes an effort to wait for a non-spurious event at least as\n/// long as `duration`. Note that in general there is no guarantee about accuracy\n/// of time and timeouts in SGX model. The enclave runner serving usercalls may\n/// lie about current time and/or ignore timeout values.\n///\n/// Once the event is observed, `should_wake_up` will be used to determine\n/// whether or not the event was spurious.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn wait_timeout<F>(event_mask: u64, duration: Duration, should_wake_up: F)\nwhere\n    F: Fn() -> bool,\n{\n    // Calls the wait usercall and checks the result. Returns true if event was\n    // returned, and false if WouldBlock/TimedOut was returned.\n    // If duration is None, it will use WAIT_NO.\n    fn wait_checked(event_mask: u64, duration: Option<Duration>) -> bool {\n        let timeout = duration.map_or(raw::WAIT_NO, |duration| {\n            cmp::min((u64::MAX - 1) as u128, duration.as_nanos()) as u64\n        });\n        match wait(event_mask, timeout) {\n            Ok(eventset) => {\n                if event_mask == 0 {\n                    rtabort!(\"expected wait() to return Err, found Ok.\");\n                }\n                rtassert!(eventset != 0 && eventset & !event_mask == 0);\n                true\n            }\n            Err(e) => {\n                rtassert!(e.kind() == ErrorKind::TimedOut || e.kind() == ErrorKind::WouldBlock);\n                false\n            }\n        }\n    }\n\n    match wait_checked(event_mask, Some(duration)) {\n        false => return,                    // timed out\n        true if should_wake_up() => return, // woken up\n        true => {}                          // spurious event\n    }\n\n    // Drain all cached events.\n    // Note that `event_mask != 0` is implied if we get here.\n    loop {\n        match wait_checked(event_mask, None) {\n            false => break,                     // no more cached events\n            true if should_wake_up() => return, // woken up\n            true => {}                          // spurious event\n        }\n    }\n\n    // Continue waiting, but take note of time spent waiting so we don't wait\n    // forever. We intentionally don't call `Instant::now()` before this point\n    // to avoid the cost of the `insecure_time` usercall in case there are no\n    // spurious wakeups.\n\n    let start = Instant::now();\n    let mut remaining = duration;\n    loop {\n        match wait_checked(event_mask, Some(remaining)) {\n            false => return,                    // timed out\n            true if should_wake_up() => return, // woken up\n            true => {}                          // spurious event\n        }\n        remaining = match duration.checked_sub(start.elapsed()) {\n            Some(remaining) => remaining,\n            None => break,\n        }\n    }\n}\n\n/// Usercall `send`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {\n    unsafe { raw::send(event_set, tcs).from_sgx_result() }\n}\n\n/// Usercall `insecure_time`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn insecure_time() -> Duration {\n    let t = unsafe { raw::insecure_time() };\n    Duration::new(t / 1_000_000_000, (t % 1_000_000_000) as _)\n}\n\n/// Usercall `alloc`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn alloc(size: usize, alignment: usize) -> IoResult<*mut u8> {\n    unsafe { raw::alloc(size, alignment).from_sgx_result() }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n#[doc(inline)]\npub use self::raw::free;\n\nfn check_os_error(err: Result) -> i32 {\n    // FIXME: not sure how to make sure all variants of Error are covered\n    if err == Error::NotFound as _\n        || err == Error::PermissionDenied as _\n        || err == Error::ConnectionRefused as _\n        || err == Error::ConnectionReset as _\n        || err == Error::ConnectionAborted as _\n        || err == Error::NotConnected as _\n        || err == Error::AddrInUse as _\n        || err == Error::AddrNotAvailable as _\n        || err == Error::BrokenPipe as _\n        || err == Error::AlreadyExists as _\n        || err == Error::WouldBlock as _\n        || err == Error::InvalidInput as _\n        || err == Error::InvalidData as _\n        || err == Error::TimedOut as _\n        || err == Error::WriteZero as _\n        || err == Error::Interrupted as _\n        || err == Error::Other as _\n        || err == Error::UnexpectedEof as _\n        || ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&err)\n    {\n        err\n    } else {\n        rtabort!(\"Usercall: returned invalid error value {}\", err)\n    }\n}\n\ntrait FromSgxResult {\n    type Return;\n\n    fn from_sgx_result(self) -> IoResult<Self::Return>;\n}\n\nimpl<T> FromSgxResult for (Result, T) {\n    type Return = T;\n\n    fn from_sgx_result(self) -> IoResult<Self::Return> {\n        if self.0 == RESULT_SUCCESS {\n            Ok(self.1)\n        } else {\n            Err(IoError::from_raw_os_error(check_os_error(self.0)))\n        }\n    }\n}\n\nimpl FromSgxResult for Result {\n    type Return = ();\n\n    fn from_sgx_result(self) -> IoResult<Self::Return> {\n        if self == RESULT_SUCCESS {\n            Ok(())\n        } else {\n            Err(IoError::from_raw_os_error(check_os_error(self)))\n        }\n    }\n}\n"],["2502","use super::usercalls::alloc::UserRef;\nuse crate::cmp;\nuse crate::io::{self, Write};\nuse crate::mem;\n\nextern \"C\" {\n    fn take_debug_panic_buf_ptr() -> *mut u8;\n    static DEBUG: u8;\n}\n\npub(crate) struct SgxPanicOutput(Option<&'static mut UserRef<[u8]>>);\n\nfn empty_user_slice() -> &'static mut UserRef<[u8]> {\n    unsafe { UserRef::from_raw_parts_mut(1 as *mut u8, 0) }\n}\n\nimpl SgxPanicOutput {\n    pub(crate) fn new() -> Option<Self> {\n        if unsafe { DEBUG == 0 } { None } else { Some(SgxPanicOutput(None)) }\n    }\n\n    fn init(&mut self) -> &mut &'static mut UserRef<[u8]> {\n        self.0.get_or_insert_with(|| unsafe {\n            let ptr = take_debug_panic_buf_ptr();\n            if ptr.is_null() { empty_user_slice() } else { UserRef::from_raw_parts_mut(ptr, 1024) }\n        })\n    }\n}\n\nimpl Write for SgxPanicOutput {\n    fn write(&mut self, src: &[u8]) -> io::Result<usize> {\n        let dst = mem::replace(self.init(), empty_user_slice());\n        let written = cmp::min(src.len(), dst.len());\n        dst[..written].copy_from_enclave(&src[..written]);\n        self.0 = Some(&mut dst[written..]);\n        Ok(written)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n"],["2503","use super::mem;\nuse crate::slice::from_raw_parts;\n\nconst R_X86_64_RELATIVE: u32 = 8;\n\n#[repr(packed)]\nstruct Rela<T> {\n    offset: T,\n    info: T,\n    addend: T,\n}\n\npub fn relocate_elf_rela() {\n    extern \"C\" {\n        static RELA: u64;\n        static RELACOUNT: usize;\n    }\n\n    if unsafe { RELACOUNT } == 0 {\n        return;\n    } // unsafe ok: link-time constant\n\n    let relas = unsafe {\n        from_raw_parts::<Rela<u64>>(mem::rel_ptr(RELA), RELACOUNT) // unsafe ok: link-time constant\n    };\n    for rela in relas {\n        if rela.info != (/*0 << 32 |*/R_X86_64_RELATIVE as u64) {\n            rtabort!(\"Invalid relocation\");\n        }\n        unsafe { *mem::rel_ptr_mut::<*const ()>(rela.offset) = mem::rel_ptr(rela.addend) };\n    }\n}\n"],["2504","#![cfg_attr(test, allow(unused))] // RT initialization logic is not compiled for test\n\nuse crate::io::Write;\nuse core::sync::atomic::{AtomicUsize, Ordering};\n\n// runtime features\npub(super) mod panic;\nmod reloc;\n\n// library features\npub mod mem;\npub mod thread;\npub mod tls;\n#[macro_use]\npub mod usercalls;\n\n#[cfg(not(test))]\nglobal_asm!(include_str!(\"entry.S\"), options(att_syntax));\n\n#[repr(C)]\nstruct EntryReturn(u64, u64);\n\n#[cfg(not(test))]\n#[no_mangle]\nunsafe extern \"C\" fn tcs_init(secondary: bool) {\n    // Be very careful when changing this code: it runs before the binary has been\n    // relocated. Any indirect accesses to symbols will likely fail.\n    const UNINIT: usize = 0;\n    const BUSY: usize = 1;\n    const DONE: usize = 2;\n    // Three-state spin-lock\n    static RELOC_STATE: AtomicUsize = AtomicUsize::new(UNINIT);\n\n    if secondary && RELOC_STATE.load(Ordering::Relaxed) != DONE {\n        rtabort!(\"Entered secondary TCS before main TCS!\")\n    }\n\n    // Try to atomically swap UNINIT with BUSY. The returned state can be:\n    match RELOC_STATE.compare_exchange(UNINIT, BUSY, Ordering::Acquire, Ordering::Acquire) {\n        // This thread just obtained the lock and other threads will observe BUSY\n        Ok(_) => {\n            reloc::relocate_elf_rela();\n            RELOC_STATE.store(DONE, Ordering::Release);\n        }\n        // We need to wait until the initialization is done.\n        Err(BUSY) => {\n            while RELOC_STATE.load(Ordering::Acquire) == BUSY {\n                core::hint::spin_loop();\n            }\n        }\n        // Initialization is done.\n        Err(DONE) => {}\n        _ => unreachable!(),\n    }\n}\n\n// FIXME: this item should only exist if this is linked into an executable\n// (main function exists). If this is a library, the crate author should be\n// able to specify this\n#[cfg(not(test))]\n#[no_mangle]\nextern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> EntryReturn {\n    // FIXME: how to support TLS in library mode?\n    let tls = Box::new(tls::Tls::new());\n    let tls_guard = unsafe { tls.activate() };\n\n    if secondary {\n        let join_notifier = super::thread::Thread::entry();\n        drop(tls_guard);\n        drop(join_notifier);\n\n        EntryReturn(0, 0)\n    } else {\n        extern \"C\" {\n            fn main(argc: isize, argv: *const *const u8) -> isize;\n        }\n\n        // check entry is being called according to ABI\n        rtassert!(p3 == 0);\n        rtassert!(p4 == 0);\n        rtassert!(p5 == 0);\n\n        unsafe {\n            // The actual types of these arguments are `p1: *const Arg, p2:\n            // usize`. We can't currently customize the argument list of Rust's\n            // main function, so we pass these in as the standard pointer-sized\n            // values in `argc` and `argv`.\n            let ret = main(p2 as _, p1 as _);\n            exit_with_code(ret)\n        }\n    }\n}\n\npub(super) fn exit_with_code(code: isize) -> ! {\n    if code != 0 {\n        if let Some(mut out) = panic::SgxPanicOutput::new() {\n            let _ = write!(out, \"Exited with status code {}\", code);\n        }\n    }\n    usercalls::exit(code != 0);\n}\n\n#[cfg(not(test))]\n#[no_mangle]\nextern \"C\" fn abort_reentry() -> ! {\n    usercalls::exit(false)\n}\n"],["2505","mod sync_bitset;\n\nuse self::sync_bitset::*;\nuse crate::cell::Cell;\nuse crate::mem;\nuse crate::num::NonZeroUsize;\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\n\n#[cfg(target_pointer_width = \"64\")]\nconst USIZE_BITS: usize = 64;\nconst TLS_KEYS: usize = 128; // Same as POSIX minimum\nconst TLS_KEYS_BITSET_SIZE: usize = (TLS_KEYS + (USIZE_BITS - 1)) / USIZE_BITS;\n\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx3abi3tls14TLS_KEY_IN_USEE\"]\nstatic TLS_KEY_IN_USE: SyncBitset = SYNC_BITSET_INIT;\nmacro_rules! dup {\n    ((* $($exp:tt)*) $($val:tt)*) => (dup!( ($($exp)*) $($val)* $($val)* ));\n    (() $($val:tt)*) => ([$($val),*])\n}\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx3abi3tls14TLS_DESTRUCTORE\"]\nstatic TLS_DESTRUCTOR: [AtomicUsize; TLS_KEYS] = dup!((* * * * * * *) (AtomicUsize::new(0)));\n\nextern \"C\" {\n    fn get_tls_ptr() -> *const u8;\n    fn set_tls_ptr(tls: *const u8);\n}\n\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct Key(NonZeroUsize);\n\nimpl Key {\n    fn to_index(self) -> usize {\n        self.0.get() - 1\n    }\n\n    fn from_index(index: usize) -> Self {\n        Key(NonZeroUsize::new(index + 1).unwrap())\n    }\n\n    pub fn as_usize(self) -> usize {\n        self.0.get()\n    }\n\n    pub fn from_usize(index: usize) -> Self {\n        Key(NonZeroUsize::new(index).unwrap())\n    }\n}\n\n#[repr(C)]\npub struct Tls {\n    data: [Cell<*mut u8>; TLS_KEYS],\n}\n\npub struct ActiveTls<'a> {\n    tls: &'a Tls,\n}\n\nimpl<'a> Drop for ActiveTls<'a> {\n    fn drop(&mut self) {\n        let value_with_destructor = |key: usize| {\n            let ptr = TLS_DESTRUCTOR[key].load(Ordering::Relaxed);\n            unsafe { mem::transmute::<_, Option<unsafe extern \"C\" fn(*mut u8)>>(ptr) }\n                .map(|dtor| (&self.tls.data[key], dtor))\n        };\n\n        let mut any_non_null_dtor = true;\n        while any_non_null_dtor {\n            any_non_null_dtor = false;\n            for (value, dtor) in TLS_KEY_IN_USE.iter().filter_map(&value_with_destructor) {\n                let value = value.replace(ptr::null_mut());\n                if !value.is_null() {\n                    any_non_null_dtor = true;\n                    unsafe { dtor(value) }\n                }\n            }\n        }\n    }\n}\n\nimpl Tls {\n    pub fn new() -> Tls {\n        Tls { data: dup!((* * * * * * *) (Cell::new(ptr::null_mut()))) }\n    }\n\n    pub unsafe fn activate(&self) -> ActiveTls<'_> {\n        // FIXME: Needs safety information. See entry.S for `set_tls_ptr` definition.\n        unsafe { set_tls_ptr(self as *const Tls as _) };\n        ActiveTls { tls: self }\n    }\n\n    #[allow(unused)]\n    pub unsafe fn activate_persistent(self: Box<Self>) {\n        // FIXME: Needs safety information. See entry.S for `set_tls_ptr` definition.\n        unsafe { set_tls_ptr((&*self) as *const Tls as _) };\n        mem::forget(self);\n    }\n\n    unsafe fn current<'a>() -> &'a Tls {\n        // FIXME: Needs safety information. See entry.S for `set_tls_ptr` definition.\n        unsafe { &*(get_tls_ptr() as *const Tls) }\n    }\n\n    pub fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n        let index = if let Some(index) = TLS_KEY_IN_USE.set() {\n            index\n        } else {\n            rtabort!(\"TLS limit exceeded\")\n        };\n        TLS_DESTRUCTOR[index].store(dtor.map_or(0, |f| f as usize), Ordering::Relaxed);\n        Key::from_index(index)\n    }\n\n    pub fn set(key: Key, value: *mut u8) {\n        let index = key.to_index();\n        rtassert!(TLS_KEY_IN_USE.get(index));\n        unsafe { Self::current() }.data[index].set(value);\n    }\n\n    pub fn get(key: Key) -> *mut u8 {\n        let index = key.to_index();\n        rtassert!(TLS_KEY_IN_USE.get(index));\n        unsafe { Self::current() }.data[index].get()\n    }\n\n    pub fn destroy(key: Key) {\n        TLS_KEY_IN_USE.clear(key.to_index());\n    }\n}\n"],["2506","#[cfg(test)]\nmod tests;\n\nuse super::{TLS_KEYS_BITSET_SIZE, USIZE_BITS};\nuse crate::iter::{Enumerate, Peekable};\nuse crate::slice::Iter;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\n\n/// A bitset that can be used synchronously.\npub(super) struct SyncBitset([AtomicUsize; TLS_KEYS_BITSET_SIZE]);\n\npub(super) const SYNC_BITSET_INIT: SyncBitset =\n    SyncBitset([AtomicUsize::new(0), AtomicUsize::new(0)]);\n\nimpl SyncBitset {\n    pub fn get(&self, index: usize) -> bool {\n        let (hi, lo) = Self::split(index);\n        (self.0[hi].load(Ordering::Relaxed) & lo) != 0\n    }\n\n    /// Not atomic.\n    pub fn iter(&self) -> SyncBitsetIter<'_> {\n        SyncBitsetIter { iter: self.0.iter().enumerate().peekable(), elem_idx: 0 }\n    }\n\n    pub fn clear(&self, index: usize) {\n        let (hi, lo) = Self::split(index);\n        self.0[hi].fetch_and(!lo, Ordering::Relaxed);\n    }\n\n    /// Sets any unset bit. Not atomic. Returns `None` if all bits were\n    /// observed to be set.\n    pub fn set(&self) -> Option<usize> {\n        'elems: for (idx, elem) in self.0.iter().enumerate() {\n            let mut current = elem.load(Ordering::Relaxed);\n            loop {\n                if 0 == !current {\n                    continue 'elems;\n                }\n                let trailing_ones = (!current).trailing_zeros() as usize;\n                match elem.compare_exchange(\n                    current,\n                    current | (1 << trailing_ones),\n                    Ordering::AcqRel,\n                    Ordering::Relaxed,\n                ) {\n                    Ok(_) => return Some(idx * USIZE_BITS + trailing_ones),\n                    Err(previous) => current = previous,\n                }\n            }\n        }\n        None\n    }\n\n    fn split(index: usize) -> (usize, usize) {\n        (index / USIZE_BITS, 1 << (index % USIZE_BITS))\n    }\n}\n\npub(super) struct SyncBitsetIter<'a> {\n    iter: Peekable<Enumerate<Iter<'a, AtomicUsize>>>,\n    elem_idx: usize,\n}\n\nimpl<'a> Iterator for SyncBitsetIter<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        self.iter.peek().cloned().and_then(|(idx, elem)| {\n            let elem = elem.load(Ordering::Relaxed);\n            let low_mask = (1 << self.elem_idx) - 1;\n            let next = elem & !low_mask;\n            let next_idx = next.trailing_zeros() as usize;\n            self.elem_idx = next_idx + 1;\n            if self.elem_idx >= 64 {\n                self.elem_idx = 0;\n                self.iter.next();\n            }\n            match next_idx {\n                64 => self.next(),\n                _ => Some(idx * USIZE_BITS + next_idx),\n            }\n        })\n    }\n}\n"],["2507","use super::*;\n\nfn test_data(bitset: [usize; 2], bit_indices: &[usize]) {\n    let set = SyncBitset([AtomicUsize::new(bitset[0]), AtomicUsize::new(bitset[1])]);\n    assert_eq!(set.iter().collect::<Vec<_>>(), bit_indices);\n    for &i in bit_indices {\n        assert!(set.get(i));\n    }\n}\n\n#[test]\nfn iter() {\n    test_data([0b0110_1001, 0], &[0, 3, 5, 6]);\n    test_data([0x8000_0000_0000_0000, 0x8000_0000_0000_0001], &[63, 64, 127]);\n    test_data([0, 0], &[]);\n}\n\n#[test]\nfn set_get_clear() {\n    let set = SYNC_BITSET_INIT;\n    let key = set.set().unwrap();\n    assert!(set.get(key));\n    set.clear(key);\n    assert!(!set.get(key));\n}\n"],["2508","use fortanix_sgx_abi::Tcs;\n\n/// Gets the ID for the current thread. The ID is guaranteed to be unique among\n/// all currently running threads in the enclave, and it is guaranteed to be\n/// constant for the lifetime of the thread. More specifically for SGX, there\n/// is a one-to-one correspondence of the ID to the address of the TCS.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn current() -> Tcs {\n    extern \"C\" {\n        fn get_tcs_addr() -> Tcs;\n    }\n    unsafe { get_tcs_addr() }\n}\n"],["2509","// Do not remove inline: will result in relocation failure\n#[inline(always)]\npub(crate) unsafe fn rel_ptr<T>(offset: u64) -> *const T {\n    (image_base() + offset) as *const T\n}\n\n// Do not remove inline: will result in relocation failure\n#[inline(always)]\npub(crate) unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n    (image_base() + offset) as *mut T\n}\n\nextern \"C\" {\n    static ENCLAVE_SIZE: usize;\n    static HEAP_BASE: u64;\n    static HEAP_SIZE: usize;\n}\n\n/// Returns the base memory address of the heap\npub(crate) fn heap_base() -> *const u8 {\n    unsafe { rel_ptr_mut(HEAP_BASE) }\n}\n\n/// Returns the size of the heap\npub(crate) fn heap_size() -> usize {\n    unsafe { HEAP_SIZE }\n}\n\n// Do not remove inline: will result in relocation failure\n// For the same reason we use inline ASM here instead of an extern static to\n// locate the base\n/// Returns address at which current enclave is loaded.\n#[inline(always)]\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn image_base() -> u64 {\n    let base: u64;\n    unsafe {\n        asm!(\n            \"lea IMAGE_BASE(%rip), {}\",\n            lateout(reg) base,\n            options(att_syntax, nostack, preserves_flags, nomem, pure),\n        )\n    };\n    base\n}\n\n/// Returns `true` if the specified memory range is in the enclave.\n///\n/// For safety, this function also checks whether the range given overflows,\n/// returning `false` if so.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n    let start = p as usize;\n\n    // Subtract one from `len` when calculating `end` in case `p + len` is\n    // exactly at the end of addressable memory (`p + len` would overflow, but\n    // the range is still valid).\n    let end = if len == 0 {\n        start\n    } else if let Some(end) = start.checked_add(len - 1) {\n        end\n    } else {\n        return false;\n    };\n\n    let base = image_base() as usize;\n    start >= base && end <= base + (unsafe { ENCLAVE_SIZE } - 1) // unsafe ok: link-time constant\n}\n\n/// Returns `true` if the specified memory range is in userspace.\n///\n/// For safety, this function also checks whether the range given overflows,\n/// returning `false` if so.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn is_user_range(p: *const u8, len: usize) -> bool {\n    let start = p as usize;\n\n    // Subtract one from `len` when calculating `end` in case `p + len` is\n    // exactly at the end of addressable memory (`p + len` would overflow, but\n    // the range is still valid).\n    let end = if len == 0 {\n        start\n    } else if let Some(end) = start.checked_add(len - 1) {\n        end\n    } else {\n        return false;\n    };\n\n    let base = image_base() as usize;\n    end < base || start > base + (unsafe { ENCLAVE_SIZE } - 1) // unsafe ok: link-time constant\n}\n"],["2510","use crate::io::prelude::*;\n\nuse super::{Command, Output, Stdio};\nuse crate::io::ErrorKind;\nuse crate::str;\n\n// FIXME(#10380) these tests should not all be ignored on android.\n\n#[test]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn smoke() {\n    let p = if cfg!(target_os = \"windows\") {\n        Command::new(\"cmd\").args(&[\"/C\", \"exit 0\"]).spawn()\n    } else {\n        Command::new(\"true\").spawn()\n    };\n    assert!(p.is_ok());\n    let mut p = p.unwrap();\n    assert!(p.wait().unwrap().success());\n}\n\n#[test]\n#[cfg_attr(target_os = \"android\", ignore)]\nfn smoke_failure() {\n    match Command::new(\"if-this-is-a-binary-then-the-world-has-ended\").spawn() {\n        Ok(..) => panic!(),\n        Err(..) => {}\n    }\n}\n\n#[test]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn exit_reported_right() {\n    let p = if cfg!(target_os = \"windows\") {\n        Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).spawn()\n    } else {\n        Command::new(\"false\").spawn()\n    };\n    assert!(p.is_ok());\n    let mut p = p.unwrap();\n    assert!(p.wait().unwrap().code() == Some(1));\n    drop(p.wait());\n}\n\n#[test]\n#[cfg(unix)]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn signal_reported_right() {\n    use crate::os::unix::process::ExitStatusExt;\n\n    let mut p =\n        Command::new(\"/bin/sh\").arg(\"-c\").arg(\"read a\").stdin(Stdio::piped()).spawn().unwrap();\n    p.kill().unwrap();\n    match p.wait().unwrap().signal() {\n        Some(9) => {}\n        result => panic!(\"not terminated by signal 9 (instead, {:?})\", result),\n    }\n}\n\npub fn run_output(mut cmd: Command) -> String {\n    let p = cmd.spawn();\n    assert!(p.is_ok());\n    let mut p = p.unwrap();\n    assert!(p.stdout.is_some());\n    let mut ret = String::new();\n    p.stdout.as_mut().unwrap().read_to_string(&mut ret).unwrap();\n    assert!(p.wait().unwrap().success());\n    return ret;\n}\n\n#[test]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn stdout_works() {\n    if cfg!(target_os = \"windows\") {\n        let mut cmd = Command::new(\"cmd\");\n        cmd.args(&[\"/C\", \"echo foobar\"]).stdout(Stdio::piped());\n        assert_eq!(run_output(cmd), \"foobar\\r\\n\");\n    } else {\n        let mut cmd = Command::new(\"echo\");\n        cmd.arg(\"foobar\").stdout(Stdio::piped());\n        assert_eq!(run_output(cmd), \"foobar\\n\");\n    }\n}\n\n#[test]\n#[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\nfn set_current_dir_works() {\n    let mut cmd = Command::new(\"/bin/sh\");\n    cmd.arg(\"-c\").arg(\"pwd\").current_dir(\"/\").stdout(Stdio::piped());\n    assert_eq!(run_output(cmd), \"/\\n\");\n}\n\n#[test]\n#[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\nfn stdin_works() {\n    let mut p = Command::new(\"/bin/sh\")\n        .arg(\"-c\")\n        .arg(\"read line; echo $line\")\n        .stdin(Stdio::piped())\n        .stdout(Stdio::piped())\n        .spawn()\n        .unwrap();\n    p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n    drop(p.stdin.take());\n    let mut out = String::new();\n    p.stdout.as_mut().unwrap().read_to_string(&mut out).unwrap();\n    assert!(p.wait().unwrap().success());\n    assert_eq!(out, \"foobar\\n\");\n}\n\n#[test]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn test_process_status() {\n    let mut status = if cfg!(target_os = \"windows\") {\n        Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).status().unwrap()\n    } else {\n        Command::new(\"false\").status().unwrap()\n    };\n    assert!(status.code() == Some(1));\n\n    status = if cfg!(target_os = \"windows\") {\n        Command::new(\"cmd\").args(&[\"/C\", \"exit 0\"]).status().unwrap()\n    } else {\n        Command::new(\"true\").status().unwrap()\n    };\n    assert!(status.success());\n}\n\n#[test]\nfn test_process_output_fail_to_start() {\n    match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n        Err(e) => assert_eq!(e.kind(), ErrorKind::NotFound),\n        Ok(..) => panic!(),\n    }\n}\n\n#[test]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn test_process_output_output() {\n    let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n        Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).output().unwrap()\n    } else {\n        Command::new(\"echo\").arg(\"hello\").output().unwrap()\n    };\n    let output_str = str::from_utf8(&stdout).unwrap();\n\n    assert!(status.success());\n    assert_eq!(output_str.trim().to_string(), \"hello\");\n    assert_eq!(stderr, Vec::new());\n}\n\n#[test]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn test_process_output_error() {\n    let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n        Command::new(\"cmd\").args(&[\"/C\", \"mkdir .\"]).output().unwrap()\n    } else {\n        Command::new(\"mkdir\").arg(\"./\").output().unwrap()\n    };\n\n    assert!(status.code() == Some(1));\n    assert_eq!(stdout, Vec::new());\n    assert!(!stderr.is_empty());\n}\n\n#[test]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn test_finish_once() {\n    let mut prog = if cfg!(target_os = \"windows\") {\n        Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).spawn().unwrap()\n    } else {\n        Command::new(\"false\").spawn().unwrap()\n    };\n    assert!(prog.wait().unwrap().code() == Some(1));\n}\n\n#[test]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn test_finish_twice() {\n    let mut prog = if cfg!(target_os = \"windows\") {\n        Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).spawn().unwrap()\n    } else {\n        Command::new(\"false\").spawn().unwrap()\n    };\n    assert!(prog.wait().unwrap().code() == Some(1));\n    assert!(prog.wait().unwrap().code() == Some(1));\n}\n\n#[test]\n#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\nfn test_wait_with_output_once() {\n    let prog = if cfg!(target_os = \"windows\") {\n        Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).stdout(Stdio::piped()).spawn().unwrap()\n    } else {\n        Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped()).spawn().unwrap()\n    };\n\n    let Output { status, stdout, stderr } = prog.wait_with_output().unwrap();\n    let output_str = str::from_utf8(&stdout).unwrap();\n\n    assert!(status.success());\n    assert_eq!(output_str.trim().to_string(), \"hello\");\n    assert_eq!(stderr, Vec::new());\n}\n\n#[cfg(all(unix, not(target_os = \"android\")))]\npub fn env_cmd() -> Command {\n    Command::new(\"env\")\n}\n#[cfg(target_os = \"android\")]\npub fn env_cmd() -> Command {\n    let mut cmd = Command::new(\"/system/bin/sh\");\n    cmd.arg(\"-c\").arg(\"set\");\n    cmd\n}\n\n#[cfg(windows)]\npub fn env_cmd() -> Command {\n    let mut cmd = Command::new(\"cmd\");\n    cmd.arg(\"/c\").arg(\"set\");\n    cmd\n}\n\n#[test]\n#[cfg_attr(target_os = \"vxworks\", ignore)]\nfn test_override_env() {\n    use crate::env;\n\n    // In some build environments (such as chrooted Nix builds), `env` can\n    // only be found in the explicitly-provided PATH env variable, not in\n    // default places such as /bin or /usr/bin. So we need to pass through\n    // PATH to our sub-process.\n    let mut cmd = env_cmd();\n    cmd.env_clear().env(\"RUN_TEST_NEW_ENV\", \"123\");\n    if let Some(p) = env::var_os(\"PATH\") {\n        cmd.env(\"PATH\", &p);\n    }\n    let result = cmd.output().unwrap();\n    let output = String::from_utf8_lossy(&result.stdout).to_string();\n\n    assert!(\n        output.contains(\"RUN_TEST_NEW_ENV=123\"),\n        \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n        output\n    );\n}\n\n#[test]\n#[cfg_attr(target_os = \"vxworks\", ignore)]\nfn test_add_to_env() {\n    let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n    let output = String::from_utf8_lossy(&result.stdout).to_string();\n\n    assert!(\n        output.contains(\"RUN_TEST_NEW_ENV=123\"),\n        \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n        output\n    );\n}\n\n#[test]\n#[cfg_attr(target_os = \"vxworks\", ignore)]\nfn test_capture_env_at_spawn() {\n    use crate::env;\n\n    let mut cmd = env_cmd();\n    cmd.env(\"RUN_TEST_NEW_ENV1\", \"123\");\n\n    // This variable will not be present if the environment has already\n    // been captured above.\n    env::set_var(\"RUN_TEST_NEW_ENV2\", \"456\");\n    let result = cmd.output().unwrap();\n    env::remove_var(\"RUN_TEST_NEW_ENV2\");\n\n    let output = String::from_utf8_lossy(&result.stdout).to_string();\n\n    assert!(\n        output.contains(\"RUN_TEST_NEW_ENV1=123\"),\n        \"didn't find RUN_TEST_NEW_ENV1 inside of:\\n\\n{}\",\n        output\n    );\n    assert!(\n        output.contains(\"RUN_TEST_NEW_ENV2=456\"),\n        \"didn't find RUN_TEST_NEW_ENV2 inside of:\\n\\n{}\",\n        output\n    );\n}\n\n// Regression tests for #30858.\n#[test]\nfn test_interior_nul_in_progname_is_error() {\n    match Command::new(\"has-some-\\0\\0s-inside\").spawn() {\n        Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n        Ok(_) => panic!(),\n    }\n}\n\n#[test]\nfn test_interior_nul_in_arg_is_error() {\n    match Command::new(\"echo\").arg(\"has-some-\\0\\0s-inside\").spawn() {\n        Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n        Ok(_) => panic!(),\n    }\n}\n\n#[test]\nfn test_interior_nul_in_args_is_error() {\n    match Command::new(\"echo\").args(&[\"has-some-\\0\\0s-inside\"]).spawn() {\n        Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n        Ok(_) => panic!(),\n    }\n}\n\n#[test]\nfn test_interior_nul_in_current_dir_is_error() {\n    match Command::new(\"echo\").current_dir(\"has-some-\\0\\0s-inside\").spawn() {\n        Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n        Ok(_) => panic!(),\n    }\n}\n\n// Regression tests for #30862.\n#[test]\n#[cfg_attr(target_os = \"vxworks\", ignore)]\nfn test_interior_nul_in_env_key_is_error() {\n    match env_cmd().env(\"has-some-\\0\\0s-inside\", \"value\").spawn() {\n        Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n        Ok(_) => panic!(),\n    }\n}\n\n#[test]\n#[cfg_attr(target_os = \"vxworks\", ignore)]\nfn test_interior_nul_in_env_value_is_error() {\n    match env_cmd().env(\"key\", \"has-some-\\0\\0s-inside\").spawn() {\n        Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n        Ok(_) => panic!(),\n    }\n}\n\n/// Tests that process creation flags work by debugging a process.\n/// Other creation flags make it hard or impossible to detect\n/// behavioral changes in the process.\n#[test]\n#[cfg(windows)]\nfn test_creation_flags() {\n    use crate::os::windows::process::CommandExt;\n    use crate::sys::c::{BOOL, DWORD, INFINITE};\n    #[repr(C, packed)]\n    struct DEBUG_EVENT {\n        pub event_code: DWORD,\n        pub process_id: DWORD,\n        pub thread_id: DWORD,\n        // This is a union in the real struct, but we don't\n        // need this data for the purposes of this test.\n        pub _junk: [u8; 164],\n    }\n\n    extern \"system\" {\n        fn WaitForDebugEvent(lpDebugEvent: *mut DEBUG_EVENT, dwMilliseconds: DWORD) -> BOOL;\n        fn ContinueDebugEvent(\n            dwProcessId: DWORD,\n            dwThreadId: DWORD,\n            dwContinueStatus: DWORD,\n        ) -> BOOL;\n    }\n\n    const DEBUG_PROCESS: DWORD = 1;\n    const EXIT_PROCESS_DEBUG_EVENT: DWORD = 5;\n    const DBG_EXCEPTION_NOT_HANDLED: DWORD = 0x80010001;\n\n    let mut child =\n        Command::new(\"cmd\").creation_flags(DEBUG_PROCESS).stdin(Stdio::piped()).spawn().unwrap();\n    child.stdin.take().unwrap().write_all(b\"exit\\r\\n\").unwrap();\n    let mut events = 0;\n    let mut event = DEBUG_EVENT { event_code: 0, process_id: 0, thread_id: 0, _junk: [0; 164] };\n    loop {\n        if unsafe { WaitForDebugEvent(&mut event as *mut DEBUG_EVENT, INFINITE) } == 0 {\n            panic!(\"WaitForDebugEvent failed!\");\n        }\n        events += 1;\n\n        if event.event_code == EXIT_PROCESS_DEBUG_EVENT {\n            break;\n        }\n\n        if unsafe {\n            ContinueDebugEvent(event.process_id, event.thread_id, DBG_EXCEPTION_NOT_HANDLED)\n        } == 0\n        {\n            panic!(\"ContinueDebugEvent failed!\");\n        }\n    }\n    assert!(events > 0);\n}\n\n#[test]\nfn test_command_implements_send_sync() {\n    fn take_send_sync_type<T: Send + Sync>(_: T) {}\n    take_send_sync_type(Command::new(\"\"))\n}\n\n// Ensure that starting a process with no environment variables works on Windows.\n// This will fail if the environment block is ill-formed.\n#[test]\n#[cfg(windows)]\nfn env_empty() {\n    let p = Command::new(\"cmd\").args(&[\"/C\", \"exit 0\"]).env_clear().spawn();\n    assert!(p.is_ok());\n}\n"],["2511","use super::Error;\nuse crate::fmt;\n\n#[derive(Debug, PartialEq)]\nstruct A;\n#[derive(Debug, PartialEq)]\nstruct B;\n\nimpl fmt::Display for A {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"A\")\n    }\n}\nimpl fmt::Display for B {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"B\")\n    }\n}\n\nimpl Error for A {}\nimpl Error for B {}\n\n#[test]\nfn downcasting() {\n    let mut a = A;\n    let a = &mut a as &mut (dyn Error + 'static);\n    assert_eq!(a.downcast_ref::<A>(), Some(&A));\n    assert_eq!(a.downcast_ref::<B>(), None);\n    assert_eq!(a.downcast_mut::<A>(), Some(&mut A));\n    assert_eq!(a.downcast_mut::<B>(), None);\n\n    let a: Box<dyn Error> = Box::new(A);\n    match a.downcast::<B>() {\n        Ok(..) => panic!(\"expected error\"),\n        Err(e) => assert_eq!(*e.downcast::<A>().unwrap(), A),\n    }\n}\n"],["2512","use crate::{\n    lazy::{Lazy, SyncLazy, SyncOnceCell},\n    panic,\n    sync::{\n        atomic::{AtomicUsize, Ordering::SeqCst},\n        mpsc::channel,\n        Mutex,\n    },\n    thread,\n};\n\n#[test]\nfn lazy_default() {\n    static CALLED: AtomicUsize = AtomicUsize::new(0);\n\n    struct Foo(u8);\n    impl Default for Foo {\n        fn default() -> Self {\n            CALLED.fetch_add(1, SeqCst);\n            Foo(42)\n        }\n    }\n\n    let lazy: Lazy<Mutex<Foo>> = <_>::default();\n\n    assert_eq!(CALLED.load(SeqCst), 0);\n\n    assert_eq!(lazy.lock().unwrap().0, 42);\n    assert_eq!(CALLED.load(SeqCst), 1);\n\n    lazy.lock().unwrap().0 = 21;\n\n    assert_eq!(lazy.lock().unwrap().0, 21);\n    assert_eq!(CALLED.load(SeqCst), 1);\n}\n\n#[test]\nfn lazy_poisoning() {\n    let x: Lazy<String> = Lazy::new(|| panic!(\"kaboom\"));\n    for _ in 0..2 {\n        let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n        assert!(res.is_err());\n    }\n}\n\nfn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n    thread::spawn(f).join().unwrap()\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn sync_once_cell() {\n    static ONCE_CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n\n    assert!(ONCE_CELL.get().is_none());\n\n    spawn_and_wait(|| {\n        ONCE_CELL.get_or_init(|| 92);\n        assert_eq!(ONCE_CELL.get(), Some(&92));\n    });\n\n    ONCE_CELL.get_or_init(|| panic!(\"Kabom!\"));\n    assert_eq!(ONCE_CELL.get(), Some(&92));\n}\n\n#[test]\nfn sync_once_cell_get_mut() {\n    let mut c = SyncOnceCell::new();\n    assert!(c.get_mut().is_none());\n    c.set(90).unwrap();\n    *c.get_mut().unwrap() += 2;\n    assert_eq!(c.get_mut(), Some(&mut 92));\n}\n\n#[test]\nfn sync_once_cell_get_unchecked() {\n    let c = SyncOnceCell::new();\n    c.set(92).unwrap();\n    unsafe {\n        assert_eq!(c.get_unchecked(), &92);\n    }\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn sync_once_cell_drop() {\n    static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n    struct Dropper;\n    impl Drop for Dropper {\n        fn drop(&mut self) {\n            DROP_CNT.fetch_add(1, SeqCst);\n        }\n    }\n\n    let x = SyncOnceCell::new();\n    spawn_and_wait(move || {\n        x.get_or_init(|| Dropper);\n        assert_eq!(DROP_CNT.load(SeqCst), 0);\n        drop(x);\n    });\n\n    assert_eq!(DROP_CNT.load(SeqCst), 1);\n}\n\n#[test]\nfn sync_once_cell_drop_empty() {\n    let x = SyncOnceCell::<String>::new();\n    drop(x);\n}\n\n#[test]\nfn clone() {\n    let s = SyncOnceCell::new();\n    let c = s.clone();\n    assert!(c.get().is_none());\n\n    s.set(\"hello\".to_string()).unwrap();\n    let c = s.clone();\n    assert_eq!(c.get().map(String::as_str), Some(\"hello\"));\n}\n\n#[test]\nfn get_or_try_init() {\n    let cell: SyncOnceCell<String> = SyncOnceCell::new();\n    assert!(cell.get().is_none());\n\n    let res = panic::catch_unwind(|| cell.get_or_try_init(|| -> Result<_, ()> { panic!() }));\n    assert!(res.is_err());\n    assert!(!cell.is_initialized());\n    assert!(cell.get().is_none());\n\n    assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n\n    assert_eq!(cell.get_or_try_init(|| Ok::<_, ()>(\"hello\".to_string())), Ok(&\"hello\".to_string()));\n    assert_eq!(cell.get(), Some(&\"hello\".to_string()));\n}\n\n#[test]\nfn from_impl() {\n    assert_eq!(SyncOnceCell::from(\"value\").get(), Some(&\"value\"));\n    assert_ne!(SyncOnceCell::from(\"foo\").get(), Some(&\"bar\"));\n}\n\n#[test]\nfn partialeq_impl() {\n    assert!(SyncOnceCell::from(\"value\") == SyncOnceCell::from(\"value\"));\n    assert!(SyncOnceCell::from(\"foo\") != SyncOnceCell::from(\"bar\"));\n\n    assert!(SyncOnceCell::<String>::new() == SyncOnceCell::new());\n    assert!(SyncOnceCell::<String>::new() != SyncOnceCell::from(\"value\".to_owned()));\n}\n\n#[test]\nfn into_inner() {\n    let cell: SyncOnceCell<String> = SyncOnceCell::new();\n    assert_eq!(cell.into_inner(), None);\n    let cell = SyncOnceCell::new();\n    cell.set(\"hello\".to_string()).unwrap();\n    assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn sync_lazy_new() {\n    static CALLED: AtomicUsize = AtomicUsize::new(0);\n    static SYNC_LAZY: SyncLazy<i32> = SyncLazy::new(|| {\n        CALLED.fetch_add(1, SeqCst);\n        92\n    });\n\n    assert_eq!(CALLED.load(SeqCst), 0);\n\n    spawn_and_wait(|| {\n        let y = *SYNC_LAZY - 30;\n        assert_eq!(y, 62);\n        assert_eq!(CALLED.load(SeqCst), 1);\n    });\n\n    let y = *SYNC_LAZY - 30;\n    assert_eq!(y, 62);\n    assert_eq!(CALLED.load(SeqCst), 1);\n}\n\n#[test]\nfn sync_lazy_default() {\n    static CALLED: AtomicUsize = AtomicUsize::new(0);\n\n    struct Foo(u8);\n    impl Default for Foo {\n        fn default() -> Self {\n            CALLED.fetch_add(1, SeqCst);\n            Foo(42)\n        }\n    }\n\n    let lazy: SyncLazy<Mutex<Foo>> = <_>::default();\n\n    assert_eq!(CALLED.load(SeqCst), 0);\n\n    assert_eq!(lazy.lock().unwrap().0, 42);\n    assert_eq!(CALLED.load(SeqCst), 1);\n\n    lazy.lock().unwrap().0 = 21;\n\n    assert_eq!(lazy.lock().unwrap().0, 21);\n    assert_eq!(CALLED.load(SeqCst), 1);\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn static_sync_lazy() {\n    static XS: SyncLazy<Vec<i32>> = SyncLazy::new(|| {\n        let mut xs = Vec::new();\n        xs.push(1);\n        xs.push(2);\n        xs.push(3);\n        xs\n    });\n\n    spawn_and_wait(|| {\n        assert_eq!(&*XS, &vec![1, 2, 3]);\n    });\n\n    assert_eq!(&*XS, &vec![1, 2, 3]);\n}\n\n#[test]\nfn static_sync_lazy_via_fn() {\n    fn xs() -> &'static Vec<i32> {\n        static XS: SyncOnceCell<Vec<i32>> = SyncOnceCell::new();\n        XS.get_or_init(|| {\n            let mut xs = Vec::new();\n            xs.push(1);\n            xs.push(2);\n            xs.push(3);\n            xs\n        })\n    }\n    assert_eq!(xs(), &vec![1, 2, 3]);\n}\n\n#[test]\nfn sync_lazy_poisoning() {\n    let x: SyncLazy<String> = SyncLazy::new(|| panic!(\"kaboom\"));\n    for _ in 0..2 {\n        let res = panic::catch_unwind(|| x.len());\n        assert!(res.is_err());\n    }\n}\n\n#[test]\nfn is_sync_send() {\n    fn assert_traits<T: Send + Sync>() {}\n    assert_traits::<SyncOnceCell<String>>();\n    assert_traits::<SyncLazy<String>>();\n}\n\n#[test]\nfn eval_once_macro() {\n    macro_rules! eval_once {\n        (|| -> $ty:ty {\n            $($body:tt)*\n        }) => {{\n            static ONCE_CELL: SyncOnceCell<$ty> = SyncOnceCell::new();\n            fn init() -> $ty {\n                $($body)*\n            }\n            ONCE_CELL.get_or_init(init)\n        }};\n    }\n\n    let fib: &'static Vec<i32> = eval_once! {\n        || -> Vec<i32> {\n            let mut res = vec![1, 1];\n            for i in 0..10 {\n                let next = res[i] + res[i + 1];\n                res.push(next);\n            }\n            res\n        }\n    };\n    assert_eq!(fib[5], 8)\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n    static ONCE_CELL: SyncOnceCell<String> = SyncOnceCell::new();\n\n    let n_readers = 10;\n    let n_writers = 3;\n    const MSG: &str = \"Hello, World\";\n\n    let (tx, rx) = channel();\n\n    for _ in 0..n_readers {\n        let tx = tx.clone();\n        thread::spawn(move || {\n            loop {\n                if let Some(msg) = ONCE_CELL.get() {\n                    tx.send(msg).unwrap();\n                    break;\n                }\n                #[cfg(target_env = \"sgx\")]\n                crate::thread::yield_now();\n            }\n        });\n    }\n    for _ in 0..n_writers {\n        thread::spawn(move || {\n            let _ = ONCE_CELL.set(MSG.to_owned());\n        });\n    }\n\n    for _ in 0..n_readers {\n        let msg = rx.recv().unwrap();\n        assert_eq!(msg, MSG);\n    }\n}\n\n#[test]\nfn dropck() {\n    let cell = SyncOnceCell::new();\n    {\n        let s = String::new();\n        cell.set(&s).unwrap();\n    }\n}\n"],["2513","use crate::f64::consts;\nuse crate::num::FpCategory as Fp;\nuse crate::num::*;\n\n#[test]\nfn test_num_f64() {\n    test_num(10f64, 2f64);\n}\n\n#[test]\nfn test_min_nan() {\n    assert_eq!(f64::NAN.min(2.0), 2.0);\n    assert_eq!(2.0f64.min(f64::NAN), 2.0);\n}\n\n#[test]\nfn test_max_nan() {\n    assert_eq!(f64::NAN.max(2.0), 2.0);\n    assert_eq!(2.0f64.max(f64::NAN), 2.0);\n}\n\n#[test]\nfn test_nan() {\n    let nan: f64 = f64::NAN;\n    assert!(nan.is_nan());\n    assert!(!nan.is_infinite());\n    assert!(!nan.is_finite());\n    assert!(!nan.is_normal());\n    assert!(nan.is_sign_positive());\n    assert!(!nan.is_sign_negative());\n    assert_eq!(Fp::Nan, nan.classify());\n}\n\n#[test]\nfn test_infinity() {\n    let inf: f64 = f64::INFINITY;\n    assert!(inf.is_infinite());\n    assert!(!inf.is_finite());\n    assert!(inf.is_sign_positive());\n    assert!(!inf.is_sign_negative());\n    assert!(!inf.is_nan());\n    assert!(!inf.is_normal());\n    assert_eq!(Fp::Infinite, inf.classify());\n}\n\n#[test]\nfn test_neg_infinity() {\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert!(neg_inf.is_infinite());\n    assert!(!neg_inf.is_finite());\n    assert!(!neg_inf.is_sign_positive());\n    assert!(neg_inf.is_sign_negative());\n    assert!(!neg_inf.is_nan());\n    assert!(!neg_inf.is_normal());\n    assert_eq!(Fp::Infinite, neg_inf.classify());\n}\n\n#[test]\nfn test_zero() {\n    let zero: f64 = 0.0f64;\n    assert_eq!(0.0, zero);\n    assert!(!zero.is_infinite());\n    assert!(zero.is_finite());\n    assert!(zero.is_sign_positive());\n    assert!(!zero.is_sign_negative());\n    assert!(!zero.is_nan());\n    assert!(!zero.is_normal());\n    assert_eq!(Fp::Zero, zero.classify());\n}\n\n#[test]\nfn test_neg_zero() {\n    let neg_zero: f64 = -0.0;\n    assert_eq!(0.0, neg_zero);\n    assert!(!neg_zero.is_infinite());\n    assert!(neg_zero.is_finite());\n    assert!(!neg_zero.is_sign_positive());\n    assert!(neg_zero.is_sign_negative());\n    assert!(!neg_zero.is_nan());\n    assert!(!neg_zero.is_normal());\n    assert_eq!(Fp::Zero, neg_zero.classify());\n}\n\n#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n#[test]\nfn test_one() {\n    let one: f64 = 1.0f64;\n    assert_eq!(1.0, one);\n    assert!(!one.is_infinite());\n    assert!(one.is_finite());\n    assert!(one.is_sign_positive());\n    assert!(!one.is_sign_negative());\n    assert!(!one.is_nan());\n    assert!(one.is_normal());\n    assert_eq!(Fp::Normal, one.classify());\n}\n\n#[test]\nfn test_is_nan() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert!(nan.is_nan());\n    assert!(!0.0f64.is_nan());\n    assert!(!5.3f64.is_nan());\n    assert!(!(-10.732f64).is_nan());\n    assert!(!inf.is_nan());\n    assert!(!neg_inf.is_nan());\n}\n\n#[test]\nfn test_is_infinite() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert!(!nan.is_infinite());\n    assert!(inf.is_infinite());\n    assert!(neg_inf.is_infinite());\n    assert!(!0.0f64.is_infinite());\n    assert!(!42.8f64.is_infinite());\n    assert!(!(-109.2f64).is_infinite());\n}\n\n#[test]\nfn test_is_finite() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert!(!nan.is_finite());\n    assert!(!inf.is_finite());\n    assert!(!neg_inf.is_finite());\n    assert!(0.0f64.is_finite());\n    assert!(42.8f64.is_finite());\n    assert!((-109.2f64).is_finite());\n}\n\n#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n#[test]\nfn test_is_normal() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    let zero: f64 = 0.0f64;\n    let neg_zero: f64 = -0.0;\n    assert!(!nan.is_normal());\n    assert!(!inf.is_normal());\n    assert!(!neg_inf.is_normal());\n    assert!(!zero.is_normal());\n    assert!(!neg_zero.is_normal());\n    assert!(1f64.is_normal());\n    assert!(1e-307f64.is_normal());\n    assert!(!1e-308f64.is_normal());\n}\n\n#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n#[test]\nfn test_classify() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    let zero: f64 = 0.0f64;\n    let neg_zero: f64 = -0.0;\n    assert_eq!(nan.classify(), Fp::Nan);\n    assert_eq!(inf.classify(), Fp::Infinite);\n    assert_eq!(neg_inf.classify(), Fp::Infinite);\n    assert_eq!(zero.classify(), Fp::Zero);\n    assert_eq!(neg_zero.classify(), Fp::Zero);\n    assert_eq!(1e-307f64.classify(), Fp::Normal);\n    assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n}\n\n#[test]\nfn test_floor() {\n    assert_approx_eq!(1.0f64.floor(), 1.0f64);\n    assert_approx_eq!(1.3f64.floor(), 1.0f64);\n    assert_approx_eq!(1.5f64.floor(), 1.0f64);\n    assert_approx_eq!(1.7f64.floor(), 1.0f64);\n    assert_approx_eq!(0.0f64.floor(), 0.0f64);\n    assert_approx_eq!((-0.0f64).floor(), -0.0f64);\n    assert_approx_eq!((-1.0f64).floor(), -1.0f64);\n    assert_approx_eq!((-1.3f64).floor(), -2.0f64);\n    assert_approx_eq!((-1.5f64).floor(), -2.0f64);\n    assert_approx_eq!((-1.7f64).floor(), -2.0f64);\n}\n\n#[test]\nfn test_ceil() {\n    assert_approx_eq!(1.0f64.ceil(), 1.0f64);\n    assert_approx_eq!(1.3f64.ceil(), 2.0f64);\n    assert_approx_eq!(1.5f64.ceil(), 2.0f64);\n    assert_approx_eq!(1.7f64.ceil(), 2.0f64);\n    assert_approx_eq!(0.0f64.ceil(), 0.0f64);\n    assert_approx_eq!((-0.0f64).ceil(), -0.0f64);\n    assert_approx_eq!((-1.0f64).ceil(), -1.0f64);\n    assert_approx_eq!((-1.3f64).ceil(), -1.0f64);\n    assert_approx_eq!((-1.5f64).ceil(), -1.0f64);\n    assert_approx_eq!((-1.7f64).ceil(), -1.0f64);\n}\n\n#[test]\nfn test_round() {\n    assert_approx_eq!(1.0f64.round(), 1.0f64);\n    assert_approx_eq!(1.3f64.round(), 1.0f64);\n    assert_approx_eq!(1.5f64.round(), 2.0f64);\n    assert_approx_eq!(1.7f64.round(), 2.0f64);\n    assert_approx_eq!(0.0f64.round(), 0.0f64);\n    assert_approx_eq!((-0.0f64).round(), -0.0f64);\n    assert_approx_eq!((-1.0f64).round(), -1.0f64);\n    assert_approx_eq!((-1.3f64).round(), -1.0f64);\n    assert_approx_eq!((-1.5f64).round(), -2.0f64);\n    assert_approx_eq!((-1.7f64).round(), -2.0f64);\n}\n\n#[test]\nfn test_trunc() {\n    assert_approx_eq!(1.0f64.trunc(), 1.0f64);\n    assert_approx_eq!(1.3f64.trunc(), 1.0f64);\n    assert_approx_eq!(1.5f64.trunc(), 1.0f64);\n    assert_approx_eq!(1.7f64.trunc(), 1.0f64);\n    assert_approx_eq!(0.0f64.trunc(), 0.0f64);\n    assert_approx_eq!((-0.0f64).trunc(), -0.0f64);\n    assert_approx_eq!((-1.0f64).trunc(), -1.0f64);\n    assert_approx_eq!((-1.3f64).trunc(), -1.0f64);\n    assert_approx_eq!((-1.5f64).trunc(), -1.0f64);\n    assert_approx_eq!((-1.7f64).trunc(), -1.0f64);\n}\n\n#[test]\nfn test_fract() {\n    assert_approx_eq!(1.0f64.fract(), 0.0f64);\n    assert_approx_eq!(1.3f64.fract(), 0.3f64);\n    assert_approx_eq!(1.5f64.fract(), 0.5f64);\n    assert_approx_eq!(1.7f64.fract(), 0.7f64);\n    assert_approx_eq!(0.0f64.fract(), 0.0f64);\n    assert_approx_eq!((-0.0f64).fract(), -0.0f64);\n    assert_approx_eq!((-1.0f64).fract(), -0.0f64);\n    assert_approx_eq!((-1.3f64).fract(), -0.3f64);\n    assert_approx_eq!((-1.5f64).fract(), -0.5f64);\n    assert_approx_eq!((-1.7f64).fract(), -0.7f64);\n}\n\n#[test]\nfn test_abs() {\n    assert_eq!(f64::INFINITY.abs(), f64::INFINITY);\n    assert_eq!(1f64.abs(), 1f64);\n    assert_eq!(0f64.abs(), 0f64);\n    assert_eq!((-0f64).abs(), 0f64);\n    assert_eq!((-1f64).abs(), 1f64);\n    assert_eq!(f64::NEG_INFINITY.abs(), f64::INFINITY);\n    assert_eq!((1f64 / f64::NEG_INFINITY).abs(), 0f64);\n    assert!(f64::NAN.abs().is_nan());\n}\n\n#[test]\nfn test_signum() {\n    assert_eq!(f64::INFINITY.signum(), 1f64);\n    assert_eq!(1f64.signum(), 1f64);\n    assert_eq!(0f64.signum(), 1f64);\n    assert_eq!((-0f64).signum(), -1f64);\n    assert_eq!((-1f64).signum(), -1f64);\n    assert_eq!(f64::NEG_INFINITY.signum(), -1f64);\n    assert_eq!((1f64 / f64::NEG_INFINITY).signum(), -1f64);\n    assert!(f64::NAN.signum().is_nan());\n}\n\n#[test]\nfn test_is_sign_positive() {\n    assert!(f64::INFINITY.is_sign_positive());\n    assert!(1f64.is_sign_positive());\n    assert!(0f64.is_sign_positive());\n    assert!(!(-0f64).is_sign_positive());\n    assert!(!(-1f64).is_sign_positive());\n    assert!(!f64::NEG_INFINITY.is_sign_positive());\n    assert!(!(1f64 / f64::NEG_INFINITY).is_sign_positive());\n    assert!(f64::NAN.is_sign_positive());\n    assert!(!(-f64::NAN).is_sign_positive());\n}\n\n#[test]\nfn test_is_sign_negative() {\n    assert!(!f64::INFINITY.is_sign_negative());\n    assert!(!1f64.is_sign_negative());\n    assert!(!0f64.is_sign_negative());\n    assert!((-0f64).is_sign_negative());\n    assert!((-1f64).is_sign_negative());\n    assert!(f64::NEG_INFINITY.is_sign_negative());\n    assert!((1f64 / f64::NEG_INFINITY).is_sign_negative());\n    assert!(!f64::NAN.is_sign_negative());\n    assert!((-f64::NAN).is_sign_negative());\n}\n\n#[test]\nfn test_mul_add() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n    assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n    assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n    assert_approx_eq!(3.4f64.mul_add(-0.0, 5.6), 5.6);\n    assert!(nan.mul_add(7.8, 9.0).is_nan());\n    assert_eq!(inf.mul_add(7.8, 9.0), inf);\n    assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n    assert_eq!(8.9f64.mul_add(inf, 3.2), inf);\n    assert_eq!((-3.2f64).mul_add(2.4, neg_inf), neg_inf);\n}\n\n#[test]\nfn test_recip() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_eq!(1.0f64.recip(), 1.0);\n    assert_eq!(2.0f64.recip(), 0.5);\n    assert_eq!((-0.4f64).recip(), -2.5);\n    assert_eq!(0.0f64.recip(), inf);\n    assert!(nan.recip().is_nan());\n    assert_eq!(inf.recip(), 0.0);\n    assert_eq!(neg_inf.recip(), 0.0);\n}\n\n#[test]\nfn test_powi() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_eq!(1.0f64.powi(1), 1.0);\n    assert_approx_eq!((-3.1f64).powi(2), 9.61);\n    assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n    assert_eq!(8.3f64.powi(0), 1.0);\n    assert!(nan.powi(2).is_nan());\n    assert_eq!(inf.powi(3), inf);\n    assert_eq!(neg_inf.powi(2), inf);\n}\n\n#[test]\nfn test_powf() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_eq!(1.0f64.powf(1.0), 1.0);\n    assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n    assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n    assert_approx_eq!((-3.1f64).powf(2.0), 9.61);\n    assert_approx_eq!(5.9f64.powf(-2.0), 0.028727);\n    assert_eq!(8.3f64.powf(0.0), 1.0);\n    assert!(nan.powf(2.0).is_nan());\n    assert_eq!(inf.powf(2.0), inf);\n    assert_eq!(neg_inf.powf(3.0), neg_inf);\n}\n\n#[test]\nfn test_sqrt_domain() {\n    assert!(f64::NAN.sqrt().is_nan());\n    assert!(f64::NEG_INFINITY.sqrt().is_nan());\n    assert!((-1.0f64).sqrt().is_nan());\n    assert_eq!((-0.0f64).sqrt(), -0.0);\n    assert_eq!(0.0f64.sqrt(), 0.0);\n    assert_eq!(1.0f64.sqrt(), 1.0);\n    assert_eq!(f64::INFINITY.sqrt(), f64::INFINITY);\n}\n\n#[test]\nfn test_exp() {\n    assert_eq!(1.0, 0.0f64.exp());\n    assert_approx_eq!(2.718282, 1.0f64.exp());\n    assert_approx_eq!(148.413159, 5.0f64.exp());\n\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    let nan: f64 = f64::NAN;\n    assert_eq!(inf, inf.exp());\n    assert_eq!(0.0, neg_inf.exp());\n    assert!(nan.exp().is_nan());\n}\n\n#[test]\nfn test_exp2() {\n    assert_eq!(32.0, 5.0f64.exp2());\n    assert_eq!(1.0, 0.0f64.exp2());\n\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    let nan: f64 = f64::NAN;\n    assert_eq!(inf, inf.exp2());\n    assert_eq!(0.0, neg_inf.exp2());\n    assert!(nan.exp2().is_nan());\n}\n\n#[test]\nfn test_ln() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n    assert!(nan.ln().is_nan());\n    assert_eq!(inf.ln(), inf);\n    assert!(neg_inf.ln().is_nan());\n    assert!((-2.3f64).ln().is_nan());\n    assert_eq!((-0.0f64).ln(), neg_inf);\n    assert_eq!(0.0f64.ln(), neg_inf);\n    assert_approx_eq!(4.0f64.ln(), 1.386294);\n}\n\n#[test]\nfn test_log() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_eq!(10.0f64.log(10.0), 1.0);\n    assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n    assert_eq!(1.0f64.exp().log(1.0f64.exp()), 1.0);\n    assert!(1.0f64.log(1.0).is_nan());\n    assert!(1.0f64.log(-13.9).is_nan());\n    assert!(nan.log(2.3).is_nan());\n    assert_eq!(inf.log(10.0), inf);\n    assert!(neg_inf.log(8.8).is_nan());\n    assert!((-2.3f64).log(0.1).is_nan());\n    assert_eq!((-0.0f64).log(2.0), neg_inf);\n    assert_eq!(0.0f64.log(7.0), neg_inf);\n}\n\n#[test]\nfn test_log2() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_approx_eq!(10.0f64.log2(), 3.321928);\n    assert_approx_eq!(2.3f64.log2(), 1.201634);\n    assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n    assert!(nan.log2().is_nan());\n    assert_eq!(inf.log2(), inf);\n    assert!(neg_inf.log2().is_nan());\n    assert!((-2.3f64).log2().is_nan());\n    assert_eq!((-0.0f64).log2(), neg_inf);\n    assert_eq!(0.0f64.log2(), neg_inf);\n}\n\n#[test]\nfn test_log10() {\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_eq!(10.0f64.log10(), 1.0);\n    assert_approx_eq!(2.3f64.log10(), 0.361728);\n    assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n    assert_eq!(1.0f64.log10(), 0.0);\n    assert!(nan.log10().is_nan());\n    assert_eq!(inf.log10(), inf);\n    assert!(neg_inf.log10().is_nan());\n    assert!((-2.3f64).log10().is_nan());\n    assert_eq!((-0.0f64).log10(), neg_inf);\n    assert_eq!(0.0f64.log10(), neg_inf);\n}\n\n#[test]\nfn test_to_degrees() {\n    let pi: f64 = consts::PI;\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_eq!(0.0f64.to_degrees(), 0.0);\n    assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n    assert_eq!(pi.to_degrees(), 180.0);\n    assert!(nan.to_degrees().is_nan());\n    assert_eq!(inf.to_degrees(), inf);\n    assert_eq!(neg_inf.to_degrees(), neg_inf);\n}\n\n#[test]\nfn test_to_radians() {\n    let pi: f64 = consts::PI;\n    let nan: f64 = f64::NAN;\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    assert_eq!(0.0f64.to_radians(), 0.0);\n    assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n    assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n    assert_eq!(180.0f64.to_radians(), pi);\n    assert!(nan.to_radians().is_nan());\n    assert_eq!(inf.to_radians(), inf);\n    assert_eq!(neg_inf.to_radians(), neg_inf);\n}\n\n#[test]\nfn test_asinh() {\n    assert_eq!(0.0f64.asinh(), 0.0f64);\n    assert_eq!((-0.0f64).asinh(), -0.0f64);\n\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    let nan: f64 = f64::NAN;\n    assert_eq!(inf.asinh(), inf);\n    assert_eq!(neg_inf.asinh(), neg_inf);\n    assert!(nan.asinh().is_nan());\n    assert!((-0.0f64).asinh().is_sign_negative());\n    // issue 63271\n    assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n    assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n    // regression test for the catastrophic cancellation fixed in 72486\n    assert_approx_eq!((-67452098.07139316f64).asinh(), -18.72007542627454439398548429400083);\n}\n\n#[test]\nfn test_acosh() {\n    assert_eq!(1.0f64.acosh(), 0.0f64);\n    assert!(0.999f64.acosh().is_nan());\n\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    let nan: f64 = f64::NAN;\n    assert_eq!(inf.acosh(), inf);\n    assert!(neg_inf.acosh().is_nan());\n    assert!(nan.acosh().is_nan());\n    assert_approx_eq!(2.0f64.acosh(), 1.31695789692481670862504634730796844f64);\n    assert_approx_eq!(3.0f64.acosh(), 1.76274717403908605046521864995958461f64);\n}\n\n#[test]\nfn test_atanh() {\n    assert_eq!(0.0f64.atanh(), 0.0f64);\n    assert_eq!((-0.0f64).atanh(), -0.0f64);\n\n    let inf: f64 = f64::INFINITY;\n    let neg_inf: f64 = f64::NEG_INFINITY;\n    let nan: f64 = f64::NAN;\n    assert_eq!(1.0f64.atanh(), inf);\n    assert_eq!((-1.0f64).atanh(), neg_inf);\n    assert!(2f64.atanh().atanh().is_nan());\n    assert!((-2f64).atanh().atanh().is_nan());\n    assert!(inf.atanh().is_nan());\n    assert!(neg_inf.atanh().is_nan());\n    assert!(nan.atanh().is_nan());\n    assert_approx_eq!(0.5f64.atanh(), 0.54930614433405484569762261846126285f64);\n    assert_approx_eq!((-0.5f64).atanh(), -0.54930614433405484569762261846126285f64);\n}\n\n#[test]\nfn test_real_consts() {\n    use super::consts;\n    let pi: f64 = consts::PI;\n    let frac_pi_2: f64 = consts::FRAC_PI_2;\n    let frac_pi_3: f64 = consts::FRAC_PI_3;\n    let frac_pi_4: f64 = consts::FRAC_PI_4;\n    let frac_pi_6: f64 = consts::FRAC_PI_6;\n    let frac_pi_8: f64 = consts::FRAC_PI_8;\n    let frac_1_pi: f64 = consts::FRAC_1_PI;\n    let frac_2_pi: f64 = consts::FRAC_2_PI;\n    let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRT_PI;\n    let sqrt2: f64 = consts::SQRT_2;\n    let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT_2;\n    let e: f64 = consts::E;\n    let log2_e: f64 = consts::LOG2_E;\n    let log10_e: f64 = consts::LOG10_E;\n    let ln_2: f64 = consts::LN_2;\n    let ln_10: f64 = consts::LN_10;\n\n    assert_approx_eq!(frac_pi_2, pi / 2f64);\n    assert_approx_eq!(frac_pi_3, pi / 3f64);\n    assert_approx_eq!(frac_pi_4, pi / 4f64);\n    assert_approx_eq!(frac_pi_6, pi / 6f64);\n    assert_approx_eq!(frac_pi_8, pi / 8f64);\n    assert_approx_eq!(frac_1_pi, 1f64 / pi);\n    assert_approx_eq!(frac_2_pi, 2f64 / pi);\n    assert_approx_eq!(frac_2_sqrtpi, 2f64 / pi.sqrt());\n    assert_approx_eq!(sqrt2, 2f64.sqrt());\n    assert_approx_eq!(frac_1_sqrt2, 1f64 / 2f64.sqrt());\n    assert_approx_eq!(log2_e, e.log2());\n    assert_approx_eq!(log10_e, e.log10());\n    assert_approx_eq!(ln_2, 2f64.ln());\n    assert_approx_eq!(ln_10, 10f64.ln());\n}\n\n#[test]\nfn test_float_bits_conv() {\n    assert_eq!((1f64).to_bits(), 0x3ff0000000000000);\n    assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n    assert_eq!((1337f64).to_bits(), 0x4094e40000000000);\n    assert_eq!((-14.25f64).to_bits(), 0xc02c800000000000);\n    assert_approx_eq!(f64::from_bits(0x3ff0000000000000), 1.0);\n    assert_approx_eq!(f64::from_bits(0x4029000000000000), 12.5);\n    assert_approx_eq!(f64::from_bits(0x4094e40000000000), 1337.0);\n    assert_approx_eq!(f64::from_bits(0xc02c800000000000), -14.25);\n\n    // Check that NaNs roundtrip their bits regardless of signaling-ness\n    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n    let masked_nan1 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n    let masked_nan2 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n    assert!(f64::from_bits(masked_nan1).is_nan());\n    assert!(f64::from_bits(masked_nan2).is_nan());\n\n    assert_eq!(f64::from_bits(masked_nan1).to_bits(), masked_nan1);\n    assert_eq!(f64::from_bits(masked_nan2).to_bits(), masked_nan2);\n}\n\n#[test]\n#[should_panic]\nfn test_clamp_min_greater_than_max() {\n    let _ = 1.0f64.clamp(3.0, 1.0);\n}\n\n#[test]\n#[should_panic]\nfn test_clamp_min_is_nan() {\n    let _ = 1.0f64.clamp(f64::NAN, 1.0);\n}\n\n#[test]\n#[should_panic]\nfn test_clamp_max_is_nan() {\n    let _ = 1.0f64.clamp(3.0, f64::NAN);\n}\n\n#[test]\nfn test_total_cmp() {\n    use core::cmp::Ordering;\n\n    fn quiet_bit_mask() -> u64 {\n        1 << (f64::MANTISSA_DIGITS - 2)\n    }\n\n    fn min_subnorm() -> f64 {\n        f64::MIN_POSITIVE / f64::powf(2.0, f64::MANTISSA_DIGITS as f64 - 1.0)\n    }\n\n    fn max_subnorm() -> f64 {\n        f64::MIN_POSITIVE - min_subnorm()\n    }\n\n    fn q_nan() -> f64 {\n        f64::from_bits(f64::NAN.to_bits() | quiet_bit_mask())\n    }\n\n    fn s_nan() -> f64 {\n        f64::from_bits((f64::NAN.to_bits() & !quiet_bit_mask()) + 42)\n    }\n\n    assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n    assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n    assert_eq!(Ordering::Equal, (-f64::INFINITY).total_cmp(&-f64::INFINITY));\n    assert_eq!(Ordering::Equal, (-f64::MAX).total_cmp(&-f64::MAX));\n    assert_eq!(Ordering::Equal, (-2.5_f64).total_cmp(&-2.5));\n    assert_eq!(Ordering::Equal, (-1.0_f64).total_cmp(&-1.0));\n    assert_eq!(Ordering::Equal, (-1.5_f64).total_cmp(&-1.5));\n    assert_eq!(Ordering::Equal, (-0.5_f64).total_cmp(&-0.5));\n    assert_eq!(Ordering::Equal, (-f64::MIN_POSITIVE).total_cmp(&-f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Equal, (-0.0_f64).total_cmp(&-0.0));\n    assert_eq!(Ordering::Equal, 0.0_f64.total_cmp(&0.0));\n    assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Equal, f64::MIN_POSITIVE.total_cmp(&f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Equal, 0.5_f64.total_cmp(&0.5));\n    assert_eq!(Ordering::Equal, 1.0_f64.total_cmp(&1.0));\n    assert_eq!(Ordering::Equal, 1.5_f64.total_cmp(&1.5));\n    assert_eq!(Ordering::Equal, 2.5_f64.total_cmp(&2.5));\n    assert_eq!(Ordering::Equal, f64::MAX.total_cmp(&f64::MAX));\n    assert_eq!(Ordering::Equal, f64::INFINITY.total_cmp(&f64::INFINITY));\n    assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n    assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n    assert_eq!(Ordering::Less, (-f64::INFINITY).total_cmp(&-f64::MAX));\n    assert_eq!(Ordering::Less, (-f64::MAX).total_cmp(&-2.5));\n    assert_eq!(Ordering::Less, (-2.5_f64).total_cmp(&-1.5));\n    assert_eq!(Ordering::Less, (-1.5_f64).total_cmp(&-1.0));\n    assert_eq!(Ordering::Less, (-1.0_f64).total_cmp(&-0.5));\n    assert_eq!(Ordering::Less, (-0.5_f64).total_cmp(&-f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-f64::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n    assert_eq!(Ordering::Less, (-0.0_f64).total_cmp(&0.0));\n    assert_eq!(Ordering::Less, 0.0_f64.total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, f64::MIN_POSITIVE.total_cmp(&0.5));\n    assert_eq!(Ordering::Less, 0.5_f64.total_cmp(&1.0));\n    assert_eq!(Ordering::Less, 1.0_f64.total_cmp(&1.5));\n    assert_eq!(Ordering::Less, 1.5_f64.total_cmp(&2.5));\n    assert_eq!(Ordering::Less, 2.5_f64.total_cmp(&f64::MAX));\n    assert_eq!(Ordering::Less, f64::MAX.total_cmp(&f64::INFINITY));\n    assert_eq!(Ordering::Less, f64::INFINITY.total_cmp(&s_nan()));\n    assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n\n    assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n    assert_eq!(Ordering::Greater, (-f64::INFINITY).total_cmp(&-s_nan()));\n    assert_eq!(Ordering::Greater, (-f64::MAX).total_cmp(&-f64::INFINITY));\n    assert_eq!(Ordering::Greater, (-2.5_f64).total_cmp(&-f64::MAX));\n    assert_eq!(Ordering::Greater, (-1.5_f64).total_cmp(&-2.5));\n    assert_eq!(Ordering::Greater, (-1.0_f64).total_cmp(&-1.5));\n    assert_eq!(Ordering::Greater, (-0.5_f64).total_cmp(&-1.0));\n    assert_eq!(Ordering::Greater, (-f64::MIN_POSITIVE).total_cmp(&-0.5));\n    assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Greater, (-0.0_f64).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Greater, 0.0_f64.total_cmp(&-0.0));\n    assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n    assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Greater, f64::MIN_POSITIVE.total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Greater, 0.5_f64.total_cmp(&f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Greater, 1.0_f64.total_cmp(&0.5));\n    assert_eq!(Ordering::Greater, 1.5_f64.total_cmp(&1.0));\n    assert_eq!(Ordering::Greater, 2.5_f64.total_cmp(&1.5));\n    assert_eq!(Ordering::Greater, f64::MAX.total_cmp(&2.5));\n    assert_eq!(Ordering::Greater, f64::INFINITY.total_cmp(&f64::MAX));\n    assert_eq!(Ordering::Greater, s_nan().total_cmp(&f64::INFINITY));\n    assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::INFINITY));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MAX));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MAX));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::INFINITY));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MAX));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MAX));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::INFINITY));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n}\n\n#[test]\nfn test_lerp_exact() {\n    // simple values\n    assert_eq!(f64::lerp(0.0, 2.0, 4.0), 2.0);\n    assert_eq!(f64::lerp(1.0, 2.0, 4.0), 4.0);\n\n    // boundary values\n    assert_eq!(f64::lerp(0.0, f64::MIN, f64::MAX), f64::MIN);\n    assert_eq!(f64::lerp(1.0, f64::MIN, f64::MAX), f64::MAX);\n}\n\n#[test]\nfn test_lerp_consistent() {\n    assert_eq!(f64::lerp(f64::MAX, f64::MIN, f64::MIN), f64::MIN);\n    assert_eq!(f64::lerp(f64::MIN, f64::MAX, f64::MAX), f64::MAX);\n\n    // as long as t is finite, a/b can be infinite\n    assert_eq!(f64::lerp(f64::MAX, f64::NEG_INFINITY, f64::NEG_INFINITY), f64::NEG_INFINITY);\n    assert_eq!(f64::lerp(f64::MIN, f64::INFINITY, f64::INFINITY), f64::INFINITY);\n}\n\n#[test]\nfn test_lerp_nan_infinite() {\n    // non-finite t is not NaN if a/b different\n    assert!(!f64::lerp(f64::INFINITY, f64::MIN, f64::MAX).is_nan());\n    assert!(!f64::lerp(f64::NEG_INFINITY, f64::MIN, f64::MAX).is_nan());\n}\n\n#[test]\nfn test_lerp_values() {\n    // just a few basic values\n    assert_eq!(f64::lerp(0.25, 1.0, 2.0), 1.25);\n    assert_eq!(f64::lerp(0.50, 1.0, 2.0), 1.50);\n    assert_eq!(f64::lerp(0.75, 1.0, 2.0), 1.75);\n}\n\n#[test]\nfn test_lerp_monotonic() {\n    // near 0\n    let below_zero = f64::lerp(-f64::EPSILON, f64::MIN, f64::MAX);\n    let zero = f64::lerp(0.0, f64::MIN, f64::MAX);\n    let above_zero = f64::lerp(f64::EPSILON, f64::MIN, f64::MAX);\n    assert!(below_zero <= zero);\n    assert!(zero <= above_zero);\n    assert!(below_zero <= above_zero);\n\n    // near 1\n    let below_one = f64::lerp(1.0 - f64::EPSILON, f64::MIN, f64::MAX);\n    let one = f64::lerp(1.0, f64::MIN, f64::MAX);\n    let above_one = f64::lerp(1.0 + f64::EPSILON, f64::MIN, f64::MAX);\n    assert!(below_one <= one);\n    assert!(one <= above_one);\n    assert!(below_one <= above_one);\n}\n"],["2514","use crate::f32::consts;\nuse crate::num::FpCategory as Fp;\nuse crate::num::*;\n\n#[test]\nfn test_num_f32() {\n    test_num(10f32, 2f32);\n}\n\n#[test]\nfn test_min_nan() {\n    assert_eq!(f32::NAN.min(2.0), 2.0);\n    assert_eq!(2.0f32.min(f32::NAN), 2.0);\n}\n\n#[test]\nfn test_max_nan() {\n    assert_eq!(f32::NAN.max(2.0), 2.0);\n    assert_eq!(2.0f32.max(f32::NAN), 2.0);\n}\n\n#[test]\nfn test_nan() {\n    let nan: f32 = f32::NAN;\n    assert!(nan.is_nan());\n    assert!(!nan.is_infinite());\n    assert!(!nan.is_finite());\n    assert!(!nan.is_normal());\n    assert!(nan.is_sign_positive());\n    assert!(!nan.is_sign_negative());\n    assert_eq!(Fp::Nan, nan.classify());\n}\n\n#[test]\nfn test_infinity() {\n    let inf: f32 = f32::INFINITY;\n    assert!(inf.is_infinite());\n    assert!(!inf.is_finite());\n    assert!(inf.is_sign_positive());\n    assert!(!inf.is_sign_negative());\n    assert!(!inf.is_nan());\n    assert!(!inf.is_normal());\n    assert_eq!(Fp::Infinite, inf.classify());\n}\n\n#[test]\nfn test_neg_infinity() {\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert!(neg_inf.is_infinite());\n    assert!(!neg_inf.is_finite());\n    assert!(!neg_inf.is_sign_positive());\n    assert!(neg_inf.is_sign_negative());\n    assert!(!neg_inf.is_nan());\n    assert!(!neg_inf.is_normal());\n    assert_eq!(Fp::Infinite, neg_inf.classify());\n}\n\n#[test]\nfn test_zero() {\n    let zero: f32 = 0.0f32;\n    assert_eq!(0.0, zero);\n    assert!(!zero.is_infinite());\n    assert!(zero.is_finite());\n    assert!(zero.is_sign_positive());\n    assert!(!zero.is_sign_negative());\n    assert!(!zero.is_nan());\n    assert!(!zero.is_normal());\n    assert_eq!(Fp::Zero, zero.classify());\n}\n\n#[test]\nfn test_neg_zero() {\n    let neg_zero: f32 = -0.0;\n    assert_eq!(0.0, neg_zero);\n    assert!(!neg_zero.is_infinite());\n    assert!(neg_zero.is_finite());\n    assert!(!neg_zero.is_sign_positive());\n    assert!(neg_zero.is_sign_negative());\n    assert!(!neg_zero.is_nan());\n    assert!(!neg_zero.is_normal());\n    assert_eq!(Fp::Zero, neg_zero.classify());\n}\n\n#[test]\nfn test_one() {\n    let one: f32 = 1.0f32;\n    assert_eq!(1.0, one);\n    assert!(!one.is_infinite());\n    assert!(one.is_finite());\n    assert!(one.is_sign_positive());\n    assert!(!one.is_sign_negative());\n    assert!(!one.is_nan());\n    assert!(one.is_normal());\n    assert_eq!(Fp::Normal, one.classify());\n}\n\n#[test]\nfn test_is_nan() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert!(nan.is_nan());\n    assert!(!0.0f32.is_nan());\n    assert!(!5.3f32.is_nan());\n    assert!(!(-10.732f32).is_nan());\n    assert!(!inf.is_nan());\n    assert!(!neg_inf.is_nan());\n}\n\n#[test]\nfn test_is_infinite() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert!(!nan.is_infinite());\n    assert!(inf.is_infinite());\n    assert!(neg_inf.is_infinite());\n    assert!(!0.0f32.is_infinite());\n    assert!(!42.8f32.is_infinite());\n    assert!(!(-109.2f32).is_infinite());\n}\n\n#[test]\nfn test_is_finite() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert!(!nan.is_finite());\n    assert!(!inf.is_finite());\n    assert!(!neg_inf.is_finite());\n    assert!(0.0f32.is_finite());\n    assert!(42.8f32.is_finite());\n    assert!((-109.2f32).is_finite());\n}\n\n#[test]\nfn test_is_normal() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    let zero: f32 = 0.0f32;\n    let neg_zero: f32 = -0.0;\n    assert!(!nan.is_normal());\n    assert!(!inf.is_normal());\n    assert!(!neg_inf.is_normal());\n    assert!(!zero.is_normal());\n    assert!(!neg_zero.is_normal());\n    assert!(1f32.is_normal());\n    assert!(1e-37f32.is_normal());\n    assert!(!1e-38f32.is_normal());\n}\n\n#[test]\nfn test_classify() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    let zero: f32 = 0.0f32;\n    let neg_zero: f32 = -0.0;\n    assert_eq!(nan.classify(), Fp::Nan);\n    assert_eq!(inf.classify(), Fp::Infinite);\n    assert_eq!(neg_inf.classify(), Fp::Infinite);\n    assert_eq!(zero.classify(), Fp::Zero);\n    assert_eq!(neg_zero.classify(), Fp::Zero);\n    assert_eq!(1f32.classify(), Fp::Normal);\n    assert_eq!(1e-37f32.classify(), Fp::Normal);\n    assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n}\n\n#[test]\nfn test_floor() {\n    assert_approx_eq!(1.0f32.floor(), 1.0f32);\n    assert_approx_eq!(1.3f32.floor(), 1.0f32);\n    assert_approx_eq!(1.5f32.floor(), 1.0f32);\n    assert_approx_eq!(1.7f32.floor(), 1.0f32);\n    assert_approx_eq!(0.0f32.floor(), 0.0f32);\n    assert_approx_eq!((-0.0f32).floor(), -0.0f32);\n    assert_approx_eq!((-1.0f32).floor(), -1.0f32);\n    assert_approx_eq!((-1.3f32).floor(), -2.0f32);\n    assert_approx_eq!((-1.5f32).floor(), -2.0f32);\n    assert_approx_eq!((-1.7f32).floor(), -2.0f32);\n}\n\n#[test]\nfn test_ceil() {\n    assert_approx_eq!(1.0f32.ceil(), 1.0f32);\n    assert_approx_eq!(1.3f32.ceil(), 2.0f32);\n    assert_approx_eq!(1.5f32.ceil(), 2.0f32);\n    assert_approx_eq!(1.7f32.ceil(), 2.0f32);\n    assert_approx_eq!(0.0f32.ceil(), 0.0f32);\n    assert_approx_eq!((-0.0f32).ceil(), -0.0f32);\n    assert_approx_eq!((-1.0f32).ceil(), -1.0f32);\n    assert_approx_eq!((-1.3f32).ceil(), -1.0f32);\n    assert_approx_eq!((-1.5f32).ceil(), -1.0f32);\n    assert_approx_eq!((-1.7f32).ceil(), -1.0f32);\n}\n\n#[test]\nfn test_round() {\n    assert_approx_eq!(1.0f32.round(), 1.0f32);\n    assert_approx_eq!(1.3f32.round(), 1.0f32);\n    assert_approx_eq!(1.5f32.round(), 2.0f32);\n    assert_approx_eq!(1.7f32.round(), 2.0f32);\n    assert_approx_eq!(0.0f32.round(), 0.0f32);\n    assert_approx_eq!((-0.0f32).round(), -0.0f32);\n    assert_approx_eq!((-1.0f32).round(), -1.0f32);\n    assert_approx_eq!((-1.3f32).round(), -1.0f32);\n    assert_approx_eq!((-1.5f32).round(), -2.0f32);\n    assert_approx_eq!((-1.7f32).round(), -2.0f32);\n}\n\n#[test]\nfn test_trunc() {\n    assert_approx_eq!(1.0f32.trunc(), 1.0f32);\n    assert_approx_eq!(1.3f32.trunc(), 1.0f32);\n    assert_approx_eq!(1.5f32.trunc(), 1.0f32);\n    assert_approx_eq!(1.7f32.trunc(), 1.0f32);\n    assert_approx_eq!(0.0f32.trunc(), 0.0f32);\n    assert_approx_eq!((-0.0f32).trunc(), -0.0f32);\n    assert_approx_eq!((-1.0f32).trunc(), -1.0f32);\n    assert_approx_eq!((-1.3f32).trunc(), -1.0f32);\n    assert_approx_eq!((-1.5f32).trunc(), -1.0f32);\n    assert_approx_eq!((-1.7f32).trunc(), -1.0f32);\n}\n\n#[test]\nfn test_fract() {\n    assert_approx_eq!(1.0f32.fract(), 0.0f32);\n    assert_approx_eq!(1.3f32.fract(), 0.3f32);\n    assert_approx_eq!(1.5f32.fract(), 0.5f32);\n    assert_approx_eq!(1.7f32.fract(), 0.7f32);\n    assert_approx_eq!(0.0f32.fract(), 0.0f32);\n    assert_approx_eq!((-0.0f32).fract(), -0.0f32);\n    assert_approx_eq!((-1.0f32).fract(), -0.0f32);\n    assert_approx_eq!((-1.3f32).fract(), -0.3f32);\n    assert_approx_eq!((-1.5f32).fract(), -0.5f32);\n    assert_approx_eq!((-1.7f32).fract(), -0.7f32);\n}\n\n#[test]\nfn test_abs() {\n    assert_eq!(f32::INFINITY.abs(), f32::INFINITY);\n    assert_eq!(1f32.abs(), 1f32);\n    assert_eq!(0f32.abs(), 0f32);\n    assert_eq!((-0f32).abs(), 0f32);\n    assert_eq!((-1f32).abs(), 1f32);\n    assert_eq!(f32::NEG_INFINITY.abs(), f32::INFINITY);\n    assert_eq!((1f32 / f32::NEG_INFINITY).abs(), 0f32);\n    assert!(f32::NAN.abs().is_nan());\n}\n\n#[test]\nfn test_signum() {\n    assert_eq!(f32::INFINITY.signum(), 1f32);\n    assert_eq!(1f32.signum(), 1f32);\n    assert_eq!(0f32.signum(), 1f32);\n    assert_eq!((-0f32).signum(), -1f32);\n    assert_eq!((-1f32).signum(), -1f32);\n    assert_eq!(f32::NEG_INFINITY.signum(), -1f32);\n    assert_eq!((1f32 / f32::NEG_INFINITY).signum(), -1f32);\n    assert!(f32::NAN.signum().is_nan());\n}\n\n#[test]\nfn test_is_sign_positive() {\n    assert!(f32::INFINITY.is_sign_positive());\n    assert!(1f32.is_sign_positive());\n    assert!(0f32.is_sign_positive());\n    assert!(!(-0f32).is_sign_positive());\n    assert!(!(-1f32).is_sign_positive());\n    assert!(!f32::NEG_INFINITY.is_sign_positive());\n    assert!(!(1f32 / f32::NEG_INFINITY).is_sign_positive());\n    assert!(f32::NAN.is_sign_positive());\n    assert!(!(-f32::NAN).is_sign_positive());\n}\n\n#[test]\nfn test_is_sign_negative() {\n    assert!(!f32::INFINITY.is_sign_negative());\n    assert!(!1f32.is_sign_negative());\n    assert!(!0f32.is_sign_negative());\n    assert!((-0f32).is_sign_negative());\n    assert!((-1f32).is_sign_negative());\n    assert!(f32::NEG_INFINITY.is_sign_negative());\n    assert!((1f32 / f32::NEG_INFINITY).is_sign_negative());\n    assert!(!f32::NAN.is_sign_negative());\n    assert!((-f32::NAN).is_sign_negative());\n}\n\n#[test]\nfn test_mul_add() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_approx_eq!(12.3f32.mul_add(4.5, 6.7), 62.05);\n    assert_approx_eq!((-12.3f32).mul_add(-4.5, -6.7), 48.65);\n    assert_approx_eq!(0.0f32.mul_add(8.9, 1.2), 1.2);\n    assert_approx_eq!(3.4f32.mul_add(-0.0, 5.6), 5.6);\n    assert!(nan.mul_add(7.8, 9.0).is_nan());\n    assert_eq!(inf.mul_add(7.8, 9.0), inf);\n    assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n    assert_eq!(8.9f32.mul_add(inf, 3.2), inf);\n    assert_eq!((-3.2f32).mul_add(2.4, neg_inf), neg_inf);\n}\n\n#[test]\nfn test_recip() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_eq!(1.0f32.recip(), 1.0);\n    assert_eq!(2.0f32.recip(), 0.5);\n    assert_eq!((-0.4f32).recip(), -2.5);\n    assert_eq!(0.0f32.recip(), inf);\n    assert!(nan.recip().is_nan());\n    assert_eq!(inf.recip(), 0.0);\n    assert_eq!(neg_inf.recip(), 0.0);\n}\n\n#[test]\nfn test_powi() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_eq!(1.0f32.powi(1), 1.0);\n    assert_approx_eq!((-3.1f32).powi(2), 9.61);\n    assert_approx_eq!(5.9f32.powi(-2), 0.028727);\n    assert_eq!(8.3f32.powi(0), 1.0);\n    assert!(nan.powi(2).is_nan());\n    assert_eq!(inf.powi(3), inf);\n    assert_eq!(neg_inf.powi(2), inf);\n}\n\n#[test]\nfn test_powf() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_eq!(1.0f32.powf(1.0), 1.0);\n    assert_approx_eq!(3.4f32.powf(4.5), 246.408218);\n    assert_approx_eq!(2.7f32.powf(-3.2), 0.041652);\n    assert_approx_eq!((-3.1f32).powf(2.0), 9.61);\n    assert_approx_eq!(5.9f32.powf(-2.0), 0.028727);\n    assert_eq!(8.3f32.powf(0.0), 1.0);\n    assert!(nan.powf(2.0).is_nan());\n    assert_eq!(inf.powf(2.0), inf);\n    assert_eq!(neg_inf.powf(3.0), neg_inf);\n}\n\n#[test]\nfn test_sqrt_domain() {\n    assert!(f32::NAN.sqrt().is_nan());\n    assert!(f32::NEG_INFINITY.sqrt().is_nan());\n    assert!((-1.0f32).sqrt().is_nan());\n    assert_eq!((-0.0f32).sqrt(), -0.0);\n    assert_eq!(0.0f32.sqrt(), 0.0);\n    assert_eq!(1.0f32.sqrt(), 1.0);\n    assert_eq!(f32::INFINITY.sqrt(), f32::INFINITY);\n}\n\n#[test]\nfn test_exp() {\n    assert_eq!(1.0, 0.0f32.exp());\n    assert_approx_eq!(2.718282, 1.0f32.exp());\n    assert_approx_eq!(148.413162, 5.0f32.exp());\n\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    let nan: f32 = f32::NAN;\n    assert_eq!(inf, inf.exp());\n    assert_eq!(0.0, neg_inf.exp());\n    assert!(nan.exp().is_nan());\n}\n\n#[test]\nfn test_exp2() {\n    assert_eq!(32.0, 5.0f32.exp2());\n    assert_eq!(1.0, 0.0f32.exp2());\n\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    let nan: f32 = f32::NAN;\n    assert_eq!(inf, inf.exp2());\n    assert_eq!(0.0, neg_inf.exp2());\n    assert!(nan.exp2().is_nan());\n}\n\n#[test]\nfn test_ln() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_approx_eq!(1.0f32.exp().ln(), 1.0);\n    assert!(nan.ln().is_nan());\n    assert_eq!(inf.ln(), inf);\n    assert!(neg_inf.ln().is_nan());\n    assert!((-2.3f32).ln().is_nan());\n    assert_eq!((-0.0f32).ln(), neg_inf);\n    assert_eq!(0.0f32.ln(), neg_inf);\n    assert_approx_eq!(4.0f32.ln(), 1.386294);\n}\n\n#[test]\nfn test_log() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_eq!(10.0f32.log(10.0), 1.0);\n    assert_approx_eq!(2.3f32.log(3.5), 0.664858);\n    assert_eq!(1.0f32.exp().log(1.0f32.exp()), 1.0);\n    assert!(1.0f32.log(1.0).is_nan());\n    assert!(1.0f32.log(-13.9).is_nan());\n    assert!(nan.log(2.3).is_nan());\n    assert_eq!(inf.log(10.0), inf);\n    assert!(neg_inf.log(8.8).is_nan());\n    assert!((-2.3f32).log(0.1).is_nan());\n    assert_eq!((-0.0f32).log(2.0), neg_inf);\n    assert_eq!(0.0f32.log(7.0), neg_inf);\n}\n\n#[test]\nfn test_log2() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_approx_eq!(10.0f32.log2(), 3.321928);\n    assert_approx_eq!(2.3f32.log2(), 1.201634);\n    assert_approx_eq!(1.0f32.exp().log2(), 1.442695);\n    assert!(nan.log2().is_nan());\n    assert_eq!(inf.log2(), inf);\n    assert!(neg_inf.log2().is_nan());\n    assert!((-2.3f32).log2().is_nan());\n    assert_eq!((-0.0f32).log2(), neg_inf);\n    assert_eq!(0.0f32.log2(), neg_inf);\n}\n\n#[test]\nfn test_log10() {\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_eq!(10.0f32.log10(), 1.0);\n    assert_approx_eq!(2.3f32.log10(), 0.361728);\n    assert_approx_eq!(1.0f32.exp().log10(), 0.434294);\n    assert_eq!(1.0f32.log10(), 0.0);\n    assert!(nan.log10().is_nan());\n    assert_eq!(inf.log10(), inf);\n    assert!(neg_inf.log10().is_nan());\n    assert!((-2.3f32).log10().is_nan());\n    assert_eq!((-0.0f32).log10(), neg_inf);\n    assert_eq!(0.0f32.log10(), neg_inf);\n}\n\n#[test]\nfn test_to_degrees() {\n    let pi: f32 = consts::PI;\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_eq!(0.0f32.to_degrees(), 0.0);\n    assert_approx_eq!((-5.8f32).to_degrees(), -332.315521);\n    assert_eq!(pi.to_degrees(), 180.0);\n    assert!(nan.to_degrees().is_nan());\n    assert_eq!(inf.to_degrees(), inf);\n    assert_eq!(neg_inf.to_degrees(), neg_inf);\n    assert_eq!(1_f32.to_degrees(), 57.2957795130823208767981548141051703);\n}\n\n#[test]\nfn test_to_radians() {\n    let pi: f32 = consts::PI;\n    let nan: f32 = f32::NAN;\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    assert_eq!(0.0f32.to_radians(), 0.0);\n    assert_approx_eq!(154.6f32.to_radians(), 2.698279);\n    assert_approx_eq!((-332.31f32).to_radians(), -5.799903);\n    assert_eq!(180.0f32.to_radians(), pi);\n    assert!(nan.to_radians().is_nan());\n    assert_eq!(inf.to_radians(), inf);\n    assert_eq!(neg_inf.to_radians(), neg_inf);\n}\n\n#[test]\nfn test_asinh() {\n    assert_eq!(0.0f32.asinh(), 0.0f32);\n    assert_eq!((-0.0f32).asinh(), -0.0f32);\n\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    let nan: f32 = f32::NAN;\n    assert_eq!(inf.asinh(), inf);\n    assert_eq!(neg_inf.asinh(), neg_inf);\n    assert!(nan.asinh().is_nan());\n    assert!((-0.0f32).asinh().is_sign_negative()); // issue 63271\n    assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n    assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n    // regression test for the catastrophic cancellation fixed in 72486\n    assert_approx_eq!((-3000.0f32).asinh(), -8.699514775987968673236893537700647f32);\n}\n\n#[test]\nfn test_acosh() {\n    assert_eq!(1.0f32.acosh(), 0.0f32);\n    assert!(0.999f32.acosh().is_nan());\n\n    let inf: f32 = f32::INFINITY;\n    let neg_inf: f32 = f32::NEG_INFINITY;\n    let nan: f32 = f32::NAN;\n    assert_eq!(inf.acosh(), inf);\n    assert!(neg_inf.acosh().is_nan());\n    assert!(nan.acosh().is_nan());\n    assert_approx_eq!(2.0f32.acosh(), 1.31695789692481670862504634730796844f32);\n    assert_approx_eq!(3.0f32.acosh(), 1.76274717403908605046521864995958461f32);\n}\n\n#[test]\nfn test_atanh() {\n    assert_eq!(0.0f32.atanh(), 0.0f32);\n    assert_eq!((-0.0f32).atanh(), -0.0f32);\n\n    let inf32: f32 = f32::INFINITY;\n    let neg_inf32: f32 = f32::NEG_INFINITY;\n    assert_eq!(1.0f32.atanh(), inf32);\n    assert_eq!((-1.0f32).atanh(), neg_inf32);\n\n    assert!(2f64.atanh().atanh().is_nan());\n    assert!((-2f64).atanh().atanh().is_nan());\n\n    let inf64: f32 = f32::INFINITY;\n    let neg_inf64: f32 = f32::NEG_INFINITY;\n    let nan32: f32 = f32::NAN;\n    assert!(inf64.atanh().is_nan());\n    assert!(neg_inf64.atanh().is_nan());\n    assert!(nan32.atanh().is_nan());\n\n    assert_approx_eq!(0.5f32.atanh(), 0.54930614433405484569762261846126285f32);\n    assert_approx_eq!((-0.5f32).atanh(), -0.54930614433405484569762261846126285f32);\n}\n\n#[test]\nfn test_real_consts() {\n    use super::consts;\n\n    let pi: f32 = consts::PI;\n    let frac_pi_2: f32 = consts::FRAC_PI_2;\n    let frac_pi_3: f32 = consts::FRAC_PI_3;\n    let frac_pi_4: f32 = consts::FRAC_PI_4;\n    let frac_pi_6: f32 = consts::FRAC_PI_6;\n    let frac_pi_8: f32 = consts::FRAC_PI_8;\n    let frac_1_pi: f32 = consts::FRAC_1_PI;\n    let frac_2_pi: f32 = consts::FRAC_2_PI;\n    let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRT_PI;\n    let sqrt2: f32 = consts::SQRT_2;\n    let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT_2;\n    let e: f32 = consts::E;\n    let log2_e: f32 = consts::LOG2_E;\n    let log10_e: f32 = consts::LOG10_E;\n    let ln_2: f32 = consts::LN_2;\n    let ln_10: f32 = consts::LN_10;\n\n    assert_approx_eq!(frac_pi_2, pi / 2f32);\n    assert_approx_eq!(frac_pi_3, pi / 3f32);\n    assert_approx_eq!(frac_pi_4, pi / 4f32);\n    assert_approx_eq!(frac_pi_6, pi / 6f32);\n    assert_approx_eq!(frac_pi_8, pi / 8f32);\n    assert_approx_eq!(frac_1_pi, 1f32 / pi);\n    assert_approx_eq!(frac_2_pi, 2f32 / pi);\n    assert_approx_eq!(frac_2_sqrtpi, 2f32 / pi.sqrt());\n    assert_approx_eq!(sqrt2, 2f32.sqrt());\n    assert_approx_eq!(frac_1_sqrt2, 1f32 / 2f32.sqrt());\n    assert_approx_eq!(log2_e, e.log2());\n    assert_approx_eq!(log10_e, e.log10());\n    assert_approx_eq!(ln_2, 2f32.ln());\n    assert_approx_eq!(ln_10, 10f32.ln());\n}\n\n#[test]\nfn test_float_bits_conv() {\n    assert_eq!((1f32).to_bits(), 0x3f800000);\n    assert_eq!((12.5f32).to_bits(), 0x41480000);\n    assert_eq!((1337f32).to_bits(), 0x44a72000);\n    assert_eq!((-14.25f32).to_bits(), 0xc1640000);\n    assert_approx_eq!(f32::from_bits(0x3f800000), 1.0);\n    assert_approx_eq!(f32::from_bits(0x41480000), 12.5);\n    assert_approx_eq!(f32::from_bits(0x44a72000), 1337.0);\n    assert_approx_eq!(f32::from_bits(0xc1640000), -14.25);\n\n    // Check that NaNs roundtrip their bits regardless of signaling-ness\n    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n    let masked_nan1 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n    let masked_nan2 = f32::NAN.to_bits() ^ 0x0055_5555;\n    assert!(f32::from_bits(masked_nan1).is_nan());\n    assert!(f32::from_bits(masked_nan2).is_nan());\n\n    assert_eq!(f32::from_bits(masked_nan1).to_bits(), masked_nan1);\n    assert_eq!(f32::from_bits(masked_nan2).to_bits(), masked_nan2);\n}\n\n#[test]\n#[should_panic]\nfn test_clamp_min_greater_than_max() {\n    let _ = 1.0f32.clamp(3.0, 1.0);\n}\n\n#[test]\n#[should_panic]\nfn test_clamp_min_is_nan() {\n    let _ = 1.0f32.clamp(f32::NAN, 1.0);\n}\n\n#[test]\n#[should_panic]\nfn test_clamp_max_is_nan() {\n    let _ = 1.0f32.clamp(3.0, f32::NAN);\n}\n\n#[test]\nfn test_total_cmp() {\n    use core::cmp::Ordering;\n\n    fn quiet_bit_mask() -> u32 {\n        1 << (f32::MANTISSA_DIGITS - 2)\n    }\n\n    fn min_subnorm() -> f32 {\n        f32::MIN_POSITIVE / f32::powf(2.0, f32::MANTISSA_DIGITS as f32 - 1.0)\n    }\n\n    fn max_subnorm() -> f32 {\n        f32::MIN_POSITIVE - min_subnorm()\n    }\n\n    fn q_nan() -> f32 {\n        f32::from_bits(f32::NAN.to_bits() | quiet_bit_mask())\n    }\n\n    fn s_nan() -> f32 {\n        f32::from_bits((f32::NAN.to_bits() & !quiet_bit_mask()) + 42)\n    }\n\n    assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n    assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n    assert_eq!(Ordering::Equal, (-f32::INFINITY).total_cmp(&-f32::INFINITY));\n    assert_eq!(Ordering::Equal, (-f32::MAX).total_cmp(&-f32::MAX));\n    assert_eq!(Ordering::Equal, (-2.5_f32).total_cmp(&-2.5));\n    assert_eq!(Ordering::Equal, (-1.0_f32).total_cmp(&-1.0));\n    assert_eq!(Ordering::Equal, (-1.5_f32).total_cmp(&-1.5));\n    assert_eq!(Ordering::Equal, (-0.5_f32).total_cmp(&-0.5));\n    assert_eq!(Ordering::Equal, (-f32::MIN_POSITIVE).total_cmp(&-f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Equal, (-0.0_f32).total_cmp(&-0.0));\n    assert_eq!(Ordering::Equal, 0.0_f32.total_cmp(&0.0));\n    assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Equal, f32::MIN_POSITIVE.total_cmp(&f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Equal, 0.5_f32.total_cmp(&0.5));\n    assert_eq!(Ordering::Equal, 1.0_f32.total_cmp(&1.0));\n    assert_eq!(Ordering::Equal, 1.5_f32.total_cmp(&1.5));\n    assert_eq!(Ordering::Equal, 2.5_f32.total_cmp(&2.5));\n    assert_eq!(Ordering::Equal, f32::MAX.total_cmp(&f32::MAX));\n    assert_eq!(Ordering::Equal, f32::INFINITY.total_cmp(&f32::INFINITY));\n    assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n    assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n    assert_eq!(Ordering::Less, (-f32::INFINITY).total_cmp(&-f32::MAX));\n    assert_eq!(Ordering::Less, (-f32::MAX).total_cmp(&-2.5));\n    assert_eq!(Ordering::Less, (-2.5_f32).total_cmp(&-1.5));\n    assert_eq!(Ordering::Less, (-1.5_f32).total_cmp(&-1.0));\n    assert_eq!(Ordering::Less, (-1.0_f32).total_cmp(&-0.5));\n    assert_eq!(Ordering::Less, (-0.5_f32).total_cmp(&-f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-f32::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n    assert_eq!(Ordering::Less, (-0.0_f32).total_cmp(&0.0));\n    assert_eq!(Ordering::Less, 0.0_f32.total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, f32::MIN_POSITIVE.total_cmp(&0.5));\n    assert_eq!(Ordering::Less, 0.5_f32.total_cmp(&1.0));\n    assert_eq!(Ordering::Less, 1.0_f32.total_cmp(&1.5));\n    assert_eq!(Ordering::Less, 1.5_f32.total_cmp(&2.5));\n    assert_eq!(Ordering::Less, 2.5_f32.total_cmp(&f32::MAX));\n    assert_eq!(Ordering::Less, f32::MAX.total_cmp(&f32::INFINITY));\n    assert_eq!(Ordering::Less, f32::INFINITY.total_cmp(&s_nan()));\n    assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n\n    assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n    assert_eq!(Ordering::Greater, (-f32::INFINITY).total_cmp(&-s_nan()));\n    assert_eq!(Ordering::Greater, (-f32::MAX).total_cmp(&-f32::INFINITY));\n    assert_eq!(Ordering::Greater, (-2.5_f32).total_cmp(&-f32::MAX));\n    assert_eq!(Ordering::Greater, (-1.5_f32).total_cmp(&-2.5));\n    assert_eq!(Ordering::Greater, (-1.0_f32).total_cmp(&-1.5));\n    assert_eq!(Ordering::Greater, (-0.5_f32).total_cmp(&-1.0));\n    assert_eq!(Ordering::Greater, (-f32::MIN_POSITIVE).total_cmp(&-0.5));\n    assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Greater, (-0.0_f32).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Greater, 0.0_f32.total_cmp(&-0.0));\n    assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n    assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Greater, f32::MIN_POSITIVE.total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Greater, 0.5_f32.total_cmp(&f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Greater, 1.0_f32.total_cmp(&0.5));\n    assert_eq!(Ordering::Greater, 1.5_f32.total_cmp(&1.0));\n    assert_eq!(Ordering::Greater, 2.5_f32.total_cmp(&1.5));\n    assert_eq!(Ordering::Greater, f32::MAX.total_cmp(&2.5));\n    assert_eq!(Ordering::Greater, f32::INFINITY.total_cmp(&f32::MAX));\n    assert_eq!(Ordering::Greater, s_nan().total_cmp(&f32::INFINITY));\n    assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::INFINITY));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MAX));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MAX));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::INFINITY));\n    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MAX));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MIN_POSITIVE));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MAX));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::INFINITY));\n    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n}\n\n#[test]\nfn test_lerp_exact() {\n    // simple values\n    assert_eq!(f32::lerp(0.0, 2.0, 4.0), 2.0);\n    assert_eq!(f32::lerp(1.0, 2.0, 4.0), 4.0);\n\n    // boundary values\n    assert_eq!(f32::lerp(0.0, f32::MIN, f32::MAX), f32::MIN);\n    assert_eq!(f32::lerp(1.0, f32::MIN, f32::MAX), f32::MAX);\n}\n\n#[test]\nfn test_lerp_consistent() {\n    assert_eq!(f32::lerp(f32::MAX, f32::MIN, f32::MIN), f32::MIN);\n    assert_eq!(f32::lerp(f32::MIN, f32::MAX, f32::MAX), f32::MAX);\n\n    // as long as t is finite, a/b can be infinite\n    assert_eq!(f32::lerp(f32::MAX, f32::NEG_INFINITY, f32::NEG_INFINITY), f32::NEG_INFINITY);\n    assert_eq!(f32::lerp(f32::MIN, f32::INFINITY, f32::INFINITY), f32::INFINITY);\n}\n\n#[test]\nfn test_lerp_nan_infinite() {\n    // non-finite t is not NaN if a/b different\n    assert!(!f32::lerp(f32::INFINITY, f32::MIN, f32::MAX).is_nan());\n    assert!(!f32::lerp(f32::NEG_INFINITY, f32::MIN, f32::MAX).is_nan());\n}\n\n#[test]\nfn test_lerp_values() {\n    // just a few basic values\n    assert_eq!(f32::lerp(0.25, 1.0, 2.0), 1.25);\n    assert_eq!(f32::lerp(0.50, 1.0, 2.0), 1.50);\n    assert_eq!(f32::lerp(0.75, 1.0, 2.0), 1.75);\n}\n\n#[test]\nfn test_lerp_monotonic() {\n    // near 0\n    let below_zero = f32::lerp(-f32::EPSILON, f32::MIN, f32::MAX);\n    let zero = f32::lerp(0.0, f32::MIN, f32::MAX);\n    let above_zero = f32::lerp(f32::EPSILON, f32::MIN, f32::MAX);\n    assert!(below_zero <= zero);\n    assert!(zero <= above_zero);\n    assert!(below_zero <= above_zero);\n\n    // near 0.5\n    let below_half = f32::lerp(0.5 - f32::EPSILON, f32::MIN, f32::MAX);\n    let half = f32::lerp(0.5, f32::MIN, f32::MAX);\n    let above_half = f32::lerp(0.5 + f32::EPSILON, f32::MIN, f32::MAX);\n    assert!(below_half <= half);\n    assert!(half <= above_half);\n    assert!(below_half <= above_half);\n\n    // near 1\n    let below_one = f32::lerp(1.0 - f32::EPSILON, f32::MIN, f32::MAX);\n    let one = f32::lerp(1.0, f32::MIN, f32::MAX);\n    let above_one = f32::lerp(1.0 + f32::EPSILON, f32::MIN, f32::MAX);\n    assert!(below_one <= one);\n    assert!(one <= above_one);\n    assert!(below_one <= above_one);\n}\n"],["2515","//! Panic support in the standard library.\n\n#![stable(feature = \"std_panic\", since = \"1.9.0\")]\n\nuse crate::any::Any;\nuse crate::cell::UnsafeCell;\nuse crate::collections;\nuse crate::fmt;\nuse crate::future::Future;\nuse crate::ops::{Deref, DerefMut};\nuse crate::panicking;\nuse crate::pin::Pin;\nuse crate::ptr::{NonNull, Unique};\nuse crate::rc::Rc;\nuse crate::stream::Stream;\nuse crate::sync::atomic;\nuse crate::sync::{Arc, Mutex, RwLock};\nuse crate::task::{Context, Poll};\nuse crate::thread::Result;\n\n#[doc(hidden)]\n#[unstable(feature = \"edition_panic\", issue = \"none\", reason = \"use panic!() instead\")]\n#[allow_internal_unstable(libstd_sys_internals)]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"std_panic_2015_macro\")]\n#[rustc_macro_transparency = \"semitransparent\"]\npub macro panic_2015 {\n    () => ({\n        $crate::rt::begin_panic(\"explicit panic\")\n    }),\n    ($msg:expr $(,)?) => ({\n        $crate::rt::begin_panic($msg)\n    }),\n    ($fmt:expr, $($arg:tt)+) => ({\n        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+))\n    }),\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"edition_panic\", issue = \"none\", reason = \"use panic!() instead\")]\npub use core::panic::panic_2021;\n\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub use crate::panicking::{set_hook, take_hook};\n\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub use core::panic::{Location, PanicInfo};\n\n/// Panic the current thread with the given message as the panic payload.\n///\n/// The message can be of any (`Any + Send`) type, not just strings.\n///\n/// The message is wrapped in a `Box<'static + Any + Send>`, which can be\n/// accessed later using [`PanicInfo::payload`].\n///\n/// See the [`panic!`] macro for more information about panicking.\n#[stable(feature = \"panic_any\", since = \"1.51.0\")]\n#[inline]\n#[track_caller]\npub fn panic_any<M: 'static + Any + Send>(msg: M) -> ! {\n    crate::panicking::begin_panic(msg);\n}\n\n/// A marker trait which represents \"panic safe\" types in Rust.\n///\n/// This trait is implemented by default for many types and behaves similarly in\n/// terms of inference of implementation to the [`Send`] and [`Sync`] traits. The\n/// purpose of this trait is to encode what types are safe to cross a [`catch_unwind`]\n/// boundary with no fear of unwind safety.\n///\n/// ## What is unwind safety?\n///\n/// In Rust a function can \"return\" early if it either panics or calls a\n/// function which transitively panics. This sort of control flow is not always\n/// anticipated, and has the possibility of causing subtle bugs through a\n/// combination of two critical components:\n///\n/// 1. A data structure is in a temporarily invalid state when the thread\n///    panics.\n/// 2. This broken invariant is then later observed.\n///\n/// Typically in Rust, it is difficult to perform step (2) because catching a\n/// panic involves either spawning a thread (which in turns makes it difficult\n/// to later witness broken invariants) or using the `catch_unwind` function in this\n/// module. Additionally, even if an invariant is witnessed, it typically isn't a\n/// problem in Rust because there are no uninitialized values (like in C or C++).\n///\n/// It is possible, however, for **logical** invariants to be broken in Rust,\n/// which can end up causing behavioral bugs. Another key aspect of unwind safety\n/// in Rust is that, in the absence of `unsafe` code, a panic cannot lead to\n/// memory unsafety.\n///\n/// That was a bit of a whirlwind tour of unwind safety, but for more information\n/// about unwind safety and how it applies to Rust, see an [associated RFC][rfc].\n///\n/// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n///\n/// ## What is `UnwindSafe`?\n///\n/// Now that we've got an idea of what unwind safety is in Rust, it's also\n/// important to understand what this trait represents. As mentioned above, one\n/// way to witness broken invariants is through the `catch_unwind` function in this\n/// module as it allows catching a panic and then re-using the environment of\n/// the closure.\n///\n/// Simply put, a type `T` implements `UnwindSafe` if it cannot easily allow\n/// witnessing a broken invariant through the use of `catch_unwind` (catching a\n/// panic). This trait is an auto trait, so it is automatically implemented for\n/// many types, and it is also structurally composed (e.g., a struct is unwind\n/// safe if all of its components are unwind safe).\n///\n/// Note, however, that this is not an unsafe trait, so there is not a succinct\n/// contract that this trait is providing. Instead it is intended as more of a\n/// \"speed bump\" to alert users of `catch_unwind` that broken invariants may be\n/// witnessed and may need to be accounted for.\n///\n/// ## Who implements `UnwindSafe`?\n///\n/// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n/// unwind safe. The general idea is that any mutable state which can be shared\n/// across `catch_unwind` is not unwind safe by default. This is because it is very\n/// easy to witness a broken invariant outside of `catch_unwind` as the data is\n/// simply accessed as usual.\n///\n/// Types like `&Mutex<T>`, however, are unwind safe because they implement\n/// poisoning by default. They still allow witnessing a broken invariant, but\n/// they already provide their own \"speed bumps\" to do so.\n///\n/// ## When should `UnwindSafe` be used?\n///\n/// It is not intended that most types or functions need to worry about this trait.\n/// It is only used as a bound on the `catch_unwind` function and as mentioned\n/// above, the lack of `unsafe` means it is mostly an advisory. The\n/// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n/// implemented for any closed over variables passed to `catch_unwind`.\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n#[cfg_attr(all(not(bootstrap), not(test)), lang = \"unwind_safe\")]\n#[rustc_on_unimplemented(\n    message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n    label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n)]\npub auto trait UnwindSafe {}\n\n/// A marker trait representing types where a shared reference is considered\n/// unwind safe.\n///\n/// This trait is namely not implemented by [`UnsafeCell`], the root of all\n/// interior mutability.\n///\n/// This is a \"helper marker trait\" used to provide impl blocks for the\n/// [`UnwindSafe`] trait, for more information see that documentation.\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n#[cfg_attr(all(not(bootstrap), not(test)), lang = \"ref_unwind_safe\")]\n#[rustc_on_unimplemented(\n    message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n               transferrable across a catch_unwind boundary\",\n    label = \"`{Self}` may contain interior mutability and a reference may not be safely \\\n             transferrable across a catch_unwind boundary\"\n)]\npub auto trait RefUnwindSafe {}\n\n/// A simple wrapper around a type to assert that it is unwind safe.\n///\n/// When using [`catch_unwind`] it may be the case that some of the closed over\n/// variables are not unwind safe. For example if `&mut T` is captured the\n/// compiler will generate a warning indicating that it is not unwind safe. It\n/// may not be the case, however, that this is actually a problem due to the\n/// specific usage of [`catch_unwind`] if unwind safety is specifically taken into\n/// account. This wrapper struct is useful for a quick and lightweight\n/// annotation that a variable is indeed unwind safe.\n///\n/// # Examples\n///\n/// One way to use `AssertUnwindSafe` is to assert that the entire closure\n/// itself is unwind safe, bypassing all checks for all variables:\n///\n/// ```\n/// use std::panic::{self, AssertUnwindSafe};\n///\n/// let mut variable = 4;\n///\n/// // This code will not compile because the closure captures `&mut variable`\n/// // which is not considered unwind safe by default.\n///\n/// // panic::catch_unwind(|| {\n/// //     variable += 3;\n/// // });\n///\n/// // This, however, will compile due to the `AssertUnwindSafe` wrapper\n/// let result = panic::catch_unwind(AssertUnwindSafe(|| {\n///     variable += 3;\n/// }));\n/// // ...\n/// ```\n///\n/// Wrapping the entire closure amounts to a blanket assertion that all captured\n/// variables are unwind safe. This has the downside that if new captures are\n/// added in the future, they will also be considered unwind safe. Therefore,\n/// you may prefer to just wrap individual captures, as shown below. This is\n/// more annotation, but it ensures that if a new capture is added which is not\n/// unwind safe, you will get a compilation error at that time, which will\n/// allow you to consider whether that new capture in fact represent a bug or\n/// not.\n///\n/// ```\n/// use std::panic::{self, AssertUnwindSafe};\n///\n/// let mut variable = 4;\n/// let other_capture = 3;\n///\n/// let result = {\n///     let mut wrapper = AssertUnwindSafe(&mut variable);\n///     panic::catch_unwind(move || {\n///         **wrapper += other_capture;\n///     })\n/// };\n/// // ...\n/// ```\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\npub struct AssertUnwindSafe<T>(#[stable(feature = \"catch_unwind\", since = \"1.9.0\")] pub T);\n\n// Implementations of the `UnwindSafe` trait:\n//\n// * By default everything is unwind safe\n// * pointers T contains mutability of some form are not unwind safe\n// * Unique, an owning pointer, lifts an implementation\n// * Types like Mutex/RwLock which are explicitly poisoned are unwind safe\n// * Our custom AssertUnwindSafe wrapper is indeed unwind safe\n\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: ?Sized> !UnwindSafe for &mut T {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: RefUnwindSafe + ?Sized> UnwindSafe for &T {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}\n#[unstable(feature = \"ptr_internals\", issue = \"none\")]\nimpl<T: UnwindSafe + ?Sized> UnwindSafe for Unique<T> {}\n#[stable(feature = \"nonnull\", since = \"1.25.0\")]\nimpl<T: RefUnwindSafe + ?Sized> UnwindSafe for NonNull<T> {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: ?Sized> UnwindSafe for Mutex<T> {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: ?Sized> UnwindSafe for RwLock<T> {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T> UnwindSafe for AssertUnwindSafe<T> {}\n\n// not covered via the Shared impl above b/c the inner contents use\n// Cell/AtomicUsize, but the usage here is unwind safe so we can lift the\n// impl up one level to Arc/Rc itself\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: RefUnwindSafe + ?Sized> UnwindSafe for Arc<T> {}\n\n// Pretty simple implementations for the `RefUnwindSafe` marker trait,\n// basically just saying that `UnsafeCell` is the\n// only thing which doesn't implement it (which then transitively applies to\n// everything else).\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: ?Sized> !RefUnwindSafe for UnsafeCell<T> {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T> RefUnwindSafe for AssertUnwindSafe<T> {}\n\n#[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\nimpl<T: ?Sized> RefUnwindSafe for Mutex<T> {}\n#[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\nimpl<T: ?Sized> RefUnwindSafe for RwLock<T> {}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\nimpl RefUnwindSafe for atomic::AtomicIsize {}\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\nimpl RefUnwindSafe for atomic::AtomicI8 {}\n#[cfg(target_has_atomic_load_store = \"16\")]\n#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\nimpl RefUnwindSafe for atomic::AtomicI16 {}\n#[cfg(target_has_atomic_load_store = \"32\")]\n#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\nimpl RefUnwindSafe for atomic::AtomicI32 {}\n#[cfg(target_has_atomic_load_store = \"64\")]\n#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\nimpl RefUnwindSafe for atomic::AtomicI64 {}\n#[cfg(target_has_atomic_load_store = \"128\")]\n#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\nimpl RefUnwindSafe for atomic::AtomicI128 {}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\nimpl RefUnwindSafe for atomic::AtomicUsize {}\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\nimpl RefUnwindSafe for atomic::AtomicU8 {}\n#[cfg(target_has_atomic_load_store = \"16\")]\n#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\nimpl RefUnwindSafe for atomic::AtomicU16 {}\n#[cfg(target_has_atomic_load_store = \"32\")]\n#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\nimpl RefUnwindSafe for atomic::AtomicU32 {}\n#[cfg(target_has_atomic_load_store = \"64\")]\n#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\nimpl RefUnwindSafe for atomic::AtomicU64 {}\n#[cfg(target_has_atomic_load_store = \"128\")]\n#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\nimpl RefUnwindSafe for atomic::AtomicU128 {}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\nimpl RefUnwindSafe for atomic::AtomicBool {}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\nimpl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n\n// https://github.com/rust-lang/rust/issues/62301\n#[stable(feature = \"hashbrown\", since = \"1.36.0\")]\nimpl<K, V, S> UnwindSafe for collections::HashMap<K, V, S>\nwhere\n    K: UnwindSafe,\n    V: UnwindSafe,\n    S: UnwindSafe,\n{\n}\n\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T> Deref for AssertUnwindSafe<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\n\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T> DerefMut for AssertUnwindSafe<T> {\n    fn deref_mut(&mut self) -> &mut T {\n        &mut self.0\n    }\n}\n\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n    type Output = R;\n\n    extern \"rust-call\" fn call_once(self, _args: ()) -> R {\n        (self.0)()\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"AssertUnwindSafe\").field(&self.0).finish()\n    }\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl<F: Future> Future for AssertUnwindSafe<F> {\n    type Output = F::Output;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n        F::poll(pinned_field, cx)\n    }\n}\n\n#[unstable(feature = \"async_stream\", issue = \"79024\")]\nimpl<S: Stream> Stream for AssertUnwindSafe<S> {\n    type Item = S::Item;\n\n    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<S::Item>> {\n        unsafe { self.map_unchecked_mut(|x| &mut x.0) }.poll_next(cx)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\n/// Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n///\n/// This function will return `Ok` with the closure's result if the closure\n/// does not panic, and will return `Err(cause)` if the closure panics. The\n/// `cause` returned is the object with which panic was originally invoked.\n///\n/// It is currently undefined behavior to unwind from Rust code into foreign\n/// code, so this function is particularly useful when Rust is called from\n/// another language (normally C). This can run arbitrary Rust code, capturing a\n/// panic and allowing a graceful handling of the error.\n///\n/// It is **not** recommended to use this function for a general try/catch\n/// mechanism. The [`Result`] type is more appropriate to use for functions that\n/// can fail on a regular basis. Additionally, this function is not guaranteed\n/// to catch all panics, see the \"Notes\" section below.\n///\n/// The closure provided is required to adhere to the [`UnwindSafe`] trait to ensure\n/// that all captured variables are safe to cross this boundary. The purpose of\n/// this bound is to encode the concept of [exception safety][rfc] in the type\n/// system. Most usage of this function should not need to worry about this\n/// bound as programs are naturally unwind safe without `unsafe` code. If it\n/// becomes a problem the [`AssertUnwindSafe`] wrapper struct can be used to quickly\n/// assert that the usage here is indeed unwind safe.\n///\n/// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n///\n/// # Notes\n///\n/// Note that this function **may not catch all panics** in Rust. A panic in\n/// Rust is not always implemented via unwinding, but can be implemented by\n/// aborting the process as well. This function *only* catches unwinding panics,\n/// not those that abort the process.\n///\n/// Also note that unwinding into Rust code with a foreign exception (e.g.\n/// an exception thrown from C++ code) is undefined behavior.\n///\n/// # Examples\n///\n/// ```\n/// use std::panic;\n///\n/// let result = panic::catch_unwind(|| {\n///     println!(\"hello!\");\n/// });\n/// assert!(result.is_ok());\n///\n/// let result = panic::catch_unwind(|| {\n///     panic!(\"oh no!\");\n/// });\n/// assert!(result.is_err());\n/// ```\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\npub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    unsafe { panicking::r#try(f) }\n}\n\n/// Triggers a panic without invoking the panic hook.\n///\n/// This is designed to be used in conjunction with [`catch_unwind`] to, for\n/// example, carry a panic across a layer of C code.\n///\n/// # Notes\n///\n/// Note that panics in Rust are not always implemented via unwinding, but they\n/// may be implemented by aborting the process. If this function is called when\n/// panics are implemented this way then this function will abort the process,\n/// not trigger an unwind.\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// let result = panic::catch_unwind(|| {\n///     panic!(\"oh no!\");\n/// });\n///\n/// if let Err(err) = result {\n///     panic::resume_unwind(err);\n/// }\n/// ```\n#[stable(feature = \"resume_unwind\", since = \"1.9.0\")]\npub fn resume_unwind(payload: Box<dyn Any + Send>) -> ! {\n    panicking::rust_panic_without_hook(payload)\n}\n\n/// Make all future panics abort directly without running the panic hook or unwinding.\n///\n/// There is no way to undo this; the effect lasts until the process exits or\n/// execs (or the equivalent).\n///\n/// # Use after fork\n///\n/// This function is particularly useful for calling after `libc::fork`.  After `fork`, in a\n/// multithreaded program it is (on many platforms) not safe to call the allocator.  It is also\n/// generally highly undesirable for an unwind to unwind past the `fork`, because that results in\n/// the unwind propagating to code that was only ever expecting to run in the parent.\n///\n/// `panic::always_abort()` helps avoid both of these.  It directly avoids any further unwinding,\n/// and if there is a panic, the abort will occur without allocating provided that the arguments to\n/// panic can be formatted without allocating.\n///\n/// Examples\n///\n/// ```no_run\n/// #![feature(panic_always_abort)]\n/// use std::panic;\n///\n/// panic::always_abort();\n///\n/// let _ = panic::catch_unwind(|| {\n///     panic!(\"inside the catch\");\n/// });\n///\n/// // We will have aborted already, due to the panic.\n/// unreachable!();\n/// ```\n#[unstable(feature = \"panic_always_abort\", issue = \"84438\")]\npub fn always_abort() {\n    crate::panicking::panic_count::set_always_abort();\n}\n\n#[cfg(test)]\nmod tests;\n"],["2516","use super::{Custom, Error, ErrorKind, Repr};\nuse crate::error;\nuse crate::fmt;\nuse crate::mem::size_of;\nuse crate::sys::decode_error_kind;\nuse crate::sys::os::error_string;\n\n#[test]\nfn test_size() {\n    assert!(size_of::<Error>() <= size_of::<[usize; 2]>());\n}\n\n#[test]\nfn test_debug_error() {\n    let code = 6;\n    let msg = error_string(code);\n    let kind = decode_error_kind(code);\n    let err = Error {\n        repr: Repr::Custom(box Custom {\n            kind: ErrorKind::InvalidInput,\n            error: box Error { repr: super::Repr::Os(code) },\n        }),\n    };\n    let expected = format!(\n        \"Custom {{ \\\n         kind: InvalidInput, \\\n         error: Os {{ \\\n         code: {:?}, \\\n         kind: {:?}, \\\n         message: {:?} \\\n         }} \\\n         }}\",\n        code, kind, msg\n    );\n    assert_eq!(format!(\"{:?}\", err), expected);\n}\n\n#[test]\nfn test_downcasting() {\n    #[derive(Debug)]\n    struct TestError;\n\n    impl fmt::Display for TestError {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.write_str(\"asdf\")\n        }\n    }\n\n    impl error::Error for TestError {}\n\n    // we have to call all of these UFCS style right now since method\n    // resolution won't implicitly drop the Send+Sync bounds\n    let mut err = Error::new(ErrorKind::Other, TestError);\n    assert!(err.get_ref().unwrap().is::<TestError>());\n    assert_eq!(\"asdf\", err.get_ref().unwrap().to_string());\n    assert!(err.get_mut().unwrap().is::<TestError>());\n    let extracted = err.into_inner().unwrap();\n    extracted.downcast::<TestError>().unwrap();\n}\n\n#[test]\nfn test_const() {\n    const E: Error = Error::new_const(ErrorKind::NotFound, &\"hello\");\n\n    assert_eq!(E.kind(), ErrorKind::NotFound);\n    assert_eq!(E.to_string(), \"hello\");\n    assert!(format!(\"{:?}\", E).contains(\"\\\"hello\\\"\"));\n    assert!(format!(\"{:?}\", E).contains(\"NotFound\"));\n}\n"],["2517","//! The I/O Prelude.\n//!\n//! The purpose of this module is to alleviate imports of many common I/O traits\n//! by adding a glob import to the top of I/O heavy modules:\n//!\n//! ```\n//! # #![allow(unused_imports)]\n//! use std::io::prelude::*;\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use super::{BufRead, Read, Seek, Write};\n"],["2518","#[cfg(test)]\nmod tests;\n\nuse crate::io::prelude::*;\n\nuse crate::cmp;\nuse crate::io::{self, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, SeekFrom};\n\nuse core::convert::TryInto;\n\n/// A `Cursor` wraps an in-memory buffer and provides it with a\n/// [`Seek`] implementation.\n///\n/// `Cursor`s are used with in-memory buffers, anything implementing\n/// [`AsRef`]`<[u8]>`, to allow them to implement [`Read`] and/or [`Write`],\n/// allowing these buffers to be used anywhere you might use a reader or writer\n/// that does actual I/O.\n///\n/// The standard library implements some I/O traits on various types which\n/// are commonly used as a buffer, like `Cursor<`[`Vec`]`<u8>>` and\n/// `Cursor<`[`&[u8]`][bytes]`>`.\n///\n/// # Examples\n///\n/// We may want to write bytes to a [`File`] in our production\n/// code, but use an in-memory buffer in our tests. We can do this with\n/// `Cursor`:\n///\n/// [bytes]: crate::slice\n/// [`File`]: crate::fs::File\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::{self, SeekFrom};\n/// use std::fs::File;\n///\n/// // a library function we've written\n/// fn write_ten_bytes_at_end<W: Write + Seek>(writer: &mut W) -> io::Result<()> {\n///     writer.seek(SeekFrom::End(-10))?;\n///\n///     for i in 0..10 {\n///         writer.write(&[i])?;\n///     }\n///\n///     // all went well\n///     Ok(())\n/// }\n///\n/// # fn foo() -> io::Result<()> {\n/// // Here's some code that uses this library function.\n/// //\n/// // We might want to use a BufReader here for efficiency, but let's\n/// // keep this example focused.\n/// let mut file = File::create(\"foo.txt\")?;\n///\n/// write_ten_bytes_at_end(&mut file)?;\n/// # Ok(())\n/// # }\n///\n/// // now let's write a test\n/// #[test]\n/// fn test_writes_bytes() {\n///     // setting up a real File is much slower than an in-memory buffer,\n///     // let's use a cursor instead\n///     use std::io::Cursor;\n///     let mut buff = Cursor::new(vec![0; 15]);\n///\n///     write_ten_bytes_at_end(&mut buff).unwrap();\n///\n///     assert_eq!(&buff.get_ref()[5..15], &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug, Default, Eq, PartialEq)]\npub struct Cursor<T> {\n    inner: T,\n    pos: u64,\n}\n\nimpl<T> Cursor<T> {\n    /// Creates a new cursor wrapping the provided underlying in-memory buffer.\n    ///\n    /// Cursor initial position is `0` even if underlying buffer (e.g., [`Vec`])\n    /// is not empty. So writing to cursor starts with overwriting [`Vec`]\n    /// content, not with appending to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\n    pub const fn new(inner: T) -> Cursor<T> {\n        Cursor { pos: 0, inner }\n    }\n\n    /// Consumes this cursor, returning the underlying value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    ///\n    /// let vec = buff.into_inner();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> T {\n        self.inner\n    }\n\n    /// Gets a reference to the underlying value in this cursor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    ///\n    /// let reference = buff.get_ref();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\n    pub const fn get_ref(&self) -> &T {\n        &self.inner\n    }\n\n    /// Gets a mutable reference to the underlying value in this cursor.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying value as it may corrupt this cursor's position.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let mut buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    ///\n    /// let reference = buff.get_mut();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.inner\n    }\n\n    /// Returns the current position of this cursor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    /// use std::io::prelude::*;\n    /// use std::io::SeekFrom;\n    ///\n    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n    ///\n    /// assert_eq!(buff.position(), 0);\n    ///\n    /// buff.seek(SeekFrom::Current(2)).unwrap();\n    /// assert_eq!(buff.position(), 2);\n    ///\n    /// buff.seek(SeekFrom::Current(-1)).unwrap();\n    /// assert_eq!(buff.position(), 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\n    pub const fn position(&self) -> u64 {\n        self.pos\n    }\n\n    /// Sets the position of this cursor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n    ///\n    /// assert_eq!(buff.position(), 0);\n    ///\n    /// buff.set_position(2);\n    /// assert_eq!(buff.position(), 2);\n    ///\n    /// buff.set_position(4);\n    /// assert_eq!(buff.position(), 4);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_position(&mut self, pos: u64) {\n        self.pos = pos;\n    }\n}\n\nimpl<T> Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    /// Returns the remaining length.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(cursor_remaining)]\n    /// use std::io::Cursor;\n    ///\n    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n    ///\n    /// assert_eq!(buff.remaining(), 5);\n    ///\n    /// buff.set_position(2);\n    /// assert_eq!(buff.remaining(), 3);\n    ///\n    /// buff.set_position(4);\n    /// assert_eq!(buff.remaining(), 1);\n    ///\n    /// buff.set_position(6);\n    /// assert_eq!(buff.remaining(), 0);\n    /// ```\n    #[unstable(feature = \"cursor_remaining\", issue = \"86369\")]\n    pub fn remaining(&self) -> u64 {\n        (self.inner.as_ref().len() as u64).checked_sub(self.pos).unwrap_or(0)\n    }\n\n    /// Returns the remaining slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(cursor_remaining)]\n    /// use std::io::Cursor;\n    ///\n    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n    ///\n    /// assert_eq!(buff.remaining_slice(), &[1, 2, 3, 4, 5]);\n    ///\n    /// buff.set_position(2);\n    /// assert_eq!(buff.remaining_slice(), &[3, 4, 5]);\n    ///\n    /// buff.set_position(4);\n    /// assert_eq!(buff.remaining_slice(), &[5]);\n    ///\n    /// buff.set_position(6);\n    /// assert_eq!(buff.remaining_slice(), &[]);\n    /// ```\n    #[unstable(feature = \"cursor_remaining\", issue = \"86369\")]\n    pub fn remaining_slice(&self) -> &[u8] {\n        let len = self.pos.min(self.inner.as_ref().len() as u64);\n        &self.inner.as_ref()[(len as usize)..]\n    }\n\n    /// Returns `true` if the remaining slice is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(cursor_remaining)]\n    /// use std::io::Cursor;\n    ///\n    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n    ///\n    /// buff.set_position(2);\n    /// assert!(!buff.is_empty());\n    ///\n    /// buff.set_position(5);\n    /// assert!(buff.is_empty());\n    ///\n    /// buff.set_position(10);\n    /// assert!(buff.is_empty());\n    /// ```\n    #[unstable(feature = \"cursor_remaining\", issue = \"86369\")]\n    pub fn is_empty(&self) -> bool {\n        self.pos >= self.inner.as_ref().len() as u64\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Cursor<T>\nwhere\n    T: Clone,\n{\n    #[inline]\n    fn clone(&self) -> Self {\n        Cursor { inner: self.inner.clone(), pos: self.pos }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, other: &Self) {\n        self.inner.clone_from(&other.inner);\n        self.pos = other.pos;\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> io::Seek for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn seek(&mut self, style: SeekFrom) -> io::Result<u64> {\n        let (base_pos, offset) = match style {\n            SeekFrom::Start(n) => {\n                self.pos = n;\n                return Ok(n);\n            }\n            SeekFrom::End(n) => (self.inner.as_ref().len() as u64, n),\n            SeekFrom::Current(n) => (self.pos, n),\n        };\n        let new_pos = if offset >= 0 {\n            base_pos.checked_add(offset as u64)\n        } else {\n            base_pos.checked_sub((offset.wrapping_neg()) as u64)\n        };\n        match new_pos {\n            Some(n) => {\n                self.pos = n;\n                Ok(self.pos)\n            }\n            None => Err(Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"invalid seek to a negative or overflowing position\",\n            )),\n        }\n    }\n\n    fn stream_len(&mut self) -> io::Result<u64> {\n        Ok(self.inner.as_ref().len() as u64)\n    }\n\n    fn stream_position(&mut self) -> io::Result<u64> {\n        Ok(self.pos)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Read for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let n = Read::read(&mut self.remaining_slice(), buf)?;\n        self.pos += n as u64;\n        Ok(n)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nread = 0;\n        for buf in bufs {\n            let n = self.read(buf)?;\n            nread += n;\n            if n < buf.len() {\n                break;\n            }\n        }\n        Ok(nread)\n    }\n\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        let n = buf.len();\n        Read::read_exact(&mut self.remaining_slice(), buf)?;\n        self.pos += n as u64;\n        Ok(())\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> BufRead for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        Ok(self.remaining_slice())\n    }\n    fn consume(&mut self, amt: usize) {\n        self.pos += amt as u64;\n    }\n}\n\n// Non-resizing write implementation\n#[inline]\nfn slice_write(pos_mut: &mut u64, slice: &mut [u8], buf: &[u8]) -> io::Result<usize> {\n    let pos = cmp::min(*pos_mut, slice.len() as u64);\n    let amt = (&mut slice[(pos as usize)..]).write(buf)?;\n    *pos_mut += amt as u64;\n    Ok(amt)\n}\n\n#[inline]\nfn slice_write_vectored(\n    pos_mut: &mut u64,\n    slice: &mut [u8],\n    bufs: &[IoSlice<'_>],\n) -> io::Result<usize> {\n    let mut nwritten = 0;\n    for buf in bufs {\n        let n = slice_write(pos_mut, slice, buf)?;\n        nwritten += n;\n        if n < buf.len() {\n            break;\n        }\n    }\n    Ok(nwritten)\n}\n\n// Resizing write implementation\nfn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n    let pos: usize = (*pos_mut).try_into().map_err(|_| {\n        Error::new_const(\n            ErrorKind::InvalidInput,\n            &\"cursor position exceeds maximum possible vector length\",\n        )\n    })?;\n    // Make sure the internal buffer is as least as big as where we\n    // currently are\n    let len = vec.len();\n    if len < pos {\n        // use `resize` so that the zero filling is as efficient as possible\n        vec.resize(pos, 0);\n    }\n    // Figure out what bytes will be used to overwrite what's currently\n    // there (left), and what will be appended on the end (right)\n    {\n        let space = vec.len() - pos;\n        let (left, right) = buf.split_at(cmp::min(space, buf.len()));\n        vec[pos..pos + left.len()].copy_from_slice(left);\n        vec.extend_from_slice(right);\n    }\n\n    // Bump us forward\n    *pos_mut = (pos + buf.len()) as u64;\n    Ok(buf.len())\n}\n\nfn vec_write_vectored(\n    pos_mut: &mut u64,\n    vec: &mut Vec<u8>,\n    bufs: &[IoSlice<'_>],\n) -> io::Result<usize> {\n    let mut nwritten = 0;\n    for buf in bufs {\n        nwritten += vec_write(pos_mut, vec, buf)?;\n    }\n    Ok(nwritten)\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Cursor<&mut [u8]> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        slice_write(&mut self.pos, self.inner, buf)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        slice_write_vectored(&mut self.pos, self.inner, bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"cursor_mut_vec\", since = \"1.25.0\")]\nimpl Write for Cursor<&mut Vec<u8>> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        vec_write(&mut self.pos, self.inner, buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        vec_write_vectored(&mut self.pos, self.inner, bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Cursor<Vec<u8>> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        vec_write(&mut self.pos, &mut self.inner, buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        vec_write_vectored(&mut self.pos, &mut self.inner, bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"cursor_box_slice\", since = \"1.5.0\")]\nimpl Write for Cursor<Box<[u8]>> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        slice_write(&mut self.pos, &mut self.inner, buf)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        slice_write_vectored(&mut self.pos, &mut self.inner, bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n"],["2519","//! Traits, helpers, and type definitions for core I/O functionality.\n//!\n//! The `std::io` module contains a number of common things you'll need\n//! when doing input and output. The most core part of this module is\n//! the [`Read`] and [`Write`] traits, which provide the\n//! most general interface for reading and writing input and output.\n//!\n//! # Read and Write\n//!\n//! Because they are traits, [`Read`] and [`Write`] are implemented by a number\n//! of other types, and you can implement them for your types too. As such,\n//! you'll see a few different types of I/O throughout the documentation in\n//! this module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s. For\n//! example, [`Read`] adds a [`read`][`Read::read`] method, which we can use on\n//! [`File`]s:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let mut f = File::open(\"foo.txt\")?;\n//!     let mut buffer = [0; 10];\n//!\n//!     // read up to 10 bytes\n//!     let n = f.read(&mut buffer)?;\n//!\n//!     println!(\"The bytes: {:?}\", &buffer[..n]);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [`Read`] and [`Write`] are so important, implementors of the two traits have a\n//! nickname: readers and writers. So you'll sometimes see 'a reader' instead\n//! of 'a type that implements the [`Read`] trait'. Much easier!\n//!\n//! ## Seek and BufRead\n//!\n//! Beyond that, there are two important traits that are provided: [`Seek`]\n//! and [`BufRead`]. Both of these build on top of a reader to control\n//! how the reading happens. [`Seek`] lets you control where the next byte is\n//! coming from:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::SeekFrom;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let mut f = File::open(\"foo.txt\")?;\n//!     let mut buffer = [0; 10];\n//!\n//!     // skip to the last 10 bytes of the file\n//!     f.seek(SeekFrom::End(-10))?;\n//!\n//!     // read up to 10 bytes\n//!     let n = f.read(&mut buffer)?;\n//!\n//!     println!(\"The bytes: {:?}\", &buffer[..n]);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [`BufRead`] uses an internal buffer to provide a number of other ways to read, but\n//! to show it off, we'll need to talk about buffers in general. Keep reading!\n//!\n//! ## BufReader and BufWriter\n//!\n//! Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be\n//! making near-constant calls to the operating system. To help with this,\n//! `std::io` comes with two structs, [`BufReader`] and [`BufWriter`], which wrap\n//! readers and writers. The wrapper uses a buffer, reducing the number of\n//! calls and providing nicer methods for accessing exactly what you want.\n//!\n//! For example, [`BufReader`] works with the [`BufRead`] trait to add extra\n//! methods to any reader:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let f = File::open(\"foo.txt\")?;\n//!     let mut reader = BufReader::new(f);\n//!     let mut buffer = String::new();\n//!\n//!     // read a line into buffer\n//!     reader.read_line(&mut buffer)?;\n//!\n//!     println!(\"{}\", buffer);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [`BufWriter`] doesn't add any new ways of writing; it just buffers every call\n//! to [`write`][`Write::write`]:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufWriter;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let f = File::create(\"foo.txt\")?;\n//!     {\n//!         let mut writer = BufWriter::new(f);\n//!\n//!         // write a byte to the buffer\n//!         writer.write(&[42])?;\n//!\n//!     } // the buffer is flushed once writer goes out of scope\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Standard input and output\n//!\n//! A very common source of input is standard input:\n//!\n//! ```no_run\n//! use std::io;\n//!\n//! fn main() -> io::Result<()> {\n//!     let mut input = String::new();\n//!\n//!     io::stdin().read_line(&mut input)?;\n//!\n//!     println!(\"You typed: {}\", input.trim());\n//!     Ok(())\n//! }\n//! ```\n//!\n//! Note that you cannot use the [`?` operator] in functions that do not return\n//! a [`Result<T, E>`][`Result`]. Instead, you can call [`.unwrap()`]\n//! or `match` on the return value to catch any possible errors:\n//!\n//! ```no_run\n//! use std::io;\n//!\n//! let mut input = String::new();\n//!\n//! io::stdin().read_line(&mut input).unwrap();\n//! ```\n//!\n//! And a very common source of output is standard output:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//!\n//! fn main() -> io::Result<()> {\n//!     io::stdout().write(&[42])?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! Of course, using [`io::stdout`] directly is less common than something like\n//! [`println!`].\n//!\n//! ## Iterator types\n//!\n//! A large number of the structures provided by `std::io` are for various\n//! ways of iterating over I/O. For example, [`Lines`] is used to split over\n//! lines:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let f = File::open(\"foo.txt\")?;\n//!     let reader = BufReader::new(f);\n//!\n//!     for line in reader.lines() {\n//!         println!(\"{}\", line?);\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Functions\n//!\n//! There are a number of [functions][functions-list] that offer access to various\n//! features. For example, we can use three of these functions to copy everything\n//! from standard input to standard output:\n//!\n//! ```no_run\n//! use std::io;\n//!\n//! fn main() -> io::Result<()> {\n//!     io::copy(&mut io::stdin(), &mut io::stdout())?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [functions-list]: #functions-1\n//!\n//! ## io::Result\n//!\n//! Last, but certainly not least, is [`io::Result`]. This type is used\n//! as the return type of many `std::io` functions that can cause an error, and\n//! can be returned from your own functions as well. Many of the examples in this\n//! module use the [`?` operator]:\n//!\n//! ```\n//! use std::io;\n//!\n//! fn read_input() -> io::Result<()> {\n//!     let mut input = String::new();\n//!\n//!     io::stdin().read_line(&mut input)?;\n//!\n//!     println!(\"You typed: {}\", input.trim());\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! The return type of `read_input()`, [`io::Result<()>`][`io::Result`], is a very\n//! common type for functions which don't have a 'real' return value, but do want to\n//! return errors if they happen. In this case, the only purpose of this function is\n//! to read the line and print it, so we use `()`.\n//!\n//! ## Platform-specific behavior\n//!\n//! Many I/O functions throughout the standard library are documented to indicate\n//! what various library or syscalls they are delegated to. This is done to help\n//! applications both understand what's happening under the hood as well as investigate\n//! any possibly unclear semantics. Note, however, that this is informative, not a binding\n//! contract. The implementation of many of these functions are subject to change over\n//! time and may call fewer or more syscalls/library functions.\n//!\n//! [`File`]: crate::fs::File\n//! [`TcpStream`]: crate::net::TcpStream\n//! [`io::stdout`]: stdout\n//! [`io::Result`]: self::Result\n//! [`?` operator]: ../../book/appendix-02-operators.html\n//! [`Result`]: crate::result::Result\n//! [`.unwrap()`]: crate::result::Result::unwrap\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::cmp;\nuse crate::convert::TryInto;\nuse crate::fmt;\nuse crate::mem::replace;\nuse crate::ops::{Deref, DerefMut};\nuse crate::ptr;\nuse crate::slice;\nuse crate::str;\nuse crate::sys;\nuse crate::sys_common::memchr;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::IntoInnerError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::{BufReader, BufWriter, LineWriter};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::copy::copy;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::cursor::Cursor;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::error::{Error, ErrorKind, Result};\n#[unstable(feature = \"internal_output_capture\", issue = \"none\")]\n#[doc(no_inline, hidden)]\npub use self::stdio::set_output_capture;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n#[unstable(feature = \"print_internals\", issue = \"none\")]\npub use self::stdio::{_eprint, _print};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::util::{empty, repeat, sink, Empty, Repeat, Sink};\n\nmod buffered;\npub(crate) mod copy;\nmod cursor;\nmod error;\nmod impls;\npub mod prelude;\nmod stdio;\nmod util;\n\nconst DEFAULT_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n\npub(crate) fn cleanup() {\n    stdio::cleanup()\n}\n\nstruct Guard<'a> {\n    buf: &'a mut Vec<u8>,\n    len: usize,\n}\n\nimpl Drop for Guard<'_> {\n    fn drop(&mut self) {\n        unsafe {\n            self.buf.set_len(self.len);\n        }\n    }\n}\n\n// A few methods below (read_to_string, read_line) will append data into a\n// `String` buffer, but we need to be pretty careful when doing this. The\n// implementation will just call `.as_mut_vec()` and then delegate to a\n// byte-oriented reading method, but we must ensure that when returning we never\n// leave `buf` in a state such that it contains invalid UTF-8 in its bounds.\n//\n// To this end, we use an RAII guard (to protect against panics) which updates\n// the length of the string when it is dropped. This guard initially truncates\n// the string to the prior length and only after we've validated that the\n// new contents are valid UTF-8 do we allow it to set a longer length.\n//\n// The unsafety in this function is twofold:\n//\n// 1. We're looking at the raw bytes of `buf`, so we take on the burden of UTF-8\n//    checks.\n// 2. We're passing a raw buffer to the function `f`, and it is expected that\n//    the function only *appends* bytes to the buffer. We'll get undefined\n//    behavior if existing bytes are overwritten to have non-UTF-8 data.\nfn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\nwhere\n    F: FnOnce(&mut Vec<u8>) -> Result<usize>,\n{\n    unsafe {\n        let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };\n        let ret = f(g.buf);\n        if str::from_utf8(&g.buf[g.len..]).is_err() {\n            ret.and_then(|_| {\n                Err(Error::new_const(ErrorKind::InvalidData, &\"stream did not contain valid UTF-8\"))\n            })\n        } else {\n            g.len = g.buf.len();\n            ret\n        }\n    }\n}\n\n// This uses an adaptive system to extend the vector when it fills. We want to\n// avoid paying to allocate and zero a huge chunk of memory if the reader only\n// has 4 bytes while still making large reads if the reader does have a ton\n// of data to return. Simply tacking on an extra DEFAULT_BUF_SIZE space every\n// time is 4,500 times (!) slower than a default reservation size of 32 if the\n// reader has a very small amount of data to return.\n//\n// Because we're extending the buffer with uninitialized data for trusted\n// readers, we need to make sure to truncate that if any of this panics.\nfn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n    read_to_end_with_reservation(r, buf, |_| 32)\n}\n\nfn read_to_end_with_reservation<R, F>(\n    r: &mut R,\n    buf: &mut Vec<u8>,\n    mut reservation_size: F,\n) -> Result<usize>\nwhere\n    R: Read + ?Sized,\n    F: FnMut(&R) -> usize,\n{\n    let start_len = buf.len();\n    let mut g = Guard { len: buf.len(), buf };\n    loop {\n        if g.len == g.buf.len() {\n            unsafe {\n                // FIXME(danielhenrymantilla): #42788\n                //\n                //   - This creates a (mut) reference to a slice of\n                //     _uninitialized_ integers, which is **undefined behavior**\n                //\n                //   - Only the standard library gets to soundly \"ignore\" this,\n                //     based on its privileged knowledge of unstable rustc\n                //     internals;\n                g.buf.reserve(reservation_size(r));\n                let capacity = g.buf.capacity();\n                g.buf.set_len(capacity);\n                r.initializer().initialize(&mut g.buf[g.len..]);\n            }\n        }\n\n        let buf = &mut g.buf[g.len..];\n        match r.read(buf) {\n            Ok(0) => return Ok(g.len - start_len),\n            Ok(n) => {\n                // We can't allow bogus values from read. If it is too large, the returned vec could have its length\n                // set past its capacity, or if it overflows the vec could be shortened which could create an invalid\n                // string if this is called via read_to_string.\n                assert!(n <= buf.len());\n                g.len += n;\n            }\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            Err(e) => return Err(e),\n        }\n    }\n}\n\npub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize>\nwhere\n    F: FnOnce(&mut [u8]) -> Result<usize>,\n{\n    let buf = bufs.iter_mut().find(|b| !b.is_empty()).map_or(&mut [][..], |b| &mut **b);\n    read(buf)\n}\n\npub(crate) fn default_write_vectored<F>(write: F, bufs: &[IoSlice<'_>]) -> Result<usize>\nwhere\n    F: FnOnce(&[u8]) -> Result<usize>,\n{\n    let buf = bufs.iter().find(|b| !b.is_empty()).map_or(&[][..], |b| &**b);\n    write(buf)\n}\n\npub(crate) fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [u8]) -> Result<()> {\n    while !buf.is_empty() {\n        match this.read(buf) {\n            Ok(0) => break,\n            Ok(n) => {\n                let tmp = buf;\n                buf = &mut tmp[n..];\n            }\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            Err(e) => return Err(e),\n        }\n    }\n    if !buf.is_empty() {\n        Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n    } else {\n        Ok(())\n    }\n}\n\n/// The `Read` trait allows for reading bytes from a source.\n///\n/// Implementors of the `Read` trait are called 'readers'.\n///\n/// Readers are defined by one required method, [`read()`]. Each call to [`read()`]\n/// will attempt to pull bytes from this source into a provided buffer. A\n/// number of other methods are implemented in terms of [`read()`], giving\n/// implementors a number of ways to read bytes while only needing to implement\n/// a single method.\n///\n/// Readers are intended to be composable with one another. Many implementors\n/// throughout [`std::io`] take and provide types which implement the `Read`\n/// trait.\n///\n/// Please note that each call to [`read()`] may involve a system call, and\n/// therefore, using something that implements [`BufRead`], such as\n/// [`BufReader`], will be more efficient.\n///\n/// # Examples\n///\n/// [`File`]s implement `Read`:\n///\n/// ```no_run\n/// use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// fn main() -> io::Result<()> {\n///     let mut f = File::open(\"foo.txt\")?;\n///     let mut buffer = [0; 10];\n///\n///     // read up to 10 bytes\n///     f.read(&mut buffer)?;\n///\n///     let mut buffer = Vec::new();\n///     // read the whole file\n///     f.read_to_end(&mut buffer)?;\n///\n///     // read into a String, so that you don't need to do the conversion.\n///     let mut buffer = String::new();\n///     f.read_to_string(&mut buffer)?;\n///\n///     // and more! See the other methods for more details.\n///     Ok(())\n/// }\n/// ```\n///\n/// Read from [`&str`] because [`&[u8]`][prim@slice] implements `Read`:\n///\n/// ```no_run\n/// # use std::io;\n/// use std::io::prelude::*;\n///\n/// fn main() -> io::Result<()> {\n///     let mut b = \"This string will be read\".as_bytes();\n///     let mut buffer = [0; 10];\n///\n///     // read up to 10 bytes\n///     b.read(&mut buffer)?;\n///\n///     // etc... it works exactly as a File does!\n///     Ok(())\n/// }\n/// ```\n///\n/// [`read()`]: Read::read\n/// [`&str`]: prim@str\n/// [`std::io`]: self\n/// [`File`]: crate::fs::File\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(notable_trait)]\npub trait Read {\n    /// Pull some bytes from this source into the specified buffer, returning\n    /// how many bytes were read.\n    ///\n    /// This function does not provide any guarantees about whether it blocks\n    /// waiting for data, but if an object needs to block for a read and cannot,\n    /// it will typically signal this via an [`Err`] return value.\n    ///\n    /// If the return value of this method is [`Ok(n)`], then implementations must\n    /// guarantee that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n    /// that the buffer `buf` has been filled in with `n` bytes of data from this\n    /// source. If `n` is `0`, then it can indicate one of two scenarios:\n    ///\n    /// 1. This reader has reached its \"end of file\" and will likely no longer\n    ///    be able to produce bytes. Note that this does not mean that the\n    ///    reader will *always* no longer be able to produce bytes. As an example,\n    ///    on Linux, this method will call the `recv` syscall for a [`TcpStream`],\n    ///    where returning zero indicates the connection was shut down correctly. While\n    ///    for [`File`], it is possible to reach the end of file and get zero as result,\n    ///    but if more data is appended to the file, future calls to `read` will return\n    ///    more data.\n    /// 2. The buffer specified was 0 bytes in length.\n    ///\n    /// It is not an error if the returned value `n` is smaller than the buffer size,\n    /// even when the reader is not at the end of the stream yet.\n    /// This may happen for example because fewer bytes are actually available right now\n    /// (e. g. being close to end-of-file) or because read() was interrupted by a signal.\n    ///\n    /// As this trait is safe to implement, callers cannot rely on `n <= buf.len()` for safety.\n    /// Extra care needs to be taken when `unsafe` functions are used to access the read bytes.\n    /// Callers have to ensure that no unchecked out-of-bounds accesses are possible even if\n    /// `n > buf.len()`.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that *implementations*\n    /// only write data to `buf` instead of reading its contents.\n    ///\n    /// Correspondingly, however, *callers* of this method may not assume any guarantees\n    /// about how the implementation uses `buf`. The trait is safe to implement,\n    /// so it is possible that the code that's supposed to write to the buffer might also read\n    /// from it. It is your responsibility to make sure that `buf` is initialized\n    /// before calling `read`. Calling `read` with an uninitialized `buf` (of the kind one\n    /// obtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.\n    ///\n    /// [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters any form of I/O or other error, an error\n    /// variant will be returned. If an error is returned then it must be\n    /// guaranteed that no bytes were read.\n    ///\n    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the read\n    /// operation should be retried if there is nothing else to do.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`Ok(n)`]: Ok\n    /// [`File`]: crate::fs::File\n    /// [`TcpStream`]: crate::net::TcpStream\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = [0; 10];\n    ///\n    ///     // read up to 10 bytes\n    ///     let n = f.read(&mut buffer[..])?;\n    ///\n    ///     println!(\"The bytes: {:?}\", &buffer[..n]);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n\n    /// Like `read`, except that it reads into a slice of buffers.\n    ///\n    /// Data is copied to fill each buffer in order, with the final buffer\n    /// written to possibly being only partially filled. This method must\n    /// behave equivalently to a single call to `read` with concatenated\n    /// buffers.\n    ///\n    /// The default implementation calls `read` with either the first nonempty\n    /// buffer provided, or an empty one if none exists.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> Result<usize> {\n        default_read_vectored(|b| self.read(b), bufs)\n    }\n\n    /// Determines if this `Read`er has an efficient `read_vectored`\n    /// implementation.\n    ///\n    /// If a `Read`er does not override the default `read_vectored`\n    /// implementation, code using it may want to avoid the method all together\n    /// and coalesce writes into a single buffer for higher performance.\n    ///\n    /// The default implementation returns `false`.\n    #[unstable(feature = \"can_vector\", issue = \"69941\")]\n    fn is_read_vectored(&self) -> bool {\n        false\n    }\n\n    /// Determines if this `Read`er can work with buffers of uninitialized\n    /// memory.\n    ///\n    /// The default implementation returns an initializer which will zero\n    /// buffers.\n    ///\n    /// If a `Read`er guarantees that it can work properly with uninitialized\n    /// memory, it should call [`Initializer::nop()`]. See the documentation for\n    /// [`Initializer`] for details.\n    ///\n    /// The behavior of this method must be independent of the state of the\n    /// `Read`er - the method only takes `&self` so that it can be used through\n    /// trait objects.\n    ///\n    /// # Safety\n    ///\n    /// This method is unsafe because a `Read`er could otherwise return a\n    /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n    /// block.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::zeroing()\n    }\n\n    /// Read all bytes until EOF in this source, placing them into `buf`.\n    ///\n    /// All bytes read from this source will be appended to the specified buffer\n    /// `buf`. This function will continuously call [`read()`] to append more data to\n    /// `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n    /// non-[`ErrorKind::Interrupted`] kind.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. Any bytes which have already been read will be appended to\n    /// `buf`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`read()`]: Read::read\n    /// [`Ok(0)`]: Ok\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = Vec::new();\n    ///\n    ///     // read the whole file\n    ///     f.read_to_end(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (See also the [`std::fs::read`] convenience function for reading from a\n    /// file.)\n    ///\n    /// [`std::fs::read`]: crate::fs::read\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n        read_to_end(self, buf)\n    }\n\n    /// Read all bytes until EOF in this source, appending them to `buf`.\n    ///\n    /// If successful, this function returns the number of bytes which were read\n    /// and appended to `buf`.\n    ///\n    /// # Errors\n    ///\n    /// If the data in this stream is *not* valid UTF-8 then an error is\n    /// returned and `buf` is unchanged.\n    ///\n    /// See [`read_to_end`] for other error semantics.\n    ///\n    /// [`read_to_end`]: Read::read_to_end\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = String::new();\n    ///\n    ///     f.read_to_string(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (See also the [`std::fs::read_to_string`] convenience function for\n    /// reading from a file.)\n    ///\n    /// [`std::fs::read_to_string`]: crate::fs::read_to_string\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n        // Note that we do *not* call `.read_to_end()` here. We are passing\n        // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n        // method to fill it up. An arbitrary implementation could overwrite the\n        // entire contents of the vector, not just append to it (which is what\n        // we are expecting).\n        //\n        // To prevent extraneously checking the UTF-8-ness of the entire buffer\n        // we pass it to our hardcoded `read_to_end` implementation which we\n        // know is guaranteed to only read data into the end of the buffer.\n        append_to_string(buf, |b| read_to_end(self, b))\n    }\n\n    /// Read the exact number of bytes required to fill `buf`.\n    ///\n    /// This function reads as many bytes as necessary to completely fill the\n    /// specified buffer `buf`.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that implementations\n    /// only write data to `buf` instead of reading its contents. The\n    /// documentation on [`read`] has a more detailed explanation on this\n    /// subject.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If this function encounters an \"end of file\" before completely filling\n    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n    /// The contents of `buf` are unspecified in this case.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. The contents of `buf` are unspecified in this case.\n    ///\n    /// If this function returns an error, it is unspecified how many bytes it\n    /// has read, but it will never read more than would be necessary to\n    /// completely fill the buffer.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`read`]: Read::read\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = [0; 10];\n    ///\n    ///     // read exactly 10 bytes\n    ///     f.read_exact(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    fn read_exact(&mut self, buf: &mut [u8]) -> Result<()> {\n        default_read_exact(self, buf)\n    }\n\n    /// Creates a \"by reference\" adaptor for this instance of `Read`.\n    ///\n    /// The returned adaptor also implements `Read` and will simply borrow this\n    /// current reader.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::Read;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = Vec::new();\n    ///     let mut other_buffer = Vec::new();\n    ///\n    ///     {\n    ///         let reference = f.by_ref();\n    ///\n    ///         // read at most 5 bytes\n    ///         reference.take(5).read_to_end(&mut buffer)?;\n    ///\n    ///     } // drop our &mut reference so we can use f again\n    ///\n    ///     // original file still usable, read the rest\n    ///     f.read_to_end(&mut other_buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self\n    where\n        Self: Sized,\n    {\n        self\n    }\n\n    /// Transforms this `Read` instance to an [`Iterator`] over its bytes.\n    ///\n    /// The returned type implements [`Iterator`] where the `Item` is\n    /// [`Result`]`<`[`u8`]`, `[`io::Error`]`>`.\n    /// The yielded item is [`Ok`] if a byte was successfully read and [`Err`]\n    /// otherwise. EOF is mapped to returning [`None`] from this iterator.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    /// [`Result`]: crate::result::Result\n    /// [`io::Error`]: self::Error\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///\n    ///     for byte in f.bytes() {\n    ///         println!(\"{}\", byte.unwrap());\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bytes(self) -> Bytes<Self>\n    where\n        Self: Sized,\n    {\n        Bytes { inner: self }\n    }\n\n    /// Creates an adaptor which will chain this stream with another.\n    ///\n    /// The returned `Read` instance will first read all bytes from this object\n    /// until EOF is encountered. Afterwards the output is equivalent to the\n    /// output of `next`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f1 = File::open(\"foo.txt\")?;\n    ///     let mut f2 = File::open(\"bar.txt\")?;\n    ///\n    ///     let mut handle = f1.chain(f2);\n    ///     let mut buffer = String::new();\n    ///\n    ///     // read the value into a String. We could use any Read method here,\n    ///     // this is just one example.\n    ///     handle.read_to_string(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn chain<R: Read>(self, next: R) -> Chain<Self, R>\n    where\n        Self: Sized,\n    {\n        Chain { first: self, second: next, done_first: false }\n    }\n\n    /// Creates an adaptor which will read at most `limit` bytes from it.\n    ///\n    /// This function returns a new instance of `Read` which will read at most\n    /// `limit` bytes, after which it will always return EOF ([`Ok(0)`]). Any\n    /// read errors will not count towards the number of bytes read and future\n    /// calls to [`read()`] may succeed.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    /// [`Ok(0)`]: Ok\n    /// [`read()`]: Read::read\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = [0; 5];\n    ///\n    ///     // read at most five bytes\n    ///     let mut handle = f.take(5);\n    ///\n    ///     handle.read(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn take(self, limit: u64) -> Take<Self>\n    where\n        Self: Sized,\n    {\n        Take { inner: self, limit }\n    }\n}\n\n/// Read all bytes from a [reader][Read] into a new [`String`].\n///\n/// This is a convenience function for [`Read::read_to_string`]. Using this\n/// function avoids having to create a variable first and provides more type\n/// safety since you can only get the buffer out if there were no errors. (If you\n/// use [`Read::read_to_string`] you have to remember to check whether the read\n/// succeeded because otherwise your buffer will be empty or only partially full.)\n///\n/// # Performance\n///\n/// The downside of this function's increased ease of use and type safety is\n/// that it gives you less control over performance. For example, you can't\n/// pre-allocate memory like you can using [`String::with_capacity`] and\n/// [`Read::read_to_string`]. Also, you can't re-use the buffer if an error\n/// occurs while reading.\n///\n/// In many cases, this function's performance will be adequate and the ease of use\n/// and type safety tradeoffs will be worth it. However, there are cases where you\n/// need more control over performance, and in those cases you should definitely use\n/// [`Read::read_to_string`] directly.\n///\n/// # Errors\n///\n/// This function forces you to handle errors because the output (the `String`)\n/// is wrapped in a [`Result`]. See [`Read::read_to_string`] for the errors\n/// that can occur. If any error occurs, you will get an [`Err`], so you\n/// don't have to worry about your buffer being empty or partially full.\n///\n/// # Examples\n///\n/// ```no_run\n/// #![feature(io_read_to_string)]\n///\n/// # use std::io;\n/// fn main() -> io::Result<()> {\n///     let stdin = io::read_to_string(&mut io::stdin())?;\n///     println!(\"Stdin was:\");\n///     println!(\"{}\", stdin);\n///     Ok(())\n/// }\n/// ```\n#[unstable(feature = \"io_read_to_string\", issue = \"80218\")]\npub fn read_to_string<R: Read>(reader: &mut R) -> Result<String> {\n    let mut buf = String::new();\n    reader.read_to_string(&mut buf)?;\n    Ok(buf)\n}\n\n/// A buffer type used with `Read::read_vectored`.\n///\n/// It is semantically a wrapper around an `&mut [u8]`, but is guaranteed to be\n/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n/// Windows.\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\n#[repr(transparent)]\npub struct IoSliceMut<'a>(sys::io::IoSliceMut<'a>);\n\n#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\nunsafe impl<'a> Send for IoSliceMut<'a> {}\n\n#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\nunsafe impl<'a> Sync for IoSliceMut<'a> {}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> fmt::Debug for IoSliceMut<'a> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.0.as_slice(), fmt)\n    }\n}\n\nimpl<'a> IoSliceMut<'a> {\n    /// Creates a new `IoSliceMut` wrapping a byte slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics on Windows if the slice is larger than 4GB.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    #[inline]\n    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n        IoSliceMut(sys::io::IoSliceMut::new(buf))\n    }\n\n    /// Advance the internal cursor of the slice.\n    ///\n    /// Also see [`IoSliceMut::advance_slices`] to advance the cursors of\n    /// multiple buffers.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(io_slice_advance)]\n    ///\n    /// use std::io::IoSliceMut;\n    /// use std::ops::Deref;\n    ///\n    /// let mut data = [1; 8];\n    /// let mut buf = IoSliceMut::new(&mut data);\n    ///\n    /// // Mark 3 bytes as read.\n    /// buf.advance(3);\n    /// assert_eq!(buf.deref(), [1; 5].as_ref());\n    /// ```\n    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        self.0.advance(n)\n    }\n\n    /// Advance the internal cursor of the slices.\n    ///\n    /// # Notes\n    ///\n    /// Elements in the slice may be modified if the cursor is not advanced to\n    /// the end of the slice. For example if we have a slice of buffers with 2\n    /// `IoSliceMut`s, both of length 8, and we advance the cursor by 10 bytes\n    /// the first `IoSliceMut` will be untouched however the second will be\n    /// modified to remove the first 2 bytes (10 - 8).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(io_slice_advance)]\n    ///\n    /// use std::io::IoSliceMut;\n    /// use std::ops::Deref;\n    ///\n    /// let mut buf1 = [1; 8];\n    /// let mut buf2 = [2; 16];\n    /// let mut buf3 = [3; 8];\n    /// let mut bufs = &mut [\n    ///     IoSliceMut::new(&mut buf1),\n    ///     IoSliceMut::new(&mut buf2),\n    ///     IoSliceMut::new(&mut buf3),\n    /// ][..];\n    ///\n    /// // Mark 10 bytes as read.\n    /// IoSliceMut::advance_slices(&mut bufs, 10);\n    /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n    /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n    /// ```\n    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n    #[inline]\n    pub fn advance_slices(bufs: &mut &mut [IoSliceMut<'a>], n: usize) {\n        // Number of buffers to remove.\n        let mut remove = 0;\n        // Total length of all the to be removed buffers.\n        let mut accumulated_len = 0;\n        for buf in bufs.iter() {\n            if accumulated_len + buf.len() > n {\n                break;\n            } else {\n                accumulated_len += buf.len();\n                remove += 1;\n            }\n        }\n\n        *bufs = &mut replace(bufs, &mut [])[remove..];\n        if !bufs.is_empty() {\n            bufs[0].advance(n - accumulated_len)\n        }\n    }\n}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> Deref for IoSliceMut<'a> {\n    type Target = [u8];\n\n    #[inline]\n    fn deref(&self) -> &[u8] {\n        self.0.as_slice()\n    }\n}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> DerefMut for IoSliceMut<'a> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut [u8] {\n        self.0.as_mut_slice()\n    }\n}\n\n/// A buffer type used with `Write::write_vectored`.\n///\n/// It is semantically a wrapper around an `&[u8]`, but is guaranteed to be\n/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n/// Windows.\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\n#[derive(Copy, Clone)]\n#[repr(transparent)]\npub struct IoSlice<'a>(sys::io::IoSlice<'a>);\n\n#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\nunsafe impl<'a> Send for IoSlice<'a> {}\n\n#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\nunsafe impl<'a> Sync for IoSlice<'a> {}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> fmt::Debug for IoSlice<'a> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.0.as_slice(), fmt)\n    }\n}\n\nimpl<'a> IoSlice<'a> {\n    /// Creates a new `IoSlice` wrapping a byte slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics on Windows if the slice is larger than 4GB.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    #[inline]\n    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n        IoSlice(sys::io::IoSlice::new(buf))\n    }\n\n    /// Advance the internal cursor of the slice.\n    ///\n    /// Also see [`IoSlice::advance_slices`] to advance the cursors of multiple\n    /// buffers.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(io_slice_advance)]\n    ///\n    /// use std::io::IoSlice;\n    /// use std::ops::Deref;\n    ///\n    /// let mut data = [1; 8];\n    /// let mut buf = IoSlice::new(&mut data);\n    ///\n    /// // Mark 3 bytes as read.\n    /// buf.advance(3);\n    /// assert_eq!(buf.deref(), [1; 5].as_ref());\n    /// ```\n    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        self.0.advance(n)\n    }\n\n    /// Advance the internal cursor of the slices.\n    ///\n    /// # Notes\n    ///\n    /// Elements in the slice may be modified if the cursor is not advanced to\n    /// the end of the slice. For example if we have a slice of buffers with 2\n    /// `IoSlice`s, both of length 8, and we advance the cursor by 10 bytes the\n    /// first `IoSlice` will be untouched however the second will be modified to\n    /// remove the first 2 bytes (10 - 8).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(io_slice_advance)]\n    ///\n    /// use std::io::IoSlice;\n    /// use std::ops::Deref;\n    ///\n    /// let buf1 = [1; 8];\n    /// let buf2 = [2; 16];\n    /// let buf3 = [3; 8];\n    /// let mut bufs = &mut [\n    ///     IoSlice::new(&buf1),\n    ///     IoSlice::new(&buf2),\n    ///     IoSlice::new(&buf3),\n    /// ][..];\n    ///\n    /// // Mark 10 bytes as written.\n    /// IoSlice::advance_slices(&mut bufs, 10);\n    /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n    /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n    #[inline]\n    pub fn advance_slices(bufs: &mut &mut [IoSlice<'a>], n: usize) {\n        // Number of buffers to remove.\n        let mut remove = 0;\n        // Total length of all the to be removed buffers.\n        let mut accumulated_len = 0;\n        for buf in bufs.iter() {\n            if accumulated_len + buf.len() > n {\n                break;\n            } else {\n                accumulated_len += buf.len();\n                remove += 1;\n            }\n        }\n\n        *bufs = &mut replace(bufs, &mut [])[remove..];\n        if !bufs.is_empty() {\n            bufs[0].advance(n - accumulated_len)\n        }\n    }\n}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> Deref for IoSlice<'a> {\n    type Target = [u8];\n\n    #[inline]\n    fn deref(&self) -> &[u8] {\n        self.0.as_slice()\n    }\n}\n\n/// A type used to conditionally initialize buffers passed to `Read` methods.\n#[unstable(feature = \"read_initializer\", issue = \"42788\")]\n#[derive(Debug)]\npub struct Initializer(bool);\n\nimpl Initializer {\n    /// Returns a new `Initializer` which will zero out buffers.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn zeroing() -> Initializer {\n        Initializer(true)\n    }\n\n    /// Returns a new `Initializer` which will not zero out buffers.\n    ///\n    /// # Safety\n    ///\n    /// This may only be called by `Read`ers which guarantee that they will not\n    /// read from buffers passed to `Read` methods, and that the return value of\n    /// the method accurately reflects the number of bytes that have been\n    /// written to the head of the buffer.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub unsafe fn nop() -> Initializer {\n        Initializer(false)\n    }\n\n    /// Indicates if a buffer should be initialized.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn should_initialize(&self) -> bool {\n        self.0\n    }\n\n    /// Initializes a buffer if necessary.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn initialize(&self, buf: &mut [u8]) {\n        if self.should_initialize() {\n            unsafe { ptr::write_bytes(buf.as_mut_ptr(), 0, buf.len()) }\n        }\n    }\n}\n\n/// A trait for objects which are byte-oriented sinks.\n///\n/// Implementors of the `Write` trait are sometimes called 'writers'.\n///\n/// Writers are defined by two required methods, [`write`] and [`flush`]:\n///\n/// * The [`write`] method will attempt to write some data into the object,\n///   returning how many bytes were successfully written.\n///\n/// * The [`flush`] method is useful for adaptors and explicit buffers\n///   themselves for ensuring that all buffered data has been pushed out to the\n///   'true sink'.\n///\n/// Writers are intended to be composable with one another. Many implementors\n/// throughout [`std::io`] take and provide types which implement the `Write`\n/// trait.\n///\n/// [`write`]: Write::write\n/// [`flush`]: Write::flush\n/// [`std::io`]: self\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// fn main() -> std::io::Result<()> {\n///     let data = b\"some bytes\";\n///\n///     let mut pos = 0;\n///     let mut buffer = File::create(\"foo.txt\")?;\n///\n///     while pos < data.len() {\n///         let bytes_written = buffer.write(&data[pos..])?;\n///         pos += bytes_written;\n///     }\n///     Ok(())\n/// }\n/// ```\n///\n/// The trait also provides convenience methods like [`write_all`], which calls\n/// `write` in a loop until its entire input has been written.\n///\n/// [`write_all`]: Write::write_all\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(notable_trait)]\npub trait Write {\n    /// Write a buffer into this writer, returning how many bytes were written.\n    ///\n    /// This function will attempt to write the entire contents of `buf`, but\n    /// the entire write may not succeed, or the write may also generate an\n    /// error. A call to `write` represents *at most one* attempt to write to\n    /// any wrapped object.\n    ///\n    /// Calls to `write` are not guaranteed to block waiting for data to be\n    /// written, and a write which would otherwise block can be indicated through\n    /// an [`Err`] variant.\n    ///\n    /// If the return value is [`Ok(n)`] then it must be guaranteed that\n    /// `n <= buf.len()`. A return value of `0` typically means that the\n    /// underlying object is no longer able to accept bytes and will likely not\n    /// be able to in the future as well, or that the buffer provided is empty.\n    ///\n    /// # Errors\n    ///\n    /// Each call to `write` may generate an I/O error indicating that the\n    /// operation could not be completed. If an error is returned then no bytes\n    /// in the buffer were written to this writer.\n    ///\n    /// It is **not** considered an error if the entire buffer could not be\n    /// written to this writer.\n    ///\n    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n    /// write operation should be retried if there is nothing else to do.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     // Writes some prefix of the byte string, not necessarily all of it.\n    ///     buffer.write(b\"some bytes\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// [`Ok(n)`]: Ok\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n\n    /// Like [`write`], except that it writes from a slice of buffers.\n    ///\n    /// Data is copied from each buffer in order, with the final buffer\n    /// read from possibly being only partially consumed. This method must\n    /// behave as a call to [`write`] with the buffers concatenated would.\n    ///\n    /// The default implementation calls [`write`] with either the first nonempty\n    /// buffer provided, or an empty one if none exists.\n    ///\n    /// [`write`]: Write::write\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> Result<usize> {\n        default_write_vectored(|b| self.write(b), bufs)\n    }\n\n    /// Determines if this `Write`r has an efficient [`write_vectored`]\n    /// implementation.\n    ///\n    /// If a `Write`r does not override the default [`write_vectored`]\n    /// implementation, code using it may want to avoid the method all together\n    /// and coalesce writes into a single buffer for higher performance.\n    ///\n    /// The default implementation returns `false`.\n    ///\n    /// [`write_vectored`]: Write::write_vectored\n    #[unstable(feature = \"can_vector\", issue = \"69941\")]\n    fn is_write_vectored(&self) -> bool {\n        false\n    }\n\n    /// Flush this output stream, ensuring that all intermediately buffered\n    /// contents reach their destination.\n    ///\n    /// # Errors\n    ///\n    /// It is considered an error if not all bytes could be written due to\n    /// I/O errors or EOF being reached.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::io::BufWriter;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = BufWriter::new(File::create(\"foo.txt\")?);\n    ///\n    ///     buffer.write_all(b\"some bytes\")?;\n    ///     buffer.flush()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn flush(&mut self) -> Result<()>;\n\n    /// Attempts to write an entire buffer into this writer.\n    ///\n    /// This method will continuously call [`write`] until there is no more data\n    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n    /// returned. This method will not return until the entire buffer has been\n    /// successfully written or such an error occurs. The first error that is\n    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n    /// returned.\n    ///\n    /// If the buffer contains no data, this will never call [`write`].\n    ///\n    /// # Errors\n    ///\n    /// This function will return the first error of\n    /// non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n    ///\n    /// [`write`]: Write::write\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     buffer.write_all(b\"some bytes\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n        while !buf.is_empty() {\n            match self.write(buf) {\n                Ok(0) => {\n                    return Err(Error::new_const(\n                        ErrorKind::WriteZero,\n                        &\"failed to write whole buffer\",\n                    ));\n                }\n                Ok(n) => buf = &buf[n..],\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Attempts to write multiple buffers into this writer.\n    ///\n    /// This method will continuously call [`write_vectored`] until there is no\n    /// more data to be written or an error of non-[`ErrorKind::Interrupted`]\n    /// kind is returned. This method will not return until all buffers have\n    /// been successfully written or such an error occurs. The first error that\n    /// is not of [`ErrorKind::Interrupted`] kind generated from this method\n    /// will be returned.\n    ///\n    /// If the buffer contains no data, this will never call [`write_vectored`].\n    ///\n    /// # Notes\n    ///\n    /// Unlike [`write_vectored`], this takes a *mutable* reference to\n    /// a slice of [`IoSlice`]s, not an immutable one. That's because we need to\n    /// modify the slice to keep track of the bytes already written.\n    ///\n    /// Once this function returns, the contents of `bufs` are unspecified, as\n    /// this depends on how many calls to [`write_vectored`] were necessary. It is\n    /// best to understand this function as taking ownership of `bufs` and to\n    /// not use `bufs` afterwards. The underlying buffers, to which the\n    /// [`IoSlice`]s point (but not the [`IoSlice`]s themselves), are unchanged and\n    /// can be reused.\n    ///\n    /// [`write_vectored`]: Write::write_vectored\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(write_all_vectored)]\n    /// # fn main() -> std::io::Result<()> {\n    ///\n    /// use std::io::{Write, IoSlice};\n    ///\n    /// let mut writer = Vec::new();\n    /// let bufs = &mut [\n    ///     IoSlice::new(&[1]),\n    ///     IoSlice::new(&[2, 3]),\n    ///     IoSlice::new(&[4, 5, 6]),\n    /// ];\n    ///\n    /// writer.write_all_vectored(bufs)?;\n    /// // Note: the contents of `bufs` is now undefined, see the Notes section.\n    ///\n    /// assert_eq!(writer, &[1, 2, 3, 4, 5, 6]);\n    /// # Ok(()) }\n    /// ```\n    #[unstable(feature = \"write_all_vectored\", issue = \"70436\")]\n    fn write_all_vectored(&mut self, mut bufs: &mut [IoSlice<'_>]) -> Result<()> {\n        // Guarantee that bufs is empty if it contains no data,\n        // to avoid calling write_vectored if there is no data to be written.\n        IoSlice::advance_slices(&mut bufs, 0);\n        while !bufs.is_empty() {\n            match self.write_vectored(bufs) {\n                Ok(0) => {\n                    return Err(Error::new_const(\n                        ErrorKind::WriteZero,\n                        &\"failed to write whole buffer\",\n                    ));\n                }\n                Ok(n) => IoSlice::advance_slices(&mut bufs, n),\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes a formatted string into this writer, returning any error\n    /// encountered.\n    ///\n    /// This method is primarily used to interface with the\n    /// [`format_args!()`] macro, but it is rare that this should\n    /// explicitly be called. The [`write!()`] macro should be favored to\n    /// invoke this method instead.\n    ///\n    /// This function internally uses the [`write_all`] method on\n    /// this trait and hence will continuously write data so long as no errors\n    /// are received. This also means that partial writes are not indicated in\n    /// this signature.\n    ///\n    /// [`write_all`]: Write::write_all\n    ///\n    /// # Errors\n    ///\n    /// This function will return any I/O error reported while formatting.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     // this call\n    ///     write!(buffer, \"{:.*}\", 2, 1.234567)?;\n    ///     // turns into this:\n    ///     buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> Result<()> {\n        // Create a shim which translates a Write to a fmt::Write and saves\n        // off I/O errors. instead of discarding them\n        struct Adaptor<'a, T: ?Sized + 'a> {\n            inner: &'a mut T,\n            error: Result<()>,\n        }\n\n        impl<T: Write + ?Sized> fmt::Write for Adaptor<'_, T> {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                match self.inner.write_all(s.as_bytes()) {\n                    Ok(()) => Ok(()),\n                    Err(e) => {\n                        self.error = Err(e);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }\n\n        let mut output = Adaptor { inner: self, error: Ok(()) };\n        match fmt::write(&mut output, fmt) {\n            Ok(()) => Ok(()),\n            Err(..) => {\n                // check if the error came from the underlying `Write` or not\n                if output.error.is_err() {\n                    output.error\n                } else {\n                    Err(Error::new_const(ErrorKind::Other, &\"formatter error\"))\n                }\n            }\n        }\n    }\n\n    /// Creates a \"by reference\" adaptor for this instance of `Write`.\n    ///\n    /// The returned adaptor also implements `Write` and will simply borrow this\n    /// current writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::Write;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     let reference = buffer.by_ref();\n    ///\n    ///     // we can use reference just like our original buffer\n    ///     reference.write_all(b\"some bytes\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self\n    where\n        Self: Sized,\n    {\n        self\n    }\n}\n\n/// The `Seek` trait provides a cursor which can be moved within a stream of\n/// bytes.\n///\n/// The stream typically has a fixed size, allowing seeking relative to either\n/// end or the current offset.\n///\n/// # Examples\n///\n/// [`File`]s implement `Seek`:\n///\n/// [`File`]: crate::fs::File\n///\n/// ```no_run\n/// use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n/// use std::io::SeekFrom;\n///\n/// fn main() -> io::Result<()> {\n///     let mut f = File::open(\"foo.txt\")?;\n///\n///     // move the cursor 42 bytes from the start of the file\n///     f.seek(SeekFrom::Start(42))?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Seek {\n    /// Seek to an offset, in bytes, in a stream.\n    ///\n    /// A seek beyond the end of a stream is allowed, but behavior is defined\n    /// by the implementation.\n    ///\n    /// If the seek operation completed successfully,\n    /// this method returns the new position from the start of the stream.\n    /// That position can be used later with [`SeekFrom::Start`].\n    ///\n    /// # Errors\n    ///\n    /// Seeking can fail, for example because it might involve flushing a buffer.\n    ///\n    /// Seeking to a negative offset is considered an error.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n\n    /// Rewind to the beginning of a stream.\n    ///\n    /// This is a convenience method, equivalent to `seek(SeekFrom::Start(0))`.\n    ///\n    /// # Errors\n    ///\n    /// Rewinding can fail, for example because it might involve flushing a buffer.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// #![feature(seek_rewind)]\n    /// use std::io::{Read, Seek, Write};\n    /// use std::fs::OpenOptions;\n    ///\n    /// let mut f = OpenOptions::new()\n    ///     .write(true)\n    ///     .read(true)\n    ///     .create(true)\n    ///     .open(\"foo.txt\").unwrap();\n    ///\n    /// let hello = \"Hello!\\n\";\n    /// write!(f, \"{}\", hello).unwrap();\n    /// f.rewind().unwrap();\n    ///\n    /// let mut buf = String::new();\n    /// f.read_to_string(&mut buf).unwrap();\n    /// assert_eq!(&buf, hello);\n    /// ```\n    #[unstable(feature = \"seek_rewind\", issue = \"85149\")]\n    fn rewind(&mut self) -> Result<()> {\n        self.seek(SeekFrom::Start(0))?;\n        Ok(())\n    }\n\n    /// Returns the length of this stream (in bytes).\n    ///\n    /// This method is implemented using up to three seek operations. If this\n    /// method returns successfully, the seek position is unchanged (i.e. the\n    /// position before calling this method is the same as afterwards).\n    /// However, if this method returns an error, the seek position is\n    /// unspecified.\n    ///\n    /// If you need to obtain the length of *many* streams and you don't care\n    /// about the seek position afterwards, you can reduce the number of seek\n    /// operations by simply calling `seek(SeekFrom::End(0))` and using its\n    /// return value (it is also the stream length).\n    ///\n    /// Note that length of a stream can change over time (for example, when\n    /// data is appended to a file). So calling this method multiple times does\n    /// not necessarily return the same length each time.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// #![feature(seek_stream_len)]\n    /// use std::{\n    ///     io::{self, Seek},\n    ///     fs::File,\n    /// };\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///\n    ///     let len = f.stream_len()?;\n    ///     println!(\"The file is currently {} bytes long\", len);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[unstable(feature = \"seek_stream_len\", issue = \"59359\")]\n    fn stream_len(&mut self) -> Result<u64> {\n        let old_pos = self.stream_position()?;\n        let len = self.seek(SeekFrom::End(0))?;\n\n        // Avoid seeking a third time when we were already at the end of the\n        // stream. The branch is usually way cheaper than a seek operation.\n        if old_pos != len {\n            self.seek(SeekFrom::Start(old_pos))?;\n        }\n\n        Ok(len)\n    }\n\n    /// Returns the current seek position from the start of the stream.\n    ///\n    /// This is equivalent to `self.seek(SeekFrom::Current(0))`.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use std::{\n    ///     io::{self, BufRead, BufReader, Seek},\n    ///     fs::File,\n    /// };\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n    ///\n    ///     let before = f.stream_position()?;\n    ///     f.read_line(&mut String::new())?;\n    ///     let after = f.stream_position()?;\n    ///\n    ///     println!(\"The first line was {} bytes long\", after - before);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"seek_convenience\", since = \"1.51.0\")]\n    fn stream_position(&mut self) -> Result<u64> {\n        self.seek(SeekFrom::Current(0))\n    }\n}\n\n/// Enumeration of possible methods to seek within an I/O object.\n///\n/// It is used by the [`Seek`] trait.\n#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum SeekFrom {\n    /// Sets the offset to the provided number of bytes.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Start(#[stable(feature = \"rust1\", since = \"1.0.0\")] u64),\n\n    /// Sets the offset to the size of this object plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    End(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n\n    /// Sets the offset to the current position plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Current(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n}\n\nfn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> Result<usize> {\n    let mut read = 0;\n    loop {\n        let (done, used) = {\n            let available = match r.fill_buf() {\n                Ok(n) => n,\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                Err(e) => return Err(e),\n            };\n            match memchr::memchr(delim, available) {\n                Some(i) => {\n                    buf.extend_from_slice(&available[..=i]);\n                    (true, i + 1)\n                }\n                None => {\n                    buf.extend_from_slice(available);\n                    (false, available.len())\n                }\n            }\n        };\n        r.consume(used);\n        read += used;\n        if done || used == 0 {\n            return Ok(read);\n        }\n    }\n}\n\n/// A `BufRead` is a type of `Read`er which has an internal buffer, allowing it\n/// to perform extra ways of reading.\n///\n/// For example, reading line-by-line is inefficient without using a buffer, so\n/// if you want to read by line, you'll need `BufRead`, which includes a\n/// [`read_line`] method as well as a [`lines`] iterator.\n///\n/// # Examples\n///\n/// A locked standard input implements `BufRead`:\n///\n/// ```no_run\n/// use std::io;\n/// use std::io::prelude::*;\n///\n/// let stdin = io::stdin();\n/// for line in stdin.lock().lines() {\n///     println!(\"{}\", line.unwrap());\n/// }\n/// ```\n///\n/// If you have something that implements [`Read`], you can use the [`BufReader`\n/// type][`BufReader`] to turn it into a `BufRead`.\n///\n/// For example, [`File`] implements [`Read`], but not `BufRead`.\n/// [`BufReader`] to the rescue!\n///\n/// [`File`]: crate::fs::File\n/// [`read_line`]: BufRead::read_line\n/// [`lines`]: BufRead::lines\n///\n/// ```no_run\n/// use std::io::{self, BufReader};\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// fn main() -> io::Result<()> {\n///     let f = File::open(\"foo.txt\")?;\n///     let f = BufReader::new(f);\n///\n///     for line in f.lines() {\n///         println!(\"{}\", line.unwrap());\n///     }\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait BufRead: Read {\n    /// Returns the contents of the internal buffer, filling it with more data\n    /// from the inner reader if it is empty.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`consume`] method to function properly. When calling this\n    /// method, none of the contents will be \"read\" in the sense that later\n    /// calling `read` may return the same contents. As such, [`consume`] must\n    /// be called with the number of bytes that are consumed from this buffer to\n    /// ensure that the bytes are never returned twice.\n    ///\n    /// [`consume`]: BufRead::consume\n    ///\n    /// An empty buffer returned indicates that the stream has reached EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an I/O error if the underlying reader was\n    /// read, but returned an error.\n    ///\n    /// # Examples\n    ///\n    /// A locked standard input implements `BufRead`:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    ///\n    /// let stdin = io::stdin();\n    /// let mut stdin = stdin.lock();\n    ///\n    /// let buffer = stdin.fill_buf().unwrap();\n    ///\n    /// // work with buffer\n    /// println!(\"{:?}\", buffer);\n    ///\n    /// // ensure the bytes we worked with aren't returned again later\n    /// let length = buffer.len();\n    /// stdin.consume(length);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fill_buf(&mut self) -> Result<&[u8]>;\n\n    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n    /// so they should no longer be returned in calls to `read`.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`fill_buf`] method to function properly. This function does\n    /// not perform any I/O, it simply informs this object that some amount of\n    /// its buffer, returned from [`fill_buf`], has been consumed and should\n    /// no longer be returned. As such, this function may do odd things if\n    /// [`fill_buf`] isn't called before calling it.\n    ///\n    /// The `amt` must be `<=` the number of bytes in the buffer returned by\n    /// [`fill_buf`].\n    ///\n    /// # Examples\n    ///\n    /// Since `consume()` is meant to be used with [`fill_buf`],\n    /// that method's example includes an example of `consume()`.\n    ///\n    /// [`fill_buf`]: BufRead::fill_buf\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn consume(&mut self, amt: usize);\n\n    /// Check if the underlying `Read` has any data left to be read.\n    ///\n    /// This function may fill the buffer to check for data,\n    /// so this functions returns `Result<bool>`, not `bool`.\n    ///\n    /// Default implementation calls `fill_buf` and checks that\n    /// returned slice is empty (which means that there is no data left,\n    /// since EOF is reached).\n    ///\n    /// Examples\n    ///\n    /// ```\n    /// #![feature(buf_read_has_data_left)]\n    /// use std::io;\n    /// use std::io::prelude::*;\n    ///\n    /// let stdin = io::stdin();\n    /// let mut stdin = stdin.lock();\n    ///\n    /// while stdin.has_data_left().unwrap() {\n    ///     let mut line = String::new();\n    ///     stdin.read_line(&mut line).unwrap();\n    ///     // work with line\n    ///     println!(\"{:?}\", line);\n    /// }\n    /// ```\n    #[unstable(feature = \"buf_read_has_data_left\", reason = \"recently added\", issue = \"86423\")]\n    fn has_data_left(&mut self) -> Result<bool> {\n        self.fill_buf().map(|b| !b.is_empty())\n    }\n\n    /// Read all bytes into `buf` until the delimiter `byte` or EOF is reached.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// delimiter or EOF is found. Once found, all bytes up to, and including,\n    /// the delimiter (if found) will be appended to `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// This function is blocking and should be used carefully: it is possible for\n    /// an attacker to continuously send bytes without ever sending the delimiter\n    /// or EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function will ignore all instances of [`ErrorKind::Interrupted`] and\n    /// will otherwise return any errors returned by [`fill_buf`].\n    ///\n    /// If an I/O error is encountered then all bytes read so far will be\n    /// present in `buf` and its length will have been adjusted appropriately.\n    ///\n    /// [`fill_buf`]: BufRead::fill_buf\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the bytes in a byte slice\n    /// in hyphen delimited segments:\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"lorem-ipsum\");\n    /// let mut buf = vec![];\n    ///\n    /// // cursor is at 'l'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 6);\n    /// assert_eq!(buf, b\"lorem-\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'i'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 5);\n    /// assert_eq!(buf, b\"ipsum\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, b\"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n        read_until(self, byte, buf)\n    }\n\n    /// Read all bytes until a newline (the `0xA` byte) is reached, and append\n    /// them to the provided buffer.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// newline delimiter (the `0xA` byte) or EOF is found. Once found, all bytes\n    /// up to, and including, the delimiter (if found) will be appended to\n    /// `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// If this function returns [`Ok(0)`], the stream has reached EOF.\n    ///\n    /// This function is blocking and should be used carefully: it is possible for\n    /// an attacker to continuously send bytes without ever sending a newline\n    /// or EOF.\n    ///\n    /// [`Ok(0)`]: Ok\n    ///\n    /// # Errors\n    ///\n    /// This function has the same error semantics as [`read_until`] and will\n    /// also return an error if the read bytes are not valid UTF-8. If an I/O\n    /// error is encountered then `buf` may contain some bytes already read in\n    /// the event that all data read so far was valid UTF-8.\n    ///\n    /// [`read_until`]: BufRead::read_until\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the lines in a byte slice:\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"foo\\nbar\");\n    /// let mut buf = String::new();\n    ///\n    /// // cursor is at 'f'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 4);\n    /// assert_eq!(buf, \"foo\\n\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'b'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 3);\n    /// assert_eq!(buf, \"bar\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, \"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n        // Note that we are not calling the `.read_until` method here, but\n        // rather our hardcoded implementation. For more details as to why, see\n        // the comments in `read_to_end`.\n        append_to_string(buf, |b| read_until(self, b'\\n', b))\n    }\n\n    /// Returns an iterator over the contents of this reader split on the byte\n    /// `byte`.\n    ///\n    /// The iterator returned from this function will return instances of\n    /// [`io::Result`]`<`[`Vec<u8>`]`>`. Each vector returned will *not* have\n    /// the delimiter byte at the end.\n    ///\n    /// This function will yield errors whenever [`read_until`] would have\n    /// also yielded an error.\n    ///\n    /// [`io::Result`]: self::Result\n    /// [`read_until`]: BufRead::read_until\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all hyphen delimited\n    /// segments in a byte slice\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem-ipsum-dolor\");\n    ///\n    /// let mut split_iter = cursor.split(b'-').map(|l| l.unwrap());\n    /// assert_eq!(split_iter.next(), Some(b\"lorem\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"ipsum\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"dolor\".to_vec()));\n    /// assert_eq!(split_iter.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn split(self, byte: u8) -> Split<Self>\n    where\n        Self: Sized,\n    {\n        Split { buf: self, delim: byte }\n    }\n\n    /// Returns an iterator over the lines of this reader.\n    ///\n    /// The iterator returned from this function will yield instances of\n    /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n    /// byte (the `0xA` byte) or `CRLF` (`0xD`, `0xA` bytes) at the end.\n    ///\n    /// [`io::Result`]: self::Result\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all the lines in a byte\n    /// slice.\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n    ///\n    /// let mut lines_iter = cursor.lines().map(|l| l.unwrap());\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"lorem\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"ipsum\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"dolor\")));\n    /// assert_eq!(lines_iter.next(), None);\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// Each line of the iterator has the same error semantics as [`BufRead::read_line`].\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn lines(self) -> Lines<Self>\n    where\n        Self: Sized,\n    {\n        Lines { buf: self }\n    }\n}\n\n/// Adaptor to chain together two readers.\n///\n/// This struct is generally created by calling [`chain`] on a reader.\n/// Please see the documentation of [`chain`] for more details.\n///\n/// [`chain`]: Read::chain\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Chain<T, U> {\n    first: T,\n    second: U,\n    done_first: bool,\n}\n\nimpl<T, U> Chain<T, U> {\n    /// Consumes the `Chain`, returning the wrapped readers.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut foo_file = File::open(\"foo.txt\")?;\n    ///     let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    ///     let chain = foo_file.chain(bar_file);\n    ///     let (foo_file, bar_file) = chain.into_inner();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn into_inner(self) -> (T, U) {\n        (self.first, self.second)\n    }\n\n    /// Gets references to the underlying readers in this `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut foo_file = File::open(\"foo.txt\")?;\n    ///     let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    ///     let chain = foo_file.chain(bar_file);\n    ///     let (foo_file, bar_file) = chain.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> (&T, &U) {\n        (&self.first, &self.second)\n    }\n\n    /// Gets mutable references to the underlying readers in this `Chain`.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying readers as doing so may corrupt the internal state of this\n    /// `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut foo_file = File::open(\"foo.txt\")?;\n    ///     let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    ///     let mut chain = foo_file.chain(bar_file);\n    ///     let (foo_file, bar_file) = chain.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> (&mut T, &mut U) {\n        (&mut self.first, &mut self.second)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read, U: Read> Read for Chain<T, U> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        if !self.done_first {\n            match self.first.read(buf)? {\n                0 if !buf.is_empty() => self.done_first = true,\n                n => return Ok(n),\n            }\n        }\n        self.second.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> Result<usize> {\n        if !self.done_first {\n            match self.first.read_vectored(bufs)? {\n                0 if bufs.iter().any(|b| !b.is_empty()) => self.done_first = true,\n                n => return Ok(n),\n            }\n        }\n        self.second.read_vectored(bufs)\n    }\n\n    unsafe fn initializer(&self) -> Initializer {\n        let initializer = self.first.initializer();\n        if initializer.should_initialize() { initializer } else { self.second.initializer() }\n    }\n}\n\n#[stable(feature = \"chain_bufread\", since = \"1.9.0\")]\nimpl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n        if !self.done_first {\n            match self.first.fill_buf()? {\n                buf if buf.is_empty() => {\n                    self.done_first = true;\n                }\n                buf => return Ok(buf),\n            }\n        }\n        self.second.fill_buf()\n    }\n\n    fn consume(&mut self, amt: usize) {\n        if !self.done_first { self.first.consume(amt) } else { self.second.consume(amt) }\n    }\n}\n\nimpl<T, U> SizeHint for Chain<T, U> {\n    #[inline]\n    fn lower_bound(&self) -> usize {\n        SizeHint::lower_bound(&self.first) + SizeHint::lower_bound(&self.second)\n    }\n\n    #[inline]\n    fn upper_bound(&self) -> Option<usize> {\n        match (SizeHint::upper_bound(&self.first), SizeHint::upper_bound(&self.second)) {\n            (Some(first), Some(second)) => first.checked_add(second),\n            _ => None,\n        }\n    }\n}\n\n/// Reader adaptor which limits the bytes read from an underlying reader.\n///\n/// This struct is generally created by calling [`take`] on a reader.\n/// Please see the documentation of [`take`] for more details.\n///\n/// [`take`]: Read::take\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Take<T> {\n    inner: T,\n    limit: u64,\n}\n\nimpl<T> Take<T> {\n    /// Returns the number of bytes that can be read before this instance will\n    /// return EOF.\n    ///\n    /// # Note\n    ///\n    /// This instance may reach `EOF` after reading fewer bytes than indicated by\n    /// this method if the underlying [`Read`] instance reaches EOF.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let f = File::open(\"foo.txt\")?;\n    ///\n    ///     // read at most five bytes\n    ///     let handle = f.take(5);\n    ///\n    ///     println!(\"limit: {}\", handle.limit());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn limit(&self) -> u64 {\n        self.limit\n    }\n\n    /// Sets the number of bytes that can be read before this instance will\n    /// return EOF. This is the same as constructing a new `Take` instance, so\n    /// the amount of bytes read and the previous limit value don't matter when\n    /// calling this method.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let f = File::open(\"foo.txt\")?;\n    ///\n    ///     // read at most five bytes\n    ///     let mut handle = f.take(5);\n    ///     handle.set_limit(10);\n    ///\n    ///     assert_eq!(handle.limit(), 10);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"take_set_limit\", since = \"1.27.0\")]\n    pub fn set_limit(&mut self, limit: u64) {\n        self.limit = limit;\n    }\n\n    /// Consumes the `Take`, returning the wrapped reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///\n    ///     let mut buffer = [0; 5];\n    ///     let mut handle = file.take(5);\n    ///     handle.read(&mut buffer)?;\n    ///\n    ///     let file = handle.into_inner();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"io_take_into_inner\", since = \"1.15.0\")]\n    pub fn into_inner(self) -> T {\n        self.inner\n    }\n\n    /// Gets a reference to the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///\n    ///     let mut buffer = [0; 5];\n    ///     let mut handle = file.take(5);\n    ///     handle.read(&mut buffer)?;\n    ///\n    ///     let file = handle.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> &T {\n        &self.inner\n    }\n\n    /// Gets a mutable reference to the underlying reader.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying reader as doing so may corrupt the internal limit of this\n    /// `Take`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///\n    ///     let mut buffer = [0; 5];\n    ///     let mut handle = file.take(5);\n    ///     handle.read(&mut buffer)?;\n    ///\n    ///     let file = handle.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.inner\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read> Read for Take<T> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        // Don't call into inner reader at all at EOF because it may still block\n        if self.limit == 0 {\n            return Ok(0);\n        }\n\n        let max = cmp::min(buf.len() as u64, self.limit) as usize;\n        let n = self.inner.read(&mut buf[..max])?;\n        self.limit -= n as u64;\n        Ok(n)\n    }\n\n    unsafe fn initializer(&self) -> Initializer {\n        self.inner.initializer()\n    }\n\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n        // Pass in a reservation_size closure that respects the current value\n        // of limit for each read. If we hit the read limit, this prevents the\n        // final zero-byte read from allocating again.\n        read_to_end_with_reservation(self, buf, |self_| cmp::min(self_.limit, 32) as usize)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: BufRead> BufRead for Take<T> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n        // Don't call into inner reader at all at EOF because it may still block\n        if self.limit == 0 {\n            return Ok(&[]);\n        }\n\n        let buf = self.inner.fill_buf()?;\n        let cap = cmp::min(buf.len() as u64, self.limit) as usize;\n        Ok(&buf[..cap])\n    }\n\n    fn consume(&mut self, amt: usize) {\n        // Don't let callers reset the limit by passing an overlarge value\n        let amt = cmp::min(amt as u64, self.limit) as usize;\n        self.limit -= amt as u64;\n        self.inner.consume(amt);\n    }\n}\n\nimpl<T> SizeHint for Take<T> {\n    #[inline]\n    fn lower_bound(&self) -> usize {\n        cmp::min(SizeHint::lower_bound(&self.inner) as u64, self.limit) as usize\n    }\n\n    #[inline]\n    fn upper_bound(&self) -> Option<usize> {\n        match SizeHint::upper_bound(&self.inner) {\n            Some(upper_bound) => Some(cmp::min(upper_bound as u64, self.limit) as usize),\n            None => self.limit.try_into().ok(),\n        }\n    }\n}\n\n/// An iterator over `u8` values of a reader.\n///\n/// This struct is generally created by calling [`bytes`] on a reader.\n/// Please see the documentation of [`bytes`] for more details.\n///\n/// [`bytes`]: Read::bytes\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Bytes<R> {\n    inner: R,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> Iterator for Bytes<R> {\n    type Item = Result<u8>;\n\n    fn next(&mut self) -> Option<Result<u8>> {\n        let mut byte = 0;\n        loop {\n            return match self.inner.read(slice::from_mut(&mut byte)) {\n                Ok(0) => None,\n                Ok(..) => Some(Ok(byte)),\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                Err(e) => Some(Err(e)),\n            };\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        SizeHint::size_hint(&self.inner)\n    }\n}\n\ntrait SizeHint {\n    fn lower_bound(&self) -> usize;\n\n    fn upper_bound(&self) -> Option<usize>;\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.lower_bound(), self.upper_bound())\n    }\n}\n\nimpl<T> SizeHint for T {\n    #[inline]\n    default fn lower_bound(&self) -> usize {\n        0\n    }\n\n    #[inline]\n    default fn upper_bound(&self) -> Option<usize> {\n        None\n    }\n}\n\nimpl<T> SizeHint for &mut T {\n    #[inline]\n    fn lower_bound(&self) -> usize {\n        SizeHint::lower_bound(*self)\n    }\n\n    #[inline]\n    fn upper_bound(&self) -> Option<usize> {\n        SizeHint::upper_bound(*self)\n    }\n}\n\nimpl<T> SizeHint for Box<T> {\n    #[inline]\n    fn lower_bound(&self) -> usize {\n        SizeHint::lower_bound(&**self)\n    }\n\n    #[inline]\n    fn upper_bound(&self) -> Option<usize> {\n        SizeHint::upper_bound(&**self)\n    }\n}\n\nimpl SizeHint for &[u8] {\n    #[inline]\n    fn lower_bound(&self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn upper_bound(&self) -> Option<usize> {\n        Some(self.len())\n    }\n}\n\n/// An iterator over the contents of an instance of `BufRead` split on a\n/// particular byte.\n///\n/// This struct is generally created by calling [`split`] on a `BufRead`.\n/// Please see the documentation of [`split`] for more details.\n///\n/// [`split`]: BufRead::split\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Split<B> {\n    buf: B,\n    delim: u8,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Split<B> {\n    type Item = Result<Vec<u8>>;\n\n    fn next(&mut self) -> Option<Result<Vec<u8>>> {\n        let mut buf = Vec::new();\n        match self.buf.read_until(self.delim, &mut buf) {\n            Ok(0) => None,\n            Ok(_n) => {\n                if buf[buf.len() - 1] == self.delim {\n                    buf.pop();\n                }\n                Some(Ok(buf))\n            }\n            Err(e) => Some(Err(e)),\n        }\n    }\n}\n\n/// An iterator over the lines of an instance of `BufRead`.\n///\n/// This struct is generally created by calling [`lines`] on a `BufRead`.\n/// Please see the documentation of [`lines`] for more details.\n///\n/// [`lines`]: BufRead::lines\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Lines<B> {\n    buf: B,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Lines<B> {\n    type Item = Result<String>;\n\n    fn next(&mut self) -> Option<Result<String>> {\n        let mut buf = String::new();\n        match self.buf.read_line(&mut buf) {\n            Ok(0) => None,\n            Ok(_n) => {\n                if buf.ends_with('\\n') {\n                    buf.pop();\n                    if buf.ends_with('\\r') {\n                        buf.pop();\n                    }\n                }\n                Some(Ok(buf))\n            }\n            Err(e) => Some(Err(e)),\n        }\n    }\n}\n"],["2520","use crate::io::prelude::*;\n\n#[bench]\nfn bench_read_slice(b: &mut test::Bencher) {\n    let buf = [5; 1024];\n    let mut dst = [0; 128];\n\n    b.iter(|| {\n        let mut rd = &buf[..];\n        for _ in 0..8 {\n            let _ = rd.read(&mut dst);\n            test::black_box(&dst);\n        }\n    })\n}\n\n#[bench]\nfn bench_write_slice(b: &mut test::Bencher) {\n    let mut buf = [0; 1024];\n    let src = [5; 128];\n\n    b.iter(|| {\n        let mut wr = &mut buf[..];\n        for _ in 0..8 {\n            let _ = wr.write_all(&src);\n            test::black_box(&wr);\n        }\n    })\n}\n\n#[bench]\nfn bench_read_vec(b: &mut test::Bencher) {\n    let buf = vec![5; 1024];\n    let mut dst = [0; 128];\n\n    b.iter(|| {\n        let mut rd = &buf[..];\n        for _ in 0..8 {\n            let _ = rd.read(&mut dst);\n            test::black_box(&dst);\n        }\n    })\n}\n\n#[bench]\nfn bench_write_vec(b: &mut test::Bencher) {\n    let mut buf = Vec::with_capacity(1024);\n    let src = [5; 128];\n\n    b.iter(|| {\n        let mut wr = &mut buf[..];\n        for _ in 0..8 {\n            let _ = wr.write_all(&src);\n            test::black_box(&wr);\n        }\n    })\n}\n"],["2521","#[cfg(test)]\nmod tests;\n\nuse crate::convert::From;\nuse crate::error;\nuse crate::fmt;\nuse crate::result;\nuse crate::sys;\n\n/// A specialized [`Result`] type for I/O operations.\n///\n/// This type is broadly used across [`std::io`] for any operation which may\n/// produce an error.\n///\n/// This typedef is generally used to avoid writing out [`io::Error`] directly and\n/// is otherwise a direct mapping to [`Result`].\n///\n/// While usual Rust style is to import types directly, aliases of [`Result`]\n/// often are not, to make it easier to distinguish between them. [`Result`] is\n/// generally assumed to be [`std::result::Result`][`Result`], and so users of this alias\n/// will generally use `io::Result` instead of shadowing the [prelude]'s import\n/// of [`std::result::Result`][`Result`].\n///\n/// [`std::io`]: crate::io\n/// [`io::Error`]: Error\n/// [`Result`]: crate::result::Result\n/// [prelude]: crate::prelude\n///\n/// # Examples\n///\n/// A convenience function that bubbles an `io::Result` to its caller:\n///\n/// ```\n/// use std::io;\n///\n/// fn get_string() -> io::Result<String> {\n///     let mut buffer = String::new();\n///\n///     io::stdin().read_line(&mut buffer)?;\n///\n///     Ok(buffer)\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result<T> = result::Result<T, Error>;\n\n/// The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and\n/// associated traits.\n///\n/// Errors mostly originate from the underlying OS, but custom instances of\n/// `Error` can be created with crafted error messages and a particular value of\n/// [`ErrorKind`].\n///\n/// [`Read`]: crate::io::Read\n/// [`Write`]: crate::io::Write\n/// [`Seek`]: crate::io::Seek\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Error {\n    repr: Repr,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.repr, f)\n    }\n}\n\nenum Repr {\n    Os(i32),\n    Simple(ErrorKind),\n    // &str is a fat pointer, but &&str is a thin pointer.\n    SimpleMessage(ErrorKind, &'static &'static str),\n    Custom(Box<Custom>),\n}\n\n#[derive(Debug)]\nstruct Custom {\n    kind: ErrorKind,\n    error: Box<dyn error::Error + Send + Sync>,\n}\n\n/// A list specifying general categories of I/O error.\n///\n/// This list is intended to grow over time and it is not recommended to\n/// exhaustively match against it.\n///\n/// It is used with the [`io::Error`] type.\n///\n/// [`io::Error`]: Error\n#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\n#[non_exhaustive]\npub enum ErrorKind {\n    /// An entity was not found, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotFound,\n    /// The operation lacked the necessary privileges to complete.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    PermissionDenied,\n    /// The connection was refused by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionRefused,\n    /// The connection was reset by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionReset,\n    /// The connection was aborted (terminated) by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionAborted,\n    /// The network operation failed because it was not connected yet.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotConnected,\n    /// A socket address could not be bound because the address is already in\n    /// use elsewhere.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrInUse,\n    /// A nonexistent interface was requested or the requested address was not\n    /// local.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrNotAvailable,\n    /// The operation failed because a pipe was closed.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    BrokenPipe,\n    /// An entity already exists, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AlreadyExists,\n    /// The operation needs to block to complete, but the blocking operation was\n    /// requested to not occur.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WouldBlock,\n    /// A parameter was incorrect.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    InvalidInput,\n    /// Data not valid for the operation were encountered.\n    ///\n    /// Unlike [`InvalidInput`], this typically means that the operation\n    /// parameters were valid, however the error was caused by malformed\n    /// input data.\n    ///\n    /// For example, a function that reads a file into a string will error with\n    /// `InvalidData` if the file's contents are not valid UTF-8.\n    ///\n    /// [`InvalidInput`]: ErrorKind::InvalidInput\n    #[stable(feature = \"io_invalid_data\", since = \"1.2.0\")]\n    InvalidData,\n    /// The I/O operation's timeout expired, causing it to be canceled.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    TimedOut,\n    /// An error returned when an operation could not be completed because a\n    /// call to [`write`] returned [`Ok(0)`].\n    ///\n    /// This typically means that an operation could only succeed if it wrote a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// written.\n    ///\n    /// [`write`]: crate::io::Write::write\n    /// [`Ok(0)`]: Ok\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WriteZero,\n    /// This operation was interrupted.\n    ///\n    /// Interrupted operations can typically be retried.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Interrupted,\n    /// Any I/O error not part of this list.\n    ///\n    /// Errors that are `Other` now may move to a different or a new\n    /// [`ErrorKind`] variant in the future. It is not recommended to match\n    /// an error against `Other` and to expect any additional characteristics,\n    /// e.g., a specific [`Error::raw_os_error`] return value.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Other,\n\n    /// An error returned when an operation could not be completed because an\n    /// \"end of file\" was reached prematurely.\n    ///\n    /// This typically means that an operation could only succeed if it read a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// read.\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    UnexpectedEof,\n\n    /// This operation is unsupported on this platform.\n    ///\n    /// This means that the operation can never succeed.\n    #[stable(feature = \"unsupported_error\", since = \"1.53.0\")]\n    Unsupported,\n\n    /// An operation could not be completed, because it failed\n    /// to allocate enough memory.\n    #[stable(feature = \"out_of_memory_error\", since = \"1.54.0\")]\n    OutOfMemory,\n}\n\nimpl ErrorKind {\n    pub(crate) fn as_str(&self) -> &'static str {\n        match *self {\n            ErrorKind::NotFound => \"entity not found\",\n            ErrorKind::PermissionDenied => \"permission denied\",\n            ErrorKind::ConnectionRefused => \"connection refused\",\n            ErrorKind::ConnectionReset => \"connection reset\",\n            ErrorKind::ConnectionAborted => \"connection aborted\",\n            ErrorKind::NotConnected => \"not connected\",\n            ErrorKind::AddrInUse => \"address in use\",\n            ErrorKind::AddrNotAvailable => \"address not available\",\n            ErrorKind::BrokenPipe => \"broken pipe\",\n            ErrorKind::AlreadyExists => \"entity already exists\",\n            ErrorKind::WouldBlock => \"operation would block\",\n            ErrorKind::InvalidInput => \"invalid input parameter\",\n            ErrorKind::InvalidData => \"invalid data\",\n            ErrorKind::TimedOut => \"timed out\",\n            ErrorKind::WriteZero => \"write zero\",\n            ErrorKind::Interrupted => \"operation interrupted\",\n            ErrorKind::Other => \"other os error\",\n            ErrorKind::UnexpectedEof => \"unexpected end of file\",\n            ErrorKind::Unsupported => \"unsupported\",\n            ErrorKind::OutOfMemory => \"out of memory\",\n        }\n    }\n}\n\n/// Intended for use for errors not exposed to the user, where allocating onto\n/// the heap (for normal construction via Error::new) is too costly.\n#[stable(feature = \"io_error_from_errorkind\", since = \"1.14.0\")]\nimpl From<ErrorKind> for Error {\n    /// Converts an [`ErrorKind`] into an [`Error`].\n    ///\n    /// This conversion allocates a new error with a simple representation of error kind.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// let not_found = ErrorKind::NotFound;\n    /// let error = Error::from(not_found);\n    /// assert_eq!(\"entity not found\", format!(\"{}\", error));\n    /// ```\n    #[inline]\n    fn from(kind: ErrorKind) -> Error {\n        Error { repr: Repr::Simple(kind) }\n    }\n}\n\nimpl Error {\n    /// Creates a new I/O error from a known kind of error as well as an\n    /// arbitrary error payload.\n    ///\n    /// This function is used to generically create I/O errors which do not\n    /// originate from the OS itself. The `error` argument is an arbitrary\n    /// payload which will be contained in this [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// // errors can be created from strings\n    /// let custom_error = Error::new(ErrorKind::Other, \"oh no!\");\n    ///\n    /// // errors can also be created from other errors\n    /// let custom_error2 = Error::new(ErrorKind::Interrupted, custom_error);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<E>(kind: ErrorKind, error: E) -> Error\n    where\n        E: Into<Box<dyn error::Error + Send + Sync>>,\n    {\n        Self::_new(kind, error.into())\n    }\n\n    fn _new(kind: ErrorKind, error: Box<dyn error::Error + Send + Sync>) -> Error {\n        Error { repr: Repr::Custom(Box::new(Custom { kind, error })) }\n    }\n\n    /// Creates a new I/O error from a known kind of error as well as a\n    /// constant message.\n    ///\n    /// This function does not allocate.\n    ///\n    /// This function should maybe change to\n    /// `new_const<const MSG: &'static str>(kind: ErrorKind)`\n    /// in the future, when const generics allow that.\n    #[inline]\n    pub(crate) const fn new_const(kind: ErrorKind, message: &'static &'static str) -> Error {\n        Self { repr: Repr::SimpleMessage(kind, message) }\n    }\n\n    /// Returns an error representing the last OS error which occurred.\n    ///\n    /// This function reads the value of `errno` for the target platform (e.g.\n    /// `GetLastError` on Windows) and will return a corresponding instance of\n    /// [`Error`] for the error code.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Error;\n    ///\n    /// println!(\"last OS error: {:?}\", Error::last_os_error());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn last_os_error() -> Error {\n        Error::from_raw_os_error(sys::os::errno() as i32)\n    }\n\n    /// Creates a new instance of an [`Error`] from a particular OS error code.\n    ///\n    /// # Examples\n    ///\n    /// On Linux:\n    ///\n    /// ```\n    /// # if cfg!(target_os = \"linux\") {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(22);\n    /// assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n    /// # }\n    /// ```\n    ///\n    /// On Windows:\n    ///\n    /// ```\n    /// # if cfg!(windows) {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(10022);\n    /// assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn from_raw_os_error(code: i32) -> Error {\n        Error { repr: Repr::Os(code) }\n    }\n\n    /// Returns the OS error that this error represents (if any).\n    ///\n    /// If this [`Error`] was constructed via [`last_os_error`] or\n    /// [`from_raw_os_error`], then this function will return [`Some`], otherwise\n    /// it will return [`None`].\n    ///\n    /// [`last_os_error`]: Error::last_os_error\n    /// [`from_raw_os_error`]: Error::from_raw_os_error\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_os_error(err: &Error) {\n    ///     if let Some(raw_os_err) = err.raw_os_error() {\n    ///         println!(\"raw OS error: {:?}\", raw_os_err);\n    ///     } else {\n    ///         println!(\"Not an OS error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"raw OS error: ...\".\n    ///     print_os_error(&Error::last_os_error());\n    ///     // Will print \"Not an OS error\".\n    ///     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn raw_os_error(&self) -> Option<i32> {\n        match self.repr {\n            Repr::Os(i) => Some(i),\n            Repr::Custom(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n        }\n    }\n\n    /// Returns a reference to the inner error wrapped by this error (if any).\n    ///\n    /// If this [`Error`] was constructed via [`new`] then this function will\n    /// return [`Some`], otherwise it will return [`None`].\n    ///\n    /// [`new`]: Error::new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {:?}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    #[inline]\n    pub fn get_ref(&self) -> Option<&(dyn error::Error + Send + Sync + 'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(ref c) => Some(&*c.error),\n        }\n    }\n\n    /// Returns a mutable reference to the inner error wrapped by this error\n    /// (if any).\n    ///\n    /// If this [`Error`] was constructed via [`new`] then this function will\n    /// return [`Some`], otherwise it will return [`None`].\n    ///\n    /// [`new`]: Error::new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    /// use std::{error, fmt};\n    /// use std::fmt::Display;\n    ///\n    /// #[derive(Debug)]\n    /// struct MyError {\n    ///     v: String,\n    /// }\n    ///\n    /// impl MyError {\n    ///     fn new() -> MyError {\n    ///         MyError {\n    ///             v: \"oh no!\".to_string()\n    ///         }\n    ///     }\n    ///\n    ///     fn change_message(&mut self, new_message: &str) {\n    ///         self.v = new_message.to_string();\n    ///     }\n    /// }\n    ///\n    /// impl error::Error for MyError {}\n    ///\n    /// impl Display for MyError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"MyError: {}\", &self.v)\n    ///     }\n    /// }\n    ///\n    /// fn change_error(mut err: Error) -> Error {\n    ///     if let Some(inner_err) = err.get_mut() {\n    ///         inner_err.downcast_mut::<MyError>().unwrap().change_message(\"I've been changed!\");\n    ///     }\n    ///     err\n    /// }\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&change_error(Error::last_os_error()));\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&change_error(Error::new(ErrorKind::Other, MyError::new())));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    #[inline]\n    pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(ref mut c) => Some(&mut *c.error),\n        }\n    }\n\n    /// Consumes the `Error`, returning its inner error (if any).\n    ///\n    /// If this [`Error`] was constructed via [`new`] then this function will\n    /// return [`Some`], otherwise it will return [`None`].\n    ///\n    /// [`new`]: Error::new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     if let Some(inner_err) = err.into_inner() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    #[inline]\n    pub fn into_inner(self) -> Option<Box<dyn error::Error + Send + Sync>> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(c) => Some(c.error),\n        }\n    }\n\n    /// Returns the corresponding [`ErrorKind`] for this error.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     println!(\"{:?}\", err.kind());\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"Other\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"AddrInUse\".\n    ///     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn kind(&self) -> ErrorKind {\n        match self.repr {\n            Repr::Os(code) => sys::decode_error_kind(code),\n            Repr::Custom(ref c) => c.kind,\n            Repr::Simple(kind) => kind,\n            Repr::SimpleMessage(kind, _) => kind,\n        }\n    }\n}\n\nimpl fmt::Debug for Repr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Repr::Os(code) => fmt\n                .debug_struct(\"Os\")\n                .field(\"code\", &code)\n                .field(\"kind\", &sys::decode_error_kind(code))\n                .field(\"message\", &sys::os::error_string(code))\n                .finish(),\n            Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),\n            Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n            Repr::SimpleMessage(kind, &message) => {\n                fmt.debug_struct(\"Error\").field(\"kind\", &kind).field(\"message\", &message).finish()\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Error {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.repr {\n            Repr::Os(code) => {\n                let detail = sys::os::error_string(code);\n                write!(fmt, \"{} (os error {})\", detail, code)\n            }\n            Repr::Custom(ref c) => c.error.fmt(fmt),\n            Repr::Simple(kind) => write!(fmt, \"{}\", kind.as_str()),\n            Repr::SimpleMessage(_, &msg) => msg.fmt(fmt),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl error::Error for Error {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        match self.repr {\n            Repr::Os(..) | Repr::Simple(..) => self.kind().as_str(),\n            Repr::SimpleMessage(_, &msg) => msg,\n            Repr::Custom(ref c) => c.error.description(),\n        }\n    }\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn error::Error> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(ref c) => c.error.cause(),\n        }\n    }\n\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(ref c) => c.error.source(),\n        }\n    }\n}\n\nfn _assert_error_is_sync_send() {\n    fn _is_sync_send<T: Sync + Send>() {}\n    _is_sync_send::<Error>();\n}\n"],["2522","#[cfg(test)]\nmod tests;\n\nuse crate::alloc::Allocator;\nuse crate::cmp;\nuse crate::fmt;\nuse crate::io::{\n    self, BufRead, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n};\nuse crate::mem;\n\n// =============================================================================\n// Forwarding implementations\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read + ?Sized> Read for &mut R {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        (**self).read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        (**self).is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        (**self).initializer()\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_to_end(buf)\n    }\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_to_string(buf)\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        (**self).read_exact(buf)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + ?Sized> Write for &mut W {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        (**self).write(buf)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        (**self).write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        (**self).is_write_vectored()\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        (**self).flush()\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (**self).write_all(buf)\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        (**self).write_fmt(fmt)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<S: Seek + ?Sized> Seek for &mut S {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        (**self).seek(pos)\n    }\n\n    #[inline]\n    fn stream_position(&mut self) -> io::Result<u64> {\n        (**self).stream_position()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead + ?Sized> BufRead for &mut B {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        (**self).fill_buf()\n    }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) {\n        (**self).consume(amt)\n    }\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_until(byte, buf)\n    }\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_line(buf)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read + ?Sized> Read for Box<R> {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        (**self).read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        (**self).is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        (**self).initializer()\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_to_end(buf)\n    }\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_to_string(buf)\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        (**self).read_exact(buf)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + ?Sized> Write for Box<W> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        (**self).write(buf)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        (**self).write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        (**self).is_write_vectored()\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        (**self).flush()\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (**self).write_all(buf)\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        (**self).write_fmt(fmt)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<S: Seek + ?Sized> Seek for Box<S> {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        (**self).seek(pos)\n    }\n\n    #[inline]\n    fn stream_position(&mut self) -> io::Result<u64> {\n        (**self).stream_position()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead + ?Sized> BufRead for Box<B> {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        (**self).fill_buf()\n    }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) {\n        (**self).consume(amt)\n    }\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_until(byte, buf)\n    }\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_line(buf)\n    }\n}\n\n// =============================================================================\n// In-memory buffer implementations\n\n/// Read is implemented for `&[u8]` by copying from the slice.\n///\n/// Note that reading updates the slice to point to the yet unread part.\n/// The slice will be empty when EOF is reached.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for &[u8] {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let amt = cmp::min(buf.len(), self.len());\n        let (a, b) = self.split_at(amt);\n\n        // First check if the amount of bytes we want to read is small:\n        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n        // for a single byte the overhead is significant.\n        if amt == 1 {\n            buf[0] = a[0];\n        } else {\n            buf[..amt].copy_from_slice(a);\n        }\n\n        *self = b;\n        Ok(amt)\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nread = 0;\n        for buf in bufs {\n            nread += self.read(buf)?;\n            if self.is_empty() {\n                break;\n            }\n        }\n\n        Ok(nread)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        if buf.len() > self.len() {\n            return Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"));\n        }\n        let (a, b) = self.split_at(buf.len());\n\n        // First check if the amount of bytes we want to read is small:\n        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n        // for a single byte the overhead is significant.\n        if buf.len() == 1 {\n            buf[0] = a[0];\n        } else {\n            buf.copy_from_slice(a);\n        }\n\n        *self = b;\n        Ok(())\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        buf.extend_from_slice(*self);\n        let len = self.len();\n        *self = &self[len..];\n        Ok(len)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl BufRead for &[u8] {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        Ok(*self)\n    }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) {\n        *self = &self[amt..];\n    }\n}\n\n/// Write is implemented for `&mut [u8]` by copying into the slice, overwriting\n/// its data.\n///\n/// Note that writing updates the slice to point to the yet unwritten part.\n/// The slice will be empty when it has been completely overwritten.\n///\n/// If the number of bytes to be written exceeds the size of the slice, write operations will\n/// return short writes: ultimately, `Ok(0)`; in this situation, `write_all` returns an error of\n/// kind `ErrorKind::WriteZero`.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for &mut [u8] {\n    #[inline]\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        let amt = cmp::min(data.len(), self.len());\n        let (a, b) = mem::replace(self, &mut []).split_at_mut(amt);\n        a.copy_from_slice(&data[..amt]);\n        *self = b;\n        Ok(amt)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let mut nwritten = 0;\n        for buf in bufs {\n            nwritten += self.write(buf)?;\n            if self.is_empty() {\n                break;\n            }\n        }\n\n        Ok(nwritten)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn write_all(&mut self, data: &[u8]) -> io::Result<()> {\n        if self.write(data)? == data.len() {\n            Ok(())\n        } else {\n            Err(Error::new_const(ErrorKind::WriteZero, &\"failed to write whole buffer\"))\n        }\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n/// Write is implemented for `Vec<u8>` by appending to the vector.\n/// The vector will grow as needed.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Allocator> Write for Vec<u8, A> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.extend_from_slice(buf);\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let len = bufs.iter().map(|b| b.len()).sum();\n        self.reserve(len);\n        for buf in bufs {\n            self.extend_from_slice(buf);\n        }\n        Ok(len)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.extend_from_slice(buf);\n        Ok(())\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n"],["2523","#![cfg_attr(test, allow(unused))]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::io::prelude::*;\n\nuse crate::cell::{Cell, RefCell};\nuse crate::fmt;\nuse crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\nuse crate::lazy::SyncOnceCell;\nuse crate::pin::Pin;\nuse crate::sync::atomic::{AtomicBool, Ordering};\nuse crate::sync::{Arc, Mutex, MutexGuard};\nuse crate::sys::stdio;\nuse crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n\ntype LocalStream = Arc<Mutex<Vec<u8>>>;\n\nthread_local! {\n    /// Used by the test crate to capture the output of the print macros and panics.\n    static OUTPUT_CAPTURE: Cell<Option<LocalStream>> = {\n        Cell::new(None)\n    }\n}\n\n/// Flag to indicate OUTPUT_CAPTURE is used.\n///\n/// If it is None and was never set on any thread, this flag is set to false,\n/// and OUTPUT_CAPTURE can be safely ignored on all threads, saving some time\n/// and memory registering an unused thread local.\n///\n/// Note about memory ordering: This contains information about whether a\n/// thread local variable might be in use. Although this is a global flag, the\n/// memory ordering between threads does not matter: we only want this flag to\n/// have a consistent order between set_output_capture and print_to *within\n/// the same thread*. Within the same thread, things always have a perfectly\n/// consistent order. So Ordering::Relaxed is fine.\nstatic OUTPUT_CAPTURE_USED: AtomicBool = AtomicBool::new(false);\n\n/// A handle to a raw instance of the standard input stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stdin_raw` function.\nstruct StdinRaw(stdio::Stdin);\n\n/// A handle to a raw instance of the standard output stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stdout_raw` function.\nstruct StdoutRaw(stdio::Stdout);\n\n/// A handle to a raw instance of the standard output stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stderr_raw` function.\nstruct StderrRaw(stdio::Stderr);\n\n/// Constructs a new raw handle to the standard input of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stdin`. Data buffered by the `std::io::stdin`\n/// handles is **not** available to raw handles returned from this function.\n///\n/// The returned handle has no external synchronization or buffering.\n#[unstable(feature = \"libstd_sys_internals\", issue = \"none\")]\nconst fn stdin_raw() -> StdinRaw {\n    StdinRaw(stdio::Stdin::new())\n}\n\n/// Constructs a new raw handle to the standard output stream of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stdout`. Note that data is buffered by the\n/// `std::io::stdout` handles so writes which happen via this raw handle may\n/// appear before previous writes.\n///\n/// The returned handle has no external synchronization or buffering layered on\n/// top.\n#[unstable(feature = \"libstd_sys_internals\", issue = \"none\")]\nconst fn stdout_raw() -> StdoutRaw {\n    StdoutRaw(stdio::Stdout::new())\n}\n\n/// Constructs a new raw handle to the standard error stream of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stderr`.\n///\n/// The returned handle has no external synchronization or buffering layered on\n/// top.\n#[unstable(feature = \"libstd_sys_internals\", issue = \"none\")]\nconst fn stderr_raw() -> StderrRaw {\n    StderrRaw(stdio::Stderr::new())\n}\n\nimpl Read for StdinRaw {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        handle_ebadf(self.0.read(buf), 0)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        handle_ebadf(self.0.read_vectored(bufs), 0)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.0.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        handle_ebadf(self.0.read_to_end(buf), 0)\n    }\n\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        handle_ebadf(self.0.read_to_string(buf), 0)\n    }\n}\n\nimpl Write for StdoutRaw {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        handle_ebadf(self.0.write(buf), buf.len())\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let total = bufs.iter().map(|b| b.len()).sum();\n        handle_ebadf(self.0.write_vectored(bufs), total)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        handle_ebadf(self.0.flush(), ())\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        handle_ebadf(self.0.write_all(buf), ())\n    }\n\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        handle_ebadf(self.0.write_all_vectored(bufs), ())\n    }\n\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        handle_ebadf(self.0.write_fmt(fmt), ())\n    }\n}\n\nimpl Write for StderrRaw {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        handle_ebadf(self.0.write(buf), buf.len())\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let total = bufs.iter().map(|b| b.len()).sum();\n        handle_ebadf(self.0.write_vectored(bufs), total)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        handle_ebadf(self.0.flush(), ())\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        handle_ebadf(self.0.write_all(buf), ())\n    }\n\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        handle_ebadf(self.0.write_all_vectored(bufs), ())\n    }\n\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        handle_ebadf(self.0.write_fmt(fmt), ())\n    }\n}\n\nfn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n    match r {\n        Err(ref e) if stdio::is_ebadf(e) => Ok(default),\n        r => r,\n    }\n}\n\n/// A handle to the standard input stream of a process.\n///\n/// Each handle is a shared reference to a global buffer of input data to this\n/// process. A handle can be `lock`'d to gain full access to [`BufRead`] methods\n/// (e.g., `.lines()`). Reads to this handle are otherwise locked with respect\n/// to other reads.\n///\n/// This handle implements the `Read` trait, but beware that concurrent reads\n/// of `Stdin` must be executed with care.\n///\n/// Created by the [`io::stdin`] method.\n///\n/// [`io::stdin`]: stdin\n///\n/// ### Note: Windows Portability Consideration\n///\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     let mut stdin = io::stdin(); // We get `Stdin` here.\n///     stdin.read_to_string(&mut buffer)?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stdin {\n    inner: &'static Mutex<BufReader<StdinRaw>>,\n}\n\n/// A locked reference to the [`Stdin`] handle.\n///\n/// This handle implements both the [`Read`] and [`BufRead`] traits, and\n/// is constructed via the [`Stdin::lock`] method.\n///\n/// ### Note: Windows Portability Consideration\n///\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     let stdin = io::stdin(); // We get `Stdin` here.\n///     {\n///         let mut handle = stdin.lock(); // We get `StdinLock` here.\n///         handle.read_to_string(&mut buffer)?;\n///     } // `StdinLock` is dropped here.\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StdinLock<'a> {\n    inner: MutexGuard<'a, BufReader<StdinRaw>>,\n}\n\n/// Constructs a new handle to the standard input of the current process.\n///\n/// Each handle returned is a reference to a shared global buffer whose access\n/// is synchronized via a mutex. If you need more explicit control over\n/// locking, see the [`Stdin::lock`] method.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     io::stdin().read_to_string(&mut buffer)?;\n///     Ok(())\n/// }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     let stdin = io::stdin();\n///     let mut handle = stdin.lock();\n///\n///     handle.read_to_string(&mut buffer)?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stdin() -> Stdin {\n    static INSTANCE: SyncOnceCell<Mutex<BufReader<StdinRaw>>> = SyncOnceCell::new();\n    Stdin {\n        inner: INSTANCE.get_or_init(|| {\n            Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin_raw()))\n        }),\n    }\n}\n\nimpl Stdin {\n    /// Locks this handle to the standard input stream, returning a readable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the [`Read`] and [`BufRead`] traits for\n    /// accessing the underlying data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{self, Read};\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut buffer = String::new();\n    ///     let stdin = io::stdin();\n    ///     let mut handle = stdin.lock();\n    ///\n    ///     handle.read_to_string(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StdinLock<'_> {\n        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n    }\n\n    /// Locks this handle and reads a line of input, appending it to the specified buffer.\n    ///\n    /// For detailed semantics of this method, see the documentation on\n    /// [`BufRead::read_line`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    ///\n    /// let mut input = String::new();\n    /// match io::stdin().read_line(&mut input) {\n    ///     Ok(n) => {\n    ///         println!(\"{} bytes read\", n);\n    ///         println!(\"{}\", input);\n    ///     }\n    ///     Err(error) => println!(\"error: {}\", error),\n    /// }\n    /// ```\n    ///\n    /// You can run the example one of two ways:\n    ///\n    /// - Pipe some text to it, e.g., `printf foo | path/to/executable`\n    /// - Give it text interactively by running the executable directly,\n    ///   in which case it will wait for the Enter key to be pressed before\n    ///   continuing\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn read_line(&self, buf: &mut String) -> io::Result<usize> {\n        self.lock().read_line(buf)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdin {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Stdin\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.lock().read(buf)\n    }\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.lock().read_vectored(bufs)\n    }\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.lock().is_read_vectored()\n    }\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        self.lock().read_to_end(buf)\n    }\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        self.lock().read_to_string(buf)\n    }\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        self.lock().read_exact(buf)\n    }\n}\n\n// only used by platform-dependent io::copy specializations, i.e. unused on some platforms\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\nimpl StdinLock<'_> {\n    pub(crate) fn as_mut_buf(&mut self) -> &mut BufReader<impl Read> {\n        &mut self.inner\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for StdinLock<'_> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        self.inner.read_to_end(buf)\n    }\n\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        self.inner.read_to_string(buf)\n    }\n\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        self.inner.read_exact(buf)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl BufRead for StdinLock<'_> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        self.inner.fill_buf()\n    }\n\n    fn consume(&mut self, n: usize) {\n        self.inner.consume(n)\n    }\n\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        self.inner.read_until(byte, buf)\n    }\n\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        self.inner.read_line(buf)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for StdinLock<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"StdinLock\").finish_non_exhaustive()\n    }\n}\n\n/// A handle to the global standard output stream of the current process.\n///\n/// Each handle shares a global buffer of data to be written to the standard\n/// output stream. Access is also synchronized via a lock and explicit control\n/// over locking is available via the [`lock`] method.\n///\n/// Created by the [`io::stdout`] method.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// [`lock`]: Stdout::lock\n/// [`io::stdout`]: stdout\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stdout {\n    // FIXME: this should be LineWriter or BufWriter depending on the state of\n    //        stdout (tty or not). Note that if this is not line buffered it\n    //        should also flush-on-panic or some form of flush-on-abort.\n    inner: Pin<&'static ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>,\n}\n\n/// A locked reference to the [`Stdout`] handle.\n///\n/// This handle implements the [`Write`] trait, and is constructed via\n/// the [`Stdout::lock`] method. See its documentation for more.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StdoutLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n}\n\nstatic STDOUT: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = SyncOnceCell::new();\n\n/// Constructs a new handle to the standard output of the current process.\n///\n/// Each handle returned is a reference to a shared global buffer whose access\n/// is synchronized via a mutex. If you need more explicit control over\n/// locking, see the [`Stdout::lock`] method.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     io::stdout().write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     let stdout = io::stdout();\n///     let mut handle = stdout.lock();\n///\n///     handle.write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stdout() -> Stdout {\n    Stdout {\n        inner: Pin::static_ref(&STDOUT).get_or_init_pin(\n            || unsafe { ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))) },\n            |mutex| unsafe { mutex.init() },\n        ),\n    }\n}\n\npub fn cleanup() {\n    if let Some(instance) = STDOUT.get() {\n        // Flush the data and disable buffering during shutdown\n        // by replacing the line writer by one with zero\n        // buffering capacity.\n        // We use try_lock() instead of lock(), because someone\n        // might have leaked a StdoutLock, which would\n        // otherwise cause a deadlock here.\n        if let Some(lock) = Pin::static_ref(instance).try_lock() {\n            *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n        }\n    }\n}\n\nimpl Stdout {\n    /// Locks this handle to the standard output stream, returning a writable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the `Write` trait for writing data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{self, Write};\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let stdout = io::stdout();\n    ///     let mut handle = stdout.lock();\n    ///\n    ///     handle.write_all(b\"hello world\")?;\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StdoutLock<'_> {\n        StdoutLock { inner: self.inner.lock() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdout {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Stdout\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        (&*self).write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        (&*self).write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        io::Write::is_write_vectored(&&*self)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        (&*self).flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (&*self).write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        (&*self).write_all_vectored(bufs)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n        (&*self).write_fmt(args)\n    }\n}\n\n#[stable(feature = \"write_mt\", since = \"1.48.0\")]\nimpl Write for &Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.lock().write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.lock().write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.lock().is_write_vectored()\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.lock().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.lock().write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        self.lock().write_all_vectored(bufs)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n        self.lock().write_fmt(args)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for StdoutLock<'_> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.borrow_mut().write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.borrow_mut().write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.inner.borrow_mut().is_write_vectored()\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.borrow_mut().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.inner.borrow_mut().write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        self.inner.borrow_mut().write_all_vectored(bufs)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for StdoutLock<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"StdoutLock\").finish_non_exhaustive()\n    }\n}\n\n/// A handle to the standard error stream of a process.\n///\n/// For more information, see the [`io::stderr`] method.\n///\n/// [`io::stderr`]: stderr\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stderr {\n    inner: Pin<&'static ReentrantMutex<RefCell<StderrRaw>>>,\n}\n\n/// A locked reference to the [`Stderr`] handle.\n///\n/// This handle implements the [`Write`] trait and is constructed via\n/// the [`Stderr::lock`] method. See its documentation for more.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StderrLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<StderrRaw>>,\n}\n\n/// Constructs a new handle to the standard error of the current process.\n///\n/// This handle is not buffered.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     io::stderr().write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     let stderr = io::stderr();\n///     let mut handle = stderr.lock();\n///\n///     handle.write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stderr() -> Stderr {\n    // Note that unlike `stdout()` we don't use `at_exit` here to register a\n    // destructor. Stderr is not buffered , so there's no need to run a\n    // destructor for flushing the buffer\n    static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<StderrRaw>>> = SyncOnceCell::new();\n\n    Stderr {\n        inner: Pin::static_ref(&INSTANCE).get_or_init_pin(\n            || unsafe { ReentrantMutex::new(RefCell::new(stderr_raw())) },\n            |mutex| unsafe { mutex.init() },\n        ),\n    }\n}\n\nimpl Stderr {\n    /// Locks this handle to the standard error stream, returning a writable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the [`Write`] trait for writing data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Write};\n    ///\n    /// fn foo() -> io::Result<()> {\n    ///     let stderr = io::stderr();\n    ///     let mut handle = stderr.lock();\n    ///\n    ///     handle.write_all(b\"hello world\")?;\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StderrLock<'_> {\n        StderrLock { inner: self.inner.lock() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stderr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Stderr\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        (&*self).write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        (&*self).write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        io::Write::is_write_vectored(&&*self)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        (&*self).flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (&*self).write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        (&*self).write_all_vectored(bufs)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n        (&*self).write_fmt(args)\n    }\n}\n\n#[stable(feature = \"write_mt\", since = \"1.48.0\")]\nimpl Write for &Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.lock().write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.lock().write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.lock().is_write_vectored()\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.lock().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.lock().write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        self.lock().write_all_vectored(bufs)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n        self.lock().write_fmt(args)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for StderrLock<'_> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.borrow_mut().write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.borrow_mut().write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.inner.borrow_mut().is_write_vectored()\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.borrow_mut().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.inner.borrow_mut().write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        self.inner.borrow_mut().write_all_vectored(bufs)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for StderrLock<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"StderrLock\").finish_non_exhaustive()\n    }\n}\n\n/// Sets the thread-local output capture buffer and returns the old one.\n#[unstable(\n    feature = \"internal_output_capture\",\n    reason = \"this function is meant for use in the test crate \\\n        and may disappear in the future\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\npub fn set_output_capture(sink: Option<LocalStream>) -> Option<LocalStream> {\n    if sink.is_none() && !OUTPUT_CAPTURE_USED.load(Ordering::Relaxed) {\n        // OUTPUT_CAPTURE is definitely None since OUTPUT_CAPTURE_USED is false.\n        return None;\n    }\n    OUTPUT_CAPTURE_USED.store(true, Ordering::Relaxed);\n    OUTPUT_CAPTURE.with(move |slot| slot.replace(sink))\n}\n\n/// Write `args` to the capture buffer if enabled and possible, or `global_s`\n/// otherwise. `label` identifies the stream in a panic message.\n///\n/// This function is used to print error messages, so it takes extra\n/// care to avoid causing a panic when `local_s` is unusable.\n/// For instance, if the TLS key for the local stream is\n/// already destroyed, or if the local stream is locked by another\n/// thread, it will just fall back to the global stream.\n///\n/// However, if the actual I/O causes an error, this function does panic.\nfn print_to<T>(args: fmt::Arguments<'_>, global_s: fn() -> T, label: &str)\nwhere\n    T: Write,\n{\n    if OUTPUT_CAPTURE_USED.load(Ordering::Relaxed)\n        && OUTPUT_CAPTURE.try_with(|s| {\n            // Note that we completely remove a local sink to write to in case\n            // our printing recursively panics/prints, so the recursive\n            // panic/print goes to the global sink instead of our local sink.\n            s.take().map(|w| {\n                let _ = w.lock().unwrap_or_else(|e| e.into_inner()).write_fmt(args);\n                s.set(Some(w));\n            })\n        }) == Ok(Some(()))\n    {\n        // Succesfully wrote to capture buffer.\n        return;\n    }\n\n    if let Err(e) = global_s().write_fmt(args) {\n        panic!(\"failed printing to {}: {}\", label, e);\n    }\n}\n\n#[unstable(\n    feature = \"print_internals\",\n    reason = \"implementation detail which may disappear or be replaced at any time\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\n#[cfg(not(test))]\npub fn _print(args: fmt::Arguments<'_>) {\n    print_to(args, stdout, \"stdout\");\n}\n\n#[unstable(\n    feature = \"print_internals\",\n    reason = \"implementation detail which may disappear or be replaced at any time\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\n#[cfg(not(test))]\npub fn _eprint(args: fmt::Arguments<'_>) {\n    print_to(args, stderr, \"stderr\");\n}\n\n#[cfg(test)]\npub use realstd::io::{_eprint, _print};\n"],["2524","use crate::cmp::{max, min};\nuse crate::io::prelude::*;\nuse crate::io::{\n    copy, empty, repeat, sink, BufWriter, Empty, Repeat, Result, SeekFrom, Sink, DEFAULT_BUF_SIZE,\n};\n\n#[test]\nfn copy_copies() {\n    let mut r = repeat(0).take(4);\n    let mut w = sink();\n    assert_eq!(copy(&mut r, &mut w).unwrap(), 4);\n\n    let mut r = repeat(0).take(1 << 17);\n    assert_eq!(copy(&mut r as &mut dyn Read, &mut w as &mut dyn Write).unwrap(), 1 << 17);\n}\n\nstruct ShortReader {\n    cap: usize,\n    read_size: usize,\n    observed_buffer: usize,\n}\n\nimpl Read for ShortReader {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        let bytes = min(self.cap, self.read_size);\n        self.cap -= bytes;\n        self.observed_buffer = max(self.observed_buffer, buf.len());\n        Ok(bytes)\n    }\n}\n\nstruct WriteObserver {\n    observed_buffer: usize,\n}\n\nimpl Write for WriteObserver {\n    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.observed_buffer = max(self.observed_buffer, buf.len());\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[test]\nfn copy_specializes_bufwriter() {\n    let cap = 117 * 1024;\n    let buf_sz = 16 * 1024;\n    let mut r = ShortReader { cap, observed_buffer: 0, read_size: 1337 };\n    let mut w = BufWriter::with_capacity(buf_sz, WriteObserver { observed_buffer: 0 });\n    assert_eq!(\n        copy(&mut r, &mut w).unwrap(),\n        cap as u64,\n        \"expected the whole capacity to be copied\"\n    );\n    assert_eq!(r.observed_buffer, buf_sz, \"expected a large buffer to be provided to the reader\");\n    assert!(w.get_mut().observed_buffer > DEFAULT_BUF_SIZE, \"expected coalesced writes\");\n}\n\n#[test]\nfn sink_sinks() {\n    let mut s = sink();\n    assert_eq!(s.write(&[]).unwrap(), 0);\n    assert_eq!(s.write(&[0]).unwrap(), 1);\n    assert_eq!(s.write(&[0; 1024]).unwrap(), 1024);\n    assert_eq!(s.by_ref().write(&[0; 1024]).unwrap(), 1024);\n}\n\n#[test]\nfn empty_reads() {\n    let mut e = empty();\n    assert_eq!(e.read(&mut []).unwrap(), 0);\n    assert_eq!(e.read(&mut [0]).unwrap(), 0);\n    assert_eq!(e.read(&mut [0; 1024]).unwrap(), 0);\n    assert_eq!(e.by_ref().read(&mut [0; 1024]).unwrap(), 0);\n}\n\n#[test]\nfn empty_seeks() {\n    let mut e = empty();\n    assert!(matches!(e.seek(SeekFrom::Start(0)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Start(1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Start(u64::MAX)), Ok(0)));\n\n    assert!(matches!(e.seek(SeekFrom::End(i64::MIN)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::End(-1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::End(0)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::End(1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::End(i64::MAX)), Ok(0)));\n\n    assert!(matches!(e.seek(SeekFrom::Current(i64::MIN)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Current(-1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Current(0)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Current(1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Current(i64::MAX)), Ok(0)));\n}\n\n#[test]\nfn repeat_repeats() {\n    let mut r = repeat(4);\n    let mut b = [0; 1024];\n    assert_eq!(r.read(&mut b).unwrap(), 1024);\n    assert!(b.iter().all(|b| *b == 4));\n}\n\n#[test]\nfn take_some_bytes() {\n    assert_eq!(repeat(4).take(100).bytes().count(), 100);\n    assert_eq!(repeat(4).take(100).bytes().next().unwrap().unwrap(), 4);\n    assert_eq!(repeat(1).take(10).chain(repeat(2).take(10)).bytes().count(), 20);\n}\n\n#[allow(dead_code)]\nfn const_utils() {\n    const _: Empty = empty();\n    const _: Repeat = repeat(b'c');\n    const _: Sink = sink();\n}\n"],["2525","use crate::io::prelude::*;\nuse crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, SeekFrom};\nuse crate::panic;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::thread;\n\n/// A dummy reader intended at testing short-reads propagation.\npub struct ShortReader {\n    lengths: Vec<usize>,\n}\n\n// FIXME: rustfmt and tidy disagree about the correct formatting of this\n// function. This leads to issues for users with editors configured to\n// rustfmt-on-save.\nimpl Read for ShortReader {\n    fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n        if self.lengths.is_empty() { Ok(0) } else { Ok(self.lengths.remove(0)) }\n    }\n}\n\n#[test]\nfn test_buffered_reader() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(2, inner);\n\n    let mut buf = [0, 0, 0];\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 3);\n    assert_eq!(buf, [5, 6, 7]);\n    assert_eq!(reader.buffer(), []);\n\n    let mut buf = [0, 0];\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 2);\n    assert_eq!(buf, [0, 1]);\n    assert_eq!(reader.buffer(), []);\n\n    let mut buf = [0];\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 1);\n    assert_eq!(buf, [2]);\n    assert_eq!(reader.buffer(), [3]);\n\n    let mut buf = [0, 0, 0];\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 1);\n    assert_eq!(buf, [3, 0, 0]);\n    assert_eq!(reader.buffer(), []);\n\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 1);\n    assert_eq!(buf, [4, 0, 0]);\n    assert_eq!(reader.buffer(), []);\n\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_buffered_reader_seek() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n\n    assert_eq!(reader.seek(SeekFrom::Start(3)).ok(), Some(3));\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(3));\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert_eq!(reader.seek(SeekFrom::Current(1)).ok(), Some(4));\n    assert_eq!(reader.fill_buf().ok(), Some(&[1, 2][..]));\n    reader.consume(1);\n    assert_eq!(reader.seek(SeekFrom::Current(-2)).ok(), Some(3));\n}\n\n#[test]\nfn test_buffered_reader_seek_relative() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n\n    assert!(reader.seek_relative(3).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert!(reader.seek_relative(0).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert!(reader.seek_relative(1).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[1][..]));\n    assert!(reader.seek_relative(-1).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert!(reader.seek_relative(2).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[2, 3][..]));\n}\n\n#[test]\nfn test_buffered_reader_stream_position() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n\n    assert_eq!(reader.stream_position().ok(), Some(0));\n    assert_eq!(reader.seek(SeekFrom::Start(3)).ok(), Some(3));\n    assert_eq!(reader.stream_position().ok(), Some(3));\n    // relative seeking within the buffer and reading position should keep the buffer\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert!(reader.seek_relative(0).is_ok());\n    assert_eq!(reader.stream_position().ok(), Some(3));\n    assert_eq!(reader.buffer(), &[0, 1][..]);\n    assert!(reader.seek_relative(1).is_ok());\n    assert_eq!(reader.stream_position().ok(), Some(4));\n    assert_eq!(reader.buffer(), &[1][..]);\n    assert!(reader.seek_relative(-1).is_ok());\n    assert_eq!(reader.stream_position().ok(), Some(3));\n    assert_eq!(reader.buffer(), &[0, 1][..]);\n    // relative seeking outside the buffer will discard it\n    assert!(reader.seek_relative(2).is_ok());\n    assert_eq!(reader.stream_position().ok(), Some(5));\n    assert_eq!(reader.buffer(), &[][..]);\n}\n\n#[test]\nfn test_buffered_reader_stream_position_panic() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(4, io::Cursor::new(inner));\n\n    // cause internal buffer to be filled but read only partially\n    let mut buffer = [0, 0];\n    assert!(reader.read_exact(&mut buffer).is_ok());\n    // rewinding the internal reader will cause buffer to loose sync\n    let inner = reader.get_mut();\n    assert!(inner.seek(SeekFrom::Start(0)).is_ok());\n    // overflow when subtracting the remaining buffer size from current position\n    let result = panic::catch_unwind(panic::AssertUnwindSafe(|| reader.stream_position().ok()));\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_buffered_reader_invalidated_after_read() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n\n    assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n    reader.consume(3);\n\n    let mut buffer = [0, 0, 0, 0, 0];\n    assert_eq!(reader.read(&mut buffer).ok(), Some(5));\n    assert_eq!(buffer, [0, 1, 2, 3, 4]);\n\n    assert!(reader.seek_relative(-2).is_ok());\n    let mut buffer = [0, 0];\n    assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n    assert_eq!(buffer, [3, 4]);\n}\n\n#[test]\nfn test_buffered_reader_invalidated_after_seek() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n\n    assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n    reader.consume(3);\n\n    assert!(reader.seek(SeekFrom::Current(5)).is_ok());\n\n    assert!(reader.seek_relative(-2).is_ok());\n    let mut buffer = [0, 0];\n    assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n    assert_eq!(buffer, [3, 4]);\n}\n\n#[test]\nfn test_buffered_reader_seek_underflow() {\n    // gimmick reader that yields its position modulo 256 for each byte\n    struct PositionReader {\n        pos: u64,\n    }\n    impl Read for PositionReader {\n        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n            let len = buf.len();\n            for x in buf {\n                *x = self.pos as u8;\n                self.pos = self.pos.wrapping_add(1);\n            }\n            Ok(len)\n        }\n    }\n    impl Seek for PositionReader {\n        fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n            match pos {\n                SeekFrom::Start(n) => {\n                    self.pos = n;\n                }\n                SeekFrom::Current(n) => {\n                    self.pos = self.pos.wrapping_add(n as u64);\n                }\n                SeekFrom::End(n) => {\n                    self.pos = u64::MAX.wrapping_add(n as u64);\n                }\n            }\n            Ok(self.pos)\n        }\n    }\n\n    let mut reader = BufReader::with_capacity(5, PositionReader { pos: 0 });\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2, 3, 4][..]));\n    assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::MAX - 5));\n    assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n    // the following seek will require two underlying seeks\n    let expected = 9223372036854775802;\n    assert_eq!(reader.seek(SeekFrom::Current(i64::MIN)).ok(), Some(expected));\n    assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n    // seeking to 0 should empty the buffer.\n    assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(expected));\n    assert_eq!(reader.get_ref().pos, expected);\n}\n\n#[test]\nfn test_buffered_reader_seek_underflow_discard_buffer_between_seeks() {\n    // gimmick reader that returns Err after first seek\n    struct ErrAfterFirstSeekReader {\n        first_seek: bool,\n    }\n    impl Read for ErrAfterFirstSeekReader {\n        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n            for x in &mut *buf {\n                *x = 0;\n            }\n            Ok(buf.len())\n        }\n    }\n    impl Seek for ErrAfterFirstSeekReader {\n        fn seek(&mut self, _: SeekFrom) -> io::Result<u64> {\n            if self.first_seek {\n                self.first_seek = false;\n                Ok(0)\n            } else {\n                Err(io::Error::new(io::ErrorKind::Other, \"oh no!\"))\n            }\n        }\n    }\n\n    let mut reader = BufReader::with_capacity(5, ErrAfterFirstSeekReader { first_seek: true });\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 0, 0, 0, 0][..]));\n\n    // The following seek will require two underlying seeks.  The first will\n    // succeed but the second will fail.  This should still invalidate the\n    // buffer.\n    assert!(reader.seek(SeekFrom::Current(i64::MIN)).is_err());\n    assert_eq!(reader.buffer().len(), 0);\n}\n\n#[test]\nfn test_buffered_writer() {\n    let inner = Vec::new();\n    let mut writer = BufWriter::with_capacity(2, inner);\n\n    writer.write(&[0, 1]).unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1]);\n\n    writer.write(&[2]).unwrap();\n    assert_eq!(writer.buffer(), [2]);\n    assert_eq!(*writer.get_ref(), [0, 1]);\n\n    writer.write(&[3]).unwrap();\n    assert_eq!(writer.buffer(), [2, 3]);\n    assert_eq!(*writer.get_ref(), [0, 1]);\n\n    writer.flush().unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n\n    writer.write(&[4]).unwrap();\n    writer.write(&[5]).unwrap();\n    assert_eq!(writer.buffer(), [4, 5]);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n\n    writer.write(&[6]).unwrap();\n    assert_eq!(writer.buffer(), [6]);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5]);\n\n    writer.write(&[7, 8]).unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8]);\n\n    writer.write(&[9, 10, 11]).unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n\n    writer.flush().unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n}\n\n#[test]\nfn test_buffered_writer_inner_flushes() {\n    let mut w = BufWriter::with_capacity(3, Vec::new());\n    w.write(&[0, 1]).unwrap();\n    assert_eq!(*w.get_ref(), []);\n    let w = w.into_inner().unwrap();\n    assert_eq!(w, [0, 1]);\n}\n\n#[test]\nfn test_buffered_writer_seek() {\n    let mut w = BufWriter::with_capacity(3, io::Cursor::new(Vec::new()));\n    w.write_all(&[0, 1, 2, 3, 4, 5]).unwrap();\n    w.write_all(&[6, 7]).unwrap();\n    assert_eq!(w.seek(SeekFrom::Current(0)).ok(), Some(8));\n    assert_eq!(&w.get_ref().get_ref()[..], &[0, 1, 2, 3, 4, 5, 6, 7][..]);\n    assert_eq!(w.seek(SeekFrom::Start(2)).ok(), Some(2));\n    w.write_all(&[8, 9]).unwrap();\n    assert_eq!(&w.into_inner().unwrap().into_inner()[..], &[0, 1, 8, 9, 4, 5, 6, 7]);\n}\n\n#[test]\nfn test_read_until() {\n    let inner: &[u8] = &[0, 1, 2, 1, 0];\n    let mut reader = BufReader::with_capacity(2, inner);\n    let mut v = Vec::new();\n    reader.read_until(0, &mut v).unwrap();\n    assert_eq!(v, [0]);\n    v.truncate(0);\n    reader.read_until(2, &mut v).unwrap();\n    assert_eq!(v, [1, 2]);\n    v.truncate(0);\n    reader.read_until(1, &mut v).unwrap();\n    assert_eq!(v, [1]);\n    v.truncate(0);\n    reader.read_until(8, &mut v).unwrap();\n    assert_eq!(v, [0]);\n    v.truncate(0);\n    reader.read_until(9, &mut v).unwrap();\n    assert_eq!(v, []);\n}\n\n#[test]\nfn test_line_buffer() {\n    let mut writer = LineWriter::new(Vec::new());\n    writer.write(&[0]).unwrap();\n    assert_eq!(*writer.get_ref(), []);\n    writer.write(&[1]).unwrap();\n    assert_eq!(*writer.get_ref(), []);\n    writer.flush().unwrap();\n    assert_eq!(*writer.get_ref(), [0, 1]);\n    writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n    assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n']);\n    writer.flush().unwrap();\n    assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2]);\n    writer.write(&[3, b'\\n']).unwrap();\n    assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n}\n\n#[test]\nfn test_read_line() {\n    let in_buf: &[u8] = b\"a\\nb\\nc\";\n    let mut reader = BufReader::with_capacity(2, in_buf);\n    let mut s = String::new();\n    reader.read_line(&mut s).unwrap();\n    assert_eq!(s, \"a\\n\");\n    s.truncate(0);\n    reader.read_line(&mut s).unwrap();\n    assert_eq!(s, \"b\\n\");\n    s.truncate(0);\n    reader.read_line(&mut s).unwrap();\n    assert_eq!(s, \"c\");\n    s.truncate(0);\n    reader.read_line(&mut s).unwrap();\n    assert_eq!(s, \"\");\n}\n\n#[test]\nfn test_lines() {\n    let in_buf: &[u8] = b\"a\\nb\\nc\";\n    let reader = BufReader::with_capacity(2, in_buf);\n    let mut it = reader.lines();\n    assert_eq!(it.next().unwrap().unwrap(), \"a\".to_string());\n    assert_eq!(it.next().unwrap().unwrap(), \"b\".to_string());\n    assert_eq!(it.next().unwrap().unwrap(), \"c\".to_string());\n    assert!(it.next().is_none());\n}\n\n#[test]\nfn test_short_reads() {\n    let inner = ShortReader { lengths: vec![0, 1, 2, 0, 1, 0] };\n    let mut reader = BufReader::new(inner);\n    let mut buf = [0, 0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.read(&mut buf).unwrap(), 2);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\n#[should_panic]\nfn dont_panic_in_drop_on_panicked_flush() {\n    struct FailFlushWriter;\n\n    impl Write for FailFlushWriter {\n        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n            Ok(buf.len())\n        }\n        fn flush(&mut self) -> io::Result<()> {\n            Err(io::Error::last_os_error())\n        }\n    }\n\n    let writer = FailFlushWriter;\n    let _writer = BufWriter::new(writer);\n\n    // If writer panics *again* due to the flush error then the process will\n    // abort.\n    panic!();\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn panic_in_write_doesnt_flush_in_drop() {\n    static WRITES: AtomicUsize = AtomicUsize::new(0);\n\n    struct PanicWriter;\n\n    impl Write for PanicWriter {\n        fn write(&mut self, _: &[u8]) -> io::Result<usize> {\n            WRITES.fetch_add(1, Ordering::SeqCst);\n            panic!();\n        }\n        fn flush(&mut self) -> io::Result<()> {\n            Ok(())\n        }\n    }\n\n    thread::spawn(|| {\n        let mut writer = BufWriter::new(PanicWriter);\n        let _ = writer.write(b\"hello world\");\n        let _ = writer.flush();\n    })\n    .join()\n    .unwrap_err();\n\n    assert_eq!(WRITES.load(Ordering::SeqCst), 1);\n}\n\n#[bench]\nfn bench_buffered_reader(b: &mut test::Bencher) {\n    b.iter(|| BufReader::new(io::empty()));\n}\n\n#[bench]\nfn bench_buffered_reader_small_reads(b: &mut test::Bencher) {\n    let data = (0..u8::MAX).cycle().take(1024 * 4).collect::<Vec<_>>();\n    b.iter(|| {\n        let mut reader = BufReader::new(&data[..]);\n        let mut buf = [0u8; 4];\n        for _ in 0..1024 {\n            reader.read_exact(&mut buf).unwrap();\n        }\n    });\n}\n\n#[bench]\nfn bench_buffered_writer(b: &mut test::Bencher) {\n    b.iter(|| BufWriter::new(io::sink()));\n}\n\n/// A simple `Write` target, designed to be wrapped by `LineWriter` /\n/// `BufWriter` / etc, that can have its `write` & `flush` behavior\n/// configured\n#[derive(Default, Clone)]\nstruct ProgrammableSink {\n    // Writes append to this slice\n    pub buffer: Vec<u8>,\n\n    // Flush sets this flag\n    pub flushed: bool,\n\n    // If true, writes will always be an error\n    pub always_write_error: bool,\n\n    // If true, flushes will always be an error\n    pub always_flush_error: bool,\n\n    // If set, only up to this number of bytes will be written in a single\n    // call to `write`\n    pub accept_prefix: Option<usize>,\n\n    // If set, counts down with each write, and writes return an error\n    // when it hits 0\n    pub max_writes: Option<usize>,\n\n    // If set, attempting to write when max_writes == Some(0) will be an\n    // error; otherwise, it will return Ok(0).\n    pub error_after_max_writes: bool,\n}\n\nimpl Write for ProgrammableSink {\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        if self.always_write_error {\n            return Err(io::Error::new(io::ErrorKind::Other, \"test - always_write_error\"));\n        }\n\n        match self.max_writes {\n            Some(0) if self.error_after_max_writes => {\n                return Err(io::Error::new(io::ErrorKind::Other, \"test - max_writes\"));\n            }\n            Some(0) => return Ok(0),\n            Some(ref mut count) => *count -= 1,\n            None => {}\n        }\n\n        let len = match self.accept_prefix {\n            None => data.len(),\n            Some(prefix) => data.len().min(prefix),\n        };\n\n        let data = &data[..len];\n        self.buffer.extend_from_slice(data);\n\n        Ok(len)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        if self.always_flush_error {\n            Err(io::Error::new(io::ErrorKind::Other, \"test - always_flush_error\"))\n        } else {\n            self.flushed = true;\n            Ok(())\n        }\n    }\n}\n\n/// Previously the `LineWriter` could successfully write some bytes but\n/// then fail to report that it has done so. Additionally, an erroneous\n/// flush after a successful write was permanently ignored.\n///\n/// Test that a line writer correctly reports the number of written bytes,\n/// and that it attempts to flush buffered lines from previous writes\n/// before processing new data\n///\n/// Regression test for #37807\n#[test]\nfn erroneous_flush_retried() {\n    let writer = ProgrammableSink {\n        // Only write up to 4 bytes at a time\n        accept_prefix: Some(4),\n\n        // Accept the first two writes, then error the others\n        max_writes: Some(2),\n        error_after_max_writes: true,\n\n        ..Default::default()\n    };\n\n    // This should write the first 4 bytes. The rest will be buffered, out\n    // to the last newline.\n    let mut writer = LineWriter::new(writer);\n    assert_eq!(writer.write(b\"a\\nb\\nc\\nd\\ne\").unwrap(), 8);\n\n    // This write should attempt to flush \"c\\nd\\n\", then buffer \"e\". No\n    // errors should happen here because no further writes should be\n    // attempted against `writer`.\n    assert_eq!(writer.write(b\"e\").unwrap(), 1);\n    assert_eq!(&writer.get_ref().buffer, b\"a\\nb\\nc\\nd\\n\");\n}\n\n#[test]\nfn line_vectored() {\n    let mut a = LineWriter::new(Vec::new());\n    assert_eq!(\n        a.write_vectored(&[\n            IoSlice::new(&[]),\n            IoSlice::new(b\"\\n\"),\n            IoSlice::new(&[]),\n            IoSlice::new(b\"a\"),\n        ])\n        .unwrap(),\n        2,\n    );\n    assert_eq!(a.get_ref(), b\"\\n\");\n\n    assert_eq!(\n        a.write_vectored(&[\n            IoSlice::new(&[]),\n            IoSlice::new(b\"b\"),\n            IoSlice::new(&[]),\n            IoSlice::new(b\"a\"),\n            IoSlice::new(&[]),\n            IoSlice::new(b\"c\"),\n        ])\n        .unwrap(),\n        3,\n    );\n    assert_eq!(a.get_ref(), b\"\\n\");\n    a.flush().unwrap();\n    assert_eq!(a.get_ref(), b\"\\nabac\");\n    assert_eq!(a.write_vectored(&[]).unwrap(), 0);\n    assert_eq!(\n        a.write_vectored(&[\n            IoSlice::new(&[]),\n            IoSlice::new(&[]),\n            IoSlice::new(&[]),\n            IoSlice::new(&[]),\n        ])\n        .unwrap(),\n        0,\n    );\n    assert_eq!(a.write_vectored(&[IoSlice::new(b\"a\\nb\"),]).unwrap(), 3);\n    assert_eq!(a.get_ref(), b\"\\nabaca\\nb\");\n}\n\n#[test]\nfn line_vectored_partial_and_errors() {\n    use crate::collections::VecDeque;\n\n    enum Call {\n        Write { inputs: Vec<&'static [u8]>, output: io::Result<usize> },\n        Flush { output: io::Result<()> },\n    }\n\n    #[derive(Default)]\n    struct Writer {\n        calls: VecDeque<Call>,\n    }\n\n    impl Write for Writer {\n        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n            self.write_vectored(&[IoSlice::new(buf)])\n        }\n\n        fn write_vectored(&mut self, buf: &[IoSlice<'_>]) -> io::Result<usize> {\n            match self.calls.pop_front().expect(\"unexpected call to write\") {\n                Call::Write { inputs, output } => {\n                    assert_eq!(inputs, buf.iter().map(|b| &**b).collect::<Vec<_>>());\n                    output\n                }\n                Call::Flush { .. } => panic!(\"unexpected call to write; expected a flush\"),\n            }\n        }\n\n        fn is_write_vectored(&self) -> bool {\n            true\n        }\n\n        fn flush(&mut self) -> io::Result<()> {\n            match self.calls.pop_front().expect(\"Unexpected call to flush\") {\n                Call::Flush { output } => output,\n                Call::Write { .. } => panic!(\"unexpected call to flush; expected a write\"),\n            }\n        }\n    }\n\n    impl Drop for Writer {\n        fn drop(&mut self) {\n            if !thread::panicking() {\n                assert_eq!(self.calls.len(), 0);\n            }\n        }\n    }\n\n    // partial writes keep going\n    let mut a = LineWriter::new(Writer::default());\n    a.write_vectored(&[IoSlice::new(&[]), IoSlice::new(b\"abc\")]).unwrap();\n\n    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"abc\"], output: Ok(1) });\n    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"bc\"], output: Ok(2) });\n    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\n\"], output: Ok(2) });\n\n    a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\n\")]).unwrap();\n\n    a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n    a.flush().unwrap();\n\n    // erroneous writes stop and don't write more\n    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\na\"], output: Err(err()) });\n    a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n    assert!(a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\na\")]).is_err());\n    a.flush().unwrap();\n\n    fn err() -> io::Error {\n        io::Error::new(io::ErrorKind::Other, \"x\")\n    }\n}\n\n/// Test that, in cases where vectored writing is not enabled, the\n/// LineWriter uses the normal `write` call, which more-correctly handles\n/// partial lines\n#[test]\nfn line_vectored_ignored() {\n    let writer = ProgrammableSink::default();\n    let mut writer = LineWriter::new(writer);\n\n    let content = [\n        IoSlice::new(&[]),\n        IoSlice::new(b\"Line 1\\nLine\"),\n        IoSlice::new(b\" 2\\nLine 3\\nL\"),\n        IoSlice::new(&[]),\n        IoSlice::new(&[]),\n        IoSlice::new(b\"ine 4\"),\n        IoSlice::new(b\"\\nLine 5\\n\"),\n    ];\n\n    let count = writer.write_vectored(&content).unwrap();\n    assert_eq!(count, 11);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n\n    let count = writer.write_vectored(&content[2..]).unwrap();\n    assert_eq!(count, 11);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n\n    let count = writer.write_vectored(&content[5..]).unwrap();\n    assert_eq!(count, 5);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n\n    let count = writer.write_vectored(&content[6..]).unwrap();\n    assert_eq!(count, 8);\n    assert_eq!(\n        writer.get_ref().buffer.as_slice(),\n        b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\n\".as_ref()\n    );\n}\n\n/// Test that, given this input:\n///\n/// Line 1\\n\n/// Line 2\\n\n/// Line 3\\n\n/// Line 4\n///\n/// And given a result that only writes to midway through Line 2\n///\n/// That only up to the end of Line 3 is buffered\n///\n/// This behavior is desirable because it prevents flushing partial lines\n#[test]\nfn partial_write_buffers_line() {\n    let writer = ProgrammableSink { accept_prefix: Some(13), ..Default::default() };\n    let mut writer = LineWriter::new(writer);\n\n    assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\\nLine4\").unwrap(), 21);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\");\n\n    assert_eq!(writer.write(b\"Line 4\").unwrap(), 6);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n}\n\n/// Test that, given this input:\n///\n/// Line 1\\n\n/// Line 2\\n\n/// Line 3\n///\n/// And given that the full write of lines 1 and 2 was successful\n/// That data up to Line 3 is buffered\n#[test]\nfn partial_line_buffered_after_line_write() {\n    let writer = ProgrammableSink::default();\n    let mut writer = LineWriter::new(writer);\n\n    assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\").unwrap(), 20);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\n\");\n\n    assert!(writer.flush().is_ok());\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\");\n}\n\n/// Test that, given a partial line that exceeds the length of\n/// LineBuffer's buffer (that is, without a trailing newline), that that\n/// line is written to the inner writer\n#[test]\nfn long_line_flushed() {\n    let writer = ProgrammableSink::default();\n    let mut writer = LineWriter::with_capacity(5, writer);\n\n    assert_eq!(writer.write(b\"0123456789\").unwrap(), 10);\n    assert_eq!(&writer.get_ref().buffer, b\"0123456789\");\n}\n\n/// Test that, given a very long partial line *after* successfully\n/// flushing a complete line, that that line is buffered unconditionally,\n/// and no additional writes take place. This assures the property that\n/// `write` should make at-most-one attempt to write new data.\n#[test]\nfn line_long_tail_not_flushed() {\n    let writer = ProgrammableSink::default();\n    let mut writer = LineWriter::with_capacity(5, writer);\n\n    // Assert that Line 1\\n is flushed, and 01234 is buffered\n    assert_eq!(writer.write(b\"Line 1\\n0123456789\").unwrap(), 12);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n\n    // Because the buffer is full, this subsequent write will flush it\n    assert_eq!(writer.write(b\"5\").unwrap(), 1);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n01234\");\n}\n\n/// Test that, if an attempt to pre-flush buffered data returns Ok(0),\n/// this is propagated as an error.\n#[test]\nfn line_buffer_write0_error() {\n    let writer = ProgrammableSink {\n        // Accept one write, then return Ok(0) on subsequent ones\n        max_writes: Some(1),\n\n        ..Default::default()\n    };\n    let mut writer = LineWriter::new(writer);\n\n    // This should write \"Line 1\\n\" and buffer \"Partial\"\n    assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n\n    // This will attempt to flush \"partial\", which will return Ok(0), which\n    // needs to be an error, because we've already informed the client\n    // that we accepted the write.\n    let err = writer.write(b\" Line End\\n\").unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::WriteZero);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n}\n\n/// Test that, if a write returns Ok(0) after a successful pre-flush, this\n/// is propagated as Ok(0)\n#[test]\nfn line_buffer_write0_normal() {\n    let writer = ProgrammableSink {\n        // Accept two writes, then return Ok(0) on subsequent ones\n        max_writes: Some(2),\n\n        ..Default::default()\n    };\n    let mut writer = LineWriter::new(writer);\n\n    // This should write \"Line 1\\n\" and buffer \"Partial\"\n    assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n\n    // This will flush partial, which will succeed, but then return Ok(0)\n    // when flushing \" Line End\\n\"\n    assert_eq!(writer.write(b\" Line End\\n\").unwrap(), 0);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nPartial\");\n}\n\n/// LineWriter has a custom `write_all`; make sure it works correctly\n#[test]\nfn line_write_all() {\n    let writer = ProgrammableSink {\n        // Only write 5 bytes at a time\n        accept_prefix: Some(5),\n        ..Default::default()\n    };\n    let mut writer = LineWriter::new(writer);\n\n    writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\").unwrap();\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\n\");\n    writer.write_all(b\" Line 5\\n\").unwrap();\n    assert_eq!(\n        writer.get_ref().buffer.as_slice(),\n        b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial Line 5\\n\".as_ref(),\n    );\n}\n\n#[test]\nfn line_write_all_error() {\n    let writer = ProgrammableSink {\n        // Only accept up to 3 writes of up to 5 bytes each\n        accept_prefix: Some(5),\n        max_writes: Some(3),\n        ..Default::default()\n    };\n\n    let mut writer = LineWriter::new(writer);\n    let res = writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\");\n    assert!(res.is_err());\n    // An error from write_all leaves everything in an indeterminate state,\n    // so there's nothing else to test here\n}\n\n/// Under certain circumstances, the old implementation of LineWriter\n/// would try to buffer \"to the last newline\" but be forced to buffer\n/// less than that, leading to inappropriate partial line writes.\n/// Regression test for that issue.\n#[test]\nfn partial_multiline_buffering() {\n    let writer = ProgrammableSink {\n        // Write only up to 5 bytes at a time\n        accept_prefix: Some(5),\n        ..Default::default()\n    };\n\n    let mut writer = LineWriter::with_capacity(10, writer);\n\n    let content = b\"AAAAABBBBB\\nCCCCDDDDDD\\nEEE\";\n\n    // When content is written, LineWriter will try to write blocks A, B,\n    // C, and D. Only block A will succeed. Under the old behavior, LineWriter\n    // would then try to buffer B, C and D, but because its capacity is 10,\n    // it will only be able to buffer B and C. We don't want to buffer\n    // partial lines concurrent with whole lines, so the correct behavior\n    // is to buffer only block B (out to the newline)\n    assert_eq!(writer.write(content).unwrap(), 11);\n    assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n\n    writer.flush().unwrap();\n    assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\\n\");\n}\n\n/// Same as test_partial_multiline_buffering, but in the event NO full lines\n/// fit in the buffer, just buffer as much as possible\n#[test]\nfn partial_multiline_buffering_without_full_line() {\n    let writer = ProgrammableSink {\n        // Write only up to 5 bytes at a time\n        accept_prefix: Some(5),\n        ..Default::default()\n    };\n\n    let mut writer = LineWriter::with_capacity(5, writer);\n\n    let content = b\"AAAAABBBBBBBBBB\\nCCCCC\\nDDDDD\";\n\n    // When content is written, LineWriter will try to write blocks A, B,\n    // and C. Only block A will succeed. Under the old behavior, LineWriter\n    // would then try to buffer B and C, but because its capacity is 5,\n    // it will only be able to buffer part of B. Because it's not possible\n    // for it to buffer any complete lines, it should buffer as much of B as\n    // possible\n    assert_eq!(writer.write(content).unwrap(), 10);\n    assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n\n    writer.flush().unwrap();\n    assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\");\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum RecordedEvent {\n    Write(String),\n    Flush,\n}\n\n#[derive(Debug, Clone, Default)]\nstruct WriteRecorder {\n    pub events: Vec<RecordedEvent>,\n}\n\nimpl Write for WriteRecorder {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        use crate::str::from_utf8;\n\n        self.events.push(RecordedEvent::Write(from_utf8(buf).unwrap().to_string()));\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.events.push(RecordedEvent::Flush);\n        Ok(())\n    }\n}\n\n/// Test that a normal, formatted writeln only results in a single write\n/// call to the underlying writer. A naive implementation of\n/// LineWriter::write_all results in two writes: one of the buffered data,\n/// and another of the final substring in the formatted set\n#[test]\nfn single_formatted_write() {\n    let writer = WriteRecorder::default();\n    let mut writer = LineWriter::new(writer);\n\n    // Under a naive implementation of LineWriter, this will result in two\n    // writes: \"hello, world\" and \"!\\n\", because write() has to flush the\n    // buffer before attempting to write the last \"!\\n\". write_all shouldn't\n    // have this limitation.\n    writeln!(&mut writer, \"{}, {}!\", \"hello\", \"world\").unwrap();\n    assert_eq!(writer.get_ref().events, [RecordedEvent::Write(\"hello, world!\\n\".to_string())]);\n}\n"],["2526","use crate::error;\nuse crate::fmt;\nuse crate::io::{\n    self, Error, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n};\nuse crate::mem;\nuse crate::ptr;\n\n/// Wraps a writer and buffers its output.\n///\n/// It can be excessively inefficient to work directly with something that\n/// implements [`Write`]. For example, every call to\n/// [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call. A\n/// `BufWriter<W>` keeps an in-memory buffer of data and writes it to an underlying\n/// writer in large, infrequent batches.\n///\n/// `BufWriter<W>` can improve the speed of programs that make *small* and\n/// *repeated* write calls to the same file or network socket. It does not\n/// help when writing very large amounts at once, or writing just one or a few\n/// times. It also provides no advantage when writing to a destination that is\n/// in memory, like a [`Vec`]`<u8>`.\n///\n/// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n/// dropping will attempt to flush the contents of the buffer, any errors\n/// that happen in the process of dropping will be ignored. Calling [`flush`]\n/// ensures that the buffer is empty and thus dropping will not even attempt\n/// file operations.\n///\n/// # Examples\n///\n/// Let's write the numbers one through ten to a [`TcpStream`]:\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::net::TcpStream;\n///\n/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n///\n/// for i in 0..10 {\n///     stream.write(&[i+1]).unwrap();\n/// }\n/// ```\n///\n/// Because we're not buffering, we write each one in turn, incurring the\n/// overhead of a system call per byte written. We can fix this with a\n/// `BufWriter<W>`:\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::BufWriter;\n/// use std::net::TcpStream;\n///\n/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n///\n/// for i in 0..10 {\n///     stream.write(&[i+1]).unwrap();\n/// }\n/// stream.flush().unwrap();\n/// ```\n///\n/// By wrapping the stream with a `BufWriter<W>`, these ten writes are all grouped\n/// together by the buffer and will all be written out in one system call when\n/// the `stream` is flushed.\n///\n// HACK(#78696): can't use `crate` for associated items\n/// [`TcpStream::write`]: super::super::super::net::TcpStream::write\n/// [`TcpStream`]: crate::net::TcpStream\n/// [`flush`]: BufWriter::flush\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BufWriter<W: Write> {\n    inner: Option<W>,\n    // The buffer. Avoid using this like a normal `Vec` in common code paths.\n    // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other\n    // methods that require bounds checking or the like. This makes an enormous\n    // difference to performance (we may want to stop using a `Vec` entirely).\n    buf: Vec<u8>,\n    // #30888: If the inner writer panics in a call to write, we don't want to\n    // write the buffered data a second time in BufWriter's destructor. This\n    // flag tells the Drop impl if it should skip the flush.\n    panicked: bool,\n}\n\nimpl<W: Write> BufWriter<W> {\n    /// Creates a new `BufWriter<W>` with a default buffer capacity. The default is currently 8 KB,\n    /// but may change in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: W) -> BufWriter<W> {\n        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n    }\n\n    /// Creates a new `BufWriter<W>` with the specified buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// Creating a buffer with a buffer of a hundred bytes.\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n    /// let mut buffer = BufWriter::with_capacity(100, stream);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {\n        BufWriter { inner: Some(inner), buf: Vec::with_capacity(capacity), panicked: false }\n    }\n\n    /// Send data in our local buffer into the inner writer, looping as\n    /// necessary until either it's all been sent or an error occurs.\n    ///\n    /// Because all the data in the buffer has been reported to our owner as\n    /// \"successfully written\" (by returning nonzero success values from\n    /// `write`), any 0-length writes from `inner` must be reported as i/o\n    /// errors from this method.\n    pub(in crate::io) fn flush_buf(&mut self) -> io::Result<()> {\n        /// Helper struct to ensure the buffer is updated after all the writes\n        /// are complete. It tracks the number of written bytes and drains them\n        /// all from the front of the buffer when dropped.\n        struct BufGuard<'a> {\n            buffer: &'a mut Vec<u8>,\n            written: usize,\n        }\n\n        impl<'a> BufGuard<'a> {\n            fn new(buffer: &'a mut Vec<u8>) -> Self {\n                Self { buffer, written: 0 }\n            }\n\n            /// The unwritten part of the buffer\n            fn remaining(&self) -> &[u8] {\n                &self.buffer[self.written..]\n            }\n\n            /// Flag some bytes as removed from the front of the buffer\n            fn consume(&mut self, amt: usize) {\n                self.written += amt;\n            }\n\n            /// true if all of the bytes have been written\n            fn done(&self) -> bool {\n                self.written >= self.buffer.len()\n            }\n        }\n\n        impl Drop for BufGuard<'_> {\n            fn drop(&mut self) {\n                if self.written > 0 {\n                    self.buffer.drain(..self.written);\n                }\n            }\n        }\n\n        let mut guard = BufGuard::new(&mut self.buf);\n        let inner = self.inner.as_mut().unwrap();\n        while !guard.done() {\n            self.panicked = true;\n            let r = inner.write(guard.remaining());\n            self.panicked = false;\n\n            match r {\n                Ok(0) => {\n                    return Err(Error::new_const(\n                        ErrorKind::WriteZero,\n                        &\"failed to write the buffered data\",\n                    ));\n                }\n                Ok(n) => guard.consume(n),\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Buffer some data without flushing it, regardless of the size of the\n    /// data. Writes as much as possible without exceeding capacity. Returns\n    /// the number of bytes written.\n    pub(super) fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n        let available = self.spare_capacity();\n        let amt_to_buffer = available.min(buf.len());\n\n        // SAFETY: `amt_to_buffer` is <= buffer's spare capacity by construction.\n        unsafe {\n            self.write_to_buffer_unchecked(&buf[..amt_to_buffer]);\n        }\n\n        amt_to_buffer\n    }\n\n    /// Gets a reference to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // we can use reference just like buffer\n    /// let reference = buffer.get_ref();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &W {\n        self.inner.as_ref().unwrap()\n    }\n\n    /// Gets a mutable reference to the underlying writer.\n    ///\n    /// It is inadvisable to directly write to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // we can use reference just like buffer\n    /// let reference = buffer.get_mut();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.as_mut().unwrap()\n    }\n\n    /// Returns a reference to the internally buffered data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // See how many bytes are currently buffered\n    /// let bytes_buffered = buf_writer.buffer().len();\n    /// ```\n    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n    pub fn buffer(&self) -> &[u8] {\n        &self.buf\n    }\n\n    /// Returns a mutable reference to the internal buffer.\n    ///\n    /// This can be used to write data directly into the buffer without triggering writers\n    /// to the underlying writer.\n    ///\n    /// That the buffer is a `Vec` is an implementation detail.\n    /// Callers should not modify the capacity as there currently is no public API to do so\n    /// and thus any capacity changes would be unexpected by the user.\n    pub(in crate::io) fn buffer_mut(&mut self) -> &mut Vec<u8> {\n        &mut self.buf\n    }\n\n    /// Returns the number of bytes the internal buffer can hold without flushing.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // Check the capacity of the inner buffer\n    /// let capacity = buf_writer.capacity();\n    /// // Calculate how many bytes can be written without flushing\n    /// let without_flush = capacity - buf_writer.buffer().len();\n    /// ```\n    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n    pub fn capacity(&self) -> usize {\n        self.buf.capacity()\n    }\n\n    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n    ///\n    /// The buffer is written out before returning the writer.\n    ///\n    /// # Errors\n    ///\n    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // unwrap the TcpStream and flush the buffer\n    /// let stream = buffer.into_inner().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n        match self.flush_buf() {\n            Err(e) => Err(IntoInnerError::new(self, e)),\n            Ok(()) => Ok(self.inner.take().unwrap()),\n        }\n    }\n\n    /// Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n    /// unwritten data.\n    ///\n    /// If the underlying writer panicked, it is not known what portion of the data was written.\n    /// In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n    /// contents can still be recovered).\n    ///\n    /// `into_raw_parts` makes no attempt to flush data and cannot fail.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(bufwriter_into_raw_parts)]\n    /// use std::io::{BufWriter, Write};\n    ///\n    /// let mut buffer = [0u8; 10];\n    /// let mut stream = BufWriter::new(buffer.as_mut());\n    /// write!(stream, \"too much data\").unwrap();\n    /// stream.flush().expect_err(\"it doesn't fit\");\n    /// let (recovered_writer, buffered_data) = stream.into_raw_parts();\n    /// assert_eq!(recovered_writer.len(), 0);\n    /// assert_eq!(&buffered_data.unwrap(), b\"ata\");\n    /// ```\n    #[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n    pub fn into_raw_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n        let buf = mem::take(&mut self.buf);\n        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n        (self.inner.take().unwrap(), buf)\n    }\n\n    // Ensure this function does not get inlined into `write`, so that it\n    // remains inlineable and its common path remains as short as possible.\n    // If this function ends up being called frequently relative to `write`,\n    // it's likely a sign that the client is using an improperly sized buffer\n    // or their write patterns are somewhat pathological.\n    #[cold]\n    #[inline(never)]\n    fn write_cold(&mut self, buf: &[u8]) -> io::Result<usize> {\n        if buf.len() > self.spare_capacity() {\n            self.flush_buf()?;\n        }\n\n        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n        if buf.len() >= self.buf.capacity() {\n            self.panicked = true;\n            let r = self.get_mut().write(buf);\n            self.panicked = false;\n            r\n        } else {\n            // Write to the buffer. In this case, we write to the buffer even if it fills it\n            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n            // input to the inner writer, which in many cases would be a worse strategy.\n\n            // SAFETY: There was either enough spare capacity already, or there wasn't and we\n            // flushed the buffer to ensure that there is. In the latter case, we know that there\n            // is because flushing ensured that our entire buffer is spare capacity, and we entered\n            // this block because the input buffer length is less than that capacity. In either\n            // case, it's safe to write the input buffer to our buffer.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(buf.len())\n        }\n    }\n\n    // Ensure this function does not get inlined into `write_all`, so that it\n    // remains inlineable and its common path remains as short as possible.\n    // If this function ends up being called frequently relative to `write_all`,\n    // it's likely a sign that the client is using an improperly sized buffer\n    // or their write patterns are somewhat pathological.\n    #[cold]\n    #[inline(never)]\n    fn write_all_cold(&mut self, buf: &[u8]) -> io::Result<()> {\n        // Normally, `write_all` just calls `write` in a loop. We can do better\n        // by calling `self.get_mut().write_all()` directly, which avoids\n        // round trips through the buffer in the event of a series of partial\n        // writes in some circumstances.\n\n        if buf.len() > self.spare_capacity() {\n            self.flush_buf()?;\n        }\n\n        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n        if buf.len() >= self.buf.capacity() {\n            self.panicked = true;\n            let r = self.get_mut().write_all(buf);\n            self.panicked = false;\n            r\n        } else {\n            // Write to the buffer. In this case, we write to the buffer even if it fills it\n            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n            // input to the inner writer, which in many cases would be a worse strategy.\n\n            // SAFETY: There was either enough spare capacity already, or there wasn't and we\n            // flushed the buffer to ensure that there is. In the latter case, we know that there\n            // is because flushing ensured that our entire buffer is spare capacity, and we entered\n            // this block because the input buffer length is less than that capacity. In either\n            // case, it's safe to write the input buffer to our buffer.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(())\n        }\n    }\n\n    // SAFETY: Requires `buf.len() <= self.buf.capacity() - self.buf.len()`,\n    // i.e., that input buffer length is less than or equal to spare capacity.\n    #[inline]\n    unsafe fn write_to_buffer_unchecked(&mut self, buf: &[u8]) {\n        debug_assert!(buf.len() <= self.spare_capacity());\n        let old_len = self.buf.len();\n        let buf_len = buf.len();\n        let src = buf.as_ptr();\n        let dst = self.buf.as_mut_ptr().add(old_len);\n        ptr::copy_nonoverlapping(src, dst, buf_len);\n        self.buf.set_len(old_len + buf_len);\n    }\n\n    #[inline]\n    fn spare_capacity(&self) -> usize {\n        self.buf.capacity() - self.buf.len()\n    }\n}\n\n#[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n/// Error returned for the buffered data from `BufWriter::into_raw_parts`, when the underlying\n/// writer has previously panicked.  Contains the (possibly partly written) buffered data.\n///\n/// # Example\n///\n/// ```\n/// #![feature(bufwriter_into_raw_parts)]\n/// use std::io::{self, BufWriter, Write};\n/// use std::panic::{catch_unwind, AssertUnwindSafe};\n///\n/// struct PanickingWriter;\n/// impl Write for PanickingWriter {\n///   fn write(&mut self, buf: &[u8]) -> io::Result<usize> { panic!() }\n///   fn flush(&mut self) -> io::Result<()> { panic!() }\n/// }\n///\n/// let mut stream = BufWriter::new(PanickingWriter);\n/// write!(stream, \"some data\").unwrap();\n/// let result = catch_unwind(AssertUnwindSafe(|| {\n///     stream.flush().unwrap()\n/// }));\n/// assert!(result.is_err());\n/// let (recovered_writer, buffered_data) = stream.into_raw_parts();\n/// assert!(matches!(recovered_writer, PanickingWriter));\n/// assert_eq!(buffered_data.unwrap_err().into_inner(), b\"some data\");\n/// ```\npub struct WriterPanicked {\n    buf: Vec<u8>,\n}\n\nimpl WriterPanicked {\n    /// Returns the perhaps-unwritten data.  Some of this data may have been written by the\n    /// panicking call(s) to the underlying writer, so simply writing it again is not a good idea.\n    #[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n    pub fn into_inner(self) -> Vec<u8> {\n        self.buf\n    }\n\n    const DESCRIPTION: &'static str =\n        \"BufWriter inner writer panicked, what data remains unwritten is not known\";\n}\n\n#[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\nimpl error::Error for WriterPanicked {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        Self::DESCRIPTION\n    }\n}\n\n#[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\nimpl fmt::Display for WriterPanicked {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", Self::DESCRIPTION)\n    }\n}\n\n#[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\nimpl fmt::Debug for WriterPanicked {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"WriterPanicked\")\n            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Write for BufWriter<W> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n        // See `write_cold` for details.\n        if buf.len() < self.spare_capacity() {\n            // SAFETY: safe by above conditional.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(buf.len())\n        } else {\n            self.write_cold(buf)\n        }\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n        // See `write_all_cold` for details.\n        if buf.len() < self.spare_capacity() {\n            // SAFETY: safe by above conditional.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(())\n        } else {\n            self.write_all_cold(buf)\n        }\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        // FIXME: Consider applying `#[inline]` / `#[inline(never)]` optimizations already applied\n        // to `write` and `write_all`. The performance benefits can be significant. See #79930.\n        if self.get_ref().is_write_vectored() {\n            // We have to handle the possibility that the total length of the buffers overflows\n            // `usize` (even though this can only happen if multiple `IoSlice`s reference the\n            // same underlying buffer, as otherwise the buffers wouldn't fit in memory). If the\n            // computation overflows, then surely the input cannot fit in our buffer, so we forward\n            // to the inner writer's `write_vectored` method to let it handle it appropriately.\n            let saturated_total_len =\n                bufs.iter().fold(0usize, |acc, b| acc.saturating_add(b.len()));\n\n            if saturated_total_len > self.spare_capacity() {\n                // Flush if the total length of the input exceeds our buffer's spare capacity.\n                // If we would have overflowed, this condition also holds, and we need to flush.\n                self.flush_buf()?;\n            }\n\n            if saturated_total_len >= self.buf.capacity() {\n                // Forward to our inner writer if the total length of the input is greater than or\n                // equal to our buffer capacity. If we would have overflowed, this condition also\n                // holds, and we punt to the inner writer.\n                self.panicked = true;\n                let r = self.get_mut().write_vectored(bufs);\n                self.panicked = false;\n                r\n            } else {\n                // `saturated_total_len < self.buf.capacity()` implies that we did not saturate.\n\n                // SAFETY: We checked whether or not the spare capacity was large enough above. If\n                // it was, then we're safe already. If it wasn't, we flushed, making sufficient\n                // room for any input <= the buffer size, which includes this input.\n                unsafe {\n                    bufs.iter().for_each(|b| self.write_to_buffer_unchecked(b));\n                };\n\n                Ok(saturated_total_len)\n            }\n        } else {\n            let mut iter = bufs.iter();\n            let mut total_written = if let Some(buf) = iter.by_ref().find(|&buf| !buf.is_empty()) {\n                // This is the first non-empty slice to write, so if it does\n                // not fit in the buffer, we still get to flush and proceed.\n                if buf.len() > self.spare_capacity() {\n                    self.flush_buf()?;\n                }\n                if buf.len() >= self.buf.capacity() {\n                    // The slice is at least as large as the buffering capacity,\n                    // so it's better to write it directly, bypassing the buffer.\n                    self.panicked = true;\n                    let r = self.get_mut().write(buf);\n                    self.panicked = false;\n                    return r;\n                } else {\n                    // SAFETY: We checked whether or not the spare capacity was large enough above.\n                    // If it was, then we're safe already. If it wasn't, we flushed, making\n                    // sufficient room for any input <= the buffer size, which includes this input.\n                    unsafe {\n                        self.write_to_buffer_unchecked(buf);\n                    }\n\n                    buf.len()\n                }\n            } else {\n                return Ok(0);\n            };\n            debug_assert!(total_written != 0);\n            for buf in iter {\n                if buf.len() <= self.spare_capacity() {\n                    // SAFETY: safe by above conditional.\n                    unsafe {\n                        self.write_to_buffer_unchecked(buf);\n                    }\n\n                    // This cannot overflow `usize`. If we are here, we've written all of the bytes\n                    // so far to our buffer, and we've ensured that we never exceed the buffer's\n                    // capacity. Therefore, `total_written` <= `self.buf.capacity()` <= `usize::MAX`.\n                    total_written += buf.len();\n                } else {\n                    break;\n                }\n            }\n            Ok(total_written)\n        }\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.flush_buf().and_then(|()| self.get_mut().flush())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> fmt::Debug for BufWriter<W>\nwhere\n    W: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"BufWriter\")\n            .field(\"writer\", &self.inner.as_ref().unwrap())\n            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + Seek> Seek for BufWriter<W> {\n    /// Seek to the offset, in bytes, in the underlying writer.\n    ///\n    /// Seeking always writes out the internal buffer before seeking.\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        self.flush_buf()?;\n        self.get_mut().seek(pos)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Drop for BufWriter<W> {\n    fn drop(&mut self) {\n        if self.inner.is_some() && !self.panicked {\n            // dtors should not panic, so we ignore a failed flush\n            let _r = self.flush_buf();\n        }\n    }\n}\n"],["2527","use crate::io::{self, BufWriter, IoSlice, Write};\nuse crate::sys_common::memchr;\n\n/// Private helper struct for implementing the line-buffered writing logic.\n/// This shim temporarily wraps a BufWriter, and uses its internals to\n/// implement a line-buffered writer (specifically by using the internal\n/// methods like write_to_buf and flush_buf). In this way, a more\n/// efficient abstraction can be created than one that only had access to\n/// `write` and `flush`, without needlessly duplicating a lot of the\n/// implementation details of BufWriter. This also allows existing\n/// `BufWriters` to be temporarily given line-buffering logic; this is what\n/// enables Stdout to be alternately in line-buffered or block-buffered mode.\n#[derive(Debug)]\npub struct LineWriterShim<'a, W: Write> {\n    buffer: &'a mut BufWriter<W>,\n}\n\nimpl<'a, W: Write> LineWriterShim<'a, W> {\n    pub fn new(buffer: &'a mut BufWriter<W>) -> Self {\n        Self { buffer }\n    }\n\n    /// Get a reference to the inner writer (that is, the writer\n    /// wrapped by the BufWriter).\n    fn inner(&self) -> &W {\n        self.buffer.get_ref()\n    }\n\n    /// Get a mutable reference to the inner writer (that is, the writer\n    /// wrapped by the BufWriter). Be careful with this writer, as writes to\n    /// it will bypass the buffer.\n    fn inner_mut(&mut self) -> &mut W {\n        self.buffer.get_mut()\n    }\n\n    /// Get the content currently buffered in self.buffer\n    fn buffered(&self) -> &[u8] {\n        self.buffer.buffer()\n    }\n\n    /// Flush the buffer iff the last byte is a newline (indicating that an\n    /// earlier write only succeeded partially, and we want to retry flushing\n    /// the buffered line before continuing with a subsequent write)\n    fn flush_if_completed_line(&mut self) -> io::Result<()> {\n        match self.buffered().last().copied() {\n            Some(b'\\n') => self.buffer.flush_buf(),\n            _ => Ok(()),\n        }\n    }\n}\n\nimpl<'a, W: Write> Write for LineWriterShim<'a, W> {\n    /// Write some data into this BufReader with line buffering. This means\n    /// that, if any newlines are present in the data, the data up to the last\n    /// newline is sent directly to the underlying writer, and data after it\n    /// is buffered. Returns the number of bytes written.\n    ///\n    /// This function operates on a \"best effort basis\"; in keeping with the\n    /// convention of `Write::write`, it makes at most one attempt to write\n    /// new data to the underlying writer. If that write only reports a partial\n    /// success, the remaining data will be buffered.\n    ///\n    /// Because this function attempts to send completed lines to the underlying\n    /// writer, it will also flush the existing buffer if it ends with a\n    /// newline, even if the incoming data does not contain any newlines.\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n            // If there are no new newlines (that is, if this write is less than\n            // one line), just do a regular buffered write (which may flush if\n            // we exceed the inner buffer's size)\n            None => {\n                self.flush_if_completed_line()?;\n                return self.buffer.write(buf);\n            }\n            // Otherwise, arrange for the lines to be written directly to the\n            // inner writer.\n            Some(newline_idx) => newline_idx + 1,\n        };\n\n        // Flush existing content to prepare for our write. We have to do this\n        // before attempting to write `buf` in order to maintain consistency;\n        // if we add `buf` to the buffer then try to flush it all at once,\n        // we're obligated to return Ok(), which would mean suppressing any\n        // errors that occur during flush.\n        self.buffer.flush_buf()?;\n\n        // This is what we're going to try to write directly to the inner\n        // writer. The rest will be buffered, if nothing goes wrong.\n        let lines = &buf[..newline_idx];\n\n        // Write `lines` directly to the inner writer. In keeping with the\n        // `write` convention, make at most one attempt to add new (unbuffered)\n        // data. Because this write doesn't touch the BufWriter state directly,\n        // and the buffer is known to be empty, we don't need to worry about\n        // self.buffer.panicked here.\n        let flushed = self.inner_mut().write(lines)?;\n\n        // If buffer returns Ok(0), propagate that to the caller without\n        // doing additional buffering; otherwise we're just guaranteeing\n        // an \"ErrorKind::WriteZero\" later.\n        if flushed == 0 {\n            return Ok(0);\n        }\n\n        // Now that the write has succeeded, buffer the rest (or as much of\n        // the rest as possible). If there were any unwritten newlines, we\n        // only buffer out to the last unwritten newline that fits in the\n        // buffer; this helps prevent flushing partial lines on subsequent\n        // calls to LineWriterShim::write.\n\n        // Handle the cases in order of most-common to least-common, under\n        // the presumption that most writes succeed in totality, and that most\n        // writes are smaller than the buffer.\n        // - Is this a partial line (ie, no newlines left in the unwritten tail)\n        // - If not, does the data out to the last unwritten newline fit in\n        //   the buffer?\n        // - If not, scan for the last newline that *does* fit in the buffer\n        let tail = if flushed >= newline_idx {\n            &buf[flushed..]\n        } else if newline_idx - flushed <= self.buffer.capacity() {\n            &buf[flushed..newline_idx]\n        } else {\n            let scan_area = &buf[flushed..];\n            let scan_area = &scan_area[..self.buffer.capacity()];\n            match memchr::memrchr(b'\\n', scan_area) {\n                Some(newline_idx) => &scan_area[..newline_idx + 1],\n                None => scan_area,\n            }\n        };\n\n        let buffered = self.buffer.write_to_buf(tail);\n        Ok(flushed + buffered)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.buffer.flush()\n    }\n\n    /// Write some vectored data into this BufReader with line buffering. This\n    /// means that, if any newlines are present in the data, the data up to\n    /// and including the buffer containing the last newline is sent directly\n    /// to the inner writer, and the data after it is buffered. Returns the\n    /// number of bytes written.\n    ///\n    /// This function operates on a \"best effort basis\"; in keeping with the\n    /// convention of `Write::write`, it makes at most one attempt to write\n    /// new data to the underlying writer.\n    ///\n    /// Because this function attempts to send completed lines to the underlying\n    /// writer, it will also flush the existing buffer if it contains any\n    /// newlines.\n    ///\n    /// Because sorting through an array of `IoSlice` can be a bit convoluted,\n    /// This method differs from write in the following ways:\n    ///\n    /// - It attempts to write the full content of all the buffers up to and\n    ///   including the one containing the last newline. This means that it\n    ///   may attempt to write a partial line, that buffer has data past the\n    ///   newline.\n    /// - If the write only reports partial success, it does not attempt to\n    ///   find the precise location of the written bytes and buffer the rest.\n    ///\n    /// If the underlying vector doesn't support vectored writing, we instead\n    /// simply write the first non-empty buffer with `write`. This way, we\n    /// get the benefits of more granular partial-line handling without losing\n    /// anything in efficiency\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        // If there's no specialized behavior for write_vectored, just use\n        // write. This has the benefit of more granular partial-line handling.\n        if !self.is_write_vectored() {\n            return match bufs.iter().find(|buf| !buf.is_empty()) {\n                Some(buf) => self.write(buf),\n                None => Ok(0),\n            };\n        }\n\n        // Find the buffer containing the last newline\n        let last_newline_buf_idx = bufs\n            .iter()\n            .enumerate()\n            .rev()\n            .find_map(|(i, buf)| memchr::memchr(b'\\n', buf).map(|_| i));\n\n        // If there are no new newlines (that is, if this write is less than\n        // one line), just do a regular buffered write\n        let last_newline_buf_idx = match last_newline_buf_idx {\n            // No newlines; just do a normal buffered write\n            None => {\n                self.flush_if_completed_line()?;\n                return self.buffer.write_vectored(bufs);\n            }\n            Some(i) => i,\n        };\n\n        // Flush existing content to prepare for our write\n        self.buffer.flush_buf()?;\n\n        // This is what we're going to try to write directly to the inner\n        // writer. The rest will be buffered, if nothing goes wrong.\n        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);\n\n        // Write `lines` directly to the inner writer. In keeping with the\n        // `write` convention, make at most one attempt to add new (unbuffered)\n        // data. Because this write doesn't touch the BufWriter state directly,\n        // and the buffer is known to be empty, we don't need to worry about\n        // self.panicked here.\n        let flushed = self.inner_mut().write_vectored(lines)?;\n\n        // If inner returns Ok(0), propagate that to the caller without\n        // doing additional buffering; otherwise we're just guaranteeing\n        // an \"ErrorKind::WriteZero\" later.\n        if flushed == 0 {\n            return Ok(0);\n        }\n\n        // Don't try to reconstruct the exact amount written; just bail\n        // in the event of a partial write\n        let lines_len = lines.iter().map(|buf| buf.len()).sum();\n        if flushed < lines_len {\n            return Ok(flushed);\n        }\n\n        // Now that the write has succeeded, buffer the rest (or as much of the\n        // rest as possible)\n        let buffered: usize = tail\n            .iter()\n            .filter(|buf| !buf.is_empty())\n            .map(|buf| self.buffer.write_to_buf(buf))\n            .take_while(|&n| n > 0)\n            .sum();\n\n        Ok(flushed + buffered)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        self.inner().is_write_vectored()\n    }\n\n    /// Write some data into this BufReader with line buffering. This means\n    /// that, if any newlines are present in the data, the data up to the last\n    /// newline is sent directly to the underlying writer, and data after it\n    /// is buffered.\n    ///\n    /// Because this function attempts to send completed lines to the underlying\n    /// writer, it will also flush the existing buffer if it contains any\n    /// newlines, even if the incoming data does not contain any newlines.\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        match memchr::memrchr(b'\\n', buf) {\n            // If there are no new newlines (that is, if this write is less than\n            // one line), just do a regular buffered write (which may flush if\n            // we exceed the inner buffer's size)\n            None => {\n                self.flush_if_completed_line()?;\n                self.buffer.write_all(buf)\n            }\n            Some(newline_idx) => {\n                let (lines, tail) = buf.split_at(newline_idx + 1);\n\n                if self.buffered().is_empty() {\n                    self.inner_mut().write_all(lines)?;\n                } else {\n                    // If there is any buffered data, we add the incoming lines\n                    // to that buffer before flushing, which saves us at least\n                    // one write call. We can't really do this with `write`,\n                    // since we can't do this *and* not suppress errors *and*\n                    // report a consistent state to the caller in a return\n                    // value, but here in write_all it's fine.\n                    self.buffer.write_all(lines)?;\n                    self.buffer.flush_buf()?;\n                }\n\n                self.buffer.write_all(tail)\n            }\n        }\n    }\n}\n"],["2528","use crate::cmp;\nuse crate::fmt;\nuse crate::io::{\n    self, BufRead, Initializer, IoSliceMut, Read, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n};\n\n/// The `BufReader<R>` struct adds buffering to any reader.\n///\n/// It can be excessively inefficient to work directly with a [`Read`] instance.\n/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n/// results in a system call. A `BufReader<R>` performs large, infrequent reads on\n/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n///\n/// `BufReader<R>` can improve the speed of programs that make *small* and\n/// *repeated* read calls to the same file or network socket. It does not\n/// help when reading very large amounts at once, or reading just one or a few\n/// times. It also provides no advantage when reading from a source that is\n/// already in memory, like a [`Vec`]`<u8>`.\n///\n/// When the `BufReader<R>` is dropped, the contents of its buffer will be\n/// discarded. Creating multiple instances of a `BufReader<R>` on the same\n/// stream can cause data loss. Reading from the underlying reader after\n/// unwrapping the `BufReader<R>` with [`BufReader::into_inner`] can also cause\n/// data loss.\n///\n// HACK(#78696): can't use `crate` for associated items\n/// [`TcpStream::read`]: super::super::super::net::TcpStream::read\n/// [`TcpStream`]: crate::net::TcpStream\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::BufReader;\n/// use std::fs::File;\n///\n/// fn main() -> std::io::Result<()> {\n///     let f = File::open(\"log.txt\")?;\n///     let mut reader = BufReader::new(f);\n///\n///     let mut line = String::new();\n///     let len = reader.read_line(&mut line)?;\n///     println!(\"First line is {} bytes long\", len);\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BufReader<R> {\n    inner: R,\n    buf: Box<[u8]>,\n    pos: usize,\n    cap: usize,\n}\n\nimpl<R: Read> BufReader<R> {\n    /// Creates a new `BufReader<R>` with a default buffer capacity. The default is currently 8 KB,\n    /// but may change in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::new(f);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: R) -> BufReader<R> {\n        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n    }\n\n    /// Creates a new `BufReader<R>` with the specified buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// Creating a buffer with ten bytes of capacity:\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::with_capacity(10, f);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n        unsafe {\n            let mut buf = Box::new_uninit_slice(capacity).assume_init();\n            inner.initializer().initialize(&mut buf);\n            BufReader { inner, buf, pos: 0, cap: 0 }\n        }\n    }\n}\n\nimpl<R> BufReader<R> {\n    /// Gets a reference to the underlying reader.\n    ///\n    /// It is inadvisable to directly read from the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f1 = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::new(f1);\n    ///\n    ///     let f2 = reader.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &R {\n        &self.inner\n    }\n\n    /// Gets a mutable reference to the underlying reader.\n    ///\n    /// It is inadvisable to directly read from the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f1 = File::open(\"log.txt\")?;\n    ///     let mut reader = BufReader::new(f1);\n    ///\n    ///     let f2 = reader.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut R {\n        &mut self.inner\n    }\n\n    /// Returns a reference to the internally buffered data.\n    ///\n    /// Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.\n    ///\n    /// [`fill_buf`]: BufRead::fill_buf\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{BufReader, BufRead};\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let mut reader = BufReader::new(f);\n    ///     assert!(reader.buffer().is_empty());\n    ///\n    ///     if reader.fill_buf()?.len() > 0 {\n    ///         assert!(!reader.buffer().is_empty());\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n    pub fn buffer(&self) -> &[u8] {\n        &self.buf[self.pos..self.cap]\n    }\n\n    /// Returns the number of bytes the internal buffer can hold at once.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{BufReader, BufRead};\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let mut reader = BufReader::new(f);\n    ///\n    ///     let capacity = reader.capacity();\n    ///     let buffer = reader.fill_buf()?;\n    ///     assert!(buffer.len() <= capacity);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n    pub fn capacity(&self) -> usize {\n        self.buf.len()\n    }\n\n    /// Unwraps this `BufReader<R>`, returning the underlying reader.\n    ///\n    /// Note that any leftover data in the internal buffer is lost. Therefore,\n    /// a following read from the underlying reader may lead to data loss.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f1 = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::new(f1);\n    ///\n    ///     let f2 = reader.into_inner();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> R {\n        self.inner\n    }\n\n    /// Invalidates all data in the internal buffer.\n    #[inline]\n    fn discard_buffer(&mut self) {\n        self.pos = 0;\n        self.cap = 0;\n    }\n}\n\nimpl<R: Seek> BufReader<R> {\n    /// Seeks relative to the current position. If the new position lies within the buffer,\n    /// the buffer will not be flushed, allowing for more efficient seeks.\n    /// This method does not return the location of the underlying reader, so the caller\n    /// must track this information themselves if it is required.\n    #[stable(feature = \"bufreader_seek_relative\", since = \"1.53.0\")]\n    pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n        let pos = self.pos as u64;\n        if offset < 0 {\n            if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n                self.pos = new_pos as usize;\n                return Ok(());\n            }\n        } else {\n            if let Some(new_pos) = pos.checked_add(offset as u64) {\n                if new_pos <= self.cap as u64 {\n                    self.pos = new_pos as usize;\n                    return Ok(());\n                }\n            }\n        }\n        self.seek(SeekFrom::Current(offset)).map(drop)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> Read for BufReader<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            self.discard_buffer();\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }\n\n    // Small read_exacts from a BufReader are extremely common when used with a deserializer.\n    // The default implementation calls read in a loop, which results in surprisingly poor code\n    // generation for the common path where the buffer has enough bytes to fill the passed-in\n    // buffer.\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        if self.buffer().len() >= buf.len() {\n            buf.copy_from_slice(&self.buffer()[..buf.len()]);\n            self.consume(buf.len());\n            return Ok(());\n        }\n\n        crate::io::default_read_exact(self, buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n        if self.pos == self.cap && total_len >= self.buf.len() {\n            self.discard_buffer();\n            return self.inner.read_vectored(bufs);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read_vectored(bufs)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }\n\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    // we can't skip unconditionally because of the large buffer case in read.\n    unsafe fn initializer(&self) -> Initializer {\n        self.inner.initializer()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> BufRead for BufReader<R> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        // If we've reached the end of our internal buffer then we need to fetch\n        // some more data from the underlying reader.\n        // Branch using `>=` instead of the more correct `==`\n        // to tell the compiler that the pos..cap slice is always valid.\n        if self.pos >= self.cap {\n            debug_assert!(self.pos == self.cap);\n            self.cap = self.inner.read(&mut self.buf)?;\n            self.pos = 0;\n        }\n        Ok(&self.buf[self.pos..self.cap])\n    }\n\n    fn consume(&mut self, amt: usize) {\n        self.pos = cmp::min(self.pos + amt, self.cap);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R> fmt::Debug for BufReader<R>\nwhere\n    R: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"BufReader\")\n            .field(\"reader\", &self.inner)\n            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Seek> Seek for BufReader<R> {\n    /// Seek to an offset, in bytes, in the underlying reader.\n    ///\n    /// The position used for seeking with [`SeekFrom::Current`]`(_)` is the\n    /// position the underlying reader would be at if the `BufReader<R>` had no\n    /// internal buffer.\n    ///\n    /// Seeking always discards the internal buffer, even if the seek position\n    /// would otherwise fall within it. This guarantees that calling\n    /// [`BufReader::into_inner()`] immediately after a seek yields the underlying reader\n    /// at the same position.\n    ///\n    /// To seek without discarding the internal buffer, use [`BufReader::seek_relative`].\n    ///\n    /// See [`std::io::Seek`] for more details.\n    ///\n    /// Note: In the edge case where you're seeking with [`SeekFrom::Current`]`(n)`\n    /// where `n` minus the internal buffer length overflows an `i64`, two\n    /// seeks will be performed instead of one. If the second seek returns\n    /// [`Err`], the underlying reader will be left at the same position it would\n    /// have if you called `seek` with [`SeekFrom::Current`]`(0)`.\n    ///\n    /// [`std::io::Seek`]: Seek\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        let result: u64;\n        if let SeekFrom::Current(n) = pos {\n            let remainder = (self.cap - self.pos) as i64;\n            // it should be safe to assume that remainder fits within an i64 as the alternative\n            // means we managed to allocate 8 exbibytes and that's absurd.\n            // But it's not out of the realm of possibility for some weird underlying reader to\n            // support seeking by i64::MIN so we need to handle underflow when subtracting\n            // remainder.\n            if let Some(offset) = n.checked_sub(remainder) {\n                result = self.inner.seek(SeekFrom::Current(offset))?;\n            } else {\n                // seek backwards by our remainder, and then by the offset\n                self.inner.seek(SeekFrom::Current(-remainder))?;\n                self.discard_buffer();\n                result = self.inner.seek(SeekFrom::Current(n))?;\n            }\n        } else {\n            // Seeking with Start/End doesn't care about our buffer length.\n            result = self.inner.seek(pos)?;\n        }\n        self.discard_buffer();\n        Ok(result)\n    }\n\n    /// Returns the current seek position from the start of the stream.\n    ///\n    /// The value returned is equivalent to `self.seek(SeekFrom::Current(0))`\n    /// but does not flush the internal buffer. Due to this optimization the\n    /// function does not guarantee that calling `.into_inner()` immediately\n    /// afterwards will yield the underlying reader at the same position. Use\n    /// [`BufReader::seek`] instead if you require that guarantee.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the position of the inner reader is smaller\n    /// than the amount of buffered data. That can happen if the inner reader\n    /// has an incorrect implementation of [`Seek::stream_position`], or if the\n    /// position has gone out of sync due to calling [`Seek::seek`] directly on\n    /// the underlying reader.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use std::{\n    ///     io::{self, BufRead, BufReader, Seek},\n    ///     fs::File,\n    /// };\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n    ///\n    ///     let before = f.stream_position()?;\n    ///     f.read_line(&mut String::new())?;\n    ///     let after = f.stream_position()?;\n    ///\n    ///     println!(\"The first line was {} bytes long\", after - before);\n    ///     Ok(())\n    /// }\n    /// ```\n    fn stream_position(&mut self) -> io::Result<u64> {\n        let remainder = (self.cap - self.pos) as u64;\n        self.inner.stream_position().map(|pos| {\n            pos.checked_sub(remainder).expect(\n                \"overflow when subtracting remaining buffer size from inner stream position\",\n            )\n        })\n    }\n}\n\nimpl<T> SizeHint for BufReader<T> {\n    #[inline]\n    fn lower_bound(&self) -> usize {\n        SizeHint::lower_bound(self.get_ref()) + self.buffer().len()\n    }\n\n    #[inline]\n    fn upper_bound(&self) -> Option<usize> {\n        SizeHint::upper_bound(self.get_ref()).and_then(|up| self.buffer().len().checked_add(up))\n    }\n}\n"],["2529","use crate::fmt;\nuse crate::io::{self, buffered::LineWriterShim, BufWriter, IntoInnerError, IoSlice, Write};\n\n/// Wraps a writer and buffers output to it, flushing whenever a newline\n/// (`0x0a`, `'\\n'`) is detected.\n///\n/// The [`BufWriter`] struct wraps a writer and buffers its output.\n/// But it only does this batched write when it goes out of scope, or when the\n/// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n/// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n/// does exactly that.\n///\n/// Like [`BufWriter`], a `LineWriter`’s buffer will also be flushed when the\n/// `LineWriter` goes out of scope or when its internal buffer is full.\n///\n/// If there's still a partial line in the buffer when the `LineWriter` is\n/// dropped, it will flush those contents.\n///\n/// # Examples\n///\n/// We can use `LineWriter` to write one line at a time, significantly\n/// reducing the number of actual writes to the file.\n///\n/// ```no_run\n/// use std::fs::{self, File};\n/// use std::io::prelude::*;\n/// use std::io::LineWriter;\n///\n/// fn main() -> std::io::Result<()> {\n///     let road_not_taken = b\"I shall be telling this with a sigh\n/// Somewhere ages and ages hence:\n/// Two roads diverged in a wood, and I -\n/// I took the one less traveled by,\n/// And that has made all the difference.\";\n///\n///     let file = File::create(\"poem.txt\")?;\n///     let mut file = LineWriter::new(file);\n///\n///     file.write_all(b\"I shall be telling this with a sigh\")?;\n///\n///     // No bytes are written until a newline is encountered (or\n///     // the internal buffer is filled).\n///     assert_eq!(fs::read_to_string(\"poem.txt\")?, \"\");\n///     file.write_all(b\"\\n\")?;\n///     assert_eq!(\n///         fs::read_to_string(\"poem.txt\")?,\n///         \"I shall be telling this with a sigh\\n\",\n///     );\n///\n///     // Write the rest of the poem.\n///     file.write_all(b\"Somewhere ages and ages hence:\n/// Two roads diverged in a wood, and I -\n/// I took the one less traveled by,\n/// And that has made all the difference.\")?;\n///\n///     // The last line of the poem doesn't end in a newline, so\n///     // we have to flush or drop the `LineWriter` to finish\n///     // writing.\n///     file.flush()?;\n///\n///     // Confirm the whole poem was written.\n///     assert_eq!(fs::read(\"poem.txt\")?, &road_not_taken[..]);\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LineWriter<W: Write> {\n    inner: BufWriter<W>,\n}\n\nimpl<W: Write> LineWriter<W> {\n    /// Creates a new `LineWriter`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let file = LineWriter::new(file);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: W) -> LineWriter<W> {\n        // Lines typically aren't that long, don't use a giant buffer\n        LineWriter::with_capacity(1024, inner)\n    }\n\n    /// Creates a new `LineWriter` with a specified capacity for the internal\n    /// buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let file = LineWriter::with_capacity(100, file);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n        LineWriter { inner: BufWriter::with_capacity(capacity, inner) }\n    }\n\n    /// Gets a reference to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let file = LineWriter::new(file);\n    ///\n    ///     let reference = file.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &W {\n        self.inner.get_ref()\n    }\n\n    /// Gets a mutable reference to the underlying writer.\n    ///\n    /// Caution must be taken when calling methods on the mutable reference\n    /// returned as extra writes could corrupt the output stream.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let mut file = LineWriter::new(file);\n    ///\n    ///     // we can use reference just like file\n    ///     let reference = file.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.get_mut()\n    }\n\n    /// Unwraps this `LineWriter`, returning the underlying writer.\n    ///\n    /// The internal buffer is written out before returning the writer.\n    ///\n    /// # Errors\n    ///\n    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///\n    ///     let writer: LineWriter<File> = LineWriter::new(file);\n    ///\n    ///     let file: File = writer.into_inner()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n        self.inner.into_inner().map_err(|err| err.new_wrapped(|inner| LineWriter { inner }))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Write for LineWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        LineWriterShim::new(&mut self.inner).write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        LineWriterShim::new(&mut self.inner).write_vectored(bufs)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        self.inner.is_write_vectored()\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_all(buf)\n    }\n\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_all_vectored(bufs)\n    }\n\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_fmt(fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> fmt::Debug for LineWriter<W>\nwhere\n    W: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"LineWriter\")\n            .field(\"writer\", &self.get_ref())\n            .field(\n                \"buffer\",\n                &format_args!(\"{}/{}\", self.inner.buffer().len(), self.inner.capacity()),\n            )\n            .finish_non_exhaustive()\n    }\n}\n"],["2530","//! Buffering wrappers for I/O traits\n\nmod bufreader;\nmod bufwriter;\nmod linewriter;\nmod linewritershim;\n\n#[cfg(test)]\nmod tests;\n\nuse crate::error;\nuse crate::fmt;\nuse crate::io::Error;\n\npub use bufreader::BufReader;\npub use bufwriter::BufWriter;\npub use linewriter::LineWriter;\nuse linewritershim::LineWriterShim;\n\n/// An error returned by [`BufWriter::into_inner`] which combines an error that\n/// happened while writing out the buffer, and the buffered writer object\n/// which may be used to recover from the condition.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::BufWriter;\n/// use std::net::TcpStream;\n///\n/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n///\n/// // do stuff with the stream\n///\n/// // we want to get our `TcpStream` back, so let's try:\n///\n/// let stream = match stream.into_inner() {\n///     Ok(s) => s,\n///     Err(e) => {\n///         // Here, e is an IntoInnerError\n///         panic!(\"An error occurred\");\n///     }\n/// };\n/// ```\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoInnerError<W>(W, Error);\n\nimpl<W> IntoInnerError<W> {\n    /// Construct a new IntoInnerError\n    fn new(writer: W, error: Error) -> Self {\n        Self(writer, error)\n    }\n\n    /// Helper to construct a new IntoInnerError; intended to help with\n    /// adapters that wrap other adapters\n    fn new_wrapped<W2>(self, f: impl FnOnce(W) -> W2) -> IntoInnerError<W2> {\n        let Self(writer, error) = self;\n        IntoInnerError::new(f(writer), error)\n    }\n\n    /// Returns the error which caused the call to [`BufWriter::into_inner()`]\n    /// to fail.\n    ///\n    /// This error was returned when attempting to write the internal buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // do stuff with the stream\n    ///\n    /// // we want to get our `TcpStream` back, so let's try:\n    ///\n    /// let stream = match stream.into_inner() {\n    ///     Ok(s) => s,\n    ///     Err(e) => {\n    ///         // Here, e is an IntoInnerError, let's log the inner error.\n    ///         //\n    ///         // We'll just 'log' to stdout for this example.\n    ///         println!(\"{}\", e.error());\n    ///\n    ///         panic!(\"An unexpected error occurred.\");\n    ///     }\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn error(&self) -> &Error {\n        &self.1\n    }\n\n    /// Returns the buffered writer instance which generated the error.\n    ///\n    /// The returned object can be used for error recovery, such as\n    /// re-inspecting the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // do stuff with the stream\n    ///\n    /// // we want to get our `TcpStream` back, so let's try:\n    ///\n    /// let stream = match stream.into_inner() {\n    ///     Ok(s) => s,\n    ///     Err(e) => {\n    ///         // Here, e is an IntoInnerError, let's re-examine the buffer:\n    ///         let buffer = e.into_inner();\n    ///\n    ///         // do stuff to try to recover\n    ///\n    ///         // afterwards, let's just return the stream\n    ///         buffer.into_inner().unwrap()\n    ///     }\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> W {\n        self.0\n    }\n\n    /// Consumes the [`IntoInnerError`] and returns the error which caused the call to\n    /// [`BufWriter::into_inner()`] to fail.  Unlike `error`, this can be used to\n    /// obtain ownership of the underlying error.\n    ///\n    /// # Example\n    /// ```\n    /// #![feature(io_into_inner_error_parts)]\n    /// use std::io::{BufWriter, ErrorKind, Write};\n    ///\n    /// let mut not_enough_space = [0u8; 10];\n    /// let mut stream = BufWriter::new(not_enough_space.as_mut());\n    /// write!(stream, \"this cannot be actually written\").unwrap();\n    /// let into_inner_err = stream.into_inner().expect_err(\"now we discover it's too small\");\n    /// let err = into_inner_err.into_error();\n    /// assert_eq!(err.kind(), ErrorKind::WriteZero);\n    /// ```\n    #[unstable(feature = \"io_into_inner_error_parts\", issue = \"79704\")]\n    pub fn into_error(self) -> Error {\n        self.1\n    }\n\n    /// Consumes the [`IntoInnerError`] and returns the error which caused the call to\n    /// [`BufWriter::into_inner()`] to fail, and the underlying writer.\n    ///\n    /// This can be used to simply obtain ownership of the underlying error; it can also be used for\n    /// advanced error recovery.\n    ///\n    /// # Example\n    /// ```\n    /// #![feature(io_into_inner_error_parts)]\n    /// use std::io::{BufWriter, ErrorKind, Write};\n    ///\n    /// let mut not_enough_space = [0u8; 10];\n    /// let mut stream = BufWriter::new(not_enough_space.as_mut());\n    /// write!(stream, \"this cannot be actually written\").unwrap();\n    /// let into_inner_err = stream.into_inner().expect_err(\"now we discover it's too small\");\n    /// let (err, recovered_writer) = into_inner_err.into_parts();\n    /// assert_eq!(err.kind(), ErrorKind::WriteZero);\n    /// assert_eq!(recovered_writer.buffer(), b\"t be actually written\");\n    /// ```\n    #[unstable(feature = \"io_into_inner_error_parts\", issue = \"79704\")]\n    pub fn into_parts(self) -> (Error, W) {\n        (self.1, self.0)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W> From<IntoInnerError<W>> for Error {\n    fn from(iie: IntoInnerError<W>) -> Error {\n        iie.1\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        error::Error::description(self.error())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W> fmt::Display for IntoInnerError<W> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.error().fmt(f)\n    }\n}\n"],["2531","use super::{repeat, Cursor, SeekFrom};\nuse crate::cmp::{self, min};\nuse crate::io::{self, IoSlice, IoSliceMut};\nuse crate::io::{BufRead, BufReader, Read, Seek, Write};\nuse crate::ops::Deref;\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn read_until() {\n    let mut buf = Cursor::new(&b\"12\"[..]);\n    let mut v = Vec::new();\n    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 2);\n    assert_eq!(v, b\"12\");\n\n    let mut buf = Cursor::new(&b\"1233\"[..]);\n    let mut v = Vec::new();\n    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 3);\n    assert_eq!(v, b\"123\");\n    v.truncate(0);\n    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 1);\n    assert_eq!(v, b\"3\");\n    v.truncate(0);\n    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 0);\n    assert_eq!(v, []);\n}\n\n#[test]\nfn split() {\n    let buf = Cursor::new(&b\"12\"[..]);\n    let mut s = buf.split(b'3');\n    assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n    assert!(s.next().is_none());\n\n    let buf = Cursor::new(&b\"1233\"[..]);\n    let mut s = buf.split(b'3');\n    assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n    assert_eq!(s.next().unwrap().unwrap(), vec![]);\n    assert!(s.next().is_none());\n}\n\n#[test]\nfn read_line() {\n    let mut buf = Cursor::new(&b\"12\"[..]);\n    let mut v = String::new();\n    assert_eq!(buf.read_line(&mut v).unwrap(), 2);\n    assert_eq!(v, \"12\");\n\n    let mut buf = Cursor::new(&b\"12\\n\\n\"[..]);\n    let mut v = String::new();\n    assert_eq!(buf.read_line(&mut v).unwrap(), 3);\n    assert_eq!(v, \"12\\n\");\n    v.truncate(0);\n    assert_eq!(buf.read_line(&mut v).unwrap(), 1);\n    assert_eq!(v, \"\\n\");\n    v.truncate(0);\n    assert_eq!(buf.read_line(&mut v).unwrap(), 0);\n    assert_eq!(v, \"\");\n}\n\n#[test]\nfn lines() {\n    let buf = Cursor::new(&b\"12\\r\"[..]);\n    let mut s = buf.lines();\n    assert_eq!(s.next().unwrap().unwrap(), \"12\\r\".to_string());\n    assert!(s.next().is_none());\n\n    let buf = Cursor::new(&b\"12\\r\\n\\n\"[..]);\n    let mut s = buf.lines();\n    assert_eq!(s.next().unwrap().unwrap(), \"12\".to_string());\n    assert_eq!(s.next().unwrap().unwrap(), \"\".to_string());\n    assert!(s.next().is_none());\n}\n\n#[test]\nfn buf_read_has_data_left() {\n    let mut buf = Cursor::new(&b\"abcd\"[..]);\n    assert!(buf.has_data_left().unwrap());\n    buf.read_exact(&mut [0; 2]).unwrap();\n    assert!(buf.has_data_left().unwrap());\n    buf.read_exact(&mut [0; 2]).unwrap();\n    assert!(!buf.has_data_left().unwrap());\n}\n\n#[test]\nfn read_to_end() {\n    let mut c = Cursor::new(&b\"\"[..]);\n    let mut v = Vec::new();\n    assert_eq!(c.read_to_end(&mut v).unwrap(), 0);\n    assert_eq!(v, []);\n\n    let mut c = Cursor::new(&b\"1\"[..]);\n    let mut v = Vec::new();\n    assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n    assert_eq!(v, b\"1\");\n\n    let cap = 1024 * 1024;\n    let data = (0..cap).map(|i| (i / 3) as u8).collect::<Vec<_>>();\n    let mut v = Vec::new();\n    let (a, b) = data.split_at(data.len() / 2);\n    assert_eq!(Cursor::new(a).read_to_end(&mut v).unwrap(), a.len());\n    assert_eq!(Cursor::new(b).read_to_end(&mut v).unwrap(), b.len());\n    assert_eq!(v, data);\n}\n\n#[test]\nfn read_to_string() {\n    let mut c = Cursor::new(&b\"\"[..]);\n    let mut v = String::new();\n    assert_eq!(c.read_to_string(&mut v).unwrap(), 0);\n    assert_eq!(v, \"\");\n\n    let mut c = Cursor::new(&b\"1\"[..]);\n    let mut v = String::new();\n    assert_eq!(c.read_to_string(&mut v).unwrap(), 1);\n    assert_eq!(v, \"1\");\n\n    let mut c = Cursor::new(&b\"\\xff\"[..]);\n    let mut v = String::new();\n    assert!(c.read_to_string(&mut v).is_err());\n}\n\n#[test]\nfn read_exact() {\n    let mut buf = [0; 4];\n\n    let mut c = Cursor::new(&b\"\"[..]);\n    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n\n    let mut c = Cursor::new(&b\"123\"[..]).chain(Cursor::new(&b\"456789\"[..]));\n    c.read_exact(&mut buf).unwrap();\n    assert_eq!(&buf, b\"1234\");\n    c.read_exact(&mut buf).unwrap();\n    assert_eq!(&buf, b\"5678\");\n    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n}\n\n#[test]\nfn read_exact_slice() {\n    let mut buf = [0; 4];\n\n    let mut c = &b\"\"[..];\n    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n\n    let mut c = &b\"123\"[..];\n    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n    // make sure the optimized (early returning) method is being used\n    assert_eq!(&buf, &[0; 4]);\n\n    let mut c = &b\"1234\"[..];\n    c.read_exact(&mut buf).unwrap();\n    assert_eq!(&buf, b\"1234\");\n\n    let mut c = &b\"56789\"[..];\n    c.read_exact(&mut buf).unwrap();\n    assert_eq!(&buf, b\"5678\");\n    assert_eq!(c, b\"9\");\n}\n\n#[test]\nfn take_eof() {\n    struct R;\n\n    impl Read for R {\n        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n        }\n    }\n    impl BufRead for R {\n        fn fill_buf(&mut self) -> io::Result<&[u8]> {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n        }\n        fn consume(&mut self, _amt: usize) {}\n    }\n\n    let mut buf = [0; 1];\n    assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n    assert_eq!(b\"\", R.take(0).fill_buf().unwrap());\n}\n\nfn cmp_bufread<Br1: BufRead, Br2: BufRead>(mut br1: Br1, mut br2: Br2, exp: &[u8]) {\n    let mut cat = Vec::new();\n    loop {\n        let consume = {\n            let buf1 = br1.fill_buf().unwrap();\n            let buf2 = br2.fill_buf().unwrap();\n            let minlen = if buf1.len() < buf2.len() { buf1.len() } else { buf2.len() };\n            assert_eq!(buf1[..minlen], buf2[..minlen]);\n            cat.extend_from_slice(&buf1[..minlen]);\n            minlen\n        };\n        if consume == 0 {\n            break;\n        }\n        br1.consume(consume);\n        br2.consume(consume);\n    }\n    assert_eq!(br1.fill_buf().unwrap().len(), 0);\n    assert_eq!(br2.fill_buf().unwrap().len(), 0);\n    assert_eq!(&cat[..], &exp[..])\n}\n\n#[test]\nfn chain_bufread() {\n    let testdata = b\"ABCDEFGHIJKL\";\n    let chain1 =\n        (&testdata[..3]).chain(&testdata[3..6]).chain(&testdata[6..9]).chain(&testdata[9..]);\n    let chain2 = (&testdata[..4]).chain(&testdata[4..8]).chain(&testdata[8..]);\n    cmp_bufread(chain1, chain2, &testdata[..]);\n}\n\n#[test]\nfn bufreader_size_hint() {\n    let testdata = b\"ABCDEFGHIJKL\";\n    let mut buf_reader = BufReader::new(&testdata[..]);\n    assert_eq!(buf_reader.buffer().len(), 0);\n\n    let buffer_length = testdata.len();\n    buf_reader.fill_buf().unwrap();\n\n    // Check that size hint matches buffer contents\n    let mut buffered_bytes = buf_reader.bytes();\n    let (lower_bound, _upper_bound) = buffered_bytes.size_hint();\n    assert_eq!(lower_bound, buffer_length);\n\n    // Check that size hint matches buffer contents after advancing\n    buffered_bytes.next().unwrap().unwrap();\n    let (lower_bound, _upper_bound) = buffered_bytes.size_hint();\n    assert_eq!(lower_bound, buffer_length - 1);\n}\n\n#[test]\nfn empty_size_hint() {\n    let size_hint = io::empty().bytes().size_hint();\n    assert_eq!(size_hint, (0, Some(0)));\n}\n\n#[test]\nfn slice_size_hint() {\n    let size_hint = (&[1, 2, 3]).bytes().size_hint();\n    assert_eq!(size_hint, (3, Some(3)));\n}\n\n#[test]\nfn take_size_hint() {\n    let size_hint = (&[1, 2, 3]).take(2).bytes().size_hint();\n    assert_eq!(size_hint, (2, Some(2)));\n\n    let size_hint = (&[1, 2, 3]).take(4).bytes().size_hint();\n    assert_eq!(size_hint, (3, Some(3)));\n\n    let size_hint = io::repeat(0).take(3).bytes().size_hint();\n    assert_eq!(size_hint, (3, Some(3)));\n}\n\n#[test]\nfn chain_empty_size_hint() {\n    let chain = io::empty().chain(io::empty());\n    let size_hint = chain.bytes().size_hint();\n    assert_eq!(size_hint, (0, Some(0)));\n}\n\n#[test]\nfn chain_size_hint() {\n    let testdata = b\"ABCDEFGHIJKL\";\n    let mut buf_reader_1 = BufReader::new(&testdata[..6]);\n    let mut buf_reader_2 = BufReader::new(&testdata[6..]);\n\n    buf_reader_1.fill_buf().unwrap();\n    buf_reader_2.fill_buf().unwrap();\n\n    let chain = buf_reader_1.chain(buf_reader_2);\n    let size_hint = chain.bytes().size_hint();\n    assert_eq!(size_hint, (testdata.len(), Some(testdata.len())));\n}\n\n#[test]\nfn chain_zero_length_read_is_not_eof() {\n    let a = b\"A\";\n    let b = b\"B\";\n    let mut s = String::new();\n    let mut chain = (&a[..]).chain(&b[..]);\n    chain.read(&mut []).unwrap();\n    chain.read_to_string(&mut s).unwrap();\n    assert_eq!(\"AB\", s);\n}\n\n#[bench]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn bench_read_to_end(b: &mut test::Bencher) {\n    b.iter(|| {\n        let mut lr = repeat(1).take(10000000);\n        let mut vec = Vec::with_capacity(1024);\n        super::read_to_end(&mut lr, &mut vec)\n    });\n}\n\n#[test]\nfn seek_len() -> io::Result<()> {\n    let mut c = Cursor::new(vec![0; 15]);\n    assert_eq!(c.stream_len()?, 15);\n\n    c.seek(SeekFrom::End(0))?;\n    let old_pos = c.stream_position()?;\n    assert_eq!(c.stream_len()?, 15);\n    assert_eq!(c.stream_position()?, old_pos);\n\n    c.seek(SeekFrom::Start(7))?;\n    c.seek(SeekFrom::Current(2))?;\n    let old_pos = c.stream_position()?;\n    assert_eq!(c.stream_len()?, 15);\n    assert_eq!(c.stream_position()?, old_pos);\n\n    Ok(())\n}\n\n#[test]\nfn seek_position() -> io::Result<()> {\n    // All `asserts` are duplicated here to make sure the method does not\n    // change anything about the seek state.\n    let mut c = Cursor::new(vec![0; 15]);\n    assert_eq!(c.stream_position()?, 0);\n    assert_eq!(c.stream_position()?, 0);\n\n    c.seek(SeekFrom::End(0))?;\n    assert_eq!(c.stream_position()?, 15);\n    assert_eq!(c.stream_position()?, 15);\n\n    c.seek(SeekFrom::Start(7))?;\n    c.seek(SeekFrom::Current(2))?;\n    assert_eq!(c.stream_position()?, 9);\n    assert_eq!(c.stream_position()?, 9);\n\n    c.seek(SeekFrom::End(-3))?;\n    c.seek(SeekFrom::Current(1))?;\n    c.seek(SeekFrom::Current(-5))?;\n    assert_eq!(c.stream_position()?, 8);\n    assert_eq!(c.stream_position()?, 8);\n\n    Ok(())\n}\n\n// A simple example reader which uses the default implementation of\n// read_to_end.\nstruct ExampleSliceReader<'a> {\n    slice: &'a [u8],\n}\n\nimpl<'a> Read for ExampleSliceReader<'a> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let len = cmp::min(self.slice.len(), buf.len());\n        buf[..len].copy_from_slice(&self.slice[..len]);\n        self.slice = &self.slice[len..];\n        Ok(len)\n    }\n}\n\n#[test]\nfn test_read_to_end_capacity() -> io::Result<()> {\n    let input = &b\"foo\"[..];\n\n    // read_to_end() generally needs to over-allocate, both for efficiency\n    // and so that it can distinguish EOF. Assert that this is the case\n    // with this simple ExampleSliceReader struct, which uses the default\n    // implementation of read_to_end. Even though vec1 is allocated with\n    // exactly enough capacity for the read, read_to_end will allocate more\n    // space here.\n    let mut vec1 = Vec::with_capacity(input.len());\n    ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n    assert_eq!(vec1.len(), input.len());\n    assert!(vec1.capacity() > input.len(), \"allocated more\");\n\n    // However, std::io::Take includes an implementation of read_to_end\n    // that will not allocate when the limit has already been reached. In\n    // this case, vec2 never grows.\n    let mut vec2 = Vec::with_capacity(input.len());\n    ExampleSliceReader { slice: input }.take(input.len() as u64).read_to_end(&mut vec2)?;\n    assert_eq!(vec2.len(), input.len());\n    assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n\n    Ok(())\n}\n\n#[test]\nfn io_slice_mut_advance_slices() {\n    let mut buf1 = [1; 8];\n    let mut buf2 = [2; 16];\n    let mut buf3 = [3; 8];\n    let mut bufs = &mut [\n        IoSliceMut::new(&mut buf1),\n        IoSliceMut::new(&mut buf2),\n        IoSliceMut::new(&mut buf3),\n    ][..];\n\n    // Only in a single buffer..\n    IoSliceMut::advance_slices(&mut bufs, 1);\n    assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n    assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n    assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n\n    // Removing a buffer, leaving others as is.\n    IoSliceMut::advance_slices(&mut bufs, 7);\n    assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n    assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n\n    // Removing a buffer and removing from the next buffer.\n    IoSliceMut::advance_slices(&mut bufs, 18);\n    assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n}\n\n#[test]\nfn io_slice_mut_advance_slices_empty_slice() {\n    let mut empty_bufs = &mut [][..];\n    // Shouldn't panic.\n    IoSliceMut::advance_slices(&mut empty_bufs, 1);\n}\n\n#[test]\nfn io_slice_mut_advance_slices_beyond_total_length() {\n    let mut buf1 = [1; 8];\n    let mut bufs = &mut [IoSliceMut::new(&mut buf1)][..];\n\n    // Going beyond the total length should be ok.\n    IoSliceMut::advance_slices(&mut bufs, 9);\n    assert!(bufs.is_empty());\n}\n\n#[test]\nfn io_slice_advance_slices() {\n    let buf1 = [1; 8];\n    let buf2 = [2; 16];\n    let buf3 = [3; 8];\n    let mut bufs = &mut [IoSlice::new(&buf1), IoSlice::new(&buf2), IoSlice::new(&buf3)][..];\n\n    // Only in a single buffer..\n    IoSlice::advance_slices(&mut bufs, 1);\n    assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n    assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n    assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n\n    // Removing a buffer, leaving others as is.\n    IoSlice::advance_slices(&mut bufs, 7);\n    assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n    assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n\n    // Removing a buffer and removing from the next buffer.\n    IoSlice::advance_slices(&mut bufs, 18);\n    assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n}\n\n#[test]\nfn io_slice_advance_slices_empty_slice() {\n    let mut empty_bufs = &mut [][..];\n    // Shouldn't panic.\n    IoSlice::advance_slices(&mut empty_bufs, 1);\n}\n\n#[test]\nfn io_slice_advance_slices_beyond_total_length() {\n    let buf1 = [1; 8];\n    let mut bufs = &mut [IoSlice::new(&buf1)][..];\n\n    // Going beyond the total length should be ok.\n    IoSlice::advance_slices(&mut bufs, 9);\n    assert!(bufs.is_empty());\n}\n\n/// Create a new writer that reads from at most `n_bufs` and reads\n/// `per_call` bytes (in total) per call to write.\nfn test_writer(n_bufs: usize, per_call: usize) -> TestWriter {\n    TestWriter { n_bufs, per_call, written: Vec::new() }\n}\n\nstruct TestWriter {\n    n_bufs: usize,\n    per_call: usize,\n    written: Vec<u8>,\n}\n\nimpl Write for TestWriter {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.write_vectored(&[IoSlice::new(buf)])\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let mut left = self.per_call;\n        let mut written = 0;\n        for buf in bufs.iter().take(self.n_bufs) {\n            let n = min(left, buf.len());\n            self.written.extend_from_slice(&buf[0..n]);\n            left -= n;\n            written += n;\n        }\n        Ok(written)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[test]\nfn test_writer_read_from_one_buf() {\n    let mut writer = test_writer(1, 2);\n\n    assert_eq!(writer.write(&[]).unwrap(), 0);\n    assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n\n    // Read at most 2 bytes.\n    assert_eq!(writer.write(&[1, 1, 1]).unwrap(), 2);\n    let bufs = &[IoSlice::new(&[2, 2, 2])];\n    assert_eq!(writer.write_vectored(bufs).unwrap(), 2);\n\n    // Only read from first buf.\n    let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4, 4])];\n    assert_eq!(writer.write_vectored(bufs).unwrap(), 1);\n\n    assert_eq!(writer.written, &[1, 1, 2, 2, 3]);\n}\n\n#[test]\nfn test_writer_read_from_multiple_bufs() {\n    let mut writer = test_writer(3, 3);\n\n    // Read at most 3 bytes from two buffers.\n    let bufs = &[IoSlice::new(&[1]), IoSlice::new(&[2, 2, 2])];\n    assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n\n    // Read at most 3 bytes from three buffers.\n    let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4]), IoSlice::new(&[5, 5])];\n    assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n\n    assert_eq!(writer.written, &[1, 2, 2, 3, 4, 5]);\n}\n\n#[test]\nfn test_write_all_vectored() {\n    #[rustfmt::skip] // Becomes unreadable otherwise.\n    let tests: Vec<(_, &'static [u8])> = vec![\n        (vec![], &[]),\n        (vec![IoSlice::new(&[]), IoSlice::new(&[])], &[]),\n        (vec![IoSlice::new(&[1])], &[1]),\n        (vec![IoSlice::new(&[1, 2])], &[1, 2]),\n        (vec![IoSlice::new(&[1, 2, 3])], &[1, 2, 3]),\n        (vec![IoSlice::new(&[1, 2, 3, 4])], &[1, 2, 3, 4]),\n        (vec![IoSlice::new(&[1, 2, 3, 4, 5])], &[1, 2, 3, 4, 5]),\n        (vec![IoSlice::new(&[1]), IoSlice::new(&[2])], &[1, 2]),\n        (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2])], &[1, 2, 2]),\n        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2])], &[1, 1, 2, 2]),\n        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n        (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 1, 2, 2, 2]),\n        (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 2, 2, 2, 2]),\n        (vec![IoSlice::new(&[1, 1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 1, 2, 2, 2, 2]),\n        (vec![IoSlice::new(&[1]), IoSlice::new(&[2]), IoSlice::new(&[3])], &[1, 2, 3]),\n        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3])], &[1, 1, 2, 2, 3, 3]),\n        (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 2, 2, 3, 3, 3]),\n        (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 1, 1, 2, 2, 2, 3, 3, 3]),\n    ];\n\n    let writer_configs = &[(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)];\n\n    for (n_bufs, per_call) in writer_configs.iter().copied() {\n        for (mut input, wanted) in tests.clone().into_iter() {\n            let mut writer = test_writer(n_bufs, per_call);\n            assert!(writer.write_all_vectored(&mut *input).is_ok());\n            assert_eq!(&*writer.written, &*wanted);\n        }\n    }\n}\n"],["2532","use super::*;\nuse crate::panic::{RefUnwindSafe, UnwindSafe};\nuse crate::thread;\n\n#[test]\nfn stdout_unwind_safe() {\n    assert_unwind_safe::<Stdout>();\n}\n#[test]\nfn stdoutlock_unwind_safe() {\n    assert_unwind_safe::<StdoutLock<'_>>();\n    assert_unwind_safe::<StdoutLock<'static>>();\n}\n#[test]\nfn stderr_unwind_safe() {\n    assert_unwind_safe::<Stderr>();\n}\n#[test]\nfn stderrlock_unwind_safe() {\n    assert_unwind_safe::<StderrLock<'_>>();\n    assert_unwind_safe::<StderrLock<'static>>();\n}\n\nfn assert_unwind_safe<T: UnwindSafe + RefUnwindSafe>() {}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn panic_doesnt_poison() {\n    thread::spawn(|| {\n        let _a = stdin();\n        let _a = _a.lock();\n        let _a = stdout();\n        let _a = _a.lock();\n        let _a = stderr();\n        let _a = _a.lock();\n        panic!();\n    })\n    .join()\n    .unwrap_err();\n\n    let _a = stdin();\n    let _a = _a.lock();\n    let _a = stdout();\n    let _a = _a.lock();\n    let _a = stderr();\n    let _a = _a.lock();\n}\n"],["2533","#![allow(missing_copy_implementations)]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::fmt;\nuse crate::io::{\n    self, BufRead, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, SizeHint, Write,\n};\n\n/// A reader which is always at EOF.\n///\n/// This struct is generally created by calling [`empty()`]. Please see\n/// the documentation of [`empty()`] for more details.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[non_exhaustive]\npub struct Empty;\n\n/// Constructs a new handle to an empty reader.\n///\n/// All reads from the returned reader will return [`Ok`]`(0)`.\n///\n/// # Examples\n///\n/// A slightly sad example of not reading anything into a buffer:\n///\n/// ```\n/// use std::io::{self, Read};\n///\n/// let mut buffer = String::new();\n/// io::empty().read_to_string(&mut buffer).unwrap();\n/// assert!(buffer.is_empty());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\npub const fn empty() -> Empty {\n    Empty\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Empty {\n    #[inline]\n    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n        Ok(0)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl BufRead for Empty {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        Ok(&[])\n    }\n    #[inline]\n    fn consume(&mut self, _n: usize) {}\n}\n\n#[stable(feature = \"empty_seek\", since = \"1.51.0\")]\nimpl Seek for Empty {\n    fn seek(&mut self, _pos: SeekFrom) -> io::Result<u64> {\n        Ok(0)\n    }\n\n    fn stream_len(&mut self) -> io::Result<u64> {\n        Ok(0)\n    }\n\n    fn stream_position(&mut self) -> io::Result<u64> {\n        Ok(0)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Empty {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Empty\").finish_non_exhaustive()\n    }\n}\n\nimpl SizeHint for Empty {\n    #[inline]\n    fn upper_bound(&self) -> Option<usize> {\n        Some(0)\n    }\n}\n\n/// A reader which yields one byte over and over and over and over and over and...\n///\n/// This struct is generally created by calling [`repeat()`]. Please\n/// see the documentation of [`repeat()`] for more details.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Repeat {\n    byte: u8,\n}\n\n/// Creates an instance of a reader that infinitely repeats one byte.\n///\n/// All reads from this reader will succeed by filling the specified buffer with\n/// the given byte.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{self, Read};\n///\n/// let mut buffer = [0; 3];\n/// io::repeat(0b101).read_exact(&mut buffer).unwrap();\n/// assert_eq!(buffer, [0b101, 0b101, 0b101]);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\npub const fn repeat(byte: u8) -> Repeat {\n    Repeat { byte }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Repeat {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        for slot in &mut *buf {\n            *slot = self.byte;\n        }\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nwritten = 0;\n        for buf in bufs {\n            nwritten += self.read(buf)?;\n        }\n        Ok(nwritten)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\n\nimpl SizeHint for Repeat {\n    #[inline]\n    fn lower_bound(&self) -> usize {\n        usize::MAX\n    }\n\n    #[inline]\n    fn upper_bound(&self) -> Option<usize> {\n        None\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Repeat {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Repeat\").finish_non_exhaustive()\n    }\n}\n\n/// A writer which will move data into the void.\n///\n/// This struct is generally created by calling [`sink`]. Please\n/// see the documentation of [`sink()`] for more details.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[non_exhaustive]\npub struct Sink;\n\n/// Creates an instance of a writer which will successfully consume all data.\n///\n/// All calls to [`write`] on the returned instance will return `Ok(buf.len())`\n/// and the contents of the buffer will not be inspected.\n///\n/// [`write`]: Write::write\n///\n/// # Examples\n///\n/// ```rust\n/// use std::io::{self, Write};\n///\n/// let buffer = vec![1, 2, 3, 5, 8];\n/// let num_bytes = io::sink().write(&buffer).unwrap();\n/// assert_eq!(num_bytes, 5);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\npub const fn sink() -> Sink {\n    Sink\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Sink {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let total_len = bufs.iter().map(|b| b.len()).sum();\n        Ok(total_len)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"write_mt\", since = \"1.48.0\")]\nimpl Write for &Sink {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let total_len = bufs.iter().map(|b| b.len()).sum();\n        Ok(total_len)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Sink {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Sink\").finish_non_exhaustive()\n    }\n}\n"],["2534","use super::{BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\nuse crate::mem::MaybeUninit;\n\n/// Copies the entire contents of a reader into a writer.\n///\n/// This function will continuously read data from `reader` and then\n/// write it into `writer` in a streaming fashion until `reader`\n/// returns EOF.\n///\n/// On success, the total number of bytes that were copied from\n/// `reader` to `writer` is returned.\n///\n/// If you’re wanting to copy the contents of one file to another and you’re\n/// working with filesystem paths, see the [`fs::copy`] function.\n///\n/// [`fs::copy`]: crate::fs::copy\n///\n/// # Errors\n///\n/// This function will return an error immediately if any call to [`read`] or\n/// [`write`] returns an error. All instances of [`ErrorKind::Interrupted`] are\n/// handled by this function and the underlying operation is retried.\n///\n/// [`read`]: Read::read\n/// [`write`]: Write::write\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n///\n/// fn main() -> io::Result<()> {\n///     let mut reader: &[u8] = b\"hello\";\n///     let mut writer: Vec<u8> = vec![];\n///\n///     io::copy(&mut reader, &mut writer)?;\n///\n///     assert_eq!(&b\"hello\"[..], &writer[..]);\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\nwhere\n    R: Read,\n    W: Write,\n{\n    cfg_if::cfg_if! {\n        if #[cfg(any(target_os = \"linux\", target_os = \"android\"))] {\n            crate::sys::kernel_copy::copy_spec(reader, writer)\n        } else {\n            generic_copy(reader, writer)\n        }\n    }\n}\n\n/// The userspace read-write-loop implementation of `io::copy` that is used when\n/// OS-specific specializations for copy offloading are not available or not applicable.\npub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\nwhere\n    R: Read,\n    W: Write,\n{\n    BufferedCopySpec::copy_to(reader, writer)\n}\n\n/// Specialization of the read-write loop that either uses a stack buffer\n/// or reuses the internal buffer of a BufWriter\ntrait BufferedCopySpec: Write {\n    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64>;\n}\n\nimpl<W: Write + ?Sized> BufferedCopySpec for W {\n    default fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n        stack_buffer_copy(reader, writer)\n    }\n}\n\nimpl<I: Write> BufferedCopySpec for BufWriter<I> {\n    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n        if writer.capacity() < DEFAULT_BUF_SIZE {\n            return stack_buffer_copy(reader, writer);\n        }\n\n        // FIXME: #42788\n        //\n        //   - This creates a (mut) reference to a slice of\n        //     _uninitialized_ integers, which is **undefined behavior**\n        //\n        //   - Only the standard library gets to soundly \"ignore\" this,\n        //     based on its privileged knowledge of unstable rustc\n        //     internals;\n        unsafe {\n            let spare_cap = writer.buffer_mut().spare_capacity_mut();\n            reader.initializer().initialize(MaybeUninit::slice_assume_init_mut(spare_cap));\n        }\n\n        let mut len = 0;\n\n        loop {\n            let buf = writer.buffer_mut();\n            let spare_cap = buf.spare_capacity_mut();\n\n            if spare_cap.len() >= DEFAULT_BUF_SIZE {\n                match reader.read(unsafe { MaybeUninit::slice_assume_init_mut(spare_cap) }) {\n                    Ok(0) => return Ok(len), // EOF reached\n                    Ok(bytes_read) => {\n                        assert!(bytes_read <= spare_cap.len());\n                        // SAFETY: The initializer contract guarantees that either it or `read`\n                        // will have initialized these bytes. And we just checked that the number\n                        // of bytes is within the buffer capacity.\n                        unsafe { buf.set_len(buf.len() + bytes_read) };\n                        len += bytes_read as u64;\n                        // Read again if the buffer still has enough capacity, as BufWriter itself would do\n                        // This will occur if the reader returns short reads\n                        continue;\n                    }\n                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                    Err(e) => return Err(e),\n                }\n            }\n\n            writer.flush_buf()?;\n        }\n    }\n}\n\nfn stack_buffer_copy<R: Read + ?Sized, W: Write + ?Sized>(\n    reader: &mut R,\n    writer: &mut W,\n) -> Result<u64> {\n    let mut buf = MaybeUninit::<[u8; DEFAULT_BUF_SIZE]>::uninit();\n    // FIXME: #42788\n    //\n    //   - This creates a (mut) reference to a slice of\n    //     _uninitialized_ integers, which is **undefined behavior**\n    //\n    //   - Only the standard library gets to soundly \"ignore\" this,\n    //     based on its privileged knowledge of unstable rustc\n    //     internals;\n    unsafe {\n        reader.initializer().initialize(buf.assume_init_mut());\n    }\n\n    let mut written = 0;\n    loop {\n        let len = match reader.read(unsafe { buf.assume_init_mut() }) {\n            Ok(0) => return Ok(written),\n            Ok(len) => len,\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n            Err(e) => return Err(e),\n        };\n        writer.write_all(unsafe { &buf.assume_init_ref()[..len] })?;\n        written += len as u64;\n    }\n}\n"],["2535","use crate::io::prelude::*;\nuse crate::io::{Cursor, IoSlice, IoSliceMut, SeekFrom};\n\n#[test]\nfn test_vec_writer() {\n    let mut writer = Vec::new();\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(\n        writer\n            .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n            .unwrap(),\n        3\n    );\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(writer, b);\n}\n\n#[test]\nfn test_mem_writer() {\n    let mut writer = Cursor::new(Vec::new());\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(\n        writer\n            .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n            .unwrap(),\n        3\n    );\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(&writer.get_ref()[..], b);\n}\n\n#[test]\nfn test_mem_mut_writer() {\n    let mut vec = Vec::new();\n    let mut writer = Cursor::new(&mut vec);\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(\n        writer\n            .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n            .unwrap(),\n        3\n    );\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(&writer.get_ref()[..], b);\n}\n\n#[test]\nfn test_box_slice_writer() {\n    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n    assert_eq!(writer.position(), 0);\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.position(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(writer.position(), 8);\n    assert_eq!(writer.write(&[]).unwrap(), 0);\n    assert_eq!(writer.position(), 8);\n\n    assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n    assert_eq!(writer.write(&[10]).unwrap(), 0);\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n    assert_eq!(&**writer.get_ref(), b);\n}\n\n#[test]\nfn test_box_slice_writer_vectored() {\n    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n    assert_eq!(writer.position(), 0);\n    assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n    assert_eq!(writer.position(), 1);\n    assert_eq!(\n        writer.write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7]),]).unwrap(),\n        7,\n    );\n    assert_eq!(writer.position(), 8);\n    assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n    assert_eq!(writer.position(), 8);\n\n    assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n    assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n    assert_eq!(&**writer.get_ref(), b);\n}\n\n#[test]\nfn test_buf_writer() {\n    let mut buf = [0 as u8; 9];\n    {\n        let mut writer = Cursor::new(&mut buf[..]);\n        assert_eq!(writer.position(), 0);\n        assert_eq!(writer.write(&[0]).unwrap(), 1);\n        assert_eq!(writer.position(), 1);\n        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n        assert_eq!(writer.position(), 8);\n        assert_eq!(writer.write(&[]).unwrap(), 0);\n        assert_eq!(writer.position(), 8);\n\n        assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n        assert_eq!(writer.write(&[10]).unwrap(), 0);\n    }\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n    assert_eq!(buf, b);\n}\n\n#[test]\nfn test_buf_writer_vectored() {\n    let mut buf = [0 as u8; 9];\n    {\n        let mut writer = Cursor::new(&mut buf[..]);\n        assert_eq!(writer.position(), 0);\n        assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n        assert_eq!(writer.position(), 1);\n        assert_eq!(\n            writer\n                .write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7])],)\n                .unwrap(),\n            7,\n        );\n        assert_eq!(writer.position(), 8);\n        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n        assert_eq!(writer.position(), 8);\n\n        assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n        assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n    }\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n    assert_eq!(buf, b);\n}\n\n#[test]\nfn test_buf_writer_seek() {\n    let mut buf = [0 as u8; 8];\n    {\n        let mut writer = Cursor::new(&mut buf[..]);\n        assert_eq!(writer.position(), 0);\n        assert_eq!(writer.write(&[1]).unwrap(), 1);\n        assert_eq!(writer.position(), 1);\n\n        assert_eq!(writer.seek(SeekFrom::Start(2)).unwrap(), 2);\n        assert_eq!(writer.position(), 2);\n        assert_eq!(writer.write(&[2]).unwrap(), 1);\n        assert_eq!(writer.position(), 3);\n\n        assert_eq!(writer.seek(SeekFrom::Current(-2)).unwrap(), 1);\n        assert_eq!(writer.position(), 1);\n        assert_eq!(writer.write(&[3]).unwrap(), 1);\n        assert_eq!(writer.position(), 2);\n\n        assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n        assert_eq!(writer.position(), 7);\n        assert_eq!(writer.write(&[4]).unwrap(), 1);\n        assert_eq!(writer.position(), 8);\n    }\n    let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n    assert_eq!(buf, b);\n}\n\n#[test]\nfn test_buf_writer_error() {\n    let mut buf = [0 as u8; 2];\n    let mut writer = Cursor::new(&mut buf[..]);\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.write(&[0, 0]).unwrap(), 1);\n    assert_eq!(writer.write(&[0, 0]).unwrap(), 0);\n}\n\n#[test]\nfn test_mem_reader() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n    let mut buf = [];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf = [0; 4];\n    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n    assert_eq!(reader.position(), 5);\n    let b: &[_] = &[1, 2, 3, 4];\n    assert_eq!(buf, b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n    let b: &[_] = &[5, 6, 7];\n    assert_eq!(&buf[..3], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_mem_reader_vectored() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n    let mut buf = [];\n    assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(\n        reader.read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),]).unwrap(),\n        1,\n    );\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf1 = [0; 4];\n    let mut buf2 = [0; 4];\n    assert_eq!(\n        reader\n            .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2),])\n            .unwrap(),\n        7,\n    );\n    let b1: &[_] = &[1, 2, 3, 4];\n    let b2: &[_] = &[5, 6, 7];\n    assert_eq!(buf1, b1);\n    assert_eq!(&buf2[..3], b2);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_boxed_slice_reader() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n    let mut buf = [];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf = [0; 4];\n    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n    assert_eq!(reader.position(), 5);\n    let b: &[_] = &[1, 2, 3, 4];\n    assert_eq!(buf, b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n    let b: &[_] = &[5, 6, 7];\n    assert_eq!(&buf[..3], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_boxed_slice_reader_vectored() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n    let mut buf = [];\n    assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(\n        reader.read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),]).unwrap(),\n        1,\n    );\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf1 = [0; 4];\n    let mut buf2 = [0; 4];\n    assert_eq!(\n        reader\n            .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],)\n            .unwrap(),\n        7,\n    );\n    let b1: &[_] = &[1, 2, 3, 4];\n    let b2: &[_] = &[5, 6, 7];\n    assert_eq!(buf1, b1);\n    assert_eq!(&buf2[..3], b2);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn read_to_end() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n    let mut v = Vec::new();\n    reader.read_to_end(&mut v).unwrap();\n    assert_eq!(v, [0, 1, 2, 3, 4, 5, 6, 7]);\n}\n\n#[test]\nfn test_slice_reader() {\n    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n    let reader = &mut &in_buf[..];\n    let mut buf = [];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    let mut buf = [0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.len(), 7);\n    let b: &[_] = &[0];\n    assert_eq!(&buf[..], b);\n    let mut buf = [0; 4];\n    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n    assert_eq!(reader.len(), 3);\n    let b: &[_] = &[1, 2, 3, 4];\n    assert_eq!(&buf[..], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n    let b: &[_] = &[5, 6, 7];\n    assert_eq!(&buf[..3], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_slice_reader_vectored() {\n    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n    let reader = &mut &in_buf[..];\n    let mut buf = [];\n    assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n    let mut buf = [0];\n    assert_eq!(\n        reader.read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),]).unwrap(),\n        1,\n    );\n    assert_eq!(reader.len(), 7);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf1 = [0; 4];\n    let mut buf2 = [0; 4];\n    assert_eq!(\n        reader\n            .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],)\n            .unwrap(),\n        7,\n    );\n    let b1: &[_] = &[1, 2, 3, 4];\n    let b2: &[_] = &[5, 6, 7];\n    assert_eq!(buf1, b1);\n    assert_eq!(&buf2[..3], b2);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_read_exact() {\n    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n    let reader = &mut &in_buf[..];\n    let mut buf = [];\n    assert!(reader.read_exact(&mut buf).is_ok());\n    let mut buf = [8];\n    assert!(reader.read_exact(&mut buf).is_ok());\n    assert_eq!(buf[0], 0);\n    assert_eq!(reader.len(), 7);\n    let mut buf = [0, 0, 0, 0, 0, 0, 0];\n    assert!(reader.read_exact(&mut buf).is_ok());\n    assert_eq!(buf, [1, 2, 3, 4, 5, 6, 7]);\n    assert_eq!(reader.len(), 0);\n    let mut buf = [0];\n    assert!(reader.read_exact(&mut buf).is_err());\n}\n\n#[test]\nfn test_buf_reader() {\n    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n    let mut reader = Cursor::new(&in_buf[..]);\n    let mut buf = [];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf = [0; 4];\n    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n    assert_eq!(reader.position(), 5);\n    let b: &[_] = &[1, 2, 3, 4];\n    assert_eq!(buf, b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n    let b: &[_] = &[5, 6, 7];\n    assert_eq!(&buf[..3], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn seek_past_end() {\n    let buf = [0xff];\n    let mut r = Cursor::new(&buf[..]);\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.read(&mut [0]).unwrap(), 0);\n\n    let mut r = Cursor::new(vec![10]);\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.read(&mut [0]).unwrap(), 0);\n\n    let mut buf = [0];\n    let mut r = Cursor::new(&mut buf[..]);\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.write(&[3]).unwrap(), 0);\n\n    let mut r = Cursor::new(vec![10].into_boxed_slice());\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.write(&[3]).unwrap(), 0);\n}\n\n#[test]\nfn seek_past_i64() {\n    let buf = [0xff];\n    let mut r = Cursor::new(&buf[..]);\n    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n\n    let mut r = Cursor::new(vec![10]);\n    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n\n    let mut buf = [0];\n    let mut r = Cursor::new(&mut buf[..]);\n    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n\n    let mut r = Cursor::new(vec![10].into_boxed_slice());\n    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n}\n\n#[test]\nfn seek_before_0() {\n    let buf = [0xff];\n    let mut r = Cursor::new(&buf[..]);\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n\n    let mut r = Cursor::new(vec![10]);\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n\n    let mut buf = [0];\n    let mut r = Cursor::new(&mut buf[..]);\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n\n    let mut r = Cursor::new(vec![10].into_boxed_slice());\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n}\n\n#[test]\nfn test_seekable_mem_writer() {\n    let mut writer = Cursor::new(Vec::<u8>::new());\n    assert_eq!(writer.position(), 0);\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.position(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(writer.position(), 8);\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n    assert_eq!(&writer.get_ref()[..], b);\n\n    assert_eq!(writer.seek(SeekFrom::Start(0)).unwrap(), 0);\n    assert_eq!(writer.position(), 0);\n    assert_eq!(writer.write(&[3, 4]).unwrap(), 2);\n    let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n    assert_eq!(&writer.get_ref()[..], b);\n\n    assert_eq!(writer.seek(SeekFrom::Current(1)).unwrap(), 3);\n    assert_eq!(writer.write(&[0, 1]).unwrap(), 2);\n    let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n    assert_eq!(&writer.get_ref()[..], b);\n\n    assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n    assert_eq!(writer.write(&[1, 2]).unwrap(), 2);\n    let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n    assert_eq!(&writer.get_ref()[..], b);\n\n    assert_eq!(writer.seek(SeekFrom::End(1)).unwrap(), 10);\n    assert_eq!(writer.write(&[1]).unwrap(), 1);\n    let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n    assert_eq!(&writer.get_ref()[..], b);\n}\n\n#[test]\nfn vec_seek_past_end() {\n    let mut r = Cursor::new(Vec::new());\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.write(&[3]).unwrap(), 1);\n}\n\n#[test]\nfn vec_seek_before_0() {\n    let mut r = Cursor::new(Vec::new());\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n}\n\n#[test]\n#[cfg(target_pointer_width = \"32\")]\nfn vec_seek_and_write_past_usize_max() {\n    let mut c = Cursor::new(Vec::new());\n    c.set_position(usize::MAX as u64 + 1);\n    assert!(c.write_all(&[1, 2, 3]).is_err());\n}\n\n#[test]\nfn test_partial_eq() {\n    assert_eq!(Cursor::new(Vec::<u8>::new()), Cursor::new(Vec::<u8>::new()));\n}\n\n#[test]\nfn test_eq() {\n    struct AssertEq<T: Eq>(pub T);\n\n    let _: AssertEq<Cursor<Vec<u8>>> = AssertEq(Cursor::new(Vec::new()));\n}\n\n#[allow(dead_code)]\nfn const_cursor() {\n    const CURSOR: Cursor<&[u8]> = Cursor::new(&[0]);\n    const _: &&[u8] = CURSOR.get_ref();\n    const _: u64 = CURSOR.position();\n}\n"],["2536","use super::{Duration, Instant, SystemTime, UNIX_EPOCH};\n\nmacro_rules! assert_almost_eq {\n    ($a:expr, $b:expr) => {{\n        let (a, b) = ($a, $b);\n        if a != b {\n            let (a, b) = if a > b { (a, b) } else { (b, a) };\n            assert!(a - Duration::from_micros(1) <= b, \"{:?} is not almost equal to {:?}\", a, b);\n        }\n    }};\n}\n\n#[test]\nfn instant_monotonic() {\n    let a = Instant::now();\n    let b = Instant::now();\n    assert!(b >= a);\n}\n\n#[test]\nfn instant_elapsed() {\n    let a = Instant::now();\n    a.elapsed();\n}\n\n#[test]\nfn instant_math() {\n    let a = Instant::now();\n    let b = Instant::now();\n    println!(\"a: {:?}\", a);\n    println!(\"b: {:?}\", b);\n    let dur = b.duration_since(a);\n    println!(\"dur: {:?}\", dur);\n    assert_almost_eq!(b - dur, a);\n    assert_almost_eq!(a + dur, b);\n\n    let second = Duration::SECOND;\n    assert_almost_eq!(a - second + second, a);\n    assert_almost_eq!(a.checked_sub(second).unwrap().checked_add(second).unwrap(), a);\n\n    // checked_add_duration will not panic on overflow\n    let mut maybe_t = Some(Instant::now());\n    let max_duration = Duration::from_secs(u64::MAX);\n    // in case `Instant` can store `>= now + max_duration`.\n    for _ in 0..2 {\n        maybe_t = maybe_t.and_then(|t| t.checked_add(max_duration));\n    }\n    assert_eq!(maybe_t, None);\n\n    // checked_add_duration calculates the right time and will work for another year\n    let year = Duration::from_secs(60 * 60 * 24 * 365);\n    assert_eq!(a + year, a.checked_add(year).unwrap());\n}\n\n#[test]\nfn instant_math_is_associative() {\n    let now = Instant::now();\n    let offset = Duration::from_millis(5);\n    // Changing the order of instant math shouldn't change the results,\n    // especially when the expression reduces to X + identity.\n    assert_eq!((now + offset) - now, (now - now) + offset);\n}\n\n#[test]\n#[should_panic]\nfn instant_duration_since_panic() {\n    let a = Instant::now();\n    (a - Duration::SECOND).duration_since(a);\n}\n\n#[test]\nfn instant_checked_duration_since_nopanic() {\n    let now = Instant::now();\n    let earlier = now - Duration::SECOND;\n    let later = now + Duration::SECOND;\n    assert_eq!(earlier.checked_duration_since(now), None);\n    assert_eq!(later.checked_duration_since(now), Some(Duration::SECOND));\n    assert_eq!(now.checked_duration_since(now), Some(Duration::ZERO));\n}\n\n#[test]\nfn instant_saturating_duration_since_nopanic() {\n    let a = Instant::now();\n    let ret = (a - Duration::SECOND).saturating_duration_since(a);\n    assert_eq!(ret, Duration::ZERO);\n}\n\n#[test]\nfn system_time_math() {\n    let a = SystemTime::now();\n    let b = SystemTime::now();\n    match b.duration_since(a) {\n        Ok(Duration::ZERO) => {\n            assert_almost_eq!(a, b);\n        }\n        Ok(dur) => {\n            assert!(b > a);\n            assert_almost_eq!(b - dur, a);\n            assert_almost_eq!(a + dur, b);\n        }\n        Err(dur) => {\n            let dur = dur.duration();\n            assert!(a > b);\n            assert_almost_eq!(b + dur, a);\n            assert_almost_eq!(a - dur, b);\n        }\n    }\n\n    let second = Duration::SECOND;\n    assert_almost_eq!(a.duration_since(a - second).unwrap(), second);\n    assert_almost_eq!(a.duration_since(a + second).unwrap_err().duration(), second);\n\n    assert_almost_eq!(a - second + second, a);\n    assert_almost_eq!(a.checked_sub(second).unwrap().checked_add(second).unwrap(), a);\n\n    let one_second_from_epoch = UNIX_EPOCH + Duration::SECOND;\n    let one_second_from_epoch2 =\n        UNIX_EPOCH + Duration::from_millis(500) + Duration::from_millis(500);\n    assert_eq!(one_second_from_epoch, one_second_from_epoch2);\n\n    // checked_add_duration will not panic on overflow\n    let mut maybe_t = Some(SystemTime::UNIX_EPOCH);\n    let max_duration = Duration::from_secs(u64::MAX);\n    // in case `SystemTime` can store `>= UNIX_EPOCH + max_duration`.\n    for _ in 0..2 {\n        maybe_t = maybe_t.and_then(|t| t.checked_add(max_duration));\n    }\n    assert_eq!(maybe_t, None);\n\n    // checked_add_duration calculates the right time and will work for another year\n    let year = Duration::from_secs(60 * 60 * 24 * 365);\n    assert_eq!(a + year, a.checked_add(year).unwrap());\n}\n\n#[test]\nfn system_time_elapsed() {\n    let a = SystemTime::now();\n    drop(a.elapsed());\n}\n\n#[test]\nfn since_epoch() {\n    let ts = SystemTime::now();\n    let a = ts.duration_since(UNIX_EPOCH + Duration::SECOND).unwrap();\n    let b = ts.duration_since(UNIX_EPOCH).unwrap();\n    assert!(b > a);\n    assert_eq!(b - a, Duration::SECOND);\n\n    let thirty_years = Duration::SECOND * 60 * 60 * 24 * 365 * 30;\n\n    // Right now for CI this test is run in an emulator, and apparently the\n    // aarch64 emulator's sense of time is that we're still living in the\n    // 70s. This is also true for riscv (also qemu)\n    //\n    // Otherwise let's assume that we're all running computers later than\n    // 2000.\n    if !cfg!(target_arch = \"aarch64\") && !cfg!(target_arch = \"riscv64\") {\n        assert!(a > thirty_years);\n    }\n\n    // let's assume that we're all running computers earlier than 2090.\n    // Should give us ~70 years to fix this!\n    let hundred_twenty_years = thirty_years * 4;\n    assert!(a < hundred_twenty_years);\n}\n"],["2537","use super::super::map::RandomState;\nuse super::HashSet;\n\nuse crate::panic::{catch_unwind, AssertUnwindSafe};\nuse crate::sync::atomic::{AtomicU32, Ordering};\n\n#[test]\nfn test_zero_capacities() {\n    type HS = HashSet<i32>;\n\n    let s = HS::new();\n    assert_eq!(s.capacity(), 0);\n\n    let s = HS::default();\n    assert_eq!(s.capacity(), 0);\n\n    let s = HS::with_hasher(RandomState::new());\n    assert_eq!(s.capacity(), 0);\n\n    let s = HS::with_capacity(0);\n    assert_eq!(s.capacity(), 0);\n\n    let s = HS::with_capacity_and_hasher(0, RandomState::new());\n    assert_eq!(s.capacity(), 0);\n\n    let mut s = HS::new();\n    s.insert(1);\n    s.insert(2);\n    s.remove(&1);\n    s.remove(&2);\n    s.shrink_to_fit();\n    assert_eq!(s.capacity(), 0);\n\n    let mut s = HS::new();\n    s.reserve(0);\n    assert_eq!(s.capacity(), 0);\n}\n\n#[test]\nfn test_disjoint() {\n    let mut xs = HashSet::new();\n    let mut ys = HashSet::new();\n    assert!(xs.is_disjoint(&ys));\n    assert!(ys.is_disjoint(&xs));\n    assert!(xs.insert(5));\n    assert!(ys.insert(11));\n    assert!(xs.is_disjoint(&ys));\n    assert!(ys.is_disjoint(&xs));\n    assert!(xs.insert(7));\n    assert!(xs.insert(19));\n    assert!(xs.insert(4));\n    assert!(ys.insert(2));\n    assert!(ys.insert(-11));\n    assert!(xs.is_disjoint(&ys));\n    assert!(ys.is_disjoint(&xs));\n    assert!(ys.insert(7));\n    assert!(!xs.is_disjoint(&ys));\n    assert!(!ys.is_disjoint(&xs));\n}\n\n#[test]\nfn test_subset_and_superset() {\n    let mut a = HashSet::new();\n    assert!(a.insert(0));\n    assert!(a.insert(5));\n    assert!(a.insert(11));\n    assert!(a.insert(7));\n\n    let mut b = HashSet::new();\n    assert!(b.insert(0));\n    assert!(b.insert(7));\n    assert!(b.insert(19));\n    assert!(b.insert(250));\n    assert!(b.insert(11));\n    assert!(b.insert(200));\n\n    assert!(!a.is_subset(&b));\n    assert!(!a.is_superset(&b));\n    assert!(!b.is_subset(&a));\n    assert!(!b.is_superset(&a));\n\n    assert!(b.insert(5));\n\n    assert!(a.is_subset(&b));\n    assert!(!a.is_superset(&b));\n    assert!(!b.is_subset(&a));\n    assert!(b.is_superset(&a));\n}\n\n#[test]\nfn test_iterate() {\n    let mut a = HashSet::new();\n    for i in 0..32 {\n        assert!(a.insert(i));\n    }\n    let mut observed: u32 = 0;\n    for k in &a {\n        observed |= 1 << *k;\n    }\n    assert_eq!(observed, 0xFFFF_FFFF);\n}\n\n#[test]\nfn test_intersection() {\n    let mut a = HashSet::new();\n    let mut b = HashSet::new();\n    assert!(a.intersection(&b).next().is_none());\n\n    assert!(a.insert(11));\n    assert!(a.insert(1));\n    assert!(a.insert(3));\n    assert!(a.insert(77));\n    assert!(a.insert(103));\n    assert!(a.insert(5));\n    assert!(a.insert(-5));\n\n    assert!(b.insert(2));\n    assert!(b.insert(11));\n    assert!(b.insert(77));\n    assert!(b.insert(-9));\n    assert!(b.insert(-42));\n    assert!(b.insert(5));\n    assert!(b.insert(3));\n\n    let mut i = 0;\n    let expected = [3, 5, 11, 77];\n    for x in a.intersection(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n\n    assert!(a.insert(9)); // make a bigger than b\n\n    i = 0;\n    for x in a.intersection(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n\n    i = 0;\n    for x in b.intersection(&a) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n}\n\n#[test]\nfn test_difference() {\n    let mut a = HashSet::new();\n    let mut b = HashSet::new();\n\n    assert!(a.insert(1));\n    assert!(a.insert(3));\n    assert!(a.insert(5));\n    assert!(a.insert(9));\n    assert!(a.insert(11));\n\n    assert!(b.insert(3));\n    assert!(b.insert(9));\n\n    let mut i = 0;\n    let expected = [1, 5, 11];\n    for x in a.difference(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n}\n\n#[test]\nfn test_symmetric_difference() {\n    let mut a = HashSet::new();\n    let mut b = HashSet::new();\n\n    assert!(a.insert(1));\n    assert!(a.insert(3));\n    assert!(a.insert(5));\n    assert!(a.insert(9));\n    assert!(a.insert(11));\n\n    assert!(b.insert(-2));\n    assert!(b.insert(3));\n    assert!(b.insert(9));\n    assert!(b.insert(14));\n    assert!(b.insert(22));\n\n    let mut i = 0;\n    let expected = [-2, 1, 5, 11, 14, 22];\n    for x in a.symmetric_difference(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n}\n\n#[test]\nfn test_union() {\n    let mut a = HashSet::new();\n    let mut b = HashSet::new();\n    assert!(a.union(&b).next().is_none());\n    assert!(b.union(&a).next().is_none());\n\n    assert!(a.insert(1));\n    assert!(a.insert(3));\n    assert!(a.insert(11));\n    assert!(a.insert(16));\n    assert!(a.insert(19));\n    assert!(a.insert(24));\n\n    assert!(b.insert(-2));\n    assert!(b.insert(1));\n    assert!(b.insert(5));\n    assert!(b.insert(9));\n    assert!(b.insert(13));\n    assert!(b.insert(19));\n\n    let mut i = 0;\n    let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n    for x in a.union(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n\n    assert!(a.insert(9)); // make a bigger than b\n    assert!(a.insert(5));\n\n    i = 0;\n    for x in a.union(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n\n    i = 0;\n    for x in b.union(&a) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n}\n\n#[test]\nfn test_from_iter() {\n    let xs = [1, 2, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    let set: HashSet<_> = xs.iter().cloned().collect();\n\n    for x in &xs {\n        assert!(set.contains(x));\n    }\n\n    assert_eq!(set.iter().len(), xs.len() - 1);\n}\n\n#[test]\nfn test_move_iter() {\n    let hs = {\n        let mut hs = HashSet::new();\n\n        hs.insert('a');\n        hs.insert('b');\n\n        hs\n    };\n\n    let v = hs.into_iter().collect::<Vec<char>>();\n    assert!(v == ['a', 'b'] || v == ['b', 'a']);\n}\n\n#[test]\nfn test_eq() {\n    // These constants once happened to expose a bug in insert().\n    // I'm keeping them around to prevent a regression.\n    let mut s1 = HashSet::new();\n\n    s1.insert(1);\n    s1.insert(2);\n    s1.insert(3);\n\n    let mut s2 = HashSet::new();\n\n    s2.insert(1);\n    s2.insert(2);\n\n    assert!(s1 != s2);\n\n    s2.insert(3);\n\n    assert_eq!(s1, s2);\n}\n\n#[test]\nfn test_show() {\n    let mut set = HashSet::new();\n    let empty = HashSet::<i32>::new();\n\n    set.insert(1);\n    set.insert(2);\n\n    let set_str = format!(\"{:?}\", set);\n\n    assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n    assert_eq!(format!(\"{:?}\", empty), \"{}\");\n}\n\n#[test]\nfn test_trivial_drain() {\n    let mut s = HashSet::<i32>::new();\n    for _ in s.drain() {}\n    assert!(s.is_empty());\n    drop(s);\n\n    let mut s = HashSet::<i32>::new();\n    drop(s.drain());\n    assert!(s.is_empty());\n}\n\n#[test]\nfn test_drain() {\n    let mut s: HashSet<_> = (1..100).collect();\n\n    // try this a bunch of times to make sure we don't screw up internal state.\n    for _ in 0..20 {\n        assert_eq!(s.len(), 99);\n\n        {\n            let mut last_i = 0;\n            let mut d = s.drain();\n            for (i, x) in d.by_ref().take(50).enumerate() {\n                last_i = i;\n                assert!(x != 0);\n            }\n            assert_eq!(last_i, 49);\n        }\n\n        for _ in &s {\n            panic!(\"s should be empty!\");\n        }\n\n        // reset to try again.\n        s.extend(1..100);\n    }\n}\n\n#[test]\nfn test_replace() {\n    use crate::hash;\n\n    #[derive(Debug)]\n    struct Foo(&'static str, i32);\n\n    impl PartialEq for Foo {\n        fn eq(&self, other: &Self) -> bool {\n            self.0 == other.0\n        }\n    }\n\n    impl Eq for Foo {}\n\n    impl hash::Hash for Foo {\n        fn hash<H: hash::Hasher>(&self, h: &mut H) {\n            self.0.hash(h);\n        }\n    }\n\n    let mut s = HashSet::new();\n    assert_eq!(s.replace(Foo(\"a\", 1)), None);\n    assert_eq!(s.len(), 1);\n    assert_eq!(s.replace(Foo(\"a\", 2)), Some(Foo(\"a\", 1)));\n    assert_eq!(s.len(), 1);\n\n    let mut it = s.iter();\n    assert_eq!(it.next(), Some(&Foo(\"a\", 2)));\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn test_extend_ref() {\n    let mut a = HashSet::new();\n    a.insert(1);\n\n    a.extend(&[2, 3, 4]);\n\n    assert_eq!(a.len(), 4);\n    assert!(a.contains(&1));\n    assert!(a.contains(&2));\n    assert!(a.contains(&3));\n    assert!(a.contains(&4));\n\n    let mut b = HashSet::new();\n    b.insert(5);\n    b.insert(6);\n\n    a.extend(&b);\n\n    assert_eq!(a.len(), 6);\n    assert!(a.contains(&1));\n    assert!(a.contains(&2));\n    assert!(a.contains(&3));\n    assert!(a.contains(&4));\n    assert!(a.contains(&5));\n    assert!(a.contains(&6));\n}\n\n#[test]\nfn test_retain() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut set: HashSet<i32> = xs.iter().cloned().collect();\n    set.retain(|&k| k % 2 == 0);\n    assert_eq!(set.len(), 3);\n    assert!(set.contains(&2));\n    assert!(set.contains(&4));\n    assert!(set.contains(&6));\n}\n\n#[test]\nfn test_drain_filter() {\n    let mut x: HashSet<_> = [1].iter().copied().collect();\n    let mut y: HashSet<_> = [1].iter().copied().collect();\n\n    x.drain_filter(|_| true);\n    y.drain_filter(|_| false);\n    assert_eq!(x.len(), 0);\n    assert_eq!(y.len(), 1);\n}\n\n#[test]\nfn test_drain_filter_drop_panic_leak() {\n    static PREDS: AtomicU32 = AtomicU32::new(0);\n    static DROPS: AtomicU32 = AtomicU32::new(0);\n\n    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n    struct D(i32);\n    impl Drop for D {\n        fn drop(&mut self) {\n            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n                panic!(\"panic in `drop`\");\n            }\n        }\n    }\n\n    let mut set = (0..3).map(|i| D(i)).collect::<HashSet<_>>();\n\n    catch_unwind(move || {\n        drop(set.drain_filter(|_| {\n            PREDS.fetch_add(1, Ordering::SeqCst);\n            true\n        }))\n    })\n    .ok();\n\n    assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n}\n\n#[test]\nfn test_drain_filter_pred_panic_leak() {\n    static PREDS: AtomicU32 = AtomicU32::new(0);\n    static DROPS: AtomicU32 = AtomicU32::new(0);\n\n    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n    struct D;\n    impl Drop for D {\n        fn drop(&mut self) {\n            DROPS.fetch_add(1, Ordering::SeqCst);\n        }\n    }\n\n    let mut set: HashSet<_> = (0..3).map(|_| D).collect();\n\n    catch_unwind(AssertUnwindSafe(|| {\n        drop(set.drain_filter(|_| match PREDS.fetch_add(1, Ordering::SeqCst) {\n            0 => true,\n            _ => panic!(),\n        }))\n    }))\n    .ok();\n\n    assert_eq!(PREDS.load(Ordering::SeqCst), 1);\n    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n    assert_eq!(set.len(), 0);\n}\n"],["2538","//! Unordered containers, implemented as hash-tables\n\npub mod map;\npub mod set;\n"],["2539","#[cfg(test)]\nmod tests;\n\nuse hashbrown::hash_set as base;\n\nuse crate::borrow::Borrow;\nuse crate::collections::TryReserveError;\nuse crate::fmt;\nuse crate::hash::{BuildHasher, Hash};\nuse crate::iter::{Chain, FromIterator, FusedIterator};\nuse crate::ops::{BitAnd, BitOr, BitXor, Sub};\n\nuse super::map::{map_try_reserve_error, RandomState};\n\n// Future Optimization (FIXME!)\n// ============================\n//\n// Iteration over zero sized values is a noop. There is no need\n// for `bucket.val` in the case of HashSet. I suppose we would need HKT\n// to get rid of it properly.\n\n/// A [hash set] implemented as a `HashMap` where the value is `()`.\n///\n/// As with the [`HashMap`] type, a `HashSet` requires that the elements\n/// implement the [`Eq`] and [`Hash`] traits. This can frequently be achieved by\n/// using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself,\n/// it is important that the following property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must be equal.\n///\n///\n/// It is a logic error for an item to be modified in such a way that the\n/// item's hash, as determined by the [`Hash`] trait, or its equality, as\n/// determined by the [`Eq`] trait, changes while it is in the set. This is\n/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or\n/// unsafe code. The behavior resulting from such a logic error is not\n/// specified, but will not result in undefined behavior. This could include\n/// panics, incorrect results, aborts, memory leaks, and non-termination.\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `HashSet<String>` in this example).\n/// let mut books = HashSet::new();\n///\n/// // Add some books.\n/// books.insert(\"A Dance With Dragons\".to_string());\n/// books.insert(\"To Kill a Mockingbird\".to_string());\n/// books.insert(\"The Odyssey\".to_string());\n/// books.insert(\"The Great Gatsby\".to_string());\n///\n/// // Check for a specific one.\n/// if !books.contains(\"The Winds of Winter\") {\n///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n///              books.len());\n/// }\n///\n/// // Remove a book.\n/// books.remove(\"The Odyssey\");\n///\n/// // Iterate over everything.\n/// for book in &books {\n///     println!(\"{}\", book);\n/// }\n/// ```\n///\n/// The easiest way to use `HashSet` with a custom type is to derive\n/// [`Eq`] and [`Hash`]. We must also derive [`PartialEq`], this will in the\n/// future be implied by [`Eq`].\n///\n/// ```\n/// use std::collections::HashSet;\n/// #[derive(Hash, Eq, PartialEq, Debug)]\n/// struct Viking {\n///     name: String,\n///     power: usize,\n/// }\n///\n/// let mut vikings = HashSet::new();\n///\n/// vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\n/// vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\n/// vikings.insert(Viking { name: \"Olaf\".to_string(), power: 4 });\n/// vikings.insert(Viking { name: \"Harald\".to_string(), power: 8 });\n///\n/// // Use derived implementation to print the vikings.\n/// for x in &vikings {\n///     println!(\"{:?}\", x);\n/// }\n/// ```\n///\n/// A `HashSet` with fixed list of elements can be initialized from an array:\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let viking_names: HashSet<&'static str> =\n///     [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n/// // use the values stored in the set\n/// ```\n///\n/// [hash set]: crate::collections#use-the-set-variant-of-any-of-these-maps-when\n/// [`HashMap`]: crate::collections::HashMap\n/// [`RefCell`]: crate::cell::RefCell\n/// [`Cell`]: crate::cell::Cell\n#[cfg_attr(not(test), rustc_diagnostic_item = \"hashset_type\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct HashSet<T, S = RandomState> {\n    base: base::HashSet<T, S>,\n}\n\nimpl<T> HashSet<T, RandomState> {\n    /// Creates an empty `HashSet`.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let set: HashSet<i32> = HashSet::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> HashSet<T, RandomState> {\n        Default::default()\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, Default::default()) }\n    }\n}\n\nimpl<T, S> HashSet<T, S> {\n    /// Returns the number of elements the set can hold without reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n    /// assert!(set.capacity() >= 100);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n        self.base.capacity()\n    }\n\n    /// An iterator visiting all elements in arbitrary order.\n    /// The iterator element type is `&'a T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let mut set = HashSet::new();\n    /// set.insert(\"a\");\n    /// set.insert(\"b\");\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in set.iter() {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n        Iter { base: self.base.iter() }\n    }\n\n    /// Returns the number of elements in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert_eq!(v.len(), 0);\n    /// v.insert(1);\n    /// assert_eq!(v.len(), 1);\n    /// ```\n    #[doc(alias = \"length\")]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n        self.base.len()\n    }\n\n    /// Returns `true` if the set contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert!(v.is_empty());\n    /// v.insert(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.base.is_empty()\n    }\n\n    /// Clears the set, returning all elements in an iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert!(!set.is_empty());\n    ///\n    /// // print 1, 2, 3 in an arbitrary order\n    /// for i in set.drain() {\n    ///     println!(\"{}\", i);\n    /// }\n    ///\n    /// assert!(set.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain(&mut self) -> Drain<'_, T> {\n        Drain { base: self.base.drain() }\n    }\n\n    /// Creates an iterator which uses a closure to determine if a value should be removed.\n    ///\n    /// If the closure returns true, then the value is removed and yielded.\n    /// If the closure returns false, the value will remain in the list and will not be yielded\n    /// by the iterator.\n    ///\n    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n    /// values will still be subjected to the closure and removed and dropped if it returns true.\n    ///\n    /// It is unspecified how many more values will be subjected to the closure\n    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n    /// `DrainFilter` itself is leaked.\n    ///\n    /// # Examples\n    ///\n    /// Splitting a set into even and odd values, reusing the original set:\n    ///\n    /// ```\n    /// #![feature(hash_drain_filter)]\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<i32> = (0..8).collect();\n    /// let drained: HashSet<i32> = set.drain_filter(|v| v % 2 == 0).collect();\n    ///\n    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n    /// let mut odds = set.into_iter().collect::<Vec<_>>();\n    /// evens.sort();\n    /// odds.sort();\n    ///\n    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        DrainFilter { base: self.base.drain_filter(pred) }\n    }\n\n    /// Clears the set, removing all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// v.insert(1);\n    /// v.clear();\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n        self.base.clear()\n    }\n\n    /// Creates a new empty hash set which will use the given hasher to hash\n    /// keys.\n    ///\n    /// The hash set is also created with the default initial capacity.\n    ///\n    /// Warning: `hasher` is normally randomly generated, and\n    /// is designed to allow `HashSet`s to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashMap to be useful, see its documentation for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut set = HashSet::with_hasher(s);\n    /// set.insert(2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n        HashSet { base: base::HashSet::with_hasher(hasher) }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity, using\n    /// `hasher` to hash the keys.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// Warning: `hasher` is normally randomly generated, and\n    /// is designed to allow `HashSet`s to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashMap to be useful, see its documentation for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n    /// set.insert(1);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, hasher) }\n    }\n\n    /// Returns a reference to the set's [`BuildHasher`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let hasher = RandomState::new();\n    /// let set: HashSet<i32> = HashSet::with_hasher(hasher);\n    /// let hasher: &RandomState = set.hasher();\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n    pub fn hasher(&self) -> &S {\n        self.base.hasher()\n    }\n}\n\nimpl<T, S> HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashSet`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new allocation size overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.reserve(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.base.reserve(additional)\n    }\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashSet<K, V>`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::HashSet;\n    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.base.try_reserve(additional).map_err(map_try_reserve_error)\n    }\n\n    /// Shrinks the capacity of the set as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to_fit();\n    /// assert!(set.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        self.base.shrink_to_fit()\n    }\n\n    /// Shrinks the capacity of the set with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// If the current capacity is less than the lower limit, this is a no-op.\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to(10);\n    /// assert!(set.capacity() >= 10);\n    /// set.shrink_to(0);\n    /// assert!(set.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.base.shrink_to(min_capacity)\n    }\n\n    /// Visits the values representing the difference,\n    /// i.e., the values that are in `self` but not in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Can be seen as `a - b`.\n    /// for x in a.difference(&b) {\n    ///     println!(\"{}\", x); // Print 1\n    /// }\n    ///\n    /// let diff: HashSet<_> = a.difference(&b).collect();\n    /// assert_eq!(diff, [1].iter().collect());\n    ///\n    /// // Note that difference is not symmetric,\n    /// // and `b - a` means something else:\n    /// let diff: HashSet<_> = b.difference(&a).collect();\n    /// assert_eq!(diff, [4].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n        Difference { iter: self.iter(), other }\n    }\n\n    /// Visits the values representing the symmetric difference,\n    /// i.e., the values that are in `self` or in `other` but not in both.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Print 1, 4 in arbitrary order.\n    /// for x in a.symmetric_difference(&b) {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let diff1: HashSet<_> = a.symmetric_difference(&b).collect();\n    /// let diff2: HashSet<_> = b.symmetric_difference(&a).collect();\n    ///\n    /// assert_eq!(diff1, diff2);\n    /// assert_eq!(diff1, [1, 4].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn symmetric_difference<'a>(\n        &'a self,\n        other: &'a HashSet<T, S>,\n    ) -> SymmetricDifference<'a, T, S> {\n        SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n    }\n\n    /// Visits the values representing the intersection,\n    /// i.e., the values that are both in `self` and `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Print 2, 3 in arbitrary order.\n    /// for x in a.intersection(&b) {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let intersection: HashSet<_> = a.intersection(&b).collect();\n    /// assert_eq!(intersection, [2, 3].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n        if self.len() <= other.len() {\n            Intersection { iter: self.iter(), other }\n        } else {\n            Intersection { iter: other.iter(), other: self }\n        }\n    }\n\n    /// Visits the values representing the union,\n    /// i.e., all the values in `self` or `other`, without duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Print 1, 2, 3, 4 in arbitrary order.\n    /// for x in a.union(&b) {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let union: HashSet<_> = a.union(&b).collect();\n    /// assert_eq!(union, [1, 2, 3, 4].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n        if self.len() >= other.len() {\n            Union { iter: self.iter().chain(other.difference(self)) }\n        } else {\n            Union { iter: other.iter().chain(self.difference(other)) }\n        }\n    }\n\n    /// Returns `true` if the set contains a value.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.contains(&1), true);\n    /// assert_eq!(set.contains(&4), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.contains(value)\n    }\n\n    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.get(&2), Some(&2));\n    /// assert_eq!(set.get(&4), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.get(value)\n    }\n\n    /// Inserts the given `value` into the set if it is not present, then\n    /// returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_set_entry)]\n    ///\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.len(), 3);\n    /// assert_eq!(set.get_or_insert(2), &2);\n    /// assert_eq!(set.get_or_insert(100), &100);\n    /// assert_eq!(set.len(), 4); // 100 was inserted\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n    pub fn get_or_insert(&mut self, value: T) -> &T {\n        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n        self.base.get_or_insert(value)\n    }\n\n    /// Inserts an owned copy of the given `value` into the set if it is not\n    /// present, then returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_set_entry)]\n    ///\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n    ///     .iter().map(|&pet| pet.to_owned()).collect();\n    ///\n    /// assert_eq!(set.len(), 3);\n    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n    ///     let value = set.get_or_insert_owned(pet);\n    ///     assert_eq!(value, pet);\n    /// }\n    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n    pub fn get_or_insert_owned<Q: ?Sized>(&mut self, value: &Q) -> &T\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq + ToOwned<Owned = T>,\n    {\n        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n        self.base.get_or_insert_owned(value)\n    }\n\n    /// Inserts a value computed from `f` into the set if the given `value` is\n    /// not present, then returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_set_entry)]\n    ///\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n    ///     .iter().map(|&pet| pet.to_owned()).collect();\n    ///\n    /// assert_eq!(set.len(), 3);\n    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n    ///     let value = set.get_or_insert_with(pet, str::to_owned);\n    ///     assert_eq!(value, pet);\n    /// }\n    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n    pub fn get_or_insert_with<Q: ?Sized, F>(&mut self, value: &Q, f: F) -> &T\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n        F: FnOnce(&Q) -> T,\n    {\n        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n        self.base.get_or_insert_with(value, f)\n    }\n\n    /// Returns `true` if `self` has no elements in common with `other`.\n    /// This is equivalent to checking for an empty intersection.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let mut b = HashSet::new();\n    ///\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(4);\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(1);\n    /// assert_eq!(a.is_disjoint(&b), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n        if self.len() <= other.len() {\n            self.iter().all(|v| !other.contains(v))\n        } else {\n            other.iter().all(|v| !self.contains(v))\n        }\n    }\n\n    /// Returns `true` if the set is a subset of another,\n    /// i.e., `other` contains at least all the values in `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(2);\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(4);\n    /// assert_eq!(set.is_subset(&sup), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n        if self.len() <= other.len() { self.iter().all(|v| other.contains(v)) } else { false }\n    }\n\n    /// Returns `true` if the set is a superset of another,\n    /// i.e., `self` contains at least all the values in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(0);\n    /// set.insert(1);\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.is_superset(&sub), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n        other.is_subset(self)\n    }\n\n    /// Adds a value to the set.\n    ///\n    /// If the set did not have this value present, `true` is returned.\n    ///\n    /// If the set did have this value present, `false` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.insert(2), true);\n    /// assert_eq!(set.insert(2), false);\n    /// assert_eq!(set.len(), 1);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, value: T) -> bool {\n        self.base.insert(value)\n    }\n\n    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n    /// one. Returns the replaced value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    /// set.insert(Vec::<i32>::new());\n    ///\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 0);\n    /// set.replace(Vec::with_capacity(10));\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn replace(&mut self, value: T) -> Option<T> {\n        self.base.replace(value)\n    }\n\n    /// Removes a value from the set. Returns whether the value was\n    /// present in the set.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.remove(&2), true);\n    /// assert_eq!(set.remove(&2), false);\n    /// ```\n    #[doc(alias = \"delete\")]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.remove(value)\n    }\n\n    /// Removes and returns the value in the set, if any, that is equal to the given one.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.take(&2), Some(2));\n    /// assert_eq!(set.take(&2), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.take(value)\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let xs = [1, 2, 3, 4, 5, 6];\n    /// let mut set: HashSet<i32> = xs.iter().cloned().collect();\n    /// set.retain(|&k| k % 2 == 0);\n    /// assert_eq!(set.len(), 3);\n    /// ```\n    #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n    pub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n        self.base.retain(f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for HashSet<T, S>\nwhere\n    T: Clone,\n    S: Clone,\n{\n    #[inline]\n    fn clone(&self) -> Self {\n        Self { base: self.base.clone() }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, other: &Self) {\n        self.base.clone_from(&other.base);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> PartialEq for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    fn eq(&self, other: &HashSet<T, S>) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter().all(|key| other.contains(key))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Eq for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> fmt::Debug for HashSet<T, S>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_set().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> FromIterator<T> for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher + Default,\n{\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> HashSet<T, S> {\n        let mut set = HashSet::with_hasher(Default::default());\n        set.extend(iter);\n        set\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Extend<T> for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        self.base.extend(iter);\n    }\n\n    #[inline]\n    fn extend_one(&mut self, item: T) {\n        self.base.insert(item);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        self.base.extend_reserve(additional);\n    }\n}\n\n#[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\nimpl<'a, T, S> Extend<&'a T> for HashSet<T, S>\nwhere\n    T: 'a + Eq + Hash + Copy,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n        self.extend(iter.into_iter().cloned());\n    }\n\n    #[inline]\n    fn extend_one(&mut self, &item: &'a T) {\n        self.base.insert(item);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<T>::extend_reserve(self, additional)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Default for HashSet<T, S>\nwhere\n    S: Default,\n{\n    /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n    #[inline]\n    fn default() -> HashSet<T, S> {\n        HashSet { base: Default::default() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> BitOr<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a | &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 3, 4, 5];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.union(rhs).cloned().collect()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> BitAnd<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n    ///\n    /// let set = &a & &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [2, 3];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.intersection(rhs).cloned().collect()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> BitXor<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a ^ &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 4, 5];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.symmetric_difference(rhs).cloned().collect()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Sub<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a - &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.difference(rhs).cloned().collect()\n    }\n}\n\n/// An iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`iter`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`iter`]: HashSet::iter\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n///\n/// let mut iter = a.iter();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, K: 'a> {\n    base: base::Iter<'a, K>,\n}\n\n/// An owning iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashSet`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`into_iter`]: IntoIterator::into_iter\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n///\n/// let mut iter = a.into_iter();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<K> {\n    base: base::IntoIter<K>,\n}\n\n/// A draining iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`drain`]: HashSet::drain\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let mut a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n///\n/// let mut drain = a.drain();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Drain<'a, K: 'a> {\n    base: base::Drain<'a, K>,\n}\n\n/// A draining, filtering iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`drain_filter`] method on [`HashSet`].\n///\n/// [`drain_filter`]: HashSet::drain_filter\n///\n/// # Examples\n///\n/// ```\n/// #![feature(hash_drain_filter)]\n///\n/// use std::collections::HashSet;\n///\n/// let mut a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n///\n/// let mut drain_filtered = a.drain_filter(|v| v % 2 == 0);\n/// ```\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\npub struct DrainFilter<'a, K, F>\nwhere\n    F: FnMut(&K) -> bool,\n{\n    base: base::DrainFilter<'a, K, F>,\n}\n\n/// A lazy iterator producing elements in the intersection of `HashSet`s.\n///\n/// This `struct` is created by the [`intersection`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`intersection`]: HashSet::intersection\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n///\n/// let mut intersection = a.intersection(&b);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Intersection<'a, T: 'a, S: 'a> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S>,\n}\n\n/// A lazy iterator producing elements in the difference of `HashSet`s.\n///\n/// This `struct` is created by the [`difference`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`difference`]: HashSet::difference\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n///\n/// let mut difference = a.difference(&b);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Difference<'a, T: 'a, S: 'a> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S>,\n}\n\n/// A lazy iterator producing elements in the symmetric difference of `HashSet`s.\n///\n/// This `struct` is created by the [`symmetric_difference`] method on\n/// [`HashSet`]. See its documentation for more.\n///\n/// [`symmetric_difference`]: HashSet::symmetric_difference\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n///\n/// let mut intersection = a.symmetric_difference(&b);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>,\n}\n\n/// A lazy iterator producing elements in the union of `HashSet`s.\n///\n/// This `struct` is created by the [`union`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`union`]: HashSet::union\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n///\n/// let mut union_iter = a.union(&b);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Union<'a, T: 'a, S: 'a> {\n    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> IntoIterator for &'a HashSet<T, S> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    #[inline]\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> IntoIterator for HashSet<T, S> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out\n    /// of the set in arbitrary order. The set cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let mut set = HashSet::new();\n    /// set.insert(\"a\".to_string());\n    /// set.insert(\"b\".to_string());\n    ///\n    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n    /// let v: Vec<String> = set.into_iter().collect();\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in &v {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter { base: self.base.into_iter() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> Clone for Iter<'_, K> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Iter { base: self.base.clone() }\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K> Iterator for Iter<'a, K> {\n    type Item = &'a K;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a K> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> ExactSizeIterator for Iter<'_, K> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K> FusedIterator for Iter<'_, K> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: fmt::Debug> fmt::Debug for Iter<'_, K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> Iterator for IntoIter<K> {\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> ExactSizeIterator for IntoIter<K> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K> FusedIterator for IntoIter<K> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: fmt::Debug> fmt::Debug for IntoIter<K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.base, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K> Iterator for Drain<'a, K> {\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> ExactSizeIterator for Drain<'_, K> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K> FusedIterator for Drain<'_, K> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.base, f)\n    }\n}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<K, F> Iterator for DrainFilter<'_, K, F>\nwhere\n    F: FnMut(&K) -> bool,\n{\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<K, F> FusedIterator for DrainFilter<'_, K, F> where F: FnMut(&K) -> bool {}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<'a, K, F> fmt::Debug for DrainFilter<'a, K, F>\nwhere\n    F: FnMut(&K) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"DrainFilter\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for Intersection<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Intersection { iter: self.iter.clone(), ..*self }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for Intersection<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n        loop {\n            let elt = self.iter.next()?;\n            if self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for Intersection<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for Intersection<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for Difference<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Difference { iter: self.iter.clone(), ..*self }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for Difference<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n        loop {\n            let elt = self.iter.next()?;\n            if !self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper)\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for Difference<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for Difference<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for SymmetricDifference<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n        SymmetricDifference { iter: self.iter.clone() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n        self.iter.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for SymmetricDifference<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for SymmetricDifference<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for Union<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Union { iter: self.iter.clone() }\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for Union<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for Union<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for Union<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n        self.iter.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[allow(dead_code)]\nfn assert_covariance() {\n    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> {\n        v\n    }\n    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> {\n        v\n    }\n    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> {\n        v\n    }\n    fn difference<'a, 'new>(\n        v: Difference<'a, &'static str, RandomState>,\n    ) -> Difference<'a, &'new str, RandomState> {\n        v\n    }\n    fn symmetric_difference<'a, 'new>(\n        v: SymmetricDifference<'a, &'static str, RandomState>,\n    ) -> SymmetricDifference<'a, &'new str, RandomState> {\n        v\n    }\n    fn intersection<'a, 'new>(\n        v: Intersection<'a, &'static str, RandomState>,\n    ) -> Intersection<'a, &'new str, RandomState> {\n        v\n    }\n    fn union<'a, 'new>(\n        v: Union<'a, &'static str, RandomState>,\n    ) -> Union<'a, &'new str, RandomState> {\n        v\n    }\n    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n        d\n    }\n}\n"],["2540","use super::Entry::{Occupied, Vacant};\nuse super::HashMap;\nuse super::RandomState;\nuse crate::cell::RefCell;\nuse rand::{thread_rng, Rng};\nuse realstd::collections::TryReserveError::*;\n\n// https://github.com/rust-lang/rust/issues/62301\nfn _assert_hashmap_is_unwind_safe() {\n    fn assert_unwind_safe<T: crate::panic::UnwindSafe>() {}\n    assert_unwind_safe::<HashMap<(), crate::cell::UnsafeCell<()>>>();\n}\n\n#[test]\nfn test_zero_capacities() {\n    type HM = HashMap<i32, i32>;\n\n    let m = HM::new();\n    assert_eq!(m.capacity(), 0);\n\n    let m = HM::default();\n    assert_eq!(m.capacity(), 0);\n\n    let m = HM::with_hasher(RandomState::new());\n    assert_eq!(m.capacity(), 0);\n\n    let m = HM::with_capacity(0);\n    assert_eq!(m.capacity(), 0);\n\n    let m = HM::with_capacity_and_hasher(0, RandomState::new());\n    assert_eq!(m.capacity(), 0);\n\n    let mut m = HM::new();\n    m.insert(1, 1);\n    m.insert(2, 2);\n    m.remove(&1);\n    m.remove(&2);\n    m.shrink_to_fit();\n    assert_eq!(m.capacity(), 0);\n\n    let mut m = HM::new();\n    m.reserve(0);\n    assert_eq!(m.capacity(), 0);\n}\n\n#[test]\nfn test_create_capacity_zero() {\n    let mut m = HashMap::with_capacity(0);\n\n    assert!(m.insert(1, 1).is_none());\n\n    assert!(m.contains_key(&1));\n    assert!(!m.contains_key(&0));\n}\n\n#[test]\nfn test_insert() {\n    let mut m = HashMap::new();\n    assert_eq!(m.len(), 0);\n    assert!(m.insert(1, 2).is_none());\n    assert_eq!(m.len(), 1);\n    assert!(m.insert(2, 4).is_none());\n    assert_eq!(m.len(), 2);\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert_eq!(*m.get(&2).unwrap(), 4);\n}\n\n#[test]\nfn test_clone() {\n    let mut m = HashMap::new();\n    assert_eq!(m.len(), 0);\n    assert!(m.insert(1, 2).is_none());\n    assert_eq!(m.len(), 1);\n    assert!(m.insert(2, 4).is_none());\n    assert_eq!(m.len(), 2);\n    let m2 = m.clone();\n    assert_eq!(*m2.get(&1).unwrap(), 2);\n    assert_eq!(*m2.get(&2).unwrap(), 4);\n    assert_eq!(m2.len(), 2);\n}\n\nthread_local! { static DROP_VECTOR: RefCell<Vec<i32>> = RefCell::new(Vec::new()) }\n\n#[derive(Hash, PartialEq, Eq)]\nstruct Droppable {\n    k: usize,\n}\n\nimpl Droppable {\n    fn new(k: usize) -> Droppable {\n        DROP_VECTOR.with(|slot| {\n            slot.borrow_mut()[k] += 1;\n        });\n\n        Droppable { k }\n    }\n}\n\nimpl Drop for Droppable {\n    fn drop(&mut self) {\n        DROP_VECTOR.with(|slot| {\n            slot.borrow_mut()[self.k] -= 1;\n        });\n    }\n}\n\nimpl Clone for Droppable {\n    fn clone(&self) -> Droppable {\n        Droppable::new(self.k)\n    }\n}\n\n#[test]\nfn test_drops() {\n    DROP_VECTOR.with(|slot| {\n        *slot.borrow_mut() = vec![0; 200];\n    });\n\n    {\n        let mut m = HashMap::new();\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 0);\n            }\n        });\n\n        for i in 0..100 {\n            let d1 = Droppable::new(i);\n            let d2 = Droppable::new(i + 100);\n            m.insert(d1, d2);\n        }\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 1);\n            }\n        });\n\n        for i in 0..50 {\n            let k = Droppable::new(i);\n            let v = m.remove(&k);\n\n            assert!(v.is_some());\n\n            DROP_VECTOR.with(|v| {\n                assert_eq!(v.borrow()[i], 1);\n                assert_eq!(v.borrow()[i + 100], 1);\n            });\n        }\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..50 {\n                assert_eq!(v.borrow()[i], 0);\n                assert_eq!(v.borrow()[i + 100], 0);\n            }\n\n            for i in 50..100 {\n                assert_eq!(v.borrow()[i], 1);\n                assert_eq!(v.borrow()[i + 100], 1);\n            }\n        });\n    }\n\n    DROP_VECTOR.with(|v| {\n        for i in 0..200 {\n            assert_eq!(v.borrow()[i], 0);\n        }\n    });\n}\n\n#[test]\nfn test_into_iter_drops() {\n    DROP_VECTOR.with(|v| {\n        *v.borrow_mut() = vec![0; 200];\n    });\n\n    let hm = {\n        let mut hm = HashMap::new();\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 0);\n            }\n        });\n\n        for i in 0..100 {\n            let d1 = Droppable::new(i);\n            let d2 = Droppable::new(i + 100);\n            hm.insert(d1, d2);\n        }\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 1);\n            }\n        });\n\n        hm\n    };\n\n    // By the way, ensure that cloning doesn't screw up the dropping.\n    drop(hm.clone());\n\n    {\n        let mut half = hm.into_iter().take(50);\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 1);\n            }\n        });\n\n        for _ in half.by_ref() {}\n\n        DROP_VECTOR.with(|v| {\n            let nk = (0..100).filter(|&i| v.borrow()[i] == 1).count();\n\n            let nv = (0..100).filter(|&i| v.borrow()[i + 100] == 1).count();\n\n            assert_eq!(nk, 50);\n            assert_eq!(nv, 50);\n        });\n    };\n\n    DROP_VECTOR.with(|v| {\n        for i in 0..200 {\n            assert_eq!(v.borrow()[i], 0);\n        }\n    });\n}\n\n#[test]\nfn test_empty_remove() {\n    let mut m: HashMap<i32, bool> = HashMap::new();\n    assert_eq!(m.remove(&0), None);\n}\n\n#[test]\nfn test_empty_entry() {\n    let mut m: HashMap<i32, bool> = HashMap::new();\n    match m.entry(0) {\n        Occupied(_) => panic!(),\n        Vacant(_) => {}\n    }\n    assert!(*m.entry(0).or_insert(true));\n    assert_eq!(m.len(), 1);\n}\n\n#[test]\nfn test_empty_iter() {\n    let mut m: HashMap<i32, bool> = HashMap::new();\n    assert_eq!(m.drain().next(), None);\n    assert_eq!(m.keys().next(), None);\n    assert_eq!(m.values().next(), None);\n    assert_eq!(m.values_mut().next(), None);\n    assert_eq!(m.iter().next(), None);\n    assert_eq!(m.iter_mut().next(), None);\n    assert_eq!(m.len(), 0);\n    assert!(m.is_empty());\n    assert_eq!(m.into_iter().next(), None);\n}\n\n#[test]\nfn test_lots_of_insertions() {\n    let mut m = HashMap::new();\n\n    // Try this a few times to make sure we never screw up the hashmap's\n    // internal state.\n    for _ in 0..10 {\n        assert!(m.is_empty());\n\n        for i in 1..1001 {\n            assert!(m.insert(i, i).is_none());\n\n            for j in 1..=i {\n                let r = m.get(&j);\n                assert_eq!(r, Some(&j));\n            }\n\n            for j in i + 1..1001 {\n                let r = m.get(&j);\n                assert_eq!(r, None);\n            }\n        }\n\n        for i in 1001..2001 {\n            assert!(!m.contains_key(&i));\n        }\n\n        // remove forwards\n        for i in 1..1001 {\n            assert!(m.remove(&i).is_some());\n\n            for j in 1..=i {\n                assert!(!m.contains_key(&j));\n            }\n\n            for j in i + 1..1001 {\n                assert!(m.contains_key(&j));\n            }\n        }\n\n        for i in 1..1001 {\n            assert!(!m.contains_key(&i));\n        }\n\n        for i in 1..1001 {\n            assert!(m.insert(i, i).is_none());\n        }\n\n        // remove backwards\n        for i in (1..1001).rev() {\n            assert!(m.remove(&i).is_some());\n\n            for j in i..1001 {\n                assert!(!m.contains_key(&j));\n            }\n\n            for j in 1..i {\n                assert!(m.contains_key(&j));\n            }\n        }\n    }\n}\n\n#[test]\nfn test_find_mut() {\n    let mut m = HashMap::new();\n    assert!(m.insert(1, 12).is_none());\n    assert!(m.insert(2, 8).is_none());\n    assert!(m.insert(5, 14).is_none());\n    let new = 100;\n    match m.get_mut(&5) {\n        None => panic!(),\n        Some(x) => *x = new,\n    }\n    assert_eq!(m.get(&5), Some(&new));\n}\n\n#[test]\nfn test_insert_overwrite() {\n    let mut m = HashMap::new();\n    assert!(m.insert(1, 2).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert!(!m.insert(1, 3).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 3);\n}\n\n#[test]\nfn test_insert_conflicts() {\n    let mut m = HashMap::with_capacity(4);\n    assert!(m.insert(1, 2).is_none());\n    assert!(m.insert(5, 3).is_none());\n    assert!(m.insert(9, 4).is_none());\n    assert_eq!(*m.get(&9).unwrap(), 4);\n    assert_eq!(*m.get(&5).unwrap(), 3);\n    assert_eq!(*m.get(&1).unwrap(), 2);\n}\n\n#[test]\nfn test_conflict_remove() {\n    let mut m = HashMap::with_capacity(4);\n    assert!(m.insert(1, 2).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert!(m.insert(5, 3).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert_eq!(*m.get(&5).unwrap(), 3);\n    assert!(m.insert(9, 4).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert_eq!(*m.get(&5).unwrap(), 3);\n    assert_eq!(*m.get(&9).unwrap(), 4);\n    assert!(m.remove(&1).is_some());\n    assert_eq!(*m.get(&9).unwrap(), 4);\n    assert_eq!(*m.get(&5).unwrap(), 3);\n}\n\n#[test]\nfn test_is_empty() {\n    let mut m = HashMap::with_capacity(4);\n    assert!(m.insert(1, 2).is_none());\n    assert!(!m.is_empty());\n    assert!(m.remove(&1).is_some());\n    assert!(m.is_empty());\n}\n\n#[test]\nfn test_remove() {\n    let mut m = HashMap::new();\n    m.insert(1, 2);\n    assert_eq!(m.remove(&1), Some(2));\n    assert_eq!(m.remove(&1), None);\n}\n\n#[test]\nfn test_remove_entry() {\n    let mut m = HashMap::new();\n    m.insert(1, 2);\n    assert_eq!(m.remove_entry(&1), Some((1, 2)));\n    assert_eq!(m.remove(&1), None);\n}\n\n#[test]\nfn test_iterate() {\n    let mut m = HashMap::with_capacity(4);\n    for i in 0..32 {\n        assert!(m.insert(i, i * 2).is_none());\n    }\n    assert_eq!(m.len(), 32);\n\n    let mut observed: u32 = 0;\n\n    for (k, v) in &m {\n        assert_eq!(*v, *k * 2);\n        observed |= 1 << *k;\n    }\n    assert_eq!(observed, 0xFFFF_FFFF);\n}\n\n#[test]\nfn test_keys() {\n    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n    let map: HashMap<_, _> = vec.into_iter().collect();\n    let keys: Vec<_> = map.keys().cloned().collect();\n    assert_eq!(keys.len(), 3);\n    assert!(keys.contains(&1));\n    assert!(keys.contains(&2));\n    assert!(keys.contains(&3));\n}\n\n#[test]\nfn test_values() {\n    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n    let map: HashMap<_, _> = vec.into_iter().collect();\n    let values: Vec<_> = map.values().cloned().collect();\n    assert_eq!(values.len(), 3);\n    assert!(values.contains(&'a'));\n    assert!(values.contains(&'b'));\n    assert!(values.contains(&'c'));\n}\n\n#[test]\nfn test_values_mut() {\n    let vec = vec![(1, 1), (2, 2), (3, 3)];\n    let mut map: HashMap<_, _> = vec.into_iter().collect();\n    for value in map.values_mut() {\n        *value = (*value) * 2\n    }\n    let values: Vec<_> = map.values().cloned().collect();\n    assert_eq!(values.len(), 3);\n    assert!(values.contains(&2));\n    assert!(values.contains(&4));\n    assert!(values.contains(&6));\n}\n\n#[test]\nfn test_into_keys() {\n    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n    let map: HashMap<_, _> = vec.into_iter().collect();\n    let keys: Vec<_> = map.into_keys().collect();\n\n    assert_eq!(keys.len(), 3);\n    assert!(keys.contains(&1));\n    assert!(keys.contains(&2));\n    assert!(keys.contains(&3));\n}\n\n#[test]\nfn test_into_values() {\n    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n    let map: HashMap<_, _> = vec.into_iter().collect();\n    let values: Vec<_> = map.into_values().collect();\n\n    assert_eq!(values.len(), 3);\n    assert!(values.contains(&'a'));\n    assert!(values.contains(&'b'));\n    assert!(values.contains(&'c'));\n}\n\n#[test]\nfn test_find() {\n    let mut m = HashMap::new();\n    assert!(m.get(&1).is_none());\n    m.insert(1, 2);\n    match m.get(&1) {\n        None => panic!(),\n        Some(v) => assert_eq!(*v, 2),\n    }\n}\n\n#[test]\nfn test_eq() {\n    let mut m1 = HashMap::new();\n    m1.insert(1, 2);\n    m1.insert(2, 3);\n    m1.insert(3, 4);\n\n    let mut m2 = HashMap::new();\n    m2.insert(1, 2);\n    m2.insert(2, 3);\n\n    assert!(m1 != m2);\n\n    m2.insert(3, 4);\n\n    assert_eq!(m1, m2);\n}\n\n#[test]\nfn test_show() {\n    let mut map = HashMap::new();\n    let empty: HashMap<i32, i32> = HashMap::new();\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n\n    let map_str = format!(\"{:?}\", map);\n\n    assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n    assert_eq!(format!(\"{:?}\", empty), \"{}\");\n}\n\n#[test]\nfn test_reserve_shrink_to_fit() {\n    let mut m = HashMap::new();\n    m.insert(0, 0);\n    m.remove(&0);\n    assert!(m.capacity() >= m.len());\n    for i in 0..128 {\n        m.insert(i, i);\n    }\n    m.reserve(256);\n\n    let usable_cap = m.capacity();\n    for i in 128..(128 + 256) {\n        m.insert(i, i);\n        assert_eq!(m.capacity(), usable_cap);\n    }\n\n    for i in 100..(128 + 256) {\n        assert_eq!(m.remove(&i), Some(i));\n    }\n    m.shrink_to_fit();\n\n    assert_eq!(m.len(), 100);\n    assert!(!m.is_empty());\n    assert!(m.capacity() >= m.len());\n\n    for i in 0..100 {\n        assert_eq!(m.remove(&i), Some(i));\n    }\n    m.shrink_to_fit();\n    m.insert(0, 0);\n\n    assert_eq!(m.len(), 1);\n    assert!(m.capacity() >= m.len());\n    assert_eq!(m.remove(&0), Some(0));\n}\n\n#[test]\nfn test_from_iter() {\n    let xs = [(1, 1), (2, 2), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    for &(k, v) in &xs {\n        assert_eq!(map.get(&k), Some(&v));\n    }\n\n    assert_eq!(map.iter().len(), xs.len() - 1);\n}\n\n#[test]\nfn test_size_hint() {\n    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let mut iter = map.iter();\n\n    for _ in iter.by_ref().take(3) {}\n\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n}\n\n#[test]\nfn test_iter_len() {\n    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let mut iter = map.iter();\n\n    for _ in iter.by_ref().take(3) {}\n\n    assert_eq!(iter.len(), 3);\n}\n\n#[test]\nfn test_mut_size_hint() {\n    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let mut iter = map.iter_mut();\n\n    for _ in iter.by_ref().take(3) {}\n\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n}\n\n#[test]\nfn test_iter_mut_len() {\n    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let mut iter = map.iter_mut();\n\n    for _ in iter.by_ref().take(3) {}\n\n    assert_eq!(iter.len(), 3);\n}\n\n#[test]\nfn test_index() {\n    let mut map = HashMap::new();\n\n    map.insert(1, 2);\n    map.insert(2, 1);\n    map.insert(3, 4);\n\n    assert_eq!(map[&2], 1);\n}\n\n#[test]\n#[should_panic]\nfn test_index_nonexistent() {\n    let mut map = HashMap::new();\n\n    map.insert(1, 2);\n    map.insert(2, 1);\n    map.insert(3, 4);\n\n    map[&4];\n}\n\n#[test]\nfn test_entry() {\n    let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n\n    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    // Existing key (insert)\n    match map.entry(1) {\n        Vacant(_) => unreachable!(),\n        Occupied(mut view) => {\n            assert_eq!(view.get(), &10);\n            assert_eq!(view.insert(100), 10);\n        }\n    }\n    assert_eq!(map.get(&1).unwrap(), &100);\n    assert_eq!(map.len(), 6);\n\n    // Existing key (update)\n    match map.entry(2) {\n        Vacant(_) => unreachable!(),\n        Occupied(mut view) => {\n            let v = view.get_mut();\n            let new_v = (*v) * 10;\n            *v = new_v;\n        }\n    }\n    assert_eq!(map.get(&2).unwrap(), &200);\n    assert_eq!(map.len(), 6);\n\n    // Existing key (take)\n    match map.entry(3) {\n        Vacant(_) => unreachable!(),\n        Occupied(view) => {\n            assert_eq!(view.remove(), 30);\n        }\n    }\n    assert_eq!(map.get(&3), None);\n    assert_eq!(map.len(), 5);\n\n    // Inexistent key (insert)\n    match map.entry(10) {\n        Occupied(_) => unreachable!(),\n        Vacant(view) => {\n            assert_eq!(*view.insert(1000), 1000);\n        }\n    }\n    assert_eq!(map.get(&10).unwrap(), &1000);\n    assert_eq!(map.len(), 6);\n}\n\n#[test]\nfn test_entry_take_doesnt_corrupt() {\n    #![allow(deprecated)] //rand\n    // Test for #19292\n    fn check(m: &HashMap<i32, ()>) {\n        for k in m.keys() {\n            assert!(m.contains_key(k), \"{} is in keys() but not in the map?\", k);\n        }\n    }\n\n    let mut m = HashMap::new();\n    let mut rng = thread_rng();\n\n    // Populate the map with some items.\n    for _ in 0..50 {\n        let x = rng.gen_range(-10, 10);\n        m.insert(x, ());\n    }\n\n    for _ in 0..1000 {\n        let x = rng.gen_range(-10, 10);\n        match m.entry(x) {\n            Vacant(_) => {}\n            Occupied(e) => {\n                e.remove();\n            }\n        }\n\n        check(&m);\n    }\n}\n\n#[test]\nfn test_extend_ref() {\n    let mut a = HashMap::new();\n    a.insert(1, \"one\");\n    let mut b = HashMap::new();\n    b.insert(2, \"two\");\n    b.insert(3, \"three\");\n\n    a.extend(&b);\n\n    assert_eq!(a.len(), 3);\n    assert_eq!(a[&1], \"one\");\n    assert_eq!(a[&2], \"two\");\n    assert_eq!(a[&3], \"three\");\n}\n\n#[test]\nfn test_capacity_not_less_than_len() {\n    let mut a = HashMap::new();\n    let mut item = 0;\n\n    for _ in 0..116 {\n        a.insert(item, 0);\n        item += 1;\n    }\n\n    assert!(a.capacity() > a.len());\n\n    let free = a.capacity() - a.len();\n    for _ in 0..free {\n        a.insert(item, 0);\n        item += 1;\n    }\n\n    assert_eq!(a.len(), a.capacity());\n\n    // Insert at capacity should cause allocation.\n    a.insert(item, 0);\n    assert!(a.capacity() > a.len());\n}\n\n#[test]\nfn test_occupied_entry_key() {\n    let mut a = HashMap::new();\n    let key = \"hello there\";\n    let value = \"value goes here\";\n    assert!(a.is_empty());\n    a.insert(key, value);\n    assert_eq!(a.len(), 1);\n    assert_eq!(a[key], value);\n\n    match a.entry(key) {\n        Vacant(_) => panic!(),\n        Occupied(e) => assert_eq!(key, *e.key()),\n    }\n    assert_eq!(a.len(), 1);\n    assert_eq!(a[key], value);\n}\n\n#[test]\nfn test_vacant_entry_key() {\n    let mut a = HashMap::new();\n    let key = \"hello there\";\n    let value = \"value goes here\";\n\n    assert!(a.is_empty());\n    match a.entry(key) {\n        Occupied(_) => panic!(),\n        Vacant(e) => {\n            assert_eq!(key, *e.key());\n            e.insert(value);\n        }\n    }\n    assert_eq!(a.len(), 1);\n    assert_eq!(a[key], value);\n}\n\n#[test]\nfn test_retain() {\n    let mut map: HashMap<i32, i32> = (0..100).map(|x| (x, x * 10)).collect();\n\n    map.retain(|&k, _| k % 2 == 0);\n    assert_eq!(map.len(), 50);\n    assert_eq!(map[&2], 20);\n    assert_eq!(map[&4], 40);\n    assert_eq!(map[&6], 60);\n}\n\n#[test]\nfn test_try_reserve() {\n    let mut empty_bytes: HashMap<u8, u8> = HashMap::new();\n\n    const MAX_USIZE: usize = usize::MAX;\n\n    if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n    } else {\n        panic!(\"usize::MAX should trigger an overflow!\");\n    }\n\n    if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n    } else {\n        panic!(\"usize::MAX / 8 should trigger an OOM!\")\n    }\n}\n\n#[test]\nfn test_raw_entry() {\n    use super::RawEntryMut::{Occupied, Vacant};\n\n    let xs = [(1i32, 10i32), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n\n    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let compute_hash = |map: &HashMap<i32, i32>, k: i32| -> u64 {\n        use core::hash::{BuildHasher, Hash, Hasher};\n\n        let mut hasher = map.hasher().build_hasher();\n        k.hash(&mut hasher);\n        hasher.finish()\n    };\n\n    // Existing key (insert)\n    match map.raw_entry_mut().from_key(&1) {\n        Vacant(_) => unreachable!(),\n        Occupied(mut view) => {\n            assert_eq!(view.get(), &10);\n            assert_eq!(view.insert(100), 10);\n        }\n    }\n    let hash1 = compute_hash(&map, 1);\n    assert_eq!(map.raw_entry().from_key(&1).unwrap(), (&1, &100));\n    assert_eq!(map.raw_entry().from_hash(hash1, |k| *k == 1).unwrap(), (&1, &100));\n    assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash1, &1).unwrap(), (&1, &100));\n    assert_eq!(map.len(), 6);\n\n    // Existing key (update)\n    match map.raw_entry_mut().from_key(&2) {\n        Vacant(_) => unreachable!(),\n        Occupied(mut view) => {\n            let v = view.get_mut();\n            let new_v = (*v) * 10;\n            *v = new_v;\n        }\n    }\n    let hash2 = compute_hash(&map, 2);\n    assert_eq!(map.raw_entry().from_key(&2).unwrap(), (&2, &200));\n    assert_eq!(map.raw_entry().from_hash(hash2, |k| *k == 2).unwrap(), (&2, &200));\n    assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash2, &2).unwrap(), (&2, &200));\n    assert_eq!(map.len(), 6);\n\n    // Existing key (take)\n    let hash3 = compute_hash(&map, 3);\n    match map.raw_entry_mut().from_key_hashed_nocheck(hash3, &3) {\n        Vacant(_) => unreachable!(),\n        Occupied(view) => {\n            assert_eq!(view.remove_entry(), (3, 30));\n        }\n    }\n    assert_eq!(map.raw_entry().from_key(&3), None);\n    assert_eq!(map.raw_entry().from_hash(hash3, |k| *k == 3), None);\n    assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash3, &3), None);\n    assert_eq!(map.len(), 5);\n\n    // Nonexistent key (insert)\n    match map.raw_entry_mut().from_key(&10) {\n        Occupied(_) => unreachable!(),\n        Vacant(view) => {\n            assert_eq!(view.insert(10, 1000), (&mut 10, &mut 1000));\n        }\n    }\n    assert_eq!(map.raw_entry().from_key(&10).unwrap(), (&10, &1000));\n    assert_eq!(map.len(), 6);\n\n    // Ensure all lookup methods produce equivalent results.\n    for k in 0..12 {\n        let hash = compute_hash(&map, k);\n        let v = map.get(&k).cloned();\n        let kv = v.as_ref().map(|v| (&k, v));\n\n        assert_eq!(map.raw_entry().from_key(&k), kv);\n        assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n\n        match map.raw_entry_mut().from_key(&k) {\n            Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n            Vacant(_) => assert_eq!(v, None),\n        }\n        match map.raw_entry_mut().from_key_hashed_nocheck(hash, &k) {\n            Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n            Vacant(_) => assert_eq!(v, None),\n        }\n        match map.raw_entry_mut().from_hash(hash, |q| *q == k) {\n            Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n            Vacant(_) => assert_eq!(v, None),\n        }\n    }\n}\n\nmod test_drain_filter {\n    use super::*;\n\n    use crate::panic::{catch_unwind, AssertUnwindSafe};\n    use crate::sync::atomic::{AtomicUsize, Ordering};\n\n    trait EqSorted: Iterator {\n        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool;\n    }\n\n    impl<T: Iterator> EqSorted for T\n    where\n        T::Item: Eq + Ord,\n    {\n        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool {\n            let mut v: Vec<_> = self.collect();\n            v.sort_unstable();\n            v.into_iter().eq(other)\n        }\n    }\n\n    #[test]\n    fn empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn consuming_nothing() {\n        let pairs = (0..3).map(|i| (i, i));\n        let mut map: HashMap<_, _> = pairs.collect();\n        assert!(map.drain_filter(|_, _| false).eq_sorted(crate::iter::empty()));\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn consuming_all() {\n        let pairs = (0..3).map(|i| (i, i));\n        let mut map: HashMap<_, _> = pairs.clone().collect();\n        assert!(map.drain_filter(|_, _| true).eq_sorted(pairs));\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn mutating_and_keeping() {\n        let pairs = (0..3).map(|i| (i, i));\n        let mut map: HashMap<_, _> = pairs.collect();\n        assert!(\n            map.drain_filter(|_, v| {\n                *v += 6;\n                false\n            })\n            .eq_sorted(crate::iter::empty())\n        );\n        assert!(map.keys().copied().eq_sorted(0..3));\n        assert!(map.values().copied().eq_sorted(6..9));\n    }\n\n    #[test]\n    fn mutating_and_removing() {\n        let pairs = (0..3).map(|i| (i, i));\n        let mut map: HashMap<_, _> = pairs.collect();\n        assert!(\n            map.drain_filter(|_, v| {\n                *v += 6;\n                true\n            })\n            .eq_sorted((0..3).map(|i| (i, i + 6)))\n        );\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn drop_panic_leak() {\n        static PREDS: AtomicUsize = AtomicUsize::new(0);\n        static DROPS: AtomicUsize = AtomicUsize::new(0);\n\n        struct D;\n        impl Drop for D {\n            fn drop(&mut self) {\n                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n                    panic!(\"panic in `drop`\");\n                }\n            }\n        }\n\n        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n\n        catch_unwind(move || {\n            drop(map.drain_filter(|_, _| {\n                PREDS.fetch_add(1, Ordering::SeqCst);\n                true\n            }))\n        })\n        .unwrap_err();\n\n        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n    }\n\n    #[test]\n    fn pred_panic_leak() {\n        static PREDS: AtomicUsize = AtomicUsize::new(0);\n        static DROPS: AtomicUsize = AtomicUsize::new(0);\n\n        struct D;\n        impl Drop for D {\n            fn drop(&mut self) {\n                DROPS.fetch_add(1, Ordering::SeqCst);\n            }\n        }\n\n        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n\n        catch_unwind(AssertUnwindSafe(|| {\n            drop(map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n                0 => true,\n                _ => panic!(),\n            }))\n        }))\n        .unwrap_err();\n\n        assert_eq!(PREDS.load(Ordering::SeqCst), 2);\n        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n        assert_eq!(map.len(), 2);\n    }\n\n    // Same as above, but attempt to use the iterator again after the panic in the predicate\n    #[test]\n    fn pred_panic_reuse() {\n        static PREDS: AtomicUsize = AtomicUsize::new(0);\n        static DROPS: AtomicUsize = AtomicUsize::new(0);\n\n        struct D;\n        impl Drop for D {\n            fn drop(&mut self) {\n                DROPS.fetch_add(1, Ordering::SeqCst);\n            }\n        }\n\n        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n\n        {\n            let mut it = map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n                0 => true,\n                _ => panic!(),\n            });\n            catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n            // Iterator behaviour after a panic is explicitly unspecified,\n            // so this is just the current implementation:\n            let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n            assert!(result.is_err());\n        }\n\n        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n        assert_eq!(map.len(), 2);\n    }\n}\n"],["2541","// ignore-tidy-filelength\n\n#[cfg(test)]\nmod tests;\n\nuse self::Entry::*;\n\nuse hashbrown::hash_map as base;\n\nuse crate::borrow::Borrow;\nuse crate::cell::Cell;\nuse crate::collections::TryReserveError;\nuse crate::fmt::{self, Debug};\n#[allow(deprecated)]\nuse crate::hash::{BuildHasher, Hash, Hasher, SipHasher13};\nuse crate::iter::{FromIterator, FusedIterator};\nuse crate::ops::Index;\nuse crate::sys;\n\n/// A [hash map] implemented with quadratic probing and SIMD lookup.\n///\n/// By default, `HashMap` uses a hashing algorithm selected to provide\n/// resistance against HashDoS attacks. The algorithm is randomly seeded, and a\n/// reasonable best-effort is made to generate this seed from a high quality,\n/// secure source of randomness provided by the host without blocking the\n/// program. Because of this, the randomness of the seed depends on the output\n/// quality of the system's random number generator when the seed is created.\n/// In particular, seeds generated when the system's entropy pool is abnormally\n/// low such as during system boot may be of a lower quality.\n///\n/// The default hashing algorithm is currently SipHash 1-3, though this is\n/// subject to change at any point in the future. While its performance is very\n/// competitive for medium sized keys, other hashing algorithms will outperform\n/// it for small keys such as integers as well as large keys such as long\n/// strings, though those algorithms will typically *not* protect against\n/// attacks such as HashDoS.\n///\n/// The hashing algorithm can be replaced on a per-`HashMap` basis using the\n/// [`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods.\n/// There are many alternative [hashing algorithms available on crates.io].\n///\n/// It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n/// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n/// If you implement these yourself, it is important that the following\n/// property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must be equal.\n///\n/// It is a logic error for a key to be modified in such a way that the key's\n/// hash, as determined by the [`Hash`] trait, or its equality, as determined by\n/// the [`Eq`] trait, changes while it is in the map. This is normally only\n/// possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n/// The behavior resulting from such a logic error is not specified, but will\n/// not result in undefined behavior. This could include panics, incorrect results,\n/// aborts, memory leaks, and non-termination.\n///\n/// The hash table implementation is a Rust port of Google's [SwissTable].\n/// The original C++ version of SwissTable can be found [here], and this\n/// [CppCon talk] gives an overview of how the algorithm works.\n///\n/// [hash map]: crate::collections#use-a-hashmap-when\n/// [hashing algorithms available on crates.io]: https://crates.io/keywords/hasher\n/// [SwissTable]: https://abseil.io/blog/20180927-swisstables\n/// [here]: https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h\n/// [CppCon talk]: https://www.youtube.com/watch?v=ncHmEUmJZf4\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `HashMap<String, String>` in this example).\n/// let mut book_reviews = HashMap::new();\n///\n/// // Review some books.\n/// book_reviews.insert(\n///     \"Adventures of Huckleberry Finn\".to_string(),\n///     \"My favorite book.\".to_string(),\n/// );\n/// book_reviews.insert(\n///     \"Grimms' Fairy Tales\".to_string(),\n///     \"Masterpiece.\".to_string(),\n/// );\n/// book_reviews.insert(\n///     \"Pride and Prejudice\".to_string(),\n///     \"Very enjoyable.\".to_string(),\n/// );\n/// book_reviews.insert(\n///     \"The Adventures of Sherlock Holmes\".to_string(),\n///     \"Eye lyked it alot.\".to_string(),\n/// );\n///\n/// // Check for a specific one.\n/// // When collections store owned values (String), they can still be\n/// // queried using references (&str).\n/// if !book_reviews.contains_key(\"Les Misérables\") {\n///     println!(\"We've got {} reviews, but Les Misérables ain't one.\",\n///              book_reviews.len());\n/// }\n///\n/// // oops, this review has a lot of spelling mistakes, let's delete it.\n/// book_reviews.remove(\"The Adventures of Sherlock Holmes\");\n///\n/// // Look up the values associated with some keys.\n/// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n/// for &book in &to_find {\n///     match book_reviews.get(book) {\n///         Some(review) => println!(\"{}: {}\", book, review),\n///         None => println!(\"{} is unreviewed.\", book)\n///     }\n/// }\n///\n/// // Look up the value for a key (will panic if the key is not found).\n/// println!(\"Review for Jane: {}\", book_reviews[\"Pride and Prejudice\"]);\n///\n/// // Iterate over everything.\n/// for (book, review) in &book_reviews {\n///     println!(\"{}: \\\"{}\\\"\", book, review);\n/// }\n/// ```\n///\n/// `HashMap` also implements an [`Entry API`](#method.entry), which allows\n/// for more complex methods of getting, setting, updating and removing keys and\n/// their values:\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// // type inference lets us omit an explicit type signature (which\n/// // would be `HashMap<&str, u8>` in this example).\n/// let mut player_stats = HashMap::new();\n///\n/// fn random_stat_buff() -> u8 {\n///     // could actually return some random value here - let's just return\n///     // some fixed value for now\n///     42\n/// }\n///\n/// // insert a key only if it doesn't already exist\n/// player_stats.entry(\"health\").or_insert(100);\n///\n/// // insert a key using a function that provides a new value only if it\n/// // doesn't already exist\n/// player_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n///\n/// // update a key, guarding against the key possibly not being set\n/// let stat = player_stats.entry(\"attack\").or_insert(100);\n/// *stat += random_stat_buff();\n/// ```\n///\n/// The easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].\n/// We must also derive [`PartialEq`].\n///\n/// [`RefCell`]: crate::cell::RefCell\n/// [`Cell`]: crate::cell::Cell\n/// [`default`]: Default::default\n/// [`with_hasher`]: Self::with_hasher\n/// [`with_capacity_and_hasher`]: Self::with_capacity_and_hasher\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// #[derive(Hash, Eq, PartialEq, Debug)]\n/// struct Viking {\n///     name: String,\n///     country: String,\n/// }\n///\n/// impl Viking {\n///     /// Creates a new Viking.\n///     fn new(name: &str, country: &str) -> Viking {\n///         Viking { name: name.to_string(), country: country.to_string() }\n///     }\n/// }\n///\n/// // Use a HashMap to store the vikings' health points.\n/// let mut vikings = HashMap::new();\n///\n/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n///\n/// // Use derived implementation to print the status of the vikings.\n/// for (viking, health) in &vikings {\n///     println!(\"{:?} has {} hp\", viking, health);\n/// }\n/// ```\n///\n/// A `HashMap` with fixed list of elements can be initialized from an array:\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let timber_resources: HashMap<&str, i32> = [(\"Norway\", 100), (\"Denmark\", 50), (\"Iceland\", 10)]\n///     .iter().cloned().collect();\n/// // use the values stored in map\n/// ```\n\n#[cfg_attr(not(test), rustc_diagnostic_item = \"hashmap_type\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct HashMap<K, V, S = RandomState> {\n    base: base::HashMap<K, V, S>,\n}\n\nimpl<K, V> HashMap<K, V, RandomState> {\n    /// Creates an empty `HashMap`.\n    ///\n    /// The hash map is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> HashMap<K, V, RandomState> {\n        Default::default()\n    }\n\n    /// Creates an empty `HashMap` with the specified capacity.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::with_capacity(10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {\n        HashMap::with_capacity_and_hasher(capacity, Default::default())\n    }\n}\n\nimpl<K, V, S> HashMap<K, V, S> {\n    /// Creates an empty `HashMap` which will use the given hash builder to hash\n    /// keys.\n    ///\n    /// The created map has the default initial capacity.\n    ///\n    /// Warning: `hash_builder` is normally randomly generated, and\n    /// is designed to allow HashMaps to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashMap to be useful, see its documentation for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut map = HashMap::with_hasher(s);\n    /// map.insert(1, 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n        HashMap { base: base::HashMap::with_hasher(hash_builder) }\n    }\n\n    /// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n    /// to hash the keys.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// Warning: `hash_builder` is normally randomly generated, and\n    /// is designed to allow HashMaps to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashMap to be useful, see its documentation for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n    /// map.insert(1, 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n        HashMap { base: base::HashMap::with_capacity_and_hasher(capacity, hash_builder) }\n    }\n\n    /// Returns the number of elements the map can hold without reallocating.\n    ///\n    /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n    /// more, but is guaranteed to be able to hold at least this many.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// assert!(map.capacity() >= 100);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n        self.base.capacity()\n    }\n\n    /// An iterator visiting all keys in arbitrary order.\n    /// The iterator element type is `&'a K`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for key in map.keys() {\n    ///     println!(\"{}\", key);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn keys(&self) -> Keys<'_, K, V> {\n        Keys { inner: self.iter() }\n    }\n\n    /// An iterator visiting all values in arbitrary order.\n    /// The iterator element type is `&'a V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for val in map.values() {\n    ///     println!(\"{}\", val);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn values(&self) -> Values<'_, K, V> {\n        Values { inner: self.iter() }\n    }\n\n    /// An iterator visiting all values mutably in arbitrary order.\n    /// The iterator element type is `&'a mut V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    ///\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for val in map.values_mut() {\n    ///     *val = *val + 10;\n    /// }\n    ///\n    /// for val in map.values() {\n    ///     println!(\"{}\", val);\n    /// }\n    /// ```\n    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {\n        ValuesMut { inner: self.iter_mut() }\n    }\n\n    /// An iterator visiting all key-value pairs in arbitrary order.\n    /// The iterator element type is `(&'a K, &'a V)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for (key, val) in map.iter() {\n    ///     println!(\"key: {} val: {}\", key, val);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, K, V> {\n        Iter { base: self.base.iter() }\n    }\n\n    /// An iterator visiting all key-value pairs in arbitrary order,\n    /// with mutable references to the values.\n    /// The iterator element type is `(&'a K, &'a mut V)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// // Update all values\n    /// for (_, val) in map.iter_mut() {\n    ///     *val *= 2;\n    /// }\n    ///\n    /// for (key, val) in &map {\n    ///     println!(\"key: {} val: {}\", key, val);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n        IterMut { base: self.base.iter_mut() }\n    }\n\n    /// Returns the number of elements in the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// assert_eq!(a.len(), 0);\n    /// a.insert(1, \"a\");\n    /// assert_eq!(a.len(), 1);\n    /// ```\n    #[doc(alias = \"length\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n        self.base.len()\n    }\n\n    /// Returns `true` if the map contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// assert!(a.is_empty());\n    /// a.insert(1, \"a\");\n    /// assert!(!a.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.base.is_empty()\n    }\n\n    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n    /// allocated memory for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// a.insert(1, \"a\");\n    /// a.insert(2, \"b\");\n    ///\n    /// for (k, v) in a.drain().take(1) {\n    ///     assert!(k == 1 || k == 2);\n    ///     assert!(v == \"a\" || v == \"b\");\n    /// }\n    ///\n    /// assert!(a.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain(&mut self) -> Drain<'_, K, V> {\n        Drain { base: self.base.drain() }\n    }\n\n    /// Creates an iterator which uses a closure to determine if an element should be removed.\n    ///\n    /// If the closure returns true, the element is removed from the map and yielded.\n    /// If the closure returns false, or panics, the element remains in the map and will not be\n    /// yielded.\n    ///\n    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n    /// whether you choose to keep or remove it.\n    ///\n    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n    ///\n    /// It is unspecified how many more elements will be subjected to the closure\n    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n    /// or if the `DrainFilter` value is leaked.\n    ///\n    /// # Examples\n    ///\n    /// Splitting a map into even and odd keys, reusing the original map:\n    ///\n    /// ```\n    /// #![feature(hash_drain_filter)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n    /// let drained: HashMap<i32, i32> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n    ///\n    /// let mut evens = drained.keys().copied().collect::<Vec<_>>();\n    /// let mut odds = map.keys().copied().collect::<Vec<_>>();\n    /// evens.sort();\n    /// odds.sort();\n    ///\n    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n    where\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        DrainFilter { base: self.base.drain_filter(pred) }\n    }\n\n    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n    /// for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// a.insert(1, \"a\");\n    /// a.clear();\n    /// assert!(a.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n        self.base.clear();\n    }\n\n    /// Returns a reference to the map's [`BuildHasher`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let hasher = RandomState::new();\n    /// let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n    /// let hasher: &RandomState = map.hasher();\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n    pub fn hasher(&self) -> &S {\n        self.base.hasher()\n    }\n}\n\nimpl<K, V, S> HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n{\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashMap`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new allocation size overflows [`usize`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    /// map.reserve(10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.base.reserve(additional)\n    }\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashMap<K, V>`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, isize> = HashMap::new();\n    /// map.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.base.try_reserve(additional).map_err(map_try_reserve_error)\n    }\n\n    /// Shrinks the capacity of the map as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// assert!(map.capacity() >= 100);\n    /// map.shrink_to_fit();\n    /// assert!(map.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        self.base.shrink_to_fit();\n    }\n\n    /// Shrinks the capacity of the map with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// If the current capacity is less than the lower limit, this is a no-op.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// assert!(map.capacity() >= 100);\n    /// map.shrink_to(10);\n    /// assert!(map.capacity() >= 10);\n    /// map.shrink_to(0);\n    /// assert!(map.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.base.shrink_to(min_capacity);\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut letters = HashMap::new();\n    ///\n    /// for ch in \"a short treatise on fungi\".chars() {\n    ///     let counter = letters.entry(ch).or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(letters[&'s'], 2);\n    /// assert_eq!(letters[&'t'], 3);\n    /// assert_eq!(letters[&'u'], 1);\n    /// assert_eq!(letters.get(&'y'), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n        map_entry(self.base.rustc_entry(key))\n    }\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.get(&1), Some(&\"a\"));\n    /// assert_eq!(map.get(&2), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.get(k)\n    }\n\n    /// Returns the key-value pair corresponding to the supplied key.\n    ///\n    /// The supplied key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n    /// assert_eq!(map.get_key_value(&2), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n    pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.get_key_value(k)\n    }\n\n    /// Returns `true` if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.contains_key(&1), true);\n    /// assert_eq!(map.contains_key(&2), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.contains_key(k)\n    }\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// if let Some(x) = map.get_mut(&1) {\n    ///     *x = \"b\";\n    /// }\n    /// assert_eq!(map[&1], \"b\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.get_mut(k)\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, [`None`] is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned. The key is not updated, though; this matters for\n    /// types that can be `==` without being identical. See the [module-level\n    /// documentation] for more.\n    ///\n    /// [module-level documentation]: crate::collections#insert-and-complex-keys\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// assert_eq!(map.insert(37, \"a\"), None);\n    /// assert_eq!(map.is_empty(), false);\n    ///\n    /// map.insert(37, \"b\");\n    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n    /// assert_eq!(map[&37], \"c\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n        self.base.insert(k, v)\n    }\n\n    /// Tries to insert a key-value pair into the map, and returns\n    /// a mutable reference to the value in the entry.\n    ///\n    /// If the map already had this key present, nothing is updated, and\n    /// an error containing the occupied entry and the value is returned.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(map_try_insert)]\n    ///\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// assert_eq!(map.try_insert(37, \"a\").unwrap(), &\"a\");\n    ///\n    /// let err = map.try_insert(37, \"b\").unwrap_err();\n    /// assert_eq!(err.entry.key(), &37);\n    /// assert_eq!(err.entry.get(), &\"a\");\n    /// assert_eq!(err.value, \"b\");\n    /// ```\n    #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n    pub fn try_insert(&mut self, key: K, value: V) -> Result<&mut V, OccupiedError<'_, K, V>> {\n        match self.entry(key) {\n            Occupied(entry) => Err(OccupiedError { entry, value }),\n            Vacant(entry) => Ok(entry.insert(value)),\n        }\n    }\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.remove(&1), Some(\"a\"));\n    /// assert_eq!(map.remove(&1), None);\n    /// ```\n    #[doc(alias = \"delete\")]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.remove(k)\n    }\n\n    /// Removes a key from the map, returning the stored key and value if the\n    /// key was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// # fn main() {\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n    /// assert_eq!(map.remove(&1), None);\n    /// # }\n    /// ```\n    #[inline]\n    #[stable(feature = \"hash_map_remove_entry\", since = \"1.27.0\")]\n    pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.remove_entry(k)\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)` returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x*10)).collect();\n    /// map.retain(|&k, _| k % 2 == 0);\n    /// assert_eq!(map.len(), 4);\n    /// ```\n    #[inline]\n    #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n    pub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        self.base.retain(f)\n    }\n\n    /// Creates a consuming iterator visiting all the keys in arbitrary order.\n    /// The map cannot be used after calling this.\n    /// The iterator element type is `K`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// let vec: Vec<&str> = map.into_keys().collect();\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n    pub fn into_keys(self) -> IntoKeys<K, V> {\n        IntoKeys { inner: self.into_iter() }\n    }\n\n    /// Creates a consuming iterator visiting all the values in arbitrary order.\n    /// The map cannot be used after calling this.\n    /// The iterator element type is `V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// let vec: Vec<i32> = map.into_values().collect();\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n    pub fn into_values(self) -> IntoValues<K, V> {\n        IntoValues { inner: self.into_iter() }\n    }\n}\n\nimpl<K, V, S> HashMap<K, V, S>\nwhere\n    S: BuildHasher,\n{\n    /// Creates a raw entry builder for the HashMap.\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched. After this, insertions into a vacant entry\n    /// still require an owned key to be provided.\n    ///\n    /// Raw entries are useful for such exotic situations as:\n    ///\n    /// * Hash memoization\n    /// * Deferring the creation of an owned key until it is known to be required\n    /// * Using a search key that doesn't work with the Borrow trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Because raw entries provide much more low-level control, it's much easier\n    /// to put the HashMap into an inconsistent state which, while memory-safe,\n    /// will cause the map to produce seemingly random results. Higher-level and\n    /// more foolproof APIs like `entry` should be preferred when possible.\n    ///\n    /// In particular, the hash used to initialized the raw entry must still be\n    /// consistent with the hash of the key that is ultimately stored in the entry.\n    /// This is because implementations of HashMap may need to recompute hashes\n    /// when resizing, at which point only the keys are available.\n    ///\n    /// Raw entries give mutable access to the keys. This must not be used\n    /// to modify how the key would compare or hash, as the map will not re-evaluate\n    /// where the key should go, meaning the keys may become \"lost\" if their\n    /// location does not reflect their state. For instance, if you change a key\n    /// so that the map now contains keys which compare equal, search may start\n    /// acting erratically, with two keys randomly masking each other. Implementations\n    /// are free to assume this doesn't happen (within the limits of memory-safety).\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<'_, K, V, S> {\n        RawEntryBuilderMut { map: self }\n    }\n\n    /// Creates a raw immutable entry builder for the HashMap.\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched.\n    ///\n    /// This is useful for\n    /// * Hash memoization\n    /// * Using a search key that doesn't work with the Borrow trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Unless you are in such a situation, higher-level and more foolproof APIs like\n    /// `get` should be preferred.\n    ///\n    /// Immutable raw entries have very limited use; you might instead want `raw_entry_mut`.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn raw_entry(&self) -> RawEntryBuilder<'_, K, V, S> {\n        RawEntryBuilder { map: self }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Clone for HashMap<K, V, S>\nwhere\n    K: Clone,\n    V: Clone,\n    S: Clone,\n{\n    #[inline]\n    fn clone(&self) -> Self {\n        Self { base: self.base.clone() }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, other: &Self) {\n        self.base.clone_from(&other.base);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> PartialEq for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    V: PartialEq,\n    S: BuildHasher,\n{\n    fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter().all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Eq for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Debug for HashMap<K, V, S>\nwhere\n    K: Debug,\n    V: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_map().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Default for HashMap<K, V, S>\nwhere\n    S: Default,\n{\n    /// Creates an empty `HashMap<K, V, S>`, with the `Default` value for the hasher.\n    #[inline]\n    fn default() -> HashMap<K, V, S> {\n        HashMap::with_hasher(Default::default())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, Q: ?Sized, V, S> Index<&Q> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash + Borrow<Q>,\n    Q: Eq + Hash,\n    S: BuildHasher,\n{\n    type Output = V;\n\n    /// Returns a reference to the value corresponding to the supplied key.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the key is not present in the `HashMap`.\n    #[inline]\n    fn index(&self, key: &Q) -> &V {\n        self.get(key).expect(\"no entry found for key\")\n    }\n}\n\n/// An iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`iter`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`iter`]: HashMap::iter\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.iter();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, K: 'a, V: 'a> {\n    base: base::Iter<'a, K, V>,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Iter<'_, K, V> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Iter { base: self.base.clone() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: Debug, V: Debug> fmt::Debug for Iter<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n/// A mutable iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`iter_mut`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`iter_mut`]: HashMap::iter_mut\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.iter_mut();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, K: 'a, V: 'a> {\n    base: base::IterMut<'a, K, V>,\n}\n\nimpl<'a, K, V> IterMut<'a, K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[inline]\n    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n        Iter { base: self.base.rustc_iter() }\n    }\n}\n\n/// An owning iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashMap`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`into_iter`]: IntoIterator::into_iter\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.into_iter();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<K, V> {\n    base: base::IntoIter<K, V>,\n}\n\nimpl<K, V> IntoIter<K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[inline]\n    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n        Iter { base: self.base.rustc_iter() }\n    }\n}\n\n/// An iterator over the keys of a `HashMap`.\n///\n/// This `struct` is created by the [`keys`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`keys`]: HashMap::keys\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_keys = map.keys();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Keys<'a, K: 'a, V: 'a> {\n    inner: Iter<'a, K, V>,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Keys<'_, K, V> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Keys { inner: self.inner.clone() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: Debug, V> fmt::Debug for Keys<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n/// An iterator over the values of a `HashMap`.\n///\n/// This `struct` is created by the [`values`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`values`]: HashMap::values\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_values = map.values();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Values<'a, K: 'a, V: 'a> {\n    inner: Iter<'a, K, V>,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Values<'_, K, V> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Values { inner: self.inner.clone() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V: Debug> fmt::Debug for Values<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n/// A draining iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`drain`]: HashMap::drain\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.drain();\n/// ```\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<'a, K: 'a, V: 'a> {\n    base: base::Drain<'a, K, V>,\n}\n\nimpl<'a, K, V> Drain<'a, K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[inline]\n    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n        Iter { base: self.base.rustc_iter() }\n    }\n}\n\n/// A draining, filtering iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`drain_filter`] method on [`HashMap`].\n///\n/// [`drain_filter`]: HashMap::drain_filter\n///\n/// # Example\n///\n/// ```\n/// #![feature(hash_drain_filter)]\n///\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.drain_filter(|_k, v| *v % 2 == 0);\n/// ```\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\npub struct DrainFilter<'a, K, V, F>\nwhere\n    F: FnMut(&K, &mut V) -> bool,\n{\n    base: base::DrainFilter<'a, K, V, F>,\n}\n\n/// A mutable iterator over the values of a `HashMap`.\n///\n/// This `struct` is created by the [`values_mut`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`values_mut`]: HashMap::values_mut\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_values = map.values_mut();\n/// ```\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\npub struct ValuesMut<'a, K: 'a, V: 'a> {\n    inner: IterMut<'a, K, V>,\n}\n\n/// An owning iterator over the keys of a `HashMap`.\n///\n/// This `struct` is created by the [`into_keys`] method on [`HashMap`].\n/// See its documentation for more.\n///\n/// [`into_keys`]: HashMap::into_keys\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_keys = map.into_keys();\n/// ```\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\npub struct IntoKeys<K, V> {\n    inner: IntoIter<K, V>,\n}\n\n/// An owning iterator over the values of a `HashMap`.\n///\n/// This `struct` is created by the [`into_values`] method on [`HashMap`].\n/// See its documentation for more.\n///\n/// [`into_values`]: HashMap::into_values\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_keys = map.into_values();\n/// ```\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\npub struct IntoValues<K, V> {\n    inner: IntoIter<K, V>,\n}\n\n/// A builder for computing where in a HashMap a key-value pair would be stored.\n///\n/// See the [`HashMap::raw_entry_mut`] docs for usage examples.\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n    map: &'a mut HashMap<K, V, S>,\n}\n\n/// A view into a single entry in a map, which may either be vacant or occupied.\n///\n/// This is a lower-level version of [`Entry`].\n///\n/// This `enum` is constructed through the [`raw_entry_mut`] method on [`HashMap`],\n/// then calling one of the methods of that [`RawEntryBuilderMut`].\n///\n/// [`raw_entry_mut`]: HashMap::raw_entry_mut\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n    /// An occupied entry.\n    Occupied(RawOccupiedEntryMut<'a, K, V, S>),\n    /// A vacant entry.\n    Vacant(RawVacantEntryMut<'a, K, V, S>),\n}\n\n/// A view into an occupied entry in a `HashMap`.\n/// It is part of the [`RawEntryMut`] enum.\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n    base: base::RawOccupiedEntryMut<'a, K, V, S>,\n}\n\n/// A view into a vacant entry in a `HashMap`.\n/// It is part of the [`RawEntryMut`] enum.\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n    base: base::RawVacantEntryMut<'a, K, V, S>,\n}\n\n/// A builder for computing where in a HashMap a key-value pair would be stored.\n///\n/// See the [`HashMap::raw_entry`] docs for usage examples.\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n    map: &'a HashMap<K, V, S>,\n}\n\nimpl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\nwhere\n    S: BuildHasher,\n{\n    /// Creates a `RawEntryMut` from the given key.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        map_raw_entry(self.map.base.raw_entry_mut().from_key(k))\n    }\n\n    /// Creates a `RawEntryMut` from the given key and its hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        K: Borrow<Q>,\n        Q: Eq,\n    {\n        map_raw_entry(self.map.base.raw_entry_mut().from_key_hashed_nocheck(hash, k))\n    }\n\n    /// Creates a `RawEntryMut` from the given hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n    where\n        for<'b> F: FnMut(&'b K) -> bool,\n    {\n        map_raw_entry(self.map.base.raw_entry_mut().from_hash(hash, is_match))\n    }\n}\n\nimpl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\nwhere\n    S: BuildHasher,\n{\n    /// Access an entry by key.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.map.base.raw_entry().from_key(k)\n    }\n\n    /// Access an entry by a key and its hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> Option<(&'a K, &'a V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.map.base.raw_entry().from_key_hashed_nocheck(hash, k)\n    }\n\n    /// Access an entry by hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n    where\n        F: FnMut(&K) -> bool,\n    {\n        self.map.base.raw_entry().from_hash(hash, is_match)\n    }\n}\n\nimpl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// mutable references to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_raw_entry)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 3);\n    /// assert_eq!(map[\"poneyland\"], 3);\n    ///\n    /// *map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 10).1 *= 2;\n    /// assert_eq!(map[\"poneyland\"], 6);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n            RawEntryMut::Vacant(entry) => entry.insert(default_key, default_val),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns mutable references to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_raw_entry)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    ///\n    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert_with(|| {\n    ///     (\"poneyland\", \"hoho\".to_string())\n    /// });\n    ///\n    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n    where\n        F: FnOnce() -> (K, V),\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n            RawEntryMut::Vacant(entry) => {\n                let (k, v) = default();\n                entry.insert(k, v)\n            }\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_raw_entry)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.raw_entry_mut()\n    ///    .from_key(\"poneyland\")\n    ///    .and_modify(|_k, v| { *v += 1 })\n    ///    .or_insert(\"poneyland\", 42);\n    /// assert_eq!(map[\"poneyland\"], 42);\n    ///\n    /// map.raw_entry_mut()\n    ///    .from_key(\"poneyland\")\n    ///    .and_modify(|_k, v| { *v += 1 })\n    ///    .or_insert(\"poneyland\", 0);\n    /// assert_eq!(map[\"poneyland\"], 43);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut K, &mut V),\n    {\n        match self {\n            RawEntryMut::Occupied(mut entry) => {\n                {\n                    let (k, v) = entry.get_key_value_mut();\n                    f(k, v);\n                }\n                RawEntryMut::Occupied(entry)\n            }\n            RawEntryMut::Vacant(entry) => RawEntryMut::Vacant(entry),\n        }\n    }\n}\n\nimpl<'a, K, V, S> RawOccupiedEntryMut<'a, K, V, S> {\n    /// Gets a reference to the key in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn key(&self) -> &K {\n        self.base.key()\n    }\n\n    /// Gets a mutable reference to the key in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn key_mut(&mut self) -> &mut K {\n        self.base.key_mut()\n    }\n\n    /// Converts the entry into a mutable reference to the key in the entry\n    /// with a lifetime bound to the map itself.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn into_key(self) -> &'a mut K {\n        self.base.into_key()\n    }\n\n    /// Gets a reference to the value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get(&self) -> &V {\n        self.base.get()\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn into_mut(self) -> &'a mut V {\n        self.base.into_mut()\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get_mut(&mut self) -> &mut V {\n        self.base.get_mut()\n    }\n\n    /// Gets a reference to the key and value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get_key_value(&mut self) -> (&K, &V) {\n        self.base.get_key_value()\n    }\n\n    /// Gets a mutable reference to the key and value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n        self.base.get_key_value_mut()\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the key and value in the entry\n    /// with a lifetime bound to the map itself.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn into_key_value(self) -> (&'a mut K, &'a mut V) {\n        self.base.into_key_value()\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert(&mut self, value: V) -> V {\n        self.base.insert(value)\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert_key(&mut self, key: K) -> K {\n        self.base.insert_key(key)\n    }\n\n    /// Takes the value out of the entry, and returns it.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn remove(self) -> V {\n        self.base.remove()\n    }\n\n    /// Take the ownership of the key and value from the map.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn remove_entry(self) -> (K, V) {\n        self.base.remove_entry()\n    }\n}\n\nimpl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n    /// Sets the value of the entry with the `VacantEntry`'s key,\n    /// and returns a mutable reference to it.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        self.base.insert(key, value)\n    }\n\n    /// Sets the value of the entry with the VacantEntry's key,\n    /// and returns a mutable reference to it.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        self.base.insert_hashed_nocheck(hash, key, value)\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K, V, S> Debug for RawEntryBuilderMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawEntryBuilder\").finish_non_exhaustive()\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K: Debug, V: Debug, S> Debug for RawEntryMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            RawEntryMut::Vacant(ref v) => f.debug_tuple(\"RawEntry\").field(v).finish(),\n            RawEntryMut::Occupied(ref o) => f.debug_tuple(\"RawEntry\").field(o).finish(),\n        }\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K: Debug, V: Debug, S> Debug for RawOccupiedEntryMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawOccupiedEntryMut\")\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish_non_exhaustive()\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K, V, S> Debug for RawVacantEntryMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawVacantEntryMut\").finish_non_exhaustive()\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K, V, S> Debug for RawEntryBuilder<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawEntryBuilder\").finish_non_exhaustive()\n    }\n}\n\n/// A view into a single entry in a map, which may either be vacant or occupied.\n///\n/// This `enum` is constructed from the [`entry`] method on [`HashMap`].\n///\n/// [`entry`]: HashMap::entry\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Entry<'a, K: 'a, V: 'a> {\n    /// An occupied entry.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n\n    /// A vacant entry.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n}\n\n#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\nimpl<K: Debug, V: Debug> Debug for Entry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n        }\n    }\n}\n\n/// A view into an occupied entry in a `HashMap`.\n/// It is part of the [`Entry`] enum.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n    base: base::RustcOccupiedEntry<'a, K, V>,\n}\n\n#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\nimpl<K: Debug, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"OccupiedEntry\")\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish_non_exhaustive()\n    }\n}\n\n/// A view into a vacant entry in a `HashMap`.\n/// It is part of the [`Entry`] enum.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct VacantEntry<'a, K: 'a, V: 'a> {\n    base: base::RustcVacantEntry<'a, K, V>,\n}\n\n#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\nimpl<K: Debug, V> Debug for VacantEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n    }\n}\n\n/// The error returned by [`try_insert`](HashMap::try_insert) when the key already exists.\n///\n/// Contains the occupied entry, and the value that was not inserted.\n#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\npub struct OccupiedError<'a, K: 'a, V: 'a> {\n    /// The entry in the map that was already occupied.\n    pub entry: OccupiedEntry<'a, K, V>,\n    /// The value which was not inserted, because the entry was already occupied.\n    pub value: V,\n}\n\n#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\nimpl<K: Debug, V: Debug> Debug for OccupiedError<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"OccupiedError\")\n            .field(\"key\", self.entry.key())\n            .field(\"old_value\", self.entry.get())\n            .field(\"new_value\", &self.value)\n            .finish_non_exhaustive()\n    }\n}\n\n#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\nimpl<'a, K: Debug, V: Debug> fmt::Display for OccupiedError<'a, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"failed to insert {:?}, key {:?} already exists with value {:?}\",\n            self.value,\n            self.entry.key(),\n            self.entry.get(),\n        )\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S> {\n    type Item = (&'a K, &'a V);\n    type IntoIter = Iter<'a, K, V>;\n\n    #[inline]\n    fn into_iter(self) -> Iter<'a, K, V> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S> {\n    type Item = (&'a K, &'a mut V);\n    type IntoIter = IterMut<'a, K, V>;\n\n    #[inline]\n    fn into_iter(self) -> IterMut<'a, K, V> {\n        self.iter_mut()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> IntoIterator for HashMap<K, V, S> {\n    type Item = (K, V);\n    type IntoIter = IntoIter<K, V>;\n\n    /// Creates a consuming iterator, that is, one that moves each key-value\n    /// pair out of the map in arbitrary order. The map cannot be used after\n    /// calling this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// // Not possible with .iter()\n    /// let vec: Vec<(&str, i32)> = map.into_iter().collect();\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<K, V> {\n        IntoIter { base: self.base.into_iter() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Iter<'a, K, V> {\n    type Item = (&'a K, &'a V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Iter<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for IterMut<'a, K, V> {\n    type Item = (&'a K, &'a mut V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for IterMut<'_, K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V> fmt::Debug for IterMut<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Iterator for IntoIter<K, V> {\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for IntoIter<K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for IntoIter<K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: Debug, V: Debug> fmt::Debug for IntoIter<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Keys<'a, K, V> {\n    type Item = &'a K;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a K> {\n        self.inner.next().map(|(k, _)| k)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Keys<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Keys<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Values<'a, K, V> {\n    type Item = &'a V;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a V> {\n        self.inner.next().map(|(_, v)| v)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Values<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Values<'_, K, V> {}\n\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\nimpl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n    type Item = &'a mut V;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut V> {\n        self.inner.next().map(|(_, v)| v)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\nimpl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V: fmt::Debug> fmt::Debug for ValuesMut<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.inner.iter().map(|(_, val)| val)).finish()\n    }\n}\n\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> Iterator for IntoKeys<K, V> {\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n        self.inner.next().map(|(k, _)| k)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> ExactSizeIterator for IntoKeys<K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> FusedIterator for IntoKeys<K, V> {}\n\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K: Debug, V> fmt::Debug for IntoKeys<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.inner.iter().map(|(k, _)| k)).finish()\n    }\n}\n\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> Iterator for IntoValues<K, V> {\n    type Item = V;\n\n    #[inline]\n    fn next(&mut self) -> Option<V> {\n        self.inner.next().map(|(_, v)| v)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> ExactSizeIterator for IntoValues<K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> FusedIterator for IntoValues<K, V> {}\n\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V: Debug> fmt::Debug for IntoValues<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.inner.iter().map(|(_, v)| v)).finish()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, K, V> Iterator for Drain<'a, K, V> {\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<K, V> ExactSizeIterator for Drain<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Drain<'_, K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V> fmt::Debug for Drain<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\nwhere\n    F: FnMut(&K, &mut V) -> bool,\n{\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\nwhere\n    F: FnMut(&K, &mut V) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"DrainFilter\").finish_non_exhaustive()\n    }\n}\n\nimpl<'a, K, V> Entry<'a, K, V> {\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.entry(\"poneyland\").or_insert(3);\n    /// assert_eq!(map[\"poneyland\"], 3);\n    ///\n    /// *map.entry(\"poneyland\").or_insert(10) *= 2;\n    /// assert_eq!(map[\"poneyland\"], 6);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_insert(self, default: V) -> &'a mut V {\n        match self {\n            Occupied(entry) => entry.into_mut(),\n            Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    /// let s = \"hoho\".to_string();\n    ///\n    /// map.entry(\"poneyland\").or_insert_with(|| s);\n    ///\n    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n        match self {\n            Occupied(entry) => entry.into_mut(),\n            Vacant(entry) => entry.insert(default()),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting, if empty, the result of the default function.\n    /// This method allows for generating key-derived values for insertion by providing the default\n    /// function a reference to the key that was moved during the `.entry(key)` method call.\n    ///\n    /// The reference to the moved key is provided so that cloning or copying the key is\n    /// unnecessary, unlike with `.or_insert_with(|| ... )`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, usize> = HashMap::new();\n    ///\n    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n    ///\n    /// assert_eq!(map[\"poneyland\"], 9);\n    /// ```\n    #[inline]\n    #[stable(feature = \"or_insert_with_key\", since = \"1.50.0\")]\n    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n        match self {\n            Occupied(entry) => entry.into_mut(),\n            Vacant(entry) => {\n                let value = default(entry.key());\n                entry.insert(value)\n            }\n        }\n    }\n\n    /// Returns a reference to this entry's key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n        match *self {\n            Occupied(ref entry) => entry.key(),\n            Vacant(ref entry) => entry.key(),\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.entry(\"poneyland\")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map[\"poneyland\"], 42);\n    ///\n    /// map.entry(\"poneyland\")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map[\"poneyland\"], 43);\n    /// ```\n    #[inline]\n    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        match self {\n            Occupied(mut entry) => {\n                f(entry.get_mut());\n                Occupied(entry)\n            }\n            Vacant(entry) => Vacant(entry),\n        }\n    }\n\n    /// Sets the value of the entry, and returns an `OccupiedEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(entry_insert)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    /// let entry = map.entry(\"poneyland\").insert(\"hoho\".to_string());\n    ///\n    /// assert_eq!(entry.key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"entry_insert\", issue = \"65225\")]\n    pub fn insert(self, value: V) -> OccupiedEntry<'a, K, V> {\n        match self {\n            Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            Vacant(entry) => entry.insert_entry(value),\n        }\n    }\n}\n\nimpl<'a, K, V: Default> Entry<'a, K, V> {\n    /// Ensures a value is in the entry by inserting the default value if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n    /// map.entry(\"poneyland\").or_default();\n    ///\n    /// assert_eq!(map[\"poneyland\"], None);\n    /// # }\n    /// ```\n    #[inline]\n    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n    pub fn or_default(self) -> &'a mut V {\n        match self {\n            Occupied(entry) => entry.into_mut(),\n            Vacant(entry) => entry.insert(Default::default()),\n        }\n    }\n}\n\nimpl<'a, K, V> OccupiedEntry<'a, K, V> {\n    /// Gets a reference to the key in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n        self.base.key()\n    }\n\n    /// Take the ownership of the key and value from the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     // We delete the entry from the map.\n    ///     o.remove_entry();\n    /// }\n    ///\n    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n    pub fn remove_entry(self) -> (K, V) {\n        self.base.remove_entry()\n    }\n\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.get(), &12);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get(&self) -> &V {\n        self.base.get()\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// If you need a reference to the `OccupiedEntry` which may outlive the\n    /// destruction of the `Entry` value, see [`into_mut`].\n    ///\n    /// [`into_mut`]: Self::into_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// assert_eq!(map[\"poneyland\"], 12);\n    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n    ///     *o.get_mut() += 10;\n    ///     assert_eq!(*o.get(), 22);\n    ///\n    ///     // We can use the same Entry multiple times.\n    ///     *o.get_mut() += 2;\n    /// }\n    ///\n    /// assert_eq!(map[\"poneyland\"], 24);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut V {\n        self.base.get_mut()\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    ///\n    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n    ///\n    /// [`get_mut`]: Self::get_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// assert_eq!(map[\"poneyland\"], 12);\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     *o.into_mut() += 10;\n    /// }\n    ///\n    /// assert_eq!(map[\"poneyland\"], 22);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_mut(self) -> &'a mut V {\n        self.base.into_mut()\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.insert(15), 12);\n    /// }\n    ///\n    /// assert_eq!(map[\"poneyland\"], 15);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, value: V) -> V {\n        self.base.insert(value)\n    }\n\n    /// Takes the value out of the entry, and returns it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.remove(), 12);\n    /// }\n    ///\n    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(self) -> V {\n        self.base.remove()\n    }\n\n    /// Replaces the entry, returning the old key and value. The new key in the hash map will be\n    /// the key used to create this entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(map_entry_replace)]\n    /// use std::collections::hash_map::{Entry, HashMap};\n    /// use std::rc::Rc;\n    ///\n    /// let mut map: HashMap<Rc<String>, u32> = HashMap::new();\n    /// map.insert(Rc::new(\"Stringthing\".to_string()), 15);\n    ///\n    /// let my_key = Rc::new(\"Stringthing\".to_string());\n    ///\n    /// if let Entry::Occupied(entry) = map.entry(my_key) {\n    ///     // Also replace the key with a handle to our other key.\n    ///     let (old_key, old_value): (Rc<String>, u32) = entry.replace_entry(16);\n    /// }\n    ///\n    /// ```\n    #[inline]\n    #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n    pub fn replace_entry(self, value: V) -> (K, V) {\n        self.base.replace_entry(value)\n    }\n\n    /// Replaces the key in the hash map with the key used to create this entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(map_entry_replace)]\n    /// use std::collections::hash_map::{Entry, HashMap};\n    /// use std::rc::Rc;\n    ///\n    /// let mut map: HashMap<Rc<String>, u32> = HashMap::new();\n    /// let known_strings: Vec<Rc<String>> = Vec::new();\n    ///\n    /// // Initialise known strings, run program, etc.\n    ///\n    /// reclaim_memory(&mut map, &known_strings);\n    ///\n    /// fn reclaim_memory(map: &mut HashMap<Rc<String>, u32>, known_strings: &[Rc<String>] ) {\n    ///     for s in known_strings {\n    ///         if let Entry::Occupied(entry) = map.entry(Rc::clone(s)) {\n    ///             // Replaces the entry's key with our version of it in `known_strings`.\n    ///             entry.replace_key();\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n    pub fn replace_key(self) -> K {\n        self.base.replace_key()\n    }\n}\n\nimpl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the `VacantEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n        self.base.key()\n    }\n\n    /// Take ownership of the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n    ///     v.into_key();\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n    pub fn into_key(self) -> K {\n        self.base.into_key()\n    }\n\n    /// Sets the value of the entry with the `VacantEntry`'s key,\n    /// and returns a mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n    ///     o.insert(37);\n    /// }\n    /// assert_eq!(map[\"poneyland\"], 37);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(self, value: V) -> &'a mut V {\n        self.base.insert(value)\n    }\n\n    /// Sets the value of the entry with the `VacantEntry`'s key,\n    /// and returns an `OccupiedEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n    ///     o.insert(37);\n    /// }\n    /// assert_eq!(map[\"poneyland\"], 37);\n    /// ```\n    #[inline]\n    fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {\n        let base = self.base.insert_entry(value);\n        OccupiedEntry { base }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher + Default,\n{\n    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> HashMap<K, V, S> {\n        let mut map = HashMap::with_hasher(Default::default());\n        map.extend(iter);\n        map\n    }\n}\n\n/// Inserts all new key-values from the iterator and replaces values with existing\n/// keys with new values returned from the iterator.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n        self.base.extend(iter)\n    }\n\n    #[inline]\n    fn extend_one(&mut self, (k, v): (K, V)) {\n        self.base.insert(k, v);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        // self.base.extend_reserve(additional);\n        // FIXME: hashbrown should implement this method.\n        // But until then, use the same reservation logic:\n\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let reserve = if self.is_empty() { additional } else { (additional + 1) / 2 };\n        self.base.reserve(reserve);\n    }\n}\n\n#[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\nimpl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash + Copy,\n    V: Copy,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n        self.base.extend(iter)\n    }\n\n    #[inline]\n    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n        self.base.insert(k, v);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<(K, V)>::extend_reserve(self, additional)\n    }\n}\n\n/// `RandomState` is the default state for [`HashMap`] types.\n///\n/// A particular instance `RandomState` will create the same instances of\n/// [`Hasher`], but the hashers created by two different `RandomState`\n/// instances are unlikely to produce the same result for the same values.\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashMap;\n/// use std::collections::hash_map::RandomState;\n///\n/// let s = RandomState::new();\n/// let mut map = HashMap::with_hasher(s);\n/// map.insert(1, 2);\n/// ```\n#[derive(Clone)]\n#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\npub struct RandomState {\n    k0: u64,\n    k1: u64,\n}\n\nimpl RandomState {\n    /// Constructs a new `RandomState` that is initialized with random keys.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// ```\n    #[inline]\n    #[allow(deprecated)]\n    // rand\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn new() -> RandomState {\n        // Historically this function did not cache keys from the OS and instead\n        // simply always called `rand::thread_rng().gen()` twice. In #31356 it\n        // was discovered, however, that because we re-seed the thread-local RNG\n        // from the OS periodically that this can cause excessive slowdown when\n        // many hash maps are created on a thread. To solve this performance\n        // trap we cache the first set of randomly generated keys per-thread.\n        //\n        // Later in #36481 it was discovered that exposing a deterministic\n        // iteration order allows a form of DOS attack. To counter that we\n        // increment one of the seeds on every RandomState creation, giving\n        // every corresponding HashMap a different iteration order.\n        thread_local!(static KEYS: Cell<(u64, u64)> = {\n            Cell::new(sys::hashmap_random_keys())\n        });\n\n        KEYS.with(|keys| {\n            let (k0, k1) = keys.get();\n            keys.set((k0.wrapping_add(1), k1));\n            RandomState { k0, k1 }\n        })\n    }\n}\n\n#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\nimpl BuildHasher for RandomState {\n    type Hasher = DefaultHasher;\n    #[inline]\n    #[allow(deprecated)]\n    fn build_hasher(&self) -> DefaultHasher {\n        DefaultHasher(SipHasher13::new_with_keys(self.k0, self.k1))\n    }\n}\n\n/// The default [`Hasher`] used by [`RandomState`].\n///\n/// The internal algorithm is not specified, and so it and its hashes should\n/// not be relied upon over releases.\n#[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n#[allow(deprecated)]\n#[derive(Clone, Debug)]\npub struct DefaultHasher(SipHasher13);\n\nimpl DefaultHasher {\n    /// Creates a new `DefaultHasher`.\n    ///\n    /// This hasher is not guaranteed to be the same as all other\n    /// `DefaultHasher` instances, but is the same as all other `DefaultHasher`\n    /// instances created through `new` or `default`.\n    #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n    #[allow(deprecated)]\n    pub fn new() -> DefaultHasher {\n        DefaultHasher(SipHasher13::new_with_keys(0, 0))\n    }\n}\n\n#[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\nimpl Default for DefaultHasher {\n    /// Creates a new `DefaultHasher` using [`new`].\n    /// See its documentation for more.\n    ///\n    /// [`new`]: DefaultHasher::new\n    fn default() -> DefaultHasher {\n        DefaultHasher::new()\n    }\n}\n\n#[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\nimpl Hasher for DefaultHasher {\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n        self.0.write(msg)\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        self.0.finish()\n    }\n}\n\n#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\nimpl Default for RandomState {\n    /// Constructs a new `RandomState`.\n    #[inline]\n    fn default() -> RandomState {\n        RandomState::new()\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for RandomState {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RandomState\").finish_non_exhaustive()\n    }\n}\n\n#[inline]\nfn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K, V> {\n    match raw {\n        base::RustcEntry::Occupied(base) => Entry::Occupied(OccupiedEntry { base }),\n        base::RustcEntry::Vacant(base) => Entry::Vacant(VacantEntry { base }),\n    }\n}\n\n#[inline]\npub(super) fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n    match err {\n        hashbrown::TryReserveError::CapacityOverflow => TryReserveError::CapacityOverflow,\n        hashbrown::TryReserveError::AllocError { layout } => {\n            TryReserveError::AllocError { layout, non_exhaustive: () }\n        }\n    }\n}\n\n#[inline]\nfn map_raw_entry<'a, K: 'a, V: 'a, S: 'a>(\n    raw: base::RawEntryMut<'a, K, V, S>,\n) -> RawEntryMut<'a, K, V, S> {\n    match raw {\n        base::RawEntryMut::Occupied(base) => RawEntryMut::Occupied(RawOccupiedEntryMut { base }),\n        base::RawEntryMut::Vacant(base) => RawEntryMut::Vacant(RawVacantEntryMut { base }),\n    }\n}\n\n#[allow(dead_code)]\nfn assert_covariance() {\n    fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> {\n        v\n    }\n    fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str> {\n        v\n    }\n    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8> {\n        v\n    }\n    fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str> {\n        v\n    }\n    fn into_iter_key<'new>(v: IntoIter<&'static str, u8>) -> IntoIter<&'new str, u8> {\n        v\n    }\n    fn into_iter_val<'new>(v: IntoIter<u8, &'static str>) -> IntoIter<u8, &'new str> {\n        v\n    }\n    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8> {\n        v\n    }\n    fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str> {\n        v\n    }\n    fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8> {\n        v\n    }\n    fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> {\n        v\n    }\n    fn drain<'new>(\n        d: Drain<'static, &'static str, &'static str>,\n    ) -> Drain<'new, &'new str, &'new str> {\n        d\n    }\n}\n"],["2542","//! Collection types.\n//!\n//! Rust's standard collection library provides efficient implementations of the\n//! most common general purpose programming data structures. By using the\n//! standard implementations, it should be possible for two libraries to\n//! communicate without significant data conversion.\n//!\n//! To get this out of the way: you should probably just use [`Vec`] or [`HashMap`].\n//! These two collections cover most use cases for generic data storage and\n//! processing. They are exceptionally good at doing what they do. All the other\n//! collections in the standard library have specific use cases where they are\n//! the optimal choice, but these cases are borderline *niche* in comparison.\n//! Even when `Vec` and `HashMap` are technically suboptimal, they're probably a\n//! good enough choice to get started.\n//!\n//! Rust's collections can be grouped into four major categories:\n//!\n//! * Sequences: [`Vec`], [`VecDeque`], [`LinkedList`]\n//! * Maps: [`HashMap`], [`BTreeMap`]\n//! * Sets: [`HashSet`], [`BTreeSet`]\n//! * Misc: [`BinaryHeap`]\n//!\n//! # When Should You Use Which Collection?\n//!\n//! These are fairly high-level and quick break-downs of when each collection\n//! should be considered. Detailed discussions of strengths and weaknesses of\n//! individual collections can be found on their own documentation pages.\n//!\n//! ### Use a `Vec` when:\n//! * You want to collect items up to be processed or sent elsewhere later, and\n//!   don't care about any properties of the actual values being stored.\n//! * You want a sequence of elements in a particular order, and will only be\n//!   appending to (or near) the end.\n//! * You want a stack.\n//! * You want a resizable array.\n//! * You want a heap-allocated array.\n//!\n//! ### Use a `VecDeque` when:\n//! * You want a [`Vec`] that supports efficient insertion at both ends of the\n//!   sequence.\n//! * You want a queue.\n//! * You want a double-ended queue (deque).\n//!\n//! ### Use a `LinkedList` when:\n//! * You want a [`Vec`] or [`VecDeque`] of unknown size, and can't tolerate\n//!   amortization.\n//! * You want to efficiently split and append lists.\n//! * You are *absolutely* certain you *really*, *truly*, want a doubly linked\n//!   list.\n//!\n//! ### Use a `HashMap` when:\n//! * You want to associate arbitrary keys with an arbitrary value.\n//! * You want a cache.\n//! * You want a map, with no extra functionality.\n//!\n//! ### Use a `BTreeMap` when:\n//! * You want a map sorted by its keys.\n//! * You want to be able to get a range of entries on-demand.\n//! * You're interested in what the smallest or largest key-value pair is.\n//! * You want to find the largest or smallest key that is smaller or larger\n//!   than something.\n//!\n//! ### Use the `Set` variant of any of these `Map`s when:\n//! * You just want to remember which keys you've seen.\n//! * There is no meaningful value to associate with your keys.\n//! * You just want a set.\n//!\n//! ### Use a `BinaryHeap` when:\n//!\n//! * You want to store a bunch of elements, but only ever want to process the\n//!   \"biggest\" or \"most important\" one at any given time.\n//! * You want a priority queue.\n//!\n//! # Performance\n//!\n//! Choosing the right collection for the job requires an understanding of what\n//! each collection is good at. Here we briefly summarize the performance of\n//! different collections for certain important operations. For further details,\n//! see each type's documentation, and note that the names of actual methods may\n//! differ from the tables below on certain collections.\n//!\n//! Throughout the documentation, we will follow a few conventions. For all\n//! operations, the collection's size is denoted by n. If another collection is\n//! involved in the operation, it contains m elements. Operations which have an\n//! *amortized* cost are suffixed with a `*`. Operations with an *expected*\n//! cost are suffixed with a `~`.\n//!\n//! All amortized costs are for the potential need to resize when capacity is\n//! exhausted. If a resize occurs it will take *O*(*n*) time. Our collections never\n//! automatically shrink, so removal operations aren't amortized. Over a\n//! sufficiently large series of operations, the average cost per operation will\n//! deterministically equal the given cost.\n//!\n//! Only [`HashMap`] has expected costs, due to the probabilistic nature of hashing.\n//! It is theoretically possible, though very unlikely, for [`HashMap`] to\n//! experience worse performance.\n//!\n//! ## Sequences\n//!\n//! |                | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n//! |----------------|----------------|-----------------|----------------|--------|----------------|\n//! | [`Vec`]        | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n//! | [`VecDeque`]   | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n//! | [`LinkedList`] | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n//!\n//! Note that where ties occur, [`Vec`] is generally going to be faster than [`VecDeque`], and\n//! [`VecDeque`] is generally going to be faster than [`LinkedList`].\n//!\n//! ## Maps\n//!\n//! For Sets, all operations have the cost of the equivalent Map operation.\n//!\n//! |              | get       | insert    | remove    | range     | append |\n//! |--------------|-----------|-----------|-----------|-----------|--------|\n//! | [`HashMap`]  | O(1)~     | O(1)~*    | O(1)~     | N/A       | N/A    |\n//! | [`BTreeMap`] | O(log(n)) | O(log(n)) | O(log(n)) | O(log(n)) | O(n+m) |\n//!\n//! # Correct and Efficient Usage of Collections\n//!\n//! Of course, knowing which collection is the right one for the job doesn't\n//! instantly permit you to use it correctly. Here are some quick tips for\n//! efficient and correct usage of the standard collections in general. If\n//! you're interested in how to use a specific collection in particular, consult\n//! its documentation for detailed discussion and code examples.\n//!\n//! ## Capacity Management\n//!\n//! Many collections provide several constructors and methods that refer to\n//! \"capacity\". These collections are generally built on top of an array.\n//! Optimally, this array would be exactly the right size to fit only the\n//! elements stored in the collection, but for the collection to do this would\n//! be very inefficient. If the backing array was exactly the right size at all\n//! times, then every time an element is inserted, the collection would have to\n//! grow the array to fit it. Due to the way memory is allocated and managed on\n//! most computers, this would almost surely require allocating an entirely new\n//! array and copying every single element from the old one into the new one.\n//! Hopefully you can see that this wouldn't be very efficient to do on every\n//! operation.\n//!\n//! Most collections therefore use an *amortized* allocation strategy. They\n//! generally let themselves have a fair amount of unoccupied space so that they\n//! only have to grow on occasion. When they do grow, they allocate a\n//! substantially larger array to move the elements into so that it will take a\n//! while for another grow to be required. While this strategy is great in\n//! general, it would be even better if the collection *never* had to resize its\n//! backing array. Unfortunately, the collection itself doesn't have enough\n//! information to do this itself. Therefore, it is up to us programmers to give\n//! it hints.\n//!\n//! Any `with_capacity` constructor will instruct the collection to allocate\n//! enough space for the specified number of elements. Ideally this will be for\n//! exactly that many elements, but some implementation details may prevent\n//! this. See collection-specific documentation for details. In general, use\n//! `with_capacity` when you know exactly how many elements will be inserted, or\n//! at least have a reasonable upper-bound on that number.\n//!\n//! When anticipating a large influx of elements, the `reserve` family of\n//! methods can be used to hint to the collection how much room it should make\n//! for the coming items. As with `with_capacity`, the precise behavior of\n//! these methods will be specific to the collection of interest.\n//!\n//! For optimal performance, collections will generally avoid shrinking\n//! themselves. If you believe that a collection will not soon contain any more\n//! elements, or just really need the memory, the `shrink_to_fit` method prompts\n//! the collection to shrink the backing array to the minimum size capable of\n//! holding its elements.\n//!\n//! Finally, if ever you're interested in what the actual capacity of the\n//! collection is, most collections provide a `capacity` method to query this\n//! information on demand. This can be useful for debugging purposes, or for\n//! use with the `reserve` methods.\n//!\n//! ## Iterators\n//!\n//! Iterators are a powerful and robust mechanism used throughout Rust's\n//! standard libraries. Iterators provide a sequence of values in a generic,\n//! safe, efficient and convenient way. The contents of an iterator are usually\n//! *lazily* evaluated, so that only the values that are actually needed are\n//! ever actually produced, and no allocation need be done to temporarily store\n//! them. Iterators are primarily consumed using a `for` loop, although many\n//! functions also take iterators where a collection or sequence of values is\n//! desired.\n//!\n//! All of the standard collections provide several iterators for performing\n//! bulk manipulation of their contents. The three primary iterators almost\n//! every collection should provide are `iter`, `iter_mut`, and `into_iter`.\n//! Some of these are not provided on collections where it would be unsound or\n//! unreasonable to provide them.\n//!\n//! `iter` provides an iterator of immutable references to all the contents of a\n//! collection in the most \"natural\" order. For sequence collections like [`Vec`],\n//! this means the items will be yielded in increasing order of index starting\n//! at 0. For ordered collections like [`BTreeMap`], this means that the items\n//! will be yielded in sorted order. For unordered collections like [`HashMap`],\n//! the items will be yielded in whatever order the internal representation made\n//! most convenient. This is great for reading through all the contents of the\n//! collection.\n//!\n//! ```\n//! let vec = vec![1, 2, 3, 4];\n//! for x in vec.iter() {\n//!    println!(\"vec contained {}\", x);\n//! }\n//! ```\n//!\n//! `iter_mut` provides an iterator of *mutable* references in the same order as\n//! `iter`. This is great for mutating all the contents of the collection.\n//!\n//! ```\n//! let mut vec = vec![1, 2, 3, 4];\n//! for x in vec.iter_mut() {\n//!    *x += 1;\n//! }\n//! ```\n//!\n//! `into_iter` transforms the actual collection into an iterator over its\n//! contents by-value. This is great when the collection itself is no longer\n//! needed, and the values are needed elsewhere. Using `extend` with `into_iter`\n//! is the main way that contents of one collection are moved into another.\n//! `extend` automatically calls `into_iter`, and takes any `T: `[`IntoIterator`].\n//! Calling `collect` on an iterator itself is also a great way to convert one\n//! collection into another. Both of these methods should internally use the\n//! capacity management tools discussed in the previous section to do this as\n//! efficiently as possible.\n//!\n//! ```\n//! let mut vec1 = vec![1, 2, 3, 4];\n//! let vec2 = vec![10, 20, 30, 40];\n//! vec1.extend(vec2);\n//! ```\n//!\n//! ```\n//! use std::collections::VecDeque;\n//!\n//! let vec = vec![1, 2, 3, 4];\n//! let buf: VecDeque<_> = vec.into_iter().collect();\n//! ```\n//!\n//! Iterators also provide a series of *adapter* methods for performing common\n//! threads to sequences. Among the adapters are functional favorites like `map`,\n//! `fold`, `skip` and `take`. Of particular interest to collections is the\n//! `rev` adapter, that reverses any iterator that supports this operation. Most\n//! collections provide reversible iterators as the way to iterate over them in\n//! reverse order.\n//!\n//! ```\n//! let vec = vec![1, 2, 3, 4];\n//! for x in vec.iter().rev() {\n//!    println!(\"vec contained {}\", x);\n//! }\n//! ```\n//!\n//! Several other collection methods also return iterators to yield a sequence\n//! of results but avoid allocating an entire collection to store the result in.\n//! This provides maximum flexibility as `collect` or `extend` can be called to\n//! \"pipe\" the sequence into any collection if desired. Otherwise, the sequence\n//! can be looped over with a `for` loop. The iterator can also be discarded\n//! after partial use, preventing the computation of the unused items.\n//!\n//! ## Entries\n//!\n//! The `entry` API is intended to provide an efficient mechanism for\n//! manipulating the contents of a map conditionally on the presence of a key or\n//! not. The primary motivating use case for this is to provide efficient\n//! accumulator maps. For instance, if one wishes to maintain a count of the\n//! number of times each key has been seen, they will have to perform some\n//! conditional logic on whether this is the first time the key has been seen or\n//! not. Normally, this would require a `find` followed by an `insert`,\n//! effectively duplicating the search effort on each insertion.\n//!\n//! When a user calls `map.entry(&key)`, the map will search for the key and\n//! then yield a variant of the `Entry` enum.\n//!\n//! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case\n//! the only valid operation is to `insert` a value into the entry. When this is\n//! done, the vacant entry is consumed and converted into a mutable reference to\n//! the value that was inserted. This allows for further manipulation of the\n//! value beyond the lifetime of the search itself. This is useful if complex\n//! logic needs to be performed on the value regardless of whether the value was\n//! just inserted.\n//!\n//! If an `Occupied(entry)` is yielded, then the key *was* found. In this case,\n//! the user has several options: they can `get`, `insert` or `remove` the\n//! value of the occupied entry. Additionally, they can convert the occupied\n//! entry into a mutable reference to its value, providing symmetry to the\n//! vacant `insert` case.\n//!\n//! ### Examples\n//!\n//! Here are the two primary ways in which `entry` is used. First, a simple\n//! example where the logic performed on the values is trivial.\n//!\n//! #### Counting the number of times each character in a string occurs\n//!\n//! ```\n//! use std::collections::btree_map::BTreeMap;\n//!\n//! let mut count = BTreeMap::new();\n//! let message = \"she sells sea shells by the sea shore\";\n//!\n//! for c in message.chars() {\n//!     *count.entry(c).or_insert(0) += 1;\n//! }\n//!\n//! assert_eq!(count.get(&'s'), Some(&8));\n//!\n//! println!(\"Number of occurrences of each character\");\n//! for (char, count) in &count {\n//!     println!(\"{}: {}\", char, count);\n//! }\n//! ```\n//!\n//! When the logic to be performed on the value is more complex, we may simply\n//! use the `entry` API to ensure that the value is initialized and perform the\n//! logic afterwards.\n//!\n//! #### Tracking the inebriation of customers at a bar\n//!\n//! ```\n//! use std::collections::btree_map::BTreeMap;\n//!\n//! // A client of the bar. They have a blood alcohol level.\n//! struct Person { blood_alcohol: f32 }\n//!\n//! // All the orders made to the bar, by client ID.\n//! let orders = vec![1, 2, 1, 2, 3, 4, 1, 2, 2, 3, 4, 1, 1, 1];\n//!\n//! // Our clients.\n//! let mut blood_alcohol = BTreeMap::new();\n//!\n//! for id in orders {\n//!     // If this is the first time we've seen this customer, initialize them\n//!     // with no blood alcohol. Otherwise, just retrieve them.\n//!     let person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: 0.0 });\n//!\n//!     // Reduce their blood alcohol level. It takes time to order and drink a beer!\n//!     person.blood_alcohol *= 0.9;\n//!\n//!     // Check if they're sober enough to have another beer.\n//!     if person.blood_alcohol > 0.3 {\n//!         // Too drunk... for now.\n//!         println!(\"Sorry {}, I have to cut you off\", id);\n//!     } else {\n//!         // Have another!\n//!         person.blood_alcohol += 0.1;\n//!     }\n//! }\n//! ```\n//!\n//! # Insert and complex keys\n//!\n//! If we have a more complex key, calls to `insert` will\n//! not update the value of the key. For example:\n//!\n//! ```\n//! use std::cmp::Ordering;\n//! use std::collections::BTreeMap;\n//! use std::hash::{Hash, Hasher};\n//!\n//! #[derive(Debug)]\n//! struct Foo {\n//!     a: u32,\n//!     b: &'static str,\n//! }\n//!\n//! // we will compare `Foo`s by their `a` value only.\n//! impl PartialEq for Foo {\n//!     fn eq(&self, other: &Self) -> bool { self.a == other.a }\n//! }\n//!\n//! impl Eq for Foo {}\n//!\n//! // we will hash `Foo`s by their `a` value only.\n//! impl Hash for Foo {\n//!     fn hash<H: Hasher>(&self, h: &mut H) { self.a.hash(h); }\n//! }\n//!\n//! impl PartialOrd for Foo {\n//!     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { self.a.partial_cmp(&other.a) }\n//! }\n//!\n//! impl Ord for Foo {\n//!     fn cmp(&self, other: &Self) -> Ordering { self.a.cmp(&other.a) }\n//! }\n//!\n//! let mut map = BTreeMap::new();\n//! map.insert(Foo { a: 1, b: \"baz\" }, 99);\n//!\n//! // We already have a Foo with an a of 1, so this will be updating the value.\n//! map.insert(Foo { a: 1, b: \"xyz\" }, 100);\n//!\n//! // The value has been updated...\n//! assert_eq!(map.values().next().unwrap(), &100);\n//!\n//! // ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\n//! assert_eq!(map.keys().next().unwrap().b, \"baz\");\n//! ```\n//!\n//! [`IntoIterator`]: crate::iter::IntoIterator\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME(#82080) The deprecation here is only theoretical, and does not actually produce a warning.\n#[rustc_deprecated(reason = \"moved to `std::ops::Bound`\", since = \"1.26.0\")]\n#[doc(hidden)]\npub use crate::ops::Bound;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{binary_heap, btree_map, btree_set};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{linked_list, vec_deque};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{BTreeMap, BTreeSet, BinaryHeap};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{LinkedList, VecDeque};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::hash_map::HashMap;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::hash_set::HashSet;\n\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\npub use alloc_crate::collections::TryReserveError;\n\nmod hash;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod hash_map {\n    //! A hash map implemented with quadratic probing and SIMD lookup.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::hash::map::*;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod hash_set {\n    //! A hash set implemented as a `HashMap` where the value is `()`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::hash::set::*;\n}\n"],["2543","//! Cross-platform path manipulation.\n//!\n//! This module provides two types, [`PathBuf`] and [`Path`] (akin to [`String`]\n//! and [`str`]), for working with paths abstractly. These types are thin wrappers\n//! around [`OsString`] and [`OsStr`] respectively, meaning that they work directly\n//! on strings according to the local platform's path syntax.\n//!\n//! Paths can be parsed into [`Component`]s by iterating over the structure\n//! returned by the [`components`] method on [`Path`]. [`Component`]s roughly\n//! correspond to the substrings between path separators (`/` or `\\`). You can\n//! reconstruct an equivalent path from components with the [`push`] method on\n//! [`PathBuf`]; note that the paths may differ syntactically by the\n//! normalization described in the documentation for the [`components`] method.\n//!\n//! ## Simple usage\n//!\n//! Path manipulation includes both parsing components from slices and building\n//! new owned paths.\n//!\n//! To parse a path, you can create a [`Path`] slice from a [`str`]\n//! slice and start asking questions:\n//!\n//! ```\n//! use std::path::Path;\n//! use std::ffi::OsStr;\n//!\n//! let path = Path::new(\"/tmp/foo/bar.txt\");\n//!\n//! let parent = path.parent();\n//! assert_eq!(parent, Some(Path::new(\"/tmp/foo\")));\n//!\n//! let file_stem = path.file_stem();\n//! assert_eq!(file_stem, Some(OsStr::new(\"bar\")));\n//!\n//! let extension = path.extension();\n//! assert_eq!(extension, Some(OsStr::new(\"txt\")));\n//! ```\n//!\n//! To build or modify paths, use [`PathBuf`]:\n//!\n//! ```\n//! use std::path::PathBuf;\n//!\n//! // This way works...\n//! let mut path = PathBuf::from(\"c:\\\\\");\n//!\n//! path.push(\"windows\");\n//! path.push(\"system32\");\n//!\n//! path.set_extension(\"dll\");\n//!\n//! // ... but push is best used if you don't know everything up\n//! // front. If you do, this way is better:\n//! let path: PathBuf = [\"c:\\\\\", \"windows\", \"system32.dll\"].iter().collect();\n//! ```\n//!\n//! [`components`]: Path::components\n//! [`push`]: PathBuf::push\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![deny(unsafe_op_in_unsafe_fn)]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::borrow::{Borrow, Cow};\nuse crate::cmp;\nuse crate::error::Error;\nuse crate::fmt;\nuse crate::fs;\nuse crate::hash::{Hash, Hasher};\nuse crate::io;\nuse crate::iter::{self, FusedIterator};\nuse crate::ops::{self, Deref};\nuse crate::rc::Rc;\nuse crate::str::FromStr;\nuse crate::sync::Arc;\n\nuse crate::ffi::{OsStr, OsString};\n\nuse crate::sys::path::{is_sep_byte, is_verbatim_sep, parse_prefix, MAIN_SEP_STR};\n\n////////////////////////////////////////////////////////////////////////////////\n// GENERAL NOTES\n////////////////////////////////////////////////////////////////////////////////\n//\n// Parsing in this module is done by directly transmuting OsStr to [u8] slices,\n// taking advantage of the fact that OsStr always encodes ASCII characters\n// as-is.  Eventually, this transmutation should be replaced by direct uses of\n// OsStr APIs for parsing, but it will take a while for those to become\n// available.\n\n////////////////////////////////////////////////////////////////////////////////\n// Windows Prefixes\n////////////////////////////////////////////////////////////////////////////////\n\n/// Windows path prefixes, e.g., `C:` or `\\\\server\\share`.\n///\n/// Windows uses a variety of path prefix styles, including references to drive\n/// volumes (like `C:`), network shared folders (like `\\\\server\\share`), and\n/// others. In addition, some path prefixes are \"verbatim\" (i.e., prefixed with\n/// `\\\\?\\`), in which case `/` is *not* treated as a separator and essentially\n/// no normalization is performed.\n///\n/// # Examples\n///\n/// ```\n/// use std::path::{Component, Path, Prefix};\n/// use std::path::Prefix::*;\n/// use std::ffi::OsStr;\n///\n/// fn get_path_prefix(s: &str) -> Prefix {\n///     let path = Path::new(s);\n///     match path.components().next().unwrap() {\n///         Component::Prefix(prefix_component) => prefix_component.kind(),\n///         _ => panic!(),\n///     }\n/// }\n///\n/// # if cfg!(windows) {\n/// assert_eq!(Verbatim(OsStr::new(\"pictures\")),\n///            get_path_prefix(r\"\\\\?\\pictures\\kittens\"));\n/// assert_eq!(VerbatimUNC(OsStr::new(\"server\"), OsStr::new(\"share\")),\n///            get_path_prefix(r\"\\\\?\\UNC\\server\\share\"));\n/// assert_eq!(VerbatimDisk(b'C'), get_path_prefix(r\"\\\\?\\c:\\\"));\n/// assert_eq!(DeviceNS(OsStr::new(\"BrainInterface\")),\n///            get_path_prefix(r\"\\\\.\\BrainInterface\"));\n/// assert_eq!(UNC(OsStr::new(\"server\"), OsStr::new(\"share\")),\n///            get_path_prefix(r\"\\\\server\\share\"));\n/// assert_eq!(Disk(b'C'), get_path_prefix(r\"C:\\Users\\Rust\\Pictures\\Ferris\"));\n/// # }\n/// ```\n#[derive(Copy, Clone, Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Prefix<'a> {\n    /// Verbatim prefix, e.g., `\\\\?\\cat_pics`.\n    ///\n    /// Verbatim prefixes consist of `\\\\?\\` immediately followed by the given\n    /// component.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Verbatim(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n\n    /// Verbatim prefix using Windows' _**U**niform **N**aming **C**onvention_,\n    /// e.g., `\\\\?\\UNC\\server\\share`.\n    ///\n    /// Verbatim UNC prefixes consist of `\\\\?\\UNC\\` immediately followed by the\n    /// server's hostname and a share name.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    VerbatimUNC(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n        #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n    ),\n\n    /// Verbatim disk prefix, e.g., `\\\\?\\C:`.\n    ///\n    /// Verbatim disk prefixes consist of `\\\\?\\` immediately followed by the\n    /// drive letter and `:`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    VerbatimDisk(#[stable(feature = \"rust1\", since = \"1.0.0\")] u8),\n\n    /// Device namespace prefix, e.g., `\\\\.\\COM42`.\n    ///\n    /// Device namespace prefixes consist of `\\\\.\\` immediately followed by the\n    /// device name.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    DeviceNS(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n\n    /// Prefix using Windows' _**U**niform **N**aming **C**onvention_, e.g.\n    /// `\\\\server\\share`.\n    ///\n    /// UNC prefixes consist of the server's hostname and a share name.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    UNC(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n        #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n    ),\n\n    /// Prefix `C:` for the given disk drive.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Disk(#[stable(feature = \"rust1\", since = \"1.0.0\")] u8),\n}\n\nimpl<'a> Prefix<'a> {\n    #[inline]\n    fn len(&self) -> usize {\n        use self::Prefix::*;\n        fn os_str_len(s: &OsStr) -> usize {\n            os_str_as_u8_slice(s).len()\n        }\n        match *self {\n            Verbatim(x) => 4 + os_str_len(x),\n            VerbatimUNC(x, y) => {\n                8 + os_str_len(x) + if os_str_len(y) > 0 { 1 + os_str_len(y) } else { 0 }\n            }\n            VerbatimDisk(_) => 6,\n            UNC(x, y) => 2 + os_str_len(x) + if os_str_len(y) > 0 { 1 + os_str_len(y) } else { 0 },\n            DeviceNS(x) => 4 + os_str_len(x),\n            Disk(_) => 2,\n        }\n    }\n\n    /// Determines if the prefix is verbatim, i.e., begins with `\\\\?\\`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Prefix::*;\n    /// use std::ffi::OsStr;\n    ///\n    /// assert!(Verbatim(OsStr::new(\"pictures\")).is_verbatim());\n    /// assert!(VerbatimUNC(OsStr::new(\"server\"), OsStr::new(\"share\")).is_verbatim());\n    /// assert!(VerbatimDisk(b'C').is_verbatim());\n    /// assert!(!DeviceNS(OsStr::new(\"BrainInterface\")).is_verbatim());\n    /// assert!(!UNC(OsStr::new(\"server\"), OsStr::new(\"share\")).is_verbatim());\n    /// assert!(!Disk(b'C').is_verbatim());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_verbatim(&self) -> bool {\n        use self::Prefix::*;\n        matches!(*self, Verbatim(_) | VerbatimDisk(_) | VerbatimUNC(..))\n    }\n\n    #[inline]\n    fn is_drive(&self) -> bool {\n        matches!(*self, Prefix::Disk(_))\n    }\n\n    #[inline]\n    fn has_implicit_root(&self) -> bool {\n        !self.is_drive()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Exposed parsing helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/// Determines whether the character is one of the permitted path\n/// separators for the current platform.\n///\n/// # Examples\n///\n/// ```\n/// use std::path;\n///\n/// assert!(path::is_separator('/')); // '/' works for both Unix and Windows\n/// assert!(!path::is_separator('❤'));\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn is_separator(c: char) -> bool {\n    c.is_ascii() && is_sep_byte(c as u8)\n}\n\n/// The primary separator of path components for the current platform.\n///\n/// For example, `/` on Unix and `\\` on Windows.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAIN_SEPARATOR: char = crate::sys::path::MAIN_SEP;\n\n////////////////////////////////////////////////////////////////////////////////\n// Misc helpers\n////////////////////////////////////////////////////////////////////////////////\n\n// Iterate through `iter` while it matches `prefix`; return `None` if `prefix`\n// is not a prefix of `iter`, otherwise return `Some(iter_after_prefix)` giving\n// `iter` after having exhausted `prefix`.\nfn iter_after<'a, 'b, I, J>(mut iter: I, mut prefix: J) -> Option<I>\nwhere\n    I: Iterator<Item = Component<'a>> + Clone,\n    J: Iterator<Item = Component<'b>>,\n{\n    loop {\n        let mut iter_next = iter.clone();\n        match (iter_next.next(), prefix.next()) {\n            (Some(ref x), Some(ref y)) if x == y => (),\n            (Some(_), Some(_)) => return None,\n            (Some(_), None) => return Some(iter),\n            (None, None) => return Some(iter),\n            (None, Some(_)) => return None,\n        }\n        iter = iter_next;\n    }\n}\n\n// See note at the top of this module to understand why these are used:\n//\n// These casts are safe as OsStr is internally a wrapper around [u8] on all\n// platforms.\n//\n// Note that currently this relies on the special knowledge that libstd has;\n// these types are single-element structs but are not marked repr(transparent)\n// or repr(C) which would make these casts allowable outside std.\nfn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n    unsafe { &*(s as *const OsStr as *const [u8]) }\n}\nunsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n    // SAFETY: see the comment of `os_str_as_u8_slice`\n    unsafe { &*(s as *const [u8] as *const OsStr) }\n}\n\n// Detect scheme on Redox\nfn has_redox_scheme(s: &[u8]) -> bool {\n    cfg!(target_os = \"redox\") && s.contains(&b':')\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Cross-platform, iterator-independent parsing\n////////////////////////////////////////////////////////////////////////////////\n\n/// Says whether the first byte after the prefix is a separator.\nfn has_physical_root(s: &[u8], prefix: Option<Prefix<'_>>) -> bool {\n    let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n    !path.is_empty() && is_sep_byte(path[0])\n}\n\n// basic workhorse for splitting stem and extension\nfn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n    if os_str_as_u8_slice(file) == b\"..\" {\n        return (Some(file), None);\n    }\n\n    // The unsafety here stems from converting between &OsStr and &[u8]\n    // and back. This is safe to do because (1) we only look at ASCII\n    // contents of the encoding and (2) new &OsStr values are produced\n    // only from ASCII-bounded slices of existing &OsStr values.\n    let mut iter = os_str_as_u8_slice(file).rsplitn(2, |b| *b == b'.');\n    let after = iter.next();\n    let before = iter.next();\n    if before == Some(b\"\") {\n        (Some(file), None)\n    } else {\n        unsafe { (before.map(|s| u8_slice_as_os_str(s)), after.map(|s| u8_slice_as_os_str(s))) }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// The core iterators\n////////////////////////////////////////////////////////////////////////////////\n\n/// Component parsing works by a double-ended state machine; the cursors at the\n/// front and back of the path each keep track of what parts of the path have\n/// been consumed so far.\n///\n/// Going front to back, a path is made up of a prefix, a starting\n/// directory component, and a body (of normal components)\n#[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\nenum State {\n    Prefix = 0,   // c:\n    StartDir = 1, // / or . or nothing\n    Body = 2,     // foo/bar/baz\n    Done = 3,\n}\n\n/// A structure wrapping a Windows path prefix as well as its unparsed string\n/// representation.\n///\n/// In addition to the parsed [`Prefix`] information returned by [`kind`],\n/// `PrefixComponent` also holds the raw and unparsed [`OsStr`] slice,\n/// returned by [`as_os_str`].\n///\n/// Instances of this `struct` can be obtained by matching against the\n/// [`Prefix` variant] on [`Component`].\n///\n/// Does not occur on Unix.\n///\n/// # Examples\n///\n/// ```\n/// # if cfg!(windows) {\n/// use std::path::{Component, Path, Prefix};\n/// use std::ffi::OsStr;\n///\n/// let path = Path::new(r\"c:\\you\\later\\\");\n/// match path.components().next().unwrap() {\n///     Component::Prefix(prefix_component) => {\n///         assert_eq!(Prefix::Disk(b'C'), prefix_component.kind());\n///         assert_eq!(OsStr::new(\"c:\"), prefix_component.as_os_str());\n///     }\n///     _ => unreachable!(),\n/// }\n/// # }\n/// ```\n///\n/// [`as_os_str`]: PrefixComponent::as_os_str\n/// [`kind`]: PrefixComponent::kind\n/// [`Prefix` variant]: Component::Prefix\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Eq, Debug)]\npub struct PrefixComponent<'a> {\n    /// The prefix as an unparsed `OsStr` slice.\n    raw: &'a OsStr,\n\n    /// The parsed prefix data.\n    parsed: Prefix<'a>,\n}\n\nimpl<'a> PrefixComponent<'a> {\n    /// Returns the parsed prefix data.\n    ///\n    /// See [`Prefix`]'s documentation for more information on the different\n    /// kinds of prefixes.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn kind(&self) -> Prefix<'a> {\n        self.parsed\n    }\n\n    /// Returns the raw [`OsStr`] slice for this prefix.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_os_str(&self) -> &'a OsStr {\n        self.raw\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> cmp::PartialEq for PrefixComponent<'a> {\n    #[inline]\n    fn eq(&self, other: &PrefixComponent<'a>) -> bool {\n        cmp::PartialEq::eq(&self.parsed, &other.parsed)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> cmp::PartialOrd for PrefixComponent<'a> {\n    #[inline]\n    fn partial_cmp(&self, other: &PrefixComponent<'a>) -> Option<cmp::Ordering> {\n        cmp::PartialOrd::partial_cmp(&self.parsed, &other.parsed)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Ord for PrefixComponent<'_> {\n    #[inline]\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n        cmp::Ord::cmp(&self.parsed, &other.parsed)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for PrefixComponent<'_> {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n        self.parsed.hash(h);\n    }\n}\n\n/// A single component of a path.\n///\n/// A `Component` roughly corresponds to a substring between path separators\n/// (`/` or `\\`).\n///\n/// This `enum` is created by iterating over [`Components`], which in turn is\n/// created by the [`components`](Path::components) method on [`Path`].\n///\n/// # Examples\n///\n/// ```rust\n/// use std::path::{Component, Path};\n///\n/// let path = Path::new(\"/tmp/foo/bar.txt\");\n/// let components = path.components().collect::<Vec<_>>();\n/// assert_eq!(&components, &[\n///     Component::RootDir,\n///     Component::Normal(\"tmp\".as_ref()),\n///     Component::Normal(\"foo\".as_ref()),\n///     Component::Normal(\"bar.txt\".as_ref()),\n/// ]);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Component<'a> {\n    /// A Windows path prefix, e.g., `C:` or `\\\\server\\share`.\n    ///\n    /// There is a large variety of prefix types, see [`Prefix`]'s documentation\n    /// for more.\n    ///\n    /// Does not occur on Unix.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Prefix(#[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>),\n\n    /// The root directory component, appears after any prefix and before anything else.\n    ///\n    /// It represents a separator that designates that a path starts from root.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    RootDir,\n\n    /// A reference to the current directory, i.e., `.`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    CurDir,\n\n    /// A reference to the parent directory, i.e., `..`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ParentDir,\n\n    /// A normal component, e.g., `a` and `b` in `a/b`.\n    ///\n    /// This variant is the most common one, it represents references to files\n    /// or directories.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Normal(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n}\n\nimpl<'a> Component<'a> {\n    /// Extracts the underlying [`OsStr`] slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"./tmp/foo/bar.txt\");\n    /// let components: Vec<_> = path.components().map(|comp| comp.as_os_str()).collect();\n    /// assert_eq!(&components, &[\".\", \"tmp\", \"foo\", \"bar.txt\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_os_str(self) -> &'a OsStr {\n        match self {\n            Component::Prefix(p) => p.as_os_str(),\n            Component::RootDir => OsStr::new(MAIN_SEP_STR),\n            Component::CurDir => OsStr::new(\".\"),\n            Component::ParentDir => OsStr::new(\"..\"),\n            Component::Normal(path) => path,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for Component<'_> {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n        self.as_os_str()\n    }\n}\n\n#[stable(feature = \"path_component_asref\", since = \"1.25.0\")]\nimpl AsRef<Path> for Component<'_> {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        self.as_os_str().as_ref()\n    }\n}\n\n/// An iterator over the [`Component`]s of a [`Path`].\n///\n/// This `struct` is created by the [`components`] method on [`Path`].\n/// See its documentation for more.\n///\n/// # Examples\n///\n/// ```\n/// use std::path::Path;\n///\n/// let path = Path::new(\"/tmp/foo/bar.txt\");\n///\n/// for component in path.components() {\n///     println!(\"{:?}\", component);\n/// }\n/// ```\n///\n/// [`components`]: Path::components\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Components<'a> {\n    // The path left to parse components from\n    path: &'a [u8],\n\n    // The prefix as it was originally parsed, if any\n    prefix: Option<Prefix<'a>>,\n\n    // true if path *physically* has a root separator; for most Windows\n    // prefixes, it may have a \"logical\" root separator for the purposes of\n    // normalization, e.g.,  \\\\server\\share == \\\\server\\share\\.\n    has_physical_root: bool,\n\n    // The iterator is double-ended, and these two states keep track of what has\n    // been produced from either end\n    front: State,\n    back: State,\n}\n\n/// An iterator over the [`Component`]s of a [`Path`], as [`OsStr`] slices.\n///\n/// This `struct` is created by the [`iter`] method on [`Path`].\n/// See its documentation for more.\n///\n/// [`iter`]: Path::iter\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a> {\n    inner: Components<'a>,\n}\n\n#[stable(feature = \"path_components_debug\", since = \"1.13.0\")]\nimpl fmt::Debug for Components<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        struct DebugHelper<'a>(&'a Path);\n\n        impl fmt::Debug for DebugHelper<'_> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.debug_list().entries(self.0.components()).finish()\n            }\n        }\n\n        f.debug_tuple(\"Components\").field(&DebugHelper(self.as_path())).finish()\n    }\n}\n\nimpl<'a> Components<'a> {\n    // how long is the prefix, if any?\n    #[inline]\n    fn prefix_len(&self) -> usize {\n        self.prefix.as_ref().map(Prefix::len).unwrap_or(0)\n    }\n\n    #[inline]\n    fn prefix_verbatim(&self) -> bool {\n        self.prefix.as_ref().map(Prefix::is_verbatim).unwrap_or(false)\n    }\n\n    /// how much of the prefix is left from the point of view of iteration?\n    #[inline]\n    fn prefix_remaining(&self) -> usize {\n        if self.front == State::Prefix { self.prefix_len() } else { 0 }\n    }\n\n    // Given the iteration so far, how much of the pre-State::Body path is left?\n    #[inline]\n    fn len_before_body(&self) -> usize {\n        let root = if self.front <= State::StartDir && self.has_physical_root { 1 } else { 0 };\n        let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() { 1 } else { 0 };\n        self.prefix_remaining() + root + cur_dir\n    }\n\n    // is the iteration complete?\n    #[inline]\n    fn finished(&self) -> bool {\n        self.front == State::Done || self.back == State::Done || self.front > self.back\n    }\n\n    #[inline]\n    fn is_sep_byte(&self, b: u8) -> bool {\n        if self.prefix_verbatim() { is_verbatim_sep(b) } else { is_sep_byte(b) }\n    }\n\n    /// Extracts a slice corresponding to the portion of the path remaining for iteration.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let mut components = Path::new(\"/tmp/foo/bar.txt\").components();\n    /// components.next();\n    /// components.next();\n    ///\n    /// assert_eq!(Path::new(\"foo/bar.txt\"), components.as_path());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_path(&self) -> &'a Path {\n        let mut comps = self.clone();\n        if comps.front == State::Body {\n            comps.trim_left();\n        }\n        if comps.back == State::Body {\n            comps.trim_right();\n        }\n        unsafe { Path::from_u8_slice(comps.path) }\n    }\n\n    /// Is the *original* path rooted?\n    fn has_root(&self) -> bool {\n        if self.has_physical_root {\n            return true;\n        }\n        if let Some(p) = self.prefix {\n            if p.has_implicit_root() {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Should the normalized path include a leading . ?\n    fn include_cur_dir(&self) -> bool {\n        if self.has_root() {\n            return false;\n        }\n        let mut iter = self.path[self.prefix_len()..].iter();\n        match (iter.next(), iter.next()) {\n            (Some(&b'.'), None) => true,\n            (Some(&b'.'), Some(&b)) => self.is_sep_byte(b),\n            _ => false,\n        }\n    }\n\n    // parse a given byte sequence into the corresponding path component\n    fn parse_single_component<'b>(&self, comp: &'b [u8]) -> Option<Component<'b>> {\n        match comp {\n            b\".\" if self.prefix_verbatim() => Some(Component::CurDir),\n            b\".\" => None, // . components are normalized away, except at\n            // the beginning of a path, which is treated\n            // separately via `include_cur_dir`\n            b\"..\" => Some(Component::ParentDir),\n            b\"\" => None,\n            _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) })),\n        }\n    }\n\n    // parse a component from the left, saying how many bytes to consume to\n    // remove the component\n    fn parse_next_component(&self) -> (usize, Option<Component<'a>>) {\n        debug_assert!(self.front == State::Body);\n        let (extra, comp) = match self.path.iter().position(|b| self.is_sep_byte(*b)) {\n            None => (0, self.path),\n            Some(i) => (1, &self.path[..i]),\n        };\n        (comp.len() + extra, self.parse_single_component(comp))\n    }\n\n    // parse a component from the right, saying how many bytes to consume to\n    // remove the component\n    fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) {\n        debug_assert!(self.back == State::Body);\n        let start = self.len_before_body();\n        let (extra, comp) = match self.path[start..].iter().rposition(|b| self.is_sep_byte(*b)) {\n            None => (0, &self.path[start..]),\n            Some(i) => (1, &self.path[start + i + 1..]),\n        };\n        (comp.len() + extra, self.parse_single_component(comp))\n    }\n\n    // trim away repeated separators (i.e., empty components) on the left\n    fn trim_left(&mut self) {\n        while !self.path.is_empty() {\n            let (size, comp) = self.parse_next_component();\n            if comp.is_some() {\n                return;\n            } else {\n                self.path = &self.path[size..];\n            }\n        }\n    }\n\n    // trim away repeated separators (i.e., empty components) on the right\n    fn trim_right(&mut self) {\n        while self.path.len() > self.len_before_body() {\n            let (size, comp) = self.parse_next_component_back();\n            if comp.is_some() {\n                return;\n            } else {\n                self.path = &self.path[..self.path.len() - size];\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for Components<'_> {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        self.as_path()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for Components<'_> {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n        self.as_path().as_os_str()\n    }\n}\n\n#[stable(feature = \"path_iter_debug\", since = \"1.13.0\")]\nimpl fmt::Debug for Iter<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        struct DebugHelper<'a>(&'a Path);\n\n        impl fmt::Debug for DebugHelper<'_> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.debug_list().entries(self.0.iter()).finish()\n            }\n        }\n\n        f.debug_tuple(\"Iter\").field(&DebugHelper(self.as_path())).finish()\n    }\n}\n\nimpl<'a> Iter<'a> {\n    /// Extracts a slice corresponding to the portion of the path remaining for iteration.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let mut iter = Path::new(\"/tmp/foo/bar.txt\").iter();\n    /// iter.next();\n    /// iter.next();\n    ///\n    /// assert_eq!(Path::new(\"foo/bar.txt\"), iter.as_path());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_path(&self) -> &'a Path {\n        self.inner.as_path()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for Iter<'_> {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        self.as_path()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for Iter<'_> {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n        self.as_path().as_os_str()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Iter<'a> {\n    type Item = &'a OsStr;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a OsStr> {\n        self.inner.next().map(Component::as_os_str)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for Iter<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a OsStr> {\n        self.inner.next_back().map(Component::as_os_str)\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for Iter<'_> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Components<'a> {\n    type Item = Component<'a>;\n\n    fn next(&mut self) -> Option<Component<'a>> {\n        while !self.finished() {\n            match self.front {\n                State::Prefix if self.prefix_len() > 0 => {\n                    self.front = State::StartDir;\n                    debug_assert!(self.prefix_len() <= self.path.len());\n                    let raw = &self.path[..self.prefix_len()];\n                    self.path = &self.path[self.prefix_len()..];\n                    return Some(Component::Prefix(PrefixComponent {\n                        raw: unsafe { u8_slice_as_os_str(raw) },\n                        parsed: self.prefix.unwrap(),\n                    }));\n                }\n                State::Prefix => {\n                    self.front = State::StartDir;\n                }\n                State::StartDir => {\n                    self.front = State::Body;\n                    if self.has_physical_root {\n                        debug_assert!(!self.path.is_empty());\n                        self.path = &self.path[1..];\n                        return Some(Component::RootDir);\n                    } else if let Some(p) = self.prefix {\n                        if p.has_implicit_root() && !p.is_verbatim() {\n                            return Some(Component::RootDir);\n                        }\n                    } else if self.include_cur_dir() {\n                        debug_assert!(!self.path.is_empty());\n                        self.path = &self.path[1..];\n                        return Some(Component::CurDir);\n                    }\n                }\n                State::Body if !self.path.is_empty() => {\n                    let (size, comp) = self.parse_next_component();\n                    self.path = &self.path[size..];\n                    if comp.is_some() {\n                        return comp;\n                    }\n                }\n                State::Body => {\n                    self.front = State::Done;\n                }\n                State::Done => unreachable!(),\n            }\n        }\n        None\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for Components<'a> {\n    fn next_back(&mut self) -> Option<Component<'a>> {\n        while !self.finished() {\n            match self.back {\n                State::Body if self.path.len() > self.len_before_body() => {\n                    let (size, comp) = self.parse_next_component_back();\n                    self.path = &self.path[..self.path.len() - size];\n                    if comp.is_some() {\n                        return comp;\n                    }\n                }\n                State::Body => {\n                    self.back = State::StartDir;\n                }\n                State::StartDir => {\n                    self.back = State::Prefix;\n                    if self.has_physical_root {\n                        self.path = &self.path[..self.path.len() - 1];\n                        return Some(Component::RootDir);\n                    } else if let Some(p) = self.prefix {\n                        if p.has_implicit_root() && !p.is_verbatim() {\n                            return Some(Component::RootDir);\n                        }\n                    } else if self.include_cur_dir() {\n                        self.path = &self.path[..self.path.len() - 1];\n                        return Some(Component::CurDir);\n                    }\n                }\n                State::Prefix if self.prefix_len() > 0 => {\n                    self.back = State::Done;\n                    return Some(Component::Prefix(PrefixComponent {\n                        raw: unsafe { u8_slice_as_os_str(self.path) },\n                        parsed: self.prefix.unwrap(),\n                    }));\n                }\n                State::Prefix => {\n                    self.back = State::Done;\n                    return None;\n                }\n                State::Done => unreachable!(),\n            }\n        }\n        None\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for Components<'_> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> cmp::PartialEq for Components<'a> {\n    #[inline]\n    fn eq(&self, other: &Components<'a>) -> bool {\n        Iterator::eq(self.clone().rev(), other.clone().rev())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Eq for Components<'_> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> cmp::PartialOrd for Components<'a> {\n    #[inline]\n    fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> {\n        Iterator::partial_cmp(self.clone(), other.clone())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Ord for Components<'_> {\n    #[inline]\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n        Iterator::cmp(self.clone(), other.clone())\n    }\n}\n\n/// An iterator over [`Path`] and its ancestors.\n///\n/// This `struct` is created by the [`ancestors`] method on [`Path`].\n/// See its documentation for more.\n///\n/// # Examples\n///\n/// ```\n/// use std::path::Path;\n///\n/// let path = Path::new(\"/foo/bar\");\n///\n/// for ancestor in path.ancestors() {\n///     println!(\"{}\", ancestor.display());\n/// }\n/// ```\n///\n/// [`ancestors`]: Path::ancestors\n#[derive(Copy, Clone, Debug)]\n#[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\npub struct Ancestors<'a> {\n    next: Option<&'a Path>,\n}\n\n#[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\nimpl<'a> Iterator for Ancestors<'a> {\n    type Item = &'a Path;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        let next = self.next;\n        self.next = next.and_then(Path::parent);\n        next\n    }\n}\n\n#[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\nimpl FusedIterator for Ancestors<'_> {}\n\n////////////////////////////////////////////////////////////////////////////////\n// Basic types and traits\n////////////////////////////////////////////////////////////////////////////////\n\n/// An owned, mutable path (akin to [`String`]).\n///\n/// This type provides methods like [`push`] and [`set_extension`] that mutate\n/// the path in place. It also implements [`Deref`] to [`Path`], meaning that\n/// all methods on [`Path`] slices are available on `PathBuf` values as well.\n///\n/// [`push`]: PathBuf::push\n/// [`set_extension`]: PathBuf::set_extension\n///\n/// More details about the overall approach can be found in\n/// the [module documentation](self).\n///\n/// # Examples\n///\n/// You can use [`push`] to build up a `PathBuf` from\n/// components:\n///\n/// ```\n/// use std::path::PathBuf;\n///\n/// let mut path = PathBuf::new();\n///\n/// path.push(r\"C:\\\");\n/// path.push(\"windows\");\n/// path.push(\"system32\");\n///\n/// path.set_extension(\"dll\");\n/// ```\n///\n/// However, [`push`] is best used for dynamic situations. This is a better way\n/// to do this when you know all of the components ahead of time:\n///\n/// ```\n/// use std::path::PathBuf;\n///\n/// let path: PathBuf = [r\"C:\\\", \"windows\", \"system32.dll\"].iter().collect();\n/// ```\n///\n/// We can still do better than this! Since these are all strings, we can use\n/// `From::from`:\n///\n/// ```\n/// use std::path::PathBuf;\n///\n/// let path = PathBuf::from(r\"C:\\windows\\system32.dll\");\n/// ```\n///\n/// Which method works best depends on what kind of situation you're in.\n#[cfg_attr(not(test), rustc_diagnostic_item = \"PathBuf\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME:\n// `PathBuf::as_mut_vec` current implementation relies\n// on `PathBuf` being layout-compatible with `Vec<u8>`.\n// When attribute privacy is implemented, `PathBuf` should be annotated as `#[repr(transparent)]`.\n// Anyway, `PathBuf` representation and layout are considered implementation detail, are\n// not documented and must not be relied upon.\npub struct PathBuf {\n    inner: OsString,\n}\n\nimpl PathBuf {\n    #[inline]\n    fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n        unsafe { &mut *(self as *mut PathBuf as *mut Vec<u8>) }\n    }\n\n    /// Allocates an empty `PathBuf`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let path = PathBuf::new();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn new() -> PathBuf {\n        PathBuf { inner: OsString::new() }\n    }\n\n    /// Creates a new `PathBuf` with a given capacity used to create the\n    /// internal [`OsString`]. See [`with_capacity`] defined on [`OsString`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let mut path = PathBuf::with_capacity(10);\n    /// let capacity = path.capacity();\n    ///\n    /// // This push is done without reallocating\n    /// path.push(r\"C:\\\");\n    ///\n    /// assert_eq!(capacity, path.capacity());\n    /// ```\n    ///\n    /// [`with_capacity`]: OsString::with_capacity\n    #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> PathBuf {\n        PathBuf { inner: OsString::with_capacity(capacity) }\n    }\n\n    /// Coerces to a [`Path`] slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let p = PathBuf::from(\"/test\");\n    /// assert_eq!(Path::new(\"/test\"), p.as_path());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_path(&self) -> &Path {\n        self\n    }\n\n    /// Extends `self` with `path`.\n    ///\n    /// If `path` is absolute, it replaces the current path.\n    ///\n    /// On Windows:\n    ///\n    /// * if `path` has a root but no prefix (e.g., `\\windows`), it\n    ///   replaces everything except for the prefix (if any) of `self`.\n    /// * if `path` has a prefix but no root, it replaces `self`.\n    ///\n    /// # Examples\n    ///\n    /// Pushing a relative path extends the existing path:\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let mut path = PathBuf::from(\"/tmp\");\n    /// path.push(\"file.bk\");\n    /// assert_eq!(path, PathBuf::from(\"/tmp/file.bk\"));\n    /// ```\n    ///\n    /// Pushing an absolute path replaces the existing path:\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let mut path = PathBuf::from(\"/tmp\");\n    /// path.push(\"/etc\");\n    /// assert_eq!(path, PathBuf::from(\"/etc\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push<P: AsRef<Path>>(&mut self, path: P) {\n        self._push(path.as_ref())\n    }\n\n    fn _push(&mut self, path: &Path) {\n        // in general, a separator is needed if the rightmost byte is not a separator\n        let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep_byte(*c)).unwrap_or(false);\n\n        // in the special case of `C:` on Windows, do *not* add a separator\n        {\n            let comps = self.components();\n            if comps.prefix_len() > 0\n                && comps.prefix_len() == comps.path.len()\n                && comps.prefix.unwrap().is_drive()\n            {\n                need_sep = false\n            }\n        }\n\n        // absolute `path` replaces `self`\n        if path.is_absolute() || path.prefix().is_some() {\n            self.as_mut_vec().truncate(0);\n\n        // `path` has a root but no prefix, e.g., `\\windows` (Windows only)\n        } else if path.has_root() {\n            let prefix_len = self.components().prefix_remaining();\n            self.as_mut_vec().truncate(prefix_len);\n\n        // `path` is a pure relative path\n        } else if need_sep {\n            self.inner.push(MAIN_SEP_STR);\n        }\n\n        self.inner.push(path);\n    }\n\n    /// Truncates `self` to [`self.parent`].\n    ///\n    /// Returns `false` and does nothing if [`self.parent`] is [`None`].\n    /// Otherwise, returns `true`.\n    ///\n    /// [`self.parent`]: Path::parent\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let mut p = PathBuf::from(\"/spirited/away.rs\");\n    ///\n    /// p.pop();\n    /// assert_eq!(Path::new(\"/spirited\"), p);\n    /// p.pop();\n    /// assert_eq!(Path::new(\"/\"), p);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> bool {\n        match self.parent().map(|p| p.as_u8_slice().len()) {\n            Some(len) => {\n                self.as_mut_vec().truncate(len);\n                true\n            }\n            None => false,\n        }\n    }\n\n    /// Updates [`self.file_name`] to `file_name`.\n    ///\n    /// If [`self.file_name`] was [`None`], this is equivalent to pushing\n    /// `file_name`.\n    ///\n    /// Otherwise it is equivalent to calling [`pop`] and then pushing\n    /// `file_name`. The new path will be a sibling of the original path.\n    /// (That is, it will have the same parent.)\n    ///\n    /// [`self.file_name`]: Path::file_name\n    /// [`pop`]: PathBuf::pop\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let mut buf = PathBuf::from(\"/\");\n    /// assert!(buf.file_name() == None);\n    /// buf.set_file_name(\"bar\");\n    /// assert!(buf == PathBuf::from(\"/bar\"));\n    /// assert!(buf.file_name().is_some());\n    /// buf.set_file_name(\"baz.txt\");\n    /// assert!(buf == PathBuf::from(\"/baz.txt\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_file_name<S: AsRef<OsStr>>(&mut self, file_name: S) {\n        self._set_file_name(file_name.as_ref())\n    }\n\n    fn _set_file_name(&mut self, file_name: &OsStr) {\n        if self.file_name().is_some() {\n            let popped = self.pop();\n            debug_assert!(popped);\n        }\n        self.push(file_name);\n    }\n\n    /// Updates [`self.extension`] to `extension`.\n    ///\n    /// Returns `false` and does nothing if [`self.file_name`] is [`None`],\n    /// returns `true` and updates the extension otherwise.\n    ///\n    /// If [`self.extension`] is [`None`], the extension is added; otherwise\n    /// it is replaced.\n    ///\n    /// [`self.file_name`]: Path::file_name\n    /// [`self.extension`]: Path::extension\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let mut p = PathBuf::from(\"/feel/the\");\n    ///\n    /// p.set_extension(\"force\");\n    /// assert_eq!(Path::new(\"/feel/the.force\"), p.as_path());\n    ///\n    /// p.set_extension(\"dark_side\");\n    /// assert_eq!(Path::new(\"/feel/the.dark_side\"), p.as_path());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool {\n        self._set_extension(extension.as_ref())\n    }\n\n    fn _set_extension(&mut self, extension: &OsStr) -> bool {\n        let file_stem = match self.file_stem() {\n            None => return false,\n            Some(f) => os_str_as_u8_slice(f),\n        };\n\n        // truncate until right after the file stem\n        let end_file_stem = file_stem[file_stem.len()..].as_ptr() as usize;\n        let start = os_str_as_u8_slice(&self.inner).as_ptr() as usize;\n        let v = self.as_mut_vec();\n        v.truncate(end_file_stem.wrapping_sub(start));\n\n        // add the new extension, if any\n        let new = os_str_as_u8_slice(extension);\n        if !new.is_empty() {\n            v.reserve_exact(new.len() + 1);\n            v.push(b'.');\n            v.extend_from_slice(new);\n        }\n\n        true\n    }\n\n    /// Consumes the `PathBuf`, yielding its internal [`OsString`] storage.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let p = PathBuf::from(\"/the/head\");\n    /// let os_str = p.into_os_string();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn into_os_string(self) -> OsString {\n        self.inner\n    }\n\n    /// Converts this `PathBuf` into a [boxed](Box) [`Path`].\n    #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n    #[inline]\n    pub fn into_boxed_path(self) -> Box<Path> {\n        let rw = Box::into_raw(self.inner.into_boxed_os_str()) as *mut Path;\n        unsafe { Box::from_raw(rw) }\n    }\n\n    /// Invokes [`capacity`] on the underlying instance of [`OsString`].\n    ///\n    /// [`capacity`]: OsString::capacity\n    #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        self.inner.capacity()\n    }\n\n    /// Invokes [`clear`] on the underlying instance of [`OsString`].\n    ///\n    /// [`clear`]: OsString::clear\n    #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n    #[inline]\n    pub fn clear(&mut self) {\n        self.inner.clear()\n    }\n\n    /// Invokes [`reserve`] on the underlying instance of [`OsString`].\n    ///\n    /// [`reserve`]: OsString::reserve\n    #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n        self.inner.reserve(additional)\n    }\n\n    /// Invokes [`reserve_exact`] on the underlying instance of [`OsString`].\n    ///\n    /// [`reserve_exact`]: OsString::reserve_exact\n    #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n    #[inline]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.inner.reserve_exact(additional)\n    }\n\n    /// Invokes [`shrink_to_fit`] on the underlying instance of [`OsString`].\n    ///\n    /// [`shrink_to_fit`]: OsString::shrink_to_fit\n    #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n    #[inline]\n    pub fn shrink_to_fit(&mut self) {\n        self.inner.shrink_to_fit()\n    }\n\n    /// Invokes [`shrink_to`] on the underlying instance of [`OsString`].\n    ///\n    /// [`shrink_to`]: OsString::shrink_to\n    #[unstable(feature = \"shrink_to\", issue = \"56431\")]\n    #[inline]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.inner.shrink_to(min_capacity)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for PathBuf {\n    #[inline]\n    fn clone(&self) -> Self {\n        PathBuf { inner: self.inner.clone() }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, source: &Self) {\n        self.inner.clone_from(&source.inner)\n    }\n}\n\n#[stable(feature = \"box_from_path\", since = \"1.17.0\")]\nimpl From<&Path> for Box<Path> {\n    /// Creates a boxed [`Path`] from a reference.\n    ///\n    /// This will allocate and clone `path` to it.\n    fn from(path: &Path) -> Box<Path> {\n        let boxed: Box<OsStr> = path.inner.into();\n        let rw = Box::into_raw(boxed) as *mut Path;\n        unsafe { Box::from_raw(rw) }\n    }\n}\n\n#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\nimpl From<Cow<'_, Path>> for Box<Path> {\n    /// Creates a boxed [`Path`] from a clone-on-write pointer.\n    ///\n    /// Converting from a `Cow::Owned` does not clone or allocate.\n    #[inline]\n    fn from(cow: Cow<'_, Path>) -> Box<Path> {\n        match cow {\n            Cow::Borrowed(path) => Box::from(path),\n            Cow::Owned(path) => Box::from(path),\n        }\n    }\n}\n\n#[stable(feature = \"path_buf_from_box\", since = \"1.18.0\")]\nimpl From<Box<Path>> for PathBuf {\n    /// Converts a `Box<Path>` into a `PathBuf`\n    ///\n    /// This conversion does not allocate or copy memory.\n    #[inline]\n    fn from(boxed: Box<Path>) -> PathBuf {\n        boxed.into_path_buf()\n    }\n}\n\n#[stable(feature = \"box_from_path_buf\", since = \"1.20.0\")]\nimpl From<PathBuf> for Box<Path> {\n    /// Converts a `PathBuf` into a `Box<Path>`\n    ///\n    /// This conversion currently should not allocate memory,\n    /// but this behavior is not guaranteed on all platforms or in all future versions.\n    #[inline]\n    fn from(p: PathBuf) -> Box<Path> {\n        p.into_boxed_path()\n    }\n}\n\n#[stable(feature = \"more_box_slice_clone\", since = \"1.29.0\")]\nimpl Clone for Box<Path> {\n    #[inline]\n    fn clone(&self) -> Self {\n        self.to_path_buf().into_boxed_path()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + AsRef<OsStr>> From<&T> for PathBuf {\n    /// Converts a borrowed `OsStr` to a `PathBuf`.\n    ///\n    /// Allocates a [`PathBuf`] and copies the data into it.\n    #[inline]\n    fn from(s: &T) -> PathBuf {\n        PathBuf::from(s.as_ref().to_os_string())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<OsString> for PathBuf {\n    /// Converts an [`OsString`] into a [`PathBuf`]\n    ///\n    /// This conversion does not allocate or copy memory.\n    #[inline]\n    fn from(s: OsString) -> PathBuf {\n        PathBuf { inner: s }\n    }\n}\n\n#[stable(feature = \"from_path_buf_for_os_string\", since = \"1.14.0\")]\nimpl From<PathBuf> for OsString {\n    /// Converts a [`PathBuf`] into an [`OsString`]\n    ///\n    /// This conversion does not allocate or copy memory.\n    #[inline]\n    fn from(path_buf: PathBuf) -> OsString {\n        path_buf.inner\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<String> for PathBuf {\n    /// Converts a [`String`] into a [`PathBuf`]\n    ///\n    /// This conversion does not allocate or copy memory.\n    #[inline]\n    fn from(s: String) -> PathBuf {\n        PathBuf::from(OsString::from(s))\n    }\n}\n\n#[stable(feature = \"path_from_str\", since = \"1.32.0\")]\nimpl FromStr for PathBuf {\n    type Err = core::convert::Infallible;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Ok(PathBuf::from(s))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<P: AsRef<Path>> iter::FromIterator<P> for PathBuf {\n    fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf {\n        let mut buf = PathBuf::new();\n        buf.extend(iter);\n        buf\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<P: AsRef<Path>> iter::Extend<P> for PathBuf {\n    fn extend<I: IntoIterator<Item = P>>(&mut self, iter: I) {\n        iter.into_iter().for_each(move |p| self.push(p.as_ref()));\n    }\n\n    #[inline]\n    fn extend_one(&mut self, p: P) {\n        self.push(p.as_ref());\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for PathBuf {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&**self, formatter)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for PathBuf {\n    type Target = Path;\n    #[inline]\n    fn deref(&self) -> &Path {\n        Path::new(&self.inner)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Borrow<Path> for PathBuf {\n    #[inline]\n    fn borrow(&self) -> &Path {\n        self.deref()\n    }\n}\n\n#[stable(feature = \"default_for_pathbuf\", since = \"1.17.0\")]\nimpl Default for PathBuf {\n    #[inline]\n    fn default() -> Self {\n        PathBuf::new()\n    }\n}\n\n#[stable(feature = \"cow_from_path\", since = \"1.6.0\")]\nimpl<'a> From<&'a Path> for Cow<'a, Path> {\n    /// Creates a clone-on-write pointer from a reference to\n    /// [`Path`].\n    ///\n    /// This conversion does not clone or allocate.\n    #[inline]\n    fn from(s: &'a Path) -> Cow<'a, Path> {\n        Cow::Borrowed(s)\n    }\n}\n\n#[stable(feature = \"cow_from_path\", since = \"1.6.0\")]\nimpl<'a> From<PathBuf> for Cow<'a, Path> {\n    /// Creates a clone-on-write pointer from an owned\n    /// instance of [`PathBuf`].\n    ///\n    /// This conversion does not clone or allocate.\n    #[inline]\n    fn from(s: PathBuf) -> Cow<'a, Path> {\n        Cow::Owned(s)\n    }\n}\n\n#[stable(feature = \"cow_from_pathbuf_ref\", since = \"1.28.0\")]\nimpl<'a> From<&'a PathBuf> for Cow<'a, Path> {\n    /// Creates a clone-on-write pointer from a reference to\n    /// [`PathBuf`].\n    ///\n    /// This conversion does not clone or allocate.\n    #[inline]\n    fn from(p: &'a PathBuf) -> Cow<'a, Path> {\n        Cow::Borrowed(p.as_path())\n    }\n}\n\n#[stable(feature = \"pathbuf_from_cow_path\", since = \"1.28.0\")]\nimpl<'a> From<Cow<'a, Path>> for PathBuf {\n    /// Converts a clone-on-write pointer to an owned path.\n    ///\n    /// Converting from a `Cow::Owned` does not clone or allocate.\n    #[inline]\n    fn from(p: Cow<'a, Path>) -> Self {\n        p.into_owned()\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<PathBuf> for Arc<Path> {\n    /// Converts a [`PathBuf`] into an [`Arc`] by moving the [`PathBuf`] data into a new [`Arc`] buffer.\n    #[inline]\n    fn from(s: PathBuf) -> Arc<Path> {\n        let arc: Arc<OsStr> = Arc::from(s.into_os_string());\n        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Path) }\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&Path> for Arc<Path> {\n    /// Converts a [`Path`] into an [`Arc`] by copying the [`Path`] data into a new [`Arc`] buffer.\n    #[inline]\n    fn from(s: &Path) -> Arc<Path> {\n        let arc: Arc<OsStr> = Arc::from(s.as_os_str());\n        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Path) }\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<PathBuf> for Rc<Path> {\n    /// Converts a [`PathBuf`] into an [`Rc`] by moving the [`PathBuf`] data into a new `Rc` buffer.\n    #[inline]\n    fn from(s: PathBuf) -> Rc<Path> {\n        let rc: Rc<OsStr> = Rc::from(s.into_os_string());\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Path) }\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&Path> for Rc<Path> {\n    /// Converts a [`Path`] into an [`Rc`] by copying the [`Path`] data into a new `Rc` buffer.\n    #[inline]\n    fn from(s: &Path) -> Rc<Path> {\n        let rc: Rc<OsStr> = Rc::from(s.as_os_str());\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Path) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToOwned for Path {\n    type Owned = PathBuf;\n    #[inline]\n    fn to_owned(&self) -> PathBuf {\n        self.to_path_buf()\n    }\n    #[inline]\n    fn clone_into(&self, target: &mut PathBuf) {\n        self.inner.clone_into(&mut target.inner);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::PartialEq for PathBuf {\n    #[inline]\n    fn eq(&self, other: &PathBuf) -> bool {\n        self.components() == other.components()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for PathBuf {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n        self.as_path().hash(h)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Eq for PathBuf {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::PartialOrd for PathBuf {\n    #[inline]\n    fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> {\n        self.components().partial_cmp(other.components())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Ord for PathBuf {\n    #[inline]\n    fn cmp(&self, other: &PathBuf) -> cmp::Ordering {\n        self.components().cmp(other.components())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for PathBuf {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n        &self.inner[..]\n    }\n}\n\n/// A slice of a path (akin to [`str`]).\n///\n/// This type supports a number of operations for inspecting a path, including\n/// breaking the path into its components (separated by `/` on Unix and by either\n/// `/` or `\\` on Windows), extracting the file name, determining whether the path\n/// is absolute, and so on.\n///\n/// This is an *unsized* type, meaning that it must always be used behind a\n/// pointer like `&` or [`Box`]. For an owned version of this type,\n/// see [`PathBuf`].\n///\n/// More details about the overall approach can be found in\n/// the [module documentation](self).\n///\n/// # Examples\n///\n/// ```\n/// use std::path::Path;\n/// use std::ffi::OsStr;\n///\n/// // Note: this example does work on Windows\n/// let path = Path::new(\"./foo/bar.txt\");\n///\n/// let parent = path.parent();\n/// assert_eq!(parent, Some(Path::new(\"./foo\")));\n///\n/// let file_stem = path.file_stem();\n/// assert_eq!(file_stem, Some(OsStr::new(\"bar\")));\n///\n/// let extension = path.extension();\n/// assert_eq!(extension, Some(OsStr::new(\"txt\")));\n/// ```\n#[cfg_attr(not(test), rustc_diagnostic_item = \"Path\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME:\n// `Path::new` current implementation relies\n// on `Path` being layout-compatible with `OsStr`.\n// When attribute privacy is implemented, `Path` should be annotated as `#[repr(transparent)]`.\n// Anyway, `Path` representation and layout are considered implementation detail, are\n// not documented and must not be relied upon.\npub struct Path {\n    inner: OsStr,\n}\n\n/// An error returned from [`Path::strip_prefix`] if the prefix was not found.\n///\n/// This `struct` is created by the [`strip_prefix`] method on [`Path`].\n/// See its documentation for more.\n///\n/// [`strip_prefix`]: Path::strip_prefix\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\npub struct StripPrefixError(());\n\nimpl Path {\n    // The following (private!) function allows construction of a path from a u8\n    // slice, which is only safe when it is known to follow the OsStr encoding.\n    unsafe fn from_u8_slice(s: &[u8]) -> &Path {\n        unsafe { Path::new(u8_slice_as_os_str(s)) }\n    }\n    // The following (private!) function reveals the byte encoding used for OsStr.\n    fn as_u8_slice(&self) -> &[u8] {\n        os_str_as_u8_slice(&self.inner)\n    }\n\n    /// Directly wraps a string slice as a `Path` slice.\n    ///\n    /// This is a cost-free conversion.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// Path::new(\"foo.txt\");\n    /// ```\n    ///\n    /// You can create `Path`s from `String`s, or even other `Path`s:\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let string = String::from(\"foo.txt\");\n    /// let from_string = Path::new(&string);\n    /// let from_path = Path::new(&from_string);\n    /// assert_eq!(from_string, from_path);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path {\n        unsafe { &*(s.as_ref() as *const OsStr as *const Path) }\n    }\n\n    /// Yields the underlying [`OsStr`] slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let os_str = Path::new(\"foo.txt\").as_os_str();\n    /// assert_eq!(os_str, std::ffi::OsStr::new(\"foo.txt\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_os_str(&self) -> &OsStr {\n        &self.inner\n    }\n\n    /// Yields a [`&str`] slice if the `Path` is valid unicode.\n    ///\n    /// This conversion may entail doing a check for UTF-8 validity.\n    /// Note that validation is performed because non-UTF-8 strings are\n    /// perfectly valid for some OS.\n    ///\n    /// [`&str`]: str\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"foo.txt\");\n    /// assert_eq!(path.to_str(), Some(\"foo.txt\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_str(&self) -> Option<&str> {\n        self.inner.to_str()\n    }\n\n    /// Converts a `Path` to a [`Cow<str>`].\n    ///\n    /// Any non-Unicode sequences are replaced with\n    /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n    ///\n    /// [U+FFFD]: super::char::REPLACEMENT_CHARACTER\n    ///\n    /// # Examples\n    ///\n    /// Calling `to_string_lossy` on a `Path` with valid unicode:\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"foo.txt\");\n    /// assert_eq!(path.to_string_lossy(), \"foo.txt\");\n    /// ```\n    ///\n    /// Had `path` contained invalid unicode, the `to_string_lossy` call might\n    /// have returned `\"fo�.txt\"`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n        self.inner.to_string_lossy()\n    }\n\n    /// Converts a `Path` to an owned [`PathBuf`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path_buf = Path::new(\"foo.txt\").to_path_buf();\n    /// assert_eq!(path_buf, std::path::PathBuf::from(\"foo.txt\"));\n    /// ```\n    #[rustc_conversion_suggestion]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_path_buf(&self) -> PathBuf {\n        PathBuf::from(self.inner.to_os_string())\n    }\n\n    /// Returns `true` if the `Path` is absolute, i.e., if it is independent of\n    /// the current directory.\n    ///\n    /// * On Unix, a path is absolute if it starts with the root, so\n    /// `is_absolute` and [`has_root`] are equivalent.\n    ///\n    /// * On Windows, a path is absolute if it has a prefix and starts with the\n    /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// assert!(!Path::new(\"foo.txt\").is_absolute());\n    /// ```\n    ///\n    /// [`has_root`]: Path::has_root\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow(deprecated)]\n    pub fn is_absolute(&self) -> bool {\n        if cfg!(target_os = \"redox\") {\n            // FIXME: Allow Redox prefixes\n            self.has_root() || has_redox_scheme(self.as_u8_slice())\n        } else {\n            self.has_root() && (cfg!(any(unix, target_os = \"wasi\")) || self.prefix().is_some())\n        }\n    }\n\n    /// Returns `true` if the `Path` is relative, i.e., not absolute.\n    ///\n    /// See [`is_absolute`]'s documentation for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// assert!(Path::new(\"foo.txt\").is_relative());\n    /// ```\n    ///\n    /// [`is_absolute`]: Path::is_absolute\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_relative(&self) -> bool {\n        !self.is_absolute()\n    }\n\n    fn prefix(&self) -> Option<Prefix<'_>> {\n        self.components().prefix\n    }\n\n    /// Returns `true` if the `Path` has a root.\n    ///\n    /// * On Unix, a path has a root if it begins with `/`.\n    ///\n    /// * On Windows, a path has a root if it:\n    ///     * has no prefix and begins with a separator, e.g., `\\windows`\n    ///     * has a prefix followed by a separator, e.g., `c:\\windows` but not `c:windows`\n    ///     * has any non-disk prefix, e.g., `\\\\server\\share`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// assert!(Path::new(\"/etc/passwd\").has_root());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn has_root(&self) -> bool {\n        self.components().has_root()\n    }\n\n    /// Returns the `Path` without its final component, if there is one.\n    ///\n    /// Returns [`None`] if the path terminates in a root or prefix.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/foo/bar\");\n    /// let parent = path.parent().unwrap();\n    /// assert_eq!(parent, Path::new(\"/foo\"));\n    ///\n    /// let grand_parent = parent.parent().unwrap();\n    /// assert_eq!(grand_parent, Path::new(\"/\"));\n    /// assert_eq!(grand_parent.parent(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn parent(&self) -> Option<&Path> {\n        let mut comps = self.components();\n        let comp = comps.next_back();\n        comp.and_then(|p| match p {\n            Component::Normal(_) | Component::CurDir | Component::ParentDir => {\n                Some(comps.as_path())\n            }\n            _ => None,\n        })\n    }\n\n    /// Produces an iterator over `Path` and its ancestors.\n    ///\n    /// The iterator will yield the `Path` that is returned if the [`parent`] method is used zero\n    /// or more times. That means, the iterator will yield `&self`, `&self.parent().unwrap()`,\n    /// `&self.parent().unwrap().parent().unwrap()` and so on. If the [`parent`] method returns\n    /// [`None`], the iterator will do likewise. The iterator will always yield at least one value,\n    /// namely `&self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let mut ancestors = Path::new(\"/foo/bar\").ancestors();\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"/foo/bar\")));\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"/foo\")));\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"/\")));\n    /// assert_eq!(ancestors.next(), None);\n    ///\n    /// let mut ancestors = Path::new(\"../foo/bar\").ancestors();\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"../foo/bar\")));\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"../foo\")));\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"..\")));\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"\")));\n    /// assert_eq!(ancestors.next(), None);\n    /// ```\n    ///\n    /// [`parent`]: Path::parent\n    #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n    #[inline]\n    pub fn ancestors(&self) -> Ancestors<'_> {\n        Ancestors { next: Some(&self) }\n    }\n\n    /// Returns the final component of the `Path`, if there is one.\n    ///\n    /// If the path is a normal file, this is the file name. If it's the path of a directory, this\n    /// is the directory name.\n    ///\n    /// Returns [`None`] if the path terminates in `..`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    /// use std::ffi::OsStr;\n    ///\n    /// assert_eq!(Some(OsStr::new(\"bin\")), Path::new(\"/usr/bin/\").file_name());\n    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"tmp/foo.txt\").file_name());\n    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.\").file_name());\n    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.//\").file_name());\n    /// assert_eq!(None, Path::new(\"foo.txt/..\").file_name());\n    /// assert_eq!(None, Path::new(\"/\").file_name());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn file_name(&self) -> Option<&OsStr> {\n        self.components().next_back().and_then(|p| match p {\n            Component::Normal(p) => Some(p),\n            _ => None,\n        })\n    }\n\n    /// Returns a path that, when joined onto `base`, yields `self`.\n    ///\n    /// # Errors\n    ///\n    /// If `base` is not a prefix of `self` (i.e., [`starts_with`]\n    /// returns `false`), returns [`Err`].\n    ///\n    /// [`starts_with`]: Path::starts_with\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let path = Path::new(\"/test/haha/foo.txt\");\n    ///\n    /// assert_eq!(path.strip_prefix(\"/\"), Ok(Path::new(\"test/haha/foo.txt\")));\n    /// assert_eq!(path.strip_prefix(\"/test\"), Ok(Path::new(\"haha/foo.txt\")));\n    /// assert_eq!(path.strip_prefix(\"/test/\"), Ok(Path::new(\"haha/foo.txt\")));\n    /// assert_eq!(path.strip_prefix(\"/test/haha/foo.txt\"), Ok(Path::new(\"\")));\n    /// assert_eq!(path.strip_prefix(\"/test/haha/foo.txt/\"), Ok(Path::new(\"\")));\n    ///\n    /// assert!(path.strip_prefix(\"test\").is_err());\n    /// assert!(path.strip_prefix(\"/haha\").is_err());\n    ///\n    /// let prefix = PathBuf::from(\"/test/\");\n    /// assert_eq!(path.strip_prefix(prefix), Ok(Path::new(\"haha/foo.txt\")));\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"path_strip_prefix\")]\n    pub fn strip_prefix<P>(&self, base: P) -> Result<&Path, StripPrefixError>\n    where\n        P: AsRef<Path>,\n    {\n        self._strip_prefix(base.as_ref())\n    }\n\n    fn _strip_prefix(&self, base: &Path) -> Result<&Path, StripPrefixError> {\n        iter_after(self.components(), base.components())\n            .map(|c| c.as_path())\n            .ok_or(StripPrefixError(()))\n    }\n\n    /// Determines whether `base` is a prefix of `self`.\n    ///\n    /// Only considers whole path components to match.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/etc/passwd\");\n    ///\n    /// assert!(path.starts_with(\"/etc\"));\n    /// assert!(path.starts_with(\"/etc/\"));\n    /// assert!(path.starts_with(\"/etc/passwd\"));\n    /// assert!(path.starts_with(\"/etc/passwd/\")); // extra slash is okay\n    /// assert!(path.starts_with(\"/etc/passwd///\")); // multiple extra slashes are okay\n    ///\n    /// assert!(!path.starts_with(\"/e\"));\n    /// assert!(!path.starts_with(\"/etc/passwd.txt\"));\n    ///\n    /// assert!(!Path::new(\"/etc/foo.rs\").starts_with(\"/etc/foo\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {\n        self._starts_with(base.as_ref())\n    }\n\n    fn _starts_with(&self, base: &Path) -> bool {\n        iter_after(self.components(), base.components()).is_some()\n    }\n\n    /// Determines whether `child` is a suffix of `self`.\n    ///\n    /// Only considers whole path components to match.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/etc/resolv.conf\");\n    ///\n    /// assert!(path.ends_with(\"resolv.conf\"));\n    /// assert!(path.ends_with(\"etc/resolv.conf\"));\n    /// assert!(path.ends_with(\"/etc/resolv.conf\"));\n    ///\n    /// assert!(!path.ends_with(\"/resolv.conf\"));\n    /// assert!(!path.ends_with(\"conf\")); // use .extension() instead\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool {\n        self._ends_with(child.as_ref())\n    }\n\n    fn _ends_with(&self, child: &Path) -> bool {\n        iter_after(self.components().rev(), child.components().rev()).is_some()\n    }\n\n    /// Extracts the stem (non-extension) portion of [`self.file_name`].\n    ///\n    /// [`self.file_name`]: Path::file_name\n    ///\n    /// The stem is:\n    ///\n    /// * [`None`], if there is no file name;\n    /// * The entire file name if there is no embedded `.`;\n    /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n    /// * Otherwise, the portion of the file name before the final `.`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// assert_eq!(\"foo\", Path::new(\"foo.rs\").file_stem().unwrap());\n    /// assert_eq!(\"foo.tar\", Path::new(\"foo.tar.gz\").file_stem().unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn file_stem(&self) -> Option<&OsStr> {\n        self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.or(after))\n    }\n\n    /// Extracts the extension of [`self.file_name`], if possible.\n    ///\n    /// The extension is:\n    ///\n    /// * [`None`], if there is no file name;\n    /// * [`None`], if there is no embedded `.`;\n    /// * [`None`], if the file name begins with `.` and has no other `.`s within;\n    /// * Otherwise, the portion of the file name after the final `.`\n    ///\n    /// [`self.file_name`]: Path::file_name\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// assert_eq!(\"rs\", Path::new(\"foo.rs\").extension().unwrap());\n    /// assert_eq!(\"gz\", Path::new(\"foo.tar.gz\").extension().unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn extension(&self) -> Option<&OsStr> {\n        self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.and(after))\n    }\n\n    /// Creates an owned [`PathBuf`] with `path` adjoined to `self`.\n    ///\n    /// See [`PathBuf::push`] for more details on what it means to adjoin a path.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// assert_eq!(Path::new(\"/etc\").join(\"passwd\"), PathBuf::from(\"/etc/passwd\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[must_use]\n    pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf {\n        self._join(path.as_ref())\n    }\n\n    fn _join(&self, path: &Path) -> PathBuf {\n        let mut buf = self.to_path_buf();\n        buf.push(path);\n        buf\n    }\n\n    /// Creates an owned [`PathBuf`] like `self` but with the given file name.\n    ///\n    /// See [`PathBuf::set_file_name`] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let path = Path::new(\"/tmp/foo.txt\");\n    /// assert_eq!(path.with_file_name(\"bar.txt\"), PathBuf::from(\"/tmp/bar.txt\"));\n    ///\n    /// let path = Path::new(\"/tmp\");\n    /// assert_eq!(path.with_file_name(\"var\"), PathBuf::from(\"/var\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf {\n        self._with_file_name(file_name.as_ref())\n    }\n\n    fn _with_file_name(&self, file_name: &OsStr) -> PathBuf {\n        let mut buf = self.to_path_buf();\n        buf.set_file_name(file_name);\n        buf\n    }\n\n    /// Creates an owned [`PathBuf`] like `self` but with the given extension.\n    ///\n    /// See [`PathBuf::set_extension`] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let path = Path::new(\"foo.rs\");\n    /// assert_eq!(path.with_extension(\"txt\"), PathBuf::from(\"foo.txt\"));\n    ///\n    /// let path = Path::new(\"foo.tar.gz\");\n    /// assert_eq!(path.with_extension(\"\"), PathBuf::from(\"foo.tar\"));\n    /// assert_eq!(path.with_extension(\"xz\"), PathBuf::from(\"foo.tar.xz\"));\n    /// assert_eq!(path.with_extension(\"\").with_extension(\"txt\"), PathBuf::from(\"foo.txt\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n        self._with_extension(extension.as_ref())\n    }\n\n    fn _with_extension(&self, extension: &OsStr) -> PathBuf {\n        let mut buf = self.to_path_buf();\n        buf.set_extension(extension);\n        buf\n    }\n\n    /// Produces an iterator over the [`Component`]s of the path.\n    ///\n    /// When parsing the path, there is a small amount of normalization:\n    ///\n    /// * Repeated separators are ignored, so `a/b` and `a//b` both have\n    ///   `a` and `b` as components.\n    ///\n    /// * Occurrences of `.` are normalized away, except if they are at the\n    ///   beginning of the path. For example, `a/./b`, `a/b/`, `a/b/.` and\n    ///   `a/b` all have `a` and `b` as components, but `./a/b` starts with\n    ///   an additional [`CurDir`] component.\n    ///\n    /// * A trailing slash is normalized away, `/a/b` and `/a/b/` are equivalent.\n    ///\n    /// Note that no other normalization takes place; in particular, `a/c`\n    /// and `a/b/../c` are distinct, to account for the possibility that `b`\n    /// is a symbolic link (so its parent isn't `a`).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, Component};\n    /// use std::ffi::OsStr;\n    ///\n    /// let mut components = Path::new(\"/tmp/foo.txt\").components();\n    ///\n    /// assert_eq!(components.next(), Some(Component::RootDir));\n    /// assert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"tmp\"))));\n    /// assert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"foo.txt\"))));\n    /// assert_eq!(components.next(), None)\n    /// ```\n    ///\n    /// [`CurDir`]: Component::CurDir\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn components(&self) -> Components<'_> {\n        let prefix = parse_prefix(self.as_os_str());\n        Components {\n            path: self.as_u8_slice(),\n            prefix,\n            has_physical_root: has_physical_root(self.as_u8_slice(), prefix)\n                || has_redox_scheme(self.as_u8_slice()),\n            front: State::Prefix,\n            back: State::Body,\n        }\n    }\n\n    /// Produces an iterator over the path's components viewed as [`OsStr`]\n    /// slices.\n    ///\n    /// For more information about the particulars of how the path is separated\n    /// into components, see [`components`].\n    ///\n    /// [`components`]: Path::components\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{self, Path};\n    /// use std::ffi::OsStr;\n    ///\n    /// let mut it = Path::new(\"/tmp/foo.txt\").iter();\n    /// assert_eq!(it.next(), Some(OsStr::new(&path::MAIN_SEPARATOR.to_string())));\n    /// assert_eq!(it.next(), Some(OsStr::new(\"tmp\")));\n    /// assert_eq!(it.next(), Some(OsStr::new(\"foo.txt\")));\n    /// assert_eq!(it.next(), None)\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn iter(&self) -> Iter<'_> {\n        Iter { inner: self.components() }\n    }\n\n    /// Returns an object that implements [`Display`] for safely printing paths\n    /// that may contain non-Unicode data. This may perform lossy conversion,\n    /// depending on the platform.  If you would like an implementation which\n    /// escapes the path please use [`Debug`] instead.\n    ///\n    /// [`Display`]: fmt::Display\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/tmp/foo.rs\");\n    ///\n    /// println!(\"{}\", path.display());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn display(&self) -> Display<'_> {\n        Display { path: self }\n    }\n\n    /// Queries the file system to get information about a file, directory, etc.\n    ///\n    /// This function will traverse symbolic links to query information about the\n    /// destination file.\n    ///\n    /// This is an alias to [`fs::metadata`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/Minas/tirith\");\n    /// let metadata = path.metadata().expect(\"metadata call failed\");\n    /// println!(\"{:?}\", metadata.file_type());\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    #[inline]\n    pub fn metadata(&self) -> io::Result<fs::Metadata> {\n        fs::metadata(self)\n    }\n\n    /// Queries the metadata about a file without following symlinks.\n    ///\n    /// This is an alias to [`fs::symlink_metadata`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/Minas/tirith\");\n    /// let metadata = path.symlink_metadata().expect(\"symlink_metadata call failed\");\n    /// println!(\"{:?}\", metadata.file_type());\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    #[inline]\n    pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> {\n        fs::symlink_metadata(self)\n    }\n\n    /// Returns the canonical, absolute form of the path with all intermediate\n    /// components normalized and symbolic links resolved.\n    ///\n    /// This is an alias to [`fs::canonicalize`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let path = Path::new(\"/foo/test/../test/bar.rs\");\n    /// assert_eq!(path.canonicalize().unwrap(), PathBuf::from(\"/foo/test/bar.rs\"));\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    #[inline]\n    pub fn canonicalize(&self) -> io::Result<PathBuf> {\n        fs::canonicalize(self)\n    }\n\n    /// Reads a symbolic link, returning the file that the link points to.\n    ///\n    /// This is an alias to [`fs::read_link`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/laputa/sky_castle.rs\");\n    /// let path_link = path.read_link().expect(\"read_link call failed\");\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    #[inline]\n    pub fn read_link(&self) -> io::Result<PathBuf> {\n        fs::read_link(self)\n    }\n\n    /// Returns an iterator over the entries within a directory.\n    ///\n    /// The iterator will yield instances of [`io::Result`]`<`[`fs::DirEntry`]`>`. New\n    /// errors may be encountered after an iterator is initially constructed.\n    ///\n    /// This is an alias to [`fs::read_dir`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/laputa\");\n    /// for entry in path.read_dir().expect(\"read_dir call failed\") {\n    ///     if let Ok(entry) = entry {\n    ///         println!(\"{:?}\", entry.path());\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    #[inline]\n    pub fn read_dir(&self) -> io::Result<fs::ReadDir> {\n        fs::read_dir(self)\n    }\n\n    /// Returns `true` if the path points at an existing entity.\n    ///\n    /// This function will traverse symbolic links to query information about the\n    /// destination file.\n    ///\n    /// If you cannot access the metadata of the file, e.g. because of a\n    /// permission error or broken symbolic links, this will return `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    /// assert!(!Path::new(\"does_not_exist.txt\").exists());\n    /// ```\n    ///\n    /// # See Also\n    ///\n    /// This is a convenience function that coerces errors to false. If you want to\n    /// check errors, call [`fs::metadata`].\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    #[inline]\n    pub fn exists(&self) -> bool {\n        fs::metadata(self).is_ok()\n    }\n\n    /// Returns `Ok(true)` if the path points at an existing entity.\n    ///\n    /// This function will traverse symbolic links to query information about the\n    /// destination file. In case of broken symbolic links this will return `Ok(false)`.\n    ///\n    /// As opposed to the `exists()` method, this one doesn't silently ignore errors\n    /// unrelated to the path not existing. (E.g. it will return `Err(_)` in case of permission\n    /// denied on some of the parent directories.)\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// #![feature(path_try_exists)]\n    ///\n    /// use std::path::Path;\n    /// assert!(!Path::new(\"does_not_exist.txt\").try_exists().expect(\"Can't check existence of file does_not_exist.txt\"));\n    /// assert!(Path::new(\"/root/secret_file.txt\").try_exists().is_err());\n    /// ```\n    // FIXME: stabilization should modify documentation of `exists()` to recommend this method\n    // instead.\n    #[unstable(feature = \"path_try_exists\", issue = \"83186\")]\n    #[inline]\n    pub fn try_exists(&self) -> io::Result<bool> {\n        fs::try_exists(self)\n    }\n\n    /// Returns `true` if the path exists on disk and is pointing at a regular file.\n    ///\n    /// This function will traverse symbolic links to query information about the\n    /// destination file.\n    ///\n    /// If you cannot access the metadata of the file, e.g. because of a\n    /// permission error or broken symbolic links, this will return `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    /// assert_eq!(Path::new(\"./is_a_directory/\").is_file(), false);\n    /// assert_eq!(Path::new(\"a_file.txt\").is_file(), true);\n    /// ```\n    ///\n    /// # See Also\n    ///\n    /// This is a convenience function that coerces errors to false. If you want to\n    /// check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n    /// [`fs::Metadata::is_file`] if it was [`Ok`].\n    ///\n    /// When the goal is simply to read from (or write to) the source, the most\n    /// reliable way to test the source can be read (or written to) is to open\n    /// it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n    /// a Unix-like system for example. See [`fs::File::open`] or\n    /// [`fs::OpenOptions::open`] for more information.\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn is_file(&self) -> bool {\n        fs::metadata(self).map(|m| m.is_file()).unwrap_or(false)\n    }\n\n    /// Returns `true` if the path exists on disk and is pointing at a directory.\n    ///\n    /// This function will traverse symbolic links to query information about the\n    /// destination file.\n    ///\n    /// If you cannot access the metadata of the file, e.g. because of a\n    /// permission error or broken symbolic links, this will return `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    /// assert_eq!(Path::new(\"./is_a_directory/\").is_dir(), true);\n    /// assert_eq!(Path::new(\"a_file.txt\").is_dir(), false);\n    /// ```\n    ///\n    /// # See Also\n    ///\n    /// This is a convenience function that coerces errors to false. If you want to\n    /// check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n    /// [`fs::Metadata::is_dir`] if it was [`Ok`].\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn is_dir(&self) -> bool {\n        fs::metadata(self).map(|m| m.is_dir()).unwrap_or(false)\n    }\n\n    /// Returns true if the path exists on disk and is pointing at a symbolic link.\n    ///\n    /// This function will not traverse symbolic links.\n    /// In case of a broken symbolic link this will also return true.\n    ///\n    /// If you cannot access the directory containing the file, e.g., because of a\n    /// permission error, this will return false.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(unix, doc = \"```no_run\")]\n    #[cfg_attr(not(unix), doc = \"```ignore\")]\n    /// #![feature(is_symlink)]\n    /// use std::path::Path;\n    /// use std::os::unix::fs::symlink;\n    ///\n    /// let link_path = Path::new(\"link\");\n    /// symlink(\"/origin_does_not_exists/\", link_path).unwrap();\n    /// assert_eq!(link_path.is_symlink(), true);\n    /// assert_eq!(link_path.exists(), false);\n    /// ```\n    #[unstable(feature = \"is_symlink\", issue = \"85748\")]\n    pub fn is_symlink(&self) -> bool {\n        fs::symlink_metadata(self).map(|m| m.is_symlink()).unwrap_or(false)\n    }\n\n    /// Converts a [`Box<Path>`](Box) into a [`PathBuf`] without copying or\n    /// allocating.\n    #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n    pub fn into_path_buf(self: Box<Path>) -> PathBuf {\n        let rw = Box::into_raw(self) as *mut OsStr;\n        let inner = unsafe { Box::from_raw(rw) };\n        PathBuf { inner: OsString::from(inner) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for Path {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n        &self.inner\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Path {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.inner, formatter)\n    }\n}\n\n/// Helper struct for safely printing paths with [`format!`] and `{}`.\n///\n/// A [`Path`] might contain non-Unicode data. This `struct` implements the\n/// [`Display`] trait in a way that mitigates that. It is created by the\n/// [`display`](Path::display) method on [`Path`]. This may perform lossy\n/// conversion, depending on the platform. If you would like an implementation\n/// which escapes the path please use [`Debug`] instead.\n///\n/// # Examples\n///\n/// ```\n/// use std::path::Path;\n///\n/// let path = Path::new(\"/tmp/foo.rs\");\n///\n/// println!(\"{}\", path.display());\n/// ```\n///\n/// [`Display`]: fmt::Display\n/// [`format!`]: crate::format\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Display<'a> {\n    path: &'a Path,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Display<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.path, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Display<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.path.inner.display(f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::PartialEq for Path {\n    #[inline]\n    fn eq(&self, other: &Path) -> bool {\n        self.components().eq(other.components())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for Path {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n        for component in self.components() {\n            component.hash(h);\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Eq for Path {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::PartialOrd for Path {\n    #[inline]\n    fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> {\n        self.components().partial_cmp(other.components())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Ord for Path {\n    #[inline]\n    fn cmp(&self, other: &Path) -> cmp::Ordering {\n        self.components().cmp(other.components())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for Path {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for OsStr {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        Path::new(self)\n    }\n}\n\n#[stable(feature = \"cow_os_str_as_ref_path\", since = \"1.8.0\")]\nimpl AsRef<Path> for Cow<'_, OsStr> {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        Path::new(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for OsString {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        Path::new(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for str {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        Path::new(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for String {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        Path::new(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for PathBuf {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n        self\n    }\n}\n\n#[stable(feature = \"path_into_iter\", since = \"1.6.0\")]\nimpl<'a> IntoIterator for &'a PathBuf {\n    type Item = &'a OsStr;\n    type IntoIter = Iter<'a>;\n    #[inline]\n    fn into_iter(self) -> Iter<'a> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"path_into_iter\", since = \"1.6.0\")]\nimpl<'a> IntoIterator for &'a Path {\n    type Item = &'a OsStr;\n    type IntoIter = Iter<'a>;\n    #[inline]\n    fn into_iter(self) -> Iter<'a> {\n        self.iter()\n    }\n}\n\nmacro_rules! impl_cmp {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool {\n                <Path as PartialEq>::eq(self, other)\n            }\n        }\n\n        #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n                <Path as PartialEq>::eq(self, other)\n            }\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$rhs) -> Option<cmp::Ordering> {\n                <Path as PartialOrd>::partial_cmp(self, other)\n            }\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<cmp::Ordering> {\n                <Path as PartialOrd>::partial_cmp(self, other)\n            }\n        }\n    };\n}\n\nimpl_cmp!(PathBuf, Path);\nimpl_cmp!(PathBuf, &'a Path);\nimpl_cmp!(Cow<'a, Path>, Path);\nimpl_cmp!(Cow<'a, Path>, &'b Path);\nimpl_cmp!(Cow<'a, Path>, PathBuf);\n\nmacro_rules! impl_cmp_os_str {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool {\n                <Path as PartialEq>::eq(self, other.as_ref())\n            }\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n                <Path as PartialEq>::eq(self.as_ref(), other)\n            }\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$rhs) -> Option<cmp::Ordering> {\n                <Path as PartialOrd>::partial_cmp(self, other.as_ref())\n            }\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<cmp::Ordering> {\n                <Path as PartialOrd>::partial_cmp(self.as_ref(), other)\n            }\n        }\n    };\n}\n\nimpl_cmp_os_str!(PathBuf, OsStr);\nimpl_cmp_os_str!(PathBuf, &'a OsStr);\nimpl_cmp_os_str!(PathBuf, Cow<'a, OsStr>);\nimpl_cmp_os_str!(PathBuf, OsString);\nimpl_cmp_os_str!(Path, OsStr);\nimpl_cmp_os_str!(Path, &'a OsStr);\nimpl_cmp_os_str!(Path, Cow<'a, OsStr>);\nimpl_cmp_os_str!(Path, OsString);\nimpl_cmp_os_str!(&'a Path, OsStr);\nimpl_cmp_os_str!(&'a Path, Cow<'b, OsStr>);\nimpl_cmp_os_str!(&'a Path, OsString);\nimpl_cmp_os_str!(Cow<'a, Path>, OsStr);\nimpl_cmp_os_str!(Cow<'a, Path>, &'b OsStr);\nimpl_cmp_os_str!(Cow<'a, Path>, OsString);\n\n#[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\nimpl fmt::Display for StripPrefixError {\n    #[allow(deprecated, deprecated_in_future)]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.description().fmt(f)\n    }\n}\n\n#[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\nimpl Error for StripPrefixError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"prefix not found\"\n    }\n}\n"],["2544","//! Operations on ASCII strings and characters.\n//!\n//! Most string operations in Rust act on UTF-8 strings. However, at times it\n//! makes more sense to only consider the ASCII character set for a specific\n//! operation.\n//!\n//! The [`AsciiExt`] trait provides methods that allow for character\n//! operations that only act on the ASCII subset and leave non-ASCII characters\n//! alone.\n//!\n//! The [`escape_default`] function provides an iterator over the bytes of an\n//! escaped version of the character given.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::ascii::{escape_default, EscapeDefault};\n\n/// Extension methods for ASCII-subset only operations.\n///\n/// Be aware that operations on seemingly non-ASCII characters can sometimes\n/// have unexpected results. Consider this example:\n///\n/// ```\n/// use std::ascii::AsciiExt;\n///\n/// assert_eq!(AsciiExt::to_ascii_uppercase(\"café\"), \"CAFÉ\");\n/// assert_eq!(AsciiExt::to_ascii_uppercase(\"café\"), \"CAFé\");\n/// ```\n///\n/// In the first example, the lowercased string is represented `\"cafe\\u{301}\"`\n/// (the last character is an acute accent [combining character]). Unlike the\n/// other characters in the string, the combining character will not get mapped\n/// to an uppercase variant, resulting in `\"CAFE\\u{301}\"`. In the second\n/// example, the lowercased string is represented `\"caf\\u{e9}\"` (the last\n/// character is a single Unicode character representing an 'e' with an acute\n/// accent). Since the last character is defined outside the scope of ASCII,\n/// it will not get mapped to an uppercase variant, resulting in `\"CAF\\u{e9}\"`.\n///\n/// [combining character]: https://en.wikipedia.org/wiki/Combining_character\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\npub trait AsciiExt {\n    /// Container type for copied ASCII characters.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Owned;\n\n    /// Checks if the value is within the ASCII range.\n    ///\n    /// # Note\n    ///\n    /// This method is deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn is_ascii(&self) -> bool;\n\n    /// Makes a copy of the value in its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// To uppercase ASCII characters in addition to non-ASCII characters, use\n    /// [`str::to_uppercase`].\n    ///\n    /// # Note\n    ///\n    /// This method is deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    ///\n    /// [`make_ascii_uppercase`]: AsciiExt::make_ascii_uppercase\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow(deprecated)]\n    fn to_ascii_uppercase(&self) -> Self::Owned;\n\n    /// Makes a copy of the value in its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// To lowercase ASCII characters in addition to non-ASCII characters, use\n    /// [`str::to_lowercase`].\n    ///\n    /// # Note\n    ///\n    /// This method is deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    ///\n    /// [`make_ascii_lowercase`]: AsciiExt::make_ascii_lowercase\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow(deprecated)]\n    fn to_ascii_lowercase(&self) -> Self::Owned;\n\n    /// Checks that two values are an ASCII case-insensitive match.\n    ///\n    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n    /// but without allocating and copying temporaries.\n    ///\n    /// # Note\n    ///\n    /// This method is deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n\n    /// Converts this type to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`to_ascii_uppercase`].\n    ///\n    /// # Note\n    ///\n    /// This method is deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    ///\n    /// [`to_ascii_uppercase`]: AsciiExt::to_ascii_uppercase\n    #[stable(feature = \"ascii\", since = \"1.9.0\")]\n    fn make_ascii_uppercase(&mut self);\n\n    /// Converts this type to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`to_ascii_lowercase`].\n    ///\n    /// # Note\n    ///\n    /// This method is deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    ///\n    /// [`to_ascii_lowercase`]: AsciiExt::to_ascii_lowercase\n    #[stable(feature = \"ascii\", since = \"1.9.0\")]\n    fn make_ascii_lowercase(&mut self);\n}\n\nmacro_rules! delegating_ascii_methods {\n    () => {\n        #[inline]\n        fn is_ascii(&self) -> bool {\n            self.is_ascii()\n        }\n\n        #[inline]\n        fn to_ascii_uppercase(&self) -> Self::Owned {\n            self.to_ascii_uppercase()\n        }\n\n        #[inline]\n        fn to_ascii_lowercase(&self) -> Self::Owned {\n            self.to_ascii_lowercase()\n        }\n\n        #[inline]\n        fn eq_ignore_ascii_case(&self, o: &Self) -> bool {\n            self.eq_ignore_ascii_case(o)\n        }\n\n        #[inline]\n        fn make_ascii_uppercase(&mut self) {\n            self.make_ascii_uppercase();\n        }\n\n        #[inline]\n        fn make_ascii_lowercase(&mut self) {\n            self.make_ascii_lowercase();\n        }\n    };\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl AsciiExt for u8 {\n    type Owned = u8;\n\n    delegating_ascii_methods!();\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl AsciiExt for char {\n    type Owned = char;\n\n    delegating_ascii_methods!();\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl AsciiExt for [u8] {\n    type Owned = Vec<u8>;\n\n    delegating_ascii_methods!();\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl AsciiExt for str {\n    type Owned = String;\n\n    delegating_ascii_methods!();\n}\n"],["2545","use crate::sys::rwlock as imp;\n\n/// An OS-based reader-writer lock, meant for use in static variables.\n///\n/// This rwlock does not implement poisoning.\n///\n/// This rwlock has a const constructor ([`StaticRWLock::new`]), does not\n/// implement `Drop` to cleanup resources.\npub struct StaticRWLock(imp::RWLock);\n\nimpl StaticRWLock {\n    /// Creates a new rwlock for use.\n    pub const fn new() -> Self {\n        Self(imp::RWLock::new())\n    }\n\n    /// Acquires shared access to the underlying lock, blocking the current\n    /// thread to do so.\n    ///\n    /// The lock is automatically unlocked when the returned guard is dropped.\n    #[inline]\n    pub fn read(&'static self) -> StaticRWLockReadGuard {\n        unsafe { self.0.read() };\n        StaticRWLockReadGuard(&self.0)\n    }\n\n    /// Acquires write access to the underlying lock, blocking the current thread\n    /// to do so.\n    ///\n    /// The lock is automatically unlocked when the returned guard is dropped.\n    #[inline]\n    pub fn write(&'static self) -> StaticRWLockWriteGuard {\n        unsafe { self.0.write() };\n        StaticRWLockWriteGuard(&self.0)\n    }\n}\n\n#[must_use]\npub struct StaticRWLockReadGuard(&'static imp::RWLock);\n\nimpl Drop for StaticRWLockReadGuard {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe {\n            self.0.read_unlock();\n        }\n    }\n}\n\n#[must_use]\npub struct StaticRWLockWriteGuard(&'static imp::RWLock);\n\nimpl Drop for StaticRWLockWriteGuard {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe {\n            self.0.write_unlock();\n        }\n    }\n}\n\n/// An OS-based reader-writer lock.\n///\n/// This rwlock does *not* have a const constructor, cleans up its resources in\n/// its `Drop` implementation and may safely be moved (when not borrowed).\n///\n/// This rwlock does not implement poisoning.\n///\n/// This is either a wrapper around `Box<imp::RWLock>` or `imp::RWLock`,\n/// depending on the platform. It is boxed on platforms where `imp::RWLock` may\n/// not be moved.\npub struct MovableRWLock(imp::MovableRWLock);\n\nimpl MovableRWLock {\n    /// Creates a new reader-writer lock for use.\n    pub fn new() -> Self {\n        Self(imp::MovableRWLock::from(imp::RWLock::new()))\n    }\n\n    /// Acquires shared access to the underlying lock, blocking the current\n    /// thread to do so.\n    #[inline]\n    pub fn read(&self) {\n        unsafe { self.0.read() }\n    }\n\n    /// Attempts to acquire shared access to this lock, returning whether it\n    /// succeeded or not.\n    ///\n    /// This function does not block the current thread.\n    #[inline]\n    pub fn try_read(&self) -> bool {\n        unsafe { self.0.try_read() }\n    }\n\n    /// Acquires write access to the underlying lock, blocking the current thread\n    /// to do so.\n    #[inline]\n    pub fn write(&self) {\n        unsafe { self.0.write() }\n    }\n\n    /// Attempts to acquire exclusive access to this lock, returning whether it\n    /// succeeded or not.\n    ///\n    /// This function does not block the current thread.\n    #[inline]\n    pub fn try_write(&self) -> bool {\n        unsafe { self.0.try_write() }\n    }\n\n    /// Unlocks previously acquired shared access to this lock.\n    ///\n    /// Behavior is undefined if the current thread does not have shared access.\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        self.0.read_unlock()\n    }\n\n    /// Unlocks previously acquired exclusive access to this lock.\n    ///\n    /// Behavior is undefined if the current thread does not currently have\n    /// exclusive access.\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        self.0.write_unlock()\n    }\n}\n\nimpl Drop for MovableRWLock {\n    fn drop(&mut self) {\n        unsafe { self.0.destroy() };\n    }\n}\n"],["2546","pub const DEFAULT_BUF_SIZE: usize = 8 * 1024;\n\n#[cfg(test)]\n#[allow(dead_code)] // not used on emscripten\npub mod test {\n    use crate::env;\n    use crate::fs;\n    use crate::path::{Path, PathBuf};\n    use rand::RngCore;\n\n    pub struct TempDir(PathBuf);\n\n    impl TempDir {\n        pub fn join(&self, path: &str) -> PathBuf {\n            let TempDir(ref p) = *self;\n            p.join(path)\n        }\n\n        pub fn path(&self) -> &Path {\n            let TempDir(ref p) = *self;\n            p\n        }\n    }\n\n    impl Drop for TempDir {\n        fn drop(&mut self) {\n            // Gee, seeing how we're testing the fs module I sure hope that we\n            // at least implement this correctly!\n            let TempDir(ref p) = *self;\n            fs::remove_dir_all(p).unwrap();\n        }\n    }\n\n    pub fn tmpdir() -> TempDir {\n        let p = env::temp_dir();\n        let mut r = rand::thread_rng();\n        let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n        fs::create_dir(&ret).unwrap();\n        TempDir(ret)\n    }\n}\n"],["2547","//! The underlying OsString/OsStr implementation on Unix and many other\n//! systems: just a `Vec<u8>`/`[u8]`.\n\nuse crate::borrow::Cow;\n\nuse crate::fmt;\nuse crate::mem;\nuse crate::rc::Rc;\nuse crate::str;\nuse crate::sync::Arc;\nuse crate::sys_common::bytestring::debug_fmt_bytestring;\nuse crate::sys_common::{AsInner, IntoInner};\n\nuse core::str::lossy::Utf8Lossy;\n\n#[derive(Hash)]\n#[repr(transparent)]\npub struct Buf {\n    pub inner: Vec<u8>,\n}\n\n#[repr(transparent)]\npub struct Slice {\n    pub inner: [u8],\n}\n\nimpl fmt::Debug for Slice {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        debug_fmt_bytestring(&self.inner, formatter)\n    }\n}\n\nimpl fmt::Display for Slice {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n    }\n}\n\nimpl fmt::Debug for Buf {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.as_slice(), formatter)\n    }\n}\n\nimpl fmt::Display for Buf {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.as_slice(), formatter)\n    }\n}\n\nimpl Clone for Buf {\n    #[inline]\n    fn clone(&self) -> Self {\n        Buf { inner: self.inner.clone() }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, source: &Self) {\n        self.inner.clone_from(&source.inner)\n    }\n}\n\nimpl IntoInner<Vec<u8>> for Buf {\n    fn into_inner(self) -> Vec<u8> {\n        self.inner\n    }\n}\n\nimpl AsInner<[u8]> for Buf {\n    fn as_inner(&self) -> &[u8] {\n        &self.inner\n    }\n}\n\nimpl Buf {\n    pub fn from_string(s: String) -> Buf {\n        Buf { inner: s.into_bytes() }\n    }\n\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Buf {\n        Buf { inner: Vec::with_capacity(capacity) }\n    }\n\n    #[inline]\n    pub fn clear(&mut self) {\n        self.inner.clear()\n    }\n\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        self.inner.capacity()\n    }\n\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n        self.inner.reserve(additional)\n    }\n\n    #[inline]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.inner.reserve_exact(additional)\n    }\n\n    #[inline]\n    pub fn shrink_to_fit(&mut self) {\n        self.inner.shrink_to_fit()\n    }\n\n    #[inline]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.inner.shrink_to(min_capacity)\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &Slice {\n        // SAFETY: Slice just wraps [u8],\n        // and &*self.inner is &[u8], therefore\n        // transmuting &[u8] to &Slice is safe.\n        unsafe { mem::transmute(&*self.inner) }\n    }\n\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut Slice {\n        // SAFETY: Slice just wraps [u8],\n        // and &mut *self.inner is &mut [u8], therefore\n        // transmuting &mut [u8] to &mut Slice is safe.\n        unsafe { mem::transmute(&mut *self.inner) }\n    }\n\n    pub fn into_string(self) -> Result<String, Buf> {\n        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() })\n    }\n\n    pub fn push_slice(&mut self, s: &Slice) {\n        self.inner.extend_from_slice(&s.inner)\n    }\n\n    #[inline]\n    pub fn into_box(self) -> Box<Slice> {\n        unsafe { mem::transmute(self.inner.into_boxed_slice()) }\n    }\n\n    #[inline]\n    pub fn from_box(boxed: Box<Slice>) -> Buf {\n        let inner: Box<[u8]> = unsafe { mem::transmute(boxed) };\n        Buf { inner: inner.into_vec() }\n    }\n\n    #[inline]\n    pub fn into_arc(&self) -> Arc<Slice> {\n        self.as_slice().into_arc()\n    }\n\n    #[inline]\n    pub fn into_rc(&self) -> Rc<Slice> {\n        self.as_slice().into_rc()\n    }\n}\n\nimpl Slice {\n    #[inline]\n    fn from_u8_slice(s: &[u8]) -> &Slice {\n        unsafe { mem::transmute(s) }\n    }\n\n    #[inline]\n    pub fn from_str(s: &str) -> &Slice {\n        Slice::from_u8_slice(s.as_bytes())\n    }\n\n    pub fn to_str(&self) -> Option<&str> {\n        str::from_utf8(&self.inner).ok()\n    }\n\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n        String::from_utf8_lossy(&self.inner)\n    }\n\n    pub fn to_owned(&self) -> Buf {\n        Buf { inner: self.inner.to_vec() }\n    }\n\n    pub fn clone_into(&self, buf: &mut Buf) {\n        self.inner.clone_into(&mut buf.inner)\n    }\n\n    #[inline]\n    pub fn into_box(&self) -> Box<Slice> {\n        let boxed: Box<[u8]> = self.inner.into();\n        unsafe { mem::transmute(boxed) }\n    }\n\n    pub fn empty_box() -> Box<Slice> {\n        let boxed: Box<[u8]> = Default::default();\n        unsafe { mem::transmute(boxed) }\n    }\n\n    #[inline]\n    pub fn into_arc(&self) -> Arc<Slice> {\n        let arc: Arc<[u8]> = Arc::from(&self.inner);\n        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Slice) }\n    }\n\n    #[inline]\n    pub fn into_rc(&self) -> Rc<Slice> {\n        let rc: Rc<[u8]> = Rc::from(&self.inner);\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Slice) }\n    }\n\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        self.inner.make_ascii_lowercase()\n    }\n\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        self.inner.make_ascii_uppercase()\n    }\n\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> Buf {\n        Buf { inner: self.inner.to_ascii_lowercase() }\n    }\n\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> Buf {\n        Buf { inner: self.inner.to_ascii_uppercase() }\n    }\n\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n        self.inner.is_ascii()\n    }\n\n    #[inline]\n    pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool {\n        self.inner.eq_ignore_ascii_case(&other.inner)\n    }\n}\n"],["2548","#![allow(dead_code)]\n#![unstable(feature = \"process_internals\", issue = \"none\")]\n\nuse crate::collections::BTreeMap;\nuse crate::env;\nuse crate::ffi::{OsStr, OsString};\nuse crate::sys::process::EnvKey;\n\n// Stores a set of changes to an environment\n#[derive(Clone, Debug)]\npub struct CommandEnv {\n    clear: bool,\n    saw_path: bool,\n    vars: BTreeMap<EnvKey, Option<OsString>>,\n}\n\nimpl Default for CommandEnv {\n    fn default() -> Self {\n        CommandEnv { clear: false, saw_path: false, vars: Default::default() }\n    }\n}\n\nimpl CommandEnv {\n    // Capture the current environment with these changes applied\n    pub fn capture(&self) -> BTreeMap<EnvKey, OsString> {\n        let mut result = BTreeMap::<EnvKey, OsString>::new();\n        if !self.clear {\n            for (k, v) in env::vars_os() {\n                result.insert(k.into(), v);\n            }\n        }\n        for (k, maybe_v) in &self.vars {\n            if let &Some(ref v) = maybe_v {\n                result.insert(k.clone(), v.clone());\n            } else {\n                result.remove(k);\n            }\n        }\n        result\n    }\n\n    // Apply these changes directly to the current environment\n    pub fn apply(&self) {\n        if self.clear {\n            for (k, _) in env::vars_os() {\n                env::remove_var(k);\n            }\n        }\n        for (key, maybe_val) in self.vars.iter() {\n            if let Some(ref val) = maybe_val {\n                env::set_var(key, val);\n            } else {\n                env::remove_var(key);\n            }\n        }\n    }\n\n    pub fn is_unchanged(&self) -> bool {\n        !self.clear && self.vars.is_empty()\n    }\n\n    pub fn capture_if_changed(&self) -> Option<BTreeMap<EnvKey, OsString>> {\n        if self.is_unchanged() { None } else { Some(self.capture()) }\n    }\n\n    // The following functions build up changes\n    pub fn set(&mut self, key: &OsStr, value: &OsStr) {\n        self.maybe_saw_path(&key);\n        self.vars.insert(key.to_owned().into(), Some(value.to_owned()));\n    }\n\n    pub fn remove(&mut self, key: &OsStr) {\n        self.maybe_saw_path(&key);\n        if self.clear {\n            self.vars.remove(key);\n        } else {\n            self.vars.insert(key.to_owned().into(), None);\n        }\n    }\n\n    pub fn clear(&mut self) {\n        self.clear = true;\n        self.vars.clear();\n    }\n\n    pub fn have_changed_path(&self) -> bool {\n        self.saw_path || self.clear\n    }\n\n    fn maybe_saw_path(&mut self, key: &OsStr) {\n        if !self.saw_path && key == \"PATH\" {\n            self.saw_path = true;\n        }\n    }\n\n    pub fn iter(&self) -> CommandEnvs<'_> {\n        let iter = self.vars.iter();\n        CommandEnvs { iter }\n    }\n}\n\n/// An iterator over the command environment variables.\n///\n/// This struct is created by\n/// [`Command::get_envs`][crate::process::Command::get_envs]. See its\n/// documentation for more.\n#[unstable(feature = \"command_access\", issue = \"44434\")]\n#[derive(Debug)]\npub struct CommandEnvs<'a> {\n    iter: crate::collections::btree_map::Iter<'a, EnvKey, Option<OsString>>,\n}\n\n#[unstable(feature = \"command_access\", issue = \"44434\")]\nimpl<'a> Iterator for CommandEnvs<'a> {\n    type Item = (&'a OsStr, Option<&'a OsStr>);\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|(key, value)| (key.as_ref(), value.as_deref()))\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[unstable(feature = \"command_access\", issue = \"44434\")]\nimpl<'a> ExactSizeIterator for CommandEnvs<'a> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n"],["2549","use crate::sys::condvar as imp;\nuse crate::sys::mutex as mutex_imp;\nuse crate::sys_common::mutex::MovableMutex;\nuse crate::time::Duration;\n\nmod check;\n\ntype CondvarCheck = <mutex_imp::MovableMutex as check::CondvarCheck>::Check;\n\n/// An OS-based condition variable.\npub struct Condvar {\n    inner: imp::MovableCondvar,\n    check: CondvarCheck,\n}\n\nimpl Condvar {\n    /// Creates a new condition variable for use.\n    pub fn new() -> Self {\n        let mut c = imp::MovableCondvar::from(imp::Condvar::new());\n        unsafe { c.init() };\n        Self { inner: c, check: CondvarCheck::new() }\n    }\n\n    /// Signals one waiter on this condition variable to wake up.\n    #[inline]\n    pub fn notify_one(&self) {\n        unsafe { self.inner.notify_one() };\n    }\n\n    /// Awakens all current waiters on this condition variable.\n    #[inline]\n    pub fn notify_all(&self) {\n        unsafe { self.inner.notify_all() };\n    }\n\n    /// Waits for a signal on the specified mutex.\n    ///\n    /// Behavior is undefined if the mutex is not locked by the current thread.\n    ///\n    /// May panic if used with more than one mutex.\n    #[inline]\n    pub unsafe fn wait(&self, mutex: &MovableMutex) {\n        self.check.verify(mutex);\n        self.inner.wait(mutex.raw())\n    }\n\n    /// Waits for a signal on the specified mutex with a timeout duration\n    /// specified by `dur` (a relative time into the future).\n    ///\n    /// Behavior is undefined if the mutex is not locked by the current thread.\n    ///\n    /// May panic if used with more than one mutex.\n    #[inline]\n    pub unsafe fn wait_timeout(&self, mutex: &MovableMutex, dur: Duration) -> bool {\n        self.check.verify(mutex);\n        self.inner.wait_timeout(mutex.raw(), dur)\n    }\n}\n\nimpl Drop for Condvar {\n    fn drop(&mut self) {\n        unsafe { self.inner.destroy() };\n    }\n}\n"],["2550","//! OS-based thread local storage\n//!\n//! This module provides an implementation of OS-based thread local storage,\n//! using the native OS-provided facilities (think `TlsAlloc` or\n//! `pthread_setspecific`). The interface of this differs from the other types\n//! of thread-local-storage provided in this crate in that OS-based TLS can only\n//! get/set pointer-sized data, possibly with an associated destructor.\n//!\n//! This module also provides two flavors of TLS. One is intended for static\n//! initialization, and does not contain a `Drop` implementation to deallocate\n//! the OS-TLS key. The other is a type which does implement `Drop` and hence\n//! has a safe interface.\n//!\n//! # Usage\n//!\n//! This module should likely not be used directly unless other primitives are\n//! being built on. Types such as `thread_local::spawn::Key` are likely much\n//! more useful in practice than this OS-based version which likely requires\n//! unsafe code to interoperate with.\n//!\n//! # Examples\n//!\n//! Using a dynamically allocated TLS key. Note that this key can be shared\n//! among many threads via an `Arc`.\n//!\n//! ```ignore (cannot-doctest-private-modules)\n//! let key = Key::new(None);\n//! assert!(key.get().is_null());\n//! key.set(1 as *mut u8);\n//! assert!(!key.get().is_null());\n//!\n//! drop(key); // deallocate this TLS slot.\n//! ```\n//!\n//! Sometimes a statically allocated key is either required or easier to work\n//! with, however.\n//!\n//! ```ignore (cannot-doctest-private-modules)\n//! static KEY: StaticKey = INIT;\n//!\n//! unsafe {\n//!     assert!(KEY.get().is_null());\n//!     KEY.set(1 as *mut u8);\n//! }\n//! ```\n\n#![allow(non_camel_case_types)]\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n#![allow(dead_code)] // sys isn't exported yet\n\n#[cfg(test)]\nmod tests;\n\nuse crate::sync::atomic::{self, AtomicUsize, Ordering};\nuse crate::sys::thread_local_key as imp;\nuse crate::sys_common::mutex::StaticMutex;\n\n/// A type for TLS keys that are statically allocated.\n///\n/// This type is entirely `unsafe` to use as it does not protect against\n/// use-after-deallocation or use-during-deallocation.\n///\n/// The actual OS-TLS key is lazily allocated when this is used for the first\n/// time. The key is also deallocated when the Rust runtime exits or `destroy`\n/// is called, whichever comes first.\n///\n/// # Examples\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use tls::os::{StaticKey, INIT};\n///\n/// static KEY: StaticKey = INIT;\n///\n/// unsafe {\n///     assert!(KEY.get().is_null());\n///     KEY.set(1 as *mut u8);\n/// }\n/// ```\npub struct StaticKey {\n    /// Inner static TLS key (internals).\n    key: AtomicUsize,\n    /// Destructor for the TLS value.\n    ///\n    /// See `Key::new` for information about when the destructor runs and how\n    /// it runs.\n    dtor: Option<unsafe extern \"C\" fn(*mut u8)>,\n}\n\n/// A type for a safely managed OS-based TLS slot.\n///\n/// This type allocates an OS TLS key when it is initialized and will deallocate\n/// the key when it falls out of scope. When compared with `StaticKey`, this\n/// type is entirely safe to use.\n///\n/// Implementations will likely, however, contain unsafe code as this type only\n/// operates on `*mut u8`, a raw pointer.\n///\n/// # Examples\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use tls::os::Key;\n///\n/// let key = Key::new(None);\n/// assert!(key.get().is_null());\n/// key.set(1 as *mut u8);\n/// assert!(!key.get().is_null());\n///\n/// drop(key); // deallocate this TLS slot.\n/// ```\npub struct Key {\n    key: imp::Key,\n}\n\n/// Constant initialization value for static TLS keys.\n///\n/// This value specifies no destructor by default.\npub const INIT: StaticKey = StaticKey::new(None);\n\nimpl StaticKey {\n    #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n    pub const fn new(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> StaticKey {\n        StaticKey { key: atomic::AtomicUsize::new(0), dtor }\n    }\n\n    /// Gets the value associated with this TLS key\n    ///\n    /// This will lazily allocate a TLS key from the OS if one has not already\n    /// been allocated.\n    #[inline]\n    pub unsafe fn get(&self) -> *mut u8 {\n        imp::get(self.key())\n    }\n\n    /// Sets this TLS key to a new value.\n    ///\n    /// This will lazily allocate a TLS key from the OS if one has not already\n    /// been allocated.\n    #[inline]\n    pub unsafe fn set(&self, val: *mut u8) {\n        imp::set(self.key(), val)\n    }\n\n    #[inline]\n    unsafe fn key(&self) -> imp::Key {\n        match self.key.load(Ordering::Relaxed) {\n            0 => self.lazy_init() as imp::Key,\n            n => n as imp::Key,\n        }\n    }\n\n    unsafe fn lazy_init(&self) -> usize {\n        // Currently the Windows implementation of TLS is pretty hairy, and\n        // it greatly simplifies creation if we just synchronize everything.\n        //\n        // Additionally a 0-index of a tls key hasn't been seen on windows, so\n        // we just simplify the whole branch.\n        if imp::requires_synchronized_create() {\n            // We never call `INIT_LOCK.init()`, so it is UB to attempt to\n            // acquire this mutex reentrantly!\n            static INIT_LOCK: StaticMutex = StaticMutex::new();\n            let _guard = INIT_LOCK.lock();\n            let mut key = self.key.load(Ordering::SeqCst);\n            if key == 0 {\n                key = imp::create(self.dtor) as usize;\n                self.key.store(key, Ordering::SeqCst);\n            }\n            rtassert!(key != 0);\n            return key;\n        }\n\n        // POSIX allows the key created here to be 0, but the compare_exchange\n        // below relies on using 0 as a sentinel value to check who won the\n        // race to set the shared TLS key. As far as I know, there is no\n        // guaranteed value that cannot be returned as a posix_key_create key,\n        // so there is no value we can initialize the inner key with to\n        // prove that it has not yet been set. As such, we'll continue using a\n        // value of 0, but with some gyrations to make sure we have a non-0\n        // value returned from the creation routine.\n        // FIXME: this is clearly a hack, and should be cleaned up.\n        let key1 = imp::create(self.dtor);\n        let key = if key1 != 0 {\n            key1\n        } else {\n            let key2 = imp::create(self.dtor);\n            imp::destroy(key1);\n            key2\n        };\n        rtassert!(key != 0);\n        match self.key.compare_exchange(0, key as usize, Ordering::SeqCst, Ordering::SeqCst) {\n            // The CAS succeeded, so we've created the actual key\n            Ok(_) => key as usize,\n            // If someone beat us to the punch, use their key instead\n            Err(n) => {\n                imp::destroy(key);\n                n\n            }\n        }\n    }\n}\n\nimpl Key {\n    /// Creates a new managed OS TLS key.\n    ///\n    /// This key will be deallocated when the key falls out of scope.\n    ///\n    /// The argument provided is an optionally-specified destructor for the\n    /// value of this TLS key. When a thread exits and the value for this key\n    /// is non-null the destructor will be invoked. The TLS value will be reset\n    /// to null before the destructor is invoked.\n    ///\n    /// Note that the destructor will not be run when the `Key` goes out of\n    /// scope.\n    #[inline]\n    pub fn new(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n        Key { key: unsafe { imp::create(dtor) } }\n    }\n\n    /// See StaticKey::get\n    #[inline]\n    pub fn get(&self) -> *mut u8 {\n        unsafe { imp::get(self.key) }\n    }\n\n    /// See StaticKey::set\n    #[inline]\n    pub fn set(&self, val: *mut u8) {\n        unsafe { imp::set(self.key, val) }\n    }\n}\n\nimpl Drop for Key {\n    fn drop(&mut self) {\n        // Right now Windows doesn't support TLS key destruction, but this also\n        // isn't used anywhere other than tests, so just leak the TLS key.\n        // unsafe { imp::destroy(self.key) }\n    }\n}\n"],["2551","use super::*;\nuse crate::borrow::Cow;\n\n#[test]\nfn code_point_from_u32() {\n    assert!(CodePoint::from_u32(0).is_some());\n    assert!(CodePoint::from_u32(0xD800).is_some());\n    assert!(CodePoint::from_u32(0x10FFFF).is_some());\n    assert!(CodePoint::from_u32(0x110000).is_none());\n}\n\n#[test]\nfn code_point_to_u32() {\n    fn c(value: u32) -> CodePoint {\n        CodePoint::from_u32(value).unwrap()\n    }\n    assert_eq!(c(0).to_u32(), 0);\n    assert_eq!(c(0xD800).to_u32(), 0xD800);\n    assert_eq!(c(0x10FFFF).to_u32(), 0x10FFFF);\n}\n\n#[test]\nfn code_point_from_char() {\n    assert_eq!(CodePoint::from_char('a').to_u32(), 0x61);\n    assert_eq!(CodePoint::from_char('💩').to_u32(), 0x1F4A9);\n}\n\n#[test]\nfn code_point_to_string() {\n    assert_eq!(format!(\"{:?}\", CodePoint::from_char('a')), \"U+0061\");\n    assert_eq!(format!(\"{:?}\", CodePoint::from_char('💩')), \"U+1F4A9\");\n}\n\n#[test]\nfn code_point_to_char() {\n    fn c(value: u32) -> CodePoint {\n        CodePoint::from_u32(value).unwrap()\n    }\n    assert_eq!(c(0x61).to_char(), Some('a'));\n    assert_eq!(c(0x1F4A9).to_char(), Some('💩'));\n    assert_eq!(c(0xD800).to_char(), None);\n}\n\n#[test]\nfn code_point_to_char_lossy() {\n    fn c(value: u32) -> CodePoint {\n        CodePoint::from_u32(value).unwrap()\n    }\n    assert_eq!(c(0x61).to_char_lossy(), 'a');\n    assert_eq!(c(0x1F4A9).to_char_lossy(), '💩');\n    assert_eq!(c(0xD800).to_char_lossy(), '\\u{FFFD}');\n}\n\n#[test]\nfn wtf8buf_new() {\n    assert_eq!(Wtf8Buf::new().bytes, b\"\");\n}\n\n#[test]\nfn wtf8buf_from_str() {\n    assert_eq!(Wtf8Buf::from_str(\"\").bytes, b\"\");\n    assert_eq!(Wtf8Buf::from_str(\"aé 💩\").bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n}\n\n#[test]\nfn wtf8buf_from_string() {\n    assert_eq!(Wtf8Buf::from_string(String::from(\"\")).bytes, b\"\");\n    assert_eq!(Wtf8Buf::from_string(String::from(\"aé 💩\")).bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n}\n\n#[test]\nfn wtf8buf_from_wide() {\n    assert_eq!(Wtf8Buf::from_wide(&[]).bytes, b\"\");\n    assert_eq!(\n        Wtf8Buf::from_wide(&[0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]).bytes,\n        b\"a\\xC3\\xA9 \\xED\\xA0\\xBD\\xF0\\x9F\\x92\\xA9\"\n    );\n}\n\n#[test]\nfn wtf8buf_push_str() {\n    let mut string = Wtf8Buf::new();\n    assert_eq!(string.bytes, b\"\");\n    string.push_str(\"aé 💩\");\n    assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n}\n\n#[test]\nfn wtf8buf_push_char() {\n    let mut string = Wtf8Buf::from_str(\"aé \");\n    assert_eq!(string.bytes, b\"a\\xC3\\xA9 \");\n    string.push_char('💩');\n    assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n}\n\n#[test]\nfn wtf8buf_push() {\n    let mut string = Wtf8Buf::from_str(\"aé \");\n    assert_eq!(string.bytes, b\"a\\xC3\\xA9 \");\n    string.push(CodePoint::from_char('💩'));\n    assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n\n    fn c(value: u32) -> CodePoint {\n        CodePoint::from_u32(value).unwrap()\n    }\n\n    let mut string = Wtf8Buf::new();\n    string.push(c(0xD83D)); // lead\n    string.push(c(0xDCA9)); // trail\n    assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n\n    let mut string = Wtf8Buf::new();\n    string.push(c(0xD83D)); // lead\n    string.push(c(0x20)); // not surrogate\n    string.push(c(0xDCA9)); // trail\n    assert_eq!(string.bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n\n    let mut string = Wtf8Buf::new();\n    string.push(c(0xD800)); // lead\n    string.push(c(0xDBFF)); // lead\n    assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n\n    let mut string = Wtf8Buf::new();\n    string.push(c(0xD800)); // lead\n    string.push(c(0xE000)); // not surrogate\n    assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n\n    let mut string = Wtf8Buf::new();\n    string.push(c(0xD7FF)); // not surrogate\n    string.push(c(0xDC00)); // trail\n    assert_eq!(string.bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n\n    let mut string = Wtf8Buf::new();\n    string.push(c(0x61)); // not surrogate, < 3 bytes\n    string.push(c(0xDC00)); // trail\n    assert_eq!(string.bytes, b\"\\x61\\xED\\xB0\\x80\");\n\n    let mut string = Wtf8Buf::new();\n    string.push(c(0xDC00)); // trail\n    assert_eq!(string.bytes, b\"\\xED\\xB0\\x80\");\n}\n\n#[test]\nfn wtf8buf_push_wtf8() {\n    let mut string = Wtf8Buf::from_str(\"aé\");\n    assert_eq!(string.bytes, b\"a\\xC3\\xA9\");\n    string.push_wtf8(Wtf8::from_str(\" 💩\"));\n    assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n\n    fn w(v: &[u8]) -> &Wtf8 {\n        unsafe { Wtf8::from_bytes_unchecked(v) }\n    }\n\n    let mut string = Wtf8Buf::new();\n    string.push_wtf8(w(b\"\\xED\\xA0\\xBD\")); // lead\n    string.push_wtf8(w(b\"\\xED\\xB2\\xA9\")); // trail\n    assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n\n    let mut string = Wtf8Buf::new();\n    string.push_wtf8(w(b\"\\xED\\xA0\\xBD\")); // lead\n    string.push_wtf8(w(b\" \")); // not surrogate\n    string.push_wtf8(w(b\"\\xED\\xB2\\xA9\")); // trail\n    assert_eq!(string.bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n\n    let mut string = Wtf8Buf::new();\n    string.push_wtf8(w(b\"\\xED\\xA0\\x80\")); // lead\n    string.push_wtf8(w(b\"\\xED\\xAF\\xBF\")); // lead\n    assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n\n    let mut string = Wtf8Buf::new();\n    string.push_wtf8(w(b\"\\xED\\xA0\\x80\")); // lead\n    string.push_wtf8(w(b\"\\xEE\\x80\\x80\")); // not surrogate\n    assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n\n    let mut string = Wtf8Buf::new();\n    string.push_wtf8(w(b\"\\xED\\x9F\\xBF\")); // not surrogate\n    string.push_wtf8(w(b\"\\xED\\xB0\\x80\")); // trail\n    assert_eq!(string.bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n\n    let mut string = Wtf8Buf::new();\n    string.push_wtf8(w(b\"a\")); // not surrogate, < 3 bytes\n    string.push_wtf8(w(b\"\\xED\\xB0\\x80\")); // trail\n    assert_eq!(string.bytes, b\"\\x61\\xED\\xB0\\x80\");\n\n    let mut string = Wtf8Buf::new();\n    string.push_wtf8(w(b\"\\xED\\xB0\\x80\")); // trail\n    assert_eq!(string.bytes, b\"\\xED\\xB0\\x80\");\n}\n\n#[test]\nfn wtf8buf_truncate() {\n    let mut string = Wtf8Buf::from_str(\"aé\");\n    string.truncate(1);\n    assert_eq!(string.bytes, b\"a\");\n}\n\n#[test]\n#[should_panic]\nfn wtf8buf_truncate_fail_code_point_boundary() {\n    let mut string = Wtf8Buf::from_str(\"aé\");\n    string.truncate(2);\n}\n\n#[test]\n#[should_panic]\nfn wtf8buf_truncate_fail_longer() {\n    let mut string = Wtf8Buf::from_str(\"aé\");\n    string.truncate(4);\n}\n\n#[test]\nfn wtf8buf_into_string() {\n    let mut string = Wtf8Buf::from_str(\"aé 💩\");\n    assert_eq!(string.clone().into_string(), Ok(String::from(\"aé 💩\")));\n    string.push(CodePoint::from_u32(0xD800).unwrap());\n    assert_eq!(string.clone().into_string(), Err(string));\n}\n\n#[test]\nfn wtf8buf_into_string_lossy() {\n    let mut string = Wtf8Buf::from_str(\"aé 💩\");\n    assert_eq!(string.clone().into_string_lossy(), String::from(\"aé 💩\"));\n    string.push(CodePoint::from_u32(0xD800).unwrap());\n    assert_eq!(string.clone().into_string_lossy(), String::from(\"aé 💩�\"));\n}\n\n#[test]\nfn wtf8buf_from_iterator() {\n    fn f(values: &[u32]) -> Wtf8Buf {\n        values.iter().map(|&c| CodePoint::from_u32(c).unwrap()).collect::<Wtf8Buf>()\n    }\n    assert_eq!(f(&[0x61, 0xE9, 0x20, 0x1F4A9]).bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n\n    assert_eq!(f(&[0xD83D, 0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n    assert_eq!(f(&[0xD83D, 0x20, 0xDCA9]).bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n    assert_eq!(f(&[0xD800, 0xDBFF]).bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n    assert_eq!(f(&[0xD800, 0xE000]).bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n    assert_eq!(f(&[0xD7FF, 0xDC00]).bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n    assert_eq!(f(&[0x61, 0xDC00]).bytes, b\"\\x61\\xED\\xB0\\x80\");\n    assert_eq!(f(&[0xDC00]).bytes, b\"\\xED\\xB0\\x80\");\n}\n\n#[test]\nfn wtf8buf_extend() {\n    fn e(initial: &[u32], extended: &[u32]) -> Wtf8Buf {\n        fn c(value: &u32) -> CodePoint {\n            CodePoint::from_u32(*value).unwrap()\n        }\n        let mut string = initial.iter().map(c).collect::<Wtf8Buf>();\n        string.extend(extended.iter().map(c));\n        string\n    }\n\n    assert_eq!(e(&[0x61, 0xE9], &[0x20, 0x1F4A9]).bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n\n    assert_eq!(e(&[0xD83D], &[0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n    assert_eq!(e(&[0xD83D, 0x20], &[0xDCA9]).bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n    assert_eq!(e(&[0xD800], &[0xDBFF]).bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n    assert_eq!(e(&[0xD800], &[0xE000]).bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n    assert_eq!(e(&[0xD7FF], &[0xDC00]).bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n    assert_eq!(e(&[0x61], &[0xDC00]).bytes, b\"\\x61\\xED\\xB0\\x80\");\n    assert_eq!(e(&[], &[0xDC00]).bytes, b\"\\xED\\xB0\\x80\");\n}\n\n#[test]\nfn wtf8buf_show() {\n    let mut string = Wtf8Buf::from_str(\"a\\té \\u{7f}💩\\r\");\n    string.push(CodePoint::from_u32(0xD800).unwrap());\n    assert_eq!(format!(\"{:?}\", string), \"\\\"a\\\\té \\\\u{7f}\\u{1f4a9}\\\\r\\\\u{d800}\\\"\");\n}\n\n#[test]\nfn wtf8buf_as_slice() {\n    assert_eq!(Wtf8Buf::from_str(\"aé\").as_slice(), Wtf8::from_str(\"aé\"));\n}\n\n#[test]\nfn wtf8buf_show_str() {\n    let text = \"a\\té 💩\\r\";\n    let string = Wtf8Buf::from_str(text);\n    assert_eq!(format!(\"{:?}\", text), format!(\"{:?}\", string));\n}\n\n#[test]\nfn wtf8_from_str() {\n    assert_eq!(&Wtf8::from_str(\"\").bytes, b\"\");\n    assert_eq!(&Wtf8::from_str(\"aé 💩\").bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n}\n\n#[test]\nfn wtf8_len() {\n    assert_eq!(Wtf8::from_str(\"\").len(), 0);\n    assert_eq!(Wtf8::from_str(\"aé 💩\").len(), 8);\n}\n\n#[test]\nfn wtf8_slice() {\n    assert_eq!(&Wtf8::from_str(\"aé 💩\")[1..4].bytes, b\"\\xC3\\xA9 \");\n}\n\n#[test]\n#[should_panic]\nfn wtf8_slice_not_code_point_boundary() {\n    let _ = &Wtf8::from_str(\"aé 💩\")[2..4];\n}\n\n#[test]\nfn wtf8_slice_from() {\n    assert_eq!(&Wtf8::from_str(\"aé 💩\")[1..].bytes, b\"\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n}\n\n#[test]\n#[should_panic]\nfn wtf8_slice_from_not_code_point_boundary() {\n    let _ = &Wtf8::from_str(\"aé 💩\")[2..];\n}\n\n#[test]\nfn wtf8_slice_to() {\n    assert_eq!(&Wtf8::from_str(\"aé 💩\")[..4].bytes, b\"a\\xC3\\xA9 \");\n}\n\n#[test]\n#[should_panic]\nfn wtf8_slice_to_not_code_point_boundary() {\n    let _ = &Wtf8::from_str(\"aé 💩\")[5..];\n}\n\n#[test]\nfn wtf8_ascii_byte_at() {\n    let slice = Wtf8::from_str(\"aé 💩\");\n    assert_eq!(slice.ascii_byte_at(0), b'a');\n    assert_eq!(slice.ascii_byte_at(1), b'\\xFF');\n    assert_eq!(slice.ascii_byte_at(2), b'\\xFF');\n    assert_eq!(slice.ascii_byte_at(3), b' ');\n    assert_eq!(slice.ascii_byte_at(4), b'\\xFF');\n}\n\n#[test]\nfn wtf8_code_points() {\n    fn c(value: u32) -> CodePoint {\n        CodePoint::from_u32(value).unwrap()\n    }\n    fn cp(string: &Wtf8Buf) -> Vec<Option<char>> {\n        string.code_points().map(|c| c.to_char()).collect::<Vec<_>>()\n    }\n    let mut string = Wtf8Buf::from_str(\"é \");\n    assert_eq!(cp(&string), [Some('é'), Some(' ')]);\n    string.push(c(0xD83D));\n    assert_eq!(cp(&string), [Some('é'), Some(' '), None]);\n    string.push(c(0xDCA9));\n    assert_eq!(cp(&string), [Some('é'), Some(' '), Some('💩')]);\n}\n\n#[test]\nfn wtf8_as_str() {\n    assert_eq!(Wtf8::from_str(\"\").as_str(), Some(\"\"));\n    assert_eq!(Wtf8::from_str(\"aé 💩\").as_str(), Some(\"aé 💩\"));\n    let mut string = Wtf8Buf::new();\n    string.push(CodePoint::from_u32(0xD800).unwrap());\n    assert_eq!(string.as_str(), None);\n}\n\n#[test]\nfn wtf8_to_string_lossy() {\n    assert_eq!(Wtf8::from_str(\"\").to_string_lossy(), Cow::Borrowed(\"\"));\n    assert_eq!(Wtf8::from_str(\"aé 💩\").to_string_lossy(), Cow::Borrowed(\"aé 💩\"));\n    let mut string = Wtf8Buf::from_str(\"aé 💩\");\n    string.push(CodePoint::from_u32(0xD800).unwrap());\n    let expected: Cow<'_, str> = Cow::Owned(String::from(\"aé 💩�\"));\n    assert_eq!(string.to_string_lossy(), expected);\n}\n\n#[test]\nfn wtf8_display() {\n    fn d(b: &[u8]) -> String {\n        (&unsafe { Wtf8::from_bytes_unchecked(b) }).to_string()\n    }\n\n    assert_eq!(\"\", d(\"\".as_bytes()));\n    assert_eq!(\"aé 💩\", d(\"aé 💩\".as_bytes()));\n\n    let mut string = Wtf8Buf::from_str(\"aé 💩\");\n    string.push(CodePoint::from_u32(0xD800).unwrap());\n    assert_eq!(\"aé 💩�\", d(string.as_inner()));\n}\n\n#[test]\nfn wtf8_encode_wide() {\n    let mut string = Wtf8Buf::from_str(\"aé \");\n    string.push(CodePoint::from_u32(0xD83D).unwrap());\n    string.push_char('💩');\n    assert_eq!(\n        string.encode_wide().collect::<Vec<_>>(),\n        vec![0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]\n    );\n}\n\n#[test]\nfn wtf8_encode_wide_size_hint() {\n    let string = Wtf8Buf::from_str(\"\\u{12345}\");\n    let mut iter = string.encode_wide();\n    assert_eq!((1, Some(8)), iter.size_hint());\n    iter.next().unwrap();\n    assert_eq!((1, Some(1)), iter.size_hint());\n    iter.next().unwrap();\n    assert_eq!((0, Some(0)), iter.size_hint());\n    assert!(iter.next().is_none());\n}\n"],["2552","// Original implementation taken from rust-memchr.\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\nuse crate::sys::memchr as sys;\n\n#[cfg(test)]\nmod tests;\n\n/// A safe interface to `memchr`.\n///\n/// Returns the index corresponding to the first occurrence of `needle` in\n/// `haystack`, or `None` if one is not found.\n///\n/// memchr reduces to super-optimized machine code at around an order of\n/// magnitude faster than `haystack.iter().position(|&b| b == needle)`.\n/// (See benchmarks.)\n///\n/// # Examples\n///\n/// This shows how to find the first position of a byte in a byte string.\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use memchr::memchr;\n///\n/// let haystack = b\"the quick brown fox\";\n/// assert_eq!(memchr(b'k', haystack), Some(8));\n/// ```\n#[inline]\npub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    sys::memchr(needle, haystack)\n}\n\n/// A safe interface to `memrchr`.\n///\n/// Returns the index corresponding to the last occurrence of `needle` in\n/// `haystack`, or `None` if one is not found.\n///\n/// # Examples\n///\n/// This shows how to find the last position of a byte in a byte string.\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use memchr::memrchr;\n///\n/// let haystack = b\"the quick brown fox\";\n/// assert_eq!(memrchr(b'o', haystack), Some(17));\n/// ```\n#[inline]\npub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    sys::memrchr(needle, haystack)\n}\n"],["2553","// Original implementation taken from rust-memchr.\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\n// test the implementations for the current platform\nuse super::{memchr, memrchr};\n\n#[test]\nfn matches_one() {\n    assert_eq!(Some(0), memchr(b'a', b\"a\"));\n}\n\n#[test]\nfn matches_begin() {\n    assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n}\n\n#[test]\nfn matches_end() {\n    assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n}\n\n#[test]\nfn matches_nul() {\n    assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n}\n\n#[test]\nfn matches_past_nul() {\n    assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n}\n\n#[test]\nfn no_match_empty() {\n    assert_eq!(None, memchr(b'a', b\"\"));\n}\n\n#[test]\nfn no_match() {\n    assert_eq!(None, memchr(b'a', b\"xyz\"));\n}\n\n#[test]\nfn matches_one_reversed() {\n    assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n}\n\n#[test]\nfn matches_begin_reversed() {\n    assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n}\n\n#[test]\nfn matches_end_reversed() {\n    assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n}\n\n#[test]\nfn matches_nul_reversed() {\n    assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n}\n\n#[test]\nfn matches_past_nul_reversed() {\n    assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n}\n\n#[test]\nfn no_match_empty_reversed() {\n    assert_eq!(None, memrchr(b'a', b\"\"));\n}\n\n#[test]\nfn no_match_reversed() {\n    assert_eq!(None, memrchr(b'a', b\"xyz\"));\n}\n\n#[test]\nfn each_alignment() {\n    let mut data = [1u8; 64];\n    let needle = 2;\n    let pos = 40;\n    data[pos] = needle;\n    for start in 0..16 {\n        assert_eq!(Some(pos - start), memchr(needle, &data[start..]));\n    }\n}\n"],["2554","use super::mul_div_u64;\n\n#[test]\nfn test_muldiv() {\n    assert_eq!(mul_div_u64(1_000_000_000_001, 1_000_000_000, 1_000_000), 1_000_000_000_001_000);\n}\n"],["2555","#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\nuse crate::marker::PhantomPinned;\nuse crate::ops::Deref;\nuse crate::panic::{RefUnwindSafe, UnwindSafe};\nuse crate::pin::Pin;\nuse crate::sys::mutex as sys;\n\n/// A re-entrant mutual exclusion\n///\n/// This mutex will block *other* threads waiting for the lock to become\n/// available. The thread which has already locked the mutex can lock it\n/// multiple times without blocking, preventing a common source of deadlocks.\npub struct ReentrantMutex<T> {\n    inner: sys::ReentrantMutex,\n    data: T,\n    _pinned: PhantomPinned,\n}\n\nunsafe impl<T: Send> Send for ReentrantMutex<T> {}\nunsafe impl<T: Send> Sync for ReentrantMutex<T> {}\n\nimpl<T> UnwindSafe for ReentrantMutex<T> {}\nimpl<T> RefUnwindSafe for ReentrantMutex<T> {}\n\n/// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n/// dropped (falls out of scope), the lock will be unlocked.\n///\n/// The data protected by the mutex can be accessed through this guard via its\n/// Deref implementation.\n///\n/// # Mutability\n///\n/// Unlike `MutexGuard`, `ReentrantMutexGuard` does not implement `DerefMut`,\n/// because implementation of the trait would violate Rust’s reference aliasing\n/// rules. Use interior mutability (usually `RefCell`) in order to mutate the\n/// guarded data.\n#[must_use = \"if unused the ReentrantMutex will immediately unlock\"]\npub struct ReentrantMutexGuard<'a, T: 'a> {\n    lock: Pin<&'a ReentrantMutex<T>>,\n}\n\nimpl<T> !Send for ReentrantMutexGuard<'_, T> {}\n\nimpl<T> ReentrantMutex<T> {\n    /// Creates a new reentrant mutex in an unlocked state.\n    ///\n    /// # Unsafety\n    ///\n    /// This function is unsafe because it is required that `init` is called\n    /// once this mutex is in its final resting place, and only then are the\n    /// lock/unlock methods safe.\n    pub const unsafe fn new(t: T) -> ReentrantMutex<T> {\n        ReentrantMutex {\n            inner: sys::ReentrantMutex::uninitialized(),\n            data: t,\n            _pinned: PhantomPinned,\n        }\n    }\n\n    /// Initializes this mutex so it's ready for use.\n    ///\n    /// # Unsafety\n    ///\n    /// Unsafe to call more than once, and must be called after this will no\n    /// longer move in memory.\n    pub unsafe fn init(self: Pin<&mut Self>) {\n        self.get_unchecked_mut().inner.init()\n    }\n\n    /// Acquires a mutex, blocking the current thread until it is able to do so.\n    ///\n    /// This function will block the caller until it is available to acquire the mutex.\n    /// Upon returning, the thread is the only thread with the mutex held. When the thread\n    /// calling this method already holds the lock, the call shall succeed without\n    /// blocking.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return failure if the mutex would otherwise be\n    /// acquired.\n    pub fn lock(self: Pin<&Self>) -> ReentrantMutexGuard<'_, T> {\n        unsafe { self.inner.lock() }\n        ReentrantMutexGuard { lock: self }\n    }\n\n    /// Attempts to acquire this lock.\n    ///\n    /// If the lock could not be acquired at this time, then `Err` is returned.\n    /// Otherwise, an RAII guard is returned.\n    ///\n    /// This function does not block.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return failure if the mutex would otherwise be\n    /// acquired.\n    pub fn try_lock(self: Pin<&Self>) -> Option<ReentrantMutexGuard<'_, T>> {\n        if unsafe { self.inner.try_lock() } {\n            Some(ReentrantMutexGuard { lock: self })\n        } else {\n            None\n        }\n    }\n}\n\nimpl<T> Drop for ReentrantMutex<T> {\n    fn drop(&mut self) {\n        // This is actually safe b/c we know that there is no further usage of\n        // this mutex (it's up to the user to arrange for a mutex to get\n        // dropped, that's not our job)\n        unsafe { self.inner.destroy() }\n    }\n}\n\nimpl<T> Deref for ReentrantMutexGuard<'_, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.lock.data\n    }\n}\n\nimpl<T> Drop for ReentrantMutexGuard<'_, T> {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe {\n            self.lock.inner.unlock();\n        }\n    }\n}\n"],["2556","//! Thread-local destructor\n//!\n//! Besides thread-local \"keys\" (pointer-sized non-addressable thread-local store\n//! with an associated destructor), many platforms also provide thread-local\n//! destructors that are not associated with any particular data. These are\n//! often more efficient.\n//!\n//! This module provides a fallback implementation for that interface, based\n//! on the less efficient thread-local \"keys\". Each platform provides\n//! a `thread_local_dtor` module which will either re-export the fallback,\n//! or implement something more efficient.\n\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n#![allow(dead_code)] // sys isn't exported yet\n\nuse crate::ptr;\nuse crate::sys_common::thread_local_key::StaticKey;\n\npub unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    // The fallback implementation uses a vanilla OS-based TLS key to track\n    // the list of destructors that need to be run for this thread. The key\n    // then has its own destructor which runs all the other destructors.\n    //\n    // The destructor for DTORS is a little special in that it has a `while`\n    // loop to continuously drain the list of registered destructors. It\n    // *should* be the case that this loop always terminates because we\n    // provide the guarantee that a TLS key cannot be set after it is\n    // flagged for destruction.\n\n    static DTORS: StaticKey = StaticKey::new(Some(run_dtors));\n    type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n    if DTORS.get().is_null() {\n        let v: Box<List> = box Vec::new();\n        DTORS.set(Box::into_raw(v) as *mut u8);\n    }\n    let list: &mut List = &mut *(DTORS.get() as *mut List);\n    list.push((t, dtor));\n\n    unsafe extern \"C\" fn run_dtors(mut ptr: *mut u8) {\n        while !ptr.is_null() {\n            let list: Box<List> = Box::from_raw(ptr as *mut List);\n            for (ptr, dtor) in list.into_iter() {\n                dtor(ptr);\n            }\n            ptr = DTORS.get();\n            DTORS.set(ptr::null_mut());\n        }\n    }\n}\n"],["2557","use crate::env;\nuse crate::sync::atomic::{self, Ordering};\nuse crate::sys::thread as imp;\n\npub fn min_stack() -> usize {\n    static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n    match MIN.load(Ordering::SeqCst) {\n        0 => {}\n        n => return n - 1,\n    }\n    let amt = env::var(\"RUST_MIN_STACK\").ok().and_then(|s| s.parse().ok());\n    let amt = amt.unwrap_or(imp::DEFAULT_MIN_STACK_SIZE);\n\n    // 0 is our sentinel value, so ensure that we'll never see 0 after\n    // initialization has run\n    MIN.store(amt + 1, Ordering::SeqCst);\n    amt\n}\n"],["2558","#![allow(dead_code)] // not used on all platforms\n\nuse crate::fs;\nuse crate::io::{self, Error, ErrorKind};\nuse crate::path::Path;\n\npub(crate) const NOT_FILE_ERROR: Error = Error::new_const(\n    ErrorKind::InvalidInput,\n    &\"the source path is neither a regular file nor a symlink to a regular file\",\n);\n\npub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n    let mut reader = fs::File::open(from)?;\n    let metadata = reader.metadata()?;\n\n    if !metadata.is_file() {\n        return Err(NOT_FILE_ERROR);\n    }\n\n    let mut writer = fs::File::create(to)?;\n    let perm = metadata.permissions();\n\n    let ret = io::copy(&mut reader, &mut writer)?;\n    writer.set_permissions(perm)?;\n    Ok(ret)\n}\n\npub fn remove_dir_all(path: &Path) -> io::Result<()> {\n    let filetype = fs::symlink_metadata(path)?.file_type();\n    if filetype.is_symlink() { fs::remove_file(path) } else { remove_dir_all_recursive(path) }\n}\n\nfn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n    for child in fs::read_dir(path)? {\n        let child = child?;\n        if child.file_type()?.is_dir() {\n            remove_dir_all_recursive(&child.path())?;\n        } else {\n            fs::remove_file(&child.path())?;\n        }\n    }\n    fs::remove_dir(path)\n}\n\npub fn try_exists(path: &Path) -> io::Result<bool> {\n    match fs::metadata(path) {\n        Ok(_) => Ok(true),\n        Err(error) if error.kind() == io::ErrorKind::NotFound => Ok(false),\n        Err(error) => Err(error),\n    }\n}\n"],["2559","#[cfg(test)]\nmod tests;\n\nuse crate::cmp;\nuse crate::convert::{TryFrom, TryInto};\nuse crate::ffi::CString;\nuse crate::fmt;\nuse crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut};\nuse crate::mem;\nuse crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\nuse crate::ptr;\nuse crate::sys::net::netc as c;\nuse crate::sys::net::{cvt, cvt_gai, cvt_r, init, wrlen_t, Socket};\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\nuse crate::time::Duration;\n\nuse libc::{c_int, c_void};\n\ncfg_if::cfg_if! {\n    if #[cfg(any(\n        target_os = \"dragonfly\", target_os = \"freebsd\",\n        target_os = \"ios\", target_os = \"macos\",\n        target_os = \"openbsd\", target_os = \"netbsd\", target_os = \"illumos\",\n        target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\"))] {\n        use crate::sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n        use crate::sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n    } else {\n        use crate::sys::net::netc::IPV6_ADD_MEMBERSHIP;\n        use crate::sys::net::netc::IPV6_DROP_MEMBERSHIP;\n    }\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(any(\n        target_os = \"linux\", target_os = \"android\",\n        target_os = \"dragonfly\", target_os = \"freebsd\",\n        target_os = \"openbsd\", target_os = \"netbsd\",\n        target_os = \"haiku\"))] {\n        use libc::MSG_NOSIGNAL;\n    } else {\n        const MSG_NOSIGNAL: c_int = 0x0;\n    }\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(any(\n        target_os = \"dragonfly\", target_os = \"freebsd\",\n        target_os = \"openbsd\", target_os = \"netbsd\",\n        target_os = \"solaris\", target_os = \"illumos\"))] {\n        use libc::c_uchar;\n        type IpV4MultiCastType = c_uchar;\n    } else {\n        type IpV4MultiCastType = c_int;\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// sockaddr and misc bindings\n////////////////////////////////////////////////////////////////////////////////\n\npub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int, payload: T) -> io::Result<()> {\n    unsafe {\n        let payload = &payload as *const T as *const c_void;\n        cvt(c::setsockopt(\n            *sock.as_inner(),\n            opt,\n            val,\n            payload,\n            mem::size_of::<T>() as c::socklen_t,\n        ))?;\n        Ok(())\n    }\n}\n\npub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int, val: c_int) -> io::Result<T> {\n    unsafe {\n        let mut slot: T = mem::zeroed();\n        let mut len = mem::size_of::<T>() as c::socklen_t;\n        cvt(c::getsockopt(*sock.as_inner(), opt, val, &mut slot as *mut _ as *mut _, &mut len))?;\n        assert_eq!(len as usize, mem::size_of::<T>());\n        Ok(slot)\n    }\n}\n\nfn sockname<F>(f: F) -> io::Result<SocketAddr>\nwhere\n    F: FnOnce(*mut c::sockaddr, *mut c::socklen_t) -> c_int,\n{\n    unsafe {\n        let mut storage: c::sockaddr_storage = mem::zeroed();\n        let mut len = mem::size_of_val(&storage) as c::socklen_t;\n        cvt(f(&mut storage as *mut _ as *mut _, &mut len))?;\n        sockaddr_to_addr(&storage, len as usize)\n    }\n}\n\npub fn sockaddr_to_addr(storage: &c::sockaddr_storage, len: usize) -> io::Result<SocketAddr> {\n    match storage.ss_family as c_int {\n        c::AF_INET => {\n            assert!(len as usize >= mem::size_of::<c::sockaddr_in>());\n            Ok(SocketAddr::V4(FromInner::from_inner(unsafe {\n                *(storage as *const _ as *const c::sockaddr_in)\n            })))\n        }\n        c::AF_INET6 => {\n            assert!(len as usize >= mem::size_of::<c::sockaddr_in6>());\n            Ok(SocketAddr::V6(FromInner::from_inner(unsafe {\n                *(storage as *const _ as *const c::sockaddr_in6)\n            })))\n        }\n        _ => Err(Error::new_const(ErrorKind::InvalidInput, &\"invalid argument\")),\n    }\n}\n\n#[cfg(target_os = \"android\")]\nfn to_ipv6mr_interface(value: u32) -> c_int {\n    value as c_int\n}\n\n#[cfg(not(target_os = \"android\"))]\nfn to_ipv6mr_interface(value: u32) -> libc::c_uint {\n    value as libc::c_uint\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// get_host_addresses\n////////////////////////////////////////////////////////////////////////////////\n\npub struct LookupHost {\n    original: *mut c::addrinfo,\n    cur: *mut c::addrinfo,\n    port: u16,\n}\n\nimpl LookupHost {\n    pub fn port(&self) -> u16 {\n        self.port\n    }\n}\n\nimpl Iterator for LookupHost {\n    type Item = SocketAddr;\n    fn next(&mut self) -> Option<SocketAddr> {\n        loop {\n            unsafe {\n                let cur = self.cur.as_ref()?;\n                self.cur = cur.ai_next;\n                match sockaddr_to_addr(mem::transmute(cur.ai_addr), cur.ai_addrlen as usize) {\n                    Ok(addr) => return Some(addr),\n                    Err(_) => continue,\n                }\n            }\n        }\n    }\n}\n\nunsafe impl Sync for LookupHost {}\nunsafe impl Send for LookupHost {}\n\nimpl Drop for LookupHost {\n    fn drop(&mut self) {\n        unsafe { c::freeaddrinfo(self.original) }\n    }\n}\n\nimpl TryFrom<&str> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from(s: &str) -> io::Result<LookupHost> {\n        macro_rules! try_opt {\n            ($e:expr, $msg:expr) => {\n                match $e {\n                    Some(r) => r,\n                    None => return Err(io::Error::new_const(io::ErrorKind::InvalidInput, &$msg)),\n                }\n            };\n        }\n\n        // split the string by ':' and convert the second part to u16\n        let (host, port_str) = try_opt!(s.rsplit_once(':'), \"invalid socket address\");\n        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n        (host, port).try_into()\n    }\n}\n\nimpl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n        init();\n\n        let c_host = CString::new(host)?;\n        let mut hints: c::addrinfo = unsafe { mem::zeroed() };\n        hints.ai_socktype = c::SOCK_STREAM;\n        let mut res = ptr::null_mut();\n        unsafe {\n            cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res))\n                .map(|_| LookupHost { original: res, cur: res, port })\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// TCP streams\n////////////////////////////////////////////////////////////////////////////////\n\npub struct TcpStream {\n    inner: Socket,\n}\n\nimpl TcpStream {\n    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n        let addr = addr?;\n\n        init();\n\n        let sock = Socket::new(addr, c::SOCK_STREAM)?;\n\n        let (addrp, len) = addr.into_inner();\n        cvt_r(|| unsafe { c::connect(*sock.as_inner(), addrp, len) })?;\n        Ok(TcpStream { inner: sock })\n    }\n\n    pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {\n        init();\n\n        let sock = Socket::new(addr, c::SOCK_STREAM)?;\n        sock.connect_timeout(addr, timeout)?;\n        Ok(TcpStream { inner: sock })\n    }\n\n    pub fn socket(&self) -> &Socket {\n        &self.inner\n    }\n\n    pub fn into_socket(self) -> Socket {\n        self.inner\n    }\n\n    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        self.inner.set_timeout(dur, c::SO_RCVTIMEO)\n    }\n\n    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        self.inner.set_timeout(dur, c::SO_SNDTIMEO)\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        self.inner.timeout(c::SO_RCVTIMEO)\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        self.inner.timeout(c::SO_SNDTIMEO)\n    }\n\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.peek(buf)\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n        let ret = cvt(unsafe {\n            c::send(*self.inner.as_inner(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.inner.is_write_vectored()\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        sockname(|buf, len| unsafe { c::getpeername(*self.inner.as_inner(), buf, len) })\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        sockname(|buf, len| unsafe { c::getsockname(*self.inner.as_inner(), buf, len) })\n    }\n\n    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n        self.inner.shutdown(how)\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpStream> {\n        self.inner.duplicate().map(|s| TcpStream { inner: s })\n    }\n\n    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n        self.inner.set_nodelay(nodelay)\n    }\n\n    pub fn nodelay(&self) -> io::Result<bool> {\n        self.inner.nodelay()\n    }\n\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL, ttl as c_int)\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL)?;\n        Ok(raw as u32)\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.inner.take_error()\n    }\n\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        self.inner.set_nonblocking(nonblocking)\n    }\n}\n\nimpl FromInner<Socket> for TcpStream {\n    fn from_inner(socket: Socket) -> TcpStream {\n        TcpStream { inner: socket }\n    }\n}\n\nimpl fmt::Debug for TcpStream {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut res = f.debug_struct(\"TcpStream\");\n\n        if let Ok(addr) = self.socket_addr() {\n            res.field(\"addr\", &addr);\n        }\n\n        if let Ok(peer) = self.peer_addr() {\n            res.field(\"peer\", &peer);\n        }\n\n        let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n        res.field(name, &self.inner.as_inner()).finish()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// TCP listeners\n////////////////////////////////////////////////////////////////////////////////\n\npub struct TcpListener {\n    inner: Socket,\n}\n\nimpl TcpListener {\n    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n        let addr = addr?;\n\n        init();\n\n        let sock = Socket::new(addr, c::SOCK_STREAM)?;\n\n        // On platforms with Berkeley-derived sockets, this allows to quickly\n        // rebind a socket, without needing to wait for the OS to clean up the\n        // previous one.\n        //\n        // On Windows, this allows rebinding sockets which are actively in use,\n        // which allows “socket hijacking”, so we explicitly don't set it here.\n        // https://docs.microsoft.com/en-us/windows/win32/winsock/using-so-reuseaddr-and-so-exclusiveaddruse\n        #[cfg(not(windows))]\n        setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR, 1 as c_int)?;\n\n        // Bind our new socket\n        let (addrp, len) = addr.into_inner();\n        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len as _) })?;\n\n        // Start listening\n        cvt(unsafe { c::listen(*sock.as_inner(), 128) })?;\n        Ok(TcpListener { inner: sock })\n    }\n\n    pub fn socket(&self) -> &Socket {\n        &self.inner\n    }\n\n    pub fn into_socket(self) -> Socket {\n        self.inner\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        sockname(|buf, len| unsafe { c::getsockname(*self.inner.as_inner(), buf, len) })\n    }\n\n    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n        let mut storage: c::sockaddr_storage = unsafe { mem::zeroed() };\n        let mut len = mem::size_of_val(&storage) as c::socklen_t;\n        let sock = self.inner.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n        let addr = sockaddr_to_addr(&storage, len as usize)?;\n        Ok((TcpStream { inner: sock }, addr))\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpListener> {\n        self.inner.duplicate().map(|s| TcpListener { inner: s })\n    }\n\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL, ttl as c_int)\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL)?;\n        Ok(raw as u32)\n    }\n\n    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY, only_v6 as c_int)\n    }\n\n    pub fn only_v6(&self) -> io::Result<bool> {\n        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY)?;\n        Ok(raw != 0)\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.inner.take_error()\n    }\n\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        self.inner.set_nonblocking(nonblocking)\n    }\n}\n\nimpl FromInner<Socket> for TcpListener {\n    fn from_inner(socket: Socket) -> TcpListener {\n        TcpListener { inner: socket }\n    }\n}\n\nimpl fmt::Debug for TcpListener {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut res = f.debug_struct(\"TcpListener\");\n\n        if let Ok(addr) = self.socket_addr() {\n            res.field(\"addr\", &addr);\n        }\n\n        let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n        res.field(name, &self.inner.as_inner()).finish()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// UDP\n////////////////////////////////////////////////////////////////////////////////\n\npub struct UdpSocket {\n    inner: Socket,\n}\n\nimpl UdpSocket {\n    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n        let addr = addr?;\n\n        init();\n\n        let sock = Socket::new(addr, c::SOCK_DGRAM)?;\n        let (addrp, len) = addr.into_inner();\n        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len as _) })?;\n        Ok(UdpSocket { inner: sock })\n    }\n\n    pub fn socket(&self) -> &Socket {\n        &self.inner\n    }\n\n    pub fn into_socket(self) -> Socket {\n        self.inner\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        sockname(|buf, len| unsafe { c::getpeername(*self.inner.as_inner(), buf, len) })\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        sockname(|buf, len| unsafe { c::getsockname(*self.inner.as_inner(), buf, len) })\n    }\n\n    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.inner.recv_from(buf)\n    }\n\n    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.inner.peek_from(buf)\n    }\n\n    pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {\n        let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n        let (dstp, dstlen) = dst.into_inner();\n        let ret = cvt(unsafe {\n            c::sendto(\n                *self.inner.as_inner(),\n                buf.as_ptr() as *const c_void,\n                len,\n                MSG_NOSIGNAL,\n                dstp,\n                dstlen,\n            )\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n        self.inner.duplicate().map(|s| UdpSocket { inner: s })\n    }\n\n    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        self.inner.set_timeout(dur, c::SO_RCVTIMEO)\n    }\n\n    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        self.inner.set_timeout(dur, c::SO_SNDTIMEO)\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        self.inner.timeout(c::SO_RCVTIMEO)\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        self.inner.timeout(c::SO_SNDTIMEO)\n    }\n\n    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {\n        setsockopt(&self.inner, c::SOL_SOCKET, c::SO_BROADCAST, broadcast as c_int)\n    }\n\n    pub fn broadcast(&self) -> io::Result<bool> {\n        let raw: c_int = getsockopt(&self.inner, c::SOL_SOCKET, c::SO_BROADCAST)?;\n        Ok(raw != 0)\n    }\n\n    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n        setsockopt(\n            &self.inner,\n            c::IPPROTO_IP,\n            c::IP_MULTICAST_LOOP,\n            multicast_loop_v4 as IpV4MultiCastType,\n        )\n    }\n\n    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n        let raw: IpV4MultiCastType = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n        Ok(raw != 0)\n    }\n\n    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n        setsockopt(\n            &self.inner,\n            c::IPPROTO_IP,\n            c::IP_MULTICAST_TTL,\n            multicast_ttl_v4 as IpV4MultiCastType,\n        )\n    }\n\n    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n        let raw: IpV4MultiCastType = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n        Ok(raw as u32)\n    }\n\n    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP, multicast_loop_v6 as c_int)\n    }\n\n    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP)?;\n        Ok(raw != 0)\n    }\n\n    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n        let mreq = c::ip_mreq {\n            imr_multiaddr: multiaddr.into_inner(),\n            imr_interface: interface.into_inner(),\n        };\n        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_ADD_MEMBERSHIP, mreq)\n    }\n\n    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n        let mreq = c::ipv6_mreq {\n            ipv6mr_multiaddr: *multiaddr.as_inner(),\n            ipv6mr_interface: to_ipv6mr_interface(interface),\n        };\n        setsockopt(&self.inner, c::IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, mreq)\n    }\n\n    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n        let mreq = c::ip_mreq {\n            imr_multiaddr: multiaddr.into_inner(),\n            imr_interface: interface.into_inner(),\n        };\n        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_DROP_MEMBERSHIP, mreq)\n    }\n\n    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n        let mreq = c::ipv6_mreq {\n            ipv6mr_multiaddr: *multiaddr.as_inner(),\n            ipv6mr_interface: to_ipv6mr_interface(interface),\n        };\n        setsockopt(&self.inner, c::IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, mreq)\n    }\n\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL, ttl as c_int)\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL)?;\n        Ok(raw as u32)\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.inner.take_error()\n    }\n\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        self.inner.set_nonblocking(nonblocking)\n    }\n\n    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.peek(buf)\n    }\n\n    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n        let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n        let ret = cvt(unsafe {\n            c::send(*self.inner.as_inner(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn connect(&self, addr: io::Result<&SocketAddr>) -> io::Result<()> {\n        let (addrp, len) = addr?.into_inner();\n        cvt_r(|| unsafe { c::connect(*self.inner.as_inner(), addrp, len) }).map(drop)\n    }\n}\n\nimpl FromInner<Socket> for UdpSocket {\n    fn from_inner(socket: Socket) -> UdpSocket {\n        UdpSocket { inner: socket }\n    }\n}\n\nimpl fmt::Debug for UdpSocket {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut res = f.debug_struct(\"UdpSocket\");\n\n        if let Ok(addr) = self.socket_addr() {\n            res.field(\"addr\", &addr);\n        }\n\n        let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n        res.field(name, &self.inner.as_inner()).finish()\n    }\n}\n"],["2560","//! Platform-independent platform abstraction\n//!\n//! This is the platform-independent portion of the standard library's\n//! platform abstraction layer, whereas `std::sys` is the\n//! platform-specific portion.\n//!\n//! The relationship between `std::sys_common`, `std::sys` and the\n//! rest of `std` is complex, with dependencies going in all\n//! directions: `std` depending on `sys_common`, `sys_common`\n//! depending on `sys`, and `sys` depending on `sys_common` and `std`.\n//! This is because `sys_common` not only contains platform-independent code,\n//! but also code that is shared between the different platforms in `sys`.\n//! Ideally all that shared code should be moved to `sys::common`,\n//! and the dependencies between `std`, `sys_common` and `sys` all would form a dag.\n//! Progress on this is tracked in #84187.\n\n#![allow(missing_docs)]\n#![allow(missing_debug_implementations)]\n\n#[cfg(test)]\nmod tests;\n\npub mod backtrace;\npub mod bytestring;\npub mod condvar;\npub mod fs;\npub mod io;\npub mod memchr;\npub mod mutex;\n// `doc` is required because `sys/mod.rs` imports `unix/ext/mod.rs` on Windows\n// when generating documentation.\n#[cfg(any(doc, not(windows)))]\npub mod os_str_bytes;\npub mod process;\npub mod remutex;\n#[macro_use]\npub mod rt;\npub mod rwlock;\npub mod thread;\npub mod thread_info;\npub mod thread_local_dtor;\npub mod thread_local_key;\npub mod thread_parker;\npub mod wtf8;\n\ncfg_if::cfg_if! {\n    if #[cfg(any(target_os = \"l4re\",\n                 target_os = \"hermit\",\n                 feature = \"restricted-std\",\n                 all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n                 all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n        pub use crate::sys::net;\n    } else {\n        pub mod net;\n    }\n}\n\n// common error constructors\n\n/// A trait for viewing representations from std types\n#[doc(hidden)]\npub trait AsInner<Inner: ?Sized> {\n    fn as_inner(&self) -> &Inner;\n}\n\n/// A trait for viewing representations from std types\n#[doc(hidden)]\npub trait AsInnerMut<Inner: ?Sized> {\n    fn as_inner_mut(&mut self) -> &mut Inner;\n}\n\n/// A trait for extracting representations from std types\n#[doc(hidden)]\npub trait IntoInner<Inner> {\n    fn into_inner(self) -> Inner;\n}\n\n/// A trait for creating std types from internal representations\n#[doc(hidden)]\npub trait FromInner<Inner> {\n    fn from_inner(inner: Inner) -> Self;\n}\n\n// Computes (value*numer)/denom without overflow, as long as both\n// (numer*denom) and the overall result fit into i64 (which is the case\n// for our time conversions).\n#[allow(dead_code)] // not used on all platforms\npub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 {\n    let q = value / denom;\n    let r = value % denom;\n    // Decompose value as (value/denom*denom + value%denom),\n    // substitute into (value*numer)/denom and simplify.\n    // r < denom, so (denom*numer) is the upper bound of (r*numer)\n    q * numer + r * numer / denom\n}\n"],["2561","use crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sys::mutex as mutex_imp;\nuse crate::sys_common::mutex::MovableMutex;\n\npub trait CondvarCheck {\n    type Check;\n}\n\n/// For boxed mutexes, a `Condvar` will check it's only ever used with the same\n/// mutex, based on its (stable) address.\nimpl CondvarCheck for Box<mutex_imp::Mutex> {\n    type Check = SameMutexCheck;\n}\n\npub struct SameMutexCheck {\n    addr: AtomicUsize,\n}\n\n#[allow(dead_code)]\nimpl SameMutexCheck {\n    pub const fn new() -> Self {\n        Self { addr: AtomicUsize::new(0) }\n    }\n    pub fn verify(&self, mutex: &MovableMutex) {\n        let addr = mutex.raw() as *const mutex_imp::Mutex as usize;\n        match self.addr.compare_exchange(0, addr, Ordering::SeqCst, Ordering::SeqCst) {\n            Ok(_) => {}               // Stored the address\n            Err(n) if n == addr => {} // Lost a race to store the same address\n            _ => panic!(\"attempted to use a condition variable with two mutexes\"),\n        }\n    }\n}\n\n/// Unboxed mutexes may move, so `Condvar` can not require its address to stay\n/// constant.\nimpl CondvarCheck for mutex_imp::Mutex {\n    type Check = NoCheck;\n}\n\npub struct NoCheck;\n\n#[allow(dead_code)]\nimpl NoCheck {\n    pub const fn new() -> Self {\n        Self\n    }\n    pub fn verify(&self, _: &MovableMutex) {}\n}\n"],["2562","use crate::sys::mutex as imp;\n\n/// An OS-based mutual exclusion lock, meant for use in static variables.\n///\n/// This mutex has a const constructor ([`StaticMutex::new`]), does not\n/// implement `Drop` to cleanup resources, and causes UB when used reentrantly.\n///\n/// This mutex does not implement poisoning.\n///\n/// This is a wrapper around `imp::Mutex` that does *not* call `init()` and\n/// `destroy()`.\npub struct StaticMutex(imp::Mutex);\n\nunsafe impl Sync for StaticMutex {}\n\nimpl StaticMutex {\n    /// Creates a new mutex for use.\n    pub const fn new() -> Self {\n        Self(imp::Mutex::new())\n    }\n\n    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n    /// will be unlocked.\n    ///\n    /// It is undefined behaviour to call this function while locked by the\n    /// same thread.\n    #[inline]\n    pub unsafe fn lock(&'static self) -> StaticMutexGuard {\n        self.0.lock();\n        StaticMutexGuard(&self.0)\n    }\n}\n\n#[must_use]\npub struct StaticMutexGuard(&'static imp::Mutex);\n\nimpl Drop for StaticMutexGuard {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe {\n            self.0.unlock();\n        }\n    }\n}\n\n/// An OS-based mutual exclusion lock.\n///\n/// This mutex does *not* have a const constructor, cleans up its resources in\n/// its `Drop` implementation, may safely be moved (when not borrowed), and\n/// does not cause UB when used reentrantly.\n///\n/// This mutex does not implement poisoning.\n///\n/// This is either a wrapper around `Box<imp::Mutex>` or `imp::Mutex`,\n/// depending on the platform. It is boxed on platforms where `imp::Mutex` may\n/// not be moved.\npub struct MovableMutex(imp::MovableMutex);\n\nunsafe impl Sync for MovableMutex {}\n\nimpl MovableMutex {\n    /// Creates a new mutex.\n    pub fn new() -> Self {\n        let mut mutex = imp::MovableMutex::from(imp::Mutex::new());\n        unsafe { mutex.init() };\n        Self(mutex)\n    }\n\n    pub(super) fn raw(&self) -> &imp::Mutex {\n        &self.0\n    }\n\n    /// Locks the mutex blocking the current thread until it is available.\n    #[inline]\n    pub fn raw_lock(&self) {\n        unsafe { self.0.lock() }\n    }\n\n    /// Attempts to lock the mutex without blocking, returning whether it was\n    /// successfully acquired or not.\n    #[inline]\n    pub fn try_lock(&self) -> bool {\n        unsafe { self.0.try_lock() }\n    }\n\n    /// Unlocks the mutex.\n    ///\n    /// Behavior is undefined if the current thread does not actually hold the\n    /// mutex.\n    #[inline]\n    pub unsafe fn raw_unlock(&self) {\n        self.0.unlock()\n    }\n}\n\nimpl Drop for MovableMutex {\n    fn drop(&mut self) {\n        unsafe { self.0.destroy() };\n    }\n}\n"],["2563","#![deny(unsafe_op_in_unsafe_fn)]\n#![allow(unused_macros)]\n\nuse crate::sync::Once;\nuse crate::sys;\nuse crate::sys_common::thread_info;\nuse crate::thread::Thread;\n\n// One-time runtime initialization.\n// Runs before `main`.\n// SAFETY: must be called only once during runtime initialization.\n// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n#[cfg_attr(test, allow(dead_code))]\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    unsafe {\n        sys::init(argc, argv);\n\n        let main_guard = sys::thread::guard::init();\n        // Next, set up the current Thread with the guard information we just\n        // created. Note that this isn't necessary in general for new threads,\n        // but we just do this to name the main thread and to give it correct\n        // info about the stack bounds.\n        let thread = Thread::new(Some(\"main\".to_owned()));\n        thread_info::set(main_guard, thread);\n    }\n}\n\n// One-time runtime cleanup.\n// Runs after `main` or at program exit.\n// NOTE: this is not guaranteed to run, for example when the program aborts.\n#[cfg_attr(test, allow(dead_code))]\npub fn cleanup() {\n    static CLEANUP: Once = Once::new();\n    CLEANUP.call_once(|| unsafe {\n        // Flush stdout and disable buffering.\n        crate::io::cleanup();\n        // SAFETY: Only called once during runtime cleanup.\n        sys::cleanup();\n    });\n}\n\n// Prints to the \"panic output\", depending on the platform this may be:\n// - the standard error output\n// - some dedicated platform specific output\n// - nothing (so this macro is a no-op)\nmacro_rules! rtprintpanic {\n    ($($t:tt)*) => {\n        if let Some(mut out) = crate::sys::stdio::panic_output() {\n            let _ = crate::io::Write::write_fmt(&mut out, format_args!($($t)*));\n        }\n    }\n}\n\nmacro_rules! rtabort {\n    ($($t:tt)*) => {\n        {\n            rtprintpanic!(\"fatal runtime error: {}\\n\", format_args!($($t)*));\n            crate::sys::abort_internal();\n        }\n    }\n}\n\nmacro_rules! rtassert {\n    ($e:expr) => {\n        if !$e {\n            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n        }\n    };\n}\n\nmacro_rules! rtunwrap {\n    ($ok:ident, $e:expr) => {\n        match $e {\n            $ok(v) => v,\n            ref err => {\n                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n            }\n        }\n    };\n}\n"],["2564","#![allow(dead_code)] // stack_guard isn't used right now on all platforms\n\nuse crate::cell::RefCell;\nuse crate::sys::thread::guard::Guard;\nuse crate::thread::Thread;\n\nstruct ThreadInfo {\n    stack_guard: Option<Guard>,\n    thread: Thread,\n}\n\nthread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(None) }\n\nimpl ThreadInfo {\n    fn with<R, F>(f: F) -> Option<R>\n    where\n        F: FnOnce(&mut ThreadInfo) -> R,\n    {\n        THREAD_INFO\n            .try_with(move |c| {\n                if c.borrow().is_none() {\n                    *c.borrow_mut() =\n                        Some(ThreadInfo { stack_guard: None, thread: Thread::new(None) })\n                }\n                f(c.borrow_mut().as_mut().unwrap())\n            })\n            .ok()\n    }\n}\n\npub fn current_thread() -> Option<Thread> {\n    ThreadInfo::with(|info| info.thread.clone())\n}\n\npub fn stack_guard() -> Option<Guard> {\n    ThreadInfo::with(|info| info.stack_guard.clone()).and_then(|o| o)\n}\n\npub fn set(stack_guard: Option<Guard>, thread: Thread) {\n    THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n    THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo { stack_guard, thread }));\n}\n\npub fn reset_guard(stack_guard: Option<Guard>) {\n    THREAD_INFO.with(move |c| c.borrow_mut().as_mut().unwrap().stack_guard = stack_guard);\n}\n"],["2565","use super::*;\nuse crate::collections::HashMap;\n\n#[test]\nfn no_lookup_host_duplicates() {\n    let mut addrs = HashMap::new();\n    let lh = match LookupHost::try_from((\"localhost\", 0)) {\n        Ok(lh) => lh,\n        Err(e) => panic!(\"couldn't resolve `localhost': {}\", e),\n    };\n    for sa in lh {\n        *addrs.entry(sa).or_insert(0) += 1;\n    }\n    assert_eq!(\n        addrs.iter().filter(|&(_, &v)| v > 1).collect::<Vec<_>>(),\n        vec![],\n        \"There should be no duplicate localhost entries\"\n    );\n}\n"],["2566","use crate::boxed::Box;\nuse crate::cell::RefCell;\nuse crate::pin::Pin;\nuse crate::sync::Arc;\nuse crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\nuse crate::thread;\n\n#[test]\nfn smoke() {\n    let m = unsafe {\n        let mut m = Box::pin(ReentrantMutex::new(()));\n        m.as_mut().init();\n        m\n    };\n    let m = m.as_ref();\n    {\n        let a = m.lock();\n        {\n            let b = m.lock();\n            {\n                let c = m.lock();\n                assert_eq!(*c, ());\n            }\n            assert_eq!(*b, ());\n        }\n        assert_eq!(*a, ());\n    }\n}\n\n#[test]\nfn is_mutex() {\n    let m = unsafe {\n        // FIXME: Simplify this if Arc gets a Arc::get_pin_mut.\n        let mut m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n        Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n        Pin::new_unchecked(m)\n    };\n    let m2 = m.clone();\n    let lock = m.as_ref().lock();\n    let child = thread::spawn(move || {\n        let lock = m2.as_ref().lock();\n        assert_eq!(*lock.borrow(), 4950);\n    });\n    for i in 0..100 {\n        let lock = m.as_ref().lock();\n        *lock.borrow_mut() += i;\n    }\n    drop(lock);\n    child.join().unwrap();\n}\n\n#[test]\nfn trylock_works() {\n    let m = unsafe {\n        // FIXME: Simplify this if Arc gets a Arc::get_pin_mut.\n        let mut m = Arc::new(ReentrantMutex::new(()));\n        Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n        Pin::new_unchecked(m)\n    };\n    let m2 = m.clone();\n    let _lock = m.as_ref().try_lock();\n    let _lock2 = m.as_ref().try_lock();\n    thread::spawn(move || {\n        let lock = m2.as_ref().try_lock();\n        assert!(lock.is_none());\n    })\n    .join()\n    .unwrap();\n    let _lock3 = m.as_ref().try_lock();\n}\n\npub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);\nimpl Drop for Answer<'_> {\n    fn drop(&mut self) {\n        *self.0.borrow_mut() = 42;\n    }\n}\n"],["2567","use super::{Key, StaticKey};\n\nfn assert_sync<T: Sync>() {}\nfn assert_send<T: Send>() {}\n\n#[test]\nfn smoke() {\n    assert_sync::<Key>();\n    assert_send::<Key>();\n\n    let k1 = Key::new(None);\n    let k2 = Key::new(None);\n    assert!(k1.get().is_null());\n    assert!(k2.get().is_null());\n    k1.set(1 as *mut _);\n    k2.set(2 as *mut _);\n    assert_eq!(k1.get() as usize, 1);\n    assert_eq!(k2.get() as usize, 2);\n}\n\n#[test]\nfn statik() {\n    static K1: StaticKey = StaticKey::new(None);\n    static K2: StaticKey = StaticKey::new(None);\n\n    unsafe {\n        assert!(K1.get().is_null());\n        assert!(K2.get().is_null());\n        K1.set(1 as *mut _);\n        K2.set(2 as *mut _);\n        assert_eq!(K1.get() as usize, 1);\n        assert_eq!(K2.get() as usize, 2);\n    }\n}\n"],["2568","use crate::backtrace_rs::{self, BacktraceFmt, BytesOrWideString, PrintFmt};\nuse crate::borrow::Cow;\n/// Common code for printing the backtrace in the same way across the different\n/// supported platforms.\nuse crate::env;\nuse crate::fmt;\nuse crate::io;\nuse crate::io::prelude::*;\nuse crate::path::{self, Path, PathBuf};\nuse crate::sync::atomic::{self, Ordering};\nuse crate::sys_common::mutex::StaticMutex;\n\n/// Max number of frames to print.\nconst MAX_NB_FRAMES: usize = 100;\n\n// SAFETY: Don't attempt to lock this reentrantly.\npub unsafe fn lock() -> impl Drop {\n    static LOCK: StaticMutex = StaticMutex::new();\n    LOCK.lock()\n}\n\n/// Prints the current backtrace.\npub fn print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n    // There are issues currently linking libbacktrace into tests, and in\n    // general during libstd's own unit tests we're not testing this path. In\n    // test mode immediately return here to optimize away any references to the\n    // libbacktrace symbols\n    if cfg!(test) {\n        return Ok(());\n    }\n\n    // Use a lock to prevent mixed output in multithreading context.\n    // Some platforms also requires it, like `SymFromAddr` on Windows.\n    unsafe {\n        let _lock = lock();\n        _print(w, format)\n    }\n}\n\nunsafe fn _print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n    struct DisplayBacktrace {\n        format: PrintFmt,\n    }\n    impl fmt::Display for DisplayBacktrace {\n        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n            unsafe { _print_fmt(fmt, self.format) }\n        }\n    }\n    write!(w, \"{}\", DisplayBacktrace { format })\n}\n\nunsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::Result {\n    // Always 'fail' to get the cwd when running under Miri -\n    // this allows Miri to display backtraces in isolation mode\n    let cwd = if !cfg!(miri) { env::current_dir().ok() } else { None };\n\n    let mut print_path = move |fmt: &mut fmt::Formatter<'_>, bows: BytesOrWideString<'_>| {\n        output_filename(fmt, bows, print_fmt, cwd.as_ref())\n    };\n    writeln!(fmt, \"stack backtrace:\")?;\n    let mut bt_fmt = BacktraceFmt::new(fmt, print_fmt, &mut print_path);\n    bt_fmt.add_context()?;\n    let mut idx = 0;\n    let mut res = Ok(());\n    // Start immediately if we're not using a short backtrace.\n    let mut start = print_fmt != PrintFmt::Short;\n    backtrace_rs::trace_unsynchronized(|frame| {\n        if print_fmt == PrintFmt::Short && idx > MAX_NB_FRAMES {\n            return false;\n        }\n\n        let mut hit = false;\n        let mut stop = false;\n        backtrace_rs::resolve_frame_unsynchronized(frame, |symbol| {\n            hit = true;\n            if print_fmt == PrintFmt::Short {\n                if let Some(sym) = symbol.name().and_then(|s| s.as_str()) {\n                    if sym.contains(\"__rust_begin_short_backtrace\") {\n                        stop = true;\n                        return;\n                    }\n                    if sym.contains(\"__rust_end_short_backtrace\") {\n                        start = true;\n                        return;\n                    }\n                }\n            }\n\n            if start {\n                res = bt_fmt.frame().symbol(frame, symbol);\n            }\n        });\n        if stop {\n            return false;\n        }\n        if !hit {\n            if start {\n                res = bt_fmt.frame().print_raw(frame.ip(), None, None, None);\n            }\n        }\n\n        idx += 1;\n        res.is_ok()\n    });\n    res?;\n    bt_fmt.finish()?;\n    if print_fmt == PrintFmt::Short {\n        writeln!(\n            fmt,\n            \"note: Some details are omitted, \\\n             run with `RUST_BACKTRACE=full` for a verbose backtrace.\"\n        )?;\n    }\n    Ok(())\n}\n\n/// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`. Note that\n/// this is only inline(never) when backtraces in libstd are enabled, otherwise\n/// it's fine to optimize away.\n#[cfg_attr(feature = \"backtrace\", inline(never))]\npub fn __rust_begin_short_backtrace<F, T>(f: F) -> T\nwhere\n    F: FnOnce() -> T,\n{\n    let result = f();\n\n    // prevent this frame from being tail-call optimised away\n    crate::hint::black_box(());\n\n    result\n}\n\n/// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`. Note that\n/// this is only inline(never) when backtraces in libstd are enabled, otherwise\n/// it's fine to optimize away.\n#[cfg_attr(feature = \"backtrace\", inline(never))]\npub fn __rust_end_short_backtrace<F, T>(f: F) -> T\nwhere\n    F: FnOnce() -> T,\n{\n    let result = f();\n\n    // prevent this frame from being tail-call optimised away\n    crate::hint::black_box(());\n\n    result\n}\n\npub enum RustBacktrace {\n    Print(PrintFmt),\n    Disabled,\n    RuntimeDisabled,\n}\n\n// For now logging is turned off by default, and this function checks to see\n// whether the magical environment variable is present to see if it's turned on.\npub fn rust_backtrace_env() -> RustBacktrace {\n    // If the `backtrace` feature of this crate isn't enabled quickly return\n    // `None` so this can be constant propagated all over the place to turn\n    // optimize away callers.\n    if !cfg!(feature = \"backtrace\") {\n        return RustBacktrace::Disabled;\n    }\n\n    // Setting environment variables for Fuchsia components isn't a standard\n    // or easily supported workflow. For now, always display backtraces.\n    if cfg!(target_os = \"fuchsia\") {\n        return RustBacktrace::Print(PrintFmt::Full);\n    }\n\n    static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n    match ENABLED.load(Ordering::SeqCst) {\n        0 => {}\n        1 => return RustBacktrace::RuntimeDisabled,\n        2 => return RustBacktrace::Print(PrintFmt::Short),\n        _ => return RustBacktrace::Print(PrintFmt::Full),\n    }\n\n    let (format, cache) = env::var_os(\"RUST_BACKTRACE\")\n        .map(|x| {\n            if &x == \"0\" {\n                (RustBacktrace::RuntimeDisabled, 1)\n            } else if &x == \"full\" {\n                (RustBacktrace::Print(PrintFmt::Full), 3)\n            } else {\n                (RustBacktrace::Print(PrintFmt::Short), 2)\n            }\n        })\n        .unwrap_or((RustBacktrace::RuntimeDisabled, 1));\n    ENABLED.store(cache, Ordering::SeqCst);\n    format\n}\n\n/// Prints the filename of the backtrace frame.\n///\n/// See also `output`.\npub fn output_filename(\n    fmt: &mut fmt::Formatter<'_>,\n    bows: BytesOrWideString<'_>,\n    print_fmt: PrintFmt,\n    cwd: Option<&PathBuf>,\n) -> fmt::Result {\n    let file: Cow<'_, Path> = match bows {\n        #[cfg(unix)]\n        BytesOrWideString::Bytes(bytes) => {\n            use crate::os::unix::prelude::*;\n            Path::new(crate::ffi::OsStr::from_bytes(bytes)).into()\n        }\n        #[cfg(not(unix))]\n        BytesOrWideString::Bytes(bytes) => {\n            Path::new(crate::str::from_utf8(bytes).unwrap_or(\"<unknown>\")).into()\n        }\n        #[cfg(windows)]\n        BytesOrWideString::Wide(wide) => {\n            use crate::os::windows::prelude::*;\n            Cow::Owned(crate::ffi::OsString::from_wide(wide).into())\n        }\n        #[cfg(not(windows))]\n        BytesOrWideString::Wide(_wide) => Path::new(\"<unknown>\").into(),\n    };\n    if print_fmt == PrintFmt::Short && file.is_absolute() {\n        if let Some(cwd) = cwd {\n            if let Ok(stripped) = file.strip_prefix(&cwd) {\n                if let Some(s) = stripped.to_str() {\n                    return write!(fmt, \".{}{}\", path::MAIN_SEPARATOR, s);\n                }\n            }\n        }\n    }\n    fmt::Display::fmt(&file.display(), fmt)\n}\n"],["2569","//! Implementation of [the WTF-8 encoding](https://simonsapin.github.io/wtf-8/).\n//!\n//! This library uses Rust’s type system to maintain\n//! [well-formedness](https://simonsapin.github.io/wtf-8/#well-formed),\n//! like the `String` and `&str` types do for UTF-8.\n//!\n//! Since [WTF-8 must not be used\n//! for interchange](https://simonsapin.github.io/wtf-8/#intended-audience),\n//! this library deliberately does not provide access to the underlying bytes\n//! of WTF-8 strings,\n//! nor can it decode WTF-8 from arbitrary bytes.\n//! WTF-8 strings can be obtained from UTF-8, UTF-16, or code points.\n\n// this module is imported from @SimonSapin's repo and has tons of dead code on\n// unix (it's mostly used on windows), so don't worry about dead code here.\n#![allow(dead_code)]\n\n#[cfg(test)]\nmod tests;\n\nuse core::str::next_code_point;\n\nuse crate::borrow::Cow;\nuse crate::char;\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\nuse crate::iter::FromIterator;\nuse crate::mem;\nuse crate::ops;\nuse crate::rc::Rc;\nuse crate::slice;\nuse crate::str;\nuse crate::sync::Arc;\nuse crate::sys_common::AsInner;\n\nconst UTF8_REPLACEMENT_CHARACTER: &str = \"\\u{FFFD}\";\n\n/// A Unicode code point: from U+0000 to U+10FFFF.\n///\n/// Compares with the `char` type,\n/// which represents a Unicode scalar value:\n/// a code point that is not a surrogate (U+D800 to U+DFFF).\n#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]\npub struct CodePoint {\n    value: u32,\n}\n\n/// Format the code point as `U+` followed by four to six hexadecimal digits.\n/// Example: `U+1F4A9`\nimpl fmt::Debug for CodePoint {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(formatter, \"U+{:04X}\", self.value)\n    }\n}\n\nimpl CodePoint {\n    /// Unsafely creates a new `CodePoint` without checking the value.\n    ///\n    /// Only use when `value` is known to be less than or equal to 0x10FFFF.\n    #[inline]\n    pub unsafe fn from_u32_unchecked(value: u32) -> CodePoint {\n        CodePoint { value }\n    }\n\n    /// Creates a new `CodePoint` if the value is a valid code point.\n    ///\n    /// Returns `None` if `value` is above 0x10FFFF.\n    #[inline]\n    pub fn from_u32(value: u32) -> Option<CodePoint> {\n        match value {\n            0..=0x10FFFF => Some(CodePoint { value }),\n            _ => None,\n        }\n    }\n\n    /// Creates a new `CodePoint` from a `char`.\n    ///\n    /// Since all Unicode scalar values are code points, this always succeeds.\n    #[inline]\n    pub fn from_char(value: char) -> CodePoint {\n        CodePoint { value: value as u32 }\n    }\n\n    /// Returns the numeric value of the code point.\n    #[inline]\n    pub fn to_u32(&self) -> u32 {\n        self.value\n    }\n\n    /// Optionally returns a Unicode scalar value for the code point.\n    ///\n    /// Returns `None` if the code point is a surrogate (from U+D800 to U+DFFF).\n    #[inline]\n    pub fn to_char(&self) -> Option<char> {\n        match self.value {\n            0xD800..=0xDFFF => None,\n            _ => Some(unsafe { char::from_u32_unchecked(self.value) }),\n        }\n    }\n\n    /// Returns a Unicode scalar value for the code point.\n    ///\n    /// Returns `'\\u{FFFD}'` (the replacement character “�”)\n    /// if the code point is a surrogate (from U+D800 to U+DFFF).\n    #[inline]\n    pub fn to_char_lossy(&self) -> char {\n        self.to_char().unwrap_or('\\u{FFFD}')\n    }\n}\n\n/// An owned, growable string of well-formed WTF-8 data.\n///\n/// Similar to `String`, but can additionally contain surrogate code points\n/// if they’re not in a surrogate pair.\n#[derive(Eq, PartialEq, Ord, PartialOrd, Clone)]\npub struct Wtf8Buf {\n    bytes: Vec<u8>,\n}\n\nimpl ops::Deref for Wtf8Buf {\n    type Target = Wtf8;\n\n    fn deref(&self) -> &Wtf8 {\n        self.as_slice()\n    }\n}\n\nimpl ops::DerefMut for Wtf8Buf {\n    fn deref_mut(&mut self) -> &mut Wtf8 {\n        self.as_mut_slice()\n    }\n}\n\n/// Format the string with double quotes,\n/// and surrogates as `\\u` followed by four hexadecimal digits.\n/// Example: `\"a\\u{D800}\"` for a string with code points [U+0061, U+D800]\nimpl fmt::Debug for Wtf8Buf {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&**self, formatter)\n    }\n}\n\nimpl Wtf8Buf {\n    /// Creates a new, empty WTF-8 string.\n    #[inline]\n    pub fn new() -> Wtf8Buf {\n        Wtf8Buf { bytes: Vec::new() }\n    }\n\n    /// Creates a new, empty WTF-8 string with pre-allocated capacity for `capacity` bytes.\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Wtf8Buf {\n        Wtf8Buf { bytes: Vec::with_capacity(capacity) }\n    }\n\n    /// Creates a WTF-8 string from a UTF-8 `String`.\n    ///\n    /// This takes ownership of the `String` and does not copy.\n    ///\n    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n    #[inline]\n    pub fn from_string(string: String) -> Wtf8Buf {\n        Wtf8Buf { bytes: string.into_bytes() }\n    }\n\n    /// Creates a WTF-8 string from a UTF-8 `&str` slice.\n    ///\n    /// This copies the content of the slice.\n    ///\n    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n    #[inline]\n    pub fn from_str(str: &str) -> Wtf8Buf {\n        Wtf8Buf { bytes: <[_]>::to_vec(str.as_bytes()) }\n    }\n\n    pub fn clear(&mut self) {\n        self.bytes.clear()\n    }\n\n    /// Creates a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit code units.\n    ///\n    /// This is lossless: calling `.encode_wide()` on the resulting string\n    /// will always return the original code units.\n    pub fn from_wide(v: &[u16]) -> Wtf8Buf {\n        let mut string = Wtf8Buf::with_capacity(v.len());\n        for item in char::decode_utf16(v.iter().cloned()) {\n            match item {\n                Ok(ch) => string.push_char(ch),\n                Err(surrogate) => {\n                    let surrogate = surrogate.unpaired_surrogate();\n                    // Surrogates are known to be in the code point range.\n                    let code_point = unsafe { CodePoint::from_u32_unchecked(surrogate as u32) };\n                    // Skip the WTF-8 concatenation check,\n                    // surrogate pairs are already decoded by decode_utf16\n                    string.push_code_point_unchecked(code_point)\n                }\n            }\n        }\n        string\n    }\n\n    /// Copied from String::push\n    /// This does **not** include the WTF-8 concatenation check.\n    fn push_code_point_unchecked(&mut self, code_point: CodePoint) {\n        let mut bytes = [0; 4];\n        let bytes = char::encode_utf8_raw(code_point.value, &mut bytes);\n        self.bytes.extend_from_slice(bytes)\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &Wtf8 {\n        unsafe { Wtf8::from_bytes_unchecked(&self.bytes) }\n    }\n\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut Wtf8 {\n        unsafe { Wtf8::from_mut_bytes_unchecked(&mut self.bytes) }\n    }\n\n    /// Reserves capacity for at least `additional` more bytes to be inserted\n    /// in the given `Wtf8Buf`.\n    /// The collection may reserve more space to avoid frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n        self.bytes.reserve(additional)\n    }\n\n    #[inline]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.bytes.reserve_exact(additional)\n    }\n\n    #[inline]\n    pub fn shrink_to_fit(&mut self) {\n        self.bytes.shrink_to_fit()\n    }\n\n    #[inline]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.bytes.shrink_to(min_capacity)\n    }\n\n    /// Returns the number of bytes that this string buffer can hold without reallocating.\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        self.bytes.capacity()\n    }\n\n    /// Append a UTF-8 slice at the end of the string.\n    #[inline]\n    pub fn push_str(&mut self, other: &str) {\n        self.bytes.extend_from_slice(other.as_bytes())\n    }\n\n    /// Append a WTF-8 slice at the end of the string.\n    ///\n    /// This replaces newly paired surrogates at the boundary\n    /// with a supplementary code point,\n    /// like concatenating ill-formed UTF-16 strings effectively would.\n    #[inline]\n    pub fn push_wtf8(&mut self, other: &Wtf8) {\n        match ((&*self).final_lead_surrogate(), other.initial_trail_surrogate()) {\n            // Replace newly paired surrogates by a supplementary code point.\n            (Some(lead), Some(trail)) => {\n                let len_without_lead_surrogate = self.len() - 3;\n                self.bytes.truncate(len_without_lead_surrogate);\n                let other_without_trail_surrogate = &other.bytes[3..];\n                // 4 bytes for the supplementary code point\n                self.bytes.reserve(4 + other_without_trail_surrogate.len());\n                self.push_char(decode_surrogate_pair(lead, trail));\n                self.bytes.extend_from_slice(other_without_trail_surrogate);\n            }\n            _ => self.bytes.extend_from_slice(&other.bytes),\n        }\n    }\n\n    /// Append a Unicode scalar value at the end of the string.\n    #[inline]\n    pub fn push_char(&mut self, c: char) {\n        self.push_code_point_unchecked(CodePoint::from_char(c))\n    }\n\n    /// Append a code point at the end of the string.\n    ///\n    /// This replaces newly paired surrogates at the boundary\n    /// with a supplementary code point,\n    /// like concatenating ill-formed UTF-16 strings effectively would.\n    #[inline]\n    pub fn push(&mut self, code_point: CodePoint) {\n        if let trail @ 0xDC00..=0xDFFF = code_point.to_u32() {\n            if let Some(lead) = (&*self).final_lead_surrogate() {\n                let len_without_lead_surrogate = self.len() - 3;\n                self.bytes.truncate(len_without_lead_surrogate);\n                self.push_char(decode_surrogate_pair(lead, trail as u16));\n                return;\n            }\n        }\n\n        // No newly paired surrogates at the boundary.\n        self.push_code_point_unchecked(code_point)\n    }\n\n    /// Shortens a string to the specified length.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `new_len` > current length,\n    /// or if `new_len` is not a code point boundary.\n    #[inline]\n    pub fn truncate(&mut self, new_len: usize) {\n        assert!(is_code_point_boundary(self, new_len));\n        self.bytes.truncate(new_len)\n    }\n\n    /// Consumes the WTF-8 string and tries to convert it to UTF-8.\n    ///\n    /// This does not copy the data.\n    ///\n    /// If the contents are not well-formed UTF-8\n    /// (that is, if the string contains surrogates),\n    /// the original WTF-8 string is returned instead.\n    pub fn into_string(self) -> Result<String, Wtf8Buf> {\n        match self.next_surrogate(0) {\n            None => Ok(unsafe { String::from_utf8_unchecked(self.bytes) }),\n            Some(_) => Err(self),\n        }\n    }\n\n    /// Consumes the WTF-8 string and converts it lossily to UTF-8.\n    ///\n    /// This does not copy the data (but may overwrite parts of it in place).\n    ///\n    /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character “�”)\n    pub fn into_string_lossy(mut self) -> String {\n        let mut pos = 0;\n        loop {\n            match self.next_surrogate(pos) {\n                Some((surrogate_pos, _)) => {\n                    pos = surrogate_pos + 3;\n                    self.bytes[surrogate_pos..pos]\n                        .copy_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());\n                }\n                None => return unsafe { String::from_utf8_unchecked(self.bytes) },\n            }\n        }\n    }\n\n    /// Converts this `Wtf8Buf` into a boxed `Wtf8`.\n    #[inline]\n    pub fn into_box(self) -> Box<Wtf8> {\n        unsafe { mem::transmute(self.bytes.into_boxed_slice()) }\n    }\n\n    /// Converts a `Box<Wtf8>` into a `Wtf8Buf`.\n    pub fn from_box(boxed: Box<Wtf8>) -> Wtf8Buf {\n        let bytes: Box<[u8]> = unsafe { mem::transmute(boxed) };\n        Wtf8Buf { bytes: bytes.into_vec() }\n    }\n}\n\n/// Creates a new WTF-8 string from an iterator of code points.\n///\n/// This replaces surrogate code point pairs with supplementary code points,\n/// like concatenating ill-formed UTF-16 strings effectively would.\nimpl FromIterator<CodePoint> for Wtf8Buf {\n    fn from_iter<T: IntoIterator<Item = CodePoint>>(iter: T) -> Wtf8Buf {\n        let mut string = Wtf8Buf::new();\n        string.extend(iter);\n        string\n    }\n}\n\n/// Append code points from an iterator to the string.\n///\n/// This replaces surrogate code point pairs with supplementary code points,\n/// like concatenating ill-formed UTF-16 strings effectively would.\nimpl Extend<CodePoint> for Wtf8Buf {\n    fn extend<T: IntoIterator<Item = CodePoint>>(&mut self, iter: T) {\n        let iterator = iter.into_iter();\n        let (low, _high) = iterator.size_hint();\n        // Lower bound of one byte per code point (ASCII only)\n        self.bytes.reserve(low);\n        iterator.for_each(move |code_point| self.push(code_point));\n    }\n\n    #[inline]\n    fn extend_one(&mut self, code_point: CodePoint) {\n        self.push(code_point);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        // Lower bound of one byte per code point (ASCII only)\n        self.bytes.reserve(additional);\n    }\n}\n\n/// A borrowed slice of well-formed WTF-8 data.\n///\n/// Similar to `&str`, but can additionally contain surrogate code points\n/// if they’re not in a surrogate pair.\n#[derive(Eq, Ord, PartialEq, PartialOrd)]\npub struct Wtf8 {\n    bytes: [u8],\n}\n\nimpl AsInner<[u8]> for Wtf8 {\n    fn as_inner(&self) -> &[u8] {\n        &self.bytes\n    }\n}\n\n/// Format the slice with double quotes,\n/// and surrogates as `\\u` followed by four hexadecimal digits.\n/// Example: `\"a\\u{D800}\"` for a slice with code points [U+0061, U+D800]\nimpl fmt::Debug for Wtf8 {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fn write_str_escaped(f: &mut fmt::Formatter<'_>, s: &str) -> fmt::Result {\n            use crate::fmt::Write;\n            for c in s.chars().flat_map(|c| c.escape_debug()) {\n                f.write_char(c)?\n            }\n            Ok(())\n        }\n\n        formatter.write_str(\"\\\"\")?;\n        let mut pos = 0;\n        while let Some((surrogate_pos, surrogate)) = self.next_surrogate(pos) {\n            write_str_escaped(formatter, unsafe {\n                str::from_utf8_unchecked(&self.bytes[pos..surrogate_pos])\n            })?;\n            write!(formatter, \"\\\\u{{{:x}}}\", surrogate)?;\n            pos = surrogate_pos + 3;\n        }\n        write_str_escaped(formatter, unsafe { str::from_utf8_unchecked(&self.bytes[pos..]) })?;\n        formatter.write_str(\"\\\"\")\n    }\n}\n\nimpl fmt::Display for Wtf8 {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let wtf8_bytes = &self.bytes;\n        let mut pos = 0;\n        loop {\n            match self.next_surrogate(pos) {\n                Some((surrogate_pos, _)) => {\n                    formatter.write_str(unsafe {\n                        str::from_utf8_unchecked(&wtf8_bytes[pos..surrogate_pos])\n                    })?;\n                    formatter.write_str(UTF8_REPLACEMENT_CHARACTER)?;\n                    pos = surrogate_pos + 3;\n                }\n                None => {\n                    let s = unsafe { str::from_utf8_unchecked(&wtf8_bytes[pos..]) };\n                    if pos == 0 { return s.fmt(formatter) } else { return formatter.write_str(s) }\n                }\n            }\n        }\n    }\n}\n\nimpl Wtf8 {\n    /// Creates a WTF-8 slice from a UTF-8 `&str` slice.\n    ///\n    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n    #[inline]\n    pub fn from_str(value: &str) -> &Wtf8 {\n        unsafe { Wtf8::from_bytes_unchecked(value.as_bytes()) }\n    }\n\n    /// Creates a WTF-8 slice from a WTF-8 byte slice.\n    ///\n    /// Since the byte slice is not checked for valid WTF-8, this functions is\n    /// marked unsafe.\n    #[inline]\n    unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 {\n        mem::transmute(value)\n    }\n\n    /// Creates a mutable WTF-8 slice from a mutable WTF-8 byte slice.\n    ///\n    /// Since the byte slice is not checked for valid WTF-8, this functions is\n    /// marked unsafe.\n    #[inline]\n    unsafe fn from_mut_bytes_unchecked(value: &mut [u8]) -> &mut Wtf8 {\n        mem::transmute(value)\n    }\n\n    /// Returns the length, in WTF-8 bytes.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.bytes.len()\n    }\n\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.bytes.is_empty()\n    }\n\n    /// Returns the code point at `position` if it is in the ASCII range,\n    /// or `b'\\xFF' otherwise.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `position` is beyond the end of the string.\n    #[inline]\n    pub fn ascii_byte_at(&self, position: usize) -> u8 {\n        match self.bytes[position] {\n            ascii_byte @ 0x00..=0x7F => ascii_byte,\n            _ => 0xFF,\n        }\n    }\n\n    /// Returns an iterator for the string’s code points.\n    #[inline]\n    pub fn code_points(&self) -> Wtf8CodePoints<'_> {\n        Wtf8CodePoints { bytes: self.bytes.iter() }\n    }\n\n    /// Tries to convert the string to UTF-8 and return a `&str` slice.\n    ///\n    /// Returns `None` if the string contains surrogates.\n    ///\n    /// This does not copy the data.\n    #[inline]\n    pub fn as_str(&self) -> Option<&str> {\n        // Well-formed WTF-8 is also well-formed UTF-8\n        // if and only if it contains no surrogate.\n        match self.next_surrogate(0) {\n            None => Some(unsafe { str::from_utf8_unchecked(&self.bytes) }),\n            Some(_) => None,\n        }\n    }\n\n    /// Lossily converts the string to UTF-8.\n    /// Returns a UTF-8 `&str` slice if the contents are well-formed in UTF-8.\n    ///\n    /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character “�”).\n    ///\n    /// This only copies the data if necessary (if it contains any surrogate).\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n        let surrogate_pos = match self.next_surrogate(0) {\n            None => return Cow::Borrowed(unsafe { str::from_utf8_unchecked(&self.bytes) }),\n            Some((pos, _)) => pos,\n        };\n        let wtf8_bytes = &self.bytes;\n        let mut utf8_bytes = Vec::with_capacity(self.len());\n        utf8_bytes.extend_from_slice(&wtf8_bytes[..surrogate_pos]);\n        utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());\n        let mut pos = surrogate_pos + 3;\n        loop {\n            match self.next_surrogate(pos) {\n                Some((surrogate_pos, _)) => {\n                    utf8_bytes.extend_from_slice(&wtf8_bytes[pos..surrogate_pos]);\n                    utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());\n                    pos = surrogate_pos + 3;\n                }\n                None => {\n                    utf8_bytes.extend_from_slice(&wtf8_bytes[pos..]);\n                    return Cow::Owned(unsafe { String::from_utf8_unchecked(utf8_bytes) });\n                }\n            }\n        }\n    }\n\n    /// Converts the WTF-8 string to potentially ill-formed UTF-16\n    /// and return an iterator of 16-bit code units.\n    ///\n    /// This is lossless:\n    /// calling `Wtf8Buf::from_ill_formed_utf16` on the resulting code units\n    /// would always return the original WTF-8 string.\n    #[inline]\n    pub fn encode_wide(&self) -> EncodeWide<'_> {\n        EncodeWide { code_points: self.code_points(), extra: 0 }\n    }\n\n    #[inline]\n    fn next_surrogate(&self, mut pos: usize) -> Option<(usize, u16)> {\n        let mut iter = self.bytes[pos..].iter();\n        loop {\n            let b = *iter.next()?;\n            if b < 0x80 {\n                pos += 1;\n            } else if b < 0xE0 {\n                iter.next();\n                pos += 2;\n            } else if b == 0xED {\n                match (iter.next(), iter.next()) {\n                    (Some(&b2), Some(&b3)) if b2 >= 0xA0 => {\n                        return Some((pos, decode_surrogate(b2, b3)));\n                    }\n                    _ => pos += 3,\n                }\n            } else if b < 0xF0 {\n                iter.next();\n                iter.next();\n                pos += 3;\n            } else {\n                iter.next();\n                iter.next();\n                iter.next();\n                pos += 4;\n            }\n        }\n    }\n\n    #[inline]\n    fn final_lead_surrogate(&self) -> Option<u16> {\n        match self.bytes {\n            [.., 0xED, b2 @ 0xA0..=0xAF, b3] => Some(decode_surrogate(b2, b3)),\n            _ => None,\n        }\n    }\n\n    #[inline]\n    fn initial_trail_surrogate(&self) -> Option<u16> {\n        match self.bytes {\n            [0xED, b2 @ 0xB0..=0xBF, b3, ..] => Some(decode_surrogate(b2, b3)),\n            _ => None,\n        }\n    }\n\n    pub fn clone_into(&self, buf: &mut Wtf8Buf) {\n        self.bytes.clone_into(&mut buf.bytes)\n    }\n\n    /// Boxes this `Wtf8`.\n    #[inline]\n    pub fn into_box(&self) -> Box<Wtf8> {\n        let boxed: Box<[u8]> = self.bytes.into();\n        unsafe { mem::transmute(boxed) }\n    }\n\n    /// Creates a boxed, empty `Wtf8`.\n    pub fn empty_box() -> Box<Wtf8> {\n        let boxed: Box<[u8]> = Default::default();\n        unsafe { mem::transmute(boxed) }\n    }\n\n    #[inline]\n    pub fn into_arc(&self) -> Arc<Wtf8> {\n        let arc: Arc<[u8]> = Arc::from(&self.bytes);\n        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Wtf8) }\n    }\n\n    #[inline]\n    pub fn into_rc(&self) -> Rc<Wtf8> {\n        let rc: Rc<[u8]> = Rc::from(&self.bytes);\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Wtf8) }\n    }\n\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        self.bytes.make_ascii_lowercase()\n    }\n\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        self.bytes.make_ascii_uppercase()\n    }\n\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> Wtf8Buf {\n        Wtf8Buf { bytes: self.bytes.to_ascii_lowercase() }\n    }\n\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> Wtf8Buf {\n        Wtf8Buf { bytes: self.bytes.to_ascii_uppercase() }\n    }\n\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n        self.bytes.is_ascii()\n    }\n\n    #[inline]\n    pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool {\n        self.bytes.eq_ignore_ascii_case(&other.bytes)\n    }\n}\n\n/// Returns a slice of the given string for the byte range [`begin`..`end`).\n///\n/// # Panics\n///\n/// Panics when `begin` and `end` do not point to code point boundaries,\n/// or point beyond the end of the string.\nimpl ops::Index<ops::Range<usize>> for Wtf8 {\n    type Output = Wtf8;\n\n    #[inline]\n    fn index(&self, range: ops::Range<usize>) -> &Wtf8 {\n        // is_code_point_boundary checks that the index is in [0, .len()]\n        if range.start <= range.end\n            && is_code_point_boundary(self, range.start)\n            && is_code_point_boundary(self, range.end)\n        {\n            unsafe { slice_unchecked(self, range.start, range.end) }\n        } else {\n            slice_error_fail(self, range.start, range.end)\n        }\n    }\n}\n\n/// Returns a slice of the given string from byte `begin` to its end.\n///\n/// # Panics\n///\n/// Panics when `begin` is not at a code point boundary,\n/// or is beyond the end of the string.\nimpl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n    type Output = Wtf8;\n\n    #[inline]\n    fn index(&self, range: ops::RangeFrom<usize>) -> &Wtf8 {\n        // is_code_point_boundary checks that the index is in [0, .len()]\n        if is_code_point_boundary(self, range.start) {\n            unsafe { slice_unchecked(self, range.start, self.len()) }\n        } else {\n            slice_error_fail(self, range.start, self.len())\n        }\n    }\n}\n\n/// Returns a slice of the given string from its beginning to byte `end`.\n///\n/// # Panics\n///\n/// Panics when `end` is not at a code point boundary,\n/// or is beyond the end of the string.\nimpl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n    type Output = Wtf8;\n\n    #[inline]\n    fn index(&self, range: ops::RangeTo<usize>) -> &Wtf8 {\n        // is_code_point_boundary checks that the index is in [0, .len()]\n        if is_code_point_boundary(self, range.end) {\n            unsafe { slice_unchecked(self, 0, range.end) }\n        } else {\n            slice_error_fail(self, 0, range.end)\n        }\n    }\n}\n\nimpl ops::Index<ops::RangeFull> for Wtf8 {\n    type Output = Wtf8;\n\n    #[inline]\n    fn index(&self, _range: ops::RangeFull) -> &Wtf8 {\n        self\n    }\n}\n\n#[inline]\nfn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 {\n    // The first byte is assumed to be 0xED\n    0xD800 | (second_byte as u16 & 0x3F) << 6 | third_byte as u16 & 0x3F\n}\n\n#[inline]\nfn decode_surrogate_pair(lead: u16, trail: u16) -> char {\n    let code_point = 0x10000 + ((((lead - 0xD800) as u32) << 10) | (trail - 0xDC00) as u32);\n    unsafe { char::from_u32_unchecked(code_point) }\n}\n\n/// Copied from core::str::StrPrelude::is_char_boundary\n#[inline]\npub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool {\n    if index == slice.len() {\n        return true;\n    }\n    match slice.bytes.get(index) {\n        None => false,\n        Some(&b) => b < 128 || b >= 192,\n    }\n}\n\n/// Copied from core::str::raw::slice_unchecked\n#[inline]\npub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 {\n    // memory layout of an &[u8] and &Wtf8 are the same\n    Wtf8::from_bytes_unchecked(slice::from_raw_parts(s.bytes.as_ptr().add(begin), end - begin))\n}\n\n/// Copied from core::str::raw::slice_error_fail\n#[inline(never)]\npub fn slice_error_fail(s: &Wtf8, begin: usize, end: usize) -> ! {\n    assert!(begin <= end);\n    panic!(\"index {} and/or {} in `{:?}` do not lie on character boundary\", begin, end, s);\n}\n\n/// Iterator for the code points of a WTF-8 string.\n///\n/// Created with the method `.code_points()`.\n#[derive(Clone)]\npub struct Wtf8CodePoints<'a> {\n    bytes: slice::Iter<'a, u8>,\n}\n\nimpl<'a> Iterator for Wtf8CodePoints<'a> {\n    type Item = CodePoint;\n\n    #[inline]\n    fn next(&mut self) -> Option<CodePoint> {\n        next_code_point(&mut self.bytes).map(|c| CodePoint { value: c })\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.bytes.len();\n        (len.saturating_add(3) / 4, Some(len))\n    }\n}\n\n/// Generates a wide character sequence for potentially ill-formed UTF-16.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct EncodeWide<'a> {\n    code_points: Wtf8CodePoints<'a>,\n    extra: u16,\n}\n\n// Copied from libunicode/u_str.rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for EncodeWide<'a> {\n    type Item = u16;\n\n    #[inline]\n    fn next(&mut self) -> Option<u16> {\n        if self.extra != 0 {\n            let tmp = self.extra;\n            self.extra = 0;\n            return Some(tmp);\n        }\n\n        let mut buf = [0; 2];\n        self.code_points.next().map(|code_point| {\n            let n = char::encode_utf16_raw(code_point.value, &mut buf).len();\n            if n == 2 {\n                self.extra = buf[1];\n            }\n            buf[0]\n        })\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.code_points.size_hint();\n        let ext = (self.extra != 0) as usize;\n        // every code point gets either one u16 or two u16,\n        // so this iterator is between 1 or 2 times as\n        // long as the underlying iterator.\n        (low + ext, high.and_then(|n| n.checked_mul(2)).and_then(|n| n.checked_add(ext)))\n    }\n}\n\nimpl Hash for CodePoint {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.value.hash(state)\n    }\n}\n\nimpl Hash for Wtf8Buf {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        state.write(&self.bytes);\n        0xfeu8.hash(state)\n    }\n}\n\nimpl Hash for Wtf8 {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        state.write(&self.bytes);\n        0xfeu8.hash(state)\n    }\n}\n"],["2570","use super::*;\nuse crate::fmt::{Debug, Formatter, Result};\n\n#[test]\nfn smoke() {\n    struct Helper<'a>(&'a [u8]);\n\n    impl Debug for Helper<'_> {\n        fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n            debug_fmt_bytestring(self.0, f)\n        }\n    }\n\n    let input = b\"\\xF0hello,\\tworld\";\n    let expected = r#\"\"\\xF0hello,\\tworld\"\"#;\n    let output = format!(\"{:?}\", Helper(input));\n\n    assert!(output == expected);\n}\n"],["2571","#![allow(dead_code)]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::fmt::{Formatter, Result, Write};\nuse core::str::lossy::{Utf8Lossy, Utf8LossyChunk};\n\npub fn debug_fmt_bytestring(slice: &[u8], f: &mut Formatter<'_>) -> Result {\n    // Writes out a valid unicode string with the correct escape sequences\n    fn write_str_escaped(f: &mut Formatter<'_>, s: &str) -> Result {\n        for c in s.chars().flat_map(|c| c.escape_debug()) {\n            f.write_char(c)?\n        }\n        Ok(())\n    }\n\n    f.write_str(\"\\\"\")?;\n    for Utf8LossyChunk { valid, broken } in Utf8Lossy::from_bytes(slice).chunks() {\n        write_str_escaped(f, valid)?;\n        for b in broken {\n            write!(f, \"\\\\x{:02X}\", b)?;\n        }\n    }\n    f.write_str(\"\\\"\")\n}\n"],["2572","use crate::sync::atomic::AtomicI32;\nuse crate::sync::atomic::Ordering::{Acquire, Release};\nuse crate::sys::futex::{futex_wait, futex_wake};\nuse crate::time::Duration;\n\nconst PARKED: i32 = -1;\nconst EMPTY: i32 = 0;\nconst NOTIFIED: i32 = 1;\n\npub struct Parker {\n    state: AtomicI32,\n}\n\n// Notes about memory ordering:\n//\n// Memory ordering is only relevant for the relative ordering of operations\n// between different variables. Even Ordering::Relaxed guarantees a\n// monotonic/consistent order when looking at just a single atomic variable.\n//\n// So, since this parker is just a single atomic variable, we only need to look\n// at the ordering guarantees we need to provide to the 'outside world'.\n//\n// The only memory ordering guarantee that parking and unparking provide, is\n// that things which happened before unpark() are visible on the thread\n// returning from park() afterwards. Otherwise, it was effectively unparked\n// before unpark() was called while still consuming the 'token'.\n//\n// In other words, unpark() needs to synchronize with the part of park() that\n// consumes the token and returns.\n//\n// This is done with a release-acquire synchronization, by using\n// Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using\n// Ordering::Acquire when checking for this state in park().\nimpl Parker {\n    #[inline]\n    pub const fn new() -> Self {\n        Parker { state: AtomicI32::new(EMPTY) }\n    }\n\n    // Assumes this is only called by the thread that owns the Parker,\n    // which means that `self.state != PARKED`.\n    pub unsafe fn park(&self) {\n        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n        // first case.\n        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n            return;\n        }\n        loop {\n            // Wait for something to happen, assuming it's still set to PARKED.\n            futex_wait(&self.state, PARKED, None);\n            // Change NOTIFIED=>EMPTY and return in that case.\n            if self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Acquire).is_ok() {\n                return;\n            } else {\n                // Spurious wake up. We loop to try again.\n            }\n        }\n    }\n\n    // Assumes this is only called by the thread that owns the Parker,\n    // which means that `self.state != PARKED`.\n    pub unsafe fn park_timeout(&self, timeout: Duration) {\n        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n        // first case.\n        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n            return;\n        }\n        // Wait for something to happen, assuming it's still set to PARKED.\n        futex_wait(&self.state, PARKED, Some(timeout));\n        // This is not just a store, because we need to establish a\n        // release-acquire ordering with unpark().\n        if self.state.swap(EMPTY, Acquire) == NOTIFIED {\n            // Woke up because of unpark().\n        } else {\n            // Timeout or spurious wake up.\n            // We return either way, because we can't easily tell if it was the\n            // timeout or not.\n        }\n    }\n\n    #[inline]\n    pub fn unpark(&self) {\n        // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n        // wake the thread in the first case.\n        //\n        // Note that even NOTIFIED=>NOTIFIED results in a write. This is on\n        // purpose, to make sure every unpark() has a release-acquire ordering\n        // with park().\n        if self.state.swap(NOTIFIED, Release) == PARKED {\n            futex_wake(&self.state);\n        }\n    }\n}\n"],["2573","cfg_if::cfg_if! {\n    if #[cfg(any(\n        target_os = \"linux\",\n        target_os = \"android\",\n        all(target_arch = \"wasm32\", target_feature = \"atomics\"),\n    ))] {\n        mod futex;\n        pub use futex::Parker;\n    } else if #[cfg(windows)] {\n        pub use crate::sys::thread_parker::Parker;\n    } else {\n        mod generic;\n        pub use generic::Parker;\n    }\n}\n"],["2574","//! Parker implementaiton based on a Mutex and Condvar.\n\nuse crate::sync::atomic::AtomicUsize;\nuse crate::sync::atomic::Ordering::SeqCst;\nuse crate::sync::{Condvar, Mutex};\nuse crate::time::Duration;\n\nconst EMPTY: usize = 0;\nconst PARKED: usize = 1;\nconst NOTIFIED: usize = 2;\n\npub struct Parker {\n    state: AtomicUsize,\n    lock: Mutex<()>,\n    cvar: Condvar,\n}\n\nimpl Parker {\n    pub fn new() -> Self {\n        Parker { state: AtomicUsize::new(EMPTY), lock: Mutex::new(()), cvar: Condvar::new() }\n    }\n\n    // This implementaiton doesn't require `unsafe`, but other implementations\n    // may assume this is only called by the thread that owns the Parker.\n    pub unsafe fn park(&self) {\n        // If we were previously notified then we consume this notification and\n        // return quickly.\n        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n            return;\n        }\n\n        // Otherwise we need to coordinate going to sleep\n        let mut m = self.lock.lock().unwrap();\n        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n            Ok(_) => {}\n            Err(NOTIFIED) => {\n                // We must read here, even though we know it will be `NOTIFIED`.\n                // This is because `unpark` may have been called again since we read\n                // `NOTIFIED` in the `compare_exchange` above. We must perform an\n                // acquire operation that synchronizes with that `unpark` to observe\n                // any writes it made before the call to unpark. To do that we must\n                // read from the write it made to `state`.\n                let old = self.state.swap(EMPTY, SeqCst);\n                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n                return;\n            } // should consume this notification, so prohibit spurious wakeups in next park.\n            Err(_) => panic!(\"inconsistent park state\"),\n        }\n        loop {\n            m = self.cvar.wait(m).unwrap();\n            match self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n                Ok(_) => return, // got a notification\n                Err(_) => {}     // spurious wakeup, go back to sleep\n            }\n        }\n    }\n\n    // This implementaiton doesn't require `unsafe`, but other implementations\n    // may assume this is only called by the thread that owns the Parker.\n    pub unsafe fn park_timeout(&self, dur: Duration) {\n        // Like `park` above we have a fast path for an already-notified thread, and\n        // afterwards we start coordinating for a sleep.\n        // return quickly.\n        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n            return;\n        }\n        let m = self.lock.lock().unwrap();\n        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n            Ok(_) => {}\n            Err(NOTIFIED) => {\n                // We must read again here, see `park`.\n                let old = self.state.swap(EMPTY, SeqCst);\n                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n                return;\n            } // should consume this notification, so prohibit spurious wakeups in next park.\n            Err(_) => panic!(\"inconsistent park_timeout state\"),\n        }\n\n        // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n        // from a notification we just want to unconditionally set the state back to\n        // empty, either consuming a notification or un-flagging ourselves as\n        // parked.\n        let (_m, _result) = self.cvar.wait_timeout(m, dur).unwrap();\n        match self.state.swap(EMPTY, SeqCst) {\n            NOTIFIED => {} // got a notification, hurray!\n            PARKED => {}   // no notification, alas\n            n => panic!(\"inconsistent park_timeout state: {}\", n),\n        }\n    }\n\n    pub fn unpark(&self) {\n        // To ensure the unparked thread will observe any writes we made\n        // before this call, we must perform a release operation that `park`\n        // can synchronize with. To do that we must write `NOTIFIED` even if\n        // `state` is already `NOTIFIED`. That is why this must be a swap\n        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n        // on failure.\n        match self.state.swap(NOTIFIED, SeqCst) {\n            EMPTY => return,    // no one was waiting\n            NOTIFIED => return, // already unparked\n            PARKED => {}        // gotta go wake someone up\n            _ => panic!(\"inconsistent state in unpark\"),\n        }\n\n        // There is a period between when the parked thread sets `state` to\n        // `PARKED` (or last checked `state` in the case of a spurious wake\n        // up) and when it actually waits on `cvar`. If we were to notify\n        // during this period it would be ignored and then when the parked\n        // thread went to sleep it would never wake up. Fortunately, it has\n        // `lock` locked at this stage so we can acquire `lock` to wait until\n        // it is ready to receive the notification.\n        //\n        // Releasing `lock` before the call to `notify_one` means that when the\n        // parked thread wakes it doesn't get woken only to have to wait for us\n        // to release `lock`.\n        drop(self.lock.lock().unwrap());\n        self.cvar.notify_one()\n    }\n}\n"],["2575","use crate::cell::RefCell;\nuse crate::collections::HashMap;\nuse crate::thread_local;\n\n#[test]\nfn smoke() {\n    fn square(i: i32) -> i32 {\n        i * i\n    }\n    thread_local!(static FOO: i32 = square(3));\n\n    FOO.with(|f| {\n        assert_eq!(*f, 9);\n    });\n}\n\n#[test]\nfn hashmap() {\n    fn map() -> RefCell<HashMap<i32, i32>> {\n        let mut m = HashMap::new();\n        m.insert(1, 2);\n        RefCell::new(m)\n    }\n    thread_local!(static FOO: RefCell<HashMap<i32, i32>> = map());\n\n    FOO.with(|map| {\n        assert_eq!(map.borrow()[&1], 2);\n    });\n}\n\n#[test]\nfn refcell_vec() {\n    thread_local!(static FOO: RefCell<Vec<u32>> = RefCell::new(vec![1, 2, 3]));\n\n    FOO.with(|vec| {\n        assert_eq!(vec.borrow().len(), 3);\n        vec.borrow_mut().push(4);\n        assert_eq!(vec.borrow()[3], 4);\n    });\n}\n"],["2576","use crate::cell::{Cell, UnsafeCell};\nuse crate::sync::atomic::{AtomicU8, Ordering};\nuse crate::sync::mpsc::{channel, Sender};\nuse crate::thread::{self, LocalKey};\nuse crate::thread_local;\n\nstruct Foo(Sender<()>);\n\nimpl Drop for Foo {\n    fn drop(&mut self) {\n        let Foo(ref s) = *self;\n        s.send(()).unwrap();\n    }\n}\n\n#[test]\nfn smoke_no_dtor() {\n    thread_local!(static FOO: Cell<i32> = Cell::new(1));\n    run(&FOO);\n    thread_local!(static FOO2: Cell<i32> = const { Cell::new(1) });\n    run(&FOO2);\n\n    fn run(key: &'static LocalKey<Cell<i32>>) {\n        key.with(|f| {\n            assert_eq!(f.get(), 1);\n            f.set(2);\n        });\n        let t = thread::spawn(move || {\n            key.with(|f| {\n                assert_eq!(f.get(), 1);\n            });\n        });\n        t.join().unwrap();\n\n        key.with(|f| {\n            assert_eq!(f.get(), 2);\n        });\n    }\n}\n\n#[test]\nfn states() {\n    struct Foo(&'static LocalKey<Foo>);\n    impl Drop for Foo {\n        fn drop(&mut self) {\n            assert!(self.0.try_with(|_| ()).is_err());\n        }\n    }\n\n    thread_local!(static FOO: Foo = Foo(&FOO));\n    run(&FOO);\n    thread_local!(static FOO2: Foo = const { Foo(&FOO2) });\n    run(&FOO2);\n\n    fn run(foo: &'static LocalKey<Foo>) {\n        thread::spawn(move || {\n            assert!(foo.try_with(|_| ()).is_ok());\n        })\n        .join()\n        .unwrap();\n    }\n}\n\n#[test]\nfn smoke_dtor() {\n    thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n    run(&FOO);\n    thread_local!(static FOO2: UnsafeCell<Option<Foo>> = const { UnsafeCell::new(None) });\n    run(&FOO2);\n\n    fn run(key: &'static LocalKey<UnsafeCell<Option<Foo>>>) {\n        let (tx, rx) = channel();\n        let t = thread::spawn(move || unsafe {\n            let mut tx = Some(tx);\n            key.with(|f| {\n                *f.get() = Some(Foo(tx.take().unwrap()));\n            });\n        });\n        rx.recv().unwrap();\n        t.join().unwrap();\n    }\n}\n\n#[test]\nfn circular() {\n    struct S1(&'static LocalKey<UnsafeCell<Option<S1>>>, &'static LocalKey<UnsafeCell<Option<S2>>>);\n    struct S2(&'static LocalKey<UnsafeCell<Option<S1>>>, &'static LocalKey<UnsafeCell<Option<S2>>>);\n    thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n    thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell::new(None));\n    thread_local!(static K3: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n    thread_local!(static K4: UnsafeCell<Option<S2>> = const { UnsafeCell::new(None) });\n    static mut HITS: usize = 0;\n\n    impl Drop for S1 {\n        fn drop(&mut self) {\n            unsafe {\n                HITS += 1;\n                if self.1.try_with(|_| ()).is_err() {\n                    assert_eq!(HITS, 3);\n                } else {\n                    if HITS == 1 {\n                        self.1.with(|s| *s.get() = Some(S2(self.0, self.1)));\n                    } else {\n                        assert_eq!(HITS, 3);\n                    }\n                }\n            }\n        }\n    }\n    impl Drop for S2 {\n        fn drop(&mut self) {\n            unsafe {\n                HITS += 1;\n                assert!(self.0.try_with(|_| ()).is_ok());\n                assert_eq!(HITS, 2);\n                self.0.with(|s| *s.get() = Some(S1(self.0, self.1)));\n            }\n        }\n    }\n\n    thread::spawn(move || {\n        drop(S1(&K1, &K2));\n    })\n    .join()\n    .unwrap();\n\n    unsafe {\n        HITS = 0;\n    }\n\n    thread::spawn(move || {\n        drop(S1(&K3, &K4));\n    })\n    .join()\n    .unwrap();\n}\n\n#[test]\nfn self_referential() {\n    struct S1(&'static LocalKey<UnsafeCell<Option<S1>>>);\n\n    thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n    thread_local!(static K2: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n\n    impl Drop for S1 {\n        fn drop(&mut self) {\n            assert!(self.0.try_with(|_| ()).is_err());\n        }\n    }\n\n    thread::spawn(move || unsafe {\n        K1.with(|s| *s.get() = Some(S1(&K1)));\n    })\n    .join()\n    .unwrap();\n\n    thread::spawn(move || unsafe {\n        K2.with(|s| *s.get() = Some(S1(&K2)));\n    })\n    .join()\n    .unwrap();\n}\n\n// Note that this test will deadlock if TLS destructors aren't run (this\n// requires the destructor to be run to pass the test).\n#[test]\nfn dtors_in_dtors_in_dtors() {\n    struct S1(Sender<()>);\n    thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n    thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n\n    impl Drop for S1 {\n        fn drop(&mut self) {\n            let S1(ref tx) = *self;\n            unsafe {\n                let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n            }\n        }\n    }\n\n    let (tx, rx) = channel();\n    let _t = thread::spawn(move || unsafe {\n        let mut tx = Some(tx);\n        K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n    });\n    rx.recv().unwrap();\n}\n\n#[test]\nfn dtors_in_dtors_in_dtors_const_init() {\n    struct S1(Sender<()>);\n    thread_local!(static K1: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n    thread_local!(static K2: UnsafeCell<Option<Foo>> = const { UnsafeCell::new(None) });\n\n    impl Drop for S1 {\n        fn drop(&mut self) {\n            let S1(ref tx) = *self;\n            unsafe {\n                let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n            }\n        }\n    }\n\n    let (tx, rx) = channel();\n    let _t = thread::spawn(move || unsafe {\n        let mut tx = Some(tx);\n        K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n    });\n    rx.recv().unwrap();\n}\n\n// This test tests that TLS destructors have run before the thread joins. The\n// test has no false positives (meaning: if the test fails, there's actually\n// an ordering problem). It may have false negatives, where the test passes but\n// join is not guaranteed to be after the TLS destructors. However, false\n// negatives should be exceedingly rare due to judicious use of\n// thread::yield_now and running the test several times.\n#[test]\nfn join_orders_after_tls_destructors() {\n    // We emulate a synchronous MPSC rendezvous channel using only atomics and\n    // thread::yield_now. We can't use std::mpsc as the implementation itself\n    // may rely on thread locals.\n    //\n    // The basic state machine for an SPSC rendezvous channel is:\n    //           FRESH -> THREAD1_WAITING -> MAIN_THREAD_RENDEZVOUS\n    // where the first transition is done by the “receiving” thread and the 2nd\n    // transition is done by the “sending” thread.\n    //\n    // We add an additional state `THREAD2_LAUNCHED` between `FRESH` and\n    // `THREAD1_WAITING` to block until all threads are actually running.\n    //\n    // A thread that joins on the “receiving” thread completion should never\n    // observe the channel in the `THREAD1_WAITING` state. If this does occur,\n    // we switch to the “poison” state `THREAD2_JOINED` and panic all around.\n    // (This is equivalent to “sending” from an alternate producer thread.)\n    const FRESH: u8 = 0;\n    const THREAD2_LAUNCHED: u8 = 1;\n    const THREAD1_WAITING: u8 = 2;\n    const MAIN_THREAD_RENDEZVOUS: u8 = 3;\n    const THREAD2_JOINED: u8 = 4;\n    static SYNC_STATE: AtomicU8 = AtomicU8::new(FRESH);\n\n    for _ in 0..10 {\n        SYNC_STATE.store(FRESH, Ordering::SeqCst);\n\n        let jh = thread::Builder::new()\n            .name(\"thread1\".into())\n            .spawn(move || {\n                struct TlDrop;\n\n                impl Drop for TlDrop {\n                    fn drop(&mut self) {\n                        let mut sync_state = SYNC_STATE.swap(THREAD1_WAITING, Ordering::SeqCst);\n                        loop {\n                            match sync_state {\n                                THREAD2_LAUNCHED | THREAD1_WAITING => thread::yield_now(),\n                                MAIN_THREAD_RENDEZVOUS => break,\n                                THREAD2_JOINED => panic!(\n                                    \"Thread 1 still running after thread 2 joined on thread 1\"\n                                ),\n                                v => unreachable!(\"sync state: {}\", v),\n                            }\n                            sync_state = SYNC_STATE.load(Ordering::SeqCst);\n                        }\n                    }\n                }\n\n                thread_local! {\n                    static TL_DROP: TlDrop = TlDrop;\n                }\n\n                TL_DROP.with(|_| {});\n\n                loop {\n                    match SYNC_STATE.load(Ordering::SeqCst) {\n                        FRESH => thread::yield_now(),\n                        THREAD2_LAUNCHED => break,\n                        v => unreachable!(\"sync state: {}\", v),\n                    }\n                }\n            })\n            .unwrap();\n\n        let jh2 = thread::Builder::new()\n            .name(\"thread2\".into())\n            .spawn(move || {\n                assert_eq!(SYNC_STATE.swap(THREAD2_LAUNCHED, Ordering::SeqCst), FRESH);\n                jh.join().unwrap();\n                match SYNC_STATE.swap(THREAD2_JOINED, Ordering::SeqCst) {\n                    MAIN_THREAD_RENDEZVOUS => return,\n                    THREAD2_LAUNCHED | THREAD1_WAITING => {\n                        panic!(\"Thread 2 running after thread 1 join before main thread rendezvous\")\n                    }\n                    v => unreachable!(\"sync state: {:?}\", v),\n                }\n            })\n            .unwrap();\n\n        loop {\n            match SYNC_STATE.compare_exchange(\n                THREAD1_WAITING,\n                MAIN_THREAD_RENDEZVOUS,\n                Ordering::SeqCst,\n                Ordering::SeqCst,\n            ) {\n                Ok(_) => break,\n                Err(FRESH) => thread::yield_now(),\n                Err(THREAD2_LAUNCHED) => thread::yield_now(),\n                Err(THREAD2_JOINED) => {\n                    panic!(\"Main thread rendezvous after thread 2 joined thread 1\")\n                }\n                v => unreachable!(\"sync state: {:?}\", v),\n            }\n        }\n        jh2.join().unwrap();\n    }\n}\n"],["2577","//! Thread local storage\n\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\n#[cfg(test)]\nmod dynamic_tests;\n\nuse crate::error::Error;\nuse crate::fmt;\n\n/// A thread local storage key which owns its contents.\n///\n/// This key uses the fastest possible implementation available to it for the\n/// target platform. It is instantiated with the [`thread_local!`] macro and the\n/// primary method is the [`with`] method.\n///\n/// The [`with`] method yields a reference to the contained value which cannot be\n/// sent across threads or escape the given closure.\n///\n/// # Initialization and Destruction\n///\n/// Initialization is dynamically performed on the first call to [`with`]\n/// within a thread, and values that implement [`Drop`] get destructed when a\n/// thread exits. Some caveats apply, which are explained below.\n///\n/// A `LocalKey`'s initializer cannot recursively depend on itself, and using\n/// a `LocalKey` in this way will cause the initializer to infinitely recurse\n/// on the first call to `with`.\n///\n/// # Examples\n///\n/// ```\n/// use std::cell::RefCell;\n/// use std::thread;\n///\n/// thread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n///\n/// FOO.with(|f| {\n///     assert_eq!(*f.borrow(), 1);\n///     *f.borrow_mut() = 2;\n/// });\n///\n/// // each thread starts out with the initial value of 1\n/// let t = thread::spawn(move|| {\n///     FOO.with(|f| {\n///         assert_eq!(*f.borrow(), 1);\n///         *f.borrow_mut() = 3;\n///     });\n/// });\n///\n/// // wait for the thread to complete and bail out on panic\n/// t.join().unwrap();\n///\n/// // we retain our original value of 2 despite the child thread\n/// FOO.with(|f| {\n///     assert_eq!(*f.borrow(), 2);\n/// });\n/// ```\n///\n/// # Platform-specific behavior\n///\n/// Note that a \"best effort\" is made to ensure that destructors for types\n/// stored in thread local storage are run, but not all platforms can guarantee\n/// that destructors will be run for all types in thread local storage. For\n/// example, there are a number of known caveats where destructors are not run:\n///\n/// 1. On Unix systems when pthread-based TLS is being used, destructors will\n///    not be run for TLS values on the main thread when it exits. Note that the\n///    application will exit immediately after the main thread exits as well.\n/// 2. On all platforms it's possible for TLS to re-initialize other TLS slots\n///    during destruction. Some platforms ensure that this cannot happen\n///    infinitely by preventing re-initialization of any slot that has been\n///    destroyed, but not all platforms have this guard. Those platforms that do\n///    not guard typically have a synthetic limit after which point no more\n///    destructors are run.\n///\n/// [`with`]: LocalKey::with\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LocalKey<T: 'static> {\n    // This outer `LocalKey<T>` type is what's going to be stored in statics,\n    // but actual data inside will sometimes be tagged with #[thread_local].\n    // It's not valid for a true static to reference a #[thread_local] static,\n    // so we get around that by exposing an accessor through a layer of function\n    // indirection (this thunk).\n    //\n    // Note that the thunk is itself unsafe because the returned lifetime of the\n    // slot where data lives, `'static`, is not actually valid. The lifetime\n    // here is actually slightly shorter than the currently running thread!\n    //\n    // Although this is an extra layer of indirection, it should in theory be\n    // trivially devirtualizable by LLVM because the value of `inner` never\n    // changes and the constant should be readonly within a crate. This mainly\n    // only runs into problems when TLS statics are exported across crates.\n    inner: unsafe fn() -> Option<&'static T>,\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: 'static> fmt::Debug for LocalKey<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"LocalKey\").finish_non_exhaustive()\n    }\n}\n\n/// Declare a new thread local storage key of type [`std::thread::LocalKey`].\n///\n/// # Syntax\n///\n/// The macro wraps any number of static declarations and makes them thread local.\n/// Publicity and attributes for each static are allowed. Example:\n///\n/// ```\n/// use std::cell::RefCell;\n/// thread_local! {\n///     pub static FOO: RefCell<u32> = RefCell::new(1);\n///\n///     #[allow(unused)]\n///     static BAR: RefCell<f32> = RefCell::new(1.0);\n/// }\n/// # fn main() {}\n/// ```\n///\n/// See [`LocalKey` documentation][`std::thread::LocalKey`] for more\n/// information.\n///\n/// [`std::thread::LocalKey`]: crate::thread::LocalKey\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(thread_local_internals)]\nmacro_rules! thread_local {\n    // empty (base case for the recursion)\n    () => {};\n\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }; $($rest:tt)*) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n        $crate::thread_local!($($rest)*);\n    );\n\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n    );\n\n    // process multiple declarations\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n        $crate::thread_local!($($rest)*);\n    );\n\n    // handle a single declaration\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n    );\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n#[macro_export]\n#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n#[allow_internal_unsafe]\nmacro_rules! __thread_local_inner {\n    // used to generate the `LocalKey` value for const-initialized thread locals\n    (@key $t:ty, const $init:expr) => {{\n        #[cfg_attr(not(windows), inline)] // see comments below\n        unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n            const _REQUIRE_UNSTABLE: () = $crate::thread::require_unstable_const_init_thread_local();\n\n            // wasm without atomics maps directly to `static mut`, and dtors\n            // aren't implemented because thread dtors aren't really a thing\n            // on wasm right now\n            //\n            // FIXME(#84224) this should come after the `target_thread_local`\n            // block.\n            #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n            {\n                static mut VAL: $t = $init;\n                Some(&VAL)\n            }\n\n            // If the platform has support for `#[thread_local]`, use it.\n            #[cfg(all(\n                target_thread_local,\n                not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n            ))]\n            {\n                // If a dtor isn't needed we can do something \"very raw\" and\n                // just get going.\n                if !$crate::mem::needs_drop::<$t>() {\n                    #[thread_local]\n                    static mut VAL: $t = $init;\n                    unsafe {\n                        return Some(&VAL)\n                    }\n                }\n\n                #[thread_local]\n                static mut VAL: $t = $init;\n                // 0 == dtor not registered\n                // 1 == dtor registered, dtor not run\n                // 2 == dtor registered and is running or has run\n                #[thread_local]\n                static mut STATE: u8 = 0;\n\n                unsafe extern \"C\" fn destroy(ptr: *mut u8) {\n                    let ptr = ptr as *mut $t;\n\n                    unsafe {\n                        debug_assert_eq!(STATE, 1);\n                        STATE = 2;\n                        $crate::ptr::drop_in_place(ptr);\n                    }\n                }\n\n                unsafe {\n                    match STATE {\n                        // 0 == we haven't registered a destructor, so do\n                        //   so now.\n                        0 => {\n                            $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n                                $crate::ptr::addr_of_mut!(VAL) as *mut u8,\n                                destroy,\n                            );\n                            STATE = 1;\n                            Some(&VAL)\n                        }\n                        // 1 == the destructor is registered and the value\n                        //   is valid, so return the pointer.\n                        1 => Some(&VAL),\n                        // otherwise the destructor has already run, so we\n                        // can't give access.\n                        _ => None,\n                    }\n                }\n            }\n\n            // On platforms without `#[thread_local]` we fall back to the\n            // same implementation as below for os thread locals.\n            #[cfg(all(\n                not(target_thread_local),\n                not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n            ))]\n            {\n                #[inline]\n                const fn __init() -> $t { $init }\n                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                    $crate::thread::__OsLocalKeyInner::new();\n                #[allow(unused_unsafe)]\n                unsafe { __KEY.get(__init) }\n            }\n        }\n\n        unsafe {\n            $crate::thread::LocalKey::new(__getit)\n        }\n    }};\n\n    // used to generate the `LocalKey` value for `thread_local!`\n    (@key $t:ty, $init:expr) => {\n        {\n            #[inline]\n            fn __init() -> $t { $init }\n\n            // When reading this function you might ask \"why is this inlined\n            // everywhere other than Windows?\", and that's a very reasonable\n            // question to ask. The short story is that it segfaults rustc if\n            // this function is inlined. The longer story is that Windows looks\n            // to not support `extern` references to thread locals across DLL\n            // boundaries. This appears to at least not be supported in the ABI\n            // that LLVM implements.\n            //\n            // Because of this we never inline on Windows, but we do inline on\n            // other platforms (where external references to thread locals\n            // across DLLs are supported). A better fix for this would be to\n            // inline this function on Windows, but only for \"statically linked\"\n            // components. For example if two separately compiled rlibs end up\n            // getting linked into a DLL then it's fine to inline this function\n            // across that boundary. It's only not fine to inline this function\n            // across a DLL boundary. Unfortunately rustc doesn't currently\n            // have this sort of logic available in an attribute, and it's not\n            // clear that rustc is even equipped to answer this (it's more of a\n            // Cargo question kinda). This means that, unfortunately, Windows\n            // gets the pessimistic path for now where it's never inlined.\n            //\n            // The issue of \"should enable on Windows sometimes\" is #84933\n            #[cfg_attr(not(windows), inline)]\n            unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n                #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                    $crate::thread::__StaticLocalKeyInner::new();\n\n                #[thread_local]\n                #[cfg(all(\n                    target_thread_local,\n                    not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                    $crate::thread::__FastLocalKeyInner::new();\n\n                #[cfg(all(\n                    not(target_thread_local),\n                    not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                    $crate::thread::__OsLocalKeyInner::new();\n\n                // FIXME: remove the #[allow(...)] marker when macros don't\n                // raise warning for missing/extraneous unsafe blocks anymore.\n                // See https://github.com/rust-lang/rust/issues/74838.\n                #[allow(unused_unsafe)]\n                unsafe { __KEY.get(__init) }\n            }\n\n            unsafe {\n                $crate::thread::LocalKey::new(__getit)\n            }\n        }\n    };\n    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n            $crate::__thread_local_inner!(@key $t, $($init)*);\n    }\n}\n\n/// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n#[non_exhaustive]\n#[derive(Clone, Copy, Eq, PartialEq)]\npub struct AccessError;\n\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\nimpl fmt::Debug for AccessError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"AccessError\").finish()\n    }\n}\n\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\nimpl fmt::Display for AccessError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(\"already destroyed\", f)\n    }\n}\n\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\nimpl Error for AccessError {}\n\nimpl<T: 'static> LocalKey<T> {\n    #[doc(hidden)]\n    #[unstable(\n        feature = \"thread_local_internals\",\n        reason = \"recently added to create a key\",\n        issue = \"none\"\n    )]\n    #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static T>) -> LocalKey<T> {\n        LocalKey { inner }\n    }\n\n    /// Acquires a reference to the value in this TLS key.\n    ///\n    /// This will lazily initialize the value if this thread has not referenced\n    /// this key yet.\n    ///\n    /// # Panics\n    ///\n    /// This function will `panic!()` if the key currently has its\n    /// destructor running, and it **may** panic if the destructor has\n    /// previously been run for this thread.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with<F, R>(&'static self, f: F) -> R\n    where\n        F: FnOnce(&T) -> R,\n    {\n        self.try_with(f).expect(\n            \"cannot access a Thread Local Storage value \\\n             during or after destruction\",\n        )\n    }\n\n    /// Acquires a reference to the value in this TLS key.\n    ///\n    /// This will lazily initialize the value if this thread has not referenced\n    /// this key yet. If the key has been destroyed (which may happen if this is called\n    /// in a destructor), this function will return an [`AccessError`].\n    ///\n    /// # Panics\n    ///\n    /// This function will still `panic!()` if the key is uninitialized and the\n    /// key's initializer panics.\n    #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n    #[inline]\n    pub fn try_with<F, R>(&'static self, f: F) -> Result<R, AccessError>\n    where\n        F: FnOnce(&T) -> R,\n    {\n        unsafe {\n            let thread_local = (self.inner)().ok_or(AccessError)?;\n            Ok(f(thread_local))\n        }\n    }\n}\n\nmod lazy {\n    use crate::cell::UnsafeCell;\n    use crate::hint;\n    use crate::mem;\n\n    pub struct LazyKeyInner<T> {\n        inner: UnsafeCell<Option<T>>,\n    }\n\n    impl<T> LazyKeyInner<T> {\n        pub const fn new() -> LazyKeyInner<T> {\n            LazyKeyInner { inner: UnsafeCell::new(None) }\n        }\n\n        pub unsafe fn get(&self) -> Option<&'static T> {\n            // SAFETY: The caller must ensure no reference is ever handed out to\n            // the inner cell nor mutable reference to the Option<T> inside said\n            // cell. This make it safe to hand a reference, though the lifetime\n            // of 'static is itself unsafe, making the get method unsafe.\n            unsafe { (*self.inner.get()).as_ref() }\n        }\n\n        /// The caller must ensure that no reference is active: this method\n        /// needs unique access.\n        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n            // Execute the initialization up front, *then* move it into our slot,\n            // just in case initialization fails.\n            let value = init();\n            let ptr = self.inner.get();\n\n            // SAFETY:\n            //\n            // note that this can in theory just be `*ptr = Some(value)`, but due to\n            // the compiler will currently codegen that pattern with something like:\n            //\n            //      ptr::drop_in_place(ptr)\n            //      ptr::write(ptr, Some(value))\n            //\n            // Due to this pattern it's possible for the destructor of the value in\n            // `ptr` (e.g., if this is being recursively initialized) to re-access\n            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n            // value (an aliasing violation). To avoid setting the \"I'm running a\n            // destructor\" flag we just use `mem::replace` which should sequence the\n            // operations a little differently and make this safe to call.\n            //\n            // The precondition also ensures that we are the only one accessing\n            // `self` at the moment so replacing is fine.\n            unsafe {\n                let _ = mem::replace(&mut *ptr, Some(value));\n            }\n\n            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n            // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n            // will never be reached.\n            unsafe {\n                // After storing `Some` we want to get a reference to the contents of\n                // what we just stored. While we could use `unwrap` here and it should\n                // always work it empirically doesn't seem to always get optimized away,\n                // which means that using something like `try_with` can pull in\n                // panicking code and cause a large size bloat.\n                match *ptr {\n                    Some(ref x) => x,\n                    None => hint::unreachable_unchecked(),\n                }\n            }\n        }\n\n        /// The other methods hand out references while taking &self.\n        /// As such, callers of this method must ensure no `&` and `&mut` are\n        /// available and used at the same time.\n        #[allow(unused)]\n        pub unsafe fn take(&mut self) -> Option<T> {\n            // SAFETY: See doc comment for this method.\n            unsafe { (*self.inner.get()).take() }\n        }\n    }\n}\n\n/// On some platforms like wasm32 there's no threads, so no need to generate\n/// thread locals and we can instead just use plain statics!\n#[doc(hidden)]\n#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\npub mod statik {\n    use super::lazy::LazyKeyInner;\n    use crate::fmt;\n\n    pub struct Key<T> {\n        inner: LazyKeyInner<T>,\n    }\n\n    unsafe impl<T> Sync for Key<T> {}\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"Key\").finish_non_exhaustive()\n        }\n    }\n\n    impl<T> Key<T> {\n        pub const fn new() -> Key<T> {\n            Key { inner: LazyKeyInner::new() }\n        }\n\n        pub unsafe fn get(&self, init: fn() -> T) -> Option<&'static T> {\n            // SAFETY: The caller must ensure no reference is ever handed out to\n            // the inner cell nor mutable reference to the Option<T> inside said\n            // cell. This make it safe to hand a reference, though the lifetime\n            // of 'static is itself unsafe, making the get method unsafe.\n            let value = unsafe {\n                match self.inner.get() {\n                    Some(ref value) => value,\n                    None => self.inner.initialize(init),\n                }\n            };\n\n            Some(value)\n        }\n    }\n}\n\n#[doc(hidden)]\n#[cfg(target_thread_local)]\npub mod fast {\n    use super::lazy::LazyKeyInner;\n    use crate::cell::Cell;\n    use crate::fmt;\n    use crate::mem;\n    use crate::sys::thread_local_dtor::register_dtor;\n\n    #[derive(Copy, Clone)]\n    enum DtorState {\n        Unregistered,\n        Registered,\n        RunningOrHasRun,\n    }\n\n    // This data structure has been carefully constructed so that the fast path\n    // only contains one branch on x86. That optimization is necessary to avoid\n    // duplicated tls lookups on OSX.\n    //\n    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n    pub struct Key<T> {\n        // If `LazyKeyInner::get` returns `None`, that indicates either:\n        //   * The value has never been initialized\n        //   * The value is being recursively initialized\n        //   * The value has already been destroyed or is being destroyed\n        // To determine which kind of `None`, check `dtor_state`.\n        //\n        // This is very optimizer friendly for the fast path - initialized but\n        // not yet dropped.\n        inner: LazyKeyInner<T>,\n\n        // Metadata to keep track of the state of the destructor. Remember that\n        // this variable is thread-local, not global.\n        dtor_state: Cell<DtorState>,\n    }\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"Key\").finish_non_exhaustive()\n        }\n    }\n\n    impl<T> Key<T> {\n        pub const fn new() -> Key<T> {\n            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n        }\n\n        // note that this is just a publically-callable function only for the\n        // const-initialized form of thread locals, basically a way to call the\n        // free `register_dtor` function defined elsewhere in libstd.\n        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n            unsafe {\n                register_dtor(a, dtor);\n            }\n        }\n\n        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n            // SAFETY: See the definitions of `LazyKeyInner::get` and\n            // `try_initialize` for more informations.\n            //\n            // The caller must ensure no mutable references are ever active to\n            // the inner cell or the inner T when this is called.\n            // The `try_initialize` is dependant on the passed `init` function\n            // for this.\n            unsafe {\n                match self.inner.get() {\n                    Some(val) => Some(val),\n                    None => self.try_initialize(init),\n                }\n            }\n        }\n\n        // `try_initialize` is only called once per fast thread local variable,\n        // except in corner cases where thread_local dtors reference other\n        // thread_local's, or it is being recursively initialized.\n        //\n        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n        // be performed for every call to `Key::get`.\n        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n        #[inline(never)]\n        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n            // SAFETY: See comment above (this function doc).\n            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n                // SAFETY: See comment above (his function doc).\n                Some(unsafe { self.inner.initialize(init) })\n            } else {\n                None\n            }\n        }\n\n        // `try_register_dtor` is only called once per fast thread local\n        // variable, except in corner cases where thread_local dtors reference\n        // other thread_local's, or it is being recursively initialized.\n        unsafe fn try_register_dtor(&self) -> bool {\n            match self.dtor_state.get() {\n                DtorState::Unregistered => {\n                    // SAFETY: dtor registration happens before initialization.\n                    // Passing `self` as a pointer while using `destroy_value<T>`\n                    // is safe because the function will build a pointer to a\n                    // Key<T>, which is the type of self and so find the correct\n                    // size.\n                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n                    self.dtor_state.set(DtorState::Registered);\n                    true\n                }\n                DtorState::Registered => {\n                    // recursively initialized\n                    true\n                }\n                DtorState::RunningOrHasRun => false,\n            }\n        }\n    }\n\n    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n        let ptr = ptr as *mut Key<T>;\n\n        // SAFETY:\n        //\n        // The pointer `ptr` has been built just above and comes from\n        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n        // making it non-NUL and of the correct type.\n        //\n        // Right before we run the user destructor be sure to set the\n        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n        // causes future calls to `get` to run `try_initialize_drop` again,\n        // which will now fail, and return `None`.\n        unsafe {\n            let value = (*ptr).inner.take();\n            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n            drop(value);\n        }\n    }\n}\n\n#[doc(hidden)]\npub mod os {\n    use super::lazy::LazyKeyInner;\n    use crate::cell::Cell;\n    use crate::fmt;\n    use crate::marker;\n    use crate::ptr;\n    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n\n    pub struct Key<T> {\n        // OS-TLS key that we'll use to key off.\n        os: OsStaticKey,\n        marker: marker::PhantomData<Cell<T>>,\n    }\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"Key\").finish_non_exhaustive()\n        }\n    }\n\n    unsafe impl<T> Sync for Key<T> {}\n\n    struct Value<T: 'static> {\n        inner: LazyKeyInner<T>,\n        key: &'static Key<T>,\n    }\n\n    impl<T: 'static> Key<T> {\n        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n        pub const fn new() -> Key<T> {\n            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n        }\n\n        /// It is a requirement for the caller to ensure that no mutable\n        /// reference is active when this method is called.\n        pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n            // SAFETY: See the documentation for this method.\n            let ptr = unsafe { self.os.get() as *mut Value<T> };\n            if ptr as usize > 1 {\n                // SAFETY: the check ensured the pointer is safe (its destructor\n                // is not running) + it is coming from a trusted source (self).\n                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n                    return Some(value);\n                }\n            }\n            // SAFETY: At this point we are sure we have no value and so\n            // initializing (or trying to) is safe.\n            unsafe { self.try_initialize(init) }\n        }\n\n        // `try_initialize` is only called once per os thread local variable,\n        // except in corner cases where thread_local dtors reference other\n        // thread_local's, or it is being recursively initialized.\n        unsafe fn try_initialize(&'static self, init: fn() -> T) -> Option<&'static T> {\n            // SAFETY: No mutable references are ever handed out meaning getting\n            // the value is ok.\n            let ptr = unsafe { self.os.get() as *mut Value<T> };\n            if ptr as usize == 1 {\n                // destructor is running\n                return None;\n            }\n\n            let ptr = if ptr.is_null() {\n                // If the lookup returned null, we haven't initialized our own\n                // local copy, so do that now.\n                let ptr: Box<Value<T>> = box Value { inner: LazyKeyInner::new(), key: self };\n                let ptr = Box::into_raw(ptr);\n                // SAFETY: At this point we are sure there is no value inside\n                // ptr so setting it will not affect anyone else.\n                unsafe {\n                    self.os.set(ptr as *mut u8);\n                }\n                ptr\n            } else {\n                // recursive initialization\n                ptr\n            };\n\n            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n            // dereferenced safely.\n            unsafe { Some((*ptr).inner.initialize(init)) }\n        }\n    }\n\n    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n        // SAFETY:\n        //\n        // The OS TLS ensures that this key contains a null value when this\n        // destructor starts to run. We set it back to a sentinel value of 1 to\n        // ensure that any future calls to `get` for this thread will return\n        // `None`.\n        //\n        // Note that to prevent an infinite loop we reset it back to null right\n        // before we return from the destructor ourselves.\n        unsafe {\n            let ptr = Box::from_raw(ptr as *mut Value<T>);\n            let key = ptr.key;\n            key.os.set(1 as *mut u8);\n            drop(ptr);\n            key.os.set(ptr::null_mut());\n        }\n    }\n}\n"],["2578","//! Native threads.\n//!\n//! ## The threading model\n//!\n//! An executing Rust program consists of a collection of native OS threads,\n//! each with their own stack and local state. Threads can be named, and\n//! provide some built-in support for low-level synchronization.\n//!\n//! Communication between threads can be done through\n//! [channels], Rust's message-passing types, along with [other forms of thread\n//! synchronization](../../std/sync/index.html) and shared-memory data\n//! structures. In particular, types that are guaranteed to be\n//! threadsafe are easily shared between threads using the\n//! atomically-reference-counted container, [`Arc`].\n//!\n//! Fatal logic errors in Rust cause *thread panic*, during which\n//! a thread will unwind the stack, running destructors and freeing\n//! owned resources. While not meant as a 'try/catch' mechanism, panics\n//! in Rust can nonetheless be caught (unless compiling with `panic=abort`) with\n//! [`catch_unwind`](../../std/panic/fn.catch_unwind.html) and recovered\n//! from, or alternatively be resumed with\n//! [`resume_unwind`](../../std/panic/fn.resume_unwind.html). If the panic\n//! is not caught the thread will exit, but the panic may optionally be\n//! detected from a different thread with [`join`]. If the main thread panics\n//! without the panic being caught, the application will exit with a\n//! non-zero exit code.\n//!\n//! When the main thread of a Rust program terminates, the entire program shuts\n//! down, even if other threads are still running. However, this module provides\n//! convenient facilities for automatically waiting for the termination of a\n//! child thread (i.e., join).\n//!\n//! ## Spawning a thread\n//!\n//! A new thread can be spawned using the [`thread::spawn`][`spawn`] function:\n//!\n//! ```rust\n//! use std::thread;\n//!\n//! thread::spawn(move || {\n//!     // some work here\n//! });\n//! ```\n//!\n//! In this example, the spawned thread is \"detached\" from the current\n//! thread. This means that it can outlive its parent (the thread that spawned\n//! it), unless this parent is the main thread.\n//!\n//! The parent thread can also wait on the completion of the child\n//! thread; a call to [`spawn`] produces a [`JoinHandle`], which provides\n//! a `join` method for waiting:\n//!\n//! ```rust\n//! use std::thread;\n//!\n//! let child = thread::spawn(move || {\n//!     // some work here\n//! });\n//! // some work here\n//! let res = child.join();\n//! ```\n//!\n//! The [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final\n//! value produced by the child thread, or [`Err`] of the value given to\n//! a call to [`panic!`] if the child panicked.\n//!\n//! ## Configuring threads\n//!\n//! A new thread can be configured before it is spawned via the [`Builder`] type,\n//! which currently allows you to set the name and stack size for the child thread:\n//!\n//! ```rust\n//! # #![allow(unused_must_use)]\n//! use std::thread;\n//!\n//! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n//!     println!(\"Hello, world!\");\n//! });\n//! ```\n//!\n//! ## The `Thread` type\n//!\n//! Threads are represented via the [`Thread`] type, which you can get in one of\n//! two ways:\n//!\n//! * By spawning a new thread, e.g., using the [`thread::spawn`][`spawn`]\n//!   function, and calling [`thread`][`JoinHandle::thread`] on the [`JoinHandle`].\n//! * By requesting the current thread, using the [`thread::current`] function.\n//!\n//! The [`thread::current`] function is available even for threads not spawned\n//! by the APIs of this module.\n//!\n//! ## Thread-local storage\n//!\n//! This module also provides an implementation of thread-local storage for Rust\n//! programs. Thread-local storage is a method of storing data into a global\n//! variable that each thread in the program will have its own copy of.\n//! Threads do not share this data, so accesses do not need to be synchronized.\n//!\n//! A thread-local key owns the value it contains and will destroy the value when the\n//! thread exits. It is created with the [`thread_local!`] macro and can contain any\n//! value that is `'static` (no borrowed pointers). It provides an accessor function,\n//! [`with`], that yields a shared reference to the value to the specified\n//! closure. Thread-local keys allow only shared access to values, as there would be no\n//! way to guarantee uniqueness if mutable borrows were allowed. Most values\n//! will want to make use of some form of **interior mutability** through the\n//! [`Cell`] or [`RefCell`] types.\n//!\n//! ## Naming threads\n//!\n//! Threads are able to have associated names for identification purposes. By default, spawned\n//! threads are unnamed. To specify a name for a thread, build the thread with [`Builder`] and pass\n//! the desired thread name to [`Builder::name`]. To retrieve the thread name from within the\n//! thread, use [`Thread::name`]. A couple examples of where the name of a thread gets used:\n//!\n//! * If a panic occurs in a named thread, the thread name will be printed in the panic message.\n//! * The thread name is provided to the OS where applicable (e.g., `pthread_setname_np` in\n//!   unix-like platforms).\n//!\n//! ## Stack size\n//!\n//! The default stack size for spawned threads is 2 MiB, though this particular stack size is\n//! subject to change in the future. There are two ways to manually specify the stack size for\n//! spawned threads:\n//!\n//! * Build the thread with [`Builder`] and pass the desired stack size to [`Builder::stack_size`].\n//! * Set the `RUST_MIN_STACK` environment variable to an integer representing the desired stack\n//!   size (in bytes). Note that setting [`Builder::stack_size`] will override this.\n//!\n//! Note that the stack size of the main thread is *not* determined by Rust.\n//!\n//! [channels]: crate::sync::mpsc\n//! [`join`]: JoinHandle::join\n//! [`Result`]: crate::result::Result\n//! [`Ok`]: crate::result::Result::Ok\n//! [`Err`]: crate::result::Result::Err\n//! [`thread::current`]: current\n//! [`thread::Result`]: Result\n//! [`unpark`]: Thread::unpark\n//! [`thread::park_timeout`]: park_timeout\n//! [`Cell`]: crate::cell::Cell\n//! [`RefCell`]: crate::cell::RefCell\n//! [`with`]: LocalKey::with\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![deny(unsafe_op_in_unsafe_fn)]\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\nuse crate::any::Any;\nuse crate::cell::UnsafeCell;\nuse crate::ffi::{CStr, CString};\nuse crate::fmt;\nuse crate::io;\nuse crate::mem;\nuse crate::num::NonZeroU64;\nuse crate::num::NonZeroUsize;\nuse crate::panic;\nuse crate::panicking;\nuse crate::str;\nuse crate::sync::Arc;\nuse crate::sys::thread as imp;\nuse crate::sys_common::mutex;\nuse crate::sys_common::thread;\nuse crate::sys_common::thread_info;\nuse crate::sys_common::thread_parker::Parker;\nuse crate::sys_common::{AsInner, IntoInner};\nuse crate::time::Duration;\n\n////////////////////////////////////////////////////////////////////////////////\n// Thread-local storage\n////////////////////////////////////////////////////////////////////////////////\n\n#[macro_use]\nmod local;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::local::{AccessError, LocalKey};\n\n// The types used by the thread_local! macro to access TLS keys. Note that there\n// are two types, the \"OS\" type and the \"fast\" type. The OS thread local key\n// type is accessed via platform-specific API calls and is slow, while the fast\n// key type is accessed via code generated via LLVM, where TLS keys are set up\n// by the elf linker. Note that the OS TLS type is always available: on macOS\n// the standard library is compiled with support for older platform versions\n// where fast TLS was not available; end-user code is compiled with fast TLS\n// where available, but both are needed.\n\n#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n#[cfg(target_thread_local)]\n#[doc(hidden)]\npub use self::local::fast::Key as __FastLocalKeyInner;\n#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n#[doc(hidden)]\npub use self::local::os::Key as __OsLocalKeyInner;\n#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n#[doc(hidden)]\npub use self::local::statik::Key as __StaticLocalKeyInner;\n\n// This is only used to make thread locals with `const { .. }` initialization\n// expressions unstable. If and/or when that syntax is stabilized with thread\n// locals this will simply be removed.\n#[doc(hidden)]\n#[unstable(feature = \"thread_local_const_init\", issue = \"84223\")]\npub const fn require_unstable_const_init_thread_local() {}\n\n////////////////////////////////////////////////////////////////////////////////\n// Builder\n////////////////////////////////////////////////////////////////////////////////\n\n/// Thread factory, which can be used in order to configure the properties of\n/// a new thread.\n///\n/// Methods can be chained on it in order to configure it.\n///\n/// The two configurations available are:\n///\n/// - [`name`]: specifies an [associated name for the thread][naming-threads]\n/// - [`stack_size`]: specifies the [desired stack size for the thread][stack-size]\n///\n/// The [`spawn`] method will take ownership of the builder and create an\n/// [`io::Result`] to the thread handle with the given configuration.\n///\n/// The [`thread::spawn`] free function uses a `Builder` with default\n/// configuration and [`unwrap`]s its return value.\n///\n/// You may want to use [`spawn`] instead of [`thread::spawn`], when you want\n/// to recover from a failure to launch a thread, indeed the free function will\n/// panic where the `Builder` method will return a [`io::Result`].\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// let builder = thread::Builder::new();\n///\n/// let handler = builder.spawn(|| {\n///     // thread code\n/// }).unwrap();\n///\n/// handler.join().unwrap();\n/// ```\n///\n/// [`stack_size`]: Builder::stack_size\n/// [`name`]: Builder::name\n/// [`spawn`]: Builder::spawn\n/// [`thread::spawn`]: spawn\n/// [`io::Result`]: crate::io::Result\n/// [`unwrap`]: crate::result::Result::unwrap\n/// [naming-threads]: ./index.html#naming-threads\n/// [stack-size]: ./index.html#stack-size\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Builder {\n    // A name for the thread-to-be, for identification in panic messages\n    name: Option<String>,\n    // The size of the stack for the spawned thread in bytes\n    stack_size: Option<usize>,\n}\n\nimpl Builder {\n    /// Generates the base configuration for spawning a thread, from which\n    /// configuration methods can be chained.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///                               .name(\"foo\".into())\n    ///                               .stack_size(32 * 1024);\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     // thread code\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> Builder {\n        Builder { name: None, stack_size: None }\n    }\n\n    /// Names the thread-to-be. Currently the name is used for identification\n    /// only in panic messages.\n    ///\n    /// The name must not contain null bytes (`\\0`).\n    ///\n    /// For more information about named threads, see\n    /// [this module-level documentation][naming-threads].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///     .name(\"foo\".into());\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert_eq!(thread::current().name(), Some(\"foo\"))\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// [naming-threads]: ./index.html#naming-threads\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn name(mut self, name: String) -> Builder {\n        self.name = Some(name);\n        self\n    }\n\n    /// Sets the size of the stack (in bytes) for the new thread.\n    ///\n    /// The actual stack size may be greater than this value if\n    /// the platform specifies a minimal stack size.\n    ///\n    /// For more information about the stack size for threads, see\n    /// [this module-level documentation][stack-size].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new().stack_size(32 * 1024);\n    /// ```\n    ///\n    /// [stack-size]: ./index.html#stack-size\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn stack_size(mut self, size: usize) -> Builder {\n        self.stack_size = Some(size);\n        self\n    }\n\n    /// Spawns a new thread by taking ownership of the `Builder`, and returns an\n    /// [`io::Result`] to its [`JoinHandle`].\n    ///\n    /// The spawned thread may outlive the caller (unless the caller thread\n    /// is the main thread; the whole process is terminated when the main\n    /// thread finishes). The join handle can be used to block on\n    /// termination of the child thread, including recovering its panics.\n    ///\n    /// For a more complete documentation see [`thread::spawn`][`spawn`].\n    ///\n    /// # Errors\n    ///\n    /// Unlike the [`spawn`] free function, this method yields an\n    /// [`io::Result`] to capture any failure to create the thread at\n    /// the OS level.\n    ///\n    /// [`io::Result`]: crate::io::Result\n    ///\n    /// # Panics\n    ///\n    /// Panics if a thread name was set and it contained null bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     // thread code\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send + 'static,\n    {\n        unsafe { self.spawn_unchecked(f) }\n    }\n\n    /// Spawns a new thread without any lifetime restrictions by taking ownership\n    /// of the `Builder`, and returns an [`io::Result`] to its [`JoinHandle`].\n    ///\n    /// The spawned thread may outlive the caller (unless the caller thread\n    /// is the main thread; the whole process is terminated when the main\n    /// thread finishes). The join handle can be used to block on\n    /// termination of the child thread, including recovering its panics.\n    ///\n    /// This method is identical to [`thread::Builder::spawn`][`Builder::spawn`],\n    /// except for the relaxed lifetime bounds, which render it unsafe.\n    /// For a more complete documentation see [`thread::spawn`][`spawn`].\n    ///\n    /// # Errors\n    ///\n    /// Unlike the [`spawn`] free function, this method yields an\n    /// [`io::Result`] to capture any failure to create the thread at\n    /// the OS level.\n    ///\n    /// # Panics\n    ///\n    /// Panics if a thread name was set and it contained null bytes.\n    ///\n    /// # Safety\n    ///\n    /// The caller has to ensure that no references in the supplied thread closure\n    /// or its return type can outlive the spawned thread's lifetime. This can be\n    /// guaranteed in two ways:\n    ///\n    /// - ensure that [`join`][`JoinHandle::join`] is called before any referenced\n    /// data is dropped\n    /// - use only types with `'static` lifetime bounds, i.e., those with no or only\n    /// `'static` references (both [`thread::Builder::spawn`][`Builder::spawn`]\n    /// and [`thread::spawn`][`spawn`] enforce this property statically)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(thread_spawn_unchecked)]\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let x = 1;\n    /// let thread_x = &x;\n    ///\n    /// let handler = unsafe {\n    ///     builder.spawn_unchecked(move || {\n    ///         println!(\"x = {}\", *thread_x);\n    ///     }).unwrap()\n    /// };\n    ///\n    /// // caller has to ensure `join()` is called, otherwise\n    /// // it is possible to access freed memory if `x` gets\n    /// // dropped before the thread closure is executed!\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// [`io::Result`]: crate::io::Result\n    #[unstable(feature = \"thread_spawn_unchecked\", issue = \"55132\")]\n    pub unsafe fn spawn_unchecked<'a, F, T>(self, f: F) -> io::Result<JoinHandle<T>>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'a,\n        T: Send + 'a,\n    {\n        let Builder { name, stack_size } = self;\n\n        let stack_size = stack_size.unwrap_or_else(thread::min_stack);\n\n        let my_thread = Thread::new(name);\n        let their_thread = my_thread.clone();\n\n        let my_packet: Arc<UnsafeCell<Option<Result<T>>>> = Arc::new(UnsafeCell::new(None));\n        let their_packet = my_packet.clone();\n\n        let output_capture = crate::io::set_output_capture(None);\n        crate::io::set_output_capture(output_capture.clone());\n\n        let main = move || {\n            if let Some(name) = their_thread.cname() {\n                imp::Thread::set_name(name);\n            }\n\n            crate::io::set_output_capture(output_capture);\n\n            // SAFETY: the stack guard passed is the one for the current thread.\n            // This means the current thread's stack and the new thread's stack\n            // are properly set and protected from each other.\n            thread_info::set(unsafe { imp::guard::current() }, their_thread);\n            let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n                crate::sys_common::backtrace::__rust_begin_short_backtrace(f)\n            }));\n            // SAFETY: `their_packet` as been built just above and moved by the\n            // closure (it is an Arc<...>) and `my_packet` will be stored in the\n            // same `JoinInner` as this closure meaning the mutation will be\n            // safe (not modify it and affect a value far away).\n            unsafe { *their_packet.get() = Some(try_result) };\n        };\n\n        Ok(JoinHandle(JoinInner {\n            // SAFETY:\n            //\n            // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n            // through FFI or otherwise used with low-level threading primitives that have no\n            // notion of or way to enforce lifetimes.\n            //\n            // As mentioned in the `Safety` section of this function's documentation, the caller of\n            // this function needs to guarantee that the passed-in lifetime is sufficiently long\n            // for the lifetime of the thread.\n            //\n            // Similarly, the `sys` implementation must guarantee that no references to the closure\n            // exist after the thread has terminated, which is signaled by `Thread::join`\n            // returning.\n            native: unsafe {\n                Some(imp::Thread::new(\n                    stack_size,\n                    mem::transmute::<Box<dyn FnOnce() + 'a>, Box<dyn FnOnce() + 'static>>(\n                        Box::new(main),\n                    ),\n                )?)\n            },\n            thread: my_thread,\n            packet: Packet(my_packet),\n        }))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Free functions\n////////////////////////////////////////////////////////////////////////////////\n\n/// Spawns a new thread, returning a [`JoinHandle`] for it.\n///\n/// The join handle will implicitly *detach* the child thread upon being\n/// dropped. In this case, the child thread may outlive the parent (unless\n/// the parent thread is the main thread; the whole process is terminated when\n/// the main thread finishes). Additionally, the join handle provides a [`join`]\n/// method that can be used to join the child thread. If the child thread\n/// panics, [`join`] will return an [`Err`] containing the argument given to\n/// [`panic!`].\n///\n/// This will create a thread using default parameters of [`Builder`], if you\n/// want to specify the stack size or the name of the thread, use this API\n/// instead.\n///\n/// As you can see in the signature of `spawn` there are two constraints on\n/// both the closure given to `spawn` and its return value, let's explain them:\n///\n/// - The `'static` constraint means that the closure and its return value\n///   must have a lifetime of the whole program execution. The reason for this\n///   is that threads can `detach` and outlive the lifetime they have been\n///   created in.\n///   Indeed if the thread, and by extension its return value, can outlive their\n///   caller, we need to make sure that they will be valid afterwards, and since\n///   we *can't* know when it will return we need to have them valid as long as\n///   possible, that is until the end of the program, hence the `'static`\n///   lifetime.\n/// - The [`Send`] constraint is because the closure will need to be passed\n///   *by value* from the thread where it is spawned to the new thread. Its\n///   return value will need to be passed from the new thread to the thread\n///   where it is `join`ed.\n///   As a reminder, the [`Send`] marker trait expresses that it is safe to be\n///   passed from thread to thread. [`Sync`] expresses that it is safe to have a\n///   reference be passed from thread to thread.\n///\n/// # Panics\n///\n/// Panics if the OS fails to create a thread; use [`Builder::spawn`]\n/// to recover from such errors.\n///\n/// # Examples\n///\n/// Creating a thread.\n///\n/// ```\n/// use std::thread;\n///\n/// let handler = thread::spawn(|| {\n///     // thread code\n/// });\n///\n/// handler.join().unwrap();\n/// ```\n///\n/// As mentioned in the module documentation, threads are usually made to\n/// communicate using [`channels`], here is how it usually looks.\n///\n/// This example also shows how to use `move`, in order to give ownership\n/// of values to a thread.\n///\n/// ```\n/// use std::thread;\n/// use std::sync::mpsc::channel;\n///\n/// let (tx, rx) = channel();\n///\n/// let sender = thread::spawn(move || {\n///     tx.send(\"Hello, thread\".to_owned())\n///         .expect(\"Unable to send on channel\");\n/// });\n///\n/// let receiver = thread::spawn(move || {\n///     let value = rx.recv().expect(\"Unable to receive from channel\");\n///     println!(\"{}\", value);\n/// });\n///\n/// sender.join().expect(\"The sender thread has panicked\");\n/// receiver.join().expect(\"The receiver thread has panicked\");\n/// ```\n///\n/// A thread can also return a value through its [`JoinHandle`], you can use\n/// this to make asynchronous computations (futures might be more appropriate\n/// though).\n///\n/// ```\n/// use std::thread;\n///\n/// let computation = thread::spawn(|| {\n///     // Some expensive computation.\n///     42\n/// });\n///\n/// let result = computation.join().unwrap();\n/// println!(\"{}\", result);\n/// ```\n///\n/// [`channels`]: crate::sync::mpsc\n/// [`join`]: JoinHandle::join\n/// [`Err`]: crate::result::Result::Err\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn spawn<F, T>(f: F) -> JoinHandle<T>\nwhere\n    F: FnOnce() -> T,\n    F: Send + 'static,\n    T: Send + 'static,\n{\n    Builder::new().spawn(f).expect(\"failed to spawn thread\")\n}\n\n/// Gets a handle to the thread that invokes it.\n///\n/// # Examples\n///\n/// Getting a handle to the current thread with `thread::current()`:\n///\n/// ```\n/// use std::thread;\n///\n/// let handler = thread::Builder::new()\n///     .name(\"named thread\".into())\n///     .spawn(|| {\n///         let handle = thread::current();\n///         assert_eq!(handle.name(), Some(\"named thread\"));\n///     })\n///     .unwrap();\n///\n/// handler.join().unwrap();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn current() -> Thread {\n    thread_info::current_thread().expect(\n        \"use of std::thread::current() is not possible \\\n         after the thread's local data has been destroyed\",\n    )\n}\n\n/// Cooperatively gives up a timeslice to the OS scheduler.\n///\n/// This is used when the programmer knows that the thread will have nothing\n/// to do for some time, and thus avoid wasting computing time.\n///\n/// For example when polling on a resource, it is common to check that it is\n/// available, and if not to yield in order to avoid busy waiting.\n///\n/// Thus the pattern of `yield`ing after a failed poll is rather common when\n/// implementing low-level shared resources or synchronization primitives.\n///\n/// However programmers will usually prefer to use [`channel`]s, [`Condvar`]s,\n/// [`Mutex`]es or [`join`] for their synchronization routines, as they avoid\n/// thinking about thread scheduling.\n///\n/// Note that [`channel`]s for example are implemented using this primitive.\n/// Indeed when you call `send` or `recv`, which are blocking, they will yield\n/// if the channel is not available.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// thread::yield_now();\n/// ```\n///\n/// [`channel`]: crate::sync::mpsc\n/// [`join`]: JoinHandle::join\n/// [`Condvar`]: crate::sync::Condvar\n/// [`Mutex`]: crate::sync::Mutex\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn yield_now() {\n    imp::Thread::yield_now()\n}\n\n/// Determines whether the current thread is unwinding because of panic.\n///\n/// A common use of this feature is to poison shared resources when writing\n/// unsafe code, by checking `panicking` when the `drop` is called.\n///\n/// This is usually not needed when writing safe code, as [`Mutex`es][Mutex]\n/// already poison themselves when a thread panics while holding the lock.\n///\n/// This can also be used in multithreaded applications, in order to send a\n/// message to other threads warning that a thread has panicked (e.g., for\n/// monitoring purposes).\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::thread;\n///\n/// struct SomeStruct;\n///\n/// impl Drop for SomeStruct {\n///     fn drop(&mut self) {\n///         if thread::panicking() {\n///             println!(\"dropped while unwinding\");\n///         } else {\n///             println!(\"dropped while not unwinding\");\n///         }\n///     }\n/// }\n///\n/// {\n///     print!(\"a: \");\n///     let a = SomeStruct;\n/// }\n///\n/// {\n///     print!(\"b: \");\n///     let b = SomeStruct;\n///     panic!()\n/// }\n/// ```\n///\n/// [Mutex]: crate::sync::Mutex\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn panicking() -> bool {\n    panicking::panicking()\n}\n\n/// Puts the current thread to sleep for at least the specified amount of time.\n///\n/// The thread may sleep longer than the duration specified due to scheduling\n/// specifics or platform-dependent functionality. It will never sleep less.\n///\n/// This function is blocking, and should not be used in `async` functions.\n///\n/// # Platform-specific behavior\n///\n/// On Unix platforms, the underlying syscall may be interrupted by a\n/// spurious wakeup or signal handler. To ensure the sleep occurs for at least\n/// the specified duration, this function may invoke that system call multiple\n/// times.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::thread;\n///\n/// // Let's sleep for 2 seconds:\n/// thread::sleep_ms(2000);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::sleep`\")]\npub fn sleep_ms(ms: u32) {\n    sleep(Duration::from_millis(ms as u64))\n}\n\n/// Puts the current thread to sleep for at least the specified amount of time.\n///\n/// The thread may sleep longer than the duration specified due to scheduling\n/// specifics or platform-dependent functionality. It will never sleep less.\n///\n/// This function is blocking, and should not be used in `async` functions.\n///\n/// # Platform-specific behavior\n///\n/// On Unix platforms, the underlying syscall may be interrupted by a\n/// spurious wakeup or signal handler. To ensure the sleep occurs for at least\n/// the specified duration, this function may invoke that system call multiple\n/// times.\n/// Platforms which do not support nanosecond precision for sleeping will\n/// have `dur` rounded up to the nearest granularity of time they can sleep for.\n///\n/// Currently, specifying a zero duration on Unix platforms returns immediately\n/// without invoking the underlying [`nanosleep`] syscall, whereas on Windows\n/// platforms the underlying [`Sleep`] syscall is always invoked.\n/// If the intention is to yield the current time-slice you may want to use\n/// [`yield_now`] instead.\n///\n/// [`nanosleep`]: https://linux.die.net/man/2/nanosleep\n/// [`Sleep`]: https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::{thread, time};\n///\n/// let ten_millis = time::Duration::from_millis(10);\n/// let now = time::Instant::now();\n///\n/// thread::sleep(ten_millis);\n///\n/// assert!(now.elapsed() >= ten_millis);\n/// ```\n#[stable(feature = \"thread_sleep\", since = \"1.4.0\")]\npub fn sleep(dur: Duration) {\n    imp::Thread::sleep(dur)\n}\n\n/// Blocks unless or until the current thread's token is made available.\n///\n/// A call to `park` does not guarantee that the thread will remain parked\n/// forever, and callers should be prepared for this possibility.\n///\n/// # park and unpark\n///\n/// Every thread is equipped with some basic low-level blocking support, via the\n/// [`thread::park`][`park`] function and [`thread::Thread::unpark`][`unpark`]\n/// method. [`park`] blocks the current thread, which can then be resumed from\n/// another thread by calling the [`unpark`] method on the blocked thread's\n/// handle.\n///\n/// Conceptually, each [`Thread`] handle has an associated token, which is\n/// initially not present:\n///\n/// * The [`thread::park`][`park`] function blocks the current thread unless or\n///   until the token is available for its thread handle, at which point it\n///   atomically consumes the token. It may also return *spuriously*, without\n///   consuming the token. [`thread::park_timeout`] does the same, but allows\n///   specifying a maximum time to block the thread for.\n///\n/// * The [`unpark`] method on a [`Thread`] atomically makes the token available\n///   if it wasn't already. Because the token is initially absent, [`unpark`]\n///   followed by [`park`] will result in the second call returning immediately.\n///\n/// In other words, each [`Thread`] acts a bit like a spinlock that can be\n/// locked and unlocked using `park` and `unpark`.\n///\n/// Notice that being unblocked does not imply any synchronization with someone\n/// that unparked this thread, it could also be spurious.\n/// For example, it would be a valid, but inefficient, implementation to make both [`park`] and\n/// [`unpark`] return immediately without doing anything.\n///\n/// The API is typically used by acquiring a handle to the current thread,\n/// placing that handle in a shared data structure so that other threads can\n/// find it, and then `park`ing in a loop. When some desired condition is met, another\n/// thread calls [`unpark`] on the handle.\n///\n/// The motivation for this design is twofold:\n///\n/// * It avoids the need to allocate mutexes and condvars when building new\n///   synchronization primitives; the threads already provide basic\n///   blocking/signaling.\n///\n/// * It can be implemented very efficiently on many platforms.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::sync::{Arc, atomic::{Ordering, AtomicBool}};\n/// use std::time::Duration;\n///\n/// let flag = Arc::new(AtomicBool::new(false));\n/// let flag2 = Arc::clone(&flag);\n///\n/// let parked_thread = thread::spawn(move || {\n///     // We want to wait until the flag is set. We *could* just spin, but using\n///     // park/unpark is more efficient.\n///     while !flag2.load(Ordering::Acquire) {\n///         println!(\"Parking thread\");\n///         thread::park();\n///         // We *could* get here spuriously, i.e., way before the 10ms below are over!\n///         // But that is no problem, we are in a loop until the flag is set anyway.\n///         println!(\"Thread unparked\");\n///     }\n///     println!(\"Flag received\");\n/// });\n///\n/// // Let some time pass for the thread to be spawned.\n/// thread::sleep(Duration::from_millis(10));\n///\n/// // Set the flag, and let the thread wake up.\n/// // There is no race condition here, if `unpark`\n/// // happens first, `park` will return immediately.\n/// // Hence there is no risk of a deadlock.\n/// flag.store(true, Ordering::Release);\n/// println!(\"Unpark the thread\");\n/// parked_thread.thread().unpark();\n///\n/// parked_thread.join().unwrap();\n/// ```\n///\n/// [`unpark`]: Thread::unpark\n/// [`thread::park_timeout`]: park_timeout\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn park() {\n    // SAFETY: park_timeout is called on the parker owned by this thread.\n    unsafe {\n        current().inner.parker.park();\n    }\n}\n\n/// Use [`park_timeout`].\n///\n/// Blocks unless or until the current thread's token is made available or\n/// the specified duration has been reached (may wake spuriously).\n///\n/// The semantics of this function are equivalent to [`park`] except\n/// that the thread will be blocked for roughly no longer than `dur`. This\n/// method should not be used for precise timing due to anomalies such as\n/// preemption or platform differences that may not cause the maximum\n/// amount of time waited to be precisely `ms` long.\n///\n/// See the [park documentation][`park`] for more detail.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::park_timeout`\")]\npub fn park_timeout_ms(ms: u32) {\n    park_timeout(Duration::from_millis(ms as u64))\n}\n\n/// Blocks unless or until the current thread's token is made available or\n/// the specified duration has been reached (may wake spuriously).\n///\n/// The semantics of this function are equivalent to [`park`][park] except\n/// that the thread will be blocked for roughly no longer than `dur`. This\n/// method should not be used for precise timing due to anomalies such as\n/// preemption or platform differences that may not cause the maximum\n/// amount of time waited to be precisely `dur` long.\n///\n/// See the [park documentation][park] for more details.\n///\n/// # Platform-specific behavior\n///\n/// Platforms which do not support nanosecond precision for sleeping will have\n/// `dur` rounded up to the nearest granularity of time they can sleep for.\n///\n/// # Examples\n///\n/// Waiting for the complete expiration of the timeout:\n///\n/// ```rust,no_run\n/// use std::thread::park_timeout;\n/// use std::time::{Instant, Duration};\n///\n/// let timeout = Duration::from_secs(2);\n/// let beginning_park = Instant::now();\n///\n/// let mut timeout_remaining = timeout;\n/// loop {\n///     park_timeout(timeout_remaining);\n///     let elapsed = beginning_park.elapsed();\n///     if elapsed >= timeout {\n///         break;\n///     }\n///     println!(\"restarting park_timeout after {:?}\", elapsed);\n///     timeout_remaining = timeout - elapsed;\n/// }\n/// ```\n#[stable(feature = \"park_timeout\", since = \"1.4.0\")]\npub fn park_timeout(dur: Duration) {\n    // SAFETY: park_timeout is called on the parker owned by this thread.\n    unsafe {\n        current().inner.parker.park_timeout(dur);\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ThreadId\n////////////////////////////////////////////////////////////////////////////////\n\n/// A unique identifier for a running thread.\n///\n/// A `ThreadId` is an opaque object that has a unique value for each thread\n/// that creates one. `ThreadId`s are not guaranteed to correspond to a thread's\n/// system-designated identifier. A `ThreadId` can be retrieved from the [`id`]\n/// method on a [`Thread`].\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// let other_thread = thread::spawn(|| {\n///     thread::current().id()\n/// });\n///\n/// let other_thread_id = other_thread.join().unwrap();\n/// assert!(thread::current().id() != other_thread_id);\n/// ```\n///\n/// [`id`]: Thread::id\n#[stable(feature = \"thread_id\", since = \"1.19.0\")]\n#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\npub struct ThreadId(NonZeroU64);\n\nimpl ThreadId {\n    // Generate a new unique thread ID.\n    fn new() -> ThreadId {\n        // It is UB to attempt to acquire this mutex reentrantly!\n        static GUARD: mutex::StaticMutex = mutex::StaticMutex::new();\n        static mut COUNTER: u64 = 1;\n\n        unsafe {\n            let _guard = GUARD.lock();\n\n            // If we somehow use up all our bits, panic so that we're not\n            // covering up subtle bugs of IDs being reused.\n            if COUNTER == u64::MAX {\n                panic!(\"failed to generate unique thread ID: bitspace exhausted\");\n            }\n\n            let id = COUNTER;\n            COUNTER += 1;\n\n            ThreadId(NonZeroU64::new(id).unwrap())\n        }\n    }\n\n    /// This returns a numeric identifier for the thread identified by this\n    /// `ThreadId`.\n    ///\n    /// As noted in the documentation for the type itself, it is essentially an\n    /// opaque ID, but is guaranteed to be unique for each thread. The returned\n    /// value is entirely opaque -- only equality testing is stable. Note that\n    /// it is not guaranteed which values new threads will return, and this may\n    /// change across Rust versions.\n    #[unstable(feature = \"thread_id_value\", issue = \"67939\")]\n    pub fn as_u64(&self) -> NonZeroU64 {\n        self.0\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Thread\n////////////////////////////////////////////////////////////////////////////////\n\n/// The internal representation of a `Thread` handle\nstruct Inner {\n    name: Option<CString>, // Guaranteed to be UTF-8\n    id: ThreadId,\n    parker: Parker,\n}\n\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n/// A handle to a thread.\n///\n/// Threads are represented via the `Thread` type, which you can get in one of\n/// two ways:\n///\n/// * By spawning a new thread, e.g., using the [`thread::spawn`][`spawn`]\n///   function, and calling [`thread`][`JoinHandle::thread`] on the\n///   [`JoinHandle`].\n/// * By requesting the current thread, using the [`thread::current`] function.\n///\n/// The [`thread::current`] function is available even for threads not spawned\n/// by the APIs of this module.\n///\n/// There is usually no need to create a `Thread` struct yourself, one\n/// should instead use a function like `spawn` to create new threads, see the\n/// docs of [`Builder`] and [`spawn`] for more details.\n///\n/// [`thread::current`]: current\npub struct Thread {\n    inner: Arc<Inner>,\n}\n\nimpl Thread {\n    // Used only internally to construct a thread object without spawning\n    // Panics if the name contains nuls.\n    pub(crate) fn new(name: Option<String>) -> Thread {\n        let cname =\n            name.map(|n| CString::new(n).expect(\"thread name may not contain interior null bytes\"));\n        Thread {\n            inner: Arc::new(Inner { name: cname, id: ThreadId::new(), parker: Parker::new() }),\n        }\n    }\n\n    /// Atomically makes the handle's token available if it is not already.\n    ///\n    /// Every thread is equipped with some basic low-level blocking support, via\n    /// the [`park`][park] function and the `unpark()` method. These can be\n    /// used as a more CPU-efficient implementation of a spinlock.\n    ///\n    /// See the [park documentation][park] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let parked_thread = thread::Builder::new()\n    ///     .spawn(|| {\n    ///         println!(\"Parking thread\");\n    ///         thread::park();\n    ///         println!(\"Thread unparked\");\n    ///     })\n    ///     .unwrap();\n    ///\n    /// // Let some time pass for the thread to be spawned.\n    /// thread::sleep(Duration::from_millis(10));\n    ///\n    /// println!(\"Unpark the thread\");\n    /// parked_thread.thread().unpark();\n    ///\n    /// parked_thread.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn unpark(&self) {\n        self.inner.parker.unpark();\n    }\n\n    /// Gets the thread's unique identifier.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let other_thread = thread::spawn(|| {\n    ///     thread::current().id()\n    /// });\n    ///\n    /// let other_thread_id = other_thread.join().unwrap();\n    /// assert!(thread::current().id() != other_thread_id);\n    /// ```\n    #[stable(feature = \"thread_id\", since = \"1.19.0\")]\n    pub fn id(&self) -> ThreadId {\n        self.inner.id\n    }\n\n    /// Gets the thread's name.\n    ///\n    /// For more information about named threads, see\n    /// [this module-level documentation][naming-threads].\n    ///\n    /// # Examples\n    ///\n    /// Threads by default have no name specified:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert!(thread::current().name().is_none());\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// Thread with a specified name:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///     .name(\"foo\".into());\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert_eq!(thread::current().name(), Some(\"foo\"))\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// [naming-threads]: ./index.html#naming-threads\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn name(&self) -> Option<&str> {\n        self.cname().map(|s| unsafe { str::from_utf8_unchecked(s.to_bytes()) })\n    }\n\n    fn cname(&self) -> Option<&CStr> {\n        self.inner.name.as_deref()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Thread {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Thread\")\n            .field(\"id\", &self.id())\n            .field(\"name\", &self.name())\n            .finish_non_exhaustive()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// JoinHandle\n////////////////////////////////////////////////////////////////////////////////\n\n/// A specialized [`Result`] type for threads.\n///\n/// Indicates the manner in which a thread exited.\n///\n/// The value contained in the `Result::Err` variant\n/// is the value the thread panicked with;\n/// that is, the argument the `panic!` macro was called with.\n/// Unlike with normal errors, this value doesn't implement\n/// the [`Error`](crate::error::Error) trait.\n///\n/// Thus, a sensible way to handle a thread panic is to either:\n///\n/// 1. propagate the panic with [`std::panic::resume_unwind`]\n/// 2. or in case the thread is intended to be a subsystem boundary\n/// that is supposed to isolate system-level failures,\n/// match on the `Err` variant and handle the panic in an appropriate way\n///\n/// A thread that completes without panicking is considered to exit successfully.\n///\n/// # Examples\n///\n/// Matching on the result of a joined thread:\n///\n/// ```no_run\n/// use std::{fs, thread, panic};\n///\n/// fn copy_in_thread() -> thread::Result<()> {\n///     thread::spawn(|| {\n///         fs::copy(\"foo.txt\", \"bar.txt\").unwrap();\n///     }).join()\n/// }\n///\n/// fn main() {\n///     match copy_in_thread() {\n///         Ok(_) => println!(\"copy succeeded\"),\n///         Err(e) => panic::resume_unwind(e),\n///     }\n/// }\n/// ```\n///\n/// [`Result`]: crate::result::Result\n/// [`std::panic::resume_unwind`]: crate::panic::resume_unwind\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result<T> = crate::result::Result<T, Box<dyn Any + Send + 'static>>;\n\n// This packet is used to communicate the return value between the child thread\n// and the parent thread. Memory is shared through the `Arc` within and there's\n// no need for a mutex here because synchronization happens with `join()` (the\n// parent thread never reads this packet until the child has exited).\n//\n// This packet itself is then stored into a `JoinInner` which in turns is placed\n// in `JoinHandle` and `JoinGuard`. Due to the usage of `UnsafeCell` we need to\n// manually worry about impls like Send and Sync. The type `T` should\n// already always be Send (otherwise the thread could not have been created) and\n// this type is inherently Sync because no methods take &self. Regardless,\n// however, we add inheriting impls for Send/Sync to this type to ensure it's\n// Send/Sync and that future modifications will still appropriately classify it.\nstruct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n\nunsafe impl<T: Send> Send for Packet<T> {}\nunsafe impl<T: Sync> Sync for Packet<T> {}\n\n/// Inner representation for JoinHandle\nstruct JoinInner<T> {\n    native: Option<imp::Thread>,\n    thread: Thread,\n    packet: Packet<T>,\n}\n\nimpl<T> JoinInner<T> {\n    fn join(&mut self) -> Result<T> {\n        self.native.take().unwrap().join();\n        unsafe { (*self.packet.0.get()).take().unwrap() }\n    }\n}\n\n/// An owned permission to join on a thread (block on its termination).\n///\n/// A `JoinHandle` *detaches* the associated thread when it is dropped, which\n/// means that there is no longer any handle to thread and no way to `join`\n/// on it.\n///\n/// Due to platform restrictions, it is not possible to [`Clone`] this\n/// handle: the ability to join a thread is a uniquely-owned permission.\n///\n/// This `struct` is created by the [`thread::spawn`] function and the\n/// [`thread::Builder::spawn`] method.\n///\n/// # Examples\n///\n/// Creation from [`thread::spawn`]:\n///\n/// ```\n/// use std::thread;\n///\n/// let join_handle: thread::JoinHandle<_> = thread::spawn(|| {\n///     // some work here\n/// });\n/// ```\n///\n/// Creation from [`thread::Builder::spawn`]:\n///\n/// ```\n/// use std::thread;\n///\n/// let builder = thread::Builder::new();\n///\n/// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n///     // some work here\n/// }).unwrap();\n/// ```\n///\n/// Child being detached and outliving its parent:\n///\n/// ```no_run\n/// use std::thread;\n/// use std::time::Duration;\n///\n/// let original_thread = thread::spawn(|| {\n///     let _detached_thread = thread::spawn(|| {\n///         // Here we sleep to make sure that the first thread returns before.\n///         thread::sleep(Duration::from_millis(10));\n///         // This will be called, even though the JoinHandle is dropped.\n///         println!(\"♫ Still alive ♫\");\n///     });\n/// });\n///\n/// original_thread.join().expect(\"The thread being joined has panicked\");\n/// println!(\"Original thread is joined.\");\n///\n/// // We make sure that the new thread has time to run, before the main\n/// // thread returns.\n///\n/// thread::sleep(Duration::from_millis(1000));\n/// ```\n///\n/// [`thread::Builder::spawn`]: Builder::spawn\n/// [`thread::spawn`]: spawn\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct JoinHandle<T>(JoinInner<T>);\n\n#[stable(feature = \"joinhandle_impl_send_sync\", since = \"1.29.0\")]\nunsafe impl<T> Send for JoinHandle<T> {}\n#[stable(feature = \"joinhandle_impl_send_sync\", since = \"1.29.0\")]\nunsafe impl<T> Sync for JoinHandle<T> {}\n\nimpl<T> JoinHandle<T> {\n    /// Extracts a handle to the underlying thread.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n    ///     // some work here\n    /// }).unwrap();\n    ///\n    /// let thread = join_handle.thread();\n    /// println!(\"thread id: {:?}\", thread.id());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn thread(&self) -> &Thread {\n        &self.0.thread\n    }\n\n    /// Waits for the associated thread to finish.\n    ///\n    /// In terms of [atomic memory orderings],  the completion of the associated\n    /// thread synchronizes with this function returning. In other words, all\n    /// operations performed by that thread are ordered before all\n    /// operations that happen after `join` returns.\n    ///\n    /// If the child thread panics, [`Err`] is returned with the parameter given\n    /// to [`panic!`].\n    ///\n    /// [`Err`]: crate::result::Result::Err\n    /// [atomic memory orderings]: crate::sync::atomic\n    ///\n    /// # Panics\n    ///\n    /// This function may panic on some platforms if a thread attempts to join\n    /// itself or otherwise may create a deadlock with joining threads.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n    ///     // some work here\n    /// }).unwrap();\n    /// join_handle.join().expect(\"Couldn't join on the associated thread\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn join(mut self) -> Result<T> {\n        self.0.join()\n    }\n}\n\nimpl<T> AsInner<imp::Thread> for JoinHandle<T> {\n    fn as_inner(&self) -> &imp::Thread {\n        self.0.native.as_ref().unwrap()\n    }\n}\n\nimpl<T> IntoInner<imp::Thread> for JoinHandle<T> {\n    fn into_inner(self) -> imp::Thread {\n        self.0.native.unwrap()\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T> fmt::Debug for JoinHandle<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"JoinHandle\").finish_non_exhaustive()\n    }\n}\n\nfn _assert_sync_and_send() {\n    fn _assert_both<T: Send + Sync>() {}\n    _assert_both::<JoinHandle<()>>();\n    _assert_both::<Thread>();\n}\n\n/// Returns the number of hardware threads available to the program.\n///\n/// This value should be considered only a hint.\n///\n/// # Platform-specific behavior\n///\n/// If interpreted as the number of actual hardware threads, it may undercount on\n/// Windows systems with more than 64 hardware threads. If interpreted as the\n/// available concurrency for that process, it may overcount on Windows systems\n/// when limited by a process wide affinity mask or job object limitations, and\n/// it may overcount on Linux systems when limited by a process wide affinity\n/// mask or affected by cgroups limits.\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// - If the number of hardware threads is not known for the target platform.\n/// - The process lacks permissions to view the number of hardware threads\n///   available.\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(dead_code)]\n/// #![feature(available_concurrency)]\n/// use std::thread;\n///\n/// let count = thread::available_concurrency().map(|n| n.get()).unwrap_or(1);\n/// ```\n#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\npub fn available_concurrency() -> io::Result<NonZeroUsize> {\n    imp::available_concurrency()\n}\n"],["2579","use super::Builder;\nuse crate::any::Any;\nuse crate::mem;\nuse crate::result;\nuse crate::sync::mpsc::{channel, Sender};\nuse crate::thread::{self, ThreadId};\nuse crate::time::Duration;\n\n// !!! These tests are dangerous. If something is buggy, they will hang, !!!\n// !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n\n#[test]\nfn test_unnamed_thread() {\n    thread::spawn(move || {\n        assert!(thread::current().name().is_none());\n    })\n    .join()\n    .ok()\n    .expect(\"thread panicked\");\n}\n\n#[test]\nfn test_named_thread() {\n    Builder::new()\n        .name(\"ada lovelace\".to_string())\n        .spawn(move || {\n            assert!(thread::current().name().unwrap() == \"ada lovelace\".to_string());\n        })\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\n#[test]\n#[should_panic]\nfn test_invalid_named_thread() {\n    let _ = Builder::new().name(\"ada l\\0velace\".to_string()).spawn(|| {});\n}\n\n#[test]\nfn test_run_basic() {\n    let (tx, rx) = channel();\n    thread::spawn(move || {\n        tx.send(()).unwrap();\n    });\n    rx.recv().unwrap();\n}\n\n#[test]\nfn test_join_panic() {\n    match thread::spawn(move || panic!()).join() {\n        result::Result::Err(_) => (),\n        result::Result::Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_spawn_sched() {\n    let (tx, rx) = channel();\n\n    fn f(i: i32, tx: Sender<()>) {\n        let tx = tx.clone();\n        thread::spawn(move || {\n            if i == 0 {\n                tx.send(()).unwrap();\n            } else {\n                f(i - 1, tx);\n            }\n        });\n    }\n    f(10, tx);\n    rx.recv().unwrap();\n}\n\n#[test]\nfn test_spawn_sched_childs_on_default_sched() {\n    let (tx, rx) = channel();\n\n    thread::spawn(move || {\n        thread::spawn(move || {\n            tx.send(()).unwrap();\n        });\n    });\n\n    rx.recv().unwrap();\n}\n\nfn avoid_copying_the_body<F>(spawnfn: F)\nwhere\n    F: FnOnce(Box<dyn Fn() + Send>),\n{\n    let (tx, rx) = channel();\n\n    let x: Box<_> = box 1;\n    let x_in_parent = (&*x) as *const i32 as usize;\n\n    spawnfn(Box::new(move || {\n        let x_in_child = (&*x) as *const i32 as usize;\n        tx.send(x_in_child).unwrap();\n    }));\n\n    let x_in_child = rx.recv().unwrap();\n    assert_eq!(x_in_parent, x_in_child);\n}\n\n#[test]\nfn test_avoid_copying_the_body_spawn() {\n    avoid_copying_the_body(|v| {\n        thread::spawn(move || v());\n    });\n}\n\n#[test]\nfn test_avoid_copying_the_body_thread_spawn() {\n    avoid_copying_the_body(|f| {\n        thread::spawn(move || {\n            f();\n        });\n    })\n}\n\n#[test]\nfn test_avoid_copying_the_body_join() {\n    avoid_copying_the_body(|f| {\n        let _ = thread::spawn(move || f()).join();\n    })\n}\n\n#[test]\nfn test_child_doesnt_ref_parent() {\n    // If the child refcounts the parent thread, this will stack overflow when\n    // climbing the thread tree to dereference each ancestor. (See #1789)\n    // (well, it would if the constant were 8000+ - I lowered it to be more\n    // valgrind-friendly. try this at home, instead..!)\n    const GENERATIONS: u32 = 16;\n    fn child_no(x: u32) -> Box<dyn Fn() + Send> {\n        return Box::new(move || {\n            if x < GENERATIONS {\n                thread::spawn(move || child_no(x + 1)());\n            }\n        });\n    }\n    thread::spawn(|| child_no(0)());\n}\n\n#[test]\nfn test_simple_newsched_spawn() {\n    thread::spawn(move || {});\n}\n\n#[test]\nfn test_try_panic_message_static_str() {\n    match thread::spawn(move || {\n        panic!(\"static string\");\n    })\n    .join()\n    {\n        Err(e) => {\n            type T = &'static str;\n            assert!(e.is::<T>());\n            assert_eq!(*e.downcast::<T>().unwrap(), \"static string\");\n        }\n        Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_try_panic_message_owned_str() {\n    match thread::spawn(move || {\n        panic!(\"owned string\".to_string());\n    })\n    .join()\n    {\n        Err(e) => {\n            type T = String;\n            assert!(e.is::<T>());\n            assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\".to_string());\n        }\n        Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_try_panic_message_any() {\n    match thread::spawn(move || {\n        panic!(box 413u16 as Box<dyn Any + Send>);\n    })\n    .join()\n    {\n        Err(e) => {\n            type T = Box<dyn Any + Send>;\n            assert!(e.is::<T>());\n            let any = e.downcast::<T>().unwrap();\n            assert!(any.is::<u16>());\n            assert_eq!(*any.downcast::<u16>().unwrap(), 413);\n        }\n        Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_try_panic_message_unit_struct() {\n    struct Juju;\n\n    match thread::spawn(move || panic!(Juju)).join() {\n        Err(ref e) if e.is::<Juju>() => {}\n        Err(_) | Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_park_timeout_unpark_before() {\n    for _ in 0..10 {\n        thread::current().unpark();\n        thread::park_timeout(Duration::from_millis(u32::MAX as u64));\n    }\n}\n\n#[test]\nfn test_park_timeout_unpark_not_called() {\n    for _ in 0..10 {\n        thread::park_timeout(Duration::from_millis(10));\n    }\n}\n\n#[test]\nfn test_park_timeout_unpark_called_other_thread() {\n    for _ in 0..10 {\n        let th = thread::current();\n\n        let _guard = thread::spawn(move || {\n            super::sleep(Duration::from_millis(50));\n            th.unpark();\n        });\n\n        thread::park_timeout(Duration::from_millis(u32::MAX as u64));\n    }\n}\n\n#[test]\nfn sleep_ms_smoke() {\n    thread::sleep(Duration::from_millis(2));\n}\n\n#[test]\nfn test_size_of_option_thread_id() {\n    assert_eq!(mem::size_of::<Option<ThreadId>>(), mem::size_of::<ThreadId>());\n}\n\n#[test]\nfn test_thread_id_equal() {\n    assert!(thread::current().id() == thread::current().id());\n}\n\n#[test]\nfn test_thread_id_not_equal() {\n    let spawned_id = thread::spawn(|| thread::current().id()).join().unwrap();\n    assert!(thread::current().id() != spawned_id);\n}\n\n// NOTE: the corresponding test for stderr is in ui/thread-stderr, due\n// to the test harness apparently interfering with stderr configuration.\n"],["2580","use test::Bencher;\n\n#[bench]\nfn bench_pow_function(b: &mut Bencher) {\n    let v = (0..1024).collect::<Vec<u32>>();\n    b.iter(|| {\n        v.iter().fold(0u32, |old, new| old.pow(*new as u32));\n    });\n}\n"],["2581","use crate::ops::Mul;\n\n#[test]\nfn test_saturating_add_uint() {\n    assert_eq!(3_usize.saturating_add(5_usize), 8_usize);\n    assert_eq!(3_usize.saturating_add(usize::MAX - 1), usize::MAX);\n    assert_eq!(usize::MAX.saturating_add(usize::MAX), usize::MAX);\n    assert_eq!((usize::MAX - 2).saturating_add(1), usize::MAX - 1);\n}\n\n#[test]\nfn test_saturating_sub_uint() {\n    assert_eq!(5_usize.saturating_sub(3_usize), 2_usize);\n    assert_eq!(3_usize.saturating_sub(5_usize), 0_usize);\n    assert_eq!(0_usize.saturating_sub(1_usize), 0_usize);\n    assert_eq!((usize::MAX - 1).saturating_sub(usize::MAX), 0);\n}\n\n#[test]\nfn test_saturating_add_int() {\n    assert_eq!(3i32.saturating_add(5), 8);\n    assert_eq!(3isize.saturating_add(isize::MAX - 1), isize::MAX);\n    assert_eq!(isize::MAX.saturating_add(isize::MAX), isize::MAX);\n    assert_eq!((isize::MAX - 2).saturating_add(1), isize::MAX - 1);\n    assert_eq!(3i32.saturating_add(-5), -2);\n    assert_eq!(isize::MIN.saturating_add(-1), isize::MIN);\n    assert_eq!((-2isize).saturating_add(-isize::MAX), isize::MIN);\n}\n\n#[test]\nfn test_saturating_sub_int() {\n    assert_eq!(3i32.saturating_sub(5), -2);\n    assert_eq!(isize::MIN.saturating_sub(1), isize::MIN);\n    assert_eq!((-2isize).saturating_sub(isize::MAX), isize::MIN);\n    assert_eq!(3i32.saturating_sub(-5), 8);\n    assert_eq!(3isize.saturating_sub(-(isize::MAX - 1)), isize::MAX);\n    assert_eq!(isize::MAX.saturating_sub(-isize::MAX), isize::MAX);\n    assert_eq!((isize::MAX - 2).saturating_sub(-1), isize::MAX - 1);\n}\n\n#[test]\nfn test_checked_add() {\n    let five_less = usize::MAX - 5;\n    assert_eq!(five_less.checked_add(0), Some(usize::MAX - 5));\n    assert_eq!(five_less.checked_add(1), Some(usize::MAX - 4));\n    assert_eq!(five_less.checked_add(2), Some(usize::MAX - 3));\n    assert_eq!(five_less.checked_add(3), Some(usize::MAX - 2));\n    assert_eq!(five_less.checked_add(4), Some(usize::MAX - 1));\n    assert_eq!(five_less.checked_add(5), Some(usize::MAX));\n    assert_eq!(five_less.checked_add(6), None);\n    assert_eq!(five_less.checked_add(7), None);\n}\n\n#[test]\nfn test_checked_sub() {\n    assert_eq!(5_usize.checked_sub(0), Some(5));\n    assert_eq!(5_usize.checked_sub(1), Some(4));\n    assert_eq!(5_usize.checked_sub(2), Some(3));\n    assert_eq!(5_usize.checked_sub(3), Some(2));\n    assert_eq!(5_usize.checked_sub(4), Some(1));\n    assert_eq!(5_usize.checked_sub(5), Some(0));\n    assert_eq!(5_usize.checked_sub(6), None);\n    assert_eq!(5_usize.checked_sub(7), None);\n}\n\n#[test]\nfn test_checked_mul() {\n    let third = usize::MAX / 3;\n    assert_eq!(third.checked_mul(0), Some(0));\n    assert_eq!(third.checked_mul(1), Some(third));\n    assert_eq!(third.checked_mul(2), Some(third * 2));\n    assert_eq!(third.checked_mul(3), Some(third * 3));\n    assert_eq!(third.checked_mul(4), None);\n}\n\nmacro_rules! test_is_power_of_two {\n    ($test_name:ident, $T:ident) => {\n        #[test]\n        fn $test_name() {\n            assert_eq!((0 as $T).is_power_of_two(), false);\n            assert_eq!((1 as $T).is_power_of_two(), true);\n            assert_eq!((2 as $T).is_power_of_two(), true);\n            assert_eq!((3 as $T).is_power_of_two(), false);\n            assert_eq!((4 as $T).is_power_of_two(), true);\n            assert_eq!((5 as $T).is_power_of_two(), false);\n            assert_eq!(($T::MAX / 2 + 1).is_power_of_two(), true);\n        }\n    };\n}\n\ntest_is_power_of_two! { test_is_power_of_two_u8, u8 }\ntest_is_power_of_two! { test_is_power_of_two_u16, u16 }\ntest_is_power_of_two! { test_is_power_of_two_u32, u32 }\ntest_is_power_of_two! { test_is_power_of_two_u64, u64 }\ntest_is_power_of_two! { test_is_power_of_two_uint, usize }\n\nmacro_rules! test_next_power_of_two {\n    ($test_name:ident, $T:ident) => {\n        #[test]\n        fn $test_name() {\n            assert_eq!((0 as $T).next_power_of_two(), 1);\n            let mut next_power = 1;\n            for i in 1 as $T..40 {\n                assert_eq!(i.next_power_of_two(), next_power);\n                if i == next_power {\n                    next_power *= 2\n                }\n            }\n        }\n    };\n}\n\ntest_next_power_of_two! { test_next_power_of_two_u8, u8 }\ntest_next_power_of_two! { test_next_power_of_two_u16, u16 }\ntest_next_power_of_two! { test_next_power_of_two_u32, u32 }\ntest_next_power_of_two! { test_next_power_of_two_u64, u64 }\ntest_next_power_of_two! { test_next_power_of_two_uint, usize }\n\nmacro_rules! test_checked_next_power_of_two {\n    ($test_name:ident, $T:ident) => {\n        #[test]\n        fn $test_name() {\n            assert_eq!((0 as $T).checked_next_power_of_two(), Some(1));\n            let smax = $T::MAX >> 1;\n            assert_eq!(smax.checked_next_power_of_two(), Some(smax + 1));\n            assert_eq!((smax + 1).checked_next_power_of_two(), Some(smax + 1));\n            assert_eq!((smax + 2).checked_next_power_of_two(), None);\n            assert_eq!(($T::MAX - 1).checked_next_power_of_two(), None);\n            assert_eq!($T::MAX.checked_next_power_of_two(), None);\n            let mut next_power = 1;\n            for i in 1 as $T..40 {\n                assert_eq!(i.checked_next_power_of_two(), Some(next_power));\n                if i == next_power {\n                    next_power *= 2\n                }\n            }\n        }\n    };\n}\n\ntest_checked_next_power_of_two! { test_checked_next_power_of_two_u8, u8 }\ntest_checked_next_power_of_two! { test_checked_next_power_of_two_u16, u16 }\ntest_checked_next_power_of_two! { test_checked_next_power_of_two_u32, u32 }\ntest_checked_next_power_of_two! { test_checked_next_power_of_two_u64, u64 }\ntest_checked_next_power_of_two! { test_checked_next_power_of_two_uint, usize }\n\n#[test]\nfn test_pow() {\n    fn naive_pow<T: Mul<Output = T> + Copy>(one: T, base: T, exp: usize) -> T {\n        (0..exp).fold(one, |acc, _| acc * base)\n    }\n    macro_rules! assert_pow {\n        (($num:expr, $exp:expr) => $expected:expr) => {{\n            let result = $num.pow($exp);\n            assert_eq!(result, $expected);\n            assert_eq!(result, naive_pow(1, $num, $exp));\n        }};\n    }\n    assert_pow!((3u32,     0 ) => 1);\n    assert_pow!((5u32,     1 ) => 5);\n    assert_pow!((-4i32,    2 ) => 16);\n    assert_pow!((8u32,     3 ) => 512);\n    assert_pow!((2u64,     50) => 1125899906842624);\n}\n\n#[test]\nfn test_uint_to_str_overflow() {\n    let mut u8_val: u8 = 255;\n    assert_eq!(u8_val.to_string(), \"255\");\n\n    u8_val = u8_val.wrapping_add(1);\n    assert_eq!(u8_val.to_string(), \"0\");\n\n    let mut u16_val: u16 = 65_535;\n    assert_eq!(u16_val.to_string(), \"65535\");\n\n    u16_val = u16_val.wrapping_add(1);\n    assert_eq!(u16_val.to_string(), \"0\");\n\n    let mut u32_val: u32 = 4_294_967_295;\n    assert_eq!(u32_val.to_string(), \"4294967295\");\n\n    u32_val = u32_val.wrapping_add(1);\n    assert_eq!(u32_val.to_string(), \"0\");\n\n    let mut u64_val: u64 = 18_446_744_073_709_551_615;\n    assert_eq!(u64_val.to_string(), \"18446744073709551615\");\n\n    u64_val = u64_val.wrapping_add(1);\n    assert_eq!(u64_val.to_string(), \"0\");\n}\n\nfn from_str<T: crate::str::FromStr>(t: &str) -> Option<T> {\n    crate::str::FromStr::from_str(t).ok()\n}\n\n#[test]\nfn test_uint_from_str_overflow() {\n    let mut u8_val: u8 = 255;\n    assert_eq!(from_str::<u8>(\"255\"), Some(u8_val));\n    assert_eq!(from_str::<u8>(\"256\"), None);\n\n    u8_val = u8_val.wrapping_add(1);\n    assert_eq!(from_str::<u8>(\"0\"), Some(u8_val));\n    assert_eq!(from_str::<u8>(\"-1\"), None);\n\n    let mut u16_val: u16 = 65_535;\n    assert_eq!(from_str::<u16>(\"65535\"), Some(u16_val));\n    assert_eq!(from_str::<u16>(\"65536\"), None);\n\n    u16_val = u16_val.wrapping_add(1);\n    assert_eq!(from_str::<u16>(\"0\"), Some(u16_val));\n    assert_eq!(from_str::<u16>(\"-1\"), None);\n\n    let mut u32_val: u32 = 4_294_967_295;\n    assert_eq!(from_str::<u32>(\"4294967295\"), Some(u32_val));\n    assert_eq!(from_str::<u32>(\"4294967296\"), None);\n\n    u32_val = u32_val.wrapping_add(1);\n    assert_eq!(from_str::<u32>(\"0\"), Some(u32_val));\n    assert_eq!(from_str::<u32>(\"-1\"), None);\n\n    let mut u64_val: u64 = 18_446_744_073_709_551_615;\n    assert_eq!(from_str::<u64>(\"18446744073709551615\"), Some(u64_val));\n    assert_eq!(from_str::<u64>(\"18446744073709551616\"), None);\n\n    u64_val = u64_val.wrapping_add(1);\n    assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n    assert_eq!(from_str::<u64>(\"-1\"), None);\n}\n"],["2582","//! Support for capturing a stack backtrace of an OS thread\n//!\n//! This module contains the support necessary to capture a stack backtrace of a\n//! running OS thread from the OS thread itself. The `Backtrace` type supports\n//! capturing a stack trace via the `Backtrace::capture` and\n//! `Backtrace::force_capture` functions.\n//!\n//! A backtrace is typically quite handy to attach to errors (e.g. types\n//! implementing `std::error::Error`) to get a causal chain of where an error\n//! was generated.\n//!\n//! > **Note**: this module is unstable and is designed in [RFC 2504], and you\n//! > can learn more about its status in the [tracking issue].\n//!\n//! [RFC 2504]: https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md\n//! [tracking issue]: https://github.com/rust-lang/rust/issues/53487\n//!\n//! ## Accuracy\n//!\n//! Backtraces are attempted to be as accurate as possible, but no guarantees\n//! are provided about the exact accuracy of a backtrace. Instruction pointers,\n//! symbol names, filenames, line numbers, etc, may all be incorrect when\n//! reported. Accuracy is attempted on a best-effort basis, however, and bugs\n//! are always welcome to indicate areas of improvement!\n//!\n//! For most platforms a backtrace with a filename/line number requires that\n//! programs be compiled with debug information. Without debug information\n//! filenames/line numbers will not be reported.\n//!\n//! ## Platform support\n//!\n//! Not all platforms that libstd compiles for support capturing backtraces.\n//! Some platforms simply do nothing when capturing a backtrace. To check\n//! whether the platform supports capturing backtraces you can consult the\n//! `BacktraceStatus` enum as a result of `Backtrace::status`.\n//!\n//! Like above with accuracy platform support is done on a best effort basis.\n//! Sometimes libraries may not be available at runtime or something may go\n//! wrong which would cause a backtrace to not be captured. Please feel free to\n//! report issues with platforms where a backtrace cannot be captured though!\n//!\n//! ## Environment Variables\n//!\n//! The `Backtrace::capture` function may not actually capture a backtrace by\n//! default. Its behavior is governed by two environment variables:\n//!\n//! * `RUST_LIB_BACKTRACE` - if this is set to `0` then `Backtrace::capture`\n//!   will never capture a backtrace. Any other value this is set to will enable\n//!   `Backtrace::capture`.\n//!\n//! * `RUST_BACKTRACE` - if `RUST_LIB_BACKTRACE` is not set, then this variable\n//!   is consulted with the same rules of `RUST_LIB_BACKTRACE`.\n//!\n//! * If neither of the above env vars are set, then `Backtrace::capture` will\n//!   be disabled.\n//!\n//! Capturing a backtrace can be a quite expensive runtime operation, so the\n//! environment variables allow either forcibly disabling this runtime\n//! performance hit or allow selectively enabling it in some programs.\n//!\n//! Note that the `Backtrace::force_capture` function can be used to ignore\n//! these environment variables. Also note that the state of environment\n//! variables is cached once the first backtrace is created, so altering\n//! `RUST_LIB_BACKTRACE` or `RUST_BACKTRACE` at runtime may not actually change\n//! how backtraces are captured.\n\n#![unstable(feature = \"backtrace\", issue = \"53487\")]\n\n#[cfg(test)]\nmod tests;\n\n// NB: A note on resolution of a backtrace:\n//\n// Backtraces primarily happen in two steps, one is where we actually capture\n// the stack backtrace, giving us a list of instruction pointers corresponding\n// to stack frames. Next we take these instruction pointers and, one-by-one,\n// turn them into a human readable name (like `main`).\n//\n// The first phase can be somewhat expensive (walking the stack), especially\n// on MSVC where debug information is consulted to return inline frames each as\n// their own frame. The second phase, however, is almost always extremely\n// expensive (on the order of milliseconds sometimes) when it's consulting debug\n// information.\n//\n// We attempt to amortize this cost as much as possible by delaying resolution\n// of an address to a human readable name for as long as possible. When\n// `Backtrace::create` is called to capture a backtrace it doesn't actually\n// perform any symbol resolution, but rather we lazily resolve symbols only just\n// before they're needed for printing. This way we can make capturing a\n// backtrace and throwing it away much cheaper, but actually printing a\n// backtrace is still basically the same cost.\n//\n// This strategy comes at the cost of some synchronization required inside of a\n// `Backtrace`, but that's a relatively small price to pay relative to capturing\n// a backtrace or actually symbolizing it.\n\nuse crate::backtrace_rs::{self, BytesOrWideString};\nuse crate::cell::UnsafeCell;\nuse crate::env;\nuse crate::ffi::c_void;\nuse crate::fmt;\nuse crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nuse crate::sync::Once;\nuse crate::sys_common::backtrace::{lock, output_filename};\nuse crate::vec::Vec;\n\n/// A captured OS thread stack backtrace.\n///\n/// This type represents a stack backtrace for an OS thread captured at a\n/// previous point in time. In some instances the `Backtrace` type may\n/// internally be empty due to configuration. For more information see\n/// `Backtrace::capture`.\npub struct Backtrace {\n    inner: Inner,\n}\n\n/// The current status of a backtrace, indicating whether it was captured or\n/// whether it is empty for some other reason.\n#[non_exhaustive]\n#[derive(Debug, PartialEq, Eq)]\npub enum BacktraceStatus {\n    /// Capturing a backtrace is not supported, likely because it's not\n    /// implemented for the current platform.\n    Unsupported,\n    /// Capturing a backtrace has been disabled through either the\n    /// `RUST_LIB_BACKTRACE` or `RUST_BACKTRACE` environment variables.\n    Disabled,\n    /// A backtrace has been captured and the `Backtrace` should print\n    /// reasonable information when rendered.\n    Captured,\n}\n\nenum Inner {\n    Unsupported,\n    Disabled,\n    Captured(LazilyResolvedCapture),\n}\n\nstruct Capture {\n    actual_start: usize,\n    resolved: bool,\n    frames: Vec<BacktraceFrame>,\n}\n\nfn _assert_send_sync() {\n    fn _assert<T: Send + Sync>() {}\n    _assert::<Backtrace>();\n}\n\n/// A single frame of a backtrace.\n#[unstable(feature = \"backtrace_frames\", issue = \"79676\")]\npub struct BacktraceFrame {\n    frame: RawFrame,\n    symbols: Vec<BacktraceSymbol>,\n}\n\n#[derive(Debug)]\nenum RawFrame {\n    Actual(backtrace_rs::Frame),\n    #[cfg(test)]\n    Fake,\n}\n\nstruct BacktraceSymbol {\n    name: Option<Vec<u8>>,\n    filename: Option<BytesOrWide>,\n    lineno: Option<u32>,\n    colno: Option<u32>,\n}\n\nenum BytesOrWide {\n    Bytes(Vec<u8>),\n    Wide(Vec<u16>),\n}\n\nimpl fmt::Debug for Backtrace {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let capture = match &self.inner {\n            Inner::Unsupported => return fmt.write_str(\"<unsupported>\"),\n            Inner::Disabled => return fmt.write_str(\"<disabled>\"),\n            Inner::Captured(c) => c.force(),\n        };\n\n        let frames = &capture.frames[capture.actual_start..];\n\n        write!(fmt, \"Backtrace \")?;\n\n        let mut dbg = fmt.debug_list();\n\n        for frame in frames {\n            if frame.frame.ip().is_null() {\n                continue;\n            }\n\n            dbg.entries(&frame.symbols);\n        }\n\n        dbg.finish()\n    }\n}\n\nimpl fmt::Debug for BacktraceFrame {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut dbg = fmt.debug_list();\n        dbg.entries(&self.symbols);\n        dbg.finish()\n    }\n}\n\nimpl fmt::Debug for BacktraceSymbol {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // FIXME: improve formatting: https://github.com/rust-lang/rust/issues/65280\n        // FIXME: Also, include column numbers into the debug format as Display already has them.\n        // Until there are stable per-frame accessors, the format shouldn't be changed:\n        // https://github.com/rust-lang/rust/issues/65280#issuecomment-638966585\n        write!(fmt, \"{{ \")?;\n\n        if let Some(fn_name) = self.name.as_ref().map(|b| backtrace_rs::SymbolName::new(b)) {\n            write!(fmt, \"fn: \\\"{:#}\\\"\", fn_name)?;\n        } else {\n            write!(fmt, \"fn: <unknown>\")?;\n        }\n\n        if let Some(fname) = self.filename.as_ref() {\n            write!(fmt, \", file: \\\"{:?}\\\"\", fname)?;\n        }\n\n        if let Some(line) = self.lineno {\n            write!(fmt, \", line: {:?}\", line)?;\n        }\n\n        write!(fmt, \" }}\")\n    }\n}\n\nimpl fmt::Debug for BytesOrWide {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        output_filename(\n            fmt,\n            match self {\n                BytesOrWide::Bytes(w) => BytesOrWideString::Bytes(w),\n                BytesOrWide::Wide(w) => BytesOrWideString::Wide(w),\n            },\n            backtrace_rs::PrintFmt::Short,\n            crate::env::current_dir().as_ref().ok(),\n        )\n    }\n}\n\nimpl Backtrace {\n    /// Returns whether backtrace captures are enabled through environment\n    /// variables.\n    fn enabled() -> bool {\n        // Cache the result of reading the environment variables to make\n        // backtrace captures speedy, because otherwise reading environment\n        // variables every time can be somewhat slow.\n        static ENABLED: AtomicUsize = AtomicUsize::new(0);\n        match ENABLED.load(SeqCst) {\n            0 => {}\n            1 => return false,\n            _ => return true,\n        }\n        let enabled = match env::var(\"RUST_LIB_BACKTRACE\") {\n            Ok(s) => s != \"0\",\n            Err(_) => match env::var(\"RUST_BACKTRACE\") {\n                Ok(s) => s != \"0\",\n                Err(_) => false,\n            },\n        };\n        ENABLED.store(enabled as usize + 1, SeqCst);\n        enabled\n    }\n\n    /// Capture a stack backtrace of the current thread.\n    ///\n    /// This function will capture a stack backtrace of the current OS thread of\n    /// execution, returning a `Backtrace` type which can be later used to print\n    /// the entire stack trace or render it to a string.\n    ///\n    /// This function will be a noop if the `RUST_BACKTRACE` or\n    /// `RUST_LIB_BACKTRACE` backtrace variables are both not set. If either\n    /// environment variable is set and enabled then this function will actually\n    /// capture a backtrace. Capturing a backtrace can be both memory intensive\n    /// and slow, so these environment variables allow liberally using\n    /// `Backtrace::capture` and only incurring a slowdown when the environment\n    /// variables are set.\n    ///\n    /// To forcibly capture a backtrace regardless of environment variables, use\n    /// the `Backtrace::force_capture` function.\n    #[inline(never)] // want to make sure there's a frame here to remove\n    pub fn capture() -> Backtrace {\n        if !Backtrace::enabled() {\n            return Backtrace { inner: Inner::Disabled };\n        }\n        Backtrace::create(Backtrace::capture as usize)\n    }\n\n    /// Forcibly captures a full backtrace, regardless of environment variable\n    /// configuration.\n    ///\n    /// This function behaves the same as `capture` except that it ignores the\n    /// values of the `RUST_BACKTRACE` and `RUST_LIB_BACKTRACE` environment\n    /// variables, always capturing a backtrace.\n    ///\n    /// Note that capturing a backtrace can be an expensive operation on some\n    /// platforms, so this should be used with caution in performance-sensitive\n    /// parts of code.\n    #[inline(never)] // want to make sure there's a frame here to remove\n    pub fn force_capture() -> Backtrace {\n        Backtrace::create(Backtrace::force_capture as usize)\n    }\n\n    /// Forcibly captures a disabled backtrace, regardless of environment\n    /// variable configuration.\n    pub const fn disabled() -> Backtrace {\n        Backtrace { inner: Inner::Disabled }\n    }\n\n    // Capture a backtrace which start just before the function addressed by\n    // `ip`\n    fn create(ip: usize) -> Backtrace {\n        // SAFETY: We don't attempt to lock this reentrantly.\n        let _lock = unsafe { lock() };\n        let mut frames = Vec::new();\n        let mut actual_start = None;\n        unsafe {\n            backtrace_rs::trace_unsynchronized(|frame| {\n                frames.push(BacktraceFrame {\n                    frame: RawFrame::Actual(frame.clone()),\n                    symbols: Vec::new(),\n                });\n                if frame.symbol_address() as usize == ip && actual_start.is_none() {\n                    actual_start = Some(frames.len());\n                }\n                true\n            });\n        }\n\n        // If no frames came out assume that this is an unsupported platform\n        // since `backtrace` doesn't provide a way of learning this right now,\n        // and this should be a good enough approximation.\n        let inner = if frames.is_empty() {\n            Inner::Unsupported\n        } else {\n            Inner::Captured(LazilyResolvedCapture::new(Capture {\n                actual_start: actual_start.unwrap_or(0),\n                frames,\n                resolved: false,\n            }))\n        };\n\n        Backtrace { inner }\n    }\n\n    /// Returns the status of this backtrace, indicating whether this backtrace\n    /// request was unsupported, disabled, or a stack trace was actually\n    /// captured.\n    pub fn status(&self) -> BacktraceStatus {\n        match self.inner {\n            Inner::Unsupported => BacktraceStatus::Unsupported,\n            Inner::Disabled => BacktraceStatus::Disabled,\n            Inner::Captured(_) => BacktraceStatus::Captured,\n        }\n    }\n}\n\nimpl<'a> Backtrace {\n    /// Returns an iterator over the backtrace frames.\n    #[unstable(feature = \"backtrace_frames\", issue = \"79676\")]\n    pub fn frames(&'a self) -> &'a [BacktraceFrame] {\n        if let Inner::Captured(c) = &self.inner { &c.force().frames } else { &[] }\n    }\n}\n\nimpl fmt::Display for Backtrace {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let capture = match &self.inner {\n            Inner::Unsupported => return fmt.write_str(\"unsupported backtrace\"),\n            Inner::Disabled => return fmt.write_str(\"disabled backtrace\"),\n            Inner::Captured(c) => c.force(),\n        };\n\n        let full = fmt.alternate();\n        let (frames, style) = if full {\n            (&capture.frames[..], backtrace_rs::PrintFmt::Full)\n        } else {\n            (&capture.frames[capture.actual_start..], backtrace_rs::PrintFmt::Short)\n        };\n\n        // When printing paths we try to strip the cwd if it exists, otherwise\n        // we just print the path as-is. Note that we also only do this for the\n        // short format, because if it's full we presumably want to print\n        // everything.\n        let cwd = crate::env::current_dir();\n        let mut print_path = move |fmt: &mut fmt::Formatter<'_>, path: BytesOrWideString<'_>| {\n            output_filename(fmt, path, style, cwd.as_ref().ok())\n        };\n\n        let mut f = backtrace_rs::BacktraceFmt::new(fmt, style, &mut print_path);\n        f.add_context()?;\n        for frame in frames {\n            if frame.symbols.is_empty() {\n                f.frame().print_raw(frame.frame.ip(), None, None, None)?;\n            } else {\n                for symbol in frame.symbols.iter() {\n                    f.frame().print_raw_with_column(\n                        frame.frame.ip(),\n                        symbol.name.as_ref().map(|b| backtrace_rs::SymbolName::new(b)),\n                        symbol.filename.as_ref().map(|b| match b {\n                            BytesOrWide::Bytes(w) => BytesOrWideString::Bytes(w),\n                            BytesOrWide::Wide(w) => BytesOrWideString::Wide(w),\n                        }),\n                        symbol.lineno,\n                        symbol.colno,\n                    )?;\n                }\n            }\n        }\n        f.finish()?;\n        Ok(())\n    }\n}\n\nstruct LazilyResolvedCapture {\n    sync: Once,\n    capture: UnsafeCell<Capture>,\n}\n\nimpl LazilyResolvedCapture {\n    fn new(capture: Capture) -> Self {\n        LazilyResolvedCapture { sync: Once::new(), capture: UnsafeCell::new(capture) }\n    }\n\n    fn force(&self) -> &Capture {\n        self.sync.call_once(|| {\n            // SAFETY: This exclusive reference can't overlap with any others\n            // `Once` guarantees callers will block until this closure returns\n            // `Once` also guarantees only a single caller will enter this closure\n            unsafe { &mut *self.capture.get() }.resolve();\n        });\n\n        // SAFETY: This shared reference can't overlap with the exclusive reference above\n        unsafe { &*self.capture.get() }\n    }\n}\n\n// SAFETY: Access to the inner value is synchronized using a thread-safe `Once`\n// So long as `Capture` is `Sync`, `LazilyResolvedCapture` is too\nunsafe impl Sync for LazilyResolvedCapture where Capture: Sync {}\n\nimpl Capture {\n    fn resolve(&mut self) {\n        // If we're already resolved, nothing to do!\n        if self.resolved {\n            return;\n        }\n        self.resolved = true;\n\n        // Use the global backtrace lock to synchronize this as it's a\n        // requirement of the `backtrace` crate, and then actually resolve\n        // everything.\n        // SAFETY: We don't attempt to lock this reentrantly.\n        let _lock = unsafe { lock() };\n        for frame in self.frames.iter_mut() {\n            let symbols = &mut frame.symbols;\n            let frame = match &frame.frame {\n                RawFrame::Actual(frame) => frame,\n                #[cfg(test)]\n                RawFrame::Fake => unimplemented!(),\n            };\n            unsafe {\n                backtrace_rs::resolve_frame_unsynchronized(frame, |symbol| {\n                    symbols.push(BacktraceSymbol {\n                        name: symbol.name().map(|m| m.as_bytes().to_vec()),\n                        filename: symbol.filename_raw().map(|b| match b {\n                            BytesOrWideString::Bytes(b) => BytesOrWide::Bytes(b.to_owned()),\n                            BytesOrWideString::Wide(b) => BytesOrWide::Wide(b.to_owned()),\n                        }),\n                        lineno: symbol.lineno(),\n                        colno: symbol.colno(),\n                    });\n                });\n            }\n        }\n    }\n}\n\nimpl RawFrame {\n    fn ip(&self) -> *mut c_void {\n        match self {\n            RawFrame::Actual(frame) => frame.ip(),\n            #[cfg(test)]\n            RawFrame::Fake => 1 as *mut c_void,\n        }\n    }\n}\n"],["2583","//! Standard library macros\n//!\n//! This module contains a set of macros which are exported from the standard\n//! library. Each macro is available for use when linking against the standard\n//! library.\n\n#[doc = include_str!(\"../../core/src/macros/panic.md\")]\n#[macro_export]\n#[rustc_builtin_macro = \"std_panic\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(edition_panic)]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"std_panic_macro\")]\nmacro_rules! panic {\n    // Expands to either `$crate::panic::panic_2015` or `$crate::panic::panic_2021`\n    // depending on the edition of the caller.\n    ($($arg:tt)*) => {\n        /* compiler built-in */\n    };\n}\n\n/// Prints to the standard output.\n///\n/// Equivalent to the [`println!`] macro except that a newline is not printed at\n/// the end of the message.\n///\n/// Note that stdout is frequently line-buffered by default so it may be\n/// necessary to use [`io::stdout().flush()`][flush] to ensure the output is emitted\n/// immediately.\n///\n/// Use `print!` only for the primary output of your program. Use\n/// [`eprint!`] instead to print error and progress messages.\n///\n/// [flush]: crate::io::Write::flush\n///\n/// # Panics\n///\n/// Panics if writing to `io::stdout()` fails.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{self, Write};\n///\n/// print!(\"this \");\n/// print!(\"will \");\n/// print!(\"be \");\n/// print!(\"on \");\n/// print!(\"the \");\n/// print!(\"same \");\n/// print!(\"line \");\n///\n/// io::stdout().flush().unwrap();\n///\n/// print!(\"this string has a newline, why not choose println! instead?\\n\");\n///\n/// io::stdout().flush().unwrap();\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! print {\n    ($($arg:tt)*) => ($crate::io::_print($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard output, with a newline.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`)).\n///\n/// Use the [`format!`] syntax to write data to the standard output.\n/// See [`std::fmt`] for more information.\n///\n/// Use `println!` only for the primary output of your program. Use\n/// [`eprintln!`] instead to print error and progress messages.\n///\n/// [`std::fmt`]: crate::fmt\n///\n/// # Panics\n///\n/// Panics if writing to [`io::stdout`] fails.\n///\n/// [`io::stdout`]: crate::io::stdout\n///\n/// # Examples\n///\n/// ```\n/// println!(); // prints just a newline\n/// println!(\"hello there!\");\n/// println!(\"format {} arguments\", \"some\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints to the standard error.\n///\n/// Equivalent to the [`print!`] macro, except that output goes to\n/// [`io::stderr`] instead of [`io::stdout`]. See [`print!`] for\n/// example usage.\n///\n/// Use `eprint!` only for error and progress messages. Use `print!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: crate::io::stderr\n/// [`io::stdout`]: crate::io::stdout\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprint!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! eprint {\n    ($($arg:tt)*) => ($crate::io::_eprint($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard error, with a newline.\n///\n/// Equivalent to the [`println!`] macro, except that output goes to\n/// [`io::stderr`] instead of [`io::stdout`]. See [`println!`] for\n/// example usage.\n///\n/// Use `eprintln!` only for error and progress messages. Use `println!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: crate::io::stderr\n/// [`io::stdout`]: crate::io::stdout\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprintln!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! eprintln {\n    () => ($crate::eprint!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_eprint($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints and returns the value of a given expression for quick and dirty\n/// debugging.\n///\n/// An example:\n///\n/// ```rust\n/// let a = 2;\n/// let b = dbg!(a * 2) + 1;\n/// //      ^-- prints: [src/main.rs:2] a * 2 = 4\n/// assert_eq!(b, 5);\n/// ```\n///\n/// The macro works by using the `Debug` implementation of the type of\n/// the given expression to print the value to [stderr] along with the\n/// source location of the macro invocation as well as the source code\n/// of the expression.\n///\n/// Invoking the macro on an expression moves and takes ownership of it\n/// before returning the evaluated expression unchanged. If the type\n/// of the expression does not implement `Copy` and you don't want\n/// to give up ownership, you can instead borrow with `dbg!(&expr)`\n/// for some expression `expr`.\n///\n/// The `dbg!` macro works exactly the same in release builds.\n/// This is useful when debugging issues that only occur in release\n/// builds or when debugging in release mode is significantly faster.\n///\n/// Note that the macro is intended as a debugging tool and therefore you\n/// should avoid having uses of it in version control for long periods\n/// (other than in tests and similar).\n/// Debug output from production code is better done with other facilities\n/// such as the [`debug!`] macro from the [`log`] crate.\n///\n/// # Stability\n///\n/// The exact output printed by this macro should not be relied upon\n/// and is subject to future changes.\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Further examples\n///\n/// With a method call:\n///\n/// ```rust\n/// fn foo(n: usize) {\n///     if let Some(_) = dbg!(n.checked_sub(4)) {\n///         // ...\n///     }\n/// }\n///\n/// foo(3)\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:4] n.checked_sub(4) = None\n/// ```\n///\n/// Naive factorial implementation:\n///\n/// ```rust\n/// fn factorial(n: u32) -> u32 {\n///     if dbg!(n <= 1) {\n///         dbg!(1)\n///     } else {\n///         dbg!(n * factorial(n - 1))\n///     }\n/// }\n///\n/// dbg!(factorial(4));\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = true\n/// [src/main.rs:4] 1 = 1\n/// [src/main.rs:5] n * factorial(n - 1) = 2\n/// [src/main.rs:5] n * factorial(n - 1) = 6\n/// [src/main.rs:5] n * factorial(n - 1) = 24\n/// [src/main.rs:11] factorial(4) = 24\n/// ```\n///\n/// The `dbg!(..)` macro moves the input:\n///\n/// ```compile_fail\n/// /// A wrapper around `usize` which importantly is not Copyable.\n/// #[derive(Debug)]\n/// struct NoCopy(usize);\n///\n/// let a = NoCopy(42);\n/// let _ = dbg!(a); // <-- `a` is moved here.\n/// let _ = dbg!(a); // <-- `a` is moved again; error!\n/// ```\n///\n/// You can also use `dbg!()` without a value to just print the\n/// file and line whenever it's reached.\n///\n/// Finally, if you want to `dbg!(..)` multiple values, it will treat them as\n/// a tuple (and return it, too):\n///\n/// ```\n/// assert_eq!(dbg!(1usize, 2u32), (1, 2));\n/// ```\n///\n/// However, a single argument with a trailing comma will still not be treated\n/// as a tuple, following the convention of ignoring trailing commas in macro\n/// invocations. You can use a 1-tuple directly if you need one:\n///\n/// ```\n/// assert_eq!(1, dbg!(1u32,)); // trailing comma ignored\n/// assert_eq!((1,), dbg!((1u32,))); // 1-tuple\n/// ```\n///\n/// [stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\n/// [`debug!`]: https://docs.rs/log/*/log/macro.debug.html\n/// [`log`]: https://crates.io/crates/log\n#[macro_export]\n#[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\nmacro_rules! dbg {\n    // NOTE: We cannot use `concat!` to make a static string as a format argument\n    // of `eprintln!` because `file!` could contain a `{` or\n    // `$val` expression could be a block (`{ .. }`), in which case the `eprintln!`\n    // will be malformed.\n    () => {\n        $crate::eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n    };\n    ($val:expr $(,)?) => {\n        // Use of `match` here is intentional because it affects the lifetimes\n        // of temporaries - https://stackoverflow.com/a/48732525/1063961\n        match $val {\n            tmp => {\n                $crate::eprintln!(\"[{}:{}] {} = {:#?}\",\n                    $crate::file!(), $crate::line!(), $crate::stringify!($val), &tmp);\n                tmp\n            }\n        }\n    };\n    ($($val:expr),+ $(,)?) => {\n        ($($crate::dbg!($val)),+,)\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_approx_eq {\n    ($a:expr, $b:expr) => {{\n        let (a, b) = (&$a, &$b);\n        assert!((*a - *b).abs() < 1.0e-6, \"{} is not approximately equal to {}\", *a, *b);\n    }};\n}\n"],["2584","//! Implementation of various bits and pieces of the `panic!` macro and\n//! associated runtime pieces.\n//!\n//! Specifically, this module contains the implementation of:\n//!\n//! * Panic hooks\n//! * Executing a panic up to doing the actual implementation\n//! * Shims around \"try\"\n\n#![deny(unsafe_op_in_unsafe_fn)]\n\nuse core::panic::{BoxMeUp, Location, PanicInfo};\n\nuse crate::any::Any;\nuse crate::fmt;\nuse crate::intrinsics;\nuse crate::mem::{self, ManuallyDrop};\nuse crate::process;\nuse crate::sync::atomic::{AtomicBool, Ordering};\nuse crate::sys::stdio::panic_output;\nuse crate::sys_common::backtrace::{self, RustBacktrace};\nuse crate::sys_common::rwlock::StaticRWLock;\nuse crate::sys_common::thread_info;\nuse crate::thread;\n\n#[cfg(not(test))]\nuse crate::io::set_output_capture;\n// make sure to use the stderr output configured\n// by libtest in the real copy of std\n#[cfg(test)]\nuse realstd::io::set_output_capture;\n\n// Binary interface to the panic runtime that the standard library depends on.\n//\n// The standard library is tagged with `#![needs_panic_runtime]` (introduced in\n// RFC 1513) to indicate that it requires some other crate tagged with\n// `#![panic_runtime]` to exist somewhere. Each panic runtime is intended to\n// implement these symbols (with the same signatures) so we can get matched up\n// to them.\n//\n// One day this may look a little less ad-hoc with the compiler helping out to\n// hook up these functions, but it is not this day!\n#[allow(improper_ctypes)]\nextern \"C\" {\n    fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any + Send + 'static);\n\n    /// `payload` is passed through another layer of raw pointers as `&mut dyn Trait` is not\n    /// FFI-safe. `BoxMeUp` lazily performs allocation only when needed (this avoids allocations\n    /// when using the \"abort\" panic runtime).\n    #[unwind(allowed)]\n    fn __rust_start_panic(payload: *mut &mut dyn BoxMeUp) -> u32;\n}\n\n/// This function is called by the panic runtime if FFI code catches a Rust\n/// panic but doesn't rethrow it. We don't support this case since it messes\n/// with our panic count.\n#[cfg(not(test))]\n#[rustc_std_internal_symbol]\nextern \"C\" fn __rust_drop_panic() -> ! {\n    rtabort!(\"Rust panics must be rethrown\");\n}\n\n/// This function is called by the panic runtime if it catches an exception\n/// object which does not correspond to a Rust panic.\n#[cfg(not(test))]\n#[rustc_std_internal_symbol]\nextern \"C\" fn __rust_foreign_exception() -> ! {\n    rtabort!(\"Rust cannot catch foreign exceptions\");\n}\n\n#[derive(Copy, Clone)]\nenum Hook {\n    Default,\n    Custom(*mut (dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send)),\n}\n\nstatic HOOK_LOCK: StaticRWLock = StaticRWLock::new();\nstatic mut HOOK: Hook = Hook::Default;\n\n/// Registers a custom panic hook, replacing any that was previously registered.\n///\n/// The panic hook is invoked when a thread panics, but before the panic runtime\n/// is invoked. As such, the hook will run with both the aborting and unwinding\n/// runtimes. The default hook prints a message to standard error and generates\n/// a backtrace if requested, but this behavior can be customized with the\n/// `set_hook` and [`take_hook`] functions.\n///\n/// [`take_hook`]: ./fn.take_hook.html\n///\n/// The hook is provided with a `PanicInfo` struct which contains information\n/// about the origin of the panic, including the payload passed to `panic!` and\n/// the source code location from which the panic originated.\n///\n/// The panic hook is a global resource.\n///\n/// # Panics\n///\n/// Panics if called from a panicking thread.\n///\n/// # Examples\n///\n/// The following will print \"Custom panic hook\":\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|_| {\n///     println!(\"Custom panic hook\");\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub fn set_hook(hook: Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send>) {\n    if thread::panicking() {\n        panic!(\"cannot modify the panic hook from a panicking thread\");\n    }\n\n    unsafe {\n        let guard = HOOK_LOCK.write();\n        let old_hook = HOOK;\n        HOOK = Hook::Custom(Box::into_raw(hook));\n        drop(guard);\n\n        if let Hook::Custom(ptr) = old_hook {\n            #[allow(unused_must_use)]\n            {\n                Box::from_raw(ptr);\n            }\n        }\n    }\n}\n\n/// Unregisters the current panic hook, returning it.\n///\n/// *See also the function [`set_hook`].*\n///\n/// [`set_hook`]: ./fn.set_hook.html\n///\n/// If no custom hook is registered, the default hook will be returned.\n///\n/// # Panics\n///\n/// Panics if called from a panicking thread.\n///\n/// # Examples\n///\n/// The following will print \"Normal panic\":\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|_| {\n///     println!(\"Custom panic hook\");\n/// }));\n///\n/// let _ = panic::take_hook();\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n    if thread::panicking() {\n        panic!(\"cannot modify the panic hook from a panicking thread\");\n    }\n\n    unsafe {\n        let guard = HOOK_LOCK.write();\n        let hook = HOOK;\n        HOOK = Hook::Default;\n        drop(guard);\n\n        match hook {\n            Hook::Default => Box::new(default_hook),\n            Hook::Custom(ptr) => Box::from_raw(ptr),\n        }\n    }\n}\n\nfn default_hook(info: &PanicInfo<'_>) {\n    // If this is a double panic, make sure that we print a backtrace\n    // for this panic. Otherwise only print it if logging is enabled.\n    let backtrace_env = if panic_count::get_count() >= 2 {\n        RustBacktrace::Print(crate::backtrace_rs::PrintFmt::Full)\n    } else {\n        backtrace::rust_backtrace_env()\n    };\n\n    // The current implementation always returns `Some`.\n    let location = info.location().unwrap();\n\n    let msg = match info.payload().downcast_ref::<&'static str>() {\n        Some(s) => *s,\n        None => match info.payload().downcast_ref::<String>() {\n            Some(s) => &s[..],\n            None => \"Box<dyn Any>\",\n        },\n    };\n    let thread = thread_info::current_thread();\n    let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n\n    let write = |err: &mut dyn crate::io::Write| {\n        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}\", name, msg, location);\n\n        static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n\n        match backtrace_env {\n            RustBacktrace::Print(format) => drop(backtrace::print(err, format)),\n            RustBacktrace::Disabled => {}\n            RustBacktrace::RuntimeDisabled => {\n                if FIRST_PANIC.swap(false, Ordering::SeqCst) {\n                    let _ = writeln!(\n                        err,\n                        \"note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\"\n                    );\n                }\n            }\n        }\n    };\n\n    if let Some(local) = set_output_capture(None) {\n        write(&mut *local.lock().unwrap_or_else(|e| e.into_inner()));\n        set_output_capture(Some(local));\n    } else if let Some(mut out) = panic_output() {\n        write(&mut out);\n    }\n}\n\n#[cfg(not(test))]\n#[doc(hidden)]\n#[unstable(feature = \"update_panic_count\", issue = \"none\")]\npub mod panic_count {\n    use crate::cell::Cell;\n    use crate::sync::atomic::{AtomicUsize, Ordering};\n\n    pub const ALWAYS_ABORT_FLAG: usize = 1 << (usize::BITS - 1);\n\n    // Panic count for the current thread.\n    thread_local! { static LOCAL_PANIC_COUNT: Cell<usize> = Cell::new(0) }\n\n    // Sum of panic counts from all threads. The purpose of this is to have\n    // a fast path in `is_zero` (which is used by `panicking`). In any particular\n    // thread, if that thread currently views `GLOBAL_PANIC_COUNT` as being zero,\n    // then `LOCAL_PANIC_COUNT` in that thread is zero. This invariant holds before\n    // and after increase and decrease, but not necessarily during their execution.\n    //\n    // Additionally, the top bit of GLOBAL_PANIC_COUNT (GLOBAL_ALWAYS_ABORT_FLAG)\n    // records whether panic::always_abort() has been called.  This can only be\n    // set, never cleared.\n    //\n    // This could be viewed as a struct containing a single bit and an n-1-bit\n    // value, but if we wrote it like that it would be more than a single word,\n    // and even a newtype around usize would be clumsy because we need atomics.\n    // But we use such a tuple for the return type of increase().\n    //\n    // Stealing a bit is fine because it just amounts to assuming that each\n    // panicking thread consumes at least 2 bytes of address space.\n    static GLOBAL_PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n    pub fn increase() -> (bool, usize) {\n        (\n            GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed) & ALWAYS_ABORT_FLAG != 0,\n            LOCAL_PANIC_COUNT.with(|c| {\n                let next = c.get() + 1;\n                c.set(next);\n                next\n            }),\n        )\n    }\n\n    pub fn decrease() {\n        GLOBAL_PANIC_COUNT.fetch_sub(1, Ordering::Relaxed);\n        LOCAL_PANIC_COUNT.with(|c| {\n            let next = c.get() - 1;\n            c.set(next);\n            next\n        });\n    }\n\n    pub fn set_always_abort() {\n        GLOBAL_PANIC_COUNT.fetch_or(ALWAYS_ABORT_FLAG, Ordering::Relaxed);\n    }\n\n    // Disregards ALWAYS_ABORT_FLAG\n    pub fn get_count() -> usize {\n        LOCAL_PANIC_COUNT.with(|c| c.get())\n    }\n\n    // Disregards ALWAYS_ABORT_FLAG\n    #[inline]\n    pub fn count_is_zero() -> bool {\n        if GLOBAL_PANIC_COUNT.load(Ordering::Relaxed) & !ALWAYS_ABORT_FLAG == 0 {\n            // Fast path: if `GLOBAL_PANIC_COUNT` is zero, all threads\n            // (including the current one) will have `LOCAL_PANIC_COUNT`\n            // equal to zero, so TLS access can be avoided.\n            //\n            // In terms of performance, a relaxed atomic load is similar to a normal\n            // aligned memory read (e.g., a mov instruction in x86), but with some\n            // compiler optimization restrictions. On the other hand, a TLS access\n            // might require calling a non-inlinable function (such as `__tls_get_addr`\n            // when using the GD TLS model).\n            true\n        } else {\n            is_zero_slow_path()\n        }\n    }\n\n    // Slow path is in a separate function to reduce the amount of code\n    // inlined from `is_zero`.\n    #[inline(never)]\n    #[cold]\n    fn is_zero_slow_path() -> bool {\n        LOCAL_PANIC_COUNT.with(|c| c.get() == 0)\n    }\n}\n\n#[cfg(test)]\npub use realstd::rt::panic_count;\n\n/// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\npub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>> {\n    union Data<F, R> {\n        f: ManuallyDrop<F>,\n        r: ManuallyDrop<R>,\n        p: ManuallyDrop<Box<dyn Any + Send>>,\n    }\n\n    // We do some sketchy operations with ownership here for the sake of\n    // performance. We can only pass pointers down to `do_call` (can't pass\n    // objects by value), so we do all the ownership tracking here manually\n    // using a union.\n    //\n    // We go through a transition where:\n    //\n    // * First, we set the data field `f` to be the argumentless closure that we're going to call.\n    // * When we make the function call, the `do_call` function below, we take\n    //   ownership of the function pointer. At this point the `data` union is\n    //   entirely uninitialized.\n    // * If the closure successfully returns, we write the return value into the\n    //   data's return slot (field `r`).\n    // * If the closure panics (`do_catch` below), we write the panic payload into field `p`.\n    // * Finally, when we come back out of the `try` intrinsic we're\n    //   in one of two states:\n    //\n    //      1. The closure didn't panic, in which case the return value was\n    //         filled in. We move it out of `data.r` and return it.\n    //      2. The closure panicked, in which case the panic payload was\n    //         filled in. We move it out of `data.p` and return it.\n    //\n    // Once we stack all that together we should have the \"most efficient'\n    // method of calling a catch panic whilst juggling ownership.\n    let mut data = Data { f: ManuallyDrop::new(f) };\n\n    let data_ptr = &mut data as *mut _ as *mut u8;\n    // SAFETY:\n    //\n    // Access to the union's fields: this is `std` and we know that the `r#try`\n    // intrinsic fills in the `r` or `p` union field based on its return value.\n    //\n    // The call to `intrinsics::r#try` is made safe by:\n    // - `do_call`, the first argument, can be called with the initial `data_ptr`.\n    // - `do_catch`, the second argument, can be called with the `data_ptr` as well.\n    // See their safety preconditions for more informations\n    unsafe {\n        return if intrinsics::r#try(do_call::<F, R>, data_ptr, do_catch::<F, R>) == 0 {\n            Ok(ManuallyDrop::into_inner(data.r))\n        } else {\n            Err(ManuallyDrop::into_inner(data.p))\n        };\n    }\n\n    // We consider unwinding to be rare, so mark this function as cold. However,\n    // do not mark it no-inline -- that decision is best to leave to the\n    // optimizer (in most cases this function is not inlined even as a normal,\n    // non-cold function, though, as of the writing of this comment).\n    #[cold]\n    unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send + 'static> {\n        // SAFETY: The whole unsafe block hinges on a correct implementation of\n        // the panic handler `__rust_panic_cleanup`. As such we can only\n        // assume it returns the correct thing for `Box::from_raw` to work\n        // without undefined behavior.\n        let obj = unsafe { Box::from_raw(__rust_panic_cleanup(payload)) };\n        panic_count::decrease();\n        obj\n    }\n\n    // SAFETY:\n    // data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>`\n    // Its must contains a valid `f` (type: F) value that can be use to fill\n    // `data.r`.\n    //\n    // This function cannot be marked as `unsafe` because `intrinsics::r#try`\n    // expects normal function pointers.\n    #[inline]\n    fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n        // SAFETY: this is the responsibilty of the caller, see above.\n        unsafe {\n            let data = data as *mut Data<F, R>;\n            let data = &mut (*data);\n            let f = ManuallyDrop::take(&mut data.f);\n            data.r = ManuallyDrop::new(f());\n        }\n    }\n\n    // We *do* want this part of the catch to be inlined: this allows the\n    // compiler to properly track accesses to the Data union and optimize it\n    // away most of the time.\n    //\n    // SAFETY:\n    // data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>`\n    // Since this uses `cleanup` it also hinges on a correct implementation of\n    // `__rustc_panic_cleanup`.\n    //\n    // This function cannot be marked as `unsafe` because `intrinsics::r#try`\n    // expects normal function pointers.\n    #[inline]\n    fn do_catch<F: FnOnce() -> R, R>(data: *mut u8, payload: *mut u8) {\n        // SAFETY: this is the responsibilty of the caller, see above.\n        //\n        // When `__rustc_panic_cleaner` is correctly implemented we can rely\n        // on `obj` being the correct thing to pass to `data.p` (after wrapping\n        // in `ManuallyDrop`).\n        unsafe {\n            let data = data as *mut Data<F, R>;\n            let data = &mut (*data);\n            let obj = cleanup(payload);\n            data.p = ManuallyDrop::new(obj);\n        }\n    }\n}\n\n/// Determines whether the current thread is unwinding because of panic.\n#[inline]\npub fn panicking() -> bool {\n    !panic_count::count_is_zero()\n}\n\n/// The entry point for panicking with a formatted message.\n///\n/// This is designed to reduce the amount of code required at the call\n/// site as much as possible (so that `panic!()` has as low an impact\n/// on (e.g.) the inlining of other functions as possible), by moving\n/// the actual formatting into this shared place.\n#[unstable(feature = \"libstd_sys_internals\", reason = \"used by the panic! macro\", issue = \"none\")]\n#[cold]\n// If panic_immediate_abort, inline the abort call,\n// otherwise avoid inlining because of it is cold path.\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), track_caller)]\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\npub fn begin_panic_fmt(msg: &fmt::Arguments<'_>) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        intrinsics::abort()\n    }\n\n    let info = PanicInfo::internal_constructor(Some(msg), Location::caller());\n    begin_panic_handler(&info)\n}\n\n/// Entry point of panics from the libcore crate (`panic_impl` lang item).\n#[cfg_attr(not(test), panic_handler)]\n#[unwind(allowed)]\npub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n    struct PanicPayload<'a> {\n        inner: &'a fmt::Arguments<'a>,\n        string: Option<String>,\n    }\n\n    impl<'a> PanicPayload<'a> {\n        fn new(inner: &'a fmt::Arguments<'a>) -> PanicPayload<'a> {\n            PanicPayload { inner, string: None }\n        }\n\n        fn fill(&mut self) -> &mut String {\n            use crate::fmt::Write;\n\n            let inner = self.inner;\n            // Lazily, the first time this gets called, run the actual string formatting.\n            self.string.get_or_insert_with(|| {\n                let mut s = String::new();\n                drop(s.write_fmt(*inner));\n                s\n            })\n        }\n    }\n\n    unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n            // We do two allocations here, unfortunately. But (a) they're required with the current\n            // scheme, and (b) we don't handle panic + OOM properly anyway (see comment in\n            // begin_panic below).\n            let contents = mem::take(self.fill());\n            Box::into_raw(Box::new(contents))\n        }\n\n        fn get(&mut self) -> &(dyn Any + Send) {\n            self.fill()\n        }\n    }\n\n    struct StrPanicPayload(&'static str);\n\n    unsafe impl BoxMeUp for StrPanicPayload {\n        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n            Box::into_raw(Box::new(self.0))\n        }\n\n        fn get(&mut self) -> &(dyn Any + Send) {\n            &self.0\n        }\n    }\n\n    let loc = info.location().unwrap(); // The current implementation always returns Some\n    let msg = info.message().unwrap(); // The current implementation always returns Some\n    crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n        if let Some(msg) = msg.as_str() {\n            rust_panic_with_hook(&mut StrPanicPayload(msg), info.message(), loc);\n        } else {\n            rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n        }\n    })\n}\n\n/// This is the entry point of panicking for the non-format-string variants of\n/// panic!() and assert!(). In particular, this is the only entry point that supports\n/// arbitrary payloads, not just format strings.\n#[unstable(feature = \"libstd_sys_internals\", reason = \"used by the panic! macro\", issue = \"none\")]\n#[cfg_attr(not(test), lang = \"begin_panic\")]\n// lang item for CTFE panic support\n// never inline unless panic_immediate_abort to avoid code\n// bloat at the call sites as much as possible\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[cold]\n#[track_caller]\npub fn begin_panic<M: Any + Send>(msg: M) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        intrinsics::abort()\n    }\n\n    let loc = Location::caller();\n    return crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n        rust_panic_with_hook(&mut PanicPayload::new(msg), None, loc)\n    });\n\n    struct PanicPayload<A> {\n        inner: Option<A>,\n    }\n\n    impl<A: Send + 'static> PanicPayload<A> {\n        fn new(inner: A) -> PanicPayload<A> {\n            PanicPayload { inner: Some(inner) }\n        }\n    }\n\n    unsafe impl<A: Send + 'static> BoxMeUp for PanicPayload<A> {\n        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n            // Note that this should be the only allocation performed in this code path. Currently\n            // this means that panic!() on OOM will invoke this code path, but then again we're not\n            // really ready for panic on OOM anyway. If we do start doing this, then we should\n            // propagate this allocation to be performed in the parent of this thread instead of the\n            // thread that's panicking.\n            let data = match self.inner.take() {\n                Some(a) => Box::new(a) as Box<dyn Any + Send>,\n                None => process::abort(),\n            };\n            Box::into_raw(data)\n        }\n\n        fn get(&mut self) -> &(dyn Any + Send) {\n            match self.inner {\n                Some(ref a) => a,\n                None => process::abort(),\n            }\n        }\n    }\n}\n\n/// Central point for dispatching panics.\n///\n/// Executes the primary logic for a panic, including checking for recursive\n/// panics, panic hooks, and finally dispatching to the panic runtime to either\n/// abort or unwind.\nfn rust_panic_with_hook(\n    payload: &mut dyn BoxMeUp,\n    message: Option<&fmt::Arguments<'_>>,\n    location: &Location<'_>,\n) -> ! {\n    let (must_abort, panics) = panic_count::increase();\n\n    // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n    // the panic hook probably triggered the last panic, otherwise the\n    // double-panic check would have aborted the process. In this case abort the\n    // process real quickly as we don't want to try calling it again as it'll\n    // probably just panic again.\n    if must_abort || panics > 2 {\n        if panics > 2 {\n            // Don't try to print the message in this case\n            // - perhaps that is causing the recursive panics.\n            rtprintpanic!(\"thread panicked while processing panic. aborting.\\n\");\n        } else {\n            // Unfortunately, this does not print a backtrace, because creating\n            // a `Backtrace` will allocate, which we must to avoid here.\n            let panicinfo = PanicInfo::internal_constructor(message, location);\n            rtprintpanic!(\"{}\\npanicked after panic::always_abort(), aborting.\\n\", panicinfo);\n        }\n        intrinsics::abort()\n    }\n\n    unsafe {\n        let mut info = PanicInfo::internal_constructor(message, location);\n        let _guard = HOOK_LOCK.read();\n        match HOOK {\n            // Some platforms (like wasm) know that printing to stderr won't ever actually\n            // print anything, and if that's the case we can skip the default\n            // hook. Since string formatting happens lazily when calling `payload`\n            // methods, this means we avoid formatting the string at all!\n            // (The panic runtime might still call `payload.take_box()` though and trigger\n            // formatting.)\n            Hook::Default if panic_output().is_none() => {}\n            Hook::Default => {\n                info.set_payload(payload.get());\n                default_hook(&info);\n            }\n            Hook::Custom(ptr) => {\n                info.set_payload(payload.get());\n                (*ptr)(&info);\n            }\n        };\n    }\n\n    if panics > 1 {\n        // If a thread panics while it's already unwinding then we\n        // have limited options. Currently our preference is to\n        // just abort. In the future we may consider resuming\n        // unwinding or otherwise exiting the thread cleanly.\n        rtprintpanic!(\"thread panicked while panicking. aborting.\\n\");\n        intrinsics::abort()\n    }\n\n    rust_panic(payload)\n}\n\n/// This is the entry point for `resume_unwind`.\n/// It just forwards the payload to the panic runtime.\npub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {\n    panic_count::increase();\n\n    struct RewrapBox(Box<dyn Any + Send>);\n\n    unsafe impl BoxMeUp for RewrapBox {\n        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n            Box::into_raw(mem::replace(&mut self.0, Box::new(())))\n        }\n\n        fn get(&mut self) -> &(dyn Any + Send) {\n            &*self.0\n        }\n    }\n\n    rust_panic(&mut RewrapBox(payload))\n}\n\n/// An unmangled function (through `rustc_std_internal_symbol`) on which to slap\n/// yer breakpoints.\n#[inline(never)]\n#[cfg_attr(not(test), rustc_std_internal_symbol)]\nfn rust_panic(mut msg: &mut dyn BoxMeUp) -> ! {\n    let code = unsafe {\n        let obj = &mut msg as *mut &mut dyn BoxMeUp;\n        __rust_start_panic(obj)\n    };\n    rtabort!(\"failed to initiate panic, error {}\", code)\n}\n"],["2585","use crate::net::test::{sa4, sa6, tsa};\nuse crate::net::*;\nuse crate::str::FromStr;\n\n#[test]\nfn test_from_str_ipv4() {\n    assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n    assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n    assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n\n    // out of range\n    let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n    assert_eq!(None, none);\n    // too short\n    let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n    assert_eq!(None, none);\n    // too long\n    let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n    assert_eq!(None, none);\n    // no number between dots\n    let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n    assert_eq!(None, none);\n}\n\n#[test]\nfn test_from_str_ipv6() {\n    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n\n    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n\n    assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)), \"2a02:6b8::11:11\".parse());\n\n    // too long group\n    let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n    assert_eq!(None, none);\n    // too short\n    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n    assert_eq!(None, none);\n    // too long\n    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n    assert_eq!(None, none);\n    // triple colon\n    let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n    assert_eq!(None, none);\n    // two double colons\n    let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n    assert_eq!(None, none);\n    // `::` indicating zero groups of zeros\n    let none: Option<Ipv6Addr> = \"1:2:3:4::5:6:7:8\".parse().ok();\n    assert_eq!(None, none);\n}\n\n#[test]\nfn test_from_str_ipv4_in_ipv6() {\n    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)), \"::192.0.2.33\".parse());\n    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)), \"::FFFF:192.0.2.33\".parse());\n    assert_eq!(\n        Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n        \"64:ff9b::192.0.2.33\".parse()\n    );\n    assert_eq!(\n        Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n        \"2001:db8:122:c000:2:2100:192.0.2.33\".parse()\n    );\n\n    // colon after v4\n    let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n    assert_eq!(None, none);\n    // not enough groups\n    let none: Option<Ipv6Addr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n    assert_eq!(None, none);\n    // too many groups\n    let none: Option<Ipv6Addr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n    assert_eq!(None, none);\n}\n\n#[test]\nfn test_from_str_socket_addr() {\n    assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n    assert_eq!(Ok(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n    assert_eq!(\n        Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n        \"[2a02:6b8:0:1::1]:53\".parse()\n    );\n    assert_eq!(\n        Ok(SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0)),\n        \"[2a02:6b8:0:1::1]:53\".parse()\n    );\n    assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)), \"[::127.0.0.1]:22\".parse());\n    assert_eq!(\n        Ok(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22, 0, 0)),\n        \"[::127.0.0.1]:22\".parse()\n    );\n\n    // without port\n    let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n    assert_eq!(None, none);\n    // without port\n    let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n    assert_eq!(None, none);\n    // wrong brackets around v4\n    let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n    assert_eq!(None, none);\n    // port out of range\n    let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n    assert_eq!(None, none);\n}\n\n#[test]\nfn ipv4_addr_to_string() {\n    assert_eq!(Ipv4Addr::new(127, 0, 0, 1).to_string(), \"127.0.0.1\");\n    // Short address\n    assert_eq!(Ipv4Addr::new(1, 1, 1, 1).to_string(), \"1.1.1.1\");\n    // Long address\n    assert_eq!(Ipv4Addr::new(127, 127, 127, 127).to_string(), \"127.127.127.127\");\n\n    // Test padding\n    assert_eq!(&format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n    assert_eq!(&format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n}\n\n#[test]\nfn ipv6_addr_to_string() {\n    // ipv4-mapped address\n    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n    assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n\n    // ipv4-compatible address\n    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n    assert_eq!(a1.to_string(), \"::192.0.2.128\");\n\n    // v6 address with no zero segments\n    assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(), \"8:9:a:b:c:d:e:f\");\n\n    // longest possible IPv6 length\n    assert_eq!(\n        Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888).to_string(),\n        \"1111:2222:3333:4444:5555:6666:7777:8888\"\n    );\n    // padding\n    assert_eq!(&format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"1:2:3:4:5:6:7:8     \");\n    assert_eq!(&format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"     1:2:3:4:5:6:7:8\");\n\n    // reduce a single run of zeros\n    assert_eq!(\n        \"ae::ffff:102:304\",\n        Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string()\n    );\n\n    // don't reduce just a single zero segment\n    assert_eq!(\"1:2:3:4:5:6:0:8\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n\n    // 'any' address\n    assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n\n    // loopback address\n    assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n\n    // ends in zeros\n    assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n\n    // two runs of zeros, second one is longer\n    assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n\n    // two runs of zeros, equal length\n    assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n\n    // don't prefix `0x` to each segment in `dbg!`.\n    assert_eq!(\"1::4:5:0:0:8\", &format!(\"{:#?}\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8)));\n}\n\n#[test]\nfn ipv4_to_ipv6() {\n    assert_eq!(\n        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped()\n    );\n    assert_eq!(\n        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible()\n    );\n}\n\n#[test]\nfn ipv6_to_ipv4_mapped() {\n    assert_eq!(\n        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4_mapped(),\n        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n    );\n    assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4_mapped(), None);\n}\n\n#[test]\nfn ipv6_to_ipv4() {\n    assert_eq!(\n        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n    );\n    assert_eq!(\n        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n    );\n    assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(), None);\n}\n\n#[test]\nfn ip_properties() {\n    macro_rules! ip {\n        ($s:expr) => {\n            IpAddr::from_str($s).unwrap()\n        };\n    }\n\n    macro_rules! check {\n        ($s:expr) => {\n            check!($s, 0);\n        };\n\n        ($s:expr, $mask:expr) => {{\n            let unspec: u8 = 1 << 0;\n            let loopback: u8 = 1 << 1;\n            let global: u8 = 1 << 2;\n            let multicast: u8 = 1 << 3;\n            let doc: u8 = 1 << 4;\n\n            if ($mask & unspec) == unspec {\n                assert!(ip!($s).is_unspecified());\n            } else {\n                assert!(!ip!($s).is_unspecified());\n            }\n\n            if ($mask & loopback) == loopback {\n                assert!(ip!($s).is_loopback());\n            } else {\n                assert!(!ip!($s).is_loopback());\n            }\n\n            if ($mask & global) == global {\n                assert!(ip!($s).is_global());\n            } else {\n                assert!(!ip!($s).is_global());\n            }\n\n            if ($mask & multicast) == multicast {\n                assert!(ip!($s).is_multicast());\n            } else {\n                assert!(!ip!($s).is_multicast());\n            }\n\n            if ($mask & doc) == doc {\n                assert!(ip!($s).is_documentation());\n            } else {\n                assert!(!ip!($s).is_documentation());\n            }\n        }};\n    }\n\n    let unspec: u8 = 1 << 0;\n    let loopback: u8 = 1 << 1;\n    let global: u8 = 1 << 2;\n    let multicast: u8 = 1 << 3;\n    let doc: u8 = 1 << 4;\n\n    check!(\"0.0.0.0\", unspec);\n    check!(\"0.0.0.1\");\n    check!(\"0.1.0.0\");\n    check!(\"10.9.8.7\");\n    check!(\"127.1.2.3\", loopback);\n    check!(\"172.31.254.253\");\n    check!(\"169.254.253.242\");\n    check!(\"192.0.2.183\", doc);\n    check!(\"192.1.2.183\", global);\n    check!(\"192.168.254.253\");\n    check!(\"198.51.100.0\", doc);\n    check!(\"203.0.113.0\", doc);\n    check!(\"203.2.113.0\", global);\n    check!(\"224.0.0.0\", global | multicast);\n    check!(\"239.255.255.255\", global | multicast);\n    check!(\"255.255.255.255\");\n    // make sure benchmarking addresses are not global\n    check!(\"198.18.0.0\");\n    check!(\"198.18.54.2\");\n    check!(\"198.19.255.255\");\n    // make sure addresses reserved for protocol assignment are not global\n    check!(\"192.0.0.0\");\n    check!(\"192.0.0.255\");\n    check!(\"192.0.0.100\");\n    // make sure reserved addresses are not global\n    check!(\"240.0.0.0\");\n    check!(\"251.54.1.76\");\n    check!(\"254.255.255.255\");\n    // make sure shared addresses are not global\n    check!(\"100.64.0.0\");\n    check!(\"100.127.255.255\");\n    check!(\"100.100.100.0\");\n\n    check!(\"::\", unspec);\n    check!(\"::1\", loopback);\n    check!(\"::0.0.0.2\", global);\n    check!(\"1::\", global);\n    check!(\"fc00::\");\n    check!(\"fdff:ffff::\");\n    check!(\"fe80:ffff::\");\n    check!(\"febf:ffff::\");\n    check!(\"fec0::\", global);\n    check!(\"ff01::\", multicast);\n    check!(\"ff02::\", multicast);\n    check!(\"ff03::\", multicast);\n    check!(\"ff04::\", multicast);\n    check!(\"ff05::\", multicast);\n    check!(\"ff08::\", multicast);\n    check!(\"ff0e::\", global | multicast);\n    check!(\"2001:db8:85a3::8a2e:370:7334\", doc);\n    check!(\"102:304:506:708:90a:b0c:d0e:f10\", global);\n}\n\n#[test]\nfn ipv4_properties() {\n    macro_rules! ip {\n        ($s:expr) => {\n            Ipv4Addr::from_str($s).unwrap()\n        };\n    }\n\n    macro_rules! check {\n        ($s:expr) => {\n            check!($s, 0);\n        };\n\n        ($s:expr, $mask:expr) => {{\n            let unspec: u16 = 1 << 0;\n            let loopback: u16 = 1 << 1;\n            let private: u16 = 1 << 2;\n            let link_local: u16 = 1 << 3;\n            let global: u16 = 1 << 4;\n            let multicast: u16 = 1 << 5;\n            let broadcast: u16 = 1 << 6;\n            let documentation: u16 = 1 << 7;\n            let benchmarking: u16 = 1 << 8;\n            let ietf_protocol_assignment: u16 = 1 << 9;\n            let reserved: u16 = 1 << 10;\n            let shared: u16 = 1 << 11;\n\n            if ($mask & unspec) == unspec {\n                assert!(ip!($s).is_unspecified());\n            } else {\n                assert!(!ip!($s).is_unspecified());\n            }\n\n            if ($mask & loopback) == loopback {\n                assert!(ip!($s).is_loopback());\n            } else {\n                assert!(!ip!($s).is_loopback());\n            }\n\n            if ($mask & private) == private {\n                assert!(ip!($s).is_private());\n            } else {\n                assert!(!ip!($s).is_private());\n            }\n\n            if ($mask & link_local) == link_local {\n                assert!(ip!($s).is_link_local());\n            } else {\n                assert!(!ip!($s).is_link_local());\n            }\n\n            if ($mask & global) == global {\n                assert!(ip!($s).is_global());\n            } else {\n                assert!(!ip!($s).is_global());\n            }\n\n            if ($mask & multicast) == multicast {\n                assert!(ip!($s).is_multicast());\n            } else {\n                assert!(!ip!($s).is_multicast());\n            }\n\n            if ($mask & broadcast) == broadcast {\n                assert!(ip!($s).is_broadcast());\n            } else {\n                assert!(!ip!($s).is_broadcast());\n            }\n\n            if ($mask & documentation) == documentation {\n                assert!(ip!($s).is_documentation());\n            } else {\n                assert!(!ip!($s).is_documentation());\n            }\n\n            if ($mask & benchmarking) == benchmarking {\n                assert!(ip!($s).is_benchmarking());\n            } else {\n                assert!(!ip!($s).is_benchmarking());\n            }\n\n            if ($mask & ietf_protocol_assignment) == ietf_protocol_assignment {\n                assert!(ip!($s).is_ietf_protocol_assignment());\n            } else {\n                assert!(!ip!($s).is_ietf_protocol_assignment());\n            }\n\n            if ($mask & reserved) == reserved {\n                assert!(ip!($s).is_reserved());\n            } else {\n                assert!(!ip!($s).is_reserved());\n            }\n\n            if ($mask & shared) == shared {\n                assert!(ip!($s).is_shared());\n            } else {\n                assert!(!ip!($s).is_shared());\n            }\n        }};\n    }\n\n    let unspec: u16 = 1 << 0;\n    let loopback: u16 = 1 << 1;\n    let private: u16 = 1 << 2;\n    let link_local: u16 = 1 << 3;\n    let global: u16 = 1 << 4;\n    let multicast: u16 = 1 << 5;\n    let broadcast: u16 = 1 << 6;\n    let documentation: u16 = 1 << 7;\n    let benchmarking: u16 = 1 << 8;\n    let ietf_protocol_assignment: u16 = 1 << 9;\n    let reserved: u16 = 1 << 10;\n    let shared: u16 = 1 << 11;\n\n    check!(\"0.0.0.0\", unspec);\n    check!(\"0.0.0.1\");\n    check!(\"0.1.0.0\");\n    check!(\"10.9.8.7\", private);\n    check!(\"127.1.2.3\", loopback);\n    check!(\"172.31.254.253\", private);\n    check!(\"169.254.253.242\", link_local);\n    check!(\"192.0.2.183\", documentation);\n    check!(\"192.1.2.183\", global);\n    check!(\"192.168.254.253\", private);\n    check!(\"198.51.100.0\", documentation);\n    check!(\"203.0.113.0\", documentation);\n    check!(\"203.2.113.0\", global);\n    check!(\"224.0.0.0\", global | multicast);\n    check!(\"239.255.255.255\", global | multicast);\n    check!(\"255.255.255.255\", broadcast);\n    check!(\"198.18.0.0\", benchmarking);\n    check!(\"198.18.54.2\", benchmarking);\n    check!(\"198.19.255.255\", benchmarking);\n    check!(\"192.0.0.0\", ietf_protocol_assignment);\n    check!(\"192.0.0.255\", ietf_protocol_assignment);\n    check!(\"192.0.0.100\", ietf_protocol_assignment);\n    check!(\"240.0.0.0\", reserved);\n    check!(\"251.54.1.76\", reserved);\n    check!(\"254.255.255.255\", reserved);\n    check!(\"100.64.0.0\", shared);\n    check!(\"100.127.255.255\", shared);\n    check!(\"100.100.100.0\", shared);\n}\n\n#[test]\nfn ipv6_properties() {\n    macro_rules! ip {\n        ($s:expr) => {\n            Ipv6Addr::from_str($s).unwrap()\n        };\n    }\n\n    macro_rules! check {\n        ($s:expr, &[$($octet:expr),*], $mask:expr) => {\n            assert_eq!($s, ip!($s).to_string());\n            let octets = &[$($octet),*];\n            assert_eq!(&ip!($s).octets(), octets);\n            assert_eq!(Ipv6Addr::from(*octets), ip!($s));\n\n            let unspecified: u16 = 1 << 0;\n            let loopback: u16 = 1 << 1;\n            let unique_local: u16 = 1 << 2;\n            let global: u16 = 1 << 3;\n            let unicast_link_local: u16 = 1 << 4;\n            let unicast_global: u16 = 1 << 7;\n            let documentation: u16 = 1 << 8;\n            let multicast_interface_local: u16 = 1 << 9;\n            let multicast_link_local: u16 = 1 << 10;\n            let multicast_realm_local: u16 = 1 << 11;\n            let multicast_admin_local: u16 = 1 << 12;\n            let multicast_site_local: u16 = 1 << 13;\n            let multicast_organization_local: u16 = 1 << 14;\n            let multicast_global: u16 = 1 << 15;\n            let multicast: u16 = multicast_interface_local\n                | multicast_admin_local\n                | multicast_global\n                | multicast_link_local\n                | multicast_realm_local\n                | multicast_site_local\n                | multicast_organization_local;\n\n            if ($mask & unspecified) == unspecified {\n                assert!(ip!($s).is_unspecified());\n            } else {\n                assert!(!ip!($s).is_unspecified());\n            }\n            if ($mask & loopback) == loopback {\n                assert!(ip!($s).is_loopback());\n            } else {\n                assert!(!ip!($s).is_loopback());\n            }\n            if ($mask & unique_local) == unique_local {\n                assert!(ip!($s).is_unique_local());\n            } else {\n                assert!(!ip!($s).is_unique_local());\n            }\n            if ($mask & global) == global {\n                assert!(ip!($s).is_global());\n            } else {\n                assert!(!ip!($s).is_global());\n            }\n            if ($mask & unicast_link_local) == unicast_link_local {\n                assert!(ip!($s).is_unicast_link_local());\n            } else {\n                assert!(!ip!($s).is_unicast_link_local());\n            }\n            if ($mask & unicast_global) == unicast_global {\n                assert!(ip!($s).is_unicast_global());\n            } else {\n                assert!(!ip!($s).is_unicast_global());\n            }\n            if ($mask & documentation) == documentation {\n                assert!(ip!($s).is_documentation());\n            } else {\n                assert!(!ip!($s).is_documentation());\n            }\n            if ($mask & multicast) != 0 {\n                assert!(ip!($s).multicast_scope().is_some());\n                assert!(ip!($s).is_multicast());\n            } else {\n                assert!(ip!($s).multicast_scope().is_none());\n                assert!(!ip!($s).is_multicast());\n            }\n            if ($mask & multicast_interface_local) == multicast_interface_local {\n                assert_eq!(ip!($s).multicast_scope().unwrap(),\n                           Ipv6MulticastScope::InterfaceLocal);\n            }\n            if ($mask & multicast_link_local) == multicast_link_local {\n                assert_eq!(ip!($s).multicast_scope().unwrap(),\n                           Ipv6MulticastScope::LinkLocal);\n            }\n            if ($mask & multicast_realm_local) == multicast_realm_local {\n                assert_eq!(ip!($s).multicast_scope().unwrap(),\n                           Ipv6MulticastScope::RealmLocal);\n            }\n            if ($mask & multicast_admin_local) == multicast_admin_local {\n                assert_eq!(ip!($s).multicast_scope().unwrap(),\n                           Ipv6MulticastScope::AdminLocal);\n            }\n            if ($mask & multicast_site_local) == multicast_site_local {\n                assert_eq!(ip!($s).multicast_scope().unwrap(),\n                           Ipv6MulticastScope::SiteLocal);\n            }\n            if ($mask & multicast_organization_local) == multicast_organization_local {\n                assert_eq!(ip!($s).multicast_scope().unwrap(),\n                           Ipv6MulticastScope::OrganizationLocal);\n            }\n            if ($mask & multicast_global) == multicast_global {\n                assert_eq!(ip!($s).multicast_scope().unwrap(),\n                           Ipv6MulticastScope::Global);\n            }\n        }\n    }\n\n    let unspecified: u16 = 1 << 0;\n    let loopback: u16 = 1 << 1;\n    let unique_local: u16 = 1 << 2;\n    let global: u16 = 1 << 3;\n    let unicast_link_local: u16 = 1 << 4;\n    let unicast_global: u16 = 1 << 7;\n    let documentation: u16 = 1 << 8;\n    let multicast_interface_local: u16 = 1 << 9;\n    let multicast_link_local: u16 = 1 << 10;\n    let multicast_realm_local: u16 = 1 << 11;\n    let multicast_admin_local: u16 = 1 << 12;\n    let multicast_site_local: u16 = 1 << 13;\n    let multicast_organization_local: u16 = 1 << 14;\n    let multicast_global: u16 = 1 << 15;\n\n    check!(\"::\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unspecified);\n\n    check!(\"::1\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], loopback);\n\n    check!(\"::0.0.0.2\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], global | unicast_global);\n\n    check!(\"1::\", &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], global | unicast_global);\n\n    check!(\"fc00::\", &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unique_local);\n\n    check!(\n        \"fdff:ffff::\",\n        &[0xfd, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        unique_local\n    );\n\n    check!(\n        \"fe80:ffff::\",\n        &[0xfe, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        unicast_link_local\n    );\n\n    check!(\"fe80::\", &[0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n\n    check!(\n        \"febf:ffff::\",\n        &[0xfe, 0xbf, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        unicast_link_local\n    );\n\n    check!(\"febf::\", &[0xfe, 0xbf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n\n    check!(\n        \"febf:ffff:ffff:ffff:ffff:ffff:ffff:ffff\",\n        &[\n            0xfe, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff\n        ],\n        unicast_link_local\n    );\n\n    check!(\n        \"fe80::ffff:ffff:ffff:ffff\",\n        &[\n            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n            0xff, 0xff\n        ],\n        unicast_link_local\n    );\n\n    check!(\n        \"fe80:0:0:1::\",\n        &[0xfe, 0x80, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n        unicast_link_local\n    );\n\n    check!(\n        \"fec0::\",\n        &[0xfe, 0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        unicast_global | global\n    );\n\n    check!(\n        \"ff01::\",\n        &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        multicast_interface_local\n    );\n\n    check!(\"ff02::\", &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_link_local);\n\n    check!(\"ff03::\", &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_realm_local);\n\n    check!(\"ff04::\", &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_admin_local);\n\n    check!(\"ff05::\", &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_site_local);\n\n    check!(\n        \"ff08::\",\n        &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        multicast_organization_local\n    );\n\n    check!(\n        \"ff0e::\",\n        &[0xff, 0xe, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        multicast_global | global\n    );\n\n    check!(\n        \"2001:db8:85a3::8a2e:370:7334\",\n        &[0x20, 1, 0xd, 0xb8, 0x85, 0xa3, 0, 0, 0, 0, 0x8a, 0x2e, 3, 0x70, 0x73, 0x34],\n        documentation\n    );\n\n    check!(\n        \"102:304:506:708:90a:b0c:d0e:f10\",\n        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n        global | unicast_global\n    );\n}\n\n#[test]\nfn to_socket_addr_socketaddr() {\n    let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n    assert_eq!(Ok(vec![a]), tsa(a));\n}\n\n#[test]\nfn test_ipv4_to_int() {\n    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n    assert_eq!(u32::from(a), 0x11223344);\n}\n\n#[test]\nfn test_int_to_ipv4() {\n    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n    assert_eq!(Ipv4Addr::from(0x11223344), a);\n}\n\n#[test]\nfn test_ipv6_to_int() {\n    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n    assert_eq!(u128::from(a), 0x112233445566778899aabbccddeeff11u128);\n}\n\n#[test]\nfn test_int_to_ipv6() {\n    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n    assert_eq!(Ipv6Addr::from(0x112233445566778899aabbccddeeff11u128), a);\n}\n\n#[test]\nfn ipv4_from_constructors() {\n    assert_eq!(Ipv4Addr::LOCALHOST, Ipv4Addr::new(127, 0, 0, 1));\n    assert!(Ipv4Addr::LOCALHOST.is_loopback());\n    assert_eq!(Ipv4Addr::UNSPECIFIED, Ipv4Addr::new(0, 0, 0, 0));\n    assert!(Ipv4Addr::UNSPECIFIED.is_unspecified());\n    assert_eq!(Ipv4Addr::BROADCAST, Ipv4Addr::new(255, 255, 255, 255));\n    assert!(Ipv4Addr::BROADCAST.is_broadcast());\n}\n\n#[test]\nfn ipv6_from_contructors() {\n    assert_eq!(Ipv6Addr::LOCALHOST, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n    assert!(Ipv6Addr::LOCALHOST.is_loopback());\n    assert_eq!(Ipv6Addr::UNSPECIFIED, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n    assert!(Ipv6Addr::UNSPECIFIED.is_unspecified());\n}\n\n#[test]\nfn ipv4_from_octets() {\n    assert_eq!(Ipv4Addr::from([127, 0, 0, 1]), Ipv4Addr::new(127, 0, 0, 1))\n}\n\n#[test]\nfn ipv6_from_segments() {\n    let from_u16s =\n        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n    let new = Ipv6Addr::new(0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff);\n    assert_eq!(new, from_u16s);\n}\n\n#[test]\nfn ipv6_from_octets() {\n    let from_u16s =\n        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n    let from_u8s = Ipv6Addr::from([\n        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,\n        0xff,\n    ]);\n    assert_eq!(from_u16s, from_u8s);\n}\n\n#[test]\nfn cmp() {\n    let v41 = Ipv4Addr::new(100, 64, 3, 3);\n    let v42 = Ipv4Addr::new(192, 0, 2, 2);\n    let v61 = \"2001:db8:f00::1002\".parse::<Ipv6Addr>().unwrap();\n    let v62 = \"2001:db8:f00::2001\".parse::<Ipv6Addr>().unwrap();\n    assert!(v41 < v42);\n    assert!(v61 < v62);\n\n    assert_eq!(v41, IpAddr::V4(v41));\n    assert_eq!(v61, IpAddr::V6(v61));\n    assert!(v41 != IpAddr::V4(v42));\n    assert!(v61 != IpAddr::V6(v62));\n\n    assert!(v41 < IpAddr::V4(v42));\n    assert!(v61 < IpAddr::V6(v62));\n    assert!(IpAddr::V4(v41) < v42);\n    assert!(IpAddr::V6(v61) < v62);\n\n    assert!(v41 < IpAddr::V6(v61));\n    assert!(IpAddr::V4(v41) < v61);\n}\n\n#[test]\nfn is_v4() {\n    let ip = IpAddr::V4(Ipv4Addr::new(100, 64, 3, 3));\n    assert!(ip.is_ipv4());\n    assert!(!ip.is_ipv6());\n}\n\n#[test]\nfn is_v6() {\n    let ip = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678));\n    assert!(!ip.is_ipv4());\n    assert!(ip.is_ipv6());\n}\n\n#[test]\nfn ipv4_const() {\n    // test that the methods of `Ipv4Addr` are usable in a const context\n\n    const IP_ADDRESS: Ipv4Addr = Ipv4Addr::new(127, 0, 0, 1);\n    assert_eq!(IP_ADDRESS, Ipv4Addr::LOCALHOST);\n\n    const OCTETS: [u8; 4] = IP_ADDRESS.octets();\n    assert_eq!(OCTETS, [127, 0, 0, 1]);\n\n    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n    assert!(!IS_UNSPECIFIED);\n\n    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n    assert!(IS_LOOPBACK);\n\n    const IS_PRIVATE: bool = IP_ADDRESS.is_private();\n    assert!(!IS_PRIVATE);\n\n    const IS_LINK_LOCAL: bool = IP_ADDRESS.is_link_local();\n    assert!(!IS_LINK_LOCAL);\n\n    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n    assert!(!IS_GLOBAL);\n\n    const IS_SHARED: bool = IP_ADDRESS.is_shared();\n    assert!(!IS_SHARED);\n\n    const IS_IETF_PROTOCOL_ASSIGNMENT: bool = IP_ADDRESS.is_ietf_protocol_assignment();\n    assert!(!IS_IETF_PROTOCOL_ASSIGNMENT);\n\n    const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n    assert!(!IS_BENCHMARKING);\n\n    const IS_RESERVED: bool = IP_ADDRESS.is_reserved();\n    assert!(!IS_RESERVED);\n\n    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n    assert!(!IS_MULTICAST);\n\n    const IS_BROADCAST: bool = IP_ADDRESS.is_broadcast();\n    assert!(!IS_BROADCAST);\n\n    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n    assert!(!IS_DOCUMENTATION);\n\n    const IP_V6_COMPATIBLE: Ipv6Addr = IP_ADDRESS.to_ipv6_compatible();\n    assert_eq!(\n        IP_V6_COMPATIBLE,\n        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 1])\n    );\n\n    const IP_V6_MAPPED: Ipv6Addr = IP_ADDRESS.to_ipv6_mapped();\n    assert_eq!(\n        IP_V6_MAPPED,\n        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 127, 0, 0, 1])\n    );\n}\n\n#[test]\nfn ipv6_const() {\n    // test that the methods of `Ipv6Addr` are usable in a const context\n\n    const IP_ADDRESS: Ipv6Addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n    assert_eq!(IP_ADDRESS, Ipv6Addr::LOCALHOST);\n\n    const SEGMENTS: [u16; 8] = IP_ADDRESS.segments();\n    assert_eq!(SEGMENTS, [0, 0, 0, 0, 0, 0, 0, 1]);\n\n    const OCTETS: [u8; 16] = IP_ADDRESS.octets();\n    assert_eq!(OCTETS, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);\n\n    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n    assert!(!IS_UNSPECIFIED);\n\n    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n    assert!(IS_LOOPBACK);\n\n    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n    assert!(!IS_GLOBAL);\n\n    const IS_UNIQUE_LOCAL: bool = IP_ADDRESS.is_unique_local();\n    assert!(!IS_UNIQUE_LOCAL);\n\n    const IS_UNICAST_LINK_LOCAL: bool = IP_ADDRESS.is_unicast_link_local();\n    assert!(!IS_UNICAST_LINK_LOCAL);\n\n    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n    assert!(!IS_DOCUMENTATION);\n\n    const IS_UNICAST_GLOBAL: bool = IP_ADDRESS.is_unicast_global();\n    assert!(!IS_UNICAST_GLOBAL);\n\n    const MULTICAST_SCOPE: Option<Ipv6MulticastScope> = IP_ADDRESS.multicast_scope();\n    assert_eq!(MULTICAST_SCOPE, None);\n\n    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n    assert!(!IS_MULTICAST);\n\n    const IP_V4: Option<Ipv4Addr> = IP_ADDRESS.to_ipv4();\n    assert_eq!(IP_V4.unwrap(), Ipv4Addr::new(0, 0, 0, 1));\n}\n\n#[test]\nfn ip_const() {\n    // test that the methods of `IpAddr` are usable in a const context\n\n    const IP_ADDRESS: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n\n    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n    assert!(!IS_UNSPECIFIED);\n\n    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n    assert!(IS_LOOPBACK);\n\n    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n    assert!(!IS_GLOBAL);\n\n    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n    assert!(!IS_MULTICAST);\n\n    const IS_IP_V4: bool = IP_ADDRESS.is_ipv4();\n    assert!(IS_IP_V4);\n\n    const IS_IP_V6: bool = IP_ADDRESS.is_ipv6();\n    assert!(!IS_IP_V6);\n}\n"],["2586","// Tests for this module\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\nuse crate::cmp::Ordering;\nuse crate::fmt::{self, Write as FmtWrite};\nuse crate::hash;\nuse crate::io::Write as IoWrite;\nuse crate::mem::transmute;\nuse crate::sys::net::netc as c;\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\n\n/// An IP address, either IPv4 or IPv6.\n///\n/// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n/// respective documentation for more details.\n///\n/// The size of an `IpAddr` instance may vary depending on the target operating\n/// system.\n///\n/// # Examples\n///\n/// ```\n/// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n///\n/// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n/// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n///\n/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost_v4));\n/// assert_eq!(\"::1\".parse(), Ok(localhost_v6));\n///\n/// assert_eq!(localhost_v4.is_ipv6(), false);\n/// assert_eq!(localhost_v4.is_ipv4(), true);\n/// ```\n#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n#[derive(Copy, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]\npub enum IpAddr {\n    /// An IPv4 address.\n    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n    V4(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv4Addr),\n    /// An IPv6 address.\n    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n    V6(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv6Addr),\n}\n\n/// An IPv4 address.\n///\n/// IPv4 addresses are defined as 32-bit integers in [IETF RFC 791].\n/// They are usually represented as four octets.\n///\n/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n///\n/// The size of an `Ipv4Addr` struct may vary depending on the target operating\n/// system.\n///\n/// [IETF RFC 791]: https://tools.ietf.org/html/rfc791\n///\n/// # Textual representation\n///\n/// `Ipv4Addr` provides a [`FromStr`] implementation. The four octets are in decimal\n/// notation, divided by `.` (this is called \"dot-decimal notation\").\n/// Notably, octal numbers and hexadecimal numbers are not allowed per [IETF RFC 6943].\n///\n/// [IETF RFC 6943]: https://tools.ietf.org/html/rfc6943#section-3.1.1\n/// [`FromStr`]: crate::str::FromStr\n///\n/// # Examples\n///\n/// ```\n/// use std::net::Ipv4Addr;\n///\n/// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\n/// assert_eq!(localhost.is_loopback(), true);\n/// ```\n#[derive(Copy)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Ipv4Addr {\n    inner: c::in_addr,\n}\n\n/// An IPv6 address.\n///\n/// IPv6 addresses are defined as 128-bit integers in [IETF RFC 4291].\n/// They are usually represented as eight 16-bit segments.\n///\n/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n///\n/// The size of an `Ipv6Addr` struct may vary depending on the target operating\n/// system.\n///\n/// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n///\n/// # Textual representation\n///\n/// `Ipv6Addr` provides a [`FromStr`] implementation. There are many ways to represent\n/// an IPv6 address in text, but in general, each segments is written in hexadecimal\n/// notation, and segments are separated by `:`. For more information, see\n/// [IETF RFC 5952].\n///\n/// [`FromStr`]: crate::str::FromStr\n/// [IETF RFC 5952]: https://tools.ietf.org/html/rfc5952\n///\n/// # Examples\n///\n/// ```\n/// use std::net::Ipv6Addr;\n///\n/// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n/// assert_eq!(\"::1\".parse(), Ok(localhost));\n/// assert_eq!(localhost.is_loopback(), true);\n/// ```\n#[derive(Copy)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Ipv6Addr {\n    inner: c::in6_addr,\n}\n\n#[allow(missing_docs)]\n#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n#[unstable(feature = \"ip\", issue = \"27709\")]\npub enum Ipv6MulticastScope {\n    InterfaceLocal,\n    LinkLocal,\n    RealmLocal,\n    AdminLocal,\n    SiteLocal,\n    OrganizationLocal,\n    Global,\n}\n\nimpl IpAddr {\n    /// Returns [`true`] for the special 'unspecified' address.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_unspecified()`] and\n    /// [`Ipv6Addr::is_unspecified()`] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)).is_unspecified(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)).is_unspecified(), true);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n    #[inline]\n    pub const fn is_unspecified(&self) -> bool {\n        match self {\n            IpAddr::V4(ip) => ip.is_unspecified(),\n            IpAddr::V6(ip) => ip.is_unspecified(),\n        }\n    }\n\n    /// Returns [`true`] if this is a loopback address.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_loopback()`] and\n    /// [`Ipv6Addr::is_loopback()`] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).is_loopback(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1)).is_loopback(), true);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n    #[inline]\n    pub const fn is_loopback(&self) -> bool {\n        match self {\n            IpAddr::V4(ip) => ip.is_loopback(),\n            IpAddr::V6(ip) => ip.is_loopback(),\n        }\n    }\n\n    /// Returns [`true`] if the address appears to be globally routable.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_global()`] and\n    /// [`Ipv6Addr::is_global()`] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(), true);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_global(&self) -> bool {\n        match self {\n            IpAddr::V4(ip) => ip.is_global(),\n            IpAddr::V6(ip) => ip.is_global(),\n        }\n    }\n\n    /// Returns [`true`] if this is a multicast address.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_multicast()`] and\n    /// [`Ipv6Addr::is_multicast()`] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(224, 254, 0, 0)).is_multicast(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0)).is_multicast(), true);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n    #[inline]\n    pub const fn is_multicast(&self) -> bool {\n        match self {\n            IpAddr::V4(ip) => ip.is_multicast(),\n            IpAddr::V6(ip) => ip.is_multicast(),\n        }\n    }\n\n    /// Returns [`true`] if this address is in a range designated for documentation.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_documentation()`] and\n    /// [`Ipv6Addr::is_documentation()`] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n    /// assert_eq!(\n    ///     IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_documentation(),\n    ///     true\n    /// );\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_documentation(&self) -> bool {\n        match self {\n            IpAddr::V4(ip) => ip.is_documentation(),\n            IpAddr::V6(ip) => ip.is_documentation(),\n        }\n    }\n\n    /// Returns [`true`] if this address is an [`IPv4` address], and [`false`]\n    /// otherwise.\n    ///\n    /// [`IPv4` address]: IpAddr::V4\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(), false);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n    #[inline]\n    pub const fn is_ipv4(&self) -> bool {\n        matches!(self, IpAddr::V4(_))\n    }\n\n    /// Returns [`true`] if this address is an [`IPv6` address], and [`false`]\n    /// otherwise.\n    ///\n    /// [`IPv6` address]: IpAddr::V6\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(), true);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ip\", since = \"1.50.0\")]\n    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n    #[inline]\n    pub const fn is_ipv6(&self) -> bool {\n        matches!(self, IpAddr::V6(_))\n    }\n}\n\nimpl Ipv4Addr {\n    /// Creates a new IPv4 address from four eight-bit octets.\n    ///\n    /// The result will represent the IP address `a`.`b`.`c`.`d`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.32.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n        // `s_addr` is stored as BE on all machine and the array is in BE order.\n        // So the native endian conversion method is used so that it's never swapped.\n        Ipv4Addr { inner: c::in_addr { s_addr: u32::from_ne_bytes([a, b, c, d]) } }\n    }\n\n    /// An IPv4 address with the address pointing to localhost: `127.0.0.1`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::LOCALHOST;\n    /// assert_eq!(addr, Ipv4Addr::new(127, 0, 0, 1));\n    /// ```\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const LOCALHOST: Self = Ipv4Addr::new(127, 0, 0, 1);\n\n    /// An IPv4 address representing an unspecified address: `0.0.0.0`\n    ///\n    /// This corresponds to the constant `INADDR_ANY` in other languages.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::UNSPECIFIED;\n    /// assert_eq!(addr, Ipv4Addr::new(0, 0, 0, 0));\n    /// ```\n    #[doc(alias = \"INADDR_ANY\")]\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const UNSPECIFIED: Self = Ipv4Addr::new(0, 0, 0, 0);\n\n    /// An IPv4 address representing the broadcast address: `255.255.255.255`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::BROADCAST;\n    /// assert_eq!(addr, Ipv4Addr::new(255, 255, 255, 255));\n    /// ```\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const BROADCAST: Self = Ipv4Addr::new(255, 255, 255, 255);\n\n    /// Returns the four eight-bit integers that make up this address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n    /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn octets(&self) -> [u8; 4] {\n        // This returns the order we want because s_addr is stored in big-endian.\n        self.inner.s_addr.to_ne_bytes()\n    }\n\n    /// Returns [`true`] for the special 'unspecified' address (`0.0.0.0`).\n    ///\n    /// This property is defined in _UNIX Network Programming, Second Edition_,\n    /// W. Richard Stevens, p. 891; see also [ip7].\n    ///\n    /// [ip7]: https://man7.org/linux/man-pages/man7/ip.7.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.32.0\")]\n    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n    #[inline]\n    pub const fn is_unspecified(&self) -> bool {\n        self.inner.s_addr == 0\n    }\n\n    /// Returns [`true`] if this is a loopback address (`127.0.0.0/8`).\n    ///\n    /// This property is defined by [IETF RFC 1122].\n    ///\n    /// [IETF RFC 1122]: https://tools.ietf.org/html/rfc1122\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    #[inline]\n    pub const fn is_loopback(&self) -> bool {\n        self.octets()[0] == 127\n    }\n\n    /// Returns [`true`] if this is a private address.\n    ///\n    /// The private address ranges are defined in [IETF RFC 1918] and include:\n    ///\n    ///  - `10.0.0.0/8`\n    ///  - `172.16.0.0/12`\n    ///  - `192.168.0.0/16`\n    ///\n    /// [IETF RFC 1918]: https://tools.ietf.org/html/rfc1918\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(10, 0, 0, 1).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(10, 10, 10, 10).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 10).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(172, 29, 45, 14).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(172, 32, 0, 2).is_private(), false);\n    /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    #[inline]\n    pub const fn is_private(&self) -> bool {\n        match self.octets() {\n            [10, ..] => true,\n            [172, b, ..] if b >= 16 && b <= 31 => true,\n            [192, 168, ..] => true,\n            _ => false,\n        }\n    }\n\n    /// Returns [`true`] if the address is link-local (`169.254.0.0/16`).\n    ///\n    /// This property is defined by [IETF RFC 3927].\n    ///\n    /// [IETF RFC 3927]: https://tools.ietf.org/html/rfc3927\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(169, 254, 0, 0).is_link_local(), true);\n    /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n    /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    #[inline]\n    pub const fn is_link_local(&self) -> bool {\n        matches!(self.octets(), [169, 254, ..])\n    }\n\n    /// Returns [`true`] if the address appears to be globally routable.\n    /// See [iana-ipv4-special-registry][ipv4-sr].\n    ///\n    /// The following return [`false`]:\n    ///\n    /// - private addresses (see [`Ipv4Addr::is_private()`])\n    /// - the loopback address (see [`Ipv4Addr::is_loopback()`])\n    /// - the link-local address (see [`Ipv4Addr::is_link_local()`])\n    /// - the broadcast address (see [`Ipv4Addr::is_broadcast()`])\n    /// - addresses used for documentation (see [`Ipv4Addr::is_documentation()`])\n    /// - the unspecified address (see [`Ipv4Addr::is_unspecified()`]), and the whole\n    ///   `0.0.0.0/8` block\n    /// - addresses reserved for future protocols (see\n    /// [`Ipv4Addr::is_ietf_protocol_assignment()`], except\n    /// `192.0.0.9/32` and `192.0.0.10/32` which are globally routable\n    /// - addresses reserved for future use (see [`Ipv4Addr::is_reserved()`]\n    /// - addresses reserved for networking devices benchmarking (see\n    /// [`Ipv4Addr::is_benchmarking()`])\n    ///\n    /// [ipv4-sr]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv4Addr;\n    ///\n    /// // private addresses are not global\n    /// assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n    ///\n    /// // the 0.0.0.0/8 block is not global\n    /// assert_eq!(Ipv4Addr::new(0, 1, 2, 3).is_global(), false);\n    /// // in particular, the unspecified address is not global\n    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n    ///\n    /// // the loopback address is not global\n    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_global(), false);\n    ///\n    /// // link local addresses are not global\n    /// assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n    ///\n    /// // the broadcast address is not global\n    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_global(), false);\n    ///\n    /// // the address space designated for documentation is not global\n    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n    ///\n    /// // shared addresses are not global\n    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n    ///\n    /// // addresses reserved for protocol assignment are not global\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_global(), false);\n    ///\n    /// // addresses reserved for future use are not global\n    /// assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n    ///\n    /// // addresses reserved for network devices benchmarking are not global\n    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n    ///\n    /// // All the other addresses are global\n    /// assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_global(&self) -> bool {\n        // check if this address is 192.0.0.9 or 192.0.0.10. These addresses are the only two\n        // globally routable addresses in the 192.0.0.0/24 range.\n        if u32::from_be_bytes(self.octets()) == 0xc0000009\n            || u32::from_be_bytes(self.octets()) == 0xc000000a\n        {\n            return true;\n        }\n        !self.is_private()\n            && !self.is_loopback()\n            && !self.is_link_local()\n            && !self.is_broadcast()\n            && !self.is_documentation()\n            && !self.is_shared()\n            && !self.is_ietf_protocol_assignment()\n            && !self.is_reserved()\n            && !self.is_benchmarking()\n            // Make sure the address is not in 0.0.0.0/8\n            && self.octets()[0] != 0\n    }\n\n    /// Returns [`true`] if this address is part of the Shared Address Space defined in\n    /// [IETF RFC 6598] (`100.64.0.0/10`).\n    ///\n    /// [IETF RFC 6598]: https://tools.ietf.org/html/rfc6598\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n    /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n    /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_shared(&self) -> bool {\n        self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n    }\n\n    /// Returns [`true`] if this address is part of `192.0.0.0/24`, which is reserved to\n    /// IANA for IETF protocol assignments, as documented in [IETF RFC 6890].\n    ///\n    /// Note that parts of this block are in use:\n    ///\n    /// - `192.0.0.8/32` is the \"IPv4 dummy address\" (see [IETF RFC 7600])\n    /// - `192.0.0.9/32` is the \"Port Control Protocol Anycast\" (see [IETF RFC 7723])\n    /// - `192.0.0.10/32` is used for NAT traversal (see [IETF RFC 8155])\n    ///\n    /// [IETF RFC 6890]: https://tools.ietf.org/html/rfc6890\n    /// [IETF RFC 7600]: https://tools.ietf.org/html/rfc7600\n    /// [IETF RFC 7723]: https://tools.ietf.org/html/rfc7723\n    /// [IETF RFC 8155]: https://tools.ietf.org/html/rfc8155\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_ietf_protocol_assignment(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 8).is_ietf_protocol_assignment(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 9).is_ietf_protocol_assignment(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_ietf_protocol_assignment(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n    /// assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_ietf_protocol_assignment(&self) -> bool {\n        self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0\n    }\n\n    /// Returns [`true`] if this address part of the `198.18.0.0/15` range, which is reserved for\n    /// network devices benchmarking. This range is defined in [IETF RFC 2544] as `192.18.0.0`\n    /// through `198.19.255.255` but [errata 423] corrects it to `198.18.0.0/15`.\n    ///\n    /// [IETF RFC 2544]: https://tools.ietf.org/html/rfc2544\n    /// [errata 423]: https://www.rfc-editor.org/errata/eid423\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n    /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n    /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_benchmarking(&self) -> bool {\n        self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n    }\n\n    /// Returns [`true`] if this address is reserved by IANA for future use. [IETF RFC 1112]\n    /// defines the block of reserved addresses as `240.0.0.0/4`. This range normally includes the\n    /// broadcast address `255.255.255.255`, but this implementation explicitly excludes it, since\n    /// it is obviously not reserved for future use.\n    ///\n    /// [IETF RFC 1112]: https://tools.ietf.org/html/rfc1112\n    ///\n    /// # Warning\n    ///\n    /// As IANA assigns new addresses, this method will be\n    /// updated. This may result in non-reserved addresses being\n    /// treated as reserved in code that relies on an outdated version\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n    ///\n    /// assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n    /// // The broadcast address is not considered as reserved for future use by this implementation\n    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_reserved(&self) -> bool {\n        self.octets()[0] & 240 == 240 && !self.is_broadcast()\n    }\n\n    /// Returns [`true`] if this is a multicast address (`224.0.0.0/4`).\n    ///\n    /// Multicast addresses have a most significant octet between `224` and `239`,\n    /// and is defined by [IETF RFC 5771].\n    ///\n    /// [IETF RFC 5771]: https://tools.ietf.org/html/rfc5771\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(224, 254, 0, 0).is_multicast(), true);\n    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    #[inline]\n    pub const fn is_multicast(&self) -> bool {\n        self.octets()[0] >= 224 && self.octets()[0] <= 239\n    }\n\n    /// Returns [`true`] if this is a broadcast address (`255.255.255.255`).\n    ///\n    /// A broadcast address has all octets set to `255` as defined in [IETF RFC 919].\n    ///\n    /// [IETF RFC 919]: https://tools.ietf.org/html/rfc919\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    #[inline]\n    pub const fn is_broadcast(&self) -> bool {\n        u32::from_be_bytes(self.octets()) == u32::from_be_bytes(Self::BROADCAST.octets())\n    }\n\n    /// Returns [`true`] if this address is in a range designated for documentation.\n    ///\n    /// This is defined in [IETF RFC 5737]:\n    ///\n    /// - `192.0.2.0/24` (TEST-NET-1)\n    /// - `198.51.100.0/24` (TEST-NET-2)\n    /// - `203.0.113.0/24` (TEST-NET-3)\n    ///\n    /// [IETF RFC 5737]: https://tools.ietf.org/html/rfc5737\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_documentation(), true);\n    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_documentation(), true);\n    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n    /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    #[inline]\n    pub const fn is_documentation(&self) -> bool {\n        match self.octets() {\n            [192, 0, 2, _] => true,\n            [198, 51, 100, _] => true,\n            [203, 0, 113, _] => true,\n            _ => false,\n        }\n    }\n\n    /// Converts this address to an IPv4-compatible [`IPv6` address].\n    ///\n    /// `a.b.c.d` becomes `::a.b.c.d`\n    ///\n    /// This isn't typically the method you want; these addresses don't typically\n    /// function on modern systems. Use `to_ipv6_mapped` instead.\n    ///\n    /// [`IPv6` address]: Ipv6Addr\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(\n    ///     Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x2ff)\n    /// );\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n        let [a, b, c, d] = self.octets();\n        Ipv6Addr {\n            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] },\n        }\n    }\n\n    /// Converts this address to an IPv4-mapped [`IPv6` address].\n    ///\n    /// `a.b.c.d` becomes `::ffff:a.b.c.d`\n    ///\n    /// [`IPv6` address]: Ipv6Addr\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x2ff));\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.50.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n        let [a, b, c, d] = self.octets();\n        Ipv6Addr {\n            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] },\n        }\n    }\n}\n\n#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\nimpl fmt::Display for IpAddr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            IpAddr::V4(ip) => ip.fmt(fmt),\n            IpAddr::V6(ip) => ip.fmt(fmt),\n        }\n    }\n}\n\n#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\nimpl fmt::Debug for IpAddr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\nimpl From<Ipv4Addr> for IpAddr {\n    /// Copies this address to a new `IpAddr::V4`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr};\n    ///\n    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n    ///\n    /// assert_eq!(\n    ///     IpAddr::V4(addr),\n    ///     IpAddr::from(addr)\n    /// )\n    /// ```\n    #[inline]\n    fn from(ipv4: Ipv4Addr) -> IpAddr {\n        IpAddr::V4(ipv4)\n    }\n}\n\n#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\nimpl From<Ipv6Addr> for IpAddr {\n    /// Copies this address to a new `IpAddr::V6`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv6Addr};\n    ///\n    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n    ///\n    /// assert_eq!(\n    ///     IpAddr::V6(addr),\n    ///     IpAddr::from(addr)\n    /// );\n    /// ```\n    #[inline]\n    fn from(ipv6: Ipv6Addr) -> IpAddr {\n        IpAddr::V6(ipv6)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Ipv4Addr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let octets = self.octets();\n        // Fast Path: if there's no alignment stuff, write directly to the buffer\n        if fmt.precision().is_none() && fmt.width().is_none() {\n            write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n        } else {\n            const IPV4_BUF_LEN: usize = 15; // Long enough for the longest possible IPv4 address\n            let mut buf = [0u8; IPV4_BUF_LEN];\n            let mut buf_slice = &mut buf[..];\n\n            // Note: The call to write should never fail, hence the unwrap\n            write!(buf_slice, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n            let len = IPV4_BUF_LEN - buf_slice.len();\n\n            // This unsafe is OK because we know what is being written to the buffer\n            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n            fmt.pad(buf)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Ipv4Addr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for Ipv4Addr {\n    #[inline]\n    fn clone(&self) -> Ipv4Addr {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for Ipv4Addr {\n    #[inline]\n    fn eq(&self, other: &Ipv4Addr) -> bool {\n        self.inner.s_addr == other.inner.s_addr\n    }\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialEq<Ipv4Addr> for IpAddr {\n    #[inline]\n    fn eq(&self, other: &Ipv4Addr) -> bool {\n        match self {\n            IpAddr::V4(v4) => v4 == other,\n            IpAddr::V6(_) => false,\n        }\n    }\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialEq<IpAddr> for Ipv4Addr {\n    #[inline]\n    fn eq(&self, other: &IpAddr) -> bool {\n        match other {\n            IpAddr::V4(v4) => self == v4,\n            IpAddr::V6(_) => false,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for Ipv4Addr {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for Ipv4Addr {\n    #[inline]\n    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n        // NOTE:\n        // * hash in big endian order\n        // * in netbsd, `in_addr` has `repr(packed)`, we need to\n        //   copy `s_addr` to avoid unsafe borrowing\n        { self.inner.s_addr }.hash(s)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for Ipv4Addr {\n    #[inline]\n    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialOrd<Ipv4Addr> for IpAddr {\n    #[inline]\n    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n        match self {\n            IpAddr::V4(v4) => v4.partial_cmp(other),\n            IpAddr::V6(_) => Some(Ordering::Greater),\n        }\n    }\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialOrd<IpAddr> for Ipv4Addr {\n    #[inline]\n    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n        match other {\n            IpAddr::V4(v4) => self.partial_cmp(v4),\n            IpAddr::V6(_) => Some(Ordering::Less),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for Ipv4Addr {\n    #[inline]\n    fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n        // Compare as native endian\n        u32::from_be(self.inner.s_addr).cmp(&u32::from_be(other.inner.s_addr))\n    }\n}\n\nimpl IntoInner<c::in_addr> for Ipv4Addr {\n    #[inline]\n    fn into_inner(self) -> c::in_addr {\n        self.inner\n    }\n}\n\n#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\nimpl From<Ipv4Addr> for u32 {\n    /// Converts an `Ipv4Addr` into a host byte order `u32`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::new(0xca, 0xfe, 0xba, 0xbe);\n    /// assert_eq!(0xcafebabe, u32::from(addr));\n    /// ```\n    #[inline]\n    fn from(ip: Ipv4Addr) -> u32 {\n        let ip = ip.octets();\n        u32::from_be_bytes(ip)\n    }\n}\n\n#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\nimpl From<u32> for Ipv4Addr {\n    /// Converts a host byte order `u32` into an `Ipv4Addr`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::from(0xcafebabe);\n    /// assert_eq!(Ipv4Addr::new(0xca, 0xfe, 0xba, 0xbe), addr);\n    /// ```\n    #[inline]\n    fn from(ip: u32) -> Ipv4Addr {\n        Ipv4Addr::from(ip.to_be_bytes())\n    }\n}\n\n#[stable(feature = \"from_slice_v4\", since = \"1.9.0\")]\nimpl From<[u8; 4]> for Ipv4Addr {\n    /// Creates an `Ipv4Addr` from a four element byte array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::from([13u8, 12u8, 11u8, 10u8]);\n    /// assert_eq!(Ipv4Addr::new(13, 12, 11, 10), addr);\n    /// ```\n    #[inline]\n    fn from(octets: [u8; 4]) -> Ipv4Addr {\n        Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3])\n    }\n}\n\n#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\nimpl From<[u8; 4]> for IpAddr {\n    /// Creates an `IpAddr::V4` from a four element byte array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr};\n    ///\n    /// let addr = IpAddr::from([13u8, 12u8, 11u8, 10u8]);\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(13, 12, 11, 10)), addr);\n    /// ```\n    #[inline]\n    fn from(octets: [u8; 4]) -> IpAddr {\n        IpAddr::V4(Ipv4Addr::from(octets))\n    }\n}\n\nimpl Ipv6Addr {\n    /// Creates a new IPv6 address from eight 16-bit segments.\n    ///\n    /// The result will represent the IP address `a:b:c:d:e:f:g:h`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n    /// ```\n    #[rustc_allow_const_fn_unstable(const_fn_transmute)]\n    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n        let addr16 = [\n            a.to_be(),\n            b.to_be(),\n            c.to_be(),\n            d.to_be(),\n            e.to_be(),\n            f.to_be(),\n            g.to_be(),\n            h.to_be(),\n        ];\n        Ipv6Addr {\n            inner: c::in6_addr {\n                // All elements in `addr16` are big endian.\n                // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n                // rustc_allow_const_fn_unstable: the transmute could be written as stable const\n                // code, but that leads to worse code generation (#75085)\n                s6_addr: unsafe { transmute::<_, [u8; 16]>(addr16) },\n            },\n        }\n    }\n\n    /// An IPv6 address representing localhost: `::1`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::LOCALHOST;\n    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n    /// ```\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const LOCALHOST: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n\n    /// An IPv6 address representing the unspecified address: `::`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::UNSPECIFIED;\n    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n    /// ```\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const UNSPECIFIED: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0);\n\n    /// Returns the eight 16-bit segments that make up this address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n    ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n    /// ```\n    #[rustc_allow_const_fn_unstable(const_fn_transmute)]\n    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn segments(&self) -> [u16; 8] {\n        // All elements in `s6_addr` must be big endian.\n        // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n        // rustc_allow_const_fn_unstable: the transmute could be written as stable const code, but\n        // that leads to worse code generation (#75085)\n        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.inner.s6_addr) };\n        // We want native endian u16\n        [\n            u16::from_be(a),\n            u16::from_be(b),\n            u16::from_be(c),\n            u16::from_be(d),\n            u16::from_be(e),\n            u16::from_be(f),\n            u16::from_be(g),\n            u16::from_be(h),\n        ]\n    }\n\n    /// Returns [`true`] for the special 'unspecified' address (`::`).\n    ///\n    /// This property is defined in [IETF RFC 4291].\n    ///\n    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    #[inline]\n    pub const fn is_unspecified(&self) -> bool {\n        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::UNSPECIFIED.octets())\n    }\n\n    /// Returns [`true`] if this is a loopback address (::1).\n    ///\n    /// This property is defined in [IETF RFC 4291].\n    ///\n    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    #[inline]\n    pub const fn is_loopback(&self) -> bool {\n        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::LOCALHOST.octets())\n    }\n\n    /// Returns [`true`] if the address appears to be globally routable.\n    ///\n    /// The following return [`false`]:\n    ///\n    /// - the loopback address\n    /// - link-local and unique local unicast addresses\n    /// - interface-, link-, realm-, admin- and site-local multicast addresses\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), true);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_global(), false);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1).is_global(), true);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_global(&self) -> bool {\n        match self.multicast_scope() {\n            Some(Ipv6MulticastScope::Global) => true,\n            None => self.is_unicast_global(),\n            _ => false,\n        }\n    }\n\n    /// Returns [`true`] if this is a unique local address (`fc00::/7`).\n    ///\n    /// This property is defined in [IETF RFC 4193].\n    ///\n    /// [IETF RFC 4193]: https://tools.ietf.org/html/rfc4193\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\n    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_unique_local(&self) -> bool {\n        (self.segments()[0] & 0xfe00) == 0xfc00\n    }\n\n    /// Returns [`true`] if this is a unicast address, as defined by [IETF RFC 4291].\n    /// Any address that is not a [multicast address] (`ff00::/8`) is unicast.\n    ///\n    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n    /// [multicast address]: Ipv6Addr::is_multicast\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// // The unspecified and loopback addresses are unicast.\n    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_unicast(), true);\n    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast(), true);\n    ///\n    /// // Any address that is not a multicast address (`ff00::/8`) is unicast.\n    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast(), true);\n    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_unicast(), false);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_unicast(&self) -> bool {\n        !self.is_multicast()\n    }\n\n    /// Returns `true` if the address is a unicast address with link-local scope,\n    /// as defined in [RFC 4291].\n    ///\n    /// A unicast address has link-local scope if it has the prefix `fe80::/10`, as per [RFC 4291 section 2.4].\n    /// Note that this encompasses more addresses than those defined in [RFC 4291 section 2.5.6],\n    /// which describes \"Link-Local IPv6 Unicast Addresses\" as having the following stricter format:\n    ///\n    /// ```text\n    /// | 10 bits  |         54 bits         |          64 bits           |\n    /// +----------+-------------------------+----------------------------+\n    /// |1111111010|           0             |       interface ID         |\n    /// +----------+-------------------------+----------------------------+\n    /// ```\n    /// So while currently the only addresses with link-local scope an application will encounter are all in `fe80::/64`,\n    /// this might change in the future with the publication of new standards. More addresses in `fe80::/10` could be allocated,\n    /// and those addresses will have link-local scope.\n    ///\n    /// Also note that while [RFC 4291 section 2.5.3] mentions about the [loopback address] (`::1`) that \"it is treated as having Link-Local scope\",\n    /// this does not mean that the loopback address actually has link-local scope and this method will return `false` on it.\n    ///\n    /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n    /// [RFC 4291 section 2.4]: https://tools.ietf.org/html/rfc4291#section-2.4\n    /// [RFC 4291 section 2.5.3]: https://tools.ietf.org/html/rfc4291#section-2.5.3\n    /// [RFC 4291 section 2.5.6]: https://tools.ietf.org/html/rfc4291#section-2.5.6\n    /// [loopback address]: Ipv6Addr::LOCALHOST\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// // The loopback address (`::1`) does not actually have link-local scope.\n    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast_link_local(), false);\n    ///\n    /// // Only addresses in `fe80::/10` have link-local scope.\n    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), false);\n    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n    ///\n    /// // Addresses outside the stricter `fe80::/64` also have link-local scope.\n    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0).is_unicast_link_local(), true);\n    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_unicast_link_local(&self) -> bool {\n        (self.segments()[0] & 0xffc0) == 0xfe80\n    }\n\n    /// Returns [`true`] if this is an address reserved for documentation\n    /// (`2001:db8::/32`).\n    ///\n    /// This property is defined in [IETF RFC 3849].\n    ///\n    /// [IETF RFC 3849]: https://tools.ietf.org/html/rfc3849\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\n    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_documentation(&self) -> bool {\n        (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n    }\n\n    /// Returns [`true`] if the address is a globally routable unicast address.\n    ///\n    /// The following return false:\n    ///\n    /// - the loopback address\n    /// - the link-local addresses\n    /// - unique local addresses\n    /// - the unspecified address\n    /// - the address range reserved for documentation\n    ///\n    /// This method returns [`true`] for site-local addresses as per [RFC 4291 section 2.5.7]\n    ///\n    /// ```no_rust\n    /// The special behavior of [the site-local unicast] prefix defined in [RFC3513] must no longer\n    /// be supported in new implementations (i.e., new implementations must treat this prefix as\n    /// Global Unicast).\n    /// ```\n    ///\n    /// [RFC 4291 section 2.5.7]: https://tools.ietf.org/html/rfc4291#section-2.5.7\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn is_unicast_global(&self) -> bool {\n        self.is_unicast()\n            && !self.is_loopback()\n            && !self.is_unicast_link_local()\n            && !self.is_unique_local()\n            && !self.is_unspecified()\n            && !self.is_documentation()\n    }\n\n    /// Returns the address's multicast scope if the address is multicast.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::{Ipv6Addr, Ipv6MulticastScope};\n    ///\n    /// assert_eq!(\n    ///     Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n    ///     Some(Ipv6MulticastScope::Global)\n    /// );\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n        if self.is_multicast() {\n            match self.segments()[0] & 0x000f {\n                1 => Some(Ipv6MulticastScope::InterfaceLocal),\n                2 => Some(Ipv6MulticastScope::LinkLocal),\n                3 => Some(Ipv6MulticastScope::RealmLocal),\n                4 => Some(Ipv6MulticastScope::AdminLocal),\n                5 => Some(Ipv6MulticastScope::SiteLocal),\n                8 => Some(Ipv6MulticastScope::OrganizationLocal),\n                14 => Some(Ipv6MulticastScope::Global),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }\n\n    /// Returns [`true`] if this is a multicast address (`ff00::/8`).\n    ///\n    /// This property is defined by [IETF RFC 4291].\n    ///\n    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    #[inline]\n    pub const fn is_multicast(&self) -> bool {\n        (self.segments()[0] & 0xff00) == 0xff00\n    }\n\n    /// Converts this address to an [`IPv4` address] if it's an \"IPv4-mapped IPv6 address\"\n    /// defined in [IETF RFC 4291 section 2.5.5.2], otherwise returns [`None`].\n    ///\n    /// `::ffff:a.b.c.d` becomes `a.b.c.d`.\n    /// All addresses *not* starting with `::ffff` will return `None`.\n    ///\n    /// [`IPv4` address]: Ipv4Addr\n    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::{Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4_mapped(), None);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4_mapped(),\n    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4_mapped(), None);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n    #[unstable(feature = \"ip\", issue = \"27709\")]\n    #[inline]\n    pub const fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n        match self.octets() {\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, a, b, c, d] => {\n                Some(Ipv4Addr::new(a, b, c, d))\n            }\n            _ => None,\n        }\n    }\n\n    /// Converts this address to an [`IPv4` address]. Returns [`None`] if this address is\n    /// neither IPv4-compatible or IPv4-mapped.\n    ///\n    /// `::a.b.c.d` and `::ffff:a.b.c.d` become `a.b.c.d`\n    ///\n    /// [`IPv4` address]: Ipv4Addr\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4(), None);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4(),\n    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n    ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.50.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub const fn to_ipv4(&self) -> Option<Ipv4Addr> {\n        if let [0, 0, 0, 0, 0, 0 | 0xffff, ab, cd] = self.segments() {\n            let [a, b] = ab.to_be_bytes();\n            let [c, d] = cd.to_be_bytes();\n            Some(Ipv4Addr::new(a, b, c, d))\n        } else {\n            None\n        }\n    }\n\n    /// Returns the sixteen eight-bit integers the IPv6 address consists of.\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n    ///            [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n    #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n    #[inline]\n    pub const fn octets(&self) -> [u8; 16] {\n        self.inner.s6_addr\n    }\n}\n\n/// Write an Ipv6Addr, conforming to the canonical style described by\n/// [RFC 5952](https://tools.ietf.org/html/rfc5952).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Ipv6Addr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // If there are no alignment requirements, write out the IP address to\n        // f. Otherwise, write it to a local buffer, then use f.pad.\n        if f.precision().is_none() && f.width().is_none() {\n            let segments = self.segments();\n\n            // Special case for :: and ::1; otherwise they get written with the\n            // IPv4 formatter\n            if self.is_unspecified() {\n                f.write_str(\"::\")\n            } else if self.is_loopback() {\n                f.write_str(\"::1\")\n            } else if let Some(ipv4) = self.to_ipv4() {\n                match segments[5] {\n                    // IPv4 Compatible address\n                    0 => write!(f, \"::{}\", ipv4),\n                    // IPv4 Mapped address\n                    0xffff => write!(f, \"::ffff:{}\", ipv4),\n                    _ => unreachable!(),\n                }\n            } else {\n                #[derive(Copy, Clone, Default)]\n                struct Span {\n                    start: usize,\n                    len: usize,\n                }\n\n                // Find the inner 0 span\n                let zeroes = {\n                    let mut longest = Span::default();\n                    let mut current = Span::default();\n\n                    for (i, &segment) in segments.iter().enumerate() {\n                        if segment == 0 {\n                            if current.len == 0 {\n                                current.start = i;\n                            }\n\n                            current.len += 1;\n\n                            if current.len > longest.len {\n                                longest = current;\n                            }\n                        } else {\n                            current = Span::default();\n                        }\n                    }\n\n                    longest\n                };\n\n                /// Write a colon-separated part of the address\n                #[inline]\n                fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n                    if let Some((first, tail)) = chunk.split_first() {\n                        write!(f, \"{:x}\", first)?;\n                        for segment in tail {\n                            f.write_char(':')?;\n                            write!(f, \"{:x}\", segment)?;\n                        }\n                    }\n                    Ok(())\n                }\n\n                if zeroes.len > 1 {\n                    fmt_subslice(f, &segments[..zeroes.start])?;\n                    f.write_str(\"::\")?;\n                    fmt_subslice(f, &segments[zeroes.start + zeroes.len..])\n                } else {\n                    fmt_subslice(f, &segments)\n                }\n            }\n        } else {\n            // Slow path: write the address to a local buffer, the use f.pad.\n            // Defined recursively by using the fast path to write to the\n            // buffer.\n\n            // This is the largest possible size of an IPv6 address\n            const IPV6_BUF_LEN: usize = (4 * 8) + 7;\n            let mut buf = [0u8; IPV6_BUF_LEN];\n            let mut buf_slice = &mut buf[..];\n\n            // Note: This call to write should never fail, so unwrap is okay.\n            write!(buf_slice, \"{}\", self).unwrap();\n            let len = IPV6_BUF_LEN - buf_slice.len();\n\n            // This is safe because we know exactly what can be in this buffer\n            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n            f.pad(buf)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Ipv6Addr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for Ipv6Addr {\n    #[inline]\n    fn clone(&self) -> Ipv6Addr {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for Ipv6Addr {\n    #[inline]\n    fn eq(&self, other: &Ipv6Addr) -> bool {\n        self.inner.s6_addr == other.inner.s6_addr\n    }\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialEq<IpAddr> for Ipv6Addr {\n    #[inline]\n    fn eq(&self, other: &IpAddr) -> bool {\n        match other {\n            IpAddr::V4(_) => false,\n            IpAddr::V6(v6) => self == v6,\n        }\n    }\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialEq<Ipv6Addr> for IpAddr {\n    #[inline]\n    fn eq(&self, other: &Ipv6Addr) -> bool {\n        match self {\n            IpAddr::V4(_) => false,\n            IpAddr::V6(v6) => v6 == other,\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for Ipv6Addr {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for Ipv6Addr {\n    #[inline]\n    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n        self.inner.s6_addr.hash(s)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for Ipv6Addr {\n    #[inline]\n    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialOrd<Ipv6Addr> for IpAddr {\n    #[inline]\n    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n        match self {\n            IpAddr::V4(_) => Some(Ordering::Less),\n            IpAddr::V6(v6) => v6.partial_cmp(other),\n        }\n    }\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialOrd<IpAddr> for Ipv6Addr {\n    #[inline]\n    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n        match other {\n            IpAddr::V4(_) => Some(Ordering::Greater),\n            IpAddr::V6(v6) => self.partial_cmp(v6),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for Ipv6Addr {\n    #[inline]\n    fn cmp(&self, other: &Ipv6Addr) -> Ordering {\n        self.segments().cmp(&other.segments())\n    }\n}\n\nimpl AsInner<c::in6_addr> for Ipv6Addr {\n    #[inline]\n    fn as_inner(&self) -> &c::in6_addr {\n        &self.inner\n    }\n}\nimpl FromInner<c::in6_addr> for Ipv6Addr {\n    #[inline]\n    fn from_inner(addr: c::in6_addr) -> Ipv6Addr {\n        Ipv6Addr { inner: addr }\n    }\n}\n\n#[stable(feature = \"i128\", since = \"1.26.0\")]\nimpl From<Ipv6Addr> for u128 {\n    /// Convert an `Ipv6Addr` into a host byte order `u128`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::new(\n    ///     0x1020, 0x3040, 0x5060, 0x7080,\n    ///     0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n    /// );\n    /// assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128, u128::from(addr));\n    /// ```\n    #[inline]\n    fn from(ip: Ipv6Addr) -> u128 {\n        let ip = ip.octets();\n        u128::from_be_bytes(ip)\n    }\n}\n#[stable(feature = \"i128\", since = \"1.26.0\")]\nimpl From<u128> for Ipv6Addr {\n    /// Convert a host byte order `u128` into an `Ipv6Addr`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);\n    /// assert_eq!(\n    ///     Ipv6Addr::new(\n    ///         0x1020, 0x3040, 0x5060, 0x7080,\n    ///         0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n    ///     ),\n    ///     addr);\n    /// ```\n    #[inline]\n    fn from(ip: u128) -> Ipv6Addr {\n        Ipv6Addr::from(ip.to_be_bytes())\n    }\n}\n\n#[stable(feature = \"ipv6_from_octets\", since = \"1.9.0\")]\nimpl From<[u8; 16]> for Ipv6Addr {\n    /// Creates an `Ipv6Addr` from a sixteen element byte array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::from([\n    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n    /// ]);\n    /// assert_eq!(\n    ///     Ipv6Addr::new(\n    ///         0x1918, 0x1716,\n    ///         0x1514, 0x1312,\n    ///         0x1110, 0x0f0e,\n    ///         0x0d0c, 0x0b0a\n    ///     ),\n    ///     addr\n    /// );\n    /// ```\n    #[inline]\n    fn from(octets: [u8; 16]) -> Ipv6Addr {\n        let inner = c::in6_addr { s6_addr: octets };\n        Ipv6Addr::from_inner(inner)\n    }\n}\n\n#[stable(feature = \"ipv6_from_segments\", since = \"1.16.0\")]\nimpl From<[u16; 8]> for Ipv6Addr {\n    /// Creates an `Ipv6Addr` from an eight element 16-bit array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::from([\n    ///     525u16, 524u16, 523u16, 522u16,\n    ///     521u16, 520u16, 519u16, 518u16,\n    /// ]);\n    /// assert_eq!(\n    ///     Ipv6Addr::new(\n    ///         0x20d, 0x20c,\n    ///         0x20b, 0x20a,\n    ///         0x209, 0x208,\n    ///         0x207, 0x206\n    ///     ),\n    ///     addr\n    /// );\n    /// ```\n    #[inline]\n    fn from(segments: [u16; 8]) -> Ipv6Addr {\n        let [a, b, c, d, e, f, g, h] = segments;\n        Ipv6Addr::new(a, b, c, d, e, f, g, h)\n    }\n}\n\n#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\nimpl From<[u8; 16]> for IpAddr {\n    /// Creates an `IpAddr::V6` from a sixteen element byte array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv6Addr};\n    ///\n    /// let addr = IpAddr::from([\n    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n    /// ]);\n    /// assert_eq!(\n    ///     IpAddr::V6(Ipv6Addr::new(\n    ///         0x1918, 0x1716,\n    ///         0x1514, 0x1312,\n    ///         0x1110, 0x0f0e,\n    ///         0x0d0c, 0x0b0a\n    ///     )),\n    ///     addr\n    /// );\n    /// ```\n    #[inline]\n    fn from(octets: [u8; 16]) -> IpAddr {\n        IpAddr::V6(Ipv6Addr::from(octets))\n    }\n}\n\n#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\nimpl From<[u16; 8]> for IpAddr {\n    /// Creates an `IpAddr::V6` from an eight element 16-bit array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv6Addr};\n    ///\n    /// let addr = IpAddr::from([\n    ///     525u16, 524u16, 523u16, 522u16,\n    ///     521u16, 520u16, 519u16, 518u16,\n    /// ]);\n    /// assert_eq!(\n    ///     IpAddr::V6(Ipv6Addr::new(\n    ///         0x20d, 0x20c,\n    ///         0x20b, 0x20a,\n    ///         0x209, 0x208,\n    ///         0x207, 0x206\n    ///     )),\n    ///     addr\n    /// );\n    /// ```\n    #[inline]\n    fn from(segments: [u16; 8]) -> IpAddr {\n        IpAddr::V6(Ipv6Addr::from(segments))\n    }\n}\n"],["2587","use crate::net::test::{sa4, sa6, tsa};\nuse crate::net::*;\n\n#[test]\nfn to_socket_addr_ipaddr_u16() {\n    let a = Ipv4Addr::new(77, 88, 21, 11);\n    let p = 12345;\n    let e = SocketAddr::V4(SocketAddrV4::new(a, p));\n    assert_eq!(Ok(vec![e]), tsa((a, p)));\n}\n\n#[test]\nfn to_socket_addr_str_u16() {\n    let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n    assert_eq!(Ok(vec![a]), tsa((\"77.88.21.11\", 24352)));\n\n    let a = sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n    assert_eq!(Ok(vec![a]), tsa((\"2a02:6b8:0:1::1\", 53)));\n\n    let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n    #[cfg(not(target_env = \"sgx\"))]\n    assert!(tsa((\"localhost\", 23924)).unwrap().contains(&a));\n    #[cfg(target_env = \"sgx\")]\n    let _ = a;\n}\n\n#[test]\nfn to_socket_addr_str() {\n    let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n    assert_eq!(Ok(vec![a]), tsa(\"77.88.21.11:24352\"));\n\n    let a = sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n    assert_eq!(Ok(vec![a]), tsa(\"[2a02:6b8:0:1::1]:53\"));\n\n    let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n    #[cfg(not(target_env = \"sgx\"))]\n    assert!(tsa(\"localhost:23924\").unwrap().contains(&a));\n    #[cfg(target_env = \"sgx\")]\n    let _ = a;\n}\n\n#[test]\nfn to_socket_addr_string() {\n    let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n    assert_eq!(Ok(vec![a]), tsa(&*format!(\"{}:{}\", \"77.88.21.11\", \"24352\")));\n    assert_eq!(Ok(vec![a]), tsa(&format!(\"{}:{}\", \"77.88.21.11\", \"24352\")));\n    assert_eq!(Ok(vec![a]), tsa(format!(\"{}:{}\", \"77.88.21.11\", \"24352\")));\n\n    let s = format!(\"{}:{}\", \"77.88.21.11\", \"24352\");\n    assert_eq!(Ok(vec![a]), tsa(s));\n    // s has been moved into the tsa call\n}\n\n#[test]\nfn bind_udp_socket_bad() {\n    // rust-lang/rust#53957: This is a regression test for a parsing problem\n    // discovered as part of issue rust-lang/rust#23076, where we were\n    // incorrectly parsing invalid input and then that would result in a\n    // successful `UdpSocket` binding when we would expect failure.\n    //\n    // At one time, this test was written as a call to `tsa` with\n    // INPUT_23076. However, that structure yields an unreliable test,\n    // because it ends up passing junk input to the DNS server, and some DNS\n    // servers will respond with `Ok` to such input, with the ip address of\n    // the DNS server itself.\n    //\n    // This form of the test is more robust: even when the DNS server\n    // returns its own address, it is still an error to bind a UDP socket to\n    // a non-local address, and so we still get an error here in that case.\n\n    const INPUT_23076: &str = \"1200::AB00:1234::2552:7777:1313:34300\";\n\n    assert!(crate::net::UdpSocket::bind(INPUT_23076).is_err())\n}\n\n#[test]\nfn set_ip() {\n    fn ip4(low: u8) -> Ipv4Addr {\n        Ipv4Addr::new(77, 88, 21, low)\n    }\n    fn ip6(low: u16) -> Ipv6Addr {\n        Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low)\n    }\n\n    let mut v4 = SocketAddrV4::new(ip4(11), 80);\n    assert_eq!(v4.ip(), &ip4(11));\n    v4.set_ip(ip4(12));\n    assert_eq!(v4.ip(), &ip4(12));\n\n    let mut addr = SocketAddr::V4(v4);\n    assert_eq!(addr.ip(), IpAddr::V4(ip4(12)));\n    addr.set_ip(IpAddr::V4(ip4(13)));\n    assert_eq!(addr.ip(), IpAddr::V4(ip4(13)));\n    addr.set_ip(IpAddr::V6(ip6(14)));\n    assert_eq!(addr.ip(), IpAddr::V6(ip6(14)));\n\n    let mut v6 = SocketAddrV6::new(ip6(1), 80, 0, 0);\n    assert_eq!(v6.ip(), &ip6(1));\n    v6.set_ip(ip6(2));\n    assert_eq!(v6.ip(), &ip6(2));\n\n    let mut addr = SocketAddr::V6(v6);\n    assert_eq!(addr.ip(), IpAddr::V6(ip6(2)));\n    addr.set_ip(IpAddr::V6(ip6(3)));\n    assert_eq!(addr.ip(), IpAddr::V6(ip6(3)));\n    addr.set_ip(IpAddr::V4(ip4(4)));\n    assert_eq!(addr.ip(), IpAddr::V4(ip4(4)));\n}\n\n#[test]\nfn set_port() {\n    let mut v4 = SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80);\n    assert_eq!(v4.port(), 80);\n    v4.set_port(443);\n    assert_eq!(v4.port(), 443);\n\n    let mut addr = SocketAddr::V4(v4);\n    assert_eq!(addr.port(), 443);\n    addr.set_port(8080);\n    assert_eq!(addr.port(), 8080);\n\n    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 0);\n    assert_eq!(v6.port(), 80);\n    v6.set_port(443);\n    assert_eq!(v6.port(), 443);\n\n    let mut addr = SocketAddr::V6(v6);\n    assert_eq!(addr.port(), 443);\n    addr.set_port(8080);\n    assert_eq!(addr.port(), 8080);\n}\n\n#[test]\nfn set_flowinfo() {\n    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 10, 0);\n    assert_eq!(v6.flowinfo(), 10);\n    v6.set_flowinfo(20);\n    assert_eq!(v6.flowinfo(), 20);\n}\n\n#[test]\nfn set_scope_id() {\n    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 10);\n    assert_eq!(v6.scope_id(), 10);\n    v6.set_scope_id(20);\n    assert_eq!(v6.scope_id(), 20);\n}\n\n#[test]\nfn is_v4() {\n    let v4 = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80));\n    assert!(v4.is_ipv4());\n    assert!(!v4.is_ipv6());\n}\n\n#[test]\nfn is_v6() {\n    let v6 = SocketAddr::V6(SocketAddrV6::new(\n        Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1),\n        80,\n        10,\n        0,\n    ));\n    assert!(!v6.is_ipv4());\n    assert!(v6.is_ipv6());\n}\n\n#[test]\nfn socket_v4_to_str() {\n    let socket = SocketAddrV4::new(Ipv4Addr::new(192, 168, 0, 1), 8080);\n\n    assert_eq!(format!(\"{}\", socket), \"192.168.0.1:8080\");\n    assert_eq!(format!(\"{:<20}\", socket), \"192.168.0.1:8080    \");\n    assert_eq!(format!(\"{:>20}\", socket), \"    192.168.0.1:8080\");\n    assert_eq!(format!(\"{:^20}\", socket), \"  192.168.0.1:8080  \");\n    assert_eq!(format!(\"{:.10}\", socket), \"192.168.0.\");\n}\n\n#[test]\nfn socket_v6_to_str() {\n    let mut socket = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0);\n\n    assert_eq!(format!(\"{}\", socket), \"[2a02:6b8:0:1::1]:53\");\n    assert_eq!(format!(\"{:<24}\", socket), \"[2a02:6b8:0:1::1]:53    \");\n    assert_eq!(format!(\"{:>24}\", socket), \"    [2a02:6b8:0:1::1]:53\");\n    assert_eq!(format!(\"{:^24}\", socket), \"  [2a02:6b8:0:1::1]:53  \");\n    assert_eq!(format!(\"{:.15}\", socket), \"[2a02:6b8:0:1::\");\n\n    socket.set_scope_id(5);\n\n    assert_eq!(format!(\"{}\", socket), \"[2a02:6b8:0:1::1%5]:53\");\n    assert_eq!(format!(\"{:<24}\", socket), \"[2a02:6b8:0:1::1%5]:53  \");\n    assert_eq!(format!(\"{:>24}\", socket), \"  [2a02:6b8:0:1::1%5]:53\");\n    assert_eq!(format!(\"{:^24}\", socket), \" [2a02:6b8:0:1::1%5]:53 \");\n    assert_eq!(format!(\"{:.18}\", socket), \"[2a02:6b8:0:1::1%5\");\n}\n\n#[test]\nfn compare() {\n    let v4_1 = \"224.120.45.1:23456\".parse::<SocketAddrV4>().unwrap();\n    let v4_2 = \"224.210.103.5:12345\".parse::<SocketAddrV4>().unwrap();\n    let v4_3 = \"224.210.103.5:23456\".parse::<SocketAddrV4>().unwrap();\n    let v6_1 = \"[2001:db8:f00::1002]:23456\".parse::<SocketAddrV6>().unwrap();\n    let v6_2 = \"[2001:db8:f00::2001]:12345\".parse::<SocketAddrV6>().unwrap();\n    let v6_3 = \"[2001:db8:f00::2001]:23456\".parse::<SocketAddrV6>().unwrap();\n\n    // equality\n    assert_eq!(v4_1, v4_1);\n    assert_eq!(v6_1, v6_1);\n    assert_eq!(SocketAddr::V4(v4_1), SocketAddr::V4(v4_1));\n    assert_eq!(SocketAddr::V6(v6_1), SocketAddr::V6(v6_1));\n    assert!(v4_1 != v4_2);\n    assert!(v6_1 != v6_2);\n\n    // compare different addresses\n    assert!(v4_1 < v4_2);\n    assert!(v6_1 < v6_2);\n    assert!(v4_2 > v4_1);\n    assert!(v6_2 > v6_1);\n\n    // compare the same address with different ports\n    assert!(v4_2 < v4_3);\n    assert!(v6_2 < v6_3);\n    assert!(v4_3 > v4_2);\n    assert!(v6_3 > v6_2);\n\n    // compare different addresses with the same port\n    assert!(v4_1 < v4_3);\n    assert!(v6_1 < v6_3);\n    assert!(v4_3 > v4_1);\n    assert!(v6_3 > v6_1);\n\n    // compare with an inferred right-hand side\n    assert_eq!(v4_1, \"224.120.45.1:23456\".parse().unwrap());\n    assert_eq!(v6_1, \"[2001:db8:f00::1002]:23456\".parse().unwrap());\n    assert_eq!(SocketAddr::V4(v4_1), \"224.120.45.1:23456\".parse().unwrap());\n}\n"],["2588","#![allow(warnings)] // not used on emscripten\n\nuse crate::env;\nuse crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\nuse crate::sync::atomic::{AtomicUsize, Ordering};\n\nstatic PORT: AtomicUsize = AtomicUsize::new(0);\n\npub fn next_test_ip4() -> SocketAddr {\n    let port = PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port();\n    SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), port))\n}\n\npub fn next_test_ip6() -> SocketAddr {\n    let port = PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port();\n    SocketAddr::V6(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), port, 0, 0))\n}\n\npub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n    SocketAddr::V4(SocketAddrV4::new(a, p))\n}\n\npub fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr {\n    SocketAddr::V6(SocketAddrV6::new(a, p, 0, 0))\n}\n\npub fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> {\n    match a.to_socket_addrs() {\n        Ok(a) => Ok(a.collect()),\n        Err(e) => Err(e.to_string()),\n    }\n}\n\n// The bots run multiple builds at the same time, and these builds\n// all want to use ports. This function figures out which workspace\n// it is running in and assigns a port range based on it.\nfn base_port() -> u16 {\n    let cwd = if cfg!(target_env = \"sgx\") {\n        String::from(\"sgx\")\n    } else {\n        env::current_dir().unwrap().into_os_string().into_string().unwrap()\n    };\n    let dirs = [\n        \"32-opt\",\n        \"32-nopt\",\n        \"musl-64-opt\",\n        \"cross-opt\",\n        \"64-opt\",\n        \"64-nopt\",\n        \"64-opt-vg\",\n        \"64-debug-opt\",\n        \"all-opt\",\n        \"snap3\",\n        \"dist\",\n        \"sgx\",\n    ];\n    dirs.iter().enumerate().find(|&(_, dir)| cwd.contains(dir)).map(|p| p.0).unwrap_or(0) as u16\n        * 1000\n        + 19600\n}\n"],["2589","//! Networking primitives for TCP/UDP communication.\n//!\n//! This module provides networking functionality for the Transmission Control and User\n//! Datagram Protocols, as well as types for IP and socket addresses.\n//!\n//! # Organization\n//!\n//! * [`TcpListener`] and [`TcpStream`] provide functionality for communication over TCP\n//! * [`UdpSocket`] provides functionality for communication over UDP\n//! * [`IpAddr`] represents IP addresses of either IPv4 or IPv6; [`Ipv4Addr`] and\n//!   [`Ipv6Addr`] are respectively IPv4 and IPv6 addresses\n//! * [`SocketAddr`] represents socket addresses of either IPv4 or IPv6; [`SocketAddrV4`]\n//!   and [`SocketAddrV6`] are respectively IPv4 and IPv6 socket addresses\n//! * [`ToSocketAddrs`] is a trait that used for generic address resolution when interacting\n//!   with networking objects like [`TcpListener`], [`TcpStream`] or [`UdpSocket`]\n//! * Other types are return or parameter types for various methods in this module\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::io::{self, Error, ErrorKind};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::parser::AddrParseError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::tcp::{Incoming, TcpListener, TcpStream};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::udp::UdpSocket;\n\nmod addr;\nmod ip;\nmod parser;\nmod tcp;\n#[cfg(test)]\nmod test;\nmod udp;\n\n/// Possible values which can be passed to the [`TcpStream::shutdown`] method.\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Shutdown {\n    /// The reading portion of the [`TcpStream`] should be shut down.\n    ///\n    /// All currently blocked and future [reads] will return [`Ok`]`(0)`.\n    ///\n    /// [reads]: crate::io::Read\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Read,\n    /// The writing portion of the [`TcpStream`] should be shut down.\n    ///\n    /// All currently blocked and future [writes] will return an error.\n    ///\n    /// [writes]: crate::io::Write\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Write,\n    /// Both the reading and the writing portions of the [`TcpStream`] should be shut down.\n    ///\n    /// See [`Shutdown::Read`] and [`Shutdown::Write`] for more information.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Both,\n}\n\n#[inline]\nconst fn htons(i: u16) -> u16 {\n    i.to_be()\n}\n#[inline]\nconst fn ntohs(i: u16) -> u16 {\n    u16::from_be(i)\n}\n\nfn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\nwhere\n    F: FnMut(io::Result<&SocketAddr>) -> io::Result<T>,\n{\n    let addrs = match addr.to_socket_addrs() {\n        Ok(addrs) => addrs,\n        Err(e) => return f(Err(e)),\n    };\n    let mut last_err = None;\n    for addr in addrs {\n        match f(Ok(&addr)) {\n            Ok(l) => return Ok(l),\n            Err(e) => last_err = Some(e),\n        }\n    }\n    Err(last_err.unwrap_or_else(|| {\n        Error::new_const(ErrorKind::InvalidInput, &\"could not resolve to any addresses\")\n    }))\n}\n"],["2590","#[cfg(all(test, not(any(target_os = \"emscripten\", target_env = \"sgx\"))))]\nmod tests;\n\nuse crate::fmt;\nuse crate::io::{self, Error, ErrorKind};\nuse crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, ToSocketAddrs};\nuse crate::sys_common::net as net_imp;\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\nuse crate::time::Duration;\n\n/// A UDP socket.\n///\n/// After creating a `UdpSocket` by [`bind`]ing it to a socket address, data can be\n/// [sent to] and [received from] any other socket address.\n///\n/// Although UDP is a connectionless protocol, this implementation provides an interface\n/// to set an address where data should be sent and received from. After setting a remote\n/// address with [`connect`], data can be sent to and received from that address with\n/// [`send`] and [`recv`].\n///\n/// As stated in the User Datagram Protocol's specification in [IETF RFC 768], UDP is\n/// an unordered, unreliable protocol; refer to [`TcpListener`] and [`TcpStream`] for TCP\n/// primitives.\n///\n/// [`bind`]: UdpSocket::bind\n/// [`connect`]: UdpSocket::connect\n/// [IETF RFC 768]: https://tools.ietf.org/html/rfc768\n/// [`recv`]: UdpSocket::recv\n/// [received from]: UdpSocket::recv_from\n/// [`send`]: UdpSocket::send\n/// [sent to]: UdpSocket::send_to\n/// [`TcpListener`]: crate::net::TcpListener\n/// [`TcpStream`]: crate::net::TcpStream\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::net::UdpSocket;\n///\n/// fn main() -> std::io::Result<()> {\n///     {\n///         let mut socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n///\n///         // Receives a single datagram message on the socket. If `buf` is too small to hold\n///         // the message, it will be cut off.\n///         let mut buf = [0; 10];\n///         let (amt, src) = socket.recv_from(&mut buf)?;\n///\n///         // Redeclare `buf` as slice of the received data and send reverse data back to origin.\n///         let buf = &mut buf[..amt];\n///         buf.reverse();\n///         socket.send_to(buf, &src)?;\n///     } // the socket is closed here\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct UdpSocket(net_imp::UdpSocket);\n\nimpl UdpSocket {\n    /// Creates a UDP socket from the given address.\n    ///\n    /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n    /// its documentation for concrete examples.\n    ///\n    /// If `addr` yields multiple addresses, `bind` will be attempted with\n    /// each of the addresses until one succeeds and returns the socket. If none\n    /// of the addresses succeed in creating a socket, the error returned from\n    /// the last attempt (the last address) is returned.\n    ///\n    /// # Examples\n    ///\n    /// Creates a UDP socket bound to `127.0.0.1:3400`:\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n    /// ```\n    ///\n    /// Creates a UDP socket bound to `127.0.0.1:3400`. If the socket cannot be\n    /// bound to that address, create a UDP socket bound to `127.0.0.1:3401`:\n    ///\n    /// ```no_run\n    /// use std::net::{SocketAddr, UdpSocket};\n    ///\n    /// let addrs = [\n    ///     SocketAddr::from(([127, 0, 0, 1], 3400)),\n    ///     SocketAddr::from(([127, 0, 0, 1], 3401)),\n    /// ];\n    /// let socket = UdpSocket::bind(&addrs[..]).expect(\"couldn't bind to address\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n        super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n    }\n\n    /// Receives a single datagram message on the socket. On success, returns the number\n    /// of bytes read and the origin.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient size to\n    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n    /// excess bytes may be discarded.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// let mut buf = [0; 10];\n    /// let (number_of_bytes, src_addr) = socket.recv_from(&mut buf)\n    ///                                         .expect(\"Didn't receive data\");\n    /// let filled_buf = &mut buf[..number_of_bytes];\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.0.recv_from(buf)\n    }\n\n    /// Receives a single datagram message on the socket, without removing it from the\n    /// queue. On success, returns the number of bytes read and the origin.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient size to\n    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n    /// excess bytes may be discarded.\n    ///\n    /// Successive calls return the same data. This is accomplished by passing\n    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n    ///\n    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n    /// synchronize IO events on one or more sockets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// let mut buf = [0; 10];\n    /// let (number_of_bytes, src_addr) = socket.peek_from(&mut buf)\n    ///                                         .expect(\"Didn't receive data\");\n    /// let filled_buf = &mut buf[..number_of_bytes];\n    /// ```\n    #[stable(feature = \"peek\", since = \"1.18.0\")]\n    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.0.peek_from(buf)\n    }\n\n    /// Sends data on the socket to the given address. On success, returns the\n    /// number of bytes written.\n    ///\n    /// Address type can be any implementor of [`ToSocketAddrs`] trait. See its\n    /// documentation for concrete examples.\n    ///\n    /// It is possible for `addr` to yield multiple addresses, but `send_to`\n    /// will only send data to the first address yielded by `addr`.\n    ///\n    /// This will return an error when the IP version of the local socket\n    /// does not match that returned from [`ToSocketAddrs`].\n    ///\n    /// See [Issue #34202] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.send_to(&[0; 10], \"127.0.0.1:4242\").expect(\"couldn't send data\");\n    /// ```\n    ///\n    /// [Issue #34202]: https://github.com/rust-lang/rust/issues/34202\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A) -> io::Result<usize> {\n        match addr.to_socket_addrs()?.next() {\n            Some(addr) => self.0.send_to(buf, &addr),\n            None => Err(Error::new_const(ErrorKind::InvalidInput, &\"no addresses to send data to\")),\n        }\n    }\n\n    /// Returns the socket address of the remote peer this socket was connected to.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"192.168.0.1:41203\").expect(\"couldn't connect to address\");\n    /// assert_eq!(socket.peer_addr().unwrap(),\n    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(192, 168, 0, 1), 41203)));\n    /// ```\n    ///\n    /// If the socket isn't connected, it will return a [`NotConnected`] error.\n    ///\n    /// [`NotConnected`]: io::ErrorKind::NotConnected\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// assert_eq!(socket.peer_addr().unwrap_err().kind(),\n    ///            std::io::ErrorKind::NotConnected);\n    /// ```\n    #[stable(feature = \"udp_peer_addr\", since = \"1.40.0\")]\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        self.0.peer_addr()\n    }\n\n    /// Returns the socket address that this socket was created from.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// assert_eq!(socket.local_addr().unwrap(),\n    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 34254)));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n        self.0.socket_addr()\n    }\n\n    /// Creates a new independently owned handle to the underlying socket.\n    ///\n    /// The returned `UdpSocket` is a reference to the same socket that this\n    /// object references. Both handles will read and write the same port, and\n    /// options set on one socket will be propagated to the other.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// let socket_clone = socket.try_clone().expect(\"couldn't clone the socket\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_clone(&self) -> io::Result<UdpSocket> {\n        self.0.duplicate().map(UdpSocket)\n    }\n\n    /// Sets the read timeout to the timeout specified.\n    ///\n    /// If the value specified is [`None`], then [`read`] calls will block\n    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n    /// passed to this method.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Platforms may return a different error code whenever a read times out as\n    /// a result of setting this option. For example Unix typically returns an\n    /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n    ///\n    /// [`read`]: io::Read::read\n    /// [`WouldBlock`]: io::ErrorKind::WouldBlock\n    /// [`TimedOut`]: io::ErrorKind::TimedOut\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n    /// ```\n    ///\n    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n    /// method:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::UdpSocket;\n    /// use std::time::Duration;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        self.0.set_read_timeout(dur)\n    }\n\n    /// Sets the write timeout to the timeout specified.\n    ///\n    /// If the value specified is [`None`], then [`write`] calls will block\n    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n    /// passed to this method.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Platforms may return a different error code whenever a write times out\n    /// as a result of setting this option. For example Unix typically returns\n    /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n    ///\n    /// [`write`]: io::Write::write\n    /// [`WouldBlock`]: io::ErrorKind::WouldBlock\n    /// [`TimedOut`]: io::ErrorKind::TimedOut\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n    /// ```\n    ///\n    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n    /// method:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::UdpSocket;\n    /// use std::time::Duration;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        self.0.set_write_timeout(dur)\n    }\n\n    /// Returns the read timeout of this socket.\n    ///\n    /// If the timeout is [`None`], then [`read`] calls will block indefinitely.\n    ///\n    /// [`read`]: io::Read::read\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n    /// assert_eq!(socket.read_timeout().unwrap(), None);\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0.read_timeout()\n    }\n\n    /// Returns the write timeout of this socket.\n    ///\n    /// If the timeout is [`None`], then [`write`] calls will block indefinitely.\n    ///\n    /// [`write`]: io::Write::write\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n    /// assert_eq!(socket.write_timeout().unwrap(), None);\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0.write_timeout()\n    }\n\n    /// Sets the value of the `SO_BROADCAST` option for this socket.\n    ///\n    /// When enabled, this socket is allowed to send packets to a broadcast\n    /// address.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_broadcast(false).expect(\"set_broadcast call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {\n        self.0.set_broadcast(broadcast)\n    }\n\n    /// Gets the value of the `SO_BROADCAST` option for this socket.\n    ///\n    /// For more information about this option, see [`UdpSocket::set_broadcast`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_broadcast(false).expect(\"set_broadcast call failed\");\n    /// assert_eq!(socket.broadcast().unwrap(), false);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn broadcast(&self) -> io::Result<bool> {\n        self.0.broadcast()\n    }\n\n    /// Sets the value of the `IP_MULTICAST_LOOP` option for this socket.\n    ///\n    /// If enabled, multicast packets will be looped back to the local socket.\n    /// Note that this may not have any effect on IPv6 sockets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n        self.0.set_multicast_loop_v4(multicast_loop_v4)\n    }\n\n    /// Gets the value of the `IP_MULTICAST_LOOP` option for this socket.\n    ///\n    /// For more information about this option, see [`UdpSocket::set_multicast_loop_v4`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");\n    /// assert_eq!(socket.multicast_loop_v4().unwrap(), false);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n        self.0.multicast_loop_v4()\n    }\n\n    /// Sets the value of the `IP_MULTICAST_TTL` option for this socket.\n    ///\n    /// Indicates the time-to-live value of outgoing multicast packets for\n    /// this socket. The default value is 1 which means that multicast packets\n    /// don't leave the local network unless explicitly requested.\n    ///\n    /// Note that this may not have any effect on IPv6 sockets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n        self.0.set_multicast_ttl_v4(multicast_ttl_v4)\n    }\n\n    /// Gets the value of the `IP_MULTICAST_TTL` option for this socket.\n    ///\n    /// For more information about this option, see [`UdpSocket::set_multicast_ttl_v4`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");\n    /// assert_eq!(socket.multicast_ttl_v4().unwrap(), 42);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n        self.0.multicast_ttl_v4()\n    }\n\n    /// Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n    ///\n    /// Controls whether this socket sees the multicast packets it sends itself.\n    /// Note that this may not have any affect on IPv4 sockets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n        self.0.set_multicast_loop_v6(multicast_loop_v6)\n    }\n\n    /// Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n    ///\n    /// For more information about this option, see [`UdpSocket::set_multicast_loop_v6`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");\n    /// assert_eq!(socket.multicast_loop_v6().unwrap(), false);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n        self.0.multicast_loop_v6()\n    }\n\n    /// Sets the value for the `IP_TTL` option on this socket.\n    ///\n    /// This value sets the time-to-live field that is used in every packet sent\n    /// from this socket.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_ttl(42).expect(\"set_ttl call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n        self.0.set_ttl(ttl)\n    }\n\n    /// Gets the value of the `IP_TTL` option for this socket.\n    ///\n    /// For more information about this option, see [`UdpSocket::set_ttl`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_ttl(42).expect(\"set_ttl call failed\");\n    /// assert_eq!(socket.ttl().unwrap(), 42);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn ttl(&self) -> io::Result<u32> {\n        self.0.ttl()\n    }\n\n    /// Executes an operation of the `IP_ADD_MEMBERSHIP` type.\n    ///\n    /// This function specifies a new multicast group for this socket to join.\n    /// The address must be a valid multicast address, and `interface` is the\n    /// address of the local interface with which the system should join the\n    /// multicast group. If it's equal to `INADDR_ANY` then an appropriate\n    /// interface is chosen by the system.\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n        self.0.join_multicast_v4(multiaddr, interface)\n    }\n\n    /// Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.\n    ///\n    /// This function specifies a new multicast group for this socket to join.\n    /// The address must be a valid multicast address, and `interface` is the\n    /// index of the interface to join/leave (or 0 to indicate any interface).\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n        self.0.join_multicast_v6(multiaddr, interface)\n    }\n\n    /// Executes an operation of the `IP_DROP_MEMBERSHIP` type.\n    ///\n    /// For more information about this option, see [`UdpSocket::join_multicast_v4`].\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n        self.0.leave_multicast_v4(multiaddr, interface)\n    }\n\n    /// Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.\n    ///\n    /// For more information about this option, see [`UdpSocket::join_multicast_v6`].\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n        self.0.leave_multicast_v6(multiaddr, interface)\n    }\n\n    /// Gets the value of the `SO_ERROR` option on this socket.\n    ///\n    /// This will retrieve the stored error in the underlying socket, clearing\n    /// the field in the process. This can be useful for checking errors between\n    /// calls.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// match socket.take_error() {\n    ///     Ok(Some(error)) => println!(\"UdpSocket error: {:?}\", error),\n    ///     Ok(None) => println!(\"No error\"),\n    ///     Err(error) => println!(\"UdpSocket.take_error failed: {:?}\", error),\n    /// }\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.0.take_error()\n    }\n\n    /// Connects this UDP socket to a remote address, allowing the `send` and\n    /// `recv` syscalls to be used to send data and also applies filters to only\n    /// receive data from the specified address.\n    ///\n    /// If `addr` yields multiple addresses, `connect` will be attempted with\n    /// each of the addresses until the underlying OS function returns no\n    /// error. Note that usually, a successful `connect` call does not specify\n    /// that there is a remote server listening on the port, rather, such an\n    /// error would only be detected after the first send. If the OS returns an\n    /// error for each of the specified addresses, the error returned from the\n    /// last connection attempt (the last address) is returned.\n    ///\n    /// # Examples\n    ///\n    /// Creates a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n    /// `127.0.0.1:8080`:\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n    /// ```\n    ///\n    /// Unlike in the TCP case, passing an array of addresses to the `connect`\n    /// function of a UDP socket is not a useful thing to do: The OS will be\n    /// unable to determine whether something is listening on the remote\n    /// address without the application sending data.\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n        super::each_addr(addr, |addr| self.0.connect(addr))\n    }\n\n    /// Sends data on the socket to the remote address to which it is connected.\n    ///\n    /// [`UdpSocket::connect`] will connect this socket to a remote address. This\n    /// method will fail if the socket is not connected.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n    /// socket.send(&[0, 1, 2]).expect(\"couldn't send message\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n        self.0.send(buf)\n    }\n\n    /// Receives a single datagram message on the socket from the remote address to\n    /// which it is connected. On success, returns the number of bytes read.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient size to\n    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n    /// excess bytes may be discarded.\n    ///\n    /// [`UdpSocket::connect`] will connect this socket to a remote address. This\n    /// method will fail if the socket is not connected.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n    /// let mut buf = [0; 10];\n    /// match socket.recv(&mut buf) {\n    ///     Ok(received) => println!(\"received {} bytes {:?}\", received, &buf[..received]),\n    ///     Err(e) => println!(\"recv function failed: {:?}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.recv(buf)\n    }\n\n    /// Receives single datagram on the socket from the remote address to which it is\n    /// connected, without removing the message from input queue. On success, returns\n    /// the number of bytes peeked.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient size to\n    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n    /// excess bytes may be discarded.\n    ///\n    /// Successive calls return the same data. This is accomplished by passing\n    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n    ///\n    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n    /// synchronize IO events on one or more sockets.\n    ///\n    /// [`UdpSocket::connect`] will connect this socket to a remote address. This\n    /// method will fail if the socket is not connected.\n    ///\n    /// # Errors\n    ///\n    /// This method will fail if the socket is not connected. The `connect` method\n    /// will connect this socket to a remote address.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n    /// let mut buf = [0; 10];\n    /// match socket.peek(&mut buf) {\n    ///     Ok(received) => println!(\"received {} bytes\", received),\n    ///     Err(e) => println!(\"peek function failed: {:?}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"peek\", since = \"1.18.0\")]\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.peek(buf)\n    }\n\n    /// Moves this UDP socket into or out of nonblocking mode.\n    ///\n    /// This will result in `recv`, `recv_from`, `send`, and `send_to`\n    /// operations becoming nonblocking, i.e., immediately returning from their\n    /// calls. If the IO operation is successful, `Ok` is returned and no\n    /// further action is required. If the IO operation could not be completed\n    /// and needs to be retried, an error with kind\n    /// [`io::ErrorKind::WouldBlock`] is returned.\n    ///\n    /// On Unix platforms, calling this method corresponds to calling `fcntl`\n    /// `FIONBIO`. On Windows calling this method corresponds to calling\n    /// `ioctlsocket` `FIONBIO`.\n    ///\n    /// # Examples\n    ///\n    /// Creates a UDP socket bound to `127.0.0.1:7878` and read bytes in\n    /// nonblocking mode:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:7878\").unwrap();\n    /// socket.set_nonblocking(true).unwrap();\n    ///\n    /// # fn wait_for_fd() { unimplemented!() }\n    /// let mut buf = [0; 10];\n    /// let (num_bytes_read, _) = loop {\n    ///     match socket.recv_from(&mut buf) {\n    ///         Ok(n) => break n,\n    ///         Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///             // wait until network socket is ready, typically implemented\n    ///             // via platform-specific APIs such as epoll or IOCP\n    ///             wait_for_fd();\n    ///         }\n    ///         Err(e) => panic!(\"encountered IO error: {}\", e),\n    ///     }\n    /// };\n    /// println!(\"bytes: {:?}\", &buf[..num_bytes_read]);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        self.0.set_nonblocking(nonblocking)\n    }\n}\n\nimpl AsInner<net_imp::UdpSocket> for UdpSocket {\n    fn as_inner(&self) -> &net_imp::UdpSocket {\n        &self.0\n    }\n}\n\nimpl FromInner<net_imp::UdpSocket> for UdpSocket {\n    fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket {\n        UdpSocket(inner)\n    }\n}\n\nimpl IntoInner<net_imp::UdpSocket> for UdpSocket {\n    fn into_inner(self) -> net_imp::UdpSocket {\n        self.0\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for UdpSocket {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n"],["2591","use crate::fmt;\nuse crate::io::prelude::*;\nuse crate::io::{ErrorKind, IoSlice, IoSliceMut};\nuse crate::net::test::{next_test_ip4, next_test_ip6};\nuse crate::net::*;\nuse crate::sync::mpsc::channel;\nuse crate::thread;\nuse crate::time::{Duration, Instant};\n\nfn each_ip(f: &mut dyn FnMut(SocketAddr)) {\n    f(next_test_ip4());\n    f(next_test_ip6());\n}\n\nmacro_rules! t {\n    ($e:expr) => {\n        match $e {\n            Ok(t) => t,\n            Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n        }\n    };\n}\n\n#[test]\nfn bind_error() {\n    match TcpListener::bind(\"1.1.1.1:9999\") {\n        Ok(..) => panic!(),\n        Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n    }\n}\n\n#[test]\nfn connect_error() {\n    match TcpStream::connect(\"0.0.0.0:1\") {\n        Ok(..) => panic!(),\n        Err(e) => assert!(\n            e.kind() == ErrorKind::ConnectionRefused\n                || e.kind() == ErrorKind::InvalidInput\n                || e.kind() == ErrorKind::AddrInUse\n                || e.kind() == ErrorKind::AddrNotAvailable,\n            \"bad error: {} {:?}\",\n            e,\n            e.kind()\n        ),\n    }\n}\n\n#[test]\nfn listen_localhost() {\n    let socket_addr = next_test_ip4();\n    let listener = t!(TcpListener::bind(&socket_addr));\n\n    let _t = thread::spawn(move || {\n        let mut stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n        t!(stream.write(&[144]));\n    });\n\n    let mut stream = t!(listener.accept()).0;\n    let mut buf = [0];\n    t!(stream.read(&mut buf));\n    assert!(buf[0] == 144);\n}\n\n#[test]\nfn connect_loopback() {\n    each_ip(&mut |addr| {\n        let acceptor = t!(TcpListener::bind(&addr));\n\n        let _t = thread::spawn(move || {\n            let host = match addr {\n                SocketAddr::V4(..) => \"127.0.0.1\",\n                SocketAddr::V6(..) => \"::1\",\n            };\n            let mut stream = t!(TcpStream::connect(&(host, addr.port())));\n            t!(stream.write(&[66]));\n        });\n\n        let mut stream = t!(acceptor.accept()).0;\n        let mut buf = [0];\n        t!(stream.read(&mut buf));\n        assert!(buf[0] == 66);\n    })\n}\n\n#[test]\nfn smoke_test() {\n    each_ip(&mut |addr| {\n        let acceptor = t!(TcpListener::bind(&addr));\n\n        let (tx, rx) = channel();\n        let _t = thread::spawn(move || {\n            let mut stream = t!(TcpStream::connect(&addr));\n            t!(stream.write(&[99]));\n            tx.send(t!(stream.local_addr())).unwrap();\n        });\n\n        let (mut stream, addr) = t!(acceptor.accept());\n        let mut buf = [0];\n        t!(stream.read(&mut buf));\n        assert!(buf[0] == 99);\n        assert_eq!(addr, t!(rx.recv()));\n    })\n}\n\n#[test]\nfn read_eof() {\n    each_ip(&mut |addr| {\n        let acceptor = t!(TcpListener::bind(&addr));\n\n        let _t = thread::spawn(move || {\n            let _stream = t!(TcpStream::connect(&addr));\n            // Close\n        });\n\n        let mut stream = t!(acceptor.accept()).0;\n        let mut buf = [0];\n        let nread = t!(stream.read(&mut buf));\n        assert_eq!(nread, 0);\n        let nread = t!(stream.read(&mut buf));\n        assert_eq!(nread, 0);\n    })\n}\n\n#[test]\nfn write_close() {\n    each_ip(&mut |addr| {\n        let acceptor = t!(TcpListener::bind(&addr));\n\n        let (tx, rx) = channel();\n        let _t = thread::spawn(move || {\n            drop(t!(TcpStream::connect(&addr)));\n            tx.send(()).unwrap();\n        });\n\n        let mut stream = t!(acceptor.accept()).0;\n        rx.recv().unwrap();\n        let buf = [0];\n        match stream.write(&buf) {\n            Ok(..) => {}\n            Err(e) => {\n                assert!(\n                    e.kind() == ErrorKind::ConnectionReset\n                        || e.kind() == ErrorKind::BrokenPipe\n                        || e.kind() == ErrorKind::ConnectionAborted,\n                    \"unknown error: {}\",\n                    e\n                );\n            }\n        }\n    })\n}\n\n#[test]\nfn multiple_connect_serial() {\n    each_ip(&mut |addr| {\n        let max = 10;\n        let acceptor = t!(TcpListener::bind(&addr));\n\n        let _t = thread::spawn(move || {\n            for _ in 0..max {\n                let mut stream = t!(TcpStream::connect(&addr));\n                t!(stream.write(&[99]));\n            }\n        });\n\n        for stream in acceptor.incoming().take(max) {\n            let mut stream = t!(stream);\n            let mut buf = [0];\n            t!(stream.read(&mut buf));\n            assert_eq!(buf[0], 99);\n        }\n    })\n}\n\n#[test]\nfn multiple_connect_interleaved_greedy_schedule() {\n    const MAX: usize = 10;\n    each_ip(&mut |addr| {\n        let acceptor = t!(TcpListener::bind(&addr));\n\n        let _t = thread::spawn(move || {\n            let acceptor = acceptor;\n            for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n                // Start another thread to handle the connection\n                let _t = thread::spawn(move || {\n                    let mut stream = t!(stream);\n                    let mut buf = [0];\n                    t!(stream.read(&mut buf));\n                    assert!(buf[0] == i as u8);\n                });\n            }\n        });\n\n        connect(0, addr);\n    });\n\n    fn connect(i: usize, addr: SocketAddr) {\n        if i == MAX {\n            return;\n        }\n\n        let t = thread::spawn(move || {\n            let mut stream = t!(TcpStream::connect(&addr));\n            // Connect again before writing\n            connect(i + 1, addr);\n            t!(stream.write(&[i as u8]));\n        });\n        t.join().ok().expect(\"thread panicked\");\n    }\n}\n\n#[test]\nfn multiple_connect_interleaved_lazy_schedule() {\n    const MAX: usize = 10;\n    each_ip(&mut |addr| {\n        let acceptor = t!(TcpListener::bind(&addr));\n\n        let _t = thread::spawn(move || {\n            for stream in acceptor.incoming().take(MAX) {\n                // Start another thread to handle the connection\n                let _t = thread::spawn(move || {\n                    let mut stream = t!(stream);\n                    let mut buf = [0];\n                    t!(stream.read(&mut buf));\n                    assert!(buf[0] == 99);\n                });\n            }\n        });\n\n        connect(0, addr);\n    });\n\n    fn connect(i: usize, addr: SocketAddr) {\n        if i == MAX {\n            return;\n        }\n\n        let t = thread::spawn(move || {\n            let mut stream = t!(TcpStream::connect(&addr));\n            connect(i + 1, addr);\n            t!(stream.write(&[99]));\n        });\n        t.join().ok().expect(\"thread panicked\");\n    }\n}\n\n#[test]\nfn socket_and_peer_name() {\n    each_ip(&mut |addr| {\n        let listener = t!(TcpListener::bind(&addr));\n        let so_name = t!(listener.local_addr());\n        assert_eq!(addr, so_name);\n        let _t = thread::spawn(move || {\n            t!(listener.accept());\n        });\n\n        let stream = t!(TcpStream::connect(&addr));\n        assert_eq!(addr, t!(stream.peer_addr()));\n    })\n}\n\n#[test]\nfn partial_read() {\n    each_ip(&mut |addr| {\n        let (tx, rx) = channel();\n        let srv = t!(TcpListener::bind(&addr));\n        let _t = thread::spawn(move || {\n            let mut cl = t!(srv.accept()).0;\n            cl.write(&[10]).unwrap();\n            let mut b = [0];\n            t!(cl.read(&mut b));\n            tx.send(()).unwrap();\n        });\n\n        let mut c = t!(TcpStream::connect(&addr));\n        let mut b = [0; 10];\n        assert_eq!(c.read(&mut b).unwrap(), 1);\n        t!(c.write(&[1]));\n        rx.recv().unwrap();\n    })\n}\n\n#[test]\nfn read_vectored() {\n    each_ip(&mut |addr| {\n        let srv = t!(TcpListener::bind(&addr));\n        let mut s1 = t!(TcpStream::connect(&addr));\n        let mut s2 = t!(srv.accept()).0;\n\n        let len = s1.write(&[10, 11, 12]).unwrap();\n        assert_eq!(len, 3);\n\n        let mut a = [];\n        let mut b = [0];\n        let mut c = [0; 3];\n        let len = t!(s2.read_vectored(&mut [\n            IoSliceMut::new(&mut a),\n            IoSliceMut::new(&mut b),\n            IoSliceMut::new(&mut c)\n        ],));\n        assert!(len > 0);\n        assert_eq!(b, [10]);\n        // some implementations don't support readv, so we may only fill the first buffer\n        assert!(len == 1 || c == [11, 12, 0]);\n    })\n}\n\n#[test]\nfn write_vectored() {\n    each_ip(&mut |addr| {\n        let srv = t!(TcpListener::bind(&addr));\n        let mut s1 = t!(TcpStream::connect(&addr));\n        let mut s2 = t!(srv.accept()).0;\n\n        let a = [];\n        let b = [10];\n        let c = [11, 12];\n        t!(s1.write_vectored(&[IoSlice::new(&a), IoSlice::new(&b), IoSlice::new(&c)]));\n\n        let mut buf = [0; 4];\n        let len = t!(s2.read(&mut buf));\n        // some implementations don't support writev, so we may only write the first buffer\n        if len == 1 {\n            assert_eq!(buf, [10, 0, 0, 0]);\n        } else {\n            assert_eq!(len, 3);\n            assert_eq!(buf, [10, 11, 12, 0]);\n        }\n    })\n}\n\n#[test]\nfn double_bind() {\n    each_ip(&mut |addr| {\n        let listener1 = t!(TcpListener::bind(&addr));\n        match TcpListener::bind(&addr) {\n            Ok(listener2) => panic!(\n                \"This system (perhaps due to options set by TcpListener::bind) \\\n                 permits double binding: {:?} and {:?}\",\n                listener1, listener2\n            ),\n            Err(e) => {\n                assert!(\n                    e.kind() == ErrorKind::ConnectionRefused\n                        || e.kind() == ErrorKind::Other\n                        || e.kind() == ErrorKind::AddrInUse,\n                    \"unknown error: {} {:?}\",\n                    e,\n                    e.kind()\n                );\n            }\n        }\n    })\n}\n\n#[test]\nfn tcp_clone_smoke() {\n    each_ip(&mut |addr| {\n        let acceptor = t!(TcpListener::bind(&addr));\n\n        let _t = thread::spawn(move || {\n            let mut s = t!(TcpStream::connect(&addr));\n            let mut buf = [0, 0];\n            assert_eq!(s.read(&mut buf).unwrap(), 1);\n            assert_eq!(buf[0], 1);\n            t!(s.write(&[2]));\n        });\n\n        let mut s1 = t!(acceptor.accept()).0;\n        let s2 = t!(s1.try_clone());\n\n        let (tx1, rx1) = channel();\n        let (tx2, rx2) = channel();\n        let _t = thread::spawn(move || {\n            let mut s2 = s2;\n            rx1.recv().unwrap();\n            t!(s2.write(&[1]));\n            tx2.send(()).unwrap();\n        });\n        tx1.send(()).unwrap();\n        let mut buf = [0, 0];\n        assert_eq!(s1.read(&mut buf).unwrap(), 1);\n        rx2.recv().unwrap();\n    })\n}\n\n#[test]\nfn tcp_clone_two_read() {\n    each_ip(&mut |addr| {\n        let acceptor = t!(TcpListener::bind(&addr));\n        let (tx1, rx) = channel();\n        let tx2 = tx1.clone();\n\n        let _t = thread::spawn(move || {\n            let mut s = t!(TcpStream::connect(&addr));\n            t!(s.write(&[1]));\n            rx.recv().unwrap();\n            t!(s.write(&[2]));\n            rx.recv().unwrap();\n        });\n\n        let mut s1 = t!(acceptor.accept()).0;\n        let s2 = t!(s1.try_clone());\n\n        let (done, rx) = channel();\n        let _t = thread::spawn(move || {\n            let mut s2 = s2;\n            let mut buf = [0, 0];\n            t!(s2.read(&mut buf));\n            tx2.send(()).unwrap();\n            done.send(()).unwrap();\n        });\n        let mut buf = [0, 0];\n        t!(s1.read(&mut buf));\n        tx1.send(()).unwrap();\n\n        rx.recv().unwrap();\n    })\n}\n\n#[test]\nfn tcp_clone_two_write() {\n    each_ip(&mut |addr| {\n        let acceptor = t!(TcpListener::bind(&addr));\n\n        let _t = thread::spawn(move || {\n            let mut s = t!(TcpStream::connect(&addr));\n            let mut buf = [0, 1];\n            t!(s.read(&mut buf));\n            t!(s.read(&mut buf));\n        });\n\n        let mut s1 = t!(acceptor.accept()).0;\n        let s2 = t!(s1.try_clone());\n\n        let (done, rx) = channel();\n        let _t = thread::spawn(move || {\n            let mut s2 = s2;\n            t!(s2.write(&[1]));\n            done.send(()).unwrap();\n        });\n        t!(s1.write(&[2]));\n\n        rx.recv().unwrap();\n    })\n}\n\n#[test]\n// FIXME: https://github.com/fortanix/rust-sgx/issues/110\n#[cfg_attr(target_env = \"sgx\", ignore)]\nfn shutdown_smoke() {\n    each_ip(&mut |addr| {\n        let a = t!(TcpListener::bind(&addr));\n        let _t = thread::spawn(move || {\n            let mut c = t!(a.accept()).0;\n            let mut b = [0];\n            assert_eq!(c.read(&mut b).unwrap(), 0);\n            t!(c.write(&[1]));\n        });\n\n        let mut s = t!(TcpStream::connect(&addr));\n        t!(s.shutdown(Shutdown::Write));\n        assert!(s.write(&[1]).is_err());\n        let mut b = [0, 0];\n        assert_eq!(t!(s.read(&mut b)), 1);\n        assert_eq!(b[0], 1);\n    })\n}\n\n#[test]\n// FIXME: https://github.com/fortanix/rust-sgx/issues/110\n#[cfg_attr(target_env = \"sgx\", ignore)]\nfn close_readwrite_smoke() {\n    each_ip(&mut |addr| {\n        let a = t!(TcpListener::bind(&addr));\n        let (tx, rx) = channel::<()>();\n        let _t = thread::spawn(move || {\n            let _s = t!(a.accept());\n            let _ = rx.recv();\n        });\n\n        let mut b = [0];\n        let mut s = t!(TcpStream::connect(&addr));\n        let mut s2 = t!(s.try_clone());\n\n        // closing should prevent reads/writes\n        t!(s.shutdown(Shutdown::Write));\n        assert!(s.write(&[0]).is_err());\n        t!(s.shutdown(Shutdown::Read));\n        assert_eq!(s.read(&mut b).unwrap(), 0);\n\n        // closing should affect previous handles\n        assert!(s2.write(&[0]).is_err());\n        assert_eq!(s2.read(&mut b).unwrap(), 0);\n\n        // closing should affect new handles\n        let mut s3 = t!(s.try_clone());\n        assert!(s3.write(&[0]).is_err());\n        assert_eq!(s3.read(&mut b).unwrap(), 0);\n\n        // make sure these don't die\n        let _ = s2.shutdown(Shutdown::Read);\n        let _ = s2.shutdown(Shutdown::Write);\n        let _ = s3.shutdown(Shutdown::Read);\n        let _ = s3.shutdown(Shutdown::Write);\n        drop(tx);\n    })\n}\n\n#[test]\n#[cfg(unix)] // test doesn't work on Windows, see #31657\nfn close_read_wakes_up() {\n    each_ip(&mut |addr| {\n        let a = t!(TcpListener::bind(&addr));\n        let (tx1, rx) = channel::<()>();\n        let _t = thread::spawn(move || {\n            let _s = t!(a.accept());\n            let _ = rx.recv();\n        });\n\n        let s = t!(TcpStream::connect(&addr));\n        let s2 = t!(s.try_clone());\n        let (tx, rx) = channel();\n        let _t = thread::spawn(move || {\n            let mut s2 = s2;\n            assert_eq!(t!(s2.read(&mut [0])), 0);\n            tx.send(()).unwrap();\n        });\n        // this should wake up the child thread\n        t!(s.shutdown(Shutdown::Read));\n\n        // this test will never finish if the child doesn't wake up\n        rx.recv().unwrap();\n        drop(tx1);\n    })\n}\n\n#[test]\nfn clone_while_reading() {\n    each_ip(&mut |addr| {\n        let accept = t!(TcpListener::bind(&addr));\n\n        // Enqueue a thread to write to a socket\n        let (tx, rx) = channel();\n        let (txdone, rxdone) = channel();\n        let txdone2 = txdone.clone();\n        let _t = thread::spawn(move || {\n            let mut tcp = t!(TcpStream::connect(&addr));\n            rx.recv().unwrap();\n            t!(tcp.write(&[0]));\n            txdone2.send(()).unwrap();\n        });\n\n        // Spawn off a reading clone\n        let tcp = t!(accept.accept()).0;\n        let tcp2 = t!(tcp.try_clone());\n        let txdone3 = txdone.clone();\n        let _t = thread::spawn(move || {\n            let mut tcp2 = tcp2;\n            t!(tcp2.read(&mut [0]));\n            txdone3.send(()).unwrap();\n        });\n\n        // Try to ensure that the reading clone is indeed reading\n        for _ in 0..50 {\n            thread::yield_now();\n        }\n\n        // clone the handle again while it's reading, then let it finish the\n        // read.\n        let _ = t!(tcp.try_clone());\n        tx.send(()).unwrap();\n        rxdone.recv().unwrap();\n        rxdone.recv().unwrap();\n    })\n}\n\n#[test]\nfn clone_accept_smoke() {\n    each_ip(&mut |addr| {\n        let a = t!(TcpListener::bind(&addr));\n        let a2 = t!(a.try_clone());\n\n        let _t = thread::spawn(move || {\n            let _ = TcpStream::connect(&addr);\n        });\n        let _t = thread::spawn(move || {\n            let _ = TcpStream::connect(&addr);\n        });\n\n        t!(a.accept());\n        t!(a2.accept());\n    })\n}\n\n#[test]\nfn clone_accept_concurrent() {\n    each_ip(&mut |addr| {\n        let a = t!(TcpListener::bind(&addr));\n        let a2 = t!(a.try_clone());\n\n        let (tx, rx) = channel();\n        let tx2 = tx.clone();\n\n        let _t = thread::spawn(move || {\n            tx.send(t!(a.accept())).unwrap();\n        });\n        let _t = thread::spawn(move || {\n            tx2.send(t!(a2.accept())).unwrap();\n        });\n\n        let _t = thread::spawn(move || {\n            let _ = TcpStream::connect(&addr);\n        });\n        let _t = thread::spawn(move || {\n            let _ = TcpStream::connect(&addr);\n        });\n\n        rx.recv().unwrap();\n        rx.recv().unwrap();\n    })\n}\n\n#[test]\nfn debug() {\n    #[cfg(not(target_env = \"sgx\"))]\n    fn render_socket_addr<'a>(addr: &'a SocketAddr) -> impl fmt::Debug + 'a {\n        addr\n    }\n    #[cfg(target_env = \"sgx\")]\n    fn render_socket_addr<'a>(addr: &'a SocketAddr) -> impl fmt::Debug + 'a {\n        addr.to_string()\n    }\n\n    #[cfg(target_env = \"sgx\")]\n    use crate::os::fortanix_sgx::io::AsRawFd;\n    #[cfg(unix)]\n    use crate::os::unix::io::AsRawFd;\n    #[cfg(not(windows))]\n    fn render_inner(addr: &dyn AsRawFd) -> impl fmt::Debug {\n        addr.as_raw_fd()\n    }\n    #[cfg(windows)]\n    fn render_inner(addr: &dyn crate::os::windows::io::AsRawSocket) -> impl fmt::Debug {\n        addr.as_raw_socket()\n    }\n\n    let inner_name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n    let socket_addr = next_test_ip4();\n\n    let listener = t!(TcpListener::bind(&socket_addr));\n    let compare = format!(\n        \"TcpListener {{ addr: {:?}, {}: {:?} }}\",\n        render_socket_addr(&socket_addr),\n        inner_name,\n        render_inner(&listener)\n    );\n    assert_eq!(format!(\"{:?}\", listener), compare);\n\n    let stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n    let compare = format!(\n        \"TcpStream {{ addr: {:?}, peer: {:?}, {}: {:?} }}\",\n        render_socket_addr(&stream.local_addr().unwrap()),\n        render_socket_addr(&stream.peer_addr().unwrap()),\n        inner_name,\n        render_inner(&stream)\n    );\n    assert_eq!(format!(\"{:?}\", stream), compare);\n}\n\n// FIXME: re-enabled openbsd tests once their socket timeout code\n//        no longer has rounding errors.\n// VxWorks ignores SO_SNDTIMEO.\n#[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n#[test]\nfn timeouts() {\n    let addr = next_test_ip4();\n    let listener = t!(TcpListener::bind(&addr));\n\n    let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n    let dur = Duration::new(15410, 0);\n\n    assert_eq!(None, t!(stream.read_timeout()));\n\n    t!(stream.set_read_timeout(Some(dur)));\n    assert_eq!(Some(dur), t!(stream.read_timeout()));\n\n    assert_eq!(None, t!(stream.write_timeout()));\n\n    t!(stream.set_write_timeout(Some(dur)));\n    assert_eq!(Some(dur), t!(stream.write_timeout()));\n\n    t!(stream.set_read_timeout(None));\n    assert_eq!(None, t!(stream.read_timeout()));\n\n    t!(stream.set_write_timeout(None));\n    assert_eq!(None, t!(stream.write_timeout()));\n    drop(listener);\n}\n\n#[test]\n#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\nfn test_read_timeout() {\n    let addr = next_test_ip4();\n    let listener = t!(TcpListener::bind(&addr));\n\n    let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n    t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n\n    let mut buf = [0; 10];\n    let start = Instant::now();\n    let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n    assert!(\n        kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n        \"unexpected_error: {:?}\",\n        kind\n    );\n    assert!(start.elapsed() > Duration::from_millis(400));\n    drop(listener);\n}\n\n#[test]\n#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\nfn test_read_with_timeout() {\n    let addr = next_test_ip4();\n    let listener = t!(TcpListener::bind(&addr));\n\n    let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n    t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n\n    let mut other_end = t!(listener.accept()).0;\n    t!(other_end.write_all(b\"hello world\"));\n\n    let mut buf = [0; 11];\n    t!(stream.read(&mut buf));\n    assert_eq!(b\"hello world\", &buf[..]);\n\n    let start = Instant::now();\n    let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n    assert!(\n        kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n        \"unexpected_error: {:?}\",\n        kind\n    );\n    assert!(start.elapsed() > Duration::from_millis(400));\n    drop(listener);\n}\n\n// Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n// when passed zero Durations\n#[test]\nfn test_timeout_zero_duration() {\n    let addr = next_test_ip4();\n\n    let listener = t!(TcpListener::bind(&addr));\n    let stream = t!(TcpStream::connect(&addr));\n\n    let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n    let err = result.unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n\n    let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n    let err = result.unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n\n    drop(listener);\n}\n\n#[test]\n#[cfg_attr(target_env = \"sgx\", ignore)]\nfn nodelay() {\n    let addr = next_test_ip4();\n    let _listener = t!(TcpListener::bind(&addr));\n\n    let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n\n    assert_eq!(false, t!(stream.nodelay()));\n    t!(stream.set_nodelay(true));\n    assert_eq!(true, t!(stream.nodelay()));\n    t!(stream.set_nodelay(false));\n    assert_eq!(false, t!(stream.nodelay()));\n}\n\n#[test]\n#[cfg_attr(target_env = \"sgx\", ignore)]\nfn ttl() {\n    let ttl = 100;\n\n    let addr = next_test_ip4();\n    let listener = t!(TcpListener::bind(&addr));\n\n    t!(listener.set_ttl(ttl));\n    assert_eq!(ttl, t!(listener.ttl()));\n\n    let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n\n    t!(stream.set_ttl(ttl));\n    assert_eq!(ttl, t!(stream.ttl()));\n}\n\n#[test]\n#[cfg_attr(target_env = \"sgx\", ignore)]\nfn set_nonblocking() {\n    let addr = next_test_ip4();\n    let listener = t!(TcpListener::bind(&addr));\n\n    t!(listener.set_nonblocking(true));\n    t!(listener.set_nonblocking(false));\n\n    let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n\n    t!(stream.set_nonblocking(false));\n    t!(stream.set_nonblocking(true));\n\n    let mut buf = [0];\n    match stream.read(&mut buf) {\n        Ok(_) => panic!(\"expected error\"),\n        Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n        Err(e) => panic!(\"unexpected error {}\", e),\n    }\n}\n\n#[test]\n#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\nfn peek() {\n    each_ip(&mut |addr| {\n        let (txdone, rxdone) = channel();\n\n        let srv = t!(TcpListener::bind(&addr));\n        let _t = thread::spawn(move || {\n            let mut cl = t!(srv.accept()).0;\n            cl.write(&[1, 3, 3, 7]).unwrap();\n            t!(rxdone.recv());\n        });\n\n        let mut c = t!(TcpStream::connect(&addr));\n        let mut b = [0; 10];\n        for _ in 1..3 {\n            let len = c.peek(&mut b).unwrap();\n            assert_eq!(len, 4);\n        }\n        let len = c.read(&mut b).unwrap();\n        assert_eq!(len, 4);\n\n        t!(c.set_nonblocking(true));\n        match c.peek(&mut b) {\n            Ok(_) => panic!(\"expected error\"),\n            Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n            Err(e) => panic!(\"unexpected error {}\", e),\n        }\n        t!(txdone.send(()));\n    })\n}\n\n#[test]\n#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\nfn connect_timeout_valid() {\n    let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n    let addr = listener.local_addr().unwrap();\n    TcpStream::connect_timeout(&addr, Duration::from_secs(2)).unwrap();\n}\n"],["2592","use crate::io::ErrorKind;\nuse crate::net::test::{next_test_ip4, next_test_ip6};\nuse crate::net::*;\nuse crate::sync::mpsc::channel;\nuse crate::sys_common::AsInner;\nuse crate::thread;\nuse crate::time::{Duration, Instant};\n\nfn each_ip(f: &mut dyn FnMut(SocketAddr, SocketAddr)) {\n    f(next_test_ip4(), next_test_ip4());\n    f(next_test_ip6(), next_test_ip6());\n}\n\nmacro_rules! t {\n    ($e:expr) => {\n        match $e {\n            Ok(t) => t,\n            Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n        }\n    };\n}\n\n#[test]\nfn bind_error() {\n    match UdpSocket::bind(\"1.1.1.1:9999\") {\n        Ok(..) => panic!(),\n        Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n    }\n}\n\n#[test]\nfn socket_smoke_test_ip4() {\n    each_ip(&mut |server_ip, client_ip| {\n        let (tx1, rx1) = channel();\n        let (tx2, rx2) = channel();\n\n        let _t = thread::spawn(move || {\n            let client = t!(UdpSocket::bind(&client_ip));\n            rx1.recv().unwrap();\n            t!(client.send_to(&[99], &server_ip));\n            tx2.send(()).unwrap();\n        });\n\n        let server = t!(UdpSocket::bind(&server_ip));\n        tx1.send(()).unwrap();\n        let mut buf = [0];\n        let (nread, src) = t!(server.recv_from(&mut buf));\n        assert_eq!(nread, 1);\n        assert_eq!(buf[0], 99);\n        assert_eq!(src, client_ip);\n        rx2.recv().unwrap();\n    })\n}\n\n#[test]\nfn socket_name() {\n    each_ip(&mut |addr, _| {\n        let server = t!(UdpSocket::bind(&addr));\n        assert_eq!(addr, t!(server.local_addr()));\n    })\n}\n\n#[test]\nfn socket_peer() {\n    each_ip(&mut |addr1, addr2| {\n        let server = t!(UdpSocket::bind(&addr1));\n        assert_eq!(server.peer_addr().unwrap_err().kind(), ErrorKind::NotConnected);\n        t!(server.connect(&addr2));\n        assert_eq!(addr2, t!(server.peer_addr()));\n    })\n}\n\n#[test]\nfn udp_clone_smoke() {\n    each_ip(&mut |addr1, addr2| {\n        let sock1 = t!(UdpSocket::bind(&addr1));\n        let sock2 = t!(UdpSocket::bind(&addr2));\n\n        let _t = thread::spawn(move || {\n            let mut buf = [0, 0];\n            assert_eq!(sock2.recv_from(&mut buf).unwrap(), (1, addr1));\n            assert_eq!(buf[0], 1);\n            t!(sock2.send_to(&[2], &addr1));\n        });\n\n        let sock3 = t!(sock1.try_clone());\n\n        let (tx1, rx1) = channel();\n        let (tx2, rx2) = channel();\n        let _t = thread::spawn(move || {\n            rx1.recv().unwrap();\n            t!(sock3.send_to(&[1], &addr2));\n            tx2.send(()).unwrap();\n        });\n        tx1.send(()).unwrap();\n        let mut buf = [0, 0];\n        assert_eq!(sock1.recv_from(&mut buf).unwrap(), (1, addr2));\n        rx2.recv().unwrap();\n    })\n}\n\n#[test]\nfn udp_clone_two_read() {\n    each_ip(&mut |addr1, addr2| {\n        let sock1 = t!(UdpSocket::bind(&addr1));\n        let sock2 = t!(UdpSocket::bind(&addr2));\n        let (tx1, rx) = channel();\n        let tx2 = tx1.clone();\n\n        let _t = thread::spawn(move || {\n            t!(sock2.send_to(&[1], &addr1));\n            rx.recv().unwrap();\n            t!(sock2.send_to(&[2], &addr1));\n            rx.recv().unwrap();\n        });\n\n        let sock3 = t!(sock1.try_clone());\n\n        let (done, rx) = channel();\n        let _t = thread::spawn(move || {\n            let mut buf = [0, 0];\n            t!(sock3.recv_from(&mut buf));\n            tx2.send(()).unwrap();\n            done.send(()).unwrap();\n        });\n        let mut buf = [0, 0];\n        t!(sock1.recv_from(&mut buf));\n        tx1.send(()).unwrap();\n\n        rx.recv().unwrap();\n    })\n}\n\n#[test]\nfn udp_clone_two_write() {\n    each_ip(&mut |addr1, addr2| {\n        let sock1 = t!(UdpSocket::bind(&addr1));\n        let sock2 = t!(UdpSocket::bind(&addr2));\n\n        let (tx, rx) = channel();\n        let (serv_tx, serv_rx) = channel();\n\n        let _t = thread::spawn(move || {\n            let mut buf = [0, 1];\n            rx.recv().unwrap();\n            t!(sock2.recv_from(&mut buf));\n            serv_tx.send(()).unwrap();\n        });\n\n        let sock3 = t!(sock1.try_clone());\n\n        let (done, rx) = channel();\n        let tx2 = tx.clone();\n        let _t = thread::spawn(move || {\n            if sock3.send_to(&[1], &addr2).is_ok() {\n                let _ = tx2.send(());\n            }\n            done.send(()).unwrap();\n        });\n        if sock1.send_to(&[2], &addr2).is_ok() {\n            let _ = tx.send(());\n        }\n        drop(tx);\n\n        rx.recv().unwrap();\n        serv_rx.recv().unwrap();\n    })\n}\n\n#[test]\nfn debug() {\n    let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n    let socket_addr = next_test_ip4();\n\n    let udpsock = t!(UdpSocket::bind(&socket_addr));\n    let udpsock_inner = udpsock.0.socket().as_inner();\n    let compare = format!(\"UdpSocket {{ addr: {:?}, {}: {:?} }}\", socket_addr, name, udpsock_inner);\n    assert_eq!(format!(\"{:?}\", udpsock), compare);\n}\n\n// FIXME: re-enabled openbsd/netbsd tests once their socket timeout code\n//        no longer has rounding errors.\n// VxWorks ignores SO_SNDTIMEO.\n#[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n#[test]\nfn timeouts() {\n    let addr = next_test_ip4();\n\n    let stream = t!(UdpSocket::bind(&addr));\n    let dur = Duration::new(15410, 0);\n\n    assert_eq!(None, t!(stream.read_timeout()));\n\n    t!(stream.set_read_timeout(Some(dur)));\n    assert_eq!(Some(dur), t!(stream.read_timeout()));\n\n    assert_eq!(None, t!(stream.write_timeout()));\n\n    t!(stream.set_write_timeout(Some(dur)));\n    assert_eq!(Some(dur), t!(stream.write_timeout()));\n\n    t!(stream.set_read_timeout(None));\n    assert_eq!(None, t!(stream.read_timeout()));\n\n    t!(stream.set_write_timeout(None));\n    assert_eq!(None, t!(stream.write_timeout()));\n}\n\n#[test]\nfn test_read_timeout() {\n    let addr = next_test_ip4();\n\n    let stream = t!(UdpSocket::bind(&addr));\n    t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n\n    let mut buf = [0; 10];\n\n    let start = Instant::now();\n    loop {\n        let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n        if kind != ErrorKind::Interrupted {\n            assert!(\n                kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n                \"unexpected_error: {:?}\",\n                kind\n            );\n            break;\n        }\n    }\n    assert!(start.elapsed() > Duration::from_millis(400));\n}\n\n#[test]\nfn test_read_with_timeout() {\n    let addr = next_test_ip4();\n\n    let stream = t!(UdpSocket::bind(&addr));\n    t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n\n    t!(stream.send_to(b\"hello world\", &addr));\n\n    let mut buf = [0; 11];\n    t!(stream.recv_from(&mut buf));\n    assert_eq!(b\"hello world\", &buf[..]);\n\n    let start = Instant::now();\n    loop {\n        let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n        if kind != ErrorKind::Interrupted {\n            assert!(\n                kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n                \"unexpected_error: {:?}\",\n                kind\n            );\n            break;\n        }\n    }\n    assert!(start.elapsed() > Duration::from_millis(400));\n}\n\n// Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n// when passed zero Durations\n#[test]\nfn test_timeout_zero_duration() {\n    let addr = next_test_ip4();\n\n    let socket = t!(UdpSocket::bind(&addr));\n\n    let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n    let err = result.unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n\n    let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n    let err = result.unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n}\n\n#[test]\nfn connect_send_recv() {\n    let addr = next_test_ip4();\n\n    let socket = t!(UdpSocket::bind(&addr));\n    t!(socket.connect(addr));\n\n    t!(socket.send(b\"hello world\"));\n\n    let mut buf = [0; 11];\n    t!(socket.recv(&mut buf));\n    assert_eq!(b\"hello world\", &buf[..]);\n}\n\n#[test]\nfn connect_send_peek_recv() {\n    each_ip(&mut |addr, _| {\n        let socket = t!(UdpSocket::bind(&addr));\n        t!(socket.connect(addr));\n\n        t!(socket.send(b\"hello world\"));\n\n        for _ in 1..3 {\n            let mut buf = [0; 11];\n            let size = t!(socket.peek(&mut buf));\n            assert_eq!(b\"hello world\", &buf[..]);\n            assert_eq!(size, 11);\n        }\n\n        let mut buf = [0; 11];\n        let size = t!(socket.recv(&mut buf));\n        assert_eq!(b\"hello world\", &buf[..]);\n        assert_eq!(size, 11);\n    })\n}\n\n#[test]\nfn peek_from() {\n    each_ip(&mut |addr, _| {\n        let socket = t!(UdpSocket::bind(&addr));\n        t!(socket.send_to(b\"hello world\", &addr));\n\n        for _ in 1..3 {\n            let mut buf = [0; 11];\n            let (size, _) = t!(socket.peek_from(&mut buf));\n            assert_eq!(b\"hello world\", &buf[..]);\n            assert_eq!(size, 11);\n        }\n\n        let mut buf = [0; 11];\n        let (size, _) = t!(socket.recv_from(&mut buf));\n        assert_eq!(b\"hello world\", &buf[..]);\n        assert_eq!(size, 11);\n    })\n}\n\n#[test]\nfn ttl() {\n    let ttl = 100;\n\n    let addr = next_test_ip4();\n\n    let stream = t!(UdpSocket::bind(&addr));\n\n    t!(stream.set_ttl(ttl));\n    assert_eq!(ttl, t!(stream.ttl()));\n}\n\n#[test]\nfn set_nonblocking() {\n    each_ip(&mut |addr, _| {\n        let socket = t!(UdpSocket::bind(&addr));\n\n        t!(socket.set_nonblocking(true));\n        t!(socket.set_nonblocking(false));\n\n        t!(socket.connect(addr));\n\n        t!(socket.set_nonblocking(false));\n        t!(socket.set_nonblocking(true));\n\n        let mut buf = [0];\n        match socket.recv(&mut buf) {\n            Ok(_) => panic!(\"expected error\"),\n            Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n            Err(e) => panic!(\"unexpected error {}\", e),\n        }\n    })\n}\n"],["2593","// FIXME: These tests are all excellent candidates for AFL fuzz testing\nuse crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\nuse crate::str::FromStr;\n\nconst PORT: u16 = 8080;\nconst SCOPE_ID: u32 = 1337;\n\nconst IPV4: Ipv4Addr = Ipv4Addr::new(192, 168, 0, 1);\nconst IPV4_STR: &str = \"192.168.0.1\";\nconst IPV4_STR_PORT: &str = \"192.168.0.1:8080\";\nconst IPV4_STR_WITH_OCTAL: &str = \"0127.0.0.1\";\nconst IPV4_STR_WITH_HEX: &str = \"0x10.0.0.1\";\n\nconst IPV6: Ipv6Addr = Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0xc0a8, 0x1);\nconst IPV6_STR_FULL: &str = \"2001:db8:0:0:0:0:c0a8:1\";\nconst IPV6_STR_COMPRESS: &str = \"2001:db8::c0a8:1\";\nconst IPV6_STR_V4: &str = \"2001:db8::192.168.0.1\";\nconst IPV6_STR_V4_WITH_OCTAL: &str = \"2001:db8::0127.0.0.1\";\nconst IPV6_STR_V4_WITH_HEX: &str = \"2001:db8::0x10.0.0.1\";\nconst IPV6_STR_PORT: &str = \"[2001:db8::c0a8:1]:8080\";\nconst IPV6_STR_PORT_SCOPE_ID: &str = \"[2001:db8::c0a8:1%1337]:8080\";\n\n#[test]\nfn parse_ipv4() {\n    let result: Ipv4Addr = IPV4_STR.parse().unwrap();\n    assert_eq!(result, IPV4);\n\n    assert!(Ipv4Addr::from_str(IPV4_STR_PORT).is_err());\n    assert!(Ipv4Addr::from_str(IPV4_STR_WITH_OCTAL).is_err());\n    assert!(Ipv4Addr::from_str(IPV4_STR_WITH_HEX).is_err());\n    assert!(Ipv4Addr::from_str(IPV6_STR_FULL).is_err());\n    assert!(Ipv4Addr::from_str(IPV6_STR_COMPRESS).is_err());\n    assert!(Ipv4Addr::from_str(IPV6_STR_V4).is_err());\n    assert!(Ipv4Addr::from_str(IPV6_STR_PORT).is_err());\n}\n\n#[test]\nfn parse_ipv6() {\n    let result: Ipv6Addr = IPV6_STR_FULL.parse().unwrap();\n    assert_eq!(result, IPV6);\n\n    let result: Ipv6Addr = IPV6_STR_COMPRESS.parse().unwrap();\n    assert_eq!(result, IPV6);\n\n    let result: Ipv6Addr = IPV6_STR_V4.parse().unwrap();\n    assert_eq!(result, IPV6);\n\n    assert!(Ipv6Addr::from_str(IPV6_STR_V4_WITH_OCTAL).is_err());\n    assert!(Ipv6Addr::from_str(IPV6_STR_V4_WITH_HEX).is_err());\n    assert!(Ipv6Addr::from_str(IPV4_STR).is_err());\n    assert!(Ipv6Addr::from_str(IPV4_STR_PORT).is_err());\n    assert!(Ipv6Addr::from_str(IPV6_STR_PORT).is_err());\n}\n\n#[test]\nfn parse_ip() {\n    let result: IpAddr = IPV4_STR.parse().unwrap();\n    assert_eq!(result, IpAddr::from(IPV4));\n\n    let result: IpAddr = IPV6_STR_FULL.parse().unwrap();\n    assert_eq!(result, IpAddr::from(IPV6));\n\n    let result: IpAddr = IPV6_STR_COMPRESS.parse().unwrap();\n    assert_eq!(result, IpAddr::from(IPV6));\n\n    let result: IpAddr = IPV6_STR_V4.parse().unwrap();\n    assert_eq!(result, IpAddr::from(IPV6));\n\n    assert!(IpAddr::from_str(IPV4_STR_PORT).is_err());\n    assert!(IpAddr::from_str(IPV6_STR_PORT).is_err());\n}\n\n#[test]\nfn parse_socket_v4() {\n    let result: SocketAddrV4 = IPV4_STR_PORT.parse().unwrap();\n    assert_eq!(result, SocketAddrV4::new(IPV4, PORT));\n\n    assert!(SocketAddrV4::from_str(IPV4_STR).is_err());\n    assert!(SocketAddrV4::from_str(IPV6_STR_FULL).is_err());\n    assert!(SocketAddrV4::from_str(IPV6_STR_COMPRESS).is_err());\n    assert!(SocketAddrV4::from_str(IPV6_STR_V4).is_err());\n    assert!(SocketAddrV4::from_str(IPV6_STR_PORT).is_err());\n}\n\n#[test]\nfn parse_socket_v6() {\n    assert_eq!(IPV6_STR_PORT.parse(), Ok(SocketAddrV6::new(IPV6, PORT, 0, 0)));\n    assert_eq!(IPV6_STR_PORT_SCOPE_ID.parse(), Ok(SocketAddrV6::new(IPV6, PORT, 0, SCOPE_ID)));\n\n    assert!(SocketAddrV6::from_str(IPV4_STR).is_err());\n    assert!(SocketAddrV6::from_str(IPV4_STR_PORT).is_err());\n    assert!(SocketAddrV6::from_str(IPV6_STR_FULL).is_err());\n    assert!(SocketAddrV6::from_str(IPV6_STR_COMPRESS).is_err());\n    assert!(SocketAddrV6::from_str(IPV6_STR_V4).is_err());\n}\n\n#[test]\nfn parse_socket() {\n    let result: SocketAddr = IPV4_STR_PORT.parse().unwrap();\n    assert_eq!(result, SocketAddr::from((IPV4, PORT)));\n\n    let result: SocketAddr = IPV6_STR_PORT.parse().unwrap();\n    assert_eq!(result, SocketAddr::from((IPV6, PORT)));\n\n    assert!(SocketAddr::from_str(IPV4_STR).is_err());\n    assert!(SocketAddr::from_str(IPV6_STR_FULL).is_err());\n    assert!(SocketAddr::from_str(IPV6_STR_COMPRESS).is_err());\n    assert!(SocketAddr::from_str(IPV6_STR_V4).is_err());\n}\n\n#[test]\nfn ipv6_corner_cases() {\n    let result: Ipv6Addr = \"1::\".parse().unwrap();\n    assert_eq!(result, Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0));\n\n    let result: Ipv6Addr = \"1:1::\".parse().unwrap();\n    assert_eq!(result, Ipv6Addr::new(1, 1, 0, 0, 0, 0, 0, 0));\n\n    let result: Ipv6Addr = \"::1\".parse().unwrap();\n    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n\n    let result: Ipv6Addr = \"::1:1\".parse().unwrap();\n    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 1, 1));\n\n    let result: Ipv6Addr = \"::\".parse().unwrap();\n    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n\n    let result: Ipv6Addr = \"::192.168.0.1\".parse().unwrap();\n    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc0a8, 0x1));\n\n    let result: Ipv6Addr = \"::1:192.168.0.1\".parse().unwrap();\n    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 1, 0xc0a8, 0x1));\n\n    let result: Ipv6Addr = \"1:1:1:1:1:1:192.168.0.1\".parse().unwrap();\n    assert_eq!(result, Ipv6Addr::new(1, 1, 1, 1, 1, 1, 0xc0a8, 0x1));\n}\n\n// Things that might not seem like failures but are\n#[test]\nfn ipv6_corner_failures() {\n    // No IP address before the ::\n    assert!(Ipv6Addr::from_str(\"1:192.168.0.1::\").is_err());\n\n    // :: must have at least 1 set of zeroes\n    assert!(Ipv6Addr::from_str(\"1:1:1:1::1:1:1:1\").is_err());\n\n    // Need brackets for a port\n    assert!(SocketAddrV6::from_str(\"1:1:1:1:1:1:1:1:8080\").is_err());\n}\n"],["2594","//! A private parser implementation of IPv4, IPv6, and socket addresses.\n//!\n//! This module is \"publicly exported\" through the `FromStr` implementations\n//! below.\n\n#[cfg(test)]\nmod tests;\n\nuse crate::convert::TryInto as _;\nuse crate::error::Error;\nuse crate::fmt;\nuse crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\nuse crate::str::FromStr;\n\ntrait ReadNumberHelper: crate::marker::Sized {\n    const ZERO: Self;\n    fn checked_mul(&self, other: u32) -> Option<Self>;\n    fn checked_add(&self, other: u32) -> Option<Self>;\n}\n\nmacro_rules! impl_helper {\n    ($($t:ty)*) => ($(impl ReadNumberHelper for $t {\n        const ZERO: Self = 0;\n        #[inline]\n        fn checked_mul(&self, other: u32) -> Option<Self> {\n            Self::checked_mul(*self, other.try_into().ok()?)\n        }\n        #[inline]\n        fn checked_add(&self, other: u32) -> Option<Self> {\n            Self::checked_add(*self, other.try_into().ok()?)\n        }\n    })*)\n}\n\nimpl_helper! { u8 u16 u32 }\n\nstruct Parser<'a> {\n    // Parsing as ASCII, so can use byte array.\n    state: &'a [u8],\n}\n\nimpl<'a> Parser<'a> {\n    fn new(input: &'a str) -> Parser<'a> {\n        Parser { state: input.as_bytes() }\n    }\n\n    /// Run a parser, and restore the pre-parse state if it fails.\n    fn read_atomically<T, F>(&mut self, inner: F) -> Option<T>\n    where\n        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n    {\n        let state = self.state;\n        let result = inner(self);\n        if result.is_none() {\n            self.state = state;\n        }\n        result\n    }\n\n    /// Run a parser, but fail if the entire input wasn't consumed.\n    /// Doesn't run atomically.\n    fn parse_with<T, F>(&mut self, inner: F) -> Result<T, AddrParseError>\n    where\n        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n    {\n        let result = inner(self);\n        if self.state.is_empty() { result } else { None }.ok_or(AddrParseError(()))\n    }\n\n    /// Peek the next character from the input\n    fn peek_char(&self) -> Option<char> {\n        self.state.first().map(|&b| char::from(b))\n    }\n\n    /// Read the next character from the input\n    fn read_char(&mut self) -> Option<char> {\n        self.state.split_first().map(|(&b, tail)| {\n            self.state = tail;\n            char::from(b)\n        })\n    }\n\n    #[must_use]\n    /// Read the next character from the input if it matches the target.\n    fn read_given_char(&mut self, target: char) -> Option<()> {\n        self.read_atomically(|p| {\n            p.read_char().and_then(|c| if c == target { Some(()) } else { None })\n        })\n    }\n\n    /// Helper for reading separators in an indexed loop. Reads the separator\n    /// character iff index > 0, then runs the parser. When used in a loop,\n    /// the separator character will only be read on index > 0 (see\n    /// read_ipv4_addr for an example)\n    fn read_separator<T, F>(&mut self, sep: char, index: usize, inner: F) -> Option<T>\n    where\n        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n    {\n        self.read_atomically(move |p| {\n            if index > 0 {\n                p.read_given_char(sep)?;\n            }\n            inner(p)\n        })\n    }\n\n    // Read a number off the front of the input in the given radix, stopping\n    // at the first non-digit character or eof. Fails if the number has more\n    // digits than max_digits or if there is no number.\n    fn read_number<T: ReadNumberHelper>(\n        &mut self,\n        radix: u32,\n        max_digits: Option<usize>,\n    ) -> Option<T> {\n        self.read_atomically(move |p| {\n            let mut result = T::ZERO;\n            let mut digit_count = 0;\n\n            while let Some(digit) = p.read_atomically(|p| p.read_char()?.to_digit(radix)) {\n                result = result.checked_mul(radix)?;\n                result = result.checked_add(digit)?;\n                digit_count += 1;\n                if let Some(max_digits) = max_digits {\n                    if digit_count > max_digits {\n                        return None;\n                    }\n                }\n            }\n\n            if digit_count == 0 { None } else { Some(result) }\n        })\n    }\n\n    /// Read an IPv4 address.\n    fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n        self.read_atomically(|p| {\n            let mut groups = [0; 4];\n\n            for (i, slot) in groups.iter_mut().enumerate() {\n                *slot = p.read_separator('.', i, |p| {\n                    // Disallow octal number in IP string.\n                    // https://tools.ietf.org/html/rfc6943#section-3.1.1\n                    match (p.peek_char(), p.read_number(10, None)) {\n                        (Some('0'), Some(number)) if number != 0 => None,\n                        (_, number) => number,\n                    }\n                })?;\n            }\n\n            Some(groups.into())\n        })\n    }\n\n    /// Read an IPv6 Address.\n    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n        /// Read a chunk of an IPv6 address into `groups`. Returns the number\n        /// of groups read, along with a bool indicating if an embedded\n        /// trailing IPv4 address was read. Specifically, read a series of\n        /// colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n        /// trailing embedded IPv4 address.\n        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16]) -> (usize, bool) {\n            let limit = groups.len();\n\n            for (i, slot) in groups.iter_mut().enumerate() {\n                // Try to read a trailing embedded IPv4 address. There must be\n                // at least two groups left.\n                if i < limit - 1 {\n                    let ipv4 = p.read_separator(':', i, |p| p.read_ipv4_addr());\n\n                    if let Some(v4_addr) = ipv4 {\n                        let [one, two, three, four] = v4_addr.octets();\n                        groups[i + 0] = u16::from_be_bytes([one, two]);\n                        groups[i + 1] = u16::from_be_bytes([three, four]);\n                        return (i + 2, true);\n                    }\n                }\n\n                let group = p.read_separator(':', i, |p| p.read_number(16, Some(4)));\n\n                match group {\n                    Some(g) => *slot = g,\n                    None => return (i, false),\n                }\n            }\n            (groups.len(), false)\n        }\n\n        self.read_atomically(|p| {\n            // Read the front part of the address; either the whole thing, or up\n            // to the first ::\n            let mut head = [0; 8];\n            let (head_size, head_ipv4) = read_groups(p, &mut head);\n\n            if head_size == 8 {\n                return Some(head.into());\n            }\n\n            // IPv4 part is not allowed before `::`\n            if head_ipv4 {\n                return None;\n            }\n\n            // Read `::` if previous code parsed less than 8 groups.\n            // `::` indicates one or more groups of 16 bits of zeros.\n            p.read_given_char(':')?;\n            p.read_given_char(':')?;\n\n            // Read the back part of the address. The :: must contain at least one\n            // set of zeroes, so our max length is 7.\n            let mut tail = [0; 7];\n            let limit = 8 - (head_size + 1);\n            let (tail_size, _) = read_groups(p, &mut tail[..limit]);\n\n            // Concat the head and tail of the IP address\n            head[(8 - tail_size)..8].copy_from_slice(&tail[..tail_size]);\n\n            Some(head.into())\n        })\n    }\n\n    /// Read an IP Address, either IPv4 or IPv6.\n    fn read_ip_addr(&mut self) -> Option<IpAddr> {\n        self.read_ipv4_addr().map(IpAddr::V4).or_else(move || self.read_ipv6_addr().map(IpAddr::V6))\n    }\n\n    /// Read a `:` followed by a port in base 10.\n    fn read_port(&mut self) -> Option<u16> {\n        self.read_atomically(|p| {\n            p.read_given_char(':')?;\n            p.read_number(10, None)\n        })\n    }\n\n    /// Read a `%` followed by a scope ID in base 10.\n    fn read_scope_id(&mut self) -> Option<u32> {\n        self.read_atomically(|p| {\n            p.read_given_char('%')?;\n            p.read_number(10, None)\n        })\n    }\n\n    /// Read an IPv4 address with a port.\n    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n        self.read_atomically(|p| {\n            let ip = p.read_ipv4_addr()?;\n            let port = p.read_port()?;\n            Some(SocketAddrV4::new(ip, port))\n        })\n    }\n\n    /// Read an IPv6 address with a port.\n    fn read_socket_addr_v6(&mut self) -> Option<SocketAddrV6> {\n        self.read_atomically(|p| {\n            p.read_given_char('[')?;\n            let ip = p.read_ipv6_addr()?;\n            let scope_id = p.read_scope_id().unwrap_or(0);\n            p.read_given_char(']')?;\n\n            let port = p.read_port()?;\n            Some(SocketAddrV6::new(ip, port, 0, scope_id))\n        })\n    }\n\n    /// Read an IP address with a port\n    fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n        self.read_socket_addr_v4()\n            .map(SocketAddr::V4)\n            .or_else(|| self.read_socket_addr_v6().map(SocketAddr::V6))\n    }\n}\n\n#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\nimpl FromStr for IpAddr {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n        Parser::new(s).parse_with(|p| p.read_ip_addr())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for Ipv4Addr {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n        Parser::new(s).parse_with(|p| p.read_ipv4_addr())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for Ipv6Addr {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n        Parser::new(s).parse_with(|p| p.read_ipv6_addr())\n    }\n}\n\n#[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\nimpl FromStr for SocketAddrV4 {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> {\n        Parser::new(s).parse_with(|p| p.read_socket_addr_v4())\n    }\n}\n\n#[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\nimpl FromStr for SocketAddrV6 {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> {\n        Parser::new(s).parse_with(|p| p.read_socket_addr_v6())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for SocketAddr {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> {\n        Parser::new(s).parse_with(|p| p.read_socket_addr())\n    }\n}\n\n/// An error which can be returned when parsing an IP address or a socket address.\n///\n/// This error is used as the error type for the [`FromStr`] implementation for\n/// [`IpAddr`], [`Ipv4Addr`], [`Ipv6Addr`], [`SocketAddr`], [`SocketAddrV4`], and\n/// [`SocketAddrV6`].\n///\n/// # Potential causes\n///\n/// `AddrParseError` may be thrown because the provided string does not parse as the given type,\n/// often because it includes information only handled by a different address type.\n///\n/// ```should_panic\n/// use std::net::IpAddr;\n/// let _foo: IpAddr = \"127.0.0.1:8080\".parse().expect(\"Cannot handle the socket port\");\n/// ```\n///\n/// [`IpAddr`] doesn't handle the port. Use [`SocketAddr`] instead.\n///\n/// ```\n/// use std::net::SocketAddr;\n///\n/// // No problem, the `panic!` message has disappeared.\n/// let _foo: SocketAddr = \"127.0.0.1:8080\".parse().expect(\"unreachable panic\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct AddrParseError(());\n\n#[stable(feature = \"addr_parse_error_error\", since = \"1.4.0\")]\nimpl fmt::Display for AddrParseError {\n    #[allow(deprecated, deprecated_in_future)]\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.write_str(self.description())\n    }\n}\n\n#[stable(feature = \"addr_parse_error_error\", since = \"1.4.0\")]\nimpl Error for AddrParseError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"invalid IP address syntax\"\n    }\n}\n"],["2595","#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\nuse crate::cmp::Ordering;\nuse crate::convert::TryInto;\nuse crate::fmt;\nuse crate::hash;\nuse crate::io::{self, Write};\nuse crate::iter;\nuse crate::mem;\nuse crate::net::{htons, ntohs, IpAddr, Ipv4Addr, Ipv6Addr};\nuse crate::option;\nuse crate::slice;\nuse crate::sys::net::netc as c;\nuse crate::sys_common::net::LookupHost;\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\nuse crate::vec;\n\n/// An internet socket address, either IPv4 or IPv6.\n///\n/// Internet socket addresses consist of an [IP address], a 16-bit port number, as well\n/// as possibly some version-dependent additional information. See [`SocketAddrV4`]'s and\n/// [`SocketAddrV6`]'s respective documentation for more details.\n///\n/// The size of a `SocketAddr` instance may vary depending on the target operating\n/// system.\n///\n/// [IP address]: IpAddr\n///\n/// # Examples\n///\n/// ```\n/// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n///\n/// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n///\n/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n/// assert_eq!(socket.port(), 8080);\n/// assert_eq!(socket.is_ipv4(), true);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum SocketAddr {\n    /// An IPv4 socket address.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    V4(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV4),\n    /// An IPv6 socket address.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    V6(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV6),\n}\n\n/// An IPv4 socket address.\n///\n/// IPv4 socket addresses consist of an [`IPv4` address] and a 16-bit port number, as\n/// stated in [IETF RFC 793].\n///\n/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n///\n/// The size of a `SocketAddrV4` struct may vary depending on the target operating\n/// system. Do not assume that this type has the same memory layout as the underlying\n/// system representation.\n///\n/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n/// [`IPv4` address]: Ipv4Addr\n///\n/// # Examples\n///\n/// ```\n/// use std::net::{Ipv4Addr, SocketAddrV4};\n///\n/// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n///\n/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n/// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n/// assert_eq!(socket.port(), 8080);\n/// ```\n#[derive(Copy)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SocketAddrV4 {\n    // Do not assume that this struct is implemented as the underlying system representation.\n    // The memory layout is not part of the stable interface that std exposes.\n    inner: c::sockaddr_in,\n}\n\n/// An IPv6 socket address.\n///\n/// IPv6 socket addresses consist of an [`IPv6` address], a 16-bit port number, as well\n/// as fields containing the traffic class, the flow label, and a scope identifier\n/// (see [IETF RFC 2553, Section 3.3] for more details).\n///\n/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n///\n/// The size of a `SocketAddrV6` struct may vary depending on the target operating\n/// system. Do not assume that this type has the same memory layout as the underlying\n/// system representation.\n///\n/// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n/// [`IPv6` address]: Ipv6Addr\n///\n/// # Examples\n///\n/// ```\n/// use std::net::{Ipv6Addr, SocketAddrV6};\n///\n/// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n///\n/// assert_eq!(\"[2001:db8::1]:8080\".parse(), Ok(socket));\n/// assert_eq!(socket.ip(), &Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1));\n/// assert_eq!(socket.port(), 8080);\n/// ```\n#[derive(Copy)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SocketAddrV6 {\n    // Do not assume that this struct is implemented as the underlying system representation.\n    // The memory layout is not part of the stable interface that std exposes.\n    inner: c::sockaddr_in6,\n}\n\nimpl SocketAddr {\n    /// Creates a new socket address from an [IP address] and a port number.\n    ///\n    /// [IP address]: IpAddr\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n    /// assert_eq!(socket.port(), 8080);\n    /// ```\n    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n    pub fn new(ip: IpAddr, port: u16) -> SocketAddr {\n        match ip {\n            IpAddr::V4(a) => SocketAddr::V4(SocketAddrV4::new(a, port)),\n            IpAddr::V6(a) => SocketAddr::V6(SocketAddrV6::new(a, port, 0, 0)),\n        }\n    }\n\n    /// Returns the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n    /// ```\n    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn ip(&self) -> IpAddr {\n        match *self {\n            SocketAddr::V4(ref a) => IpAddr::V4(*a.ip()),\n            SocketAddr::V6(ref a) => IpAddr::V6(*a.ip()),\n        }\n    }\n\n    /// Changes the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// socket.set_ip(IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_ip(&mut self, new_ip: IpAddr) {\n        // `match (*self, new_ip)` would have us mutate a copy of self only to throw it away.\n        match (self, new_ip) {\n            (&mut SocketAddr::V4(ref mut a), IpAddr::V4(new_ip)) => a.set_ip(new_ip),\n            (&mut SocketAddr::V6(ref mut a), IpAddr::V6(new_ip)) => a.set_ip(new_ip),\n            (self_, new_ip) => *self_ = Self::new(new_ip, self_.port()),\n        }\n    }\n\n    /// Returns the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// assert_eq!(socket.port(), 8080);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn port(&self) -> u16 {\n        match *self {\n            SocketAddr::V4(ref a) => a.port(),\n            SocketAddr::V6(ref a) => a.port(),\n        }\n    }\n\n    /// Changes the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// socket.set_port(1025);\n    /// assert_eq!(socket.port(), 1025);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_port(&mut self, new_port: u16) {\n        match *self {\n            SocketAddr::V4(ref mut a) => a.set_port(new_port),\n            SocketAddr::V6(ref mut a) => a.set_port(new_port),\n        }\n    }\n\n    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n    /// [`IPv4` address], and [`false`] otherwise.\n    ///\n    /// [IP address]: IpAddr\n    /// [`IPv4` address]: IpAddr::V4\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// assert_eq!(socket.is_ipv4(), true);\n    /// assert_eq!(socket.is_ipv6(), false);\n    /// ```\n    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn is_ipv4(&self) -> bool {\n        matches!(*self, SocketAddr::V4(_))\n    }\n\n    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n    /// [`IPv6` address], and [`false`] otherwise.\n    ///\n    /// [IP address]: IpAddr\n    /// [`IPv6` address]: IpAddr::V6\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n    /// assert_eq!(socket.is_ipv4(), false);\n    /// assert_eq!(socket.is_ipv6(), true);\n    /// ```\n    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn is_ipv6(&self) -> bool {\n        matches!(*self, SocketAddr::V6(_))\n    }\n}\n\nimpl SocketAddrV4 {\n    /// Creates a new socket address from an [`IPv4` address] and a port number.\n    ///\n    /// [`IPv4` address]: Ipv4Addr\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n        SocketAddrV4 {\n            inner: c::sockaddr_in {\n                sin_family: c::AF_INET as c::sa_family_t,\n                sin_port: htons(port),\n                sin_addr: ip.into_inner(),\n                ..unsafe { mem::zeroed() }\n            },\n        }\n    }\n\n    /// Returns the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn ip(&self) -> &Ipv4Addr {\n        // SAFETY: `Ipv4Addr` is `#[repr(C)] struct { _: in_addr; }`.\n        // It is safe to cast from `&in_addr` to `&Ipv4Addr`.\n        unsafe { &*(&self.inner.sin_addr as *const c::in_addr as *const Ipv4Addr) }\n    }\n\n    /// Changes the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// socket.set_ip(Ipv4Addr::new(192, 168, 0, 1));\n    /// assert_eq!(socket.ip(), &Ipv4Addr::new(192, 168, 0, 1));\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_ip(&mut self, new_ip: Ipv4Addr) {\n        self.inner.sin_addr = new_ip.into_inner()\n    }\n\n    /// Returns the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// assert_eq!(socket.port(), 8080);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn port(&self) -> u16 {\n        ntohs(self.inner.sin_port)\n    }\n\n    /// Changes the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// socket.set_port(4242);\n    /// assert_eq!(socket.port(), 4242);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_port(&mut self, new_port: u16) {\n        self.inner.sin_port = htons(new_port);\n    }\n}\n\nimpl SocketAddrV6 {\n    /// Creates a new socket address from an [`IPv6` address], a 16-bit port number,\n    /// and the `flowinfo` and `scope_id` fields.\n    ///\n    /// For more information on the meaning and layout of the `flowinfo` and `scope_id`\n    /// parameters, see [IETF RFC 2553, Section 3.3].\n    ///\n    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n    /// [`IPv6` address]: Ipv6Addr\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n        SocketAddrV6 {\n            inner: c::sockaddr_in6 {\n                sin6_family: c::AF_INET6 as c::sa_family_t,\n                sin6_port: htons(port),\n                sin6_addr: *ip.as_inner(),\n                sin6_flowinfo: flowinfo,\n                sin6_scope_id: scope_id,\n                ..unsafe { mem::zeroed() }\n            },\n        }\n    }\n\n    /// Returns the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// assert_eq!(socket.ip(), &Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn ip(&self) -> &Ipv6Addr {\n        unsafe { &*(&self.inner.sin6_addr as *const c::in6_addr as *const Ipv6Addr) }\n    }\n\n    /// Changes the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// socket.set_ip(Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n    /// assert_eq!(socket.ip(), &Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n        self.inner.sin6_addr = *new_ip.as_inner()\n    }\n\n    /// Returns the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// assert_eq!(socket.port(), 8080);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn port(&self) -> u16 {\n        ntohs(self.inner.sin6_port)\n    }\n\n    /// Changes the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// socket.set_port(4242);\n    /// assert_eq!(socket.port(), 4242);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_port(&mut self, new_port: u16) {\n        self.inner.sin6_port = htons(new_port);\n    }\n\n    /// Returns the flow information associated with this address.\n    ///\n    /// This information corresponds to the `sin6_flowinfo` field in C's `netinet/in.h`,\n    /// as specified in [IETF RFC 2553, Section 3.3].\n    /// It combines information about the flow label and the traffic class as specified\n    /// in [IETF RFC 2460], respectively [Section 6] and [Section 7].\n    ///\n    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n    /// [IETF RFC 2460]: https://tools.ietf.org/html/rfc2460\n    /// [Section 6]: https://tools.ietf.org/html/rfc2460#section-6\n    /// [Section 7]: https://tools.ietf.org/html/rfc2460#section-7\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n    /// assert_eq!(socket.flowinfo(), 10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn flowinfo(&self) -> u32 {\n        self.inner.sin6_flowinfo\n    }\n\n    /// Changes the flow information associated with this socket address.\n    ///\n    /// See [`SocketAddrV6::flowinfo`]'s documentation for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n    /// socket.set_flowinfo(56);\n    /// assert_eq!(socket.flowinfo(), 56);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_flowinfo(&mut self, new_flowinfo: u32) {\n        self.inner.sin6_flowinfo = new_flowinfo;\n    }\n\n    /// Returns the scope ID associated with this address.\n    ///\n    /// This information corresponds to the `sin6_scope_id` field in C's `netinet/in.h`,\n    /// as specified in [IETF RFC 2553, Section 3.3].\n    ///\n    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n    /// assert_eq!(socket.scope_id(), 78);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_socketaddr\", issue = \"82485\")]\n    pub const fn scope_id(&self) -> u32 {\n        self.inner.sin6_scope_id\n    }\n\n    /// Changes the scope ID associated with this socket address.\n    ///\n    /// See [`SocketAddrV6::scope_id`]'s documentation for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n    /// socket.set_scope_id(42);\n    /// assert_eq!(socket.scope_id(), 42);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_scope_id(&mut self, new_scope_id: u32) {\n        self.inner.sin6_scope_id = new_scope_id;\n    }\n}\n\nimpl FromInner<c::sockaddr_in> for SocketAddrV4 {\n    fn from_inner(addr: c::sockaddr_in) -> SocketAddrV4 {\n        SocketAddrV4 { inner: addr }\n    }\n}\n\nimpl FromInner<c::sockaddr_in6> for SocketAddrV6 {\n    fn from_inner(addr: c::sockaddr_in6) -> SocketAddrV6 {\n        SocketAddrV6 { inner: addr }\n    }\n}\n\n#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\nimpl From<SocketAddrV4> for SocketAddr {\n    /// Converts a [`SocketAddrV4`] into a [`SocketAddr::V4`].\n    fn from(sock4: SocketAddrV4) -> SocketAddr {\n        SocketAddr::V4(sock4)\n    }\n}\n\n#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\nimpl From<SocketAddrV6> for SocketAddr {\n    /// Converts a [`SocketAddrV6`] into a [`SocketAddr::V6`].\n    fn from(sock6: SocketAddrV6) -> SocketAddr {\n        SocketAddr::V6(sock6)\n    }\n}\n\n#[stable(feature = \"addr_from_into_ip\", since = \"1.17.0\")]\nimpl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n    /// Converts a tuple struct (Into<[`IpAddr`]>, `u16`) into a [`SocketAddr`].\n    ///\n    /// This conversion creates a [`SocketAddr::V4`] for a [`IpAddr::V4`]\n    /// and creates a [`SocketAddr::V6`] for a [`IpAddr::V6`].\n    ///\n    /// `u16` is treated as port of the newly created [`SocketAddr`].\n    fn from(pieces: (I, u16)) -> SocketAddr {\n        SocketAddr::new(pieces.0.into(), pieces.1)\n    }\n}\n\nimpl<'a> IntoInner<(*const c::sockaddr, c::socklen_t)> for &'a SocketAddr {\n    fn into_inner(self) -> (*const c::sockaddr, c::socklen_t) {\n        match *self {\n            SocketAddr::V4(ref a) => {\n                (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n            }\n            SocketAddr::V6(ref a) => {\n                (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for SocketAddr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            SocketAddr::V4(ref a) => a.fmt(f),\n            SocketAddr::V6(ref a) => a.fmt(f),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for SocketAddr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for SocketAddrV4 {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Fast path: if there's no alignment stuff, write to the output buffer\n        // directly\n        if f.precision().is_none() && f.width().is_none() {\n            write!(f, \"{}:{}\", self.ip(), self.port())\n        } else {\n            const IPV4_SOCKET_BUF_LEN: usize = (3 * 4)  // the segments\n                + 3  // the separators\n                + 1 + 5; // the port\n            let mut buf = [0; IPV4_SOCKET_BUF_LEN];\n            let mut buf_slice = &mut buf[..];\n\n            // Unwrap is fine because writing to a sufficiently-sized\n            // buffer is infallible\n            write!(buf_slice, \"{}:{}\", self.ip(), self.port()).unwrap();\n            let len = IPV4_SOCKET_BUF_LEN - buf_slice.len();\n\n            // This unsafe is OK because we know what is being written to the buffer\n            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n            f.pad(buf)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for SocketAddrV4 {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for SocketAddrV6 {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Fast path: if there's no alignment stuff, write to the output\n        // buffer directly\n        if f.precision().is_none() && f.width().is_none() {\n            match self.scope_id() {\n                0 => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n                scope_id => write!(f, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n            }\n        } else {\n            const IPV6_SOCKET_BUF_LEN: usize = (4 * 8)  // The address\n            + 7  // The colon separators\n            + 2  // The brackets\n            + 1 + 10 // The scope id\n            + 1 + 5; // The port\n\n            let mut buf = [0; IPV6_SOCKET_BUF_LEN];\n            let mut buf_slice = &mut buf[..];\n\n            match self.scope_id() {\n                0 => write!(buf_slice, \"[{}]:{}\", self.ip(), self.port()),\n                scope_id => write!(buf_slice, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n            }\n            // Unwrap is fine because writing to a sufficiently-sized\n            // buffer is infallible\n            .unwrap();\n            let len = IPV6_SOCKET_BUF_LEN - buf_slice.len();\n\n            // This unsafe is OK because we know what is being written to the buffer\n            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n            f.pad(buf)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for SocketAddrV6 {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for SocketAddrV4 {\n    fn clone(&self) -> SocketAddrV4 {\n        *self\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for SocketAddrV6 {\n    fn clone(&self) -> SocketAddrV6 {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for SocketAddrV4 {\n    fn eq(&self, other: &SocketAddrV4) -> bool {\n        self.inner.sin_port == other.inner.sin_port\n            && self.inner.sin_addr.s_addr == other.inner.sin_addr.s_addr\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for SocketAddrV6 {\n    fn eq(&self, other: &SocketAddrV6) -> bool {\n        self.inner.sin6_port == other.inner.sin6_port\n            && self.inner.sin6_addr.s6_addr == other.inner.sin6_addr.s6_addr\n            && self.inner.sin6_flowinfo == other.inner.sin6_flowinfo\n            && self.inner.sin6_scope_id == other.inner.sin6_scope_id\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for SocketAddrV4 {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for SocketAddrV6 {}\n\n#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\nimpl PartialOrd for SocketAddrV4 {\n    fn partial_cmp(&self, other: &SocketAddrV4) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\nimpl PartialOrd for SocketAddrV6 {\n    fn partial_cmp(&self, other: &SocketAddrV6) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\nimpl Ord for SocketAddrV4 {\n    fn cmp(&self, other: &SocketAddrV4) -> Ordering {\n        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n    }\n}\n\n#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\nimpl Ord for SocketAddrV6 {\n    fn cmp(&self, other: &SocketAddrV6) -> Ordering {\n        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for SocketAddrV4 {\n    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n        (self.inner.sin_port, self.inner.sin_addr.s_addr).hash(s)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for SocketAddrV6 {\n    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n        (\n            self.inner.sin6_port,\n            &self.inner.sin6_addr.s6_addr,\n            self.inner.sin6_flowinfo,\n            self.inner.sin6_scope_id,\n        )\n            .hash(s)\n    }\n}\n\n/// A trait for objects which can be converted or resolved to one or more\n/// [`SocketAddr`] values.\n///\n/// This trait is used for generic address resolution when constructing network\n/// objects. By default it is implemented for the following types:\n///\n///  * [`SocketAddr`]: [`to_socket_addrs`] is the identity function.\n///\n///  * [`SocketAddrV4`], [`SocketAddrV6`], `(`[`IpAddr`]`, `[`u16`]`)`,\n///    `(`[`Ipv4Addr`]`, `[`u16`]`)`, `(`[`Ipv6Addr`]`, `[`u16`]`)`:\n///    [`to_socket_addrs`] constructs a [`SocketAddr`] trivially.\n///\n///  * `(`[`&str`]`, `[`u16`]`)`: [`&str`] should be either a string representation\n///    of an [`IpAddr`] address as expected by [`FromStr`] implementation or a host\n///    name. [`u16`] is the port number.\n///\n///  * [`&str`]: the string should be either a string representation of a\n///    [`SocketAddr`] as expected by its [`FromStr`] implementation or a string like\n///    `<host_name>:<port>` pair where `<port>` is a [`u16`] value.\n///\n/// This trait allows constructing network objects like [`TcpStream`] or\n/// [`UdpSocket`] easily with values of various types for the bind/connection\n/// address. It is needed because sometimes one type is more appropriate than\n/// the other: for simple uses a string like `\"localhost:12345\"` is much nicer\n/// than manual construction of the corresponding [`SocketAddr`], but sometimes\n/// [`SocketAddr`] value is *the* main source of the address, and converting it to\n/// some other type (e.g., a string) just for it to be converted back to\n/// [`SocketAddr`] in constructor methods is pointless.\n///\n/// Addresses returned by the operating system that are not IP addresses are\n/// silently ignored.\n///\n/// [`FromStr`]: crate::str::FromStr\n/// [`&str`]: str\n/// [`TcpStream`]: crate::net::TcpStream\n/// [`to_socket_addrs`]: ToSocketAddrs::to_socket_addrs\n/// [`UdpSocket`]: crate::net::UdpSocket\n///\n/// # Examples\n///\n/// Creating a [`SocketAddr`] iterator that yields one item:\n///\n/// ```\n/// use std::net::{ToSocketAddrs, SocketAddr};\n///\n/// let addr = SocketAddr::from(([127, 0, 0, 1], 443));\n/// let mut addrs_iter = addr.to_socket_addrs().unwrap();\n///\n/// assert_eq!(Some(addr), addrs_iter.next());\n/// assert!(addrs_iter.next().is_none());\n/// ```\n///\n/// Creating a [`SocketAddr`] iterator from a hostname:\n///\n/// ```no_run\n/// use std::net::{SocketAddr, ToSocketAddrs};\n///\n/// // assuming 'localhost' resolves to 127.0.0.1\n/// let mut addrs_iter = \"localhost:443\".to_socket_addrs().unwrap();\n/// assert_eq!(addrs_iter.next(), Some(SocketAddr::from(([127, 0, 0, 1], 443))));\n/// assert!(addrs_iter.next().is_none());\n///\n/// // assuming 'foo' does not resolve\n/// assert!(\"foo:443\".to_socket_addrs().is_err());\n/// ```\n///\n/// Creating a [`SocketAddr`] iterator that yields multiple items:\n///\n/// ```\n/// use std::net::{SocketAddr, ToSocketAddrs};\n///\n/// let addr1 = SocketAddr::from(([0, 0, 0, 0], 80));\n/// let addr2 = SocketAddr::from(([127, 0, 0, 1], 443));\n/// let addrs = vec![addr1, addr2];\n///\n/// let mut addrs_iter = (&addrs[..]).to_socket_addrs().unwrap();\n///\n/// assert_eq!(Some(addr1), addrs_iter.next());\n/// assert_eq!(Some(addr2), addrs_iter.next());\n/// assert!(addrs_iter.next().is_none());\n/// ```\n///\n/// Attempting to create a [`SocketAddr`] iterator from an improperly formatted\n/// socket address `&str` (missing the port):\n///\n/// ```\n/// use std::io;\n/// use std::net::ToSocketAddrs;\n///\n/// let err = \"127.0.0.1\".to_socket_addrs().unwrap_err();\n/// assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n/// ```\n///\n/// [`TcpStream::connect`] is an example of an function that utilizes\n/// `ToSocketAddrs` as a trait bound on its parameter in order to accept\n/// different types:\n///\n/// ```no_run\n/// use std::net::{TcpStream, Ipv4Addr};\n///\n/// let stream = TcpStream::connect((\"127.0.0.1\", 443));\n/// // or\n/// let stream = TcpStream::connect(\"127.0.0.1:443\");\n/// // or\n/// let stream = TcpStream::connect((Ipv4Addr::new(127, 0, 0, 1), 443));\n/// ```\n///\n/// [`TcpStream::connect`]: crate::net::TcpStream::connect\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait ToSocketAddrs {\n    /// Returned iterator over socket addresses which this type may correspond\n    /// to.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Iter: Iterator<Item = SocketAddr>;\n\n    /// Converts this object to an iterator of resolved `SocketAddr`s.\n    ///\n    /// The returned iterator may not actually yield any values depending on the\n    /// outcome of any resolution performed.\n    ///\n    /// Note that this function may block the current thread while resolution is\n    /// performed.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn to_socket_addrs(&self) -> io::Result<Self::Iter>;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for SocketAddr {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n        Ok(Some(*self).into_iter())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for SocketAddrV4 {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n        SocketAddr::V4(*self).to_socket_addrs()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for SocketAddrV6 {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n        SocketAddr::V6(*self).to_socket_addrs()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for (IpAddr, u16) {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n        let (ip, port) = *self;\n        match ip {\n            IpAddr::V4(ref a) => (*a, port).to_socket_addrs(),\n            IpAddr::V6(ref a) => (*a, port).to_socket_addrs(),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for (Ipv4Addr, u16) {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n        let (ip, port) = *self;\n        SocketAddrV4::new(ip, port).to_socket_addrs()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for (Ipv6Addr, u16) {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n        let (ip, port) = *self;\n        SocketAddrV6::new(ip, port, 0, 0).to_socket_addrs()\n    }\n}\n\nfn resolve_socket_addr(lh: LookupHost) -> io::Result<vec::IntoIter<SocketAddr>> {\n    let p = lh.port();\n    let v: Vec<_> = lh\n        .map(|mut a| {\n            a.set_port(p);\n            a\n        })\n        .collect();\n    Ok(v.into_iter())\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for (&str, u16) {\n    type Iter = vec::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n        let (host, port) = *self;\n\n        // try to parse the host as a regular IP address first\n        if let Ok(addr) = host.parse::<Ipv4Addr>() {\n            let addr = SocketAddrV4::new(addr, port);\n            return Ok(vec![SocketAddr::V4(addr)].into_iter());\n        }\n        if let Ok(addr) = host.parse::<Ipv6Addr>() {\n            let addr = SocketAddrV6::new(addr, port, 0, 0);\n            return Ok(vec![SocketAddr::V6(addr)].into_iter());\n        }\n\n        resolve_socket_addr((host, port).try_into()?)\n    }\n}\n\n#[stable(feature = \"string_u16_to_socket_addrs\", since = \"1.46.0\")]\nimpl ToSocketAddrs for (String, u16) {\n    type Iter = vec::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n        (&*self.0, self.1).to_socket_addrs()\n    }\n}\n\n// accepts strings like 'localhost:12345'\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for str {\n    type Iter = vec::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n        // try to parse as a regular SocketAddr first\n        if let Ok(addr) = self.parse() {\n            return Ok(vec![addr].into_iter());\n        }\n\n        resolve_socket_addr(self.try_into()?)\n    }\n}\n\n#[stable(feature = \"slice_to_socket_addrs\", since = \"1.8.0\")]\nimpl<'a> ToSocketAddrs for &'a [SocketAddr] {\n    type Iter = iter::Cloned<slice::Iter<'a, SocketAddr>>;\n\n    fn to_socket_addrs(&self) -> io::Result<Self::Iter> {\n        Ok(self.iter().cloned())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ToSocketAddrs + ?Sized> ToSocketAddrs for &T {\n    type Iter = T::Iter;\n    fn to_socket_addrs(&self) -> io::Result<T::Iter> {\n        (**self).to_socket_addrs()\n    }\n}\n\n#[stable(feature = \"string_to_socket_addrs\", since = \"1.16.0\")]\nimpl ToSocketAddrs for String {\n    type Iter = vec::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n        (&**self).to_socket_addrs()\n    }\n}\n"],["2596","#![deny(unsafe_op_in_unsafe_fn)]\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\nuse crate::io::prelude::*;\n\nuse crate::fmt;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut};\nuse crate::net::{Shutdown, SocketAddr, ToSocketAddrs};\nuse crate::sys_common::net as net_imp;\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\nuse crate::time::Duration;\n\n/// A TCP stream between a local and a remote socket.\n///\n/// After creating a `TcpStream` by either [`connect`]ing to a remote host or\n/// [`accept`]ing a connection on a [`TcpListener`], data can be transmitted\n/// by [reading] and [writing] to it.\n///\n/// The connection will be closed when the value is dropped. The reading and writing\n/// portions of the connection can also be shut down individually with the [`shutdown`]\n/// method.\n///\n/// The Transmission Control Protocol is specified in [IETF RFC 793].\n///\n/// [`accept`]: TcpListener::accept\n/// [`connect`]: TcpStream::connect\n/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n/// [reading]: Read\n/// [`shutdown`]: TcpStream::shutdown\n/// [writing]: Write\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::net::TcpStream;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\")?;\n///\n///     stream.write(&[1])?;\n///     stream.read(&mut [0; 128])?;\n///     Ok(())\n/// } // the stream is closed here\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct TcpStream(net_imp::TcpStream);\n\n/// A TCP socket server, listening for connections.\n///\n/// After creating a `TcpListener` by [`bind`]ing it to a socket address, it listens\n/// for incoming TCP connections. These can be accepted by calling [`accept`] or by\n/// iterating over the [`Incoming`] iterator returned by [`incoming`][`TcpListener::incoming`].\n///\n/// The socket will be closed when the value is dropped.\n///\n/// The Transmission Control Protocol is specified in [IETF RFC 793].\n///\n/// [`accept`]: TcpListener::accept\n/// [`bind`]: TcpListener::bind\n/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::net::{TcpListener, TcpStream};\n///\n/// fn handle_client(stream: TcpStream) {\n///     // ...\n/// }\n///\n/// fn main() -> std::io::Result<()> {\n///     let listener = TcpListener::bind(\"127.0.0.1:80\")?;\n///\n///     // accept connections and process them serially\n///     for stream in listener.incoming() {\n///         handle_client(stream?);\n///     }\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct TcpListener(net_imp::TcpListener);\n\n/// An iterator that infinitely [`accept`]s connections on a [`TcpListener`].\n///\n/// This `struct` is created by the [`TcpListener::incoming`] method.\n/// See its documentation for more.\n///\n/// [`accept`]: TcpListener::accept\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Incoming<'a> {\n    listener: &'a TcpListener,\n}\n\nimpl TcpStream {\n    /// Opens a TCP connection to a remote host.\n    ///\n    /// `addr` is an address of the remote host. Anything which implements\n    /// [`ToSocketAddrs`] trait can be supplied for the address; see this trait\n    /// documentation for concrete examples.\n    ///\n    /// If `addr` yields multiple addresses, `connect` will be attempted with\n    /// each of the addresses until a connection is successful. If none of\n    /// the addresses result in a successful connection, the error returned from\n    /// the last connection attempt (the last address) is returned.\n    ///\n    /// # Examples\n    ///\n    /// Open a TCP connection to `127.0.0.1:8080`:\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// if let Ok(stream) = TcpStream::connect(\"127.0.0.1:8080\") {\n    ///     println!(\"Connected to the server!\");\n    /// } else {\n    ///     println!(\"Couldn't connect to server...\");\n    /// }\n    /// ```\n    ///\n    /// Open a TCP connection to `127.0.0.1:8080`. If the connection fails, open\n    /// a TCP connection to `127.0.0.1:8081`:\n    ///\n    /// ```no_run\n    /// use std::net::{SocketAddr, TcpStream};\n    ///\n    /// let addrs = [\n    ///     SocketAddr::from(([127, 0, 0, 1], 8080)),\n    ///     SocketAddr::from(([127, 0, 0, 1], 8081)),\n    /// ];\n    /// if let Ok(stream) = TcpStream::connect(&addrs[..]) {\n    ///     println!(\"Connected to the server!\");\n    /// } else {\n    ///     println!(\"Couldn't connect to server...\");\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> {\n        super::each_addr(addr, net_imp::TcpStream::connect).map(TcpStream)\n    }\n\n    /// Opens a TCP connection to a remote host with a timeout.\n    ///\n    /// Unlike `connect`, `connect_timeout` takes a single [`SocketAddr`] since\n    /// timeout must be applied to individual addresses.\n    ///\n    /// It is an error to pass a zero `Duration` to this function.\n    ///\n    /// Unlike other methods on `TcpStream`, this does not correspond to a\n    /// single system call. It instead calls `connect` in nonblocking mode and\n    /// then uses an OS-specific mechanism to await the completion of the\n    /// connection request.\n    #[stable(feature = \"tcpstream_connect_timeout\", since = \"1.21.0\")]\n    pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {\n        net_imp::TcpStream::connect_timeout(addr, timeout).map(TcpStream)\n    }\n\n    /// Returns the socket address of the remote peer of this TCP connection.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpStream};\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// assert_eq!(stream.peer_addr().unwrap(),\n    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        self.0.peer_addr()\n    }\n\n    /// Returns the socket address of the local half of this TCP connection.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{IpAddr, Ipv4Addr, TcpStream};\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// assert_eq!(stream.local_addr().unwrap().ip(),\n    ///            IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n        self.0.socket_addr()\n    }\n\n    /// Shuts down the read, write, or both halves of this connection.\n    ///\n    /// This function will cause all pending and future I/O on the specified\n    /// portions to return immediately with an appropriate value (see the\n    /// documentation of [`Shutdown`]).\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Calling this function multiple times may result in different behavior,\n    /// depending on the operating system. On Linux, the second call will\n    /// return `Ok(())`, but on macOS, it will return `ErrorKind::NotConnected`.\n    /// This may change in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Shutdown, TcpStream};\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.shutdown(Shutdown::Both).expect(\"shutdown call failed\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n        self.0.shutdown(how)\n    }\n\n    /// Creates a new independently owned handle to the underlying socket.\n    ///\n    /// The returned `TcpStream` is a reference to the same stream that this\n    /// object references. Both handles will read and write the same stream of\n    /// data, and options set on one stream will be propagated to the other\n    /// stream.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// let stream_clone = stream.try_clone().expect(\"clone failed...\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_clone(&self) -> io::Result<TcpStream> {\n        self.0.duplicate().map(TcpStream)\n    }\n\n    /// Sets the read timeout to the timeout specified.\n    ///\n    /// If the value specified is [`None`], then [`read`] calls will block\n    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n    /// passed to this method.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Platforms may return a different error code whenever a read times out as\n    /// a result of setting this option. For example Unix typically returns an\n    /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n    ///\n    /// [`read`]: Read::read\n    /// [`WouldBlock`]: io::ErrorKind::WouldBlock\n    /// [`TimedOut`]: io::ErrorKind::TimedOut\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n    /// ```\n    ///\n    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n    /// method:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::TcpStream;\n    /// use std::time::Duration;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n    /// let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        self.0.set_read_timeout(dur)\n    }\n\n    /// Sets the write timeout to the timeout specified.\n    ///\n    /// If the value specified is [`None`], then [`write`] calls will block\n    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n    /// passed to this method.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Platforms may return a different error code whenever a write times out\n    /// as a result of setting this option. For example Unix typically returns\n    /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n    ///\n    /// [`write`]: Write::write\n    /// [`WouldBlock`]: io::ErrorKind::WouldBlock\n    /// [`TimedOut`]: io::ErrorKind::TimedOut\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n    /// ```\n    ///\n    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n    /// method:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::TcpStream;\n    /// use std::time::Duration;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n    /// let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        self.0.set_write_timeout(dur)\n    }\n\n    /// Returns the read timeout of this socket.\n    ///\n    /// If the timeout is [`None`], then [`read`] calls will block indefinitely.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Some platforms do not provide access to the current timeout.\n    ///\n    /// [`read`]: Read::read\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n    /// assert_eq!(stream.read_timeout().unwrap(), None);\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0.read_timeout()\n    }\n\n    /// Returns the write timeout of this socket.\n    ///\n    /// If the timeout is [`None`], then [`write`] calls will block indefinitely.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Some platforms do not provide access to the current timeout.\n    ///\n    /// [`write`]: Write::write\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n    /// assert_eq!(stream.write_timeout().unwrap(), None);\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0.write_timeout()\n    }\n\n    /// Receives data on the socket from the remote address to which it is\n    /// connected, without removing that data from the queue. On success,\n    /// returns the number of bytes peeked.\n    ///\n    /// Successive calls return the same data. This is accomplished by passing\n    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8000\")\n    ///                        .expect(\"couldn't bind to address\");\n    /// let mut buf = [0; 10];\n    /// let len = stream.peek(&mut buf).expect(\"peek failed\");\n    /// ```\n    #[stable(feature = \"peek\", since = \"1.18.0\")]\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.peek(buf)\n    }\n\n    /// Sets the value of the `TCP_NODELAY` option on this socket.\n    ///\n    /// If set, this option disables the Nagle algorithm. This means that\n    /// segments are always sent as soon as possible, even if there is only a\n    /// small amount of data. When not set, data is buffered until there is a\n    /// sufficient amount to send out, thereby avoiding the frequent sending of\n    /// small packets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_nodelay(true).expect(\"set_nodelay call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n        self.0.set_nodelay(nodelay)\n    }\n\n    /// Gets the value of the `TCP_NODELAY` option on this socket.\n    ///\n    /// For more information about this option, see [`TcpStream::set_nodelay`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_nodelay(true).expect(\"set_nodelay call failed\");\n    /// assert_eq!(stream.nodelay().unwrap_or(false), true);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn nodelay(&self) -> io::Result<bool> {\n        self.0.nodelay()\n    }\n\n    /// Sets the value for the `IP_TTL` option on this socket.\n    ///\n    /// This value sets the time-to-live field that is used in every packet sent\n    /// from this socket.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_ttl(100).expect(\"set_ttl call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n        self.0.set_ttl(ttl)\n    }\n\n    /// Gets the value of the `IP_TTL` option for this socket.\n    ///\n    /// For more information about this option, see [`TcpStream::set_ttl`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_ttl(100).expect(\"set_ttl call failed\");\n    /// assert_eq!(stream.ttl().unwrap_or(0), 100);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn ttl(&self) -> io::Result<u32> {\n        self.0.ttl()\n    }\n\n    /// Gets the value of the `SO_ERROR` option on this socket.\n    ///\n    /// This will retrieve the stored error in the underlying socket, clearing\n    /// the field in the process. This can be useful for checking errors between\n    /// calls.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.take_error().expect(\"No error was expected...\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.0.take_error()\n    }\n\n    /// Moves this TCP stream into or out of nonblocking mode.\n    ///\n    /// This will result in `read`, `write`, `recv` and `send` operations\n    /// becoming nonblocking, i.e., immediately returning from their calls.\n    /// If the IO operation is successful, `Ok` is returned and no further\n    /// action is required. If the IO operation could not be completed and needs\n    /// to be retried, an error with kind [`io::ErrorKind::WouldBlock`] is\n    /// returned.\n    ///\n    /// On Unix platforms, calling this method corresponds to calling `fcntl`\n    /// `FIONBIO`. On Windows calling this method corresponds to calling\n    /// `ioctlsocket` `FIONBIO`.\n    ///\n    /// # Examples\n    ///\n    /// Reading bytes from a TCP stream in non-blocking mode:\n    ///\n    /// ```no_run\n    /// use std::io::{self, Read};\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = TcpStream::connect(\"127.0.0.1:7878\")\n    ///     .expect(\"Couldn't connect to the server...\");\n    /// stream.set_nonblocking(true).expect(\"set_nonblocking call failed\");\n    ///\n    /// # fn wait_for_fd() { unimplemented!() }\n    /// let mut buf = vec![];\n    /// loop {\n    ///     match stream.read_to_end(&mut buf) {\n    ///         Ok(_) => break,\n    ///         Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///             // wait until network socket is ready, typically implemented\n    ///             // via platform-specific APIs such as epoll or IOCP\n    ///             wait_for_fd();\n    ///         }\n    ///         Err(e) => panic!(\"encountered IO error: {}\", e),\n    ///     };\n    /// };\n    /// println!(\"bytes: {:?}\", buf);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        self.0.set_nonblocking(nonblocking)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for TcpStream {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.0.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        // SAFETY: Read is guaranteed to work on uninitialized memory\n        unsafe { Initializer::nop() }\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for TcpStream {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0.write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for &TcpStream {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.0.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        // SAFETY: Read is guaranteed to work on uninitialized memory\n        unsafe { Initializer::nop() }\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for &TcpStream {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0.write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl AsInner<net_imp::TcpStream> for TcpStream {\n    fn as_inner(&self) -> &net_imp::TcpStream {\n        &self.0\n    }\n}\n\nimpl FromInner<net_imp::TcpStream> for TcpStream {\n    fn from_inner(inner: net_imp::TcpStream) -> TcpStream {\n        TcpStream(inner)\n    }\n}\n\nimpl IntoInner<net_imp::TcpStream> for TcpStream {\n    fn into_inner(self) -> net_imp::TcpStream {\n        self.0\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for TcpStream {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\nimpl TcpListener {\n    /// Creates a new `TcpListener` which will be bound to the specified\n    /// address.\n    ///\n    /// The returned listener is ready for accepting connections.\n    ///\n    /// Binding with a port number of 0 will request that the OS assigns a port\n    /// to this listener. The port allocated can be queried via the\n    /// [`TcpListener::local_addr`] method.\n    ///\n    /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n    /// its documentation for concrete examples.\n    ///\n    /// If `addr` yields multiple addresses, `bind` will be attempted with\n    /// each of the addresses until one succeeds and returns the listener. If\n    /// none of the addresses succeed in creating a listener, the error returned\n    /// from the last attempt (the last address) is returned.\n    ///\n    /// # Examples\n    ///\n    /// Creates a TCP listener bound to `127.0.0.1:80`:\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    /// ```\n    ///\n    /// Creates a TCP listener bound to `127.0.0.1:80`. If that fails, create a\n    /// TCP listener bound to `127.0.0.1:443`:\n    ///\n    /// ```no_run\n    /// use std::net::{SocketAddr, TcpListener};\n    ///\n    /// let addrs = [\n    ///     SocketAddr::from(([127, 0, 0, 1], 80)),\n    ///     SocketAddr::from(([127, 0, 0, 1], 443)),\n    /// ];\n    /// let listener = TcpListener::bind(&addrs[..]).unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n        super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)\n    }\n\n    /// Returns the local socket address of this listener.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpListener};\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n    /// assert_eq!(listener.local_addr().unwrap(),\n    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n        self.0.socket_addr()\n    }\n\n    /// Creates a new independently owned handle to the underlying socket.\n    ///\n    /// The returned [`TcpListener`] is a reference to the same socket that this\n    /// object references. Both handles can be used to accept incoming\n    /// connections and options set on one listener will affect the other.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n    /// let listener_clone = listener.try_clone().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_clone(&self) -> io::Result<TcpListener> {\n        self.0.duplicate().map(TcpListener)\n    }\n\n    /// Accept a new incoming connection from this listener.\n    ///\n    /// This function will block the calling thread until a new TCP connection\n    /// is established. When established, the corresponding [`TcpStream`] and the\n    /// remote peer's address will be returned.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n    /// match listener.accept() {\n    ///     Ok((_socket, addr)) => println!(\"new client: {:?}\", addr),\n    ///     Err(e) => println!(\"couldn't get client: {:?}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n        // On WASM, `TcpStream` is uninhabited (as it's unsupported) and so\n        // the `a` variable here is technically unused.\n        #[cfg_attr(target_arch = \"wasm32\", allow(unused_variables))]\n        self.0.accept().map(|(a, b)| (TcpStream(a), b))\n    }\n\n    /// Returns an iterator over the connections being received on this\n    /// listener.\n    ///\n    /// The returned iterator will never return [`None`] and will also not yield\n    /// the peer's [`SocketAddr`] structure. Iterating over it is equivalent to\n    /// calling [`TcpListener::accept`] in a loop.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    ///\n    /// for stream in listener.incoming() {\n    ///     match stream {\n    ///         Ok(stream) => {\n    ///             println!(\"new client!\");\n    ///         }\n    ///         Err(e) => { /* connection failed */ }\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn incoming(&self) -> Incoming<'_> {\n        Incoming { listener: self }\n    }\n\n    /// Sets the value for the `IP_TTL` option on this socket.\n    ///\n    /// This value sets the time-to-live field that is used in every packet sent\n    /// from this socket.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    /// listener.set_ttl(100).expect(\"could not set TTL\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n        self.0.set_ttl(ttl)\n    }\n\n    /// Gets the value of the `IP_TTL` option for this socket.\n    ///\n    /// For more information about this option, see [`TcpListener::set_ttl`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    /// listener.set_ttl(100).expect(\"could not set TTL\");\n    /// assert_eq!(listener.ttl().unwrap_or(0), 100);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn ttl(&self) -> io::Result<u32> {\n        self.0.ttl()\n    }\n\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    #[rustc_deprecated(\n        since = \"1.16.0\",\n        reason = \"this option can only be set before the socket is bound\"\n    )]\n    #[allow(missing_docs)]\n    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n        self.0.set_only_v6(only_v6)\n    }\n\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    #[rustc_deprecated(\n        since = \"1.16.0\",\n        reason = \"this option can only be set before the socket is bound\"\n    )]\n    #[allow(missing_docs)]\n    pub fn only_v6(&self) -> io::Result<bool> {\n        self.0.only_v6()\n    }\n\n    /// Gets the value of the `SO_ERROR` option on this socket.\n    ///\n    /// This will retrieve the stored error in the underlying socket, clearing\n    /// the field in the process. This can be useful for checking errors between\n    /// calls.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    /// listener.take_error().expect(\"No error was expected\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.0.take_error()\n    }\n\n    /// Moves this TCP stream into or out of nonblocking mode.\n    ///\n    /// This will result in the `accept` operation becoming nonblocking,\n    /// i.e., immediately returning from their calls. If the IO operation is\n    /// successful, `Ok` is returned and no further action is required. If the\n    /// IO operation could not be completed and needs to be retried, an error\n    /// with kind [`io::ErrorKind::WouldBlock`] is returned.\n    ///\n    /// On Unix platforms, calling this method corresponds to calling `fcntl`\n    /// `FIONBIO`. On Windows calling this method corresponds to calling\n    /// `ioctlsocket` `FIONBIO`.\n    ///\n    /// # Examples\n    ///\n    /// Bind a TCP listener to an address, listen for connections, and read\n    /// bytes in nonblocking mode:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    /// listener.set_nonblocking(true).expect(\"Cannot set non-blocking\");\n    ///\n    /// # fn wait_for_fd() { unimplemented!() }\n    /// # fn handle_connection(stream: std::net::TcpStream) { unimplemented!() }\n    /// for stream in listener.incoming() {\n    ///     match stream {\n    ///         Ok(s) => {\n    ///             // do something with the TcpStream\n    ///             handle_connection(s);\n    ///         }\n    ///         Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///             // wait until network socket is ready, typically implemented\n    ///             // via platform-specific APIs such as epoll or IOCP\n    ///             wait_for_fd();\n    ///             continue;\n    ///         }\n    ///         Err(e) => panic!(\"encountered IO error: {}\", e),\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        self.0.set_nonblocking(nonblocking)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Incoming<'a> {\n    type Item = io::Result<TcpStream>;\n    fn next(&mut self) -> Option<io::Result<TcpStream>> {\n        Some(self.listener.accept().map(|p| p.0))\n    }\n}\n\nimpl AsInner<net_imp::TcpListener> for TcpListener {\n    fn as_inner(&self) -> &net_imp::TcpListener {\n        &self.0\n    }\n}\n\nimpl FromInner<net_imp::TcpListener> for TcpListener {\n    fn from_inner(inner: net_imp::TcpListener) -> TcpListener {\n        TcpListener(inner)\n    }\n}\n\nimpl IntoInner<net_imp::TcpListener> for TcpListener {\n    fn into_inner(self) -> net_imp::TcpListener {\n        self.0\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for TcpListener {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n"],["2597","//! Constants specific to the `f64` double-precision floating point type.\n//!\n//! *[See also the `f64` primitive type](primitive@f64).*\n//!\n//! Mathematically significant numbers are provided in the `consts` sub-module.\n//!\n//! For the constants defined directly in this module\n//! (as distinct from those defined in the `consts` sub-module),\n//! new code should instead use the associated constants\n//! defined directly on the `f64` type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![allow(missing_docs)]\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(not(test))]\nuse crate::intrinsics;\n#[cfg(not(test))]\nuse crate::sys::cmath;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated, deprecated_in_future)]\npub use core::f64::{\n    consts, DIGITS, EPSILON, INFINITY, MANTISSA_DIGITS, MAX, MAX_10_EXP, MAX_EXP, MIN, MIN_10_EXP,\n    MIN_EXP, MIN_POSITIVE, NAN, NEG_INFINITY, RADIX,\n};\n\n#[cfg(not(test))]\n#[lang = \"f64_runtime\"]\nimpl f64 {\n    /// Returns the largest integer less than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.7_f64;\n    /// let g = 3.0_f64;\n    /// let h = -3.7_f64;\n    ///\n    /// assert_eq!(f.floor(), 3.0);\n    /// assert_eq!(g.floor(), 3.0);\n    /// assert_eq!(h.floor(), -4.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn floor(self) -> f64 {\n        unsafe { intrinsics::floorf64(self) }\n    }\n\n    /// Returns the smallest integer greater than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.01_f64;\n    /// let g = 4.0_f64;\n    ///\n    /// assert_eq!(f.ceil(), 4.0);\n    /// assert_eq!(g.ceil(), 4.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ceil(self) -> f64 {\n        unsafe { intrinsics::ceilf64(self) }\n    }\n\n    /// Returns the nearest integer to a number. Round half-way cases away from\n    /// `0.0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.3_f64;\n    /// let g = -3.3_f64;\n    ///\n    /// assert_eq!(f.round(), 3.0);\n    /// assert_eq!(g.round(), -3.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn round(self) -> f64 {\n        unsafe { intrinsics::roundf64(self) }\n    }\n\n    /// Returns the integer part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.7_f64;\n    /// let g = 3.0_f64;\n    /// let h = -3.7_f64;\n    ///\n    /// assert_eq!(f.trunc(), 3.0);\n    /// assert_eq!(g.trunc(), 3.0);\n    /// assert_eq!(h.trunc(), -3.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn trunc(self) -> f64 {\n        unsafe { intrinsics::truncf64(self) }\n    }\n\n    /// Returns the fractional part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 3.6_f64;\n    /// let y = -3.6_f64;\n    /// let abs_difference_x = (x.fract() - 0.6).abs();\n    /// let abs_difference_y = (y.fract() - (-0.6)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn fract(self) -> f64 {\n        self - self.trunc()\n    }\n\n    /// Computes the absolute value of `self`. Returns `NAN` if the\n    /// number is `NAN`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 3.5_f64;\n    /// let y = -3.5_f64;\n    ///\n    /// let abs_difference_x = (x.abs() - x).abs();\n    /// let abs_difference_y = (y.abs() - (-y)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    ///\n    /// assert!(f64::NAN.abs().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn abs(self) -> f64 {\n        unsafe { intrinsics::fabsf64(self) }\n    }\n\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n    /// - `NAN` if the number is `NAN`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.5_f64;\n    ///\n    /// assert_eq!(f.signum(), 1.0);\n    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n    ///\n    /// assert!(f64::NAN.signum().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn signum(self) -> f64 {\n        if self.is_nan() { Self::NAN } else { 1.0_f64.copysign(self) }\n    }\n\n    /// Returns a number composed of the magnitude of `self` and the sign of\n    /// `sign`.\n    ///\n    /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n    /// `sign` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.5_f64;\n    ///\n    /// assert_eq!(f.copysign(0.42), 3.5_f64);\n    /// assert_eq!(f.copysign(-0.42), -3.5_f64);\n    /// assert_eq!((-f).copysign(0.42), 3.5_f64);\n    /// assert_eq!((-f).copysign(-0.42), -3.5_f64);\n    ///\n    /// assert!(f64::NAN.copysign(1.0).is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"copysign\", since = \"1.35.0\")]\n    #[inline]\n    pub fn copysign(self, sign: f64) -> f64 {\n        unsafe { intrinsics::copysignf64(self, sign) }\n    }\n\n    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n    /// error, yielding a more accurate result than an unfused multiply-add.\n    ///\n    /// Using `mul_add` *may* be more performant than an unfused multiply-add if\n    /// the target architecture has a dedicated `fma` CPU instruction. However,\n    /// this is not always true, and will be heavily dependant on designing\n    /// algorithms with specific target hardware in mind.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let m = 10.0_f64;\n    /// let x = 4.0_f64;\n    /// let b = 60.0_f64;\n    ///\n    /// // 100.0\n    /// let abs_difference = (m.mul_add(x, b) - ((m * x) + b)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn mul_add(self, a: f64, b: f64) -> f64 {\n        unsafe { intrinsics::fmaf64(self, a, b) }\n    }\n\n    /// Calculates Euclidean division, the matching method for `rem_euclid`.\n    ///\n    /// This computes the integer `n` such that\n    /// `self = n * rhs + self.rem_euclid(rhs)`.\n    /// In other words, the result is `self / rhs` rounded to the integer `n`\n    /// such that `self >= n * rhs`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a: f64 = 7.0;\n    /// let b = 4.0;\n    /// assert_eq!(a.div_euclid(b), 1.0); // 7.0 > 4.0 * 1.0\n    /// assert_eq!((-a).div_euclid(b), -2.0); // -7.0 >= 4.0 * -2.0\n    /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n    /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[inline]\n    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n    pub fn div_euclid(self, rhs: f64) -> f64 {\n        let q = (self / rhs).trunc();\n        if self % rhs < 0.0 {\n            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 };\n        }\n        q\n    }\n\n    /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n    ///\n    /// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in\n    /// most cases. However, due to a floating point round-off error it can\n    /// result in `r == rhs.abs()`, violating the mathematical definition, if\n    /// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.\n    /// This result is not an element of the function's codomain, but it is the\n    /// closest floating point number in the real numbers and thus fulfills the\n    /// property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`\n    /// approximatively.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a: f64 = 7.0;\n    /// let b = 4.0;\n    /// assert_eq!(a.rem_euclid(b), 3.0);\n    /// assert_eq!((-a).rem_euclid(b), 1.0);\n    /// assert_eq!(a.rem_euclid(-b), 3.0);\n    /// assert_eq!((-a).rem_euclid(-b), 1.0);\n    /// // limitation due to round-off error\n    /// assert!((-f64::EPSILON).rem_euclid(3.0) != 0.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[inline]\n    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n    pub fn rem_euclid(self, rhs: f64) -> f64 {\n        let r = self % rhs;\n        if r < 0.0 { r + rhs.abs() } else { r }\n    }\n\n    /// Raises a number to an integer power.\n    ///\n    /// Using this function is generally faster than using `powf`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let abs_difference = (x.powi(2) - (x * x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn powi(self, n: i32) -> f64 {\n        unsafe { intrinsics::powif64(self, n) }\n    }\n\n    /// Raises a number to a floating point power.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let abs_difference = (x.powf(2.0) - (x * x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn powf(self, n: f64) -> f64 {\n        unsafe { intrinsics::powf64(self, n) }\n    }\n\n    /// Returns the square root of a number.\n    ///\n    /// Returns NaN if `self` is a negative number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let positive = 4.0_f64;\n    /// let negative = -4.0_f64;\n    ///\n    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// assert!(negative.sqrt().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sqrt(self) -> f64 {\n        unsafe { intrinsics::sqrtf64(self) }\n    }\n\n    /// Returns `e^(self)`, (the exponential function).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let one = 1.0_f64;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp(self) -> f64 {\n        unsafe { intrinsics::expf64(self) }\n    }\n\n    /// Returns `2^(self)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 2.0_f64;\n    ///\n    /// // 2^2 - 4 == 0\n    /// let abs_difference = (f.exp2() - 4.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp2(self) -> f64 {\n        unsafe { intrinsics::exp2f64(self) }\n    }\n\n    /// Returns the natural logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let one = 1.0_f64;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ln(self) -> f64 {\n        self.log_wrapper(|n| unsafe { intrinsics::logf64(n) })\n    }\n\n    /// Returns the logarithm of the number with respect to an arbitrary base.\n    ///\n    /// The result may not be correctly rounded owing to implementation details;\n    /// `self.log2()` can produce more accurate results for base 2, and\n    /// `self.log10()` can produce more accurate results for base 10.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let twenty_five = 25.0_f64;\n    ///\n    /// // log5(25) - 2 == 0\n    /// let abs_difference = (twenty_five.log(5.0) - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log(self, base: f64) -> f64 {\n        self.ln() / base.ln()\n    }\n\n    /// Returns the base 2 logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let four = 4.0_f64;\n    ///\n    /// // log2(4) - 2 == 0\n    /// let abs_difference = (four.log2() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log2(self) -> f64 {\n        self.log_wrapper(|n| {\n            #[cfg(target_os = \"android\")]\n            return crate::sys::android::log2f64(n);\n            #[cfg(not(target_os = \"android\"))]\n            return unsafe { intrinsics::log2f64(n) };\n        })\n    }\n\n    /// Returns the base 10 logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let hundred = 100.0_f64;\n    ///\n    /// // log10(100) - 2 == 0\n    /// let abs_difference = (hundred.log10() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log10(self) -> f64 {\n        self.log_wrapper(|n| unsafe { intrinsics::log10f64(n) })\n    }\n\n    /// The positive difference of two numbers.\n    ///\n    /// * If `self <= other`: `0:0`\n    /// * Else: `self - other`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 3.0_f64;\n    /// let y = -3.0_f64;\n    ///\n    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    #[rustc_deprecated(\n        since = \"1.10.0\",\n        reason = \"you probably meant `(self - other).abs()`: \\\n                  this operation is `(self - other).max(0.0)` \\\n                  except that `abs_sub` also propagates NaNs (also \\\n                  known as `fdim` in C). If you truly need the positive \\\n                  difference, consider using that expression or the C function \\\n                  `fdim`, depending on how you wish to handle NaN (please consider \\\n                  filing an issue describing your use-case too).\"\n    )]\n    pub fn abs_sub(self, other: f64) -> f64 {\n        unsafe { cmath::fdim(self, other) }\n    }\n\n    /// Returns the cube root of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 8.0_f64;\n    ///\n    /// // x^(1/3) - 2 == 0\n    /// let abs_difference = (x.cbrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cbrt(self) -> f64 {\n        unsafe { cmath::cbrt(self) }\n    }\n\n    /// Calculates the length of the hypotenuse of a right-angle triangle given\n    /// legs of length `x` and `y`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let y = 3.0_f64;\n    ///\n    /// // sqrt(x^2 + y^2)\n    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn hypot(self, other: f64) -> f64 {\n        unsafe { cmath::hypot(self, other) }\n    }\n\n    /// Computes the sine of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = std::f64::consts::FRAC_PI_2;\n    ///\n    /// let abs_difference = (x.sin() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sin(self) -> f64 {\n        unsafe { intrinsics::sinf64(self) }\n    }\n\n    /// Computes the cosine of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0 * std::f64::consts::PI;\n    ///\n    /// let abs_difference = (x.cos() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cos(self) -> f64 {\n        unsafe { intrinsics::cosf64(self) }\n    }\n\n    /// Computes the tangent of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = std::f64::consts::FRAC_PI_4;\n    /// let abs_difference = (x.tan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-14);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn tan(self) -> f64 {\n        unsafe { cmath::tan(self) }\n    }\n\n    /// Computes the arcsine of a number. Return value is in radians in\n    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = std::f64::consts::FRAC_PI_2;\n    ///\n    /// // asin(sin(pi/2))\n    /// let abs_difference = (f.sin().asin() - std::f64::consts::FRAC_PI_2).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn asin(self) -> f64 {\n        unsafe { cmath::asin(self) }\n    }\n\n    /// Computes the arccosine of a number. Return value is in radians in\n    /// the range [0, pi] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = std::f64::consts::FRAC_PI_4;\n    ///\n    /// // acos(cos(pi/4))\n    /// let abs_difference = (f.cos().acos() - std::f64::consts::FRAC_PI_4).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn acos(self) -> f64 {\n        unsafe { cmath::acos(self) }\n    }\n\n    /// Computes the arctangent of a number. Return value is in radians in the\n    /// range [-pi/2, pi/2];\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 1.0_f64;\n    ///\n    /// // atan(tan(1))\n    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atan(self) -> f64 {\n        unsafe { cmath::atan(self) }\n    }\n\n    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`) in radians.\n    ///\n    /// * `x = 0`, `y = 0`: `0`\n    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // Positive angles measured counter-clockwise\n    /// // from positive x axis\n    /// // -pi/4 radians (45 deg clockwise)\n    /// let x1 = 3.0_f64;\n    /// let y1 = -3.0_f64;\n    ///\n    /// // 3pi/4 radians (135 deg counter-clockwise)\n    /// let x2 = -3.0_f64;\n    /// let y2 = 3.0_f64;\n    ///\n    /// let abs_difference_1 = (y1.atan2(x1) - (-std::f64::consts::FRAC_PI_4)).abs();\n    /// let abs_difference_2 = (y2.atan2(x2) - (3.0 * std::f64::consts::FRAC_PI_4)).abs();\n    ///\n    /// assert!(abs_difference_1 < 1e-10);\n    /// assert!(abs_difference_2 < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atan2(self, other: f64) -> f64 {\n        unsafe { cmath::atan2(self, other) }\n    }\n\n    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n    /// `(sin(x), cos(x))`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = std::f64::consts::FRAC_PI_4;\n    /// let f = x.sin_cos();\n    ///\n    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n    ///\n    /// assert!(abs_difference_0 < 1e-10);\n    /// assert!(abs_difference_1 < 1e-10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sin_cos(self) -> (f64, f64) {\n        (self.sin(), self.cos())\n    }\n\n    /// Returns `e^(self) - 1` in a way that is accurate even if the\n    /// number is close to zero.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1e-16_f64;\n    ///\n    /// // for very small x, e^x is approximately 1 + x + x^2 / 2\n    /// let approx = x + x * x / 2.0;\n    /// let abs_difference = (x.exp_m1() - approx).abs();\n    ///\n    /// assert!(abs_difference < 1e-20);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp_m1(self) -> f64 {\n        unsafe { cmath::expm1(self) }\n    }\n\n    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n    /// the operations were performed separately.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1e-16_f64;\n    ///\n    /// // for very small x, ln(1 + x) is approximately x - x^2 / 2\n    /// let approx = x - x * x / 2.0;\n    /// let abs_difference = (x.ln_1p() - approx).abs();\n    ///\n    /// assert!(abs_difference < 1e-20);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ln_1p(self) -> f64 {\n        unsafe { cmath::log1p(self) }\n    }\n\n    /// Hyperbolic sine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let e = std::f64::consts::E;\n    /// let x = 1.0_f64;\n    ///\n    /// let f = x.sinh();\n    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n    /// let g = ((e * e) - 1.0) / (2.0 * e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sinh(self) -> f64 {\n        unsafe { cmath::sinh(self) }\n    }\n\n    /// Hyperbolic cosine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let e = std::f64::consts::E;\n    /// let x = 1.0_f64;\n    /// let f = x.cosh();\n    /// // Solving cosh() at 1 gives this result\n    /// let g = ((e * e) + 1.0) / (2.0 * e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// // Same result\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cosh(self) -> f64 {\n        unsafe { cmath::cosh(self) }\n    }\n\n    /// Hyperbolic tangent function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let e = std::f64::consts::E;\n    /// let x = 1.0_f64;\n    ///\n    /// let f = x.tanh();\n    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n    /// let g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn tanh(self) -> f64 {\n        unsafe { cmath::tanh(self) }\n    }\n\n    /// Inverse hyperbolic sine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let f = x.sinh().asinh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn asinh(self) -> f64 {\n        (self.abs() + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n    }\n\n    /// Inverse hyperbolic cosine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let f = x.cosh().acosh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn acosh(self) -> f64 {\n        if self < 1.0 { Self::NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n    }\n\n    /// Inverse hyperbolic tangent function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let e = std::f64::consts::E;\n    /// let f = e.tanh().atanh();\n    ///\n    /// let abs_difference = (f - e).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atanh(self) -> f64 {\n        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n    }\n\n    /// Linear interpolation between `start` and `end`.\n    ///\n    /// This enables linear interpolation between `start` and `end`, where start is represented by\n    /// `self == 0.0` and `end` is represented by `self == 1.0`. This is the basis of all\n    /// \"transition\", \"easing\", or \"step\" functions; if you change `self` from 0.0 to 1.0\n    /// at a given rate, the result will change from `start` to `end` at a similar rate.\n    ///\n    /// Values below 0.0 or above 1.0 are allowed, allowing you to extrapolate values outside the\n    /// range from `start` to `end`. This also is useful for transition functions which might\n    /// move slightly past the end or start for a desired effect. Mathematically, the values\n    /// returned are equivalent to `start + self * (end - start)`, although we make a few specific\n    /// guarantees that are useful specifically to linear interpolation.\n    ///\n    /// These guarantees are:\n    ///\n    /// * If `start` and `end` are [finite], the value at 0.0 is always `start` and the\n    ///   value at 1.0 is always `end`. (exactness)\n    /// * If `start` and `end` are [finite], the values will always move in the direction from\n    ///   `start` to `end` (monotonicity)\n    /// * If `self` is [finite] and `start == end`, the value at any point will always be\n    ///   `start == end`. (consistency)\n    ///\n    /// [finite]: #method.is_finite\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[unstable(feature = \"float_interpolation\", issue = \"86269\")]\n    pub fn lerp(self, start: f64, end: f64) -> f64 {\n        // consistent\n        if start == end {\n            start\n\n        // exact/monotonic\n        } else {\n            self.mul_add(end, (-self).mul_add(start, start))\n        }\n    }\n\n    // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n    // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n    // of expected NaN).\n    fn log_wrapper<F: Fn(f64) -> f64>(self, log_fn: F) -> f64 {\n        if !cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n            log_fn(self)\n        } else if self.is_finite() {\n            if self > 0.0 {\n                log_fn(self)\n            } else if self == 0.0 {\n                Self::NEG_INFINITY // log(0) = -Inf\n            } else {\n                Self::NAN // log(-n) = NaN\n            }\n        } else if self.is_nan() {\n            self // log(NaN) = NaN\n        } else if self > 0.0 {\n            self // log(Inf) = Inf\n        } else {\n            Self::NAN // log(-Inf) = NaN\n        }\n    }\n}\n"],["2598","use super::*;\n\nuse crate::rc::Rc;\nuse crate::sync::Arc;\n\nmacro_rules! t(\n    ($path:expr, iter: $iter:expr) => (\n        {\n            let path = Path::new($path);\n\n            // Forward iteration\n            let comps = path.iter()\n                .map(|p| p.to_string_lossy().into_owned())\n                .collect::<Vec<String>>();\n            let exp: &[&str] = &$iter;\n            let exps = exp.iter().map(|s| s.to_string()).collect::<Vec<String>>();\n            assert!(comps == exps, \"iter: Expected {:?}, found {:?}\",\n                    exps, comps);\n\n            // Reverse iteration\n            let comps = Path::new($path).iter().rev()\n                .map(|p| p.to_string_lossy().into_owned())\n                .collect::<Vec<String>>();\n            let exps = exps.into_iter().rev().collect::<Vec<String>>();\n            assert!(comps == exps, \"iter().rev(): Expected {:?}, found {:?}\",\n                    exps, comps);\n        }\n    );\n\n    ($path:expr, has_root: $has_root:expr, is_absolute: $is_absolute:expr) => (\n        {\n            let path = Path::new($path);\n\n            let act_root = path.has_root();\n            assert!(act_root == $has_root, \"has_root: Expected {:?}, found {:?}\",\n                    $has_root, act_root);\n\n            let act_abs = path.is_absolute();\n            assert!(act_abs == $is_absolute, \"is_absolute: Expected {:?}, found {:?}\",\n                    $is_absolute, act_abs);\n        }\n    );\n\n    ($path:expr, parent: $parent:expr, file_name: $file:expr) => (\n        {\n            let path = Path::new($path);\n\n            let parent = path.parent().map(|p| p.to_str().unwrap());\n            let exp_parent: Option<&str> = $parent;\n            assert!(parent == exp_parent, \"parent: Expected {:?}, found {:?}\",\n                    exp_parent, parent);\n\n            let file = path.file_name().map(|p| p.to_str().unwrap());\n            let exp_file: Option<&str> = $file;\n            assert!(file == exp_file, \"file_name: Expected {:?}, found {:?}\",\n                    exp_file, file);\n        }\n    );\n\n    ($path:expr, file_stem: $file_stem:expr, extension: $extension:expr) => (\n        {\n            let path = Path::new($path);\n\n            let stem = path.file_stem().map(|p| p.to_str().unwrap());\n            let exp_stem: Option<&str> = $file_stem;\n            assert!(stem == exp_stem, \"file_stem: Expected {:?}, found {:?}\",\n                    exp_stem, stem);\n\n            let ext = path.extension().map(|p| p.to_str().unwrap());\n            let exp_ext: Option<&str> = $extension;\n            assert!(ext == exp_ext, \"extension: Expected {:?}, found {:?}\",\n                    exp_ext, ext);\n        }\n    );\n\n    ($path:expr, iter: $iter:expr,\n                 has_root: $has_root:expr, is_absolute: $is_absolute:expr,\n                 parent: $parent:expr, file_name: $file:expr,\n                 file_stem: $file_stem:expr, extension: $extension:expr) => (\n        {\n            t!($path, iter: $iter);\n            t!($path, has_root: $has_root, is_absolute: $is_absolute);\n            t!($path, parent: $parent, file_name: $file);\n            t!($path, file_stem: $file_stem, extension: $extension);\n        }\n    );\n);\n\n#[test]\nfn into() {\n    use crate::borrow::Cow;\n\n    let static_path = Path::new(\"/home/foo\");\n    let static_cow_path: Cow<'static, Path> = static_path.into();\n    let pathbuf = PathBuf::from(\"/home/foo\");\n\n    {\n        let path: &Path = &pathbuf;\n        let borrowed_cow_path: Cow<'_, Path> = path.into();\n\n        assert_eq!(static_cow_path, borrowed_cow_path);\n    }\n\n    let owned_cow_path: Cow<'static, Path> = pathbuf.into();\n\n    assert_eq!(static_cow_path, owned_cow_path);\n}\n\n#[test]\n#[cfg(unix)]\npub fn test_decompositions_unix() {\n    t!(\"\",\n    iter: [],\n    has_root: false,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"/\",\n    iter: [\"/\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"/foo\",\n    iter: [\"/\", \"foo\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"/foo/\",\n    iter: [\"/\", \"foo\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/bar\",\n    iter: [\"foo\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"/foo/bar\",\n    iter: [\"/\", \"foo\", \"bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"///foo///\",\n    iter: [\"/\", \"foo\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"///foo///bar\",\n    iter: [\"/\", \"foo\", \"bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"///foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"./.\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"/..\",\n    iter: [\"/\", \"..\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"../\",\n    iter: [\"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/.\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/..\",\n    iter: [\"foo\", \"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/./\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/./bar\",\n    iter: [\"foo\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"foo/../\",\n    iter: [\"foo\", \"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/../bar\",\n    iter: [\"foo\", \"..\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo/..\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"./a\",\n    iter: [\".\", \"a\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\".\"),\n    file_name: Some(\"a\"),\n    file_stem: Some(\"a\"),\n    extension: None\n    );\n\n    t!(\".\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"./\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"a/b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a//b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a/./b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a/b/c\",\n    iter: [\"a\", \"b\", \"c\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a/b\"),\n    file_name: Some(\"c\"),\n    file_stem: Some(\"c\"),\n    extension: None\n    );\n\n    t!(\".foo\",\n    iter: [\".foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\".foo\"),\n    file_stem: Some(\".foo\"),\n    extension: None\n    );\n}\n\n#[test]\n#[cfg(windows)]\npub fn test_decompositions_windows() {\n    t!(\"\",\n    iter: [],\n    has_root: false,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"/\",\n    iter: [\"\\\\\"],\n    has_root: true,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\",\n    iter: [\"\\\\\"],\n    has_root: true,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"c:\",\n    iter: [\"c:\"],\n    has_root: false,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"c:\\\\\",\n    iter: [\"c:\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"c:/\",\n    iter: [\"c:\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"/foo\",\n    iter: [\"\\\\\", \"foo\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"/foo/\",\n    iter: [\"\\\\\", \"foo\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/bar\",\n    iter: [\"foo\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"/foo/bar\",\n    iter: [\"\\\\\", \"foo\", \"bar\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"///foo///\",\n    iter: [\"\\\\\", \"foo\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"///foo///bar\",\n    iter: [\"\\\\\", \"foo\", \"bar\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"///foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"./.\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"/..\",\n    iter: [\"\\\\\", \"..\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"../\",\n    iter: [\"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/.\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/..\",\n    iter: [\"foo\", \"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/./\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/./bar\",\n    iter: [\"foo\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"foo/../\",\n    iter: [\"foo\", \"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/../bar\",\n    iter: [\"foo\", \"..\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo/..\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"./a\",\n    iter: [\".\", \"a\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\".\"),\n    file_name: Some(\"a\"),\n    file_stem: Some(\"a\"),\n    extension: None\n    );\n\n    t!(\".\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"./\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"a/b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a//b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a/./b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a/b/c\",\n       iter: [\"a\", \"b\", \"c\"],\n       has_root: false,\n       is_absolute: false,\n       parent: Some(\"a/b\"),\n       file_name: Some(\"c\"),\n       file_stem: Some(\"c\"),\n       extension: None);\n\n    t!(\"a\\\\b\\\\c\",\n    iter: [\"a\", \"b\", \"c\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\\\\b\"),\n    file_name: Some(\"c\"),\n    file_stem: Some(\"c\"),\n    extension: None\n    );\n\n    t!(\"\\\\a\",\n    iter: [\"\\\\\", \"a\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"\\\\\"),\n    file_name: Some(\"a\"),\n    file_stem: Some(\"a\"),\n    extension: None\n    );\n\n    t!(\"c:\\\\foo.txt\",\n    iter: [\"c:\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"c:\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\server\\\\share\\\\foo.txt\",\n    iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\server\\\\share\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\server\\\\share\",\n    iter: [\"\\\\\\\\server\\\\share\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\server\",\n    iter: [\"\\\\\", \"server\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"\\\\\"),\n    file_name: Some(\"server\"),\n    file_stem: Some(\"server\"),\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\bar\\\\foo.txt\",\n    iter: [\"\\\\\\\\?\\\\bar\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\?\\\\bar\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\?\\\\bar\",\n    iter: [\"\\\\\\\\?\\\\bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\\",\n    iter: [\"\\\\\\\\?\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\",\n    iter: [\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\?\\\\UNC\\\\server\",\n    iter: [\"\\\\\\\\?\\\\UNC\\\\server\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\UNC\\\\\",\n    iter: [\"\\\\\\\\?\\\\UNC\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\C:\\\\foo.txt\",\n    iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\?\\\\C:\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\?\\\\C:\\\\\",\n    iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\C:\",\n    iter: [\"\\\\\\\\?\\\\C:\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\foo/bar\",\n    iter: [\"\\\\\\\\?\\\\foo/bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\C:/foo\",\n    iter: [\"\\\\\\\\?\\\\C:/foo\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\foo\\\\bar\",\n    iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\.\\\\foo\\\\\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\foo\",\n    iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\foo/bar\",\n    iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\.\\\\foo/\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\foo\\\\bar/baz\",\n    iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\", \"baz\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\.\\\\foo\\\\bar\"),\n    file_name: Some(\"baz\"),\n    file_stem: Some(\"baz\"),\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\\",\n    iter: [\"\\\\\\\\.\\\\\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\a\\\\b\\\\\",\n    iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\?\\\\a\\\\\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n}\n\n#[test]\npub fn test_stem_ext() {\n    t!(\"foo\",\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo.\",\n    file_stem: Some(\"foo\"),\n    extension: Some(\"\")\n    );\n\n    t!(\".foo\",\n    file_stem: Some(\".foo\"),\n    extension: None\n    );\n\n    t!(\"foo.txt\",\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"foo.bar.txt\",\n    file_stem: Some(\"foo.bar\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"foo.bar.\",\n    file_stem: Some(\"foo.bar\"),\n    extension: Some(\"\")\n    );\n\n    t!(\".\", file_stem: None, extension: None);\n\n    t!(\"..\", file_stem: None, extension: None);\n\n    t!(\"\", file_stem: None, extension: None);\n}\n\n#[test]\npub fn test_push() {\n    macro_rules! tp(\n        ($path:expr, $push:expr, $expected:expr) => ( {\n            let mut actual = PathBuf::from($path);\n            actual.push($push);\n            assert!(actual.to_str() == Some($expected),\n                    \"pushing {:?} onto {:?}: Expected {:?}, got {:?}\",\n                    $push, $path, $expected, actual.to_str().unwrap());\n        });\n    );\n\n    if cfg!(unix) || cfg!(all(target_env = \"sgx\", target_vendor = \"fortanix\")) {\n        tp!(\"\", \"foo\", \"foo\");\n        tp!(\"foo\", \"bar\", \"foo/bar\");\n        tp!(\"foo/\", \"bar\", \"foo/bar\");\n        tp!(\"foo//\", \"bar\", \"foo//bar\");\n        tp!(\"foo/.\", \"bar\", \"foo/./bar\");\n        tp!(\"foo./.\", \"bar\", \"foo././bar\");\n        tp!(\"foo\", \"\", \"foo/\");\n        tp!(\"foo\", \".\", \"foo/.\");\n        tp!(\"foo\", \"..\", \"foo/..\");\n        tp!(\"foo\", \"/\", \"/\");\n        tp!(\"/foo/bar\", \"/\", \"/\");\n        tp!(\"/foo/bar\", \"/baz\", \"/baz\");\n        tp!(\"/foo/bar\", \"./baz\", \"/foo/bar/./baz\");\n    } else {\n        tp!(\"\", \"foo\", \"foo\");\n        tp!(\"foo\", \"bar\", r\"foo\\bar\");\n        tp!(\"foo/\", \"bar\", r\"foo/bar\");\n        tp!(r\"foo\\\", \"bar\", r\"foo\\bar\");\n        tp!(\"foo//\", \"bar\", r\"foo//bar\");\n        tp!(r\"foo\\\\\", \"bar\", r\"foo\\\\bar\");\n        tp!(\"foo/.\", \"bar\", r\"foo/.\\bar\");\n        tp!(\"foo./.\", \"bar\", r\"foo./.\\bar\");\n        tp!(r\"foo\\.\", \"bar\", r\"foo\\.\\bar\");\n        tp!(r\"foo.\\.\", \"bar\", r\"foo.\\.\\bar\");\n        tp!(\"foo\", \"\", \"foo\\\\\");\n        tp!(\"foo\", \".\", r\"foo\\.\");\n        tp!(\"foo\", \"..\", r\"foo\\..\");\n        tp!(\"foo\", \"/\", \"/\");\n        tp!(\"foo\", r\"\\\", r\"\\\");\n        tp!(\"/foo/bar\", \"/\", \"/\");\n        tp!(r\"\\foo\\bar\", r\"\\\", r\"\\\");\n        tp!(\"/foo/bar\", \"/baz\", \"/baz\");\n        tp!(\"/foo/bar\", r\"\\baz\", r\"\\baz\");\n        tp!(\"/foo/bar\", \"./baz\", r\"/foo/bar\\./baz\");\n        tp!(\"/foo/bar\", r\".\\baz\", r\"/foo/bar\\.\\baz\");\n\n        tp!(\"c:\\\\\", \"windows\", \"c:\\\\windows\");\n        tp!(\"c:\", \"windows\", \"c:windows\");\n\n        tp!(\"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n        tp!(\"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n        tp!(\"a\\\\b\", \"c\\\\d\", \"a\\\\b\\\\c\\\\d\");\n        tp!(\"a\\\\b\", \"\\\\c\\\\d\", \"\\\\c\\\\d\");\n        tp!(\"a\\\\b\", \".\", \"a\\\\b\\\\.\");\n        tp!(\"a\\\\b\", \"..\\\\c\", \"a\\\\b\\\\..\\\\c\");\n        tp!(\"a\\\\b\", \"C:a.txt\", \"C:a.txt\");\n        tp!(\"a\\\\b\", \"C:\\\\a.txt\", \"C:\\\\a.txt\");\n        tp!(\"C:\\\\a\", \"C:\\\\b.txt\", \"C:\\\\b.txt\");\n        tp!(\"C:\\\\a\\\\b\\\\c\", \"C:d\", \"C:d\");\n        tp!(\"C:a\\\\b\\\\c\", \"C:d\", \"C:d\");\n        tp!(\"C:\", r\"a\\b\\c\", r\"C:a\\b\\c\");\n        tp!(\"C:\", r\"..\\a\", r\"C:..\\a\");\n        tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n        tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"C:baz\", \"C:baz\");\n        tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n        tp!(\"\\\\\\\\?\\\\C:a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n        tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", \"C:\\\\c\\\\d\");\n        tp!(\"\\\\\\\\?\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\");\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:\\\\a\", \"C:\\\\a\");\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:a\", \"C:a\");\n\n        // Note: modified from old path API\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\", \"foo\", \"\\\\\\\\?\\\\UNC\\\\server\\\\foo\");\n\n        tp!(\"C:\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n        tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\");\n        tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"C:a\", \"C:a\");\n        // again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim\n        tp!(\"\\\\\\\\.\\\\foo\", \"..\\\\bar\", \"\\\\\\\\.\\\\foo\\\\..\\\\bar\");\n\n        tp!(\"\\\\\\\\?\\\\C:\", \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\"); // this is a weird one\n    }\n}\n\n#[test]\npub fn test_pop() {\n    macro_rules! tp(\n        ($path:expr, $expected:expr, $output:expr) => ( {\n            let mut actual = PathBuf::from($path);\n            let output = actual.pop();\n            assert!(actual.to_str() == Some($expected) && output == $output,\n                    \"popping from {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n                    $path, $expected, $output,\n                    actual.to_str().unwrap(), output);\n        });\n    );\n\n    tp!(\"\", \"\", false);\n    tp!(\"/\", \"/\", false);\n    tp!(\"foo\", \"\", true);\n    tp!(\".\", \"\", true);\n    tp!(\"/foo\", \"/\", true);\n    tp!(\"/foo/bar\", \"/foo\", true);\n    tp!(\"foo/bar\", \"foo\", true);\n    tp!(\"foo/.\", \"\", true);\n    tp!(\"foo//bar\", \"foo\", true);\n\n    if cfg!(windows) {\n        tp!(\"a\\\\b\\\\c\", \"a\\\\b\", true);\n        tp!(\"\\\\a\", \"\\\\\", true);\n        tp!(\"\\\\\", \"\\\\\", false);\n\n        tp!(\"C:\\\\a\\\\b\", \"C:\\\\a\", true);\n        tp!(\"C:\\\\a\", \"C:\\\\\", true);\n        tp!(\"C:\\\\\", \"C:\\\\\", false);\n        tp!(\"C:a\\\\b\", \"C:a\", true);\n        tp!(\"C:a\", \"C:\", true);\n        tp!(\"C:\", \"C:\", false);\n        tp!(\"\\\\\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\server\\\\share\\\\a\", true);\n        tp!(\"\\\\\\\\server\\\\share\\\\a\", \"\\\\\\\\server\\\\share\\\\\", true);\n        tp!(\"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\", false);\n        tp!(\"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", true);\n        tp!(\"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\\", true);\n        tp!(\"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\a\", false);\n        tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", true);\n        tp!(\"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", true);\n        tp!(\"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", false);\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", true);\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\", true);\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", false);\n        tp!(\"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", true);\n        tp!(\"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\\\\\", true);\n        tp!(\"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n\n        tp!(\"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\\\\\", true);\n    }\n}\n\n#[test]\npub fn test_set_file_name() {\n    macro_rules! tfn(\n            ($path:expr, $file:expr, $expected:expr) => ( {\n            let mut p = PathBuf::from($path);\n            p.set_file_name($file);\n            assert!(p.to_str() == Some($expected),\n                    \"setting file name of {:?} to {:?}: Expected {:?}, got {:?}\",\n                    $path, $file, $expected,\n                    p.to_str().unwrap());\n        });\n    );\n\n    tfn!(\"foo\", \"foo\", \"foo\");\n    tfn!(\"foo\", \"bar\", \"bar\");\n    tfn!(\"foo\", \"\", \"\");\n    tfn!(\"\", \"foo\", \"foo\");\n    if cfg!(unix) || cfg!(all(target_env = \"sgx\", target_vendor = \"fortanix\")) {\n        tfn!(\".\", \"foo\", \"./foo\");\n        tfn!(\"foo/\", \"bar\", \"bar\");\n        tfn!(\"foo/.\", \"bar\", \"bar\");\n        tfn!(\"..\", \"foo\", \"../foo\");\n        tfn!(\"foo/..\", \"bar\", \"foo/../bar\");\n        tfn!(\"/\", \"foo\", \"/foo\");\n    } else {\n        tfn!(\".\", \"foo\", r\".\\foo\");\n        tfn!(r\"foo\\\", \"bar\", r\"bar\");\n        tfn!(r\"foo\\.\", \"bar\", r\"bar\");\n        tfn!(\"..\", \"foo\", r\"..\\foo\");\n        tfn!(r\"foo\\..\", \"bar\", r\"foo\\..\\bar\");\n        tfn!(r\"\\\", \"foo\", r\"\\foo\");\n    }\n}\n\n#[test]\npub fn test_set_extension() {\n    macro_rules! tfe(\n            ($path:expr, $ext:expr, $expected:expr, $output:expr) => ( {\n            let mut p = PathBuf::from($path);\n            let output = p.set_extension($ext);\n            assert!(p.to_str() == Some($expected) && output == $output,\n                    \"setting extension of {:?} to {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n                    $path, $ext, $expected, $output,\n                    p.to_str().unwrap(), output);\n        });\n    );\n\n    tfe!(\"foo\", \"txt\", \"foo.txt\", true);\n    tfe!(\"foo.bar\", \"txt\", \"foo.txt\", true);\n    tfe!(\"foo.bar.baz\", \"txt\", \"foo.bar.txt\", true);\n    tfe!(\".test\", \"txt\", \".test.txt\", true);\n    tfe!(\"foo.txt\", \"\", \"foo\", true);\n    tfe!(\"foo\", \"\", \"foo\", true);\n    tfe!(\"\", \"foo\", \"\", false);\n    tfe!(\".\", \"foo\", \".\", false);\n    tfe!(\"foo/\", \"bar\", \"foo.bar\", true);\n    tfe!(\"foo/.\", \"bar\", \"foo.bar\", true);\n    tfe!(\"..\", \"foo\", \"..\", false);\n    tfe!(\"foo/..\", \"bar\", \"foo/..\", false);\n    tfe!(\"/\", \"foo\", \"/\", false);\n}\n\n#[test]\nfn test_eq_receivers() {\n    use crate::borrow::Cow;\n\n    let borrowed: &Path = Path::new(\"foo/bar\");\n    let mut owned: PathBuf = PathBuf::new();\n    owned.push(\"foo\");\n    owned.push(\"bar\");\n    let borrowed_cow: Cow<'_, Path> = borrowed.into();\n    let owned_cow: Cow<'_, Path> = owned.clone().into();\n\n    macro_rules! t {\n        ($($current:expr),+) => {\n            $(\n                assert_eq!($current, borrowed);\n                assert_eq!($current, owned);\n                assert_eq!($current, borrowed_cow);\n                assert_eq!($current, owned_cow);\n            )+\n        }\n    }\n\n    t!(borrowed, owned, borrowed_cow, owned_cow);\n}\n\n#[test]\npub fn test_compare() {\n    use crate::collections::hash_map::DefaultHasher;\n    use crate::hash::{Hash, Hasher};\n\n    fn hash<T: Hash>(t: T) -> u64 {\n        let mut s = DefaultHasher::new();\n        t.hash(&mut s);\n        s.finish()\n    }\n\n    macro_rules! tc(\n        ($path1:expr, $path2:expr, eq: $eq:expr,\n         starts_with: $starts_with:expr, ends_with: $ends_with:expr,\n         relative_from: $relative_from:expr) => ({\n             let path1 = Path::new($path1);\n             let path2 = Path::new($path2);\n\n             let eq = path1 == path2;\n             assert!(eq == $eq, \"{:?} == {:?}, expected {:?}, got {:?}\",\n                     $path1, $path2, $eq, eq);\n             assert!($eq == (hash(path1) == hash(path2)),\n                     \"{:?} == {:?}, expected {:?}, got {} and {}\",\n                     $path1, $path2, $eq, hash(path1), hash(path2));\n\n             let starts_with = path1.starts_with(path2);\n             assert!(starts_with == $starts_with,\n                     \"{:?}.starts_with({:?}), expected {:?}, got {:?}\", $path1, $path2,\n                     $starts_with, starts_with);\n\n             let ends_with = path1.ends_with(path2);\n             assert!(ends_with == $ends_with,\n                     \"{:?}.ends_with({:?}), expected {:?}, got {:?}\", $path1, $path2,\n                     $ends_with, ends_with);\n\n             let relative_from = path1.strip_prefix(path2)\n                                      .map(|p| p.to_str().unwrap())\n                                      .ok();\n             let exp: Option<&str> = $relative_from;\n             assert!(relative_from == exp,\n                     \"{:?}.strip_prefix({:?}), expected {:?}, got {:?}\",\n                     $path1, $path2, exp, relative_from);\n        });\n    );\n\n    tc!(\"\", \"\",\n    eq: true,\n    starts_with: true,\n    ends_with: true,\n    relative_from: Some(\"\")\n    );\n\n    tc!(\"foo\", \"\",\n    eq: false,\n    starts_with: true,\n    ends_with: true,\n    relative_from: Some(\"foo\")\n    );\n\n    tc!(\"\", \"foo\",\n    eq: false,\n    starts_with: false,\n    ends_with: false,\n    relative_from: None\n    );\n\n    tc!(\"foo\", \"foo\",\n    eq: true,\n    starts_with: true,\n    ends_with: true,\n    relative_from: Some(\"\")\n    );\n\n    tc!(\"foo/\", \"foo\",\n    eq: true,\n    starts_with: true,\n    ends_with: true,\n    relative_from: Some(\"\")\n    );\n\n    tc!(\"foo/bar\", \"foo\",\n    eq: false,\n    starts_with: true,\n    ends_with: false,\n    relative_from: Some(\"bar\")\n    );\n\n    tc!(\"foo/bar/baz\", \"foo/bar\",\n    eq: false,\n    starts_with: true,\n    ends_with: false,\n    relative_from: Some(\"baz\")\n    );\n\n    tc!(\"foo/bar\", \"foo/bar/baz\",\n    eq: false,\n    starts_with: false,\n    ends_with: false,\n    relative_from: None\n    );\n\n    tc!(\"./foo/bar/\", \".\",\n    eq: false,\n    starts_with: true,\n    ends_with: false,\n    relative_from: Some(\"foo/bar\")\n    );\n\n    if cfg!(windows) {\n        tc!(r\"C:\\src\\rust\\cargo-test\\test\\Cargo.toml\",\n        r\"c:\\src\\rust\\cargo-test\\test\",\n        eq: false,\n        starts_with: true,\n        ends_with: false,\n        relative_from: Some(\"Cargo.toml\")\n        );\n\n        tc!(r\"c:\\foo\", r\"C:\\foo\",\n        eq: true,\n        starts_with: true,\n        ends_with: true,\n        relative_from: Some(\"\")\n        );\n    }\n}\n\n#[test]\nfn test_components_debug() {\n    let path = Path::new(\"/tmp\");\n\n    let mut components = path.components();\n\n    let expected = \"Components([RootDir, Normal(\\\"tmp\\\")])\";\n    let actual = format!(\"{:?}\", components);\n    assert_eq!(expected, actual);\n\n    let _ = components.next().unwrap();\n    let expected = \"Components([Normal(\\\"tmp\\\")])\";\n    let actual = format!(\"{:?}\", components);\n    assert_eq!(expected, actual);\n\n    let _ = components.next().unwrap();\n    let expected = \"Components([])\";\n    let actual = format!(\"{:?}\", components);\n    assert_eq!(expected, actual);\n}\n\n#[cfg(unix)]\n#[test]\nfn test_iter_debug() {\n    let path = Path::new(\"/tmp\");\n\n    let mut iter = path.iter();\n\n    let expected = \"Iter([\\\"/\\\", \\\"tmp\\\"])\";\n    let actual = format!(\"{:?}\", iter);\n    assert_eq!(expected, actual);\n\n    let _ = iter.next().unwrap();\n    let expected = \"Iter([\\\"tmp\\\"])\";\n    let actual = format!(\"{:?}\", iter);\n    assert_eq!(expected, actual);\n\n    let _ = iter.next().unwrap();\n    let expected = \"Iter([])\";\n    let actual = format!(\"{:?}\", iter);\n    assert_eq!(expected, actual);\n}\n\n#[test]\nfn into_boxed() {\n    let orig: &str = \"some/sort/of/path\";\n    let path = Path::new(orig);\n    let boxed: Box<Path> = Box::from(path);\n    let path_buf = path.to_owned().into_boxed_path().into_path_buf();\n    assert_eq!(path, &*boxed);\n    assert_eq!(&*boxed, &*path_buf);\n    assert_eq!(&*path_buf, path);\n}\n\n#[test]\nfn test_clone_into() {\n    let mut path_buf = PathBuf::from(\"supercalifragilisticexpialidocious\");\n    let path = Path::new(\"short\");\n    path.clone_into(&mut path_buf);\n    assert_eq!(path, path_buf);\n    assert!(path_buf.into_os_string().capacity() >= 15);\n}\n\n#[test]\nfn display_format_flags() {\n    assert_eq!(format!(\"a{:#<5}b\", Path::new(\"\").display()), \"a#####b\");\n    assert_eq!(format!(\"a{:#<5}b\", Path::new(\"a\").display()), \"aa####b\");\n}\n\n#[test]\nfn into_rc() {\n    let orig = \"hello/world\";\n    let path = Path::new(orig);\n    let rc: Rc<Path> = Rc::from(path);\n    let arc: Arc<Path> = Arc::from(path);\n\n    assert_eq!(&*rc, path);\n    assert_eq!(&*arc, path);\n\n    let rc2: Rc<Path> = Rc::from(path.to_owned());\n    let arc2: Arc<Path> = Arc::from(path.to_owned());\n\n    assert_eq!(&*rc2, path);\n    assert_eq!(&*arc2, path);\n}\n"],["2599","//! The first version of the prelude of The Rust Standard Library.\n//!\n//! See the [module-level documentation](super) for more.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// Re-exported core operators\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::marker::{Send, Sized, Sync, Unpin};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::ops::{Drop, Fn, FnMut, FnOnce};\n\n// Re-exported functions\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::mem::drop;\n\n// Re-exported types and traits\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::convert::{AsMut, AsRef, From, Into};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::iter::{Extend, IntoIterator, Iterator};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::option::Option::{self, None, Some};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::result::Result::{self, Err, Ok};\n\n// Re-exported built-in macros\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow(deprecated)]\n#[doc(no_inline)]\npub use core::prelude::v1::{\n    asm, assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n    format_args_nl, global_asm, include, include_bytes, include_str, line, llvm_asm, log_syntax,\n    module_path, option_env, stringify, trace_macros, Clone, Copy, Debug, Default, Eq, Hash, Ord,\n    PartialEq, PartialOrd,\n};\n\n// FIXME: Attribute and internal derive macros are not documented because for them rustdoc generates\n// dead links which fail link checker testing.\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow(deprecated, deprecated_in_future)]\n#[doc(hidden)]\npub use core::prelude::v1::{\n    bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n};\n\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(hidden)]\npub use core::prelude::v1::derive;\n\n#[unstable(\n    feature = \"cfg_accessible\",\n    issue = \"64797\",\n    reason = \"`cfg_accessible` is not fully implemented\"\n)]\n#[doc(hidden)]\npub use core::prelude::v1::cfg_accessible;\n\n#[unstable(\n    feature = \"cfg_eval\",\n    issue = \"82679\",\n    reason = \"`cfg_eval` is a recently implemented feature\"\n)]\n#[doc(hidden)]\npub use core::prelude::v1::cfg_eval;\n\n// The file so far is equivalent to src/libcore/prelude/v1.rs,\n// and below to src/liballoc/prelude.rs.\n// Those files are duplicated rather than using glob imports\n// because we want docs to show these re-exports as pointing to within `std`.\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::borrow::ToOwned;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::boxed::Box;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::string::{String, ToString};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::vec::Vec;\n"],["2600","//! # The Rust Prelude\n//!\n//! Rust comes with a variety of things in its standard library. However, if\n//! you had to manually import every single thing that you used, it would be\n//! very verbose. But importing a lot of things that a program never uses isn't\n//! good either. A balance needs to be struck.\n//!\n//! The *prelude* is the list of things that Rust automatically imports into\n//! every Rust program. It's kept as small as possible, and is focused on\n//! things, particularly traits, which are used in almost every single Rust\n//! program.\n//!\n//! # Other preludes\n//!\n//! Preludes can be seen as a pattern to make using multiple types more\n//! convenient. As such, you'll find other preludes in the standard library,\n//! such as [`std::io::prelude`]. Various libraries in the Rust ecosystem may\n//! also define their own preludes.\n//!\n//! [`std::io::prelude`]: crate::io::prelude\n//!\n//! The difference between 'the prelude' and these other preludes is that they\n//! are not automatically `use`'d, and must be imported manually. This is still\n//! easier than importing all of their constituent components.\n//!\n//! # Prelude contents\n//!\n//! The first version of the prelude is used in Rust 2015 and Rust 2018,\n//! and lives in [`std::prelude::v1`].\n//! [`std::prelude::rust_2015`] and [`std::prelude::rust_2018`] re-export this prelude.\n//! It re-exports the following:\n//!\n//! * <code>[std::marker]::{[Copy], [Send], [Sized], [Sync], [Unpin]}</code>,\n//!   marker traits that indicate fundamental properties of types.\n//! * <code>[std::ops]::{[Drop], [Fn], [FnMut], [FnOnce]}</code>, various\n//!   operations for both destructors and overloading `()`.\n//! * <code>[std::mem]::[drop][mem::drop]</code>, a convenience function for explicitly\n//!   dropping a value.\n//! * <code>[std::boxed]::[Box]</code>, a way to allocate values on the heap.\n//! * <code>[std::borrow]::[ToOwned]</code>, the conversion trait that defines\n//!   [`to_owned`], the generic method for creating an owned type from a\n//!   borrowed type.\n//! * <code>[std::clone]::[Clone]</code>, the ubiquitous trait that defines\n//!   [`clone`][Clone::clone], the method for producing a copy of a value.\n//! * <code>[std::cmp]::{[PartialEq], [PartialOrd], [Eq], [Ord]}</code>, the\n//!   comparison traits, which implement the comparison operators and are often\n//!   seen in trait bounds.\n//! * <code>[std::convert]::{[AsRef], [AsMut], [Into], [From]}</code>, generic\n//!   conversions, used by savvy API authors to create overloaded methods.\n//! * <code>[std::default]::[Default]</code>, types that have default values.\n//! * <code>[std::iter]::{[Iterator], [Extend], [IntoIterator], [DoubleEndedIterator], [ExactSizeIterator]}</code>,\n//!   iterators of various\n//!   kinds.\n//! * <code>[std::option]::[Option]::{[self][Option], [Some], [None]}</code>, a\n//!   type which expresses the presence or absence of a value. This type is so\n//!   commonly used, its variants are also exported.\n//! * <code>[std::result]::[Result]::{[self][Result], [Ok], [Err]}</code>, a type\n//!   for functions that may succeed or fail. Like [`Option`], its variants are\n//!   exported as well.\n//! * <code>[std::string]::{[String], [ToString]}</code>, heap-allocated strings.\n//! * <code>[std::vec]::[Vec]</code>, a growable, heap-allocated vector.\n//!\n//! The prelude used in Rust 2021, [`std::prelude::rust_2021`], includes all of the above,\n//! and in addition re-exports:\n//!\n//! * <code>[std::convert]::{[TryFrom], [TryInto]}</code>,\n//! * <code>[std::iter]::[FromIterator]</code>.\n//!\n//! [mem::drop]: crate::mem::drop\n//! [std::borrow]: crate::borrow\n//! [std::boxed]: crate::boxed\n//! [std::clone]: crate::clone\n//! [std::cmp]: crate::cmp\n//! [std::convert]: crate::convert\n//! [std::default]: crate::default\n//! [std::iter]: crate::iter\n//! [std::marker]: crate::marker\n//! [std::mem]: crate::mem\n//! [std::ops]: crate::ops\n//! [std::option]: crate::option\n//! [`std::prelude::v1`]: v1\n//! [`std::prelude::rust_2015`]: rust_2015\n//! [`std::prelude::rust_2018`]: rust_2018\n//! [`std::prelude::rust_2021`]: rust_2021\n//! [std::result]: crate::result\n//! [std::slice]: crate::slice\n//! [std::string]: crate::string\n//! [std::vec]: mod@crate::vec\n//! [TryFrom]: crate::convert::TryFrom\n//! [TryInto]: crate::convert::TryInto\n//! [FromIterator]: crate::iter::FromIterator\n//! [`to_owned`]: crate::borrow::ToOwned::to_owned\n//! [book-closures]: ../../book/ch13-01-closures.html\n//! [book-dtor]: ../../book/ch15-03-drop.html\n//! [book-enums]: ../../book/ch06-01-defining-an-enum.html\n//! [book-iter]: ../../book/ch13-02-iterators.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\npub mod v1;\n\n/// The 2015 version of the prelude of The Rust Standard Library.\n///\n/// See the [module-level documentation](self) for more.\n#[stable(feature = \"prelude_2015\", since = \"1.55.0\")]\npub mod rust_2015 {\n    #[stable(feature = \"prelude_2015\", since = \"1.55.0\")]\n    #[doc(no_inline)]\n    pub use super::v1::*;\n}\n\n/// The 2018 version of the prelude of The Rust Standard Library.\n///\n/// See the [module-level documentation](self) for more.\n#[stable(feature = \"prelude_2018\", since = \"1.55.0\")]\npub mod rust_2018 {\n    #[stable(feature = \"prelude_2018\", since = \"1.55.0\")]\n    #[doc(no_inline)]\n    pub use super::v1::*;\n}\n\n/// The 2021 version of the prelude of The Rust Standard Library.\n///\n/// See the [module-level documentation](self) for more.\n#[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\npub mod rust_2021 {\n    #[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\n    #[doc(no_inline)]\n    pub use super::v1::*;\n\n    #[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\n    #[doc(no_inline)]\n    pub use core::prelude::rust_2021::*;\n}\n"],["2601","use super::*;\n\nuse crate::path::Path;\n\n#[test]\n#[cfg_attr(any(target_os = \"emscripten\", target_env = \"sgx\"), ignore)]\nfn test_self_exe_path() {\n    let path = current_exe();\n    assert!(path.is_ok());\n    let path = path.unwrap();\n\n    // Hard to test this function\n    assert!(path.is_absolute());\n}\n\n#[test]\nfn test() {\n    assert!((!Path::new(\"test-path\").is_absolute()));\n\n    #[cfg(not(target_env = \"sgx\"))]\n    current_dir().unwrap();\n}\n\n#[test]\n#[cfg(windows)]\nfn split_paths_windows() {\n    use crate::path::PathBuf;\n\n    fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n        split_paths(unparsed).collect::<Vec<_>>()\n            == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n    }\n\n    assert!(check_parse(\"\", &mut [\"\"]));\n    assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n    assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n    assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n    assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n    assert!(check_parse(r\"c:\\;c:\\Program Files\\\", &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n    assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n    assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#, &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n}\n\n#[test]\n#[cfg(unix)]\nfn split_paths_unix() {\n    use crate::path::PathBuf;\n\n    fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n        split_paths(unparsed).collect::<Vec<_>>()\n            == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n    }\n\n    assert!(check_parse(\"\", &mut [\"\"]));\n    assert!(check_parse(\"::\", &mut [\"\", \"\", \"\"]));\n    assert!(check_parse(\"/\", &mut [\"/\"]));\n    assert!(check_parse(\"/:\", &mut [\"/\", \"\"]));\n    assert!(check_parse(\"/:/usr/local\", &mut [\"/\", \"/usr/local\"]));\n}\n\n#[test]\n#[cfg(unix)]\nfn join_paths_unix() {\n    use crate::ffi::OsStr;\n\n    fn test_eq(input: &[&str], output: &str) -> bool {\n        &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n    }\n\n    assert!(test_eq(&[], \"\"));\n    assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"], \"/bin:/usr/bin:/usr/local/bin\"));\n    assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"], \":/bin:::/usr/bin:\"));\n    assert!(join_paths([\"/te:st\"].iter().cloned()).is_err());\n}\n\n#[test]\n#[cfg(windows)]\nfn join_paths_windows() {\n    use crate::ffi::OsStr;\n\n    fn test_eq(input: &[&str], output: &str) -> bool {\n        &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n    }\n\n    assert!(test_eq(&[], \"\"));\n    assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"], r\"c:\\windows;c:\\\"));\n    assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"], r\";c:\\windows;;;c:\\;\"));\n    assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"], r#\"\"c:\\te;st\";c:\\\"#));\n    assert!(join_paths([r#\"c:\\te\"st\"#].iter().cloned()).is_err());\n}\n\n#[test]\nfn args_debug() {\n    assert_eq!(\n        format!(\"Args {{ inner: {:?} }}\", args().collect::<Vec<_>>()),\n        format!(\"{:?}\", args())\n    );\n    assert_eq!(\n        format!(\"ArgsOs {{ inner: {:?} }}\", args_os().collect::<Vec<_>>()),\n        format!(\"{:?}\", args_os())\n    );\n}\n"],["2602","//! Bit manipulation utilities.\n\n/// Tests the `bit` of `x`.\n#[allow(dead_code)]\n#[inline]\npub(crate) fn test(x: usize, bit: u32) -> bool {\n    debug_assert!(bit < usize::BITS, \"bit index out-of-bounds\");\n    x & (1 << bit) != 0\n}\n"],["2603","//! Parses ELF auxiliary vectors.\n#![cfg_attr(\n    any(\n        target_arch = \"aarch64\",\n        target_arch = \"arm\",\n        target_arch = \"powerpc64\"\n    ),\n    allow(dead_code)\n)]\n\n/// Key to access the CPU Hardware capabilities bitfield.\npub(crate) const AT_HWCAP: usize = 25;\n/// Key to access the CPU Hardware capabilities 2 bitfield.\npub(crate) const AT_HWCAP2: usize = 26;\n\n/// Cache HWCAP bitfields of the ELF Auxiliary Vector.\n///\n/// If an entry cannot be read all the bits in the bitfield are set to zero.\n/// This should be interpreted as all the features being disabled.\n#[derive(Debug, Copy, Clone)]\npub(crate) struct AuxVec {\n    pub hwcap: usize,\n    pub hwcap2: usize,\n}\n\n/// ELF Auxiliary Vector\n///\n/// The auxiliary vector is a memory region in a running ELF program's stack\n/// composed of (key: usize, value: usize) pairs.\n///\n/// The keys used in the aux vector are platform dependent. For FreeBSD, they are\n/// defined in [sys/elf_common.h][elf_common_h]. The hardware capabilities of a given\n/// CPU can be queried with the  `AT_HWCAP` and `AT_HWCAP2` keys.\n///\n/// Note that run-time feature detection is not invoked for features that can\n/// be detected at compile-time.\n///\n/// [elf_common.h]: https://svnweb.freebsd.org/base/release/12.0.0/sys/sys/elf_common.h?revision=341707\npub(crate) fn auxv() -> Result<AuxVec, ()> {\n    if let Ok(hwcap) = archauxv(AT_HWCAP) {\n        if let Ok(hwcap2) = archauxv(AT_HWCAP2) {\n            if hwcap != 0 && hwcap2 != 0 {\n                return Ok(AuxVec { hwcap, hwcap2 });\n            }\n        }\n    }\n    Err(())\n}\n\n/// Tries to read the `key` from the auxiliary vector.\nfn archauxv(key: usize) -> Result<usize, ()> {\n    use core::mem;\n\n    #[derive(Copy, Clone)]\n    #[repr(C)]\n    pub struct Elf_Auxinfo {\n        pub a_type: usize,\n        pub a_un: unnamed,\n    }\n    #[derive(Copy, Clone)]\n    #[repr(C)]\n    pub union unnamed {\n        pub a_val: libc::c_long,\n        pub a_ptr: *mut libc::c_void,\n        pub a_fcn: Option<unsafe extern \"C\" fn() -> ()>,\n    }\n\n    let mut auxv: [Elf_Auxinfo; 27] = [Elf_Auxinfo {\n        a_type: 0,\n        a_un: unnamed { a_val: 0 },\n    }; 27];\n\n    let mut len: libc::c_uint = mem::size_of_val(&auxv) as libc::c_uint;\n\n    unsafe {\n        let mut mib = [\n            libc::CTL_KERN,\n            libc::KERN_PROC,\n            libc::KERN_PROC_AUXV,\n            libc::getpid(),\n        ];\n\n        let ret = libc::sysctl(\n            mib.as_mut_ptr(),\n            mib.len() as u32,\n            &mut auxv as *mut _ as *mut _,\n            &mut len as *mut _ as *mut _,\n            0 as *mut libc::c_void,\n            0,\n        );\n\n        if ret != -1 {\n            for i in 0..auxv.len() {\n                if auxv[i].a_type == key {\n                    return Ok(auxv[i].a_un.a_val as usize);\n                }\n            }\n        }\n    }\n    return Ok(0);\n}\n"],["2604","//! Run-time feature detection for Aarch64 on FreeBSD.\n\npub(crate) use super::super::aarch64::detect_features;\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn dump() {\n        println!(\"asimd: {:?}\", is_aarch64_feature_detected!(\"asimd\"));\n        println!(\"pmull: {:?}\", is_aarch64_feature_detected!(\"pmull\"));\n        println!(\"fp: {:?}\", is_aarch64_feature_detected!(\"fp\"));\n        println!(\"fp16: {:?}\", is_aarch64_feature_detected!(\"fp16\"));\n        println!(\"sve: {:?}\", is_aarch64_feature_detected!(\"sve\"));\n        println!(\"crc: {:?}\", is_aarch64_feature_detected!(\"crc\"));\n        println!(\"lse: {:?}\", is_aarch64_feature_detected!(\"lse\"));\n        println!(\"rdm: {:?}\", is_aarch64_feature_detected!(\"rdm\"));\n        println!(\"rcpc: {:?}\", is_aarch64_feature_detected!(\"rcpc\"));\n        println!(\"dotprod: {:?}\", is_aarch64_feature_detected!(\"dotprod\"));\n        println!(\"tme: {:?}\", is_aarch64_feature_detected!(\"tme\"));\n    }\n}\n"],["2605","//! Run-time feature detection on FreeBSD\n\nmod auxvec;\n\ncfg_if::cfg_if! {\n    if #[cfg(target_arch = \"aarch64\")] {\n        mod aarch64;\n        pub(crate) use self::aarch64::detect_features;\n    } else if #[cfg(target_arch = \"arm\")] {\n        mod arm;\n        pub(crate) use self::arm::detect_features;\n    } else if #[cfg(target_arch = \"powerpc64\")] {\n        mod powerpc;\n        pub(crate) use self::powerpc::detect_features;\n    } else {\n        use crate::detect::cache;\n        /// Performs run-time feature detection.\n        pub(crate) fn detect_features() -> cache::Initializer {\n            cache::Initializer::default()\n        }\n    }\n}\n"],["2606","//! Run-time feature detection for PowerPC on FreeBSD.\n\nuse super::auxvec;\nuse crate::detect::{cache, Feature};\n\npub(crate) fn detect_features() -> cache::Initializer {\n    let mut value = cache::Initializer::default();\n    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n        if enable {\n            value.set(f as u32);\n        }\n    };\n\n    if let Ok(auxv) = auxvec::auxv() {\n        enable_feature(&mut value, Feature::altivec, auxv.hwcap & 0x10000000 != 0);\n        enable_feature(&mut value, Feature::vsx, auxv.hwcap & 0x00000080 != 0);\n        enable_feature(&mut value, Feature::power8, auxv.hwcap2 & 0x80000000 != 0);\n        return value;\n    }\n    value\n}\n"],["2607","//! Run-time feature detection for ARM on FreeBSD\n\nuse super::auxvec;\nuse crate::detect::{cache, Feature};\n\n/// Try to read the features from the auxiliary vector\npub(crate) fn detect_features() -> cache::Initializer {\n    let mut value = cache::Initializer::default();\n    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n        if enable {\n            value.set(f as u32);\n        }\n    };\n\n    if let Ok(auxv) = auxvec::auxv() {\n        enable_feature(&mut value, Feature::neon, auxv.hwcap & 0x00001000 != 0);\n        enable_feature(&mut value, Feature::pmull, auxv.hwcap2 & 0x00000002 != 0);\n        return value;\n    }\n    value\n}\n"],["2608","//! x86 run-time feature detection is OS independent.\n\n#[cfg(target_arch = \"x86\")]\nuse core::arch::x86::*;\n#[cfg(target_arch = \"x86_64\")]\nuse core::arch::x86_64::*;\n\nuse core::mem;\n\nuse crate::detect::{bit, cache, Feature};\n\n/// Run-time feature detection on x86 works by using the CPUID instruction.\n///\n/// The [CPUID Wikipedia page][wiki_cpuid] contains\n/// all the information about which flags to set to query which values, and in\n/// which registers these are reported.\n///\n/// The definitive references are:\n/// - [Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2:\n///   Instruction Set Reference, A-Z][intel64_ref].\n/// - [AMD64 Architecture Programmer's Manual, Volume 3: General-Purpose and\n///   System Instructions][amd64_ref].\n///\n/// [wiki_cpuid]: https://en.wikipedia.org/wiki/CPUID\n/// [intel64_ref]: http://www.intel.de/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf\n/// [amd64_ref]: http://support.amd.com/TechDocs/24594.pdf\n#[allow(clippy::similar_names)]\npub(crate) fn detect_features() -> cache::Initializer {\n    let mut value = cache::Initializer::default();\n\n    // If the x86 CPU does not support the CPUID instruction then it is too\n    // old to support any of the currently-detectable features.\n    if !has_cpuid() {\n        return value;\n    }\n\n    // Calling `__cpuid`/`__cpuid_count` from here on is safe because the CPU\n    // has `cpuid` support.\n\n    // 0. EAX = 0: Basic Information:\n    // - EAX returns the \"Highest Function Parameter\", that is, the maximum\n    // leaf value for subsequent calls of `cpuinfo` in range [0,\n    // 0x8000_0000]. - The vendor ID is stored in 12 u8 ascii chars,\n    // returned in EBX, EDX, and   ECX (in that order):\n    let (max_basic_leaf, vendor_id) = unsafe {\n        let CpuidResult {\n            eax: max_basic_leaf,\n            ebx,\n            ecx,\n            edx,\n        } = __cpuid(0);\n        let vendor_id: [[u8; 4]; 3] = [\n            mem::transmute(ebx),\n            mem::transmute(edx),\n            mem::transmute(ecx),\n        ];\n        let vendor_id: [u8; 12] = mem::transmute(vendor_id);\n        (max_basic_leaf, vendor_id)\n    };\n\n    if max_basic_leaf < 1 {\n        // Earlier Intel 486, CPUID not implemented\n        return value;\n    }\n\n    // EAX = 1, ECX = 0: Queries \"Processor Info and Feature Bits\";\n    // Contains information about most x86 features.\n    let CpuidResult {\n        ecx: proc_info_ecx,\n        edx: proc_info_edx,\n        ..\n    } = unsafe { __cpuid(0x0000_0001_u32) };\n\n    // EAX = 7, ECX = 0: Queries \"Extended Features\";\n    // Contains information about bmi,bmi2, and avx2 support.\n    let (extended_features_ebx, extended_features_ecx) = if max_basic_leaf >= 7 {\n        let CpuidResult { ebx, ecx, .. } = unsafe { __cpuid(0x0000_0007_u32) };\n        (ebx, ecx)\n    } else {\n        (0, 0) // CPUID does not support \"Extended Features\"\n    };\n\n    // EAX = 0x8000_0000, ECX = 0: Get Highest Extended Function Supported\n    // - EAX returns the max leaf value for extended information, that is,\n    // `cpuid` calls in range [0x8000_0000; u32::MAX]:\n    let CpuidResult {\n        eax: extended_max_basic_leaf,\n        ..\n    } = unsafe { __cpuid(0x8000_0000_u32) };\n\n    // EAX = 0x8000_0001, ECX=0: Queries \"Extended Processor Info and Feature\n    // Bits\"\n    let extended_proc_info_ecx = if extended_max_basic_leaf >= 1 {\n        let CpuidResult { ecx, .. } = unsafe { __cpuid(0x8000_0001_u32) };\n        ecx\n    } else {\n        0\n    };\n\n    {\n        // borrows value till the end of this scope:\n        let mut enable = |r, rb, f| {\n            if bit::test(r as usize, rb) {\n                value.set(f as u32);\n            }\n        };\n\n        enable(proc_info_ecx, 0, Feature::sse3);\n        enable(proc_info_ecx, 1, Feature::pclmulqdq);\n        enable(proc_info_ecx, 9, Feature::ssse3);\n        enable(proc_info_ecx, 13, Feature::cmpxchg16b);\n        enable(proc_info_ecx, 19, Feature::sse4_1);\n        enable(proc_info_ecx, 20, Feature::sse4_2);\n        enable(proc_info_ecx, 23, Feature::popcnt);\n        enable(proc_info_ecx, 25, Feature::aes);\n        enable(proc_info_ecx, 29, Feature::f16c);\n        enable(proc_info_ecx, 30, Feature::rdrand);\n        enable(extended_features_ebx, 18, Feature::rdseed);\n        enable(extended_features_ebx, 19, Feature::adx);\n        enable(extended_features_ebx, 11, Feature::rtm);\n        enable(proc_info_edx, 4, Feature::tsc);\n        enable(proc_info_edx, 23, Feature::mmx);\n        enable(proc_info_edx, 24, Feature::fxsr);\n        enable(proc_info_edx, 25, Feature::sse);\n        enable(proc_info_edx, 26, Feature::sse2);\n        enable(extended_features_ebx, 29, Feature::sha);\n\n        enable(extended_features_ebx, 3, Feature::bmi1);\n        enable(extended_features_ebx, 8, Feature::bmi2);\n\n        // `XSAVE` and `AVX` support:\n        let cpu_xsave = bit::test(proc_info_ecx as usize, 26);\n        if cpu_xsave {\n            // 0. Here the CPU supports `XSAVE`.\n\n            // 1. Detect `OSXSAVE`, that is, whether the OS is AVX enabled and\n            // supports saving the state of the AVX/AVX2 vector registers on\n            // context-switches, see:\n            //\n            // - [intel: is avx enabled?][is_avx_enabled],\n            // - [mozilla: sse.cpp][mozilla_sse_cpp].\n            //\n            // [is_avx_enabled]: https://software.intel.com/en-us/blogs/2011/04/14/is-avx-enabled\n            // [mozilla_sse_cpp]: https://hg.mozilla.org/mozilla-central/file/64bab5cbb9b6/mozglue/build/SSE.cpp#l190\n            let cpu_osxsave = bit::test(proc_info_ecx as usize, 27);\n\n            if cpu_osxsave {\n                // 2. The OS must have signaled the CPU that it supports saving and\n                // restoring the:\n                //\n                // * SSE -> `XCR0.SSE[1]`\n                // * AVX -> `XCR0.AVX[2]`\n                // * AVX-512 -> `XCR0.AVX-512[7:5]`.\n                //\n                // by setting the corresponding bits of `XCR0` to `1`.\n                //\n                // This is safe because the CPU supports `xsave`\n                // and the OS has set `osxsave`.\n                let xcr0 = unsafe { _xgetbv(0) };\n                // Test `XCR0.SSE[1]` and `XCR0.AVX[2]` with the mask `0b110 == 6`:\n                let os_avx_support = xcr0 & 6 == 6;\n                // Test `XCR0.AVX-512[7:5]` with the mask `0b1110_0000 == 224`:\n                let os_avx512_support = xcr0 & 224 == 224;\n\n                // Only if the OS and the CPU support saving/restoring the AVX\n                // registers we enable `xsave` support:\n                if os_avx_support {\n                    // See \"13.3 ENABLING THE XSAVE FEATURE SET AND XSAVE-ENABLED\n                    // FEATURES\" in the \"Intel® 64 and IA-32 Architectures Software\n                    // Developer’s Manual, Volume 1: Basic Architecture\":\n                    //\n                    // \"Software enables the XSAVE feature set by setting\n                    // CR4.OSXSAVE[bit 18] to 1 (e.g., with the MOV to CR4\n                    // instruction). If this bit is 0, execution of any of XGETBV,\n                    // XRSTOR, XRSTORS, XSAVE, XSAVEC, XSAVEOPT, XSAVES, and XSETBV\n                    // causes an invalid-opcode exception (#UD)\"\n                    //\n                    enable(proc_info_ecx, 26, Feature::xsave);\n\n                    // For `xsaveopt`, `xsavec`, and `xsaves` we need to query:\n                    // Processor Extended State Enumeration Sub-leaf (EAX = 0DH,\n                    // ECX = 1):\n                    if max_basic_leaf >= 0xd {\n                        let CpuidResult {\n                            eax: proc_extended_state1_eax,\n                            ..\n                        } = unsafe { __cpuid_count(0xd_u32, 1) };\n                        enable(proc_extended_state1_eax, 0, Feature::xsaveopt);\n                        enable(proc_extended_state1_eax, 1, Feature::xsavec);\n                        enable(proc_extended_state1_eax, 3, Feature::xsaves);\n                    }\n\n                    // FMA (uses 256-bit wide registers):\n                    enable(proc_info_ecx, 12, Feature::fma);\n\n                    // And AVX/AVX2:\n                    enable(proc_info_ecx, 28, Feature::avx);\n                    enable(extended_features_ebx, 5, Feature::avx2);\n\n                    // For AVX-512 the OS also needs to support saving/restoring\n                    // the extended state, only then we enable AVX-512 support:\n                    if os_avx512_support {\n                        enable(extended_features_ebx, 16, Feature::avx512f);\n                        enable(extended_features_ebx, 17, Feature::avx512dq);\n                        enable(extended_features_ebx, 21, Feature::avx512ifma);\n                        enable(extended_features_ebx, 26, Feature::avx512pf);\n                        enable(extended_features_ebx, 27, Feature::avx512er);\n                        enable(extended_features_ebx, 28, Feature::avx512cd);\n                        enable(extended_features_ebx, 30, Feature::avx512bw);\n                        enable(extended_features_ebx, 31, Feature::avx512vl);\n                        enable(extended_features_ecx, 1, Feature::avx512vbmi);\n                        enable(extended_features_ecx, 5, Feature::avx512bf16);\n                        enable(extended_features_ecx, 6, Feature::avx512vbmi2);\n                        enable(extended_features_ecx, 8, Feature::avx512gfni);\n                        enable(extended_features_ecx, 8, Feature::avx512vp2intersect);\n                        enable(extended_features_ecx, 9, Feature::avx512vaes);\n                        enable(extended_features_ecx, 10, Feature::avx512vpclmulqdq);\n                        enable(extended_features_ecx, 11, Feature::avx512vnni);\n                        enable(extended_features_ecx, 12, Feature::avx512bitalg);\n                        enable(extended_features_ecx, 14, Feature::avx512vpopcntdq);\n                    }\n                }\n            }\n        }\n\n        // This detects ABM on AMD CPUs and LZCNT on Intel CPUs.\n        // On intel CPUs with popcnt, lzcnt implements the\n        // \"missing part\" of ABM, so we map both to the same\n        // internal feature.\n        //\n        // The `is_x86_feature_detected!(\"lzcnt\")` macro then\n        // internally maps to Feature::abm.\n        enable(extended_proc_info_ecx, 5, Feature::lzcnt);\n\n        // As Hygon Dhyana originates from AMD technology and shares most of the architecture with\n        // AMD's family 17h, but with different CPU Vendor ID(\"HygonGenuine\")/Family series\n        // number(Family 18h).\n        //\n        // For CPUID feature bits, Hygon Dhyana(family 18h) share the same definition with AMD\n        // family 17h.\n        //\n        // Related AMD CPUID specification is https://www.amd.com/system/files/TechDocs/25481.pdf.\n        // Related Hygon kernel patch can be found on\n        // http://lkml.kernel.org/r/5ce86123a7b9dad925ac583d88d2f921040e859b.1538583282.git.puwen@hygon.cn\n        if vendor_id == *b\"AuthenticAMD\" || vendor_id == *b\"HygonGenuine\" {\n            // These features are available on AMD arch CPUs:\n            enable(extended_proc_info_ecx, 6, Feature::sse4a);\n            enable(extended_proc_info_ecx, 21, Feature::tbm);\n        }\n    }\n\n    value\n}\n"],["2609","//! Other operating systems\n\nuse crate::detect::cache;\n\n#[allow(dead_code)]\npub(crate) fn detect_features() -> cache::Initializer {\n    cache::Initializer::default()\n}\n"],["2610","//! Run-time feature detection for Aarch64 on Windows.\n\nuse crate::detect::{cache, Feature};\n\n/// Try to read the features using IsProcessorFeaturePresent.\npub(crate) fn detect_features() -> cache::Initializer {\n    type DWORD = u32;\n    type BOOL = i32;\n\n    const FALSE: BOOL = 0;\n    // The following Microsoft documents isn't updated for aarch64.\n    // https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-isprocessorfeaturepresent\n    // These are defined in winnt.h of Windows SDK\n    const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19;\n    const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: u32 = 30;\n    const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: u32 = 31;\n\n    extern \"system\" {\n        pub fn IsProcessorFeaturePresent(ProcessorFeature: DWORD) -> BOOL;\n    }\n\n    let mut value = cache::Initializer::default();\n    {\n        let mut enable_feature = |f, enable| {\n            if enable {\n                value.set(f as u32);\n            }\n        };\n\n        // Some features such Feature::fp may be supported on current CPU,\n        // but no way to detect it by OS API.\n        // Also, we require unsafe block for the extern \"system\" calls.\n        unsafe {\n            enable_feature(\n                Feature::asimd,\n                IsProcessorFeaturePresent(PF_ARM_NEON_INSTRUCTIONS_AVAILABLE) != FALSE,\n            );\n            enable_feature(\n                Feature::crc,\n                IsProcessorFeaturePresent(PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE) != FALSE,\n            );\n            // PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE means aes, sha1, sha2 and\n            // pmull support\n            enable_feature(\n                Feature::aes,\n                IsProcessorFeaturePresent(PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE) != FALSE,\n            );\n            enable_feature(\n                Feature::pmull,\n                IsProcessorFeaturePresent(PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE) != FALSE,\n            );\n            enable_feature(\n                Feature::sha2,\n                IsProcessorFeaturePresent(PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE) != FALSE,\n            );\n        }\n    }\n    value\n}\n"],["2611","//! Run-time feature detection for Aarch64 on any OS that emulates the mrs instruction.\n//!\n//! On FreeBSD >= 12.0, Linux >= 4.11 and other operating systems, it is possible to use\n//! privileged system registers from userspace to check CPU feature support.\n//!\n//! AArch64 system registers ID_AA64ISAR0_EL1, ID_AA64PFR0_EL1, ID_AA64ISAR1_EL1\n//! have bits dedicated to features like AdvSIMD, CRC32, AES, atomics (LSE), etc.\n//! Each part of the register indicates the level of support for a certain feature, e.g.\n//! when ID_AA64ISAR0_EL1\\[7:4\\] is >= 1, AES is supported; when it's >= 2, PMULL is supported.\n//!\n//! For proper support of [SoCs where different cores have different capabilities](https://medium.com/@jadr2ddude/a-big-little-problem-a-tale-of-big-little-gone-wrong-e7778ce744bb),\n//! the OS has to always report only the features supported by all cores, like [FreeBSD does](https://reviews.freebsd.org/D17137#393947).\n//!\n//! References:\n//!\n//! - [Zircon implementation](https://fuchsia.googlesource.com/zircon/+/master/kernel/arch/arm64/feature.cpp)\n//! - [Linux documentation](https://www.kernel.org/doc/Documentation/arm64/cpu-feature-registers.txt)\n\nuse crate::detect::{cache, Feature};\n\n/// Try to read the features from the system registers.\n///\n/// This will cause SIGILL if the current OS is not trapping the mrs instruction.\npub(crate) fn detect_features() -> cache::Initializer {\n    let mut value = cache::Initializer::default();\n\n    {\n        let mut enable_feature = |f, enable| {\n            if enable {\n                value.set(f as u32);\n            }\n        };\n\n        // ID_AA64ISAR0_EL1 - Instruction Set Attribute Register 0\n        let aa64isar0: u64;\n        unsafe {\n            asm!(\n                \"mrs {}, ID_AA64ISAR0_EL1\",\n                out(reg) aa64isar0,\n                options(pure, nomem, preserves_flags, nostack)\n            );\n        }\n\n        enable_feature(Feature::pmull, bits_shift(aa64isar0, 7, 4) >= 2);\n        enable_feature(Feature::tme, bits_shift(aa64isar0, 27, 24) == 1);\n        enable_feature(Feature::lse, bits_shift(aa64isar0, 23, 20) >= 1);\n        enable_feature(Feature::crc, bits_shift(aa64isar0, 19, 16) >= 1);\n\n        // ID_AA64PFR0_EL1 - Processor Feature Register 0\n        let aa64pfr0: u64;\n        unsafe {\n            asm!(\n                \"mrs {}, ID_AA64PFR0_EL1\",\n                out(reg) aa64pfr0,\n                options(pure, nomem, preserves_flags, nostack)\n            );\n        }\n\n        let fp = bits_shift(aa64pfr0, 19, 16) < 0xF;\n        let fphp = bits_shift(aa64pfr0, 19, 16) >= 1;\n        let asimd = bits_shift(aa64pfr0, 23, 20) < 0xF;\n        let asimdhp = bits_shift(aa64pfr0, 23, 20) >= 1;\n        enable_feature(Feature::fp, fp);\n        enable_feature(Feature::fp16, fphp);\n        // SIMD support requires float support - if half-floats are\n        // supported, it also requires half-float support:\n        enable_feature(Feature::asimd, fp && asimd && (!fphp | asimdhp));\n        // SIMD extensions require SIMD support:\n        enable_feature(Feature::aes, asimd && bits_shift(aa64isar0, 7, 4) >= 1);\n        let sha1 = bits_shift(aa64isar0, 11, 8) >= 1;\n        let sha2 = bits_shift(aa64isar0, 15, 12) >= 1;\n        enable_feature(Feature::sha2, asimd && sha1 && sha2);\n        enable_feature(Feature::rdm, asimd && bits_shift(aa64isar0, 31, 28) >= 1);\n        enable_feature(\n            Feature::dotprod,\n            asimd && bits_shift(aa64isar0, 47, 44) >= 1,\n        );\n        enable_feature(Feature::sve, asimd && bits_shift(aa64pfr0, 35, 32) >= 1);\n\n        // ID_AA64ISAR1_EL1 - Instruction Set Attribute Register 1\n        let aa64isar1: u64;\n        unsafe {\n            asm!(\n                \"mrs {}, ID_AA64ISAR1_EL1\",\n                out(reg) aa64isar1,\n                options(pure, nomem, preserves_flags, nostack)\n            );\n        }\n\n        enable_feature(Feature::rcpc, bits_shift(aa64isar1, 23, 20) >= 1);\n    }\n\n    value\n}\n\n#[inline]\nfn bits_shift(x: u64, high: usize, low: usize) -> u64 {\n    (x >> low) & ((1 << (high - low + 1)) - 1)\n}\n"],["2612","//! Run-time feature detection on Linux\n//!\n#[cfg(feature = \"std_detect_file_io\")]\nuse alloc::vec::Vec;\n\nmod auxvec;\n\n#[cfg(feature = \"std_detect_file_io\")]\nmod cpuinfo;\n\n#[cfg(feature = \"std_detect_file_io\")]\nfn read_file(path: &str) -> Result<Vec<u8>, ()> {\n    let mut path = Vec::from(path.as_bytes());\n    path.push(0);\n\n    unsafe {\n        let file = libc::open(path.as_ptr() as *const libc::c_char, libc::O_RDONLY);\n        if file == -1 {\n            return Err(());\n        }\n\n        let mut data = Vec::new();\n        loop {\n            data.reserve(4096);\n            let spare = data.spare_capacity_mut();\n            match libc::read(file, spare.as_mut_ptr() as *mut _, spare.len()) {\n                -1 => {\n                    libc::close(file);\n                    return Err(());\n                }\n                0 => break,\n                n => data.set_len(data.len() + n as usize),\n            }\n        }\n\n        libc::close(file);\n        Ok(data)\n    }\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(target_arch = \"aarch64\")] {\n        mod aarch64;\n        pub(crate) use self::aarch64::detect_features;\n    } else if #[cfg(target_arch = \"arm\")] {\n        mod arm;\n        pub(crate) use self::arm::detect_features;\n    } else  if #[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))] {\n        mod mips;\n        pub(crate) use self::mips::detect_features;\n    } else if #[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))] {\n        mod powerpc;\n        pub(crate) use self::powerpc::detect_features;\n    } else {\n        use crate::detect::cache;\n        /// Performs run-time feature detection.\n        pub(crate) fn detect_features() -> cache::Initializer {\n            cache::Initializer::default()\n        }\n    }\n}\n"],["2613","//! Run-time feature detection for MIPS on Linux.\n\nuse super::auxvec;\nuse crate::detect::{bit, cache, Feature};\n\n/// Try to read the features from the auxiliary vector, and if that fails, try\n/// to read them from `/proc/cpuinfo`.\npub(crate) fn detect_features() -> cache::Initializer {\n    let mut value = cache::Initializer::default();\n    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n        if enable {\n            value.set(f as u32);\n        }\n    };\n\n    // The values are part of the platform-specific [asm/hwcap.h][hwcap]\n    //\n    // [hwcap]: https://github.com/torvalds/linux/blob/master/arch/arm64/include/uapi/asm/hwcap.h\n    if let Ok(auxv) = auxvec::auxv() {\n        enable_feature(&mut value, Feature::msa, bit::test(auxv.hwcap, 1));\n        return value;\n    }\n    // TODO: fall back via `cpuinfo`.\n    value\n}\n"],["2614","//! Parses ELF auxiliary vectors.\n#![cfg_attr(not(target_arch = \"aarch64\"), allow(dead_code))]\n\npub(crate) const AT_NULL: usize = 0;\n\n/// Key to access the CPU Hardware capabilities bitfield.\npub(crate) const AT_HWCAP: usize = 16;\n/// Key to access the CPU Hardware capabilities 2 bitfield.\n#[cfg(any(\n    target_arch = \"arm\",\n    target_arch = \"powerpc\",\n    target_arch = \"powerpc64\"\n))]\npub(crate) const AT_HWCAP2: usize = 26;\n\n/// Cache HWCAP bitfields of the ELF Auxiliary Vector.\n///\n/// If an entry cannot be read all the bits in the bitfield are set to zero.\n/// This should be interpreted as all the features being disabled.\n#[derive(Debug, Copy, Clone)]\npub(crate) struct AuxVec {\n    pub hwcap: usize,\n    #[cfg(any(\n        target_arch = \"arm\",\n        target_arch = \"powerpc\",\n        target_arch = \"powerpc64\"\n    ))]\n    pub hwcap2: usize,\n}\n\n/// ELF Auxiliary Vector\n///\n/// The auxiliary vector is a memory region in a running ELF program's stack\n/// composed of (key: usize, value: usize) pairs.\n///\n/// The keys used in the aux vector are platform dependent. For Linux, they are\n/// defined in [linux/auxvec.h][auxvec_h]. The hardware capabilities of a given\n/// CPU can be queried with the  `AT_HWCAP` and `AT_HWCAP2` keys.\n///\n/// There is no perfect way of reading the auxiliary vector.\n///\n/// - If the `std_detect_dlsym_getauxval` cargo feature is enabled, this will use\n/// `getauxval` if its linked to the binary, and otherwise proceed to a fallback implementation.\n/// When `std_detect_dlsym_getauxval` is disabled, this will assume that `getauxval` is\n/// linked to the binary - if that is not the case the behavior is undefined.\n/// - Otherwise, if the `std_detect_file_io` cargo feature is enabled, it will\n///   try to read `/proc/self/auxv`.\n/// - If that fails, this function returns an error.\n///\n/// Note that run-time feature detection is not invoked for features that can\n/// be detected at compile-time. Also note that if this function returns an\n/// error, cpuinfo still can (and will) be used to try to perform run-time\n/// feature detecton on some platforms.\n///\n/// For more information about when `getauxval` is available check the great\n/// [`auxv` crate documentation][auxv_docs].\n///\n/// [auxvec_h]: https://github.com/torvalds/linux/blob/master/include/uapi/linux/auxvec.h\n/// [auxv_docs]: https://docs.rs/auxv/0.3.3/auxv/\npub(crate) fn auxv() -> Result<AuxVec, ()> {\n    #[cfg(feature = \"std_detect_dlsym_getauxval\")]\n    {\n        // Try to call a dynamically-linked getauxval function.\n        if let Ok(hwcap) = getauxval(AT_HWCAP) {\n            // Targets with only AT_HWCAP:\n            #[cfg(any(target_arch = \"aarch64\", target_arch = \"mips\", target_arch = \"mips64\"))]\n            {\n                if hwcap != 0 {\n                    return Ok(AuxVec { hwcap });\n                }\n            }\n\n            // Targets with AT_HWCAP and AT_HWCAP2:\n            #[cfg(any(\n                target_arch = \"arm\",\n                target_arch = \"powerpc\",\n                target_arch = \"powerpc64\"\n            ))]\n            {\n                if let Ok(hwcap2) = getauxval(AT_HWCAP2) {\n                    if hwcap != 0 && hwcap2 != 0 {\n                        return Ok(AuxVec { hwcap, hwcap2 });\n                    }\n                }\n            }\n            drop(hwcap);\n        }\n    }\n\n    #[cfg(not(feature = \"std_detect_dlsym_getauxval\"))]\n    {\n        let hwcap = unsafe { libc::getauxval(AT_HWCAP as libc::c_ulong) as usize };\n\n        // Targets with only AT_HWCAP:\n        #[cfg(any(target_arch = \"aarch64\", target_arch = \"mips\", target_arch = \"mips64\"))]\n        {\n            if hwcap != 0 {\n                return Ok(AuxVec { hwcap });\n            }\n        }\n\n        // Targets with AT_HWCAP and AT_HWCAP2:\n        #[cfg(any(\n            target_arch = \"arm\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\"\n        ))]\n        {\n            let hwcap2 = unsafe { libc::getauxval(AT_HWCAP2 as libc::c_ulong) as usize };\n            if hwcap != 0 && hwcap2 != 0 {\n                return Ok(AuxVec { hwcap, hwcap2 });\n            }\n        }\n    }\n\n    #[cfg(feature = \"std_detect_file_io\")]\n    {\n        // If calling getauxval fails, try to read the auxiliary vector from\n        // its file:\n        auxv_from_file(\"/proc/self/auxv\")\n    }\n    #[cfg(not(feature = \"std_detect_file_io\"))]\n    {\n        Err(())\n    }\n}\n\n/// Tries to read the `key` from the auxiliary vector by calling the\n/// dynamically-linked `getauxval` function. If the function is not linked,\n/// this function return `Err`.\n#[cfg(feature = \"std_detect_dlsym_getauxval\")]\nfn getauxval(key: usize) -> Result<usize, ()> {\n    use libc;\n    pub type F = unsafe extern \"C\" fn(usize) -> usize;\n    unsafe {\n        let ptr = libc::dlsym(libc::RTLD_DEFAULT, \"getauxval\\0\".as_ptr() as *const _);\n        if ptr.is_null() {\n            return Err(());\n        }\n\n        let ffi_getauxval: F = core::mem::transmute(ptr);\n        Ok(ffi_getauxval(key))\n    }\n}\n\n/// Tries to read the auxiliary vector from the `file`. If this fails, this\n/// function returns `Err`.\n#[cfg(feature = \"std_detect_file_io\")]\nfn auxv_from_file(file: &str) -> Result<AuxVec, ()> {\n    let file = super::read_file(file)?;\n\n    // See <https://github.com/torvalds/linux/blob/v3.19/include/uapi/linux/auxvec.h>.\n    //\n    // The auxiliary vector contains at most 32 (key,value) fields: from\n    // `AT_EXECFN = 31` to `AT_NULL = 0`. That is, a buffer of\n    // 2*32 `usize` elements is enough to read the whole vector.\n    let mut buf = [0_usize; 64];\n    let len = core::mem::size_of_val(&buf).max(file.len());\n    unsafe {\n        core::ptr::copy_nonoverlapping(file.as_ptr(), buf.as_mut_ptr() as *mut u8, len);\n    }\n\n    auxv_from_buf(&buf)\n}\n\n/// Tries to interpret the `buffer` as an auxiliary vector. If that fails, this\n/// function returns `Err`.\n#[cfg(feature = \"std_detect_file_io\")]\nfn auxv_from_buf(buf: &[usize; 64]) -> Result<AuxVec, ()> {\n    // Targets with only AT_HWCAP:\n    #[cfg(any(target_arch = \"aarch64\", target_arch = \"mips\", target_arch = \"mips64\"))]\n    {\n        for el in buf.chunks(2) {\n            match el[0] {\n                AT_NULL => break,\n                AT_HWCAP => return Ok(AuxVec { hwcap: el[1] }),\n                _ => (),\n            }\n        }\n    }\n    // Targets with AT_HWCAP and AT_HWCAP2:\n    #[cfg(any(\n        target_arch = \"arm\",\n        target_arch = \"powerpc\",\n        target_arch = \"powerpc64\"\n    ))]\n    {\n        let mut hwcap = None;\n        let mut hwcap2 = None;\n        for el in buf.chunks(2) {\n            match el[0] {\n                AT_NULL => break,\n                AT_HWCAP => hwcap = Some(el[1]),\n                AT_HWCAP2 => hwcap2 = Some(el[1]),\n                _ => (),\n            }\n        }\n\n        if let (Some(hwcap), Some(hwcap2)) = (hwcap, hwcap2) {\n            return Ok(AuxVec { hwcap, hwcap2 });\n        }\n    }\n    drop(buf);\n    Err(())\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate auxv as auxv_crate;\n    use super::*;\n\n    // Reads the Auxiliary Vector key from /proc/self/auxv\n    // using the auxv crate.\n    #[cfg(feature = \"std_detect_file_io\")]\n    fn auxv_crate_getprocfs(key: usize) -> Option<usize> {\n        use self::auxv_crate::procfs::search_procfs_auxv;\n        use self::auxv_crate::AuxvType;\n        let k = key as AuxvType;\n        match search_procfs_auxv(&[k]) {\n            Ok(v) => Some(v[&k] as usize),\n            Err(_) => None,\n        }\n    }\n\n    // Reads the Auxiliary Vector key from getauxval()\n    // using the auxv crate.\n    #[cfg(not(any(target_arch = \"mips\", target_arch = \"mips64\")))]\n    fn auxv_crate_getauxval(key: usize) -> Option<usize> {\n        use self::auxv_crate::getauxval::Getauxval;\n        use self::auxv_crate::AuxvType;\n        let q = auxv_crate::getauxval::NativeGetauxval {};\n        match q.getauxval(key as AuxvType) {\n            Ok(v) => Some(v as usize),\n            Err(_) => None,\n        }\n    }\n\n    // FIXME: on mips/mips64 getauxval returns 0, and /proc/self/auxv\n    // does not always contain the AT_HWCAP key under qemu.\n    #[cfg(any(\n        target_arch = \"aarch64\",\n        target_arch = \"arm\",\n        target_arch = \"powerpc\",\n        target_arch = \"powerpc64\"\n    ))]\n    #[test]\n    fn auxv_crate() {\n        let v = auxv();\n        if let Some(hwcap) = auxv_crate_getauxval(AT_HWCAP) {\n            let rt_hwcap = v.expect(\"failed to find hwcap key\").hwcap;\n            assert_eq!(rt_hwcap, hwcap);\n        }\n\n        // Targets with AT_HWCAP and AT_HWCAP2:\n        #[cfg(any(\n            target_arch = \"arm\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\"\n        ))]\n        {\n            if let Some(hwcap2) = auxv_crate_getauxval(AT_HWCAP2) {\n                let rt_hwcap2 = v.expect(\"failed to find hwcap2 key\").hwcap2;\n                assert_eq!(rt_hwcap2, hwcap2);\n            }\n        }\n    }\n\n    #[test]\n    fn auxv_dump() {\n        if let Ok(auxvec) = auxv() {\n            println!(\"{:?}\", auxvec);\n        } else {\n            println!(\"both getauxval() and reading /proc/self/auxv failed!\");\n        }\n    }\n\n    #[cfg(feature = \"std_detect_file_io\")]\n    cfg_if::cfg_if! {\n        if #[cfg(target_arch = \"arm\")] {\n            #[test]\n            fn linux_rpi3() {\n                let file = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/detect/test_data/linux-rpi3.auxv\");\n                println!(\"file: {}\", file);\n                let v = auxv_from_file(file).unwrap();\n                assert_eq!(v.hwcap, 4174038);\n                assert_eq!(v.hwcap2, 16);\n            }\n\n            #[test]\n            #[should_panic]\n            fn linux_macos_vb() {\n                let file = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/detect/test_data/macos-virtualbox-linux-x86-4850HQ.auxv\");\n                println!(\"file: {}\", file);\n                let v = auxv_from_file(file).unwrap();\n                // this file is incomplete (contains hwcap but not hwcap2), we\n                // want to fall back to /proc/cpuinfo in this case, so\n                // reading should fail. assert_eq!(v.hwcap, 126614527);\n                // assert_eq!(v.hwcap2, 0);\n                let _ = v;\n            }\n        } else if #[cfg(target_arch = \"aarch64\")] {\n            #[test]\n            fn linux_x64() {\n                let file = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/detect/test_data/linux-x64-i7-6850k.auxv\");\n                println!(\"file: {}\", file);\n                let v = auxv_from_file(file).unwrap();\n                assert_eq!(v.hwcap, 3219913727);\n            }\n        }\n    }\n\n    #[test]\n    #[cfg(feature = \"std_detect_file_io\")]\n    fn auxv_dump_procfs() {\n        if let Ok(auxvec) = auxv_from_file(\"/proc/self/auxv\") {\n            println!(\"{:?}\", auxvec);\n        } else {\n            println!(\"reading /proc/self/auxv failed!\");\n        }\n    }\n\n    #[cfg(any(\n        target_arch = \"aarch64\",\n        target_arch = \"arm\",\n        target_arch = \"powerpc\",\n        target_arch = \"powerpc64\"\n    ))]\n    #[test]\n    #[cfg(feature = \"std_detect_file_io\")]\n    fn auxv_crate_procfs() {\n        let v = auxv();\n        if let Some(hwcap) = auxv_crate_getprocfs(AT_HWCAP) {\n            assert_eq!(v.unwrap().hwcap, hwcap);\n        }\n\n        // Targets with AT_HWCAP and AT_HWCAP2:\n        #[cfg(any(\n            target_arch = \"arm\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\"\n        ))]\n        {\n            if let Some(hwcap2) = auxv_crate_getprocfs(AT_HWCAP2) {\n                assert_eq!(v.unwrap().hwcap2, hwcap2);\n            }\n        }\n    }\n}\n"],["2615","//! Run-time feature detection for Aarch64 on Linux.\n\nuse super::auxvec;\nuse crate::detect::{bit, cache, Feature};\n\n/// Try to read the features from the auxiliary vector, and if that fails, try\n/// to read them from /proc/cpuinfo.\npub(crate) fn detect_features() -> cache::Initializer {\n    if let Ok(auxv) = auxvec::auxv() {\n        let hwcap: AtHwcap = auxv.into();\n        return hwcap.cache();\n    }\n    #[cfg(feature = \"std_detect_file_io\")]\n    if let Ok(c) = super::cpuinfo::CpuInfo::new() {\n        let hwcap: AtHwcap = c.into();\n        return hwcap.cache();\n    }\n    cache::Initializer::default()\n}\n\n/// These values are part of the platform-specific [asm/hwcap.h][hwcap] .\n///\n/// The names match those used for cpuinfo.\n///\n/// [hwcap]: https://github.com/torvalds/linux/blob/master/arch/arm64/include/uapi/asm/hwcap.h\nstruct AtHwcap {\n    fp: bool,    // 0\n    asimd: bool, // 1\n    // evtstrm: bool, // 2 No LLVM support\n    aes: bool,     // 3\n    pmull: bool,   // 4\n    sha1: bool,    // 5\n    sha2: bool,    // 6\n    crc32: bool,   // 7\n    atomics: bool, // 8\n    fphp: bool,    // 9\n    asimdhp: bool, // 10\n    // cpuid: bool, // 11 No LLVM support\n    asimdrdm: bool, // 12\n    jscvt: bool,    // 13\n    fcma: bool,     // 14\n    lrcpc: bool,    // 15\n    dcpop: bool,    // 16\n    sha3: bool,     // 17\n    sm3: bool,      // 18\n    sm4: bool,      // 19\n    asimddp: bool,  // 20\n    sha512: bool,   // 21\n    sve: bool,      // 22\n    fhm: bool,      // 23\n    dit: bool,      // 24\n    uscat: bool,    // 25\n    ilrcpc: bool,   // 26\n    flagm: bool,    // 27\n    ssbs: bool,     // 28\n    sb: bool,       // 29\n    paca: bool,     // 30\n    pacg: bool,     // 31\n    dcpodp: bool,   // 32\n    sve2: bool,     // 33\n    sveaes: bool,   // 34\n    // svepmull: bool, // 35 No LLVM support\n    svebitperm: bool, // 36\n    svesha3: bool,    // 37\n    svesm4: bool,     // 38\n    // flagm2: bool, // 39 No LLVM support\n    frint: bool, // 40\n    // svei8mm: bool, // 41 See i8mm feature\n    svef32mm: bool, // 42\n    svef64mm: bool, // 43\n    // svebf16: bool, // 44 See bf16 feature\n    i8mm: bool, // 45\n    bf16: bool, // 46\n    // dgh: bool, // 47 No LLVM support\n    rng: bool, // 48\n    bti: bool, // 49\n    mte: bool, // 50\n}\n\nimpl From<auxvec::AuxVec> for AtHwcap {\n    /// Reads AtHwcap from the auxiliary vector.\n    fn from(auxv: auxvec::AuxVec) -> Self {\n        AtHwcap {\n            fp: bit::test(auxv.hwcap, 0),\n            asimd: bit::test(auxv.hwcap, 1),\n            // evtstrm: bit::test(auxv.hwcap, 2),\n            aes: bit::test(auxv.hwcap, 3),\n            pmull: bit::test(auxv.hwcap, 4),\n            sha1: bit::test(auxv.hwcap, 5),\n            sha2: bit::test(auxv.hwcap, 6),\n            crc32: bit::test(auxv.hwcap, 7),\n            atomics: bit::test(auxv.hwcap, 8),\n            fphp: bit::test(auxv.hwcap, 9),\n            asimdhp: bit::test(auxv.hwcap, 10),\n            // cpuid: bit::test(auxv.hwcap, 11),\n            asimdrdm: bit::test(auxv.hwcap, 12),\n            jscvt: bit::test(auxv.hwcap, 13),\n            fcma: bit::test(auxv.hwcap, 14),\n            lrcpc: bit::test(auxv.hwcap, 15),\n            dcpop: bit::test(auxv.hwcap, 16),\n            sha3: bit::test(auxv.hwcap, 17),\n            sm3: bit::test(auxv.hwcap, 18),\n            sm4: bit::test(auxv.hwcap, 19),\n            asimddp: bit::test(auxv.hwcap, 20),\n            sha512: bit::test(auxv.hwcap, 21),\n            sve: bit::test(auxv.hwcap, 22),\n            fhm: bit::test(auxv.hwcap, 23),\n            dit: bit::test(auxv.hwcap, 24),\n            uscat: bit::test(auxv.hwcap, 25),\n            ilrcpc: bit::test(auxv.hwcap, 26),\n            flagm: bit::test(auxv.hwcap, 27),\n            ssbs: bit::test(auxv.hwcap, 28),\n            sb: bit::test(auxv.hwcap, 29),\n            paca: bit::test(auxv.hwcap, 30),\n            pacg: bit::test(auxv.hwcap, 31),\n            dcpodp: bit::test(auxv.hwcap, 32),\n            sve2: bit::test(auxv.hwcap, 33),\n            sveaes: bit::test(auxv.hwcap, 34),\n            // svepmull: bit::test(auxv.hwcap, 35),\n            svebitperm: bit::test(auxv.hwcap, 36),\n            svesha3: bit::test(auxv.hwcap, 37),\n            svesm4: bit::test(auxv.hwcap, 38),\n            // flagm2: bit::test(auxv.hwcap, 39),\n            frint: bit::test(auxv.hwcap, 40),\n            // svei8mm: bit::test(auxv.hwcap, 41),\n            svef32mm: bit::test(auxv.hwcap, 42),\n            svef64mm: bit::test(auxv.hwcap, 43),\n            // svebf16: bit::test(auxv.hwcap, 44),\n            i8mm: bit::test(auxv.hwcap, 45),\n            bf16: bit::test(auxv.hwcap, 46),\n            // dgh: bit::test(auxv.hwcap, 47),\n            rng: bit::test(auxv.hwcap, 48),\n            bti: bit::test(auxv.hwcap, 49),\n            mte: bit::test(auxv.hwcap, 50),\n        }\n    }\n}\n\n#[cfg(feature = \"std_detect_file_io\")]\nimpl From<super::cpuinfo::CpuInfo> for AtHwcap {\n    /// Reads AtHwcap from /proc/cpuinfo .\n    fn from(c: super::cpuinfo::CpuInfo) -> Self {\n        let f = &c.field(\"Features\");\n        AtHwcap {\n            // 64-bit names. FIXME: In 32-bit compatibility mode /proc/cpuinfo will\n            // map some of the 64-bit names to some 32-bit feature names. This does not\n            // cover that yet.\n            fp: f.has(\"fp\"),\n            asimd: f.has(\"asimd\"),\n            // evtstrm: f.has(\"evtstrm\"),\n            aes: f.has(\"aes\"),\n            pmull: f.has(\"pmull\"),\n            sha1: f.has(\"sha1\"),\n            sha2: f.has(\"sha2\"),\n            crc32: f.has(\"crc32\"),\n            atomics: f.has(\"atomics\"),\n            fphp: f.has(\"fphp\"),\n            asimdhp: f.has(\"asimdhp\"),\n            // cpuid: f.has(\"cpuid\"),\n            asimdrdm: f.has(\"asimdrdm\"),\n            jscvt: f.has(\"jscvt\"),\n            fcma: f.has(\"fcma\"),\n            lrcpc: f.has(\"lrcpc\"),\n            dcpop: f.has(\"dcpop\"),\n            sha3: f.has(\"sha3\"),\n            sm3: f.has(\"sm3\"),\n            sm4: f.has(\"sm4\"),\n            asimddp: f.has(\"asimddp\"),\n            sha512: f.has(\"sha512\"),\n            sve: f.has(\"sve\"),\n            fhm: f.has(\"asimdfhm\"),\n            dit: f.has(\"dit\"),\n            uscat: f.has(\"uscat\"),\n            ilrcpc: f.has(\"ilrcpc\"),\n            flagm: f.has(\"flagm\"),\n            ssbs: f.has(\"ssbs\"),\n            sb: f.has(\"sb\"),\n            paca: f.has(\"paca\"),\n            pacg: f.has(\"pacg\"),\n            dcpodp: f.has(\"dcpodp\"),\n            sve2: f.has(\"sve2\"),\n            sveaes: f.has(\"sveaes\"),\n            // svepmull: f.has(\"svepmull\"),\n            svebitperm: f.has(\"svebitperm\"),\n            svesha3: f.has(\"svesha3\"),\n            svesm4: f.has(\"svesm4\"),\n            // flagm2: f.has(\"flagm2\"),\n            frint: f.has(\"frint\"),\n            // svei8mm: f.has(\"svei8mm\"),\n            svef32mm: f.has(\"svef32mm\"),\n            svef64mm: f.has(\"svef64mm\"),\n            // svebf16: f.has(\"svebf16\"),\n            i8mm: f.has(\"i8mm\"),\n            bf16: f.has(\"bf16\"),\n            // dgh: f.has(\"dgh\"),\n            rng: f.has(\"rng\"),\n            bti: f.has(\"bti\"),\n            mte: f.has(\"mte\"),\n        }\n    }\n}\n\nimpl AtHwcap {\n    /// Initializes the cache from the feature -bits.\n    ///\n    /// The feature dependencies here come directly from LLVM's feature definintions:\n    /// https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/AArch64/AArch64.td\n    fn cache(self) -> cache::Initializer {\n        let mut value = cache::Initializer::default();\n        {\n            let mut enable_feature = |f, enable| {\n                if enable {\n                    value.set(f as u32);\n                }\n            };\n\n            enable_feature(Feature::fp, self.fp);\n            // Half-float support requires float support\n            enable_feature(Feature::fp16, self.fp && self.fphp);\n            // FHM (fp16fml in LLVM) requires half float support\n            enable_feature(Feature::fhm, self.fphp && self.fhm);\n            enable_feature(Feature::pmull, self.pmull);\n            enable_feature(Feature::crc, self.crc32);\n            enable_feature(Feature::lse, self.atomics);\n            enable_feature(Feature::lse2, self.uscat);\n            enable_feature(Feature::rcpc, self.lrcpc);\n            // RCPC2 (rcpc-immo in LLVM) requires RCPC support\n            enable_feature(Feature::rcpc2, self.ilrcpc && self.lrcpc);\n            enable_feature(Feature::dit, self.dit);\n            enable_feature(Feature::flagm, self.flagm);\n            enable_feature(Feature::ssbs, self.ssbs);\n            enable_feature(Feature::sb, self.sb);\n            // FEAT_PAuth provides both paca & pacg\n            enable_feature(Feature::pauth, self.paca && self.pacg);\n            enable_feature(Feature::dpb, self.dcpop);\n            enable_feature(Feature::dpb2, self.dcpodp);\n            enable_feature(Feature::rand, self.rng);\n            enable_feature(Feature::bti, self.bti);\n            enable_feature(Feature::mte, self.mte);\n            // jsconv requires float support\n            enable_feature(Feature::jsconv, self.jscvt && self.fp);\n            enable_feature(Feature::rdm, self.asimdrdm);\n            enable_feature(Feature::dotprod, self.asimddp);\n            enable_feature(Feature::frintts, self.frint);\n\n            // FEAT_I8MM & FEAT_BF16 also include optional SVE components which linux exposes\n            // separately. We ignore that distinction here.\n            enable_feature(Feature::i8mm, self.i8mm);\n            enable_feature(Feature::bf16, self.bf16);\n\n            // ASIMD support requires float support - if half-floats are\n            // supported, it also requires half-float support:\n            let asimd = self.fp && self.asimd && (!self.fphp | self.asimdhp);\n            enable_feature(Feature::asimd, asimd);\n            // ASIMD extensions require ASIMD support:\n            enable_feature(Feature::fcma, self.fcma && asimd);\n            enable_feature(Feature::sve, self.sve && asimd);\n\n            // SVE extensions require SVE & ASIMD\n            enable_feature(Feature::f32mm, self.svef32mm && self.sve && asimd);\n            enable_feature(Feature::f64mm, self.svef64mm && self.sve && asimd);\n\n            // Cryptographic extensions require ASIMD\n            enable_feature(Feature::aes, self.aes && asimd);\n            enable_feature(Feature::sha2, self.sha1 && self.sha2 && asimd);\n            // SHA512/SHA3 require SHA1 & SHA256\n            enable_feature(\n                Feature::sha3,\n                self.sha512 && self.sha3 && self.sha1 && self.sha2 && asimd,\n            );\n            enable_feature(Feature::sm4, self.sm3 && self.sm4 && asimd);\n\n            // SVE2 requires SVE\n            let sve2 = self.sve2 && self.sve && asimd;\n            enable_feature(Feature::sve2, sve2);\n            // SVE2 extensions require SVE2 and crypto features\n            enable_feature(Feature::sve2_aes, self.sveaes && sve2 && self.aes);\n            enable_feature(\n                Feature::sve2_sm4,\n                self.svesm4 && sve2 && self.sm3 && self.sm4,\n            );\n            enable_feature(\n                Feature::sve2_sha3,\n                self.svesha3 && sve2 && self.sha512 && self.sha3 && self.sha1 && self.sha2,\n            );\n            enable_feature(Feature::sve2_bitperm, self.svebitperm && self.sve2);\n        }\n        value\n    }\n}\n"],["2616","//! Parses /proc/cpuinfo\n#![cfg_attr(not(target_arch = \"arm\"), allow(dead_code))]\n\nuse alloc::string::String;\n\n/// cpuinfo\npub(crate) struct CpuInfo {\n    raw: String,\n}\n\nimpl CpuInfo {\n    /// Reads /proc/cpuinfo into CpuInfo.\n    pub(crate) fn new() -> Result<Self, ()> {\n        let raw = super::read_file(\"/proc/cpuinfo\")?;\n        Ok(Self {\n            raw: String::from_utf8(raw).map_err(|_| ())?,\n        })\n    }\n    /// Returns the value of the cpuinfo `field`.\n    pub(crate) fn field(&self, field: &str) -> CpuInfoField<'_> {\n        for l in self.raw.lines() {\n            if l.trim().starts_with(field) {\n                return CpuInfoField::new(l.split(\": \").nth(1));\n            }\n        }\n        CpuInfoField(None)\n    }\n\n    /// Returns the `raw` contents of `/proc/cpuinfo`\n    #[cfg(test)]\n    fn raw(&self) -> &String {\n        &self.raw\n    }\n\n    #[cfg(test)]\n    fn from_str(other: &str) -> Result<Self, ()> {\n        Ok(Self {\n            raw: String::from(other),\n        })\n    }\n}\n\n/// Field of cpuinfo\n#[derive(Debug)]\npub(crate) struct CpuInfoField<'a>(Option<&'a str>);\n\nimpl<'a> PartialEq<&'a str> for CpuInfoField<'a> {\n    fn eq(&self, other: &&'a str) -> bool {\n        match self.0 {\n            None => other.is_empty(),\n            Some(f) => f == other.trim(),\n        }\n    }\n}\n\nimpl<'a> CpuInfoField<'a> {\n    pub(crate) fn new<'b>(v: Option<&'b str>) -> CpuInfoField<'b> {\n        match v {\n            None => CpuInfoField::<'b>(None),\n            Some(f) => CpuInfoField::<'b>(Some(f.trim())),\n        }\n    }\n    /// Does the field exist?\n    #[cfg(test)]\n    pub(crate) fn exists(&self) -> bool {\n        self.0.is_some()\n    }\n    /// Does the field contain `other`?\n    pub(crate) fn has(&self, other: &str) -> bool {\n        match self.0 {\n            None => other.is_empty(),\n            Some(f) => {\n                let other = other.trim();\n                for v in f.split(' ') {\n                    if v == other {\n                        return true;\n                    }\n                }\n                false\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn raw_dump() {\n        let cpuinfo = CpuInfo::new().unwrap();\n        if cpuinfo.field(\"vendor_id\") == \"GenuineIntel\" {\n            assert!(cpuinfo.field(\"flags\").exists());\n            assert!(!cpuinfo.field(\"vendor33_id\").exists());\n            assert!(cpuinfo.field(\"flags\").has(\"sse\"));\n            assert!(!cpuinfo.field(\"flags\").has(\"avx314\"));\n        }\n        println!(\"{}\", cpuinfo.raw());\n    }\n\n    const CORE_DUO_T6500: &str = r\"processor       : 0\nvendor_id       : GenuineIntel\ncpu family      : 6\nmodel           : 23\nmodel name      : Intel(R) Core(TM)2 Duo CPU     T6500  @ 2.10GHz\nstepping        : 10\nmicrocode       : 0xa0b\ncpu MHz         : 1600.000\ncache size      : 2048 KB\nphysical id     : 0\nsiblings        : 2\ncore id         : 0\ncpu cores       : 2\napicid          : 0\ninitial apicid  : 0\nfdiv_bug        : no\nhlt_bug         : no\nf00f_bug        : no\ncoma_bug        : no\nfpu             : yes\nfpu_exception   : yes\ncpuid level     : 13\nwp              : yes\nflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe nx lm constant_tsc arch_perfmon pebs bts aperfmperf pni dtes64 monitor ds_cpl est tm2 ssse3 cx16 xtpr pdcm sse4_1 xsave lahf_lm dtherm\nbogomips        : 4190.43\nclflush size    : 64\ncache_alignment : 64\naddress sizes   : 36 bits physical, 48 bits virtual\npower management:\n\";\n\n    #[test]\n    fn core_duo_t6500() {\n        let cpuinfo = CpuInfo::from_str(CORE_DUO_T6500).unwrap();\n        assert_eq!(cpuinfo.field(\"vendor_id\"), \"GenuineIntel\");\n        assert_eq!(cpuinfo.field(\"cpu family\"), \"6\");\n        assert_eq!(cpuinfo.field(\"model\"), \"23\");\n        assert_eq!(\n            cpuinfo.field(\"model name\"),\n            \"Intel(R) Core(TM)2 Duo CPU     T6500  @ 2.10GHz\"\n        );\n        assert_eq!(\n            cpuinfo.field(\"flags\"),\n            \"fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe nx lm constant_tsc arch_perfmon pebs bts aperfmperf pni dtes64 monitor ds_cpl est tm2 ssse3 cx16 xtpr pdcm sse4_1 xsave lahf_lm dtherm\"\n        );\n        assert!(cpuinfo.field(\"flags\").has(\"fpu\"));\n        assert!(cpuinfo.field(\"flags\").has(\"dtherm\"));\n        assert!(cpuinfo.field(\"flags\").has(\"sse2\"));\n        assert!(!cpuinfo.field(\"flags\").has(\"avx\"));\n    }\n\n    const ARM_CORTEX_A53: &str = r\"Processor   : AArch64 Processor rev 3 (aarch64)\n        processor   : 0\n        processor   : 1\n        processor   : 2\n        processor   : 3\n        processor   : 4\n        processor   : 5\n        processor   : 6\n        processor   : 7\n        Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32\n        CPU implementer : 0x41\n        CPU architecture: AArch64\n        CPU variant : 0x0\n        CPU part    : 0xd03\n        CPU revision    : 3\n\n        Hardware    : HiKey Development Board\n        \";\n\n    #[test]\n    fn arm_cortex_a53() {\n        let cpuinfo = CpuInfo::from_str(ARM_CORTEX_A53).unwrap();\n        assert_eq!(\n            cpuinfo.field(\"Processor\"),\n            \"AArch64 Processor rev 3 (aarch64)\"\n        );\n        assert_eq!(\n            cpuinfo.field(\"Features\"),\n            \"fp asimd evtstrm aes pmull sha1 sha2 crc32\"\n        );\n        assert!(cpuinfo.field(\"Features\").has(\"pmull\"));\n        assert!(!cpuinfo.field(\"Features\").has(\"neon\"));\n        assert!(cpuinfo.field(\"Features\").has(\"asimd\"));\n    }\n\n    const ARM_CORTEX_A57: &str = r\"Processor\t: Cortex A57 Processor rev 1 (aarch64)\nprocessor\t: 0\nprocessor\t: 1\nprocessor\t: 2\nprocessor\t: 3\nFeatures\t: fp asimd aes pmull sha1 sha2 crc32 wp half thumb fastmult vfp edsp neon vfpv3 tlsi vfpv4 idiva idivt\nCPU implementer\t: 0x41\nCPU architecture: 8\nCPU variant\t: 0x1\nCPU part\t: 0xd07\nCPU revision\t: 1\";\n\n    #[test]\n    fn arm_cortex_a57() {\n        let cpuinfo = CpuInfo::from_str(ARM_CORTEX_A57).unwrap();\n        assert_eq!(\n            cpuinfo.field(\"Processor\"),\n            \"Cortex A57 Processor rev 1 (aarch64)\"\n        );\n        assert_eq!(\n            cpuinfo.field(\"Features\"),\n            \"fp asimd aes pmull sha1 sha2 crc32 wp half thumb fastmult vfp edsp neon vfpv3 tlsi vfpv4 idiva idivt\"\n        );\n        assert!(cpuinfo.field(\"Features\").has(\"pmull\"));\n        assert!(cpuinfo.field(\"Features\").has(\"neon\"));\n        assert!(cpuinfo.field(\"Features\").has(\"asimd\"));\n    }\n\n    const POWER8E_POWERKVM: &str = r\"processor       : 0\ncpu             : POWER8E (raw), altivec supported\nclock           : 3425.000000MHz\nrevision        : 2.1 (pvr 004b 0201)\n\nprocessor       : 1\ncpu             : POWER8E (raw), altivec supported\nclock           : 3425.000000MHz\nrevision        : 2.1 (pvr 004b 0201)\n\nprocessor       : 2\ncpu             : POWER8E (raw), altivec supported\nclock           : 3425.000000MHz\nrevision        : 2.1 (pvr 004b 0201)\n\nprocessor       : 3\ncpu             : POWER8E (raw), altivec supported\nclock           : 3425.000000MHz\nrevision        : 2.1 (pvr 004b 0201)\n\ntimebase        : 512000000\nplatform        : pSeries\nmodel           : IBM pSeries (emulated by qemu)\nmachine         : CHRP IBM pSeries (emulated by qemu)\";\n\n    #[test]\n    fn power8_powerkvm() {\n        let cpuinfo = CpuInfo::from_str(POWER8E_POWERKVM).unwrap();\n        assert_eq!(cpuinfo.field(\"cpu\"), \"POWER8E (raw), altivec supported\");\n\n        assert!(cpuinfo.field(\"cpu\").has(\"altivec\"));\n    }\n\n    const POWER5P: &str = r\"processor       : 0\ncpu             : POWER5+ (gs)\nclock           : 1900.098000MHz\nrevision        : 2.1 (pvr 003b 0201)\n\nprocessor       : 1\ncpu             : POWER5+ (gs)\nclock           : 1900.098000MHz\nrevision        : 2.1 (pvr 003b 0201)\n\nprocessor       : 2\ncpu             : POWER5+ (gs)\nclock           : 1900.098000MHz\nrevision        : 2.1 (pvr 003b 0201)\n\nprocessor       : 3\ncpu             : POWER5+ (gs)\nclock           : 1900.098000MHz\nrevision        : 2.1 (pvr 003b 0201)\n\nprocessor       : 4\ncpu             : POWER5+ (gs)\nclock           : 1900.098000MHz\nrevision        : 2.1 (pvr 003b 0201)\n\nprocessor       : 5\ncpu             : POWER5+ (gs)\nclock           : 1900.098000MHz\nrevision        : 2.1 (pvr 003b 0201)\n\nprocessor       : 6\ncpu             : POWER5+ (gs)\nclock           : 1900.098000MHz\nrevision        : 2.1 (pvr 003b 0201)\n\nprocessor       : 7\ncpu             : POWER5+ (gs)\nclock           : 1900.098000MHz\nrevision        : 2.1 (pvr 003b 0201)\n\ntimebase        : 237331000\nplatform        : pSeries\nmachine         : CHRP IBM,9133-55A\";\n\n    #[test]\n    fn power5p() {\n        let cpuinfo = CpuInfo::from_str(POWER5P).unwrap();\n        assert_eq!(cpuinfo.field(\"cpu\"), \"POWER5+ (gs)\");\n\n        assert!(!cpuinfo.field(\"cpu\").has(\"altivec\"));\n    }\n}\n"],["2617","//! Run-time feature detection for ARM on Linux.\n\nuse super::auxvec;\nuse crate::detect::{bit, cache, Feature};\n\n/// Try to read the features from the auxiliary vector, and if that fails, try\n/// to read them from /proc/cpuinfo.\npub(crate) fn detect_features() -> cache::Initializer {\n    let mut value = cache::Initializer::default();\n    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n        if enable {\n            value.set(f as u32);\n        }\n    };\n\n    // The values are part of the platform-specific [asm/hwcap.h][hwcap]\n    //\n    // [hwcap]: https://github.com/torvalds/linux/blob/master/arch/arm/include/uapi/asm/hwcap.h\n    if let Ok(auxv) = auxvec::auxv() {\n        enable_feature(&mut value, Feature::neon, bit::test(auxv.hwcap, 12));\n        enable_feature(&mut value, Feature::pmull, bit::test(auxv.hwcap2, 1));\n        enable_feature(&mut value, Feature::crc, bit::test(auxv.hwcap2, 4));\n        enable_feature(\n            &mut value,\n            Feature::crypto,\n            bit::test(auxv.hwcap2, 0)\n                && bit::test(auxv.hwcap2, 1)\n                && bit::test(auxv.hwcap2, 2)\n                && bit::test(auxv.hwcap2, 3),\n        );\n        enable_feature(&mut value, Feature::aes, bit::test(auxv.hwcap2, 0));\n        // SHA2 requires SHA1 & SHA2 features\n        enable_feature(\n            &mut value,\n            Feature::sha2,\n            bit::test(auxv.hwcap2, 2) && bit::test(auxv.hwcap2, 3),\n        );\n        return value;\n    }\n\n    #[cfg(feature = \"std_detect_file_io\")]\n    if let Ok(c) = super::cpuinfo::CpuInfo::new() {\n        enable_feature(\n            &mut value,\n            Feature::neon,\n            c.field(\"Features\").has(\"neon\") && !has_broken_neon(&c),\n        );\n        enable_feature(&mut value, Feature::pmull, c.field(\"Features\").has(\"pmull\"));\n        enable_feature(&mut value, Feature::crc, c.field(\"Features\").has(\"crc32\"));\n        enable_feature(\n            &mut value,\n            Feature::crypto,\n            c.field(\"Features\").has(\"aes\")\n                && c.field(\"Features\").has(\"pmull\")\n                && c.field(\"Features\").has(\"sha1\")\n                && c.field(\"Features\").has(\"sha2\"),\n        );\n        enable_feature(&mut value, Feature::aes, c.field(\"Features\").has(\"aes\"));\n        enable_feature(\n            &mut value,\n            Feature::sha2,\n            c.field(\"Features\").has(\"sha1\") && c.field(\"Features\").has(\"sha2\"),\n        );\n        return value;\n    }\n    value\n}\n\n/// Is the CPU known to have a broken NEON unit?\n///\n/// See https://crbug.com/341598.\n#[cfg(feature = \"std_detect_file_io\")]\nfn has_broken_neon(cpuinfo: &super::cpuinfo::CpuInfo) -> bool {\n    cpuinfo.field(\"CPU implementer\") == \"0x51\"\n        && cpuinfo.field(\"CPU architecture\") == \"7\"\n        && cpuinfo.field(\"CPU variant\") == \"0x1\"\n        && cpuinfo.field(\"CPU part\") == \"0x04d\"\n        && cpuinfo.field(\"CPU revision\") == \"0\"\n}\n"],["2618","//! Run-time feature detection for PowerPC on Linux.\n\nuse super::auxvec;\nuse crate::detect::{cache, Feature};\n\n/// Try to read the features from the auxiliary vector, and if that fails, try\n/// to read them from /proc/cpuinfo.\npub(crate) fn detect_features() -> cache::Initializer {\n    let mut value = cache::Initializer::default();\n    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n        if enable {\n            value.set(f as u32);\n        }\n    };\n\n    // The values are part of the platform-specific [asm/cputable.h][cputable]\n    //\n    // [cputable]: https://github.com/torvalds/linux/blob/master/arch/powerpc/include/uapi/asm/cputable.h\n    if let Ok(auxv) = auxvec::auxv() {\n        // note: the PowerPC values are the mask to do the test (instead of the\n        // index of the bit to test like in ARM and Aarch64)\n        enable_feature(&mut value, Feature::altivec, auxv.hwcap & 0x10000000 != 0);\n        enable_feature(&mut value, Feature::vsx, auxv.hwcap & 0x00000080 != 0);\n        enable_feature(&mut value, Feature::power8, auxv.hwcap2 & 0x80000000 != 0);\n        return value;\n    }\n\n    // PowerPC's /proc/cpuinfo lacks a proper Feature field,\n    // but `altivec` support is indicated in the `cpu` field.\n    #[cfg(feature = \"std_detect_file_io\")]\n    if let Ok(c) = super::cpuinfo::CpuInfo::new() {\n        enable_feature(&mut value, Feature::altivec, c.field(\"cpu\").has(\"altivec\"));\n        return value;\n    }\n    value\n}\n"],["2619","//! The `is_{target_arch}_feature_detected!` macro are only available on their\n//! architecture. These macros provide a better error messages when the user\n//! attempts to call them in a different architecture.\n\n/// Prevents compilation if `is_x86_feature_detected` is used somewhere\n/// else than `x86` and `x86_64` targets.\n#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n#[macro_export]\n#[unstable(feature = \"stdsimd\", issue = \"27731\")]\nmacro_rules! is_x86_feature_detected {\n    ($t: tt) => {\n        compile_error!(\n            r#\"\n        is_x86_feature_detected can only be used on x86 and x86_64 targets.\n        You can prevent it from being used in other architectures by\n        guarding it behind a cfg(target_arch) as follows:\n\n            #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n                if is_x86_feature_detected(...) { ... }\n            }\n        \"#\n        )\n    };\n}\n\n/// Prevents compilation if `is_arm_feature_detected` is used somewhere else\n/// than `ARM` targets.\n#[cfg(not(target_arch = \"arm\"))]\n#[macro_export]\n#[unstable(feature = \"stdsimd\", issue = \"27731\")]\nmacro_rules! is_arm_feature_detected {\n    ($t:tt) => {\n        compile_error!(\n            r#\"\n        is_arm_feature_detected can only be used on ARM targets.\n        You can prevent it from being used in other architectures by\n        guarding it behind a cfg(target_arch) as follows:\n\n            #[cfg(target_arch = \"arm\")] {\n                if is_arm_feature_detected(...) { ... }\n            }\n        \"#\n        )\n    };\n}\n\n/// Prevents compilation if `is_aarch64_feature_detected` is used somewhere else\n/// than `aarch64` targets.\n#[cfg(not(target_arch = \"aarch64\"))]\n#[macro_export]\n#[unstable(feature = \"stdsimd\", issue = \"27731\")]\nmacro_rules! is_aarch64_feature_detected {\n    ($t: tt) => {\n        compile_error!(\n            r#\"\n        is_aarch64_feature_detected can only be used on AArch64 targets.\n        You can prevent it from being used in other architectures by\n        guarding it behind a cfg(target_arch) as follows:\n\n            #[cfg(target_arch = \"aarch64\")] {\n                if is_aarch64_feature_detected(...) { ... }\n            }\n        \"#\n        )\n    };\n}\n\n/// Prevents compilation if `is_powerpc_feature_detected` is used somewhere else\n/// than `PowerPC` targets.\n#[cfg(not(target_arch = \"powerpc\"))]\n#[macro_export]\n#[unstable(feature = \"stdsimd\", issue = \"27731\")]\nmacro_rules! is_powerpc_feature_detected {\n    ($t:tt) => {\n        compile_error!(\n            r#\"\nis_powerpc_feature_detected can only be used on PowerPC targets.\nYou can prevent it from being used in other architectures by\nguarding it behind a cfg(target_arch) as follows:\n\n    #[cfg(target_arch = \"powerpc\")] {\n        if is_powerpc_feature_detected(...) { ... }\n    }\n\"#\n        )\n    };\n}\n\n/// Prevents compilation if `is_powerpc64_feature_detected` is used somewhere\n/// else than `PowerPC64` targets.\n#[cfg(not(target_arch = \"powerpc64\"))]\n#[macro_export]\n#[unstable(feature = \"stdsimd\", issue = \"27731\")]\nmacro_rules! is_powerpc64_feature_detected {\n    ($t:tt) => {\n        compile_error!(\n            r#\"\nis_powerpc64_feature_detected can only be used on PowerPC64 targets.\nYou can prevent it from being used in other architectures by\nguarding it behind a cfg(target_arch) as follows:\n\n    #[cfg(target_arch = \"powerpc64\")] {\n        if is_powerpc64_feature_detected(...) { ... }\n    }\n\"#\n        )\n    };\n}\n\n/// Prevents compilation if `is_mips_feature_detected` is used somewhere else\n/// than `MIPS` targets.\n#[cfg(not(target_arch = \"mips\"))]\n#[macro_export]\n#[unstable(feature = \"stdsimd\", issue = \"27731\")]\nmacro_rules! is_mips_feature_detected {\n    ($t:tt) => {\n        compile_error!(\n            r#\"\n        is_mips_feature_detected can only be used on MIPS targets.\n        You can prevent it from being used in other architectures by\n        guarding it behind a cfg(target_arch) as follows:\n\n            #[cfg(target_arch = \"mips\")] {\n                if is_mips_feature_detected(...) { ... }\n            }\n        \"#\n        )\n    };\n}\n\n/// Prevents compilation if `is_mips64_feature_detected` is used somewhere else\n/// than `MIPS64` targets.\n#[cfg(not(target_arch = \"mips64\"))]\n#[macro_export]\n#[unstable(feature = \"stdsimd\", issue = \"27731\")]\nmacro_rules! is_mips64_feature_detected {\n    ($t:tt) => {\n        compile_error!(\n            r#\"\n        is_mips64_feature_detected can only be used on MIPS64 targets.\n        You can prevent it from being used in other architectures by\n        guarding it behind a cfg(target_arch) as follows:\n\n            #[cfg(target_arch = \"mips64\")] {\n                if is_mips64_feature_detected(...) { ... }\n            }\n        \"#\n        )\n    };\n}\n"],["2620","//! Caches run-time feature detection so that it only needs to be computed\n//! once.\n\n#![allow(dead_code)] // not used on all platforms\n\nuse core::sync::atomic::Ordering;\n\nuse core::sync::atomic::AtomicUsize;\n\n/// Sets the `bit` of `x`.\n#[inline]\nconst fn set_bit(x: u64, bit: u32) -> u64 {\n    x | 1 << bit\n}\n\n/// Tests the `bit` of `x`.\n#[inline]\nconst fn test_bit(x: u64, bit: u32) -> bool {\n    x & (1 << bit) != 0\n}\n\n/// Unset the `bit of `x`.\n#[inline]\nconst fn unset_bit(x: u64, bit: u32) -> u64 {\n    x & !(1 << bit)\n}\n\n/// Maximum number of features that can be cached.\nconst CACHE_CAPACITY: u32 = 62;\n\n/// This type is used to initialize the cache\n#[derive(Copy, Clone)]\npub(crate) struct Initializer(u64);\n\n#[allow(clippy::use_self)]\nimpl Default for Initializer {\n    fn default() -> Self {\n        Initializer(0)\n    }\n}\n\n// NOTE: the `debug_assert!` would catch that we do not add more Features than\n// the one fitting our cache.\nimpl Initializer {\n    /// Tests the `bit` of the cache.\n    #[inline]\n    pub(crate) fn test(self, bit: u32) -> bool {\n        debug_assert!(\n            bit < CACHE_CAPACITY,\n            \"too many features, time to increase the cache size!\"\n        );\n        test_bit(self.0, bit)\n    }\n\n    /// Sets the `bit` of the cache.\n    #[inline]\n    pub(crate) fn set(&mut self, bit: u32) {\n        debug_assert!(\n            bit < CACHE_CAPACITY,\n            \"too many features, time to increase the cache size!\"\n        );\n        let v = self.0;\n        self.0 = set_bit(v, bit);\n    }\n\n    /// Unsets the `bit` of the cache.\n    #[inline]\n    pub(crate) fn unset(&mut self, bit: u32) {\n        debug_assert!(\n            bit < CACHE_CAPACITY,\n            \"too many features, time to increase the cache size!\"\n        );\n        let v = self.0;\n        self.0 = unset_bit(v, bit);\n    }\n}\n\n/// This global variable is a cache of the features supported by the CPU.\n// Note: on x64, we only use the first slot\nstatic CACHE: [Cache; 2] = [Cache::uninitialized(), Cache::uninitialized()];\n\n/// Feature cache with capacity for `size_of::<usize::MAX>() * 8 - 1` features.\n///\n/// Note: 0 is used to represent an uninitialized cache, and (at least) the most\n/// significant bit is set on any cache which has been initialized.\n///\n/// Note: we use `Relaxed` atomic operations, because we are only interested in\n/// the effects of operations on a single memory location. That is, we only need\n/// \"modification order\", and not the full-blown \"happens before\".\nstruct Cache(AtomicUsize);\n\nimpl Cache {\n    const CAPACITY: u32 = (core::mem::size_of::<usize>() * 8 - 1) as u32;\n    const MASK: usize = (1 << Cache::CAPACITY) - 1;\n    const INITIALIZED_BIT: usize = 1usize << Cache::CAPACITY;\n\n    /// Creates an uninitialized cache.\n    #[allow(clippy::declare_interior_mutable_const)]\n    const fn uninitialized() -> Self {\n        Cache(AtomicUsize::new(0))\n    }\n\n    /// Is the `bit` in the cache set? Returns `None` if the cache has not been initialized.\n    #[inline]\n    pub(crate) fn test(&self, bit: u32) -> Option<bool> {\n        let cached = self.0.load(Ordering::Relaxed);\n        if cached == 0 {\n            None\n        } else {\n            Some(test_bit(cached as u64, bit))\n        }\n    }\n\n    /// Initializes the cache.\n    #[inline]\n    fn initialize(&self, value: usize) -> usize {\n        debug_assert_eq!((value & !Cache::MASK), 0);\n        self.0\n            .store(value | Cache::INITIALIZED_BIT, Ordering::Relaxed);\n        value\n    }\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(feature = \"std_detect_env_override\")] {\n        #[inline]\n        fn initialize(mut value: Initializer) -> Initializer {\n            let env = unsafe {\n                libc::getenv(b\"RUST_STD_DETECT_UNSTABLE\\0\".as_ptr() as *const libc::c_char)\n            };\n            if !env.is_null() {\n                let len = unsafe { libc::strlen(env) };\n                let env = unsafe { core::slice::from_raw_parts(env as *const u8, len) };\n                if let Ok(disable) = core::str::from_utf8(env) {\n                    for v in disable.split(\" \") {\n                        let _ = super::Feature::from_str(v).map(|v| value.unset(v as u32));\n                    }\n                }\n            }\n            do_initialize(value);\n            value\n        }\n    } else {\n        #[inline]\n        fn initialize(value: Initializer) -> Initializer {\n            do_initialize(value);\n            value\n        }\n    }\n}\n\n#[inline]\nfn do_initialize(value: Initializer) {\n    CACHE[0].initialize((value.0) as usize & Cache::MASK);\n    CACHE[1].initialize((value.0 >> Cache::CAPACITY) as usize & Cache::MASK);\n}\n\n// We only have to detect features once, and it's fairly costly, so hint to LLVM\n// that it should assume that cache hits are more common than misses (which is\n// the point of caching). It's possibly unfortunate that this function needs to\n// reach across modules like this to call `os::detect_features`, but it produces\n// the best code out of several attempted variants.\n//\n// The `Initializer` that the cache was initialized with is returned, so that\n// the caller can call `test()` on it without having to load the value from the\n// cache again.\n#[cold]\nfn detect_and_initialize() -> Initializer {\n    initialize(super::os::detect_features())\n}\n\n/// Tests the `bit` of the storage. If the storage has not been initialized,\n/// initializes it with the result of `os::detect_features()`.\n///\n/// On its first invocation, it detects the CPU features and caches them in the\n/// `CACHE` global variable as an `AtomicU64`.\n///\n/// It uses the `Feature` variant to index into this variable as a bitset. If\n/// the bit is set, the feature is enabled, and otherwise it is disabled.\n///\n/// If the feature `std_detect_env_override` is enabled looks for the env\n/// variable `RUST_STD_DETECT_UNSTABLE` and uses its its content to disable\n/// Features that would had been otherwise detected.\n#[inline]\npub(crate) fn test(bit: u32) -> bool {\n    let (relative_bit, idx) = if bit < Cache::CAPACITY {\n        (bit, 0)\n    } else {\n        (bit - Cache::CAPACITY, 1)\n    };\n    CACHE[idx]\n        .test(relative_bit)\n        .unwrap_or_else(|| detect_and_initialize().test(bit))\n}\n"],["2621","//! This module implements run-time feature detection.\n//!\n//! The `is_{arch}_feature_detected!(\"feature-name\")` macros take the name of a\n//! feature as a string-literal, and return a boolean indicating whether the\n//! feature is enabled at run-time or not.\n//!\n//! These macros do two things:\n//! * map the string-literal into an integer stored as a `Feature` enum,\n//! * call a `os::check_for(x: Feature)` function that returns `true` if the\n//! feature is enabled.\n//!\n//! The `Feature` enums are also implemented in the `arch/{target_arch}.rs`\n//! modules.\n//!\n//! The `check_for` functions are, in general, Operating System dependent. Most\n//! architectures do not allow user-space programs to query the feature bits\n//! due to security concerns (x86 is the big exception). These functions are\n//! implemented in the `os/{target_os}.rs` modules.\n\nuse cfg_if::cfg_if;\n\n#[macro_use]\nmod error_macros;\n\n#[macro_use]\nmod macros;\n\ncfg_if! {\n    if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n        #[path = \"arch/x86.rs\"]\n        #[macro_use]\n        mod arch;\n    } else if #[cfg(target_arch = \"arm\")] {\n        #[path = \"arch/arm.rs\"]\n        #[macro_use]\n        mod arch;\n    } else if #[cfg(target_arch = \"aarch64\")] {\n        #[path = \"arch/aarch64.rs\"]\n        #[macro_use]\n        mod arch;\n    } else if #[cfg(target_arch = \"powerpc\")] {\n        #[path = \"arch/powerpc.rs\"]\n        #[macro_use]\n        mod arch;\n    } else if #[cfg(target_arch = \"powerpc64\")] {\n        #[path = \"arch/powerpc64.rs\"]\n        #[macro_use]\n        mod arch;\n    } else if #[cfg(target_arch = \"mips\")] {\n        #[path = \"arch/mips.rs\"]\n        #[macro_use]\n        mod arch;\n    } else if #[cfg(target_arch = \"mips64\")] {\n        #[path = \"arch/mips64.rs\"]\n        #[macro_use]\n        mod arch;\n    } else {\n        // Unimplemented architecture:\n        #[allow(dead_code)]\n        mod arch {\n            #[doc(hidden)]\n            pub(crate) enum Feature {\n                Null\n            }\n            #[doc(hidden)]\n            pub mod __is_feature_detected {}\n\n            impl Feature {\n                #[doc(hidden)]\n                pub(crate) fn from_str(_s: &str) -> Result<Feature, ()> { Err(()) }\n                #[doc(hidden)]\n                pub(crate) fn to_str(self) -> &'static str { \"\" }\n            }\n        }\n    }\n}\n\n// This module needs to be public because the `is_{arch}_feature_detected!`\n// macros expand calls to items within it in user crates.\n#[doc(hidden)]\npub use self::arch::__is_feature_detected;\n\npub(crate) use self::arch::Feature;\n\nmod bit;\nmod cache;\n\ncfg_if! {\n    if #[cfg(miri)] {\n        // When running under miri all target-features that are not enabled at\n        // compile-time are reported as disabled at run-time.\n        //\n        // For features for which `cfg(target_feature)` returns true,\n        // this run-time detection logic is never called.\n        #[path = \"os/other.rs\"]\n        mod os;\n    } else if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n        // On x86/x86_64 no OS specific functionality is required.\n        #[path = \"os/x86.rs\"]\n        mod os;\n    } else if #[cfg(all(target_os = \"linux\", feature = \"libc\"))] {\n        #[path = \"os/linux/mod.rs\"]\n        mod os;\n    } else if #[cfg(all(target_os = \"freebsd\", feature = \"libc\"))] {\n        #[cfg(target_arch = \"aarch64\")]\n        #[path = \"os/aarch64.rs\"]\n        mod aarch64;\n        #[path = \"os/freebsd/mod.rs\"]\n        mod os;\n    } else if #[cfg(all(target_os = \"windows\", target_arch = \"aarch64\"))] {\n        #[path = \"os/windows/aarch64.rs\"]\n        mod os;\n    } else {\n        #[path = \"os/other.rs\"]\n        mod os;\n    }\n}\n\n/// Performs run-time feature detection.\n#[inline]\n#[allow(dead_code)]\nfn check_for(x: Feature) -> bool {\n    cache::test(x as u32)\n}\n\n/// Returns an `Iterator<Item=(&'static str, bool)>` where\n/// `Item.0` is the feature name, and `Item.1` is a `bool` which\n/// is `true` if the feature is supported by the host and `false` otherwise.\n#[unstable(feature = \"stdsimd\", issue = \"27731\")]\npub fn features() -> impl Iterator<Item = (&'static str, bool)> {\n    cfg_if! {\n        if #[cfg(any(\n            target_arch = \"x86\",\n            target_arch = \"x86_64\",\n            target_arch = \"arm\",\n            target_arch = \"aarch64\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\",\n            target_arch = \"mips\",\n            target_arch = \"mips64\",\n        ))] {\n            (0_u8..Feature::_last as u8).map(|discriminant: u8| {\n                let f: Feature = unsafe { core::mem::transmute(discriminant) };\n                let name: &'static str = f.to_str();\n                let enabled: bool = check_for(f);\n                (name, enabled)\n            })\n        } else {\n            None.into_iter()\n        }\n    }\n}\n"],["2622","//! Run-time feature detection on ARM Aarch32.\n\nfeatures! {\n    @TARGET: arm;\n    @MACRO_NAME: is_arm_feature_detected;\n    @MACRO_ATTRS:\n    /// Checks if `arm` feature is enabled.\n    #[unstable(feature = \"stdsimd\", issue = \"27731\")]\n    @NO_RUNTIME_DETECTION: \"v7\";\n    @NO_RUNTIME_DETECTION: \"vfp2\";\n    @NO_RUNTIME_DETECTION: \"vfp3\";\n    @NO_RUNTIME_DETECTION: \"vfp4\";\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] neon: \"neon\";\n    /// ARM Advanced SIMD (NEON) - Aarch32\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] pmull: \"pmull\";\n    /// Polynomial Multiply\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] crc: \"crc\";\n    /// CRC32 (Cyclic Redundancy Check)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] crypto: \"crypto\";\n    /// Crypto: AES + PMULL + SHA1 + SHA256. Prefer using the individual features where possible.\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] aes: \"aes\";\n    /// FEAT_AES (AES instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sha2: \"sha2\";\n    /// FEAT_SHA1 & FEAT_SHA256 (SHA1 & SHA2-256 instructions)\n}\n"],["2623","//! Aarch64 run-time features.\n\nfeatures! {\n    @TARGET: aarch64;\n    @MACRO_NAME: is_aarch64_feature_detected;\n    @MACRO_ATTRS:\n    /// This macro tests, at runtime, whether an `aarch64` feature is enabled on aarch64 platforms.\n    /// Currently most features are only supported on linux-based platforms.\n    ///\n    /// This macro takes one argument which is a string literal of the feature being tested for.\n    /// The feature names are mostly taken from their FEAT_* definitiions in the [ARM Architecture\n    /// Reference Manual][docs].\n    ///\n    /// ## Supported arguments\n    ///\n    /// * `\"asimd\"` or \"neon\" - FEAT_AdvSIMD\n    /// * `\"pmull\"` - FEAT_PMULL\n    /// * `\"fp\"` - FEAT_FP\n    /// * `\"fp16\"` - FEAT_FP16\n    /// * `\"sve\"` - FEAT_SVE\n    /// * `\"crc\"` - FEAT_CRC\n    /// * `\"lse\"` - FEAT_LSE\n    /// * `\"lse2\"` - FEAT_LSE2\n    /// * `\"rdm\"` - FEAT_RDM\n    /// * `\"rcpc\"` - FEAT_LRCPC\n    /// * `\"rcpc2\"` - FEAT_LRCPC2\n    /// * `\"dotprod\"` - FEAT_DotProd\n    /// * `\"tme\"` - FEAT_TME\n    /// * `\"fhm\"` - FEAT_FHM\n    /// * `\"dit\"` - FEAT_DIT\n    /// * `\"flagm\"` - FEAT_FLAGM\n    /// * `\"ssbs\"` - FEAT_SSBS\n    /// * `\"sb\"` - FEAT_SB\n    /// * `\"pauth\"` - FEAT_PAuth\n    /// * `\"dpb\"` - FEAT_DPB\n    /// * `\"dpb2\"` - FEAT_DPB2\n    /// * `\"sve2\"` - FEAT_SVE2\n    /// * `\"sve2-aes\"` - FEAT_SVE2_AES\n    /// * `\"sve2-sm4\"` - FEAT_SVE2_SM4\n    /// * `\"sve2-sha3\"` - FEAT_SVE2_SHA3\n    /// * `\"sve2-bitperm\"` - FEAT_SVE2_BitPerm\n    /// * `\"frintts\"` - FEAT_FRINTTS\n    /// * `\"i8mm\"` - FEAT_I8MM\n    /// * `\"f32mm\"` - FEAT_F32MM\n    /// * `\"f64mm\"` - FEAT_F64MM\n    /// * `\"bf16\"` - FEAT_BF16\n    /// * `\"rand\"` - FEAT_RNG\n    /// * `\"bti\"` - FEAT_BTI\n    /// * `\"mte\"` - FEAT_MTE\n    /// * `\"jsconv\"` - FEAT_JSCVT\n    /// * `\"fcma\"` - FEAT_FCMA\n    /// * `\"aes\"` - FEAT_AES\n    /// * `\"sha2\"` - FEAT_SHA1 & FEAT_SHA256\n    /// * `\"sha3\"` - FEAT_SHA512 & FEAT_SHA3\n    /// * `\"sm4\"` - FEAT_SM3 & FEAT_SM4\n    ///\n    /// [docs]: https://developer.arm.com/documentation/ddi0487/latest\n    #[unstable(feature = \"stdsimd\", issue = \"27731\")]\n    @BIND_FEATURE_NAME: \"asimd\"; \"neon\";\n    @NO_RUNTIME_DETECTION: \"ras\";\n    @NO_RUNTIME_DETECTION: \"v8.1a\";\n    @NO_RUNTIME_DETECTION: \"v8.2a\";\n    @NO_RUNTIME_DETECTION: \"v8.3a\";\n    @NO_RUNTIME_DETECTION: \"v8.4a\";\n    @NO_RUNTIME_DETECTION: \"v8.5a\";\n    @NO_RUNTIME_DETECTION: \"v8.6a\";\n    @NO_RUNTIME_DETECTION: \"v8.7a\";\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] asimd: \"neon\";\n    /// FEAT_AdvSIMD (Advanced SIMD/NEON)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] pmull: \"pmull\";\n    /// FEAT_PMULL (Polynomial Multiply)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] fp: \"fp\";\n    /// FEAT_FP (Floating point support)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] fp16: \"fp16\";\n    /// FEAT_FP16 (Half-float support)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sve: \"sve\";\n    /// FEAT_SVE (Scalable Vector Extension)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] crc: \"crc\";\n    /// FEAT_CRC32 (Cyclic Redundancy Check)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] lse: \"lse\";\n    /// FEAT_LSE (Large System Extension - atomics)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] lse2: \"lse2\";\n    /// FEAT_LSE2 (unaligned and register-pair atomics)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] rdm: \"rdm\";\n    /// FEAT_RDM (Rounding Doubling Multiply - ASIMDRDM)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] rcpc: \"rcpc\";\n    /// FEAT_LRCPC (Release consistent Processor consistent)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] rcpc2: \"rcpc2\";\n    /// FEAT_LRCPC2 (RCPC with immediate offsets)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] dotprod: \"dotprod\";\n    /// FEAT_DotProd (Vector Dot-Product - ASIMDDP)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] tme: \"tme\";\n    /// FEAT_TME (Transactional Memory Extensions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] fhm: \"fhm\";\n    /// FEAT_FHM (fp16 multiplication instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] dit: \"dit\";\n    /// FEAT_DIT (Data Independent Timing instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] flagm: \"flagm\";\n    /// FEAT_FLAGM (flag manipulation instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] ssbs: \"ssbs\";\n    /// FEAT_SSBS (speculative store bypass safe)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sb: \"sb\";\n    /// FEAT_SB (speculation barrier)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] pauth: \"pauth\";\n    /// FEAT_PAuth (pointer authentication)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] dpb: \"dpb\";\n    /// FEAT_DPB (aka dcpop - data cache clean to point of persistance)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] dpb2: \"dpb2\";\n    /// FEAT_DPB2 (aka dcpodp - data cache clean to point of deep persistance)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sve2: \"sve2\";\n    /// FEAT_SVE2 (Scalable Vector Extension 2)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sve2_aes: \"sve2-aes\";\n    /// FEAT_SVE_AES (SVE2 AES crypto)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sve2_sm4: \"sve2-sm4\";\n    /// FEAT_SVE_SM4 (SVE2 SM4 crypto)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sve2_sha3: \"sve2-sha3\";\n    /// FEAT_SVE_SHA3 (SVE2 SHA3 crypto)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sve2_bitperm: \"sve2-bitperm\";\n    /// FEAT_SVE_BitPerm (SVE2 bit permutation instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] frintts: \"frintts\";\n    /// FEAT_FRINTTS (float to integer rounding instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] i8mm: \"i8mm\";\n    /// FEAT_I8MM (integer matrix multiplication, plus ASIMD support)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] f32mm: \"f32mm\";\n    /// FEAT_F32MM (single-precision matrix multiplication)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] f64mm: \"f64mm\";\n    /// FEAT_F64MM (double-precision matrix multiplication)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] bf16: \"bf16\";\n    /// FEAT_BF16 (BFloat16 type, plus MM instructions, plus ASIMD support)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] rand: \"rand\";\n    /// FEAT_RNG (Random Number Generator)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] bti: \"bti\";\n    /// FEAT_BTI (Branch Target Identification)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] mte: \"mte\";\n    /// FEAT_MTE (Memory Tagging Extension)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] jsconv: \"jsconv\";\n    /// FEAT_JSCVT (JavaScript float conversion instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] fcma: \"fcma\";\n    /// FEAT_FCMA (float complex number operations)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] aes: \"aes\";\n    /// FEAT_AES (AES instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sha2: \"sha2\";\n    /// FEAT_SHA1 & FEAT_SHA256 (SHA1 & SHA2-256 instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sha3: \"sha3\";\n    /// FEAT_SHA512 & FEAT_SHA3 (SHA2-512 & SHA3 instructions)\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] sm4: \"sm4\";\n    /// FEAT_SM3 & FEAT_SM4 (SM3 & SM4 instructions)\n}\n"],["2624","//! Run-time feature detection on MIPS.\n\nfeatures! {\n    @TARGET: mips;\n    @MACRO_NAME: is_mips_feature_detected;\n    @MACRO_ATTRS:\n    /// Checks if `mips` feature is enabled.\n    #[unstable(feature = \"stdsimd\", issue = \"27731\")]\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] msa: \"msa\";\n    /// MIPS SIMD Architecture (MSA)\n}\n"],["2625","//! Run-time feature detection on MIPS64.\n\nfeatures! {\n    @TARGET: mips64;\n    @MACRO_NAME: is_mips64_feature_detected;\n    @MACRO_ATTRS:\n    /// Checks if `mips64` feature is enabled.\n    #[unstable(feature = \"stdsimd\", issue = \"27731\")]\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] msa: \"msa\";\n    /// MIPS SIMD Architecture (MSA)\n}\n"],["2626","//! Run-time feature detection on PowerPC64.\n\nfeatures! {\n    @TARGET: powerpc64;\n    @MACRO_NAME: is_powerpc64_feature_detected;\n    @MACRO_ATTRS:\n    /// Checks if `powerpc` feature is enabled.\n    #[unstable(feature = \"stdsimd\", issue = \"27731\")]\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] altivec: \"altivec\";\n    /// Altivec\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] vsx: \"vsx\";\n    /// VSX\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] power8: \"power8\";\n    /// Power8\n}\n"],["2627","//! Run-time feature detection on PowerPC.\n\nfeatures! {\n    @TARGET: powerpc;\n    @MACRO_NAME: is_powerpc_feature_detected;\n    @MACRO_ATTRS:\n    /// Checks if `powerpc` feature is enabled.\n    #[unstable(feature = \"stdsimd\", issue = \"27731\")]\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] altivec: \"altivec\";\n    /// Altivec\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] vsx: \"vsx\";\n    /// VSX\n    @FEATURE: #[unstable(feature = \"stdsimd\", issue = \"27731\")] power8: \"power8\";\n    /// Power8\n}\n"],["2628","//! This module implements minimal run-time feature detection for x86.\n//!\n//! The features are detected using the `detect_features` function below.\n//! This function uses the CPUID instruction to read the feature flags from the\n//! CPU and encodes them in an `usize` where each bit position represents\n//! whether a feature is available (bit is set) or unavaiable (bit is cleared).\n//!\n//! The enum `Feature` is used to map bit positions to feature names, and the\n//! the `__crate::detect::check_for!` macro is used to map string literals (e.g.,\n//! \"avx\") to these bit positions (e.g., `Feature::avx`).\n//!\n//! The run-time feature detection is performed by the\n//! `__crate::detect::check_for(Feature) -> bool` function. On its first call,\n//! this functions queries the CPU for the available features and stores them\n//! in a global `AtomicUsize` variable. The query is performed by just checking\n//! whether the feature bit in this global variable is set or cleared.\n\nfeatures! {\n    @TARGET: x86;\n    @MACRO_NAME: is_x86_feature_detected;\n    @MACRO_ATTRS:\n    /// A macro to test at *runtime* whether a CPU feature is available on\n    /// x86/x86-64 platforms.\n    ///\n    /// This macro is provided in the standard library and will detect at runtime\n    /// whether the specified CPU feature is detected. This does **not** resolve at\n    /// compile time unless the specified feature is already enabled for the entire\n    /// crate. Runtime detection currently relies mostly on the `cpuid` instruction.\n    ///\n    /// This macro only takes one argument which is a string literal of the feature\n    /// being tested for. The feature names supported are the lowercase versions of\n    /// the ones defined by Intel in [their documentation][docs].\n    ///\n    /// ## Supported arguments\n    ///\n    /// This macro supports the same names that `#[target_feature]` supports. Unlike\n    /// `#[target_feature]`, however, this macro does not support names separated\n    /// with a comma. Instead testing for multiple features must be done through\n    /// separate macro invocations for now.\n    ///\n    /// Supported arguments are:\n    ///\n    /// * `\"aes\"`\n    /// * `\"pclmulqdq\"`\n    /// * `\"rdrand\"`\n    /// * `\"rdseed\"`\n    /// * `\"tsc\"`\n    /// * `\"mmx\"`\n    /// * `\"sse\"`\n    /// * `\"sse2\"`\n    /// * `\"sse3\"`\n    /// * `\"ssse3\"`\n    /// * `\"sse4.1\"`\n    /// * `\"sse4.2\"`\n    /// * `\"sse4a\"`\n    /// * `\"sha\"`\n    /// * `\"avx\"`\n    /// * `\"avx2\"`\n    /// * `\"avx512f\"`\n    /// * `\"avx512cd\"`\n    /// * `\"avx512er\"`\n    /// * `\"avx512pf\"`\n    /// * `\"avx512bw\"`\n    /// * `\"avx512dq\"`\n    /// * `\"avx512vl\"`\n    /// * `\"avx512ifma\"`\n    /// * `\"avx512vbmi\"`\n    /// * `\"avx512vpopcntdq\"`\n    /// * `\"avx512vbmi2\"`\n    /// * `\"avx512gfni\"`\n    /// * `\"avx512vaes\"`\n    /// * `\"avx512vpclmulqdq\"`\n    /// * `\"avx512vnni\"`\n    /// * `\"avx512bitalg\"`\n    /// * `\"avx512bf16\"`\n    /// * `\"avx512vp2intersect\"`\n    /// * `\"f16c\"`\n    /// * `\"fma\"`\n    /// * `\"bmi1\"`\n    /// * `\"bmi2\"`\n    /// * `\"abm\"`\n    /// * `\"lzcnt\"`\n    /// * `\"tbm\"`\n    /// * `\"popcnt\"`\n    /// * `\"fxsr\"`\n    /// * `\"xsave\"`\n    /// * `\"xsaveopt\"`\n    /// * `\"xsaves\"`\n    /// * `\"xsavec\"`\n    /// * `\"cmpxchg16b\"`\n    /// * `\"adx\"`\n    /// * `\"rtm\"`\n    ///\n    /// [docs]: https://software.intel.com/sites/landingpage/IntrinsicsGuide\n    #[stable(feature = \"simd_x86\", since = \"1.27.0\")]\n    @BIND_FEATURE_NAME: \"abm\"; \"lzcnt\"; // abm is a synonym for lzcnt\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] aes: \"aes\";\n    /// AES (Advanced Encryption Standard New Instructions AES-NI)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] pclmulqdq: \"pclmulqdq\";\n    /// CLMUL (Carry-less Multiplication)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] rdrand: \"rdrand\";\n    /// RDRAND\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] rdseed: \"rdseed\";\n    /// RDSEED\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] tsc: \"tsc\";\n    /// TSC (Time Stamp Counter)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] mmx: \"mmx\";\n    /// MMX (MultiMedia eXtensions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] sse: \"sse\";\n    /// SSE (Streaming SIMD Extensions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] sse2: \"sse2\";\n    /// SSE2 (Streaming SIMD Extensions 2)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] sse3: \"sse3\";\n    /// SSE3 (Streaming SIMD Extensions 3)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] ssse3: \"ssse3\";\n    /// SSSE3 (Supplemental Streaming SIMD Extensions 3)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] sse4_1: \"sse4.1\";\n    /// SSE4.1 (Streaming SIMD Extensions 4.1)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] sse4_2: \"sse4.2\";\n    /// SSE4.2 (Streaming SIMD Extensions 4.2)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] sse4a: \"sse4a\";\n    /// SSE4a (Streaming SIMD Extensions 4a)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] sha: \"sha\";\n    /// SHA\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx: \"avx\";\n    /// AVX (Advanced Vector Extensions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx2: \"avx2\";\n    /// AVX2 (Advanced Vector Extensions 2)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512f: \"avx512f\" ;\n    /// AVX-512 F (Foundation)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512cd: \"avx512cd\" ;\n    /// AVX-512 CD (Conflict Detection Instructions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512er: \"avx512er\";\n    /// AVX-512 ER (Expo nential and Reciprocal Instructions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512pf: \"avx512pf\";\n    /// AVX-512 PF (Prefetch Instructions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512bw: \"avx512bw\";\n    /// AVX-512 BW (Byte and Word Instructions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512dq: \"avx512dq\";\n    /// AVX-512 DQ (Doubleword and Quadword)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512vl: \"avx512vl\";\n    /// AVX-512 VL (Vector Length Extensions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512ifma: \"avx512ifma\";\n    /// AVX-512 IFMA (Integer Fused Multiply Add)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512vbmi: \"avx512vbmi\";\n    /// AVX-512 VBMI (Vector Byte Manipulation Instructions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512vpopcntdq: \"avx512vpopcntdq\";\n    /// AVX-512 VPOPCNTDQ (Vector Population Count Doubleword and\n    /// Quadword)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512vbmi2: \"avx512vbmi2\";\n    /// AVX-512 VBMI2 (Additional byte, word, dword and qword capabilities)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512gfni: \"avx512gfni\";\n    /// AVX-512 GFNI (Galois Field New Instruction)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512vaes: \"avx512vaes\";\n    /// AVX-512 VAES (Vector AES instruction)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512vpclmulqdq: \"avx512vpclmulqdq\";\n    /// AVX-512 VPCLMULQDQ (Vector PCLMULQDQ instructions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512vnni: \"avx512vnni\";\n    /// AVX-512 VNNI (Vector Neural Network Instructions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512bitalg: \"avx512bitalg\";\n    /// AVX-512 BITALG (Support for VPOPCNT\\[B,W\\] and VPSHUFBITQMB)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512bf16: \"avx512bf16\";\n    /// AVX-512 BF16 (BFLOAT16 instructions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] avx512vp2intersect: \"avx512vp2intersect\";\n    /// AVX-512 P2INTERSECT\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] f16c: \"f16c\";\n    /// F16C (Conversions between IEEE-754 `binary16` and `binary32` formats)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] fma: \"fma\";\n    /// FMA (Fused Multiply Add)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] bmi1: \"bmi1\" ;\n    /// BMI1 (Bit Manipulation Instructions 1)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] bmi2: \"bmi2\" ;\n    /// BMI2 (Bit Manipulation Instructions 2)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] lzcnt: \"lzcnt\";\n    /// ABM (Advanced Bit Manipulation) / LZCNT (Leading Zero Count)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] tbm: \"tbm\";\n    /// TBM (Trailing Bit Manipulation)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] popcnt: \"popcnt\";\n    /// POPCNT (Population Count)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] fxsr: \"fxsr\";\n    /// FXSR (Floating-point context fast save and restor)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] xsave: \"xsave\";\n    /// XSAVE (Save Processor Extended States)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] xsaveopt: \"xsaveopt\";\n    /// XSAVEOPT (Save Processor Extended States Optimized)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] xsaves: \"xsaves\";\n    /// XSAVES (Save Processor Extended States Supervisor)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] xsavec: \"xsavec\";\n    /// XSAVEC (Save Processor Extended States Compacted)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] cmpxchg16b: \"cmpxchg16b\";\n    /// CMPXCH16B (16-byte compare-and-swap instruction)\n    @FEATURE: #[stable(feature = \"simd_x86_adx\", since = \"1.33.0\")] adx: \"adx\";\n    /// ADX, Intel ADX (Multi-Precision Add-Carry Instruction Extensions)\n    @FEATURE: #[stable(feature = \"simd_x86\", since = \"1.27.0\")] rtm: \"rtm\";\n    /// RTM, Intel (Restricted Transactional Memory)\n}\n"],["2629","#[allow(unused)]\nmacro_rules! features {\n    (\n      @TARGET: $target:ident;\n      @MACRO_NAME: $macro_name:ident;\n      @MACRO_ATTRS: $(#[$macro_attrs:meta])*\n      $(@BIND_FEATURE_NAME: $bind_feature:tt; $feature_impl:tt; )*\n      $(@NO_RUNTIME_DETECTION: $nort_feature:tt; )*\n      $(@FEATURE: #[$stability_attr:meta] $feature:ident: $feature_lit:tt; $(#[$feature_comment:meta])*)*\n    ) => {\n        #[macro_export]\n        $(#[$macro_attrs])*\n        #[allow_internal_unstable(stdsimd_internal)]\n        macro_rules! $macro_name {\n            $(\n                ($feature_lit) => {\n                    cfg!(target_feature = $feature_lit) ||\n                        $crate::detect::__is_feature_detected::$feature()\n                };\n            )*\n            $(\n                ($bind_feature) => { $macro_name!($feature_impl) };\n            )*\n            $(\n                ($nort_feature) => {\n                    compile_error!(\n                        concat!(\n                            stringify!(nort_feature),\n                            \" feature cannot be detected at run-time\"\n                        )\n                    )\n                };\n            )*\n            ($t:tt,) => {\n                    $macro_name!($t);\n            };\n            ($t:tt) => {\n                compile_error!(\n                    concat!(\n                        concat!(\"unknown \", stringify!($target)),\n                        concat!(\" target feature: \", $t)\n                    )\n                )\n            };\n        }\n\n        /// Each variant denotes a position in a bitset for a particular feature.\n        ///\n        /// PLEASE: do not use this, it is an implementation detail subject\n        /// to change.\n        #[doc(hidden)]\n        #[allow(non_camel_case_types)]\n        #[derive(Copy, Clone)]\n        #[repr(u8)]\n        #[unstable(feature = \"stdsimd_internal\", issue = \"none\")]\n        pub(crate) enum Feature {\n            $(\n                $(#[$feature_comment])*\n                $feature,\n            )*\n\n            // Do not add variants after last:\n            _last\n        }\n\n        impl Feature {\n            pub(crate) fn to_str(self) -> &'static str {\n                match self {\n                    $(Feature::$feature => $feature_lit,)*\n                    Feature::_last => unreachable!(),\n                }\n            }\n            #[cfg(feature = \"std_detect_env_override\")]\n            pub(crate) fn from_str(s: &str) -> Result<Feature, ()> {\n                match s {\n                    $($feature_lit => Ok(Feature::$feature),)*\n                    _ => Err(())\n                }\n            }\n        }\n\n        /// Each function performs run-time feature detection for a single\n        /// feature. This allow us to use stability attributes on a per feature\n        /// basis.\n        ///\n        /// PLEASE: do not use this, it is an implementation detail subject\n        /// to change.\n        #[doc(hidden)]\n        pub mod __is_feature_detected {\n            $(\n\n                /// PLEASE: do not use this, it is an implementation detail\n                /// subject to change.\n                #[inline]\n                #[doc(hidden)]\n                #[$stability_attr]\n                pub fn $feature() -> bool {\n                    $crate::detect::check_for($crate::detect::Feature::$feature)\n                }\n            )*\n        }\n    };\n}\n"],["2630","//! ncurses-compatible database discovery.\n//!\n//! Does not support hashed database, only filesystem!\n\nuse std::env;\nuse std::fs;\nuse std::path::PathBuf;\n\n#[cfg(test)]\nmod tests;\n\n/// Return path to database entry for `term`\n#[allow(deprecated)]\npub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n    let mut dirs_to_search = Vec::new();\n    let first_char = term.chars().next()?;\n\n    // Find search directory\n    if let Some(dir) = env::var_os(\"TERMINFO\") {\n        dirs_to_search.push(PathBuf::from(dir));\n    }\n\n    if let Ok(dirs) = env::var(\"TERMINFO_DIRS\") {\n        for i in dirs.split(':') {\n            if i == \"\" {\n                dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n            } else {\n                dirs_to_search.push(PathBuf::from(i));\n            }\n        }\n    } else {\n        // Found nothing in TERMINFO_DIRS, use the default paths:\n        // According to  /etc/terminfo/README, after looking at\n        // ~/.terminfo, ncurses will search /etc/terminfo, then\n        // /lib/terminfo, and eventually /usr/share/terminfo.\n        // On Haiku the database can be found at /boot/system/data/terminfo\n        if let Some(mut homedir) = env::home_dir() {\n            homedir.push(\".terminfo\");\n            dirs_to_search.push(homedir)\n        }\n\n        dirs_to_search.push(PathBuf::from(\"/etc/terminfo\"));\n        dirs_to_search.push(PathBuf::from(\"/lib/terminfo\"));\n        dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n        dirs_to_search.push(PathBuf::from(\"/boot/system/data/terminfo\"));\n    }\n\n    // Look for the terminal in all of the search directories\n    for mut p in dirs_to_search {\n        if fs::metadata(&p).is_ok() {\n            p.push(&first_char.to_string());\n            p.push(&term);\n            if fs::metadata(&p).is_ok() {\n                return Some(p);\n            }\n            p.pop();\n            p.pop();\n\n            // on some installations the dir is named after the hex of the char\n            // (e.g., macOS)\n            p.push(&format!(\"{:x}\", first_char as usize));\n            p.push(term);\n            if fs::metadata(&p).is_ok() {\n                return Some(p);\n            }\n        }\n    }\n    None\n}\n"],["2631","use super::*;\n\n#[test]\n#[ignore = \"buildbots don't have ncurses installed and I can't mock everything I need\"]\nfn test_get_dbpath_for_term() {\n    // woefully inadequate test coverage\n    // note: current tests won't work with non-standard terminfo hierarchies (e.g., macOS's)\n    use std::env;\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    fn x(t: &str) -> String {\n        let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n        p.to_str().unwrap().to_string()\n    }\n    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n    assert!(get_dbpath_for_term(\"\") == None);\n    env::set_var(\"TERMINFO_DIRS\", \":\");\n    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n    env::remove_var(\"TERMINFO_DIRS\");\n}\n"],["2632","#![allow(non_upper_case_globals, missing_docs)]\n\n//! ncurses-compatible compiled terminfo format parsing (term(5))\n\nuse super::super::TermInfo;\nuse std::collections::HashMap;\nuse std::io;\nuse std::io::prelude::*;\n\n#[cfg(test)]\nmod tests;\n\n// These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n\n#[rustfmt::skip]\npub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n    \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n    \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n    \"memory_below\", \"move_insert_mode\", \"move_standout_mode\", \"over_strike\", \"status_line_esc_ok\",\n    \"dest_tabs_magic_smso\", \"tilde_glitch\", \"transparent_underline\", \"xon_xoff\", \"needs_xon_xoff\",\n    \"prtr_silent\", \"hard_cursor\", \"non_rev_rmcup\", \"no_pad_char\", \"non_dest_scroll_region\",\n    \"can_change\", \"back_color_erase\", \"hue_lightness_saturation\", \"col_addr_glitch\",\n    \"cr_cancels_micro_mode\", \"has_print_wheel\", \"row_addr_glitch\", \"semi_auto_right_margin\",\n    \"cpi_changes_res\", \"lpi_changes_res\", \"backspaces_with_bs\", \"crt_no_scrolling\",\n    \"no_correctly_working_cr\", \"gnu_has_meta_key\", \"linefeed_is_newline\", \"has_hardware_tabs\",\n    \"return_does_clr_eol\"];\n\n#[rustfmt::skip]\npub static boolnames: &[&str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n    \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n    \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n    \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n\n#[rustfmt::skip]\npub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n    \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n    \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n    \"maximum_windows\", \"max_colors\", \"max_pairs\", \"no_color_video\", \"buffer_capacity\",\n    \"dot_vert_spacing\", \"dot_horz_spacing\", \"max_micro_address\", \"max_micro_jump\", \"micro_col_size\",\n    \"micro_line_size\", \"number_of_pins\", \"output_res_char\", \"output_res_line\",\n    \"output_res_horz_inch\", \"output_res_vert_inch\", \"print_rate\", \"wide_char_size\", \"buttons\",\n    \"bit_image_entwining\", \"bit_image_type\", \"magic_cookie_glitch_ul\", \"carriage_return_delay\",\n    \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n\n#[rustfmt::skip]\npub static numnames: &[&str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n    \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n    \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n    \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n\n#[rustfmt::skip]\npub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n    \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n    \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n    \"cursor_invisible\", \"cursor_left\", \"cursor_mem_address\", \"cursor_normal\", \"cursor_right\",\n    \"cursor_to_ll\", \"cursor_up\", \"cursor_visible\", \"delete_character\", \"delete_line\",\n    \"dis_status_line\", \"down_half_line\", \"enter_alt_charset_mode\", \"enter_blink_mode\",\n    \"enter_bold_mode\", \"enter_ca_mode\", \"enter_delete_mode\", \"enter_dim_mode\", \"enter_insert_mode\",\n    \"enter_secure_mode\", \"enter_protected_mode\", \"enter_reverse_mode\", \"enter_standout_mode\",\n    \"enter_underline_mode\", \"erase_chars\", \"exit_alt_charset_mode\", \"exit_attribute_mode\",\n    \"exit_ca_mode\", \"exit_delete_mode\", \"exit_insert_mode\", \"exit_standout_mode\",\n    \"exit_underline_mode\", \"flash_screen\", \"form_feed\", \"from_status_line\", \"init_1string\",\n    \"init_2string\", \"init_3string\", \"init_file\", \"insert_character\", \"insert_line\",\n    \"insert_padding\", \"key_backspace\", \"key_catab\", \"key_clear\", \"key_ctab\", \"key_dc\", \"key_dl\",\n    \"key_down\", \"key_eic\", \"key_eol\", \"key_eos\", \"key_f0\", \"key_f1\", \"key_f10\", \"key_f2\", \"key_f3\",\n    \"key_f4\", \"key_f5\", \"key_f6\", \"key_f7\", \"key_f8\", \"key_f9\", \"key_home\", \"key_ic\", \"key_il\",\n    \"key_left\", \"key_ll\", \"key_npage\", \"key_ppage\", \"key_right\", \"key_sf\", \"key_sr\", \"key_stab\",\n    \"key_up\", \"keypad_local\", \"keypad_xmit\", \"lab_f0\", \"lab_f1\", \"lab_f10\", \"lab_f2\", \"lab_f3\",\n    \"lab_f4\", \"lab_f5\", \"lab_f6\", \"lab_f7\", \"lab_f8\", \"lab_f9\", \"meta_off\", \"meta_on\", \"newline\",\n    \"pad_char\", \"parm_dch\", \"parm_delete_line\", \"parm_down_cursor\", \"parm_ich\", \"parm_index\",\n    \"parm_insert_line\", \"parm_left_cursor\", \"parm_right_cursor\", \"parm_rindex\", \"parm_up_cursor\",\n    \"pkey_key\", \"pkey_local\", \"pkey_xmit\", \"print_screen\", \"prtr_off\", \"prtr_on\", \"repeat_char\",\n    \"reset_1string\", \"reset_2string\", \"reset_3string\", \"reset_file\", \"restore_cursor\",\n    \"row_address\", \"save_cursor\", \"scroll_forward\", \"scroll_reverse\", \"set_attributes\", \"set_tab\",\n    \"set_window\", \"tab\", \"to_status_line\", \"underline_char\", \"up_half_line\", \"init_prog\", \"key_a1\",\n    \"key_a3\", \"key_b2\", \"key_c1\", \"key_c3\", \"prtr_non\", \"char_padding\", \"acs_chars\", \"plab_norm\",\n    \"key_btab\", \"enter_xon_mode\", \"exit_xon_mode\", \"enter_am_mode\", \"exit_am_mode\", \"xon_character\",\n    \"xoff_character\", \"ena_acs\", \"label_on\", \"label_off\", \"key_beg\", \"key_cancel\", \"key_close\",\n    \"key_command\", \"key_copy\", \"key_create\", \"key_end\", \"key_enter\", \"key_exit\", \"key_find\",\n    \"key_help\", \"key_mark\", \"key_message\", \"key_move\", \"key_next\", \"key_open\", \"key_options\",\n    \"key_previous\", \"key_print\", \"key_redo\", \"key_reference\", \"key_refresh\", \"key_replace\",\n    \"key_restart\", \"key_resume\", \"key_save\", \"key_suspend\", \"key_undo\", \"key_sbeg\", \"key_scancel\",\n    \"key_scommand\", \"key_scopy\", \"key_screate\", \"key_sdc\", \"key_sdl\", \"key_select\", \"key_send\",\n    \"key_seol\", \"key_sexit\", \"key_sfind\", \"key_shelp\", \"key_shome\", \"key_sic\", \"key_sleft\",\n    \"key_smessage\", \"key_smove\", \"key_snext\", \"key_soptions\", \"key_sprevious\", \"key_sprint\",\n    \"key_sredo\", \"key_sreplace\", \"key_sright\", \"key_srsume\", \"key_ssave\", \"key_ssuspend\",\n    \"key_sundo\", \"req_for_input\", \"key_f11\", \"key_f12\", \"key_f13\", \"key_f14\", \"key_f15\", \"key_f16\",\n    \"key_f17\", \"key_f18\", \"key_f19\", \"key_f20\", \"key_f21\", \"key_f22\", \"key_f23\", \"key_f24\",\n    \"key_f25\", \"key_f26\", \"key_f27\", \"key_f28\", \"key_f29\", \"key_f30\", \"key_f31\", \"key_f32\",\n    \"key_f33\", \"key_f34\", \"key_f35\", \"key_f36\", \"key_f37\", \"key_f38\", \"key_f39\", \"key_f40\",\n    \"key_f41\", \"key_f42\", \"key_f43\", \"key_f44\", \"key_f45\", \"key_f46\", \"key_f47\", \"key_f48\",\n    \"key_f49\", \"key_f50\", \"key_f51\", \"key_f52\", \"key_f53\", \"key_f54\", \"key_f55\", \"key_f56\",\n    \"key_f57\", \"key_f58\", \"key_f59\", \"key_f60\", \"key_f61\", \"key_f62\", \"key_f63\", \"clr_bol\",\n    \"clear_margins\", \"set_left_margin\", \"set_right_margin\", \"label_format\", \"set_clock\",\n    \"display_clock\", \"remove_clock\", \"create_window\", \"goto_window\", \"hangup\", \"dial_phone\",\n    \"quick_dial\", \"tone\", \"pulse\", \"flash_hook\", \"fixed_pause\", \"wait_tone\", \"user0\", \"user1\",\n    \"user2\", \"user3\", \"user4\", \"user5\", \"user6\", \"user7\", \"user8\", \"user9\", \"orig_pair\",\n    \"orig_colors\", \"initialize_color\", \"initialize_pair\", \"set_color_pair\", \"set_foreground\",\n    \"set_background\", \"change_char_pitch\", \"change_line_pitch\", \"change_res_horz\",\n    \"change_res_vert\", \"define_char\", \"enter_doublewide_mode\", \"enter_draft_quality\",\n    \"enter_italics_mode\", \"enter_leftward_mode\", \"enter_micro_mode\", \"enter_near_letter_quality\",\n    \"enter_normal_quality\", \"enter_shadow_mode\", \"enter_subscript_mode\", \"enter_superscript_mode\",\n    \"enter_upward_mode\", \"exit_doublewide_mode\", \"exit_italics_mode\", \"exit_leftward_mode\",\n    \"exit_micro_mode\", \"exit_shadow_mode\", \"exit_subscript_mode\", \"exit_superscript_mode\",\n    \"exit_upward_mode\", \"micro_column_address\", \"micro_down\", \"micro_left\", \"micro_right\",\n    \"micro_row_address\", \"micro_up\", \"order_of_pins\", \"parm_down_micro\", \"parm_left_micro\",\n    \"parm_right_micro\", \"parm_up_micro\", \"select_char_set\", \"set_bottom_margin\",\n    \"set_bottom_margin_parm\", \"set_left_margin_parm\", \"set_right_margin_parm\", \"set_top_margin\",\n    \"set_top_margin_parm\", \"start_bit_image\", \"start_char_set_def\", \"stop_bit_image\",\n    \"stop_char_set_def\", \"subscript_characters\", \"superscript_characters\", \"these_cause_cr\",\n    \"zero_motion\", \"char_set_names\", \"key_mouse\", \"mouse_info\", \"req_mouse_pos\", \"get_mouse\",\n    \"set_a_foreground\", \"set_a_background\", \"pkey_plab\", \"device_type\", \"code_set_init\",\n    \"set0_des_seq\", \"set1_des_seq\", \"set2_des_seq\", \"set3_des_seq\", \"set_lr_margin\",\n    \"set_tb_margin\", \"bit_image_repeat\", \"bit_image_newline\", \"bit_image_carriage_return\",\n    \"color_names\", \"define_bit_image_region\", \"end_bit_image_region\", \"set_color_band\",\n    \"set_page_length\", \"display_pc_char\", \"enter_pc_charset_mode\", \"exit_pc_charset_mode\",\n    \"enter_scancode_mode\", \"exit_scancode_mode\", \"pc_term_options\", \"scancode_escape\",\n    \"alt_scancode_esc\", \"enter_horizontal_hl_mode\", \"enter_left_hl_mode\", \"enter_low_hl_mode\",\n    \"enter_right_hl_mode\", \"enter_top_hl_mode\", \"enter_vertical_hl_mode\", \"set_a_attributes\",\n    \"set_pglen_inch\", \"termcap_init2\", \"termcap_reset\", \"linefeed_if_not_lf\", \"backspace_if_not_bs\",\n    \"other_non_function_keys\", \"arrow_key_map\", \"acs_ulcorner\", \"acs_llcorner\", \"acs_urcorner\",\n    \"acs_lrcorner\", \"acs_ltee\", \"acs_rtee\", \"acs_btee\", \"acs_ttee\", \"acs_hline\", \"acs_vline\",\n    \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n\n#[rustfmt::skip]\npub static stringnames: &[&str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n    \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n    \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\",\n    \"dim\", \"smir\", \"invis\", \"prot\", \"rev\", \"smso\", \"smul\", \"ech\", \"rmacs\", \"sgr0\", \"rmcup\", \"rmdc\",\n    \"rmir\", \"rmso\", \"rmul\", \"flash\", \"ff\", \"fsl\", \"is1\", \"is2\", \"is3\", \"if\", \"ich1\", \"il1\", \"ip\",\n    \"kbs\", \"ktbc\", \"kclr\", \"kctab\", \"_\", \"_\", \"kcud1\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"khome\", \"_\", \"_\", \"kcub1\", \"_\", \"knp\", \"kpp\", \"kcuf1\", \"_\", \"_\",\n    \"khts\", \"_\", \"rmkx\", \"smkx\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"rmm\", \"_\",\n    \"_\", \"pad\", \"dch\", \"dl\", \"cud\", \"ich\", \"indn\", \"il\", \"cub\", \"cuf\", \"rin\", \"cuu\", \"pfkey\",\n    \"pfloc\", \"pfx\", \"mc0\", \"mc4\", \"_\", \"rep\", \"rs1\", \"rs2\", \"rs3\", \"rf\", \"rc\", \"vpa\", \"sc\", \"ind\",\n    \"ri\", \"sgr\", \"_\", \"wind\", \"_\", \"tsl\", \"uc\", \"hu\", \"iprog\", \"_\", \"_\", \"_\", \"_\", \"_\", \"mc5p\",\n    \"rmp\", \"acsc\", \"pln\", \"kcbt\", \"smxon\", \"rmxon\", \"smam\", \"rmam\", \"xonc\", \"xoffc\", \"_\", \"smln\",\n    \"rmln\", \"_\", \"kcan\", \"kclo\", \"kcmd\", \"kcpy\", \"kcrt\", \"_\", \"kent\", \"kext\", \"kfnd\", \"khlp\",\n    \"kmrk\", \"kmsg\", \"kmov\", \"knxt\", \"kopn\", \"kopt\", \"kprv\", \"kprt\", \"krdo\", \"kref\", \"krfr\", \"krpl\",\n    \"krst\", \"kres\", \"ksav\", \"kspd\", \"kund\", \"kBEG\", \"kCAN\", \"kCMD\", \"kCPY\", \"kCRT\", \"_\", \"_\",\n    \"kslt\", \"kEND\", \"kEOL\", \"kEXT\", \"kFND\", \"kHLP\", \"kHOM\", \"_\", \"kLFT\", \"kMSG\", \"kMOV\", \"kNXT\",\n    \"kOPT\", \"kPRV\", \"kPRT\", \"kRDO\", \"kRPL\", \"kRIT\", \"kRES\", \"kSAV\", \"kSPD\", \"kUND\", \"rfi\", \"_\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n    \"dclk\", \"rmclk\", \"cwin\", \"wingo\", \"_\", \"dial\", \"qdial\", \"_\", \"_\", \"hook\", \"pause\", \"wait\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"op\", \"oc\", \"initc\", \"initp\", \"scp\", \"setf\",\n    \"setb\", \"cpi\", \"lpi\", \"chr\", \"cvr\", \"defc\", \"swidm\", \"sdrfq\", \"sitm\", \"slm\", \"smicm\", \"snlq\",\n    \"snrmq\", \"sshm\", \"ssubm\", \"ssupm\", \"sum\", \"rwidm\", \"ritm\", \"rlm\", \"rmicm\", \"rshm\", \"rsubm\",\n    \"rsupm\", \"rum\", \"mhpa\", \"mcud1\", \"mcub1\", \"mcuf1\", \"mvpa\", \"mcuu1\", \"porder\", \"mcud\", \"mcub\",\n    \"mcuf\", \"mcuu\", \"scs\", \"smgb\", \"smgbp\", \"smglp\", \"smgrp\", \"smgt\", \"smgtp\", \"sbim\", \"scsd\",\n    \"rbim\", \"rcsd\", \"subcs\", \"supcs\", \"docr\", \"zerom\", \"csnm\", \"kmous\", \"minfo\", \"reqmp\", \"getm\",\n    \"setaf\", \"setab\", \"pfxl\", \"devt\", \"csin\", \"s0ds\", \"s1ds\", \"s2ds\", \"s3ds\", \"smglr\", \"smgtb\",\n    \"birep\", \"binel\", \"bicr\", \"colornm\", \"defbi\", \"endbi\", \"setcolor\", \"slines\", \"dispc\", \"smpch\",\n    \"rmpch\", \"smsc\", \"rmsc\", \"pctrm\", \"scesc\", \"scesa\", \"ehhlm\", \"elhlm\", \"elohlm\", \"erhlm\",\n    \"ethlm\", \"evhlm\", \"sgr1\", \"slength\", \"OTi2\", \"OTrs\", \"OTnl\", \"OTbs\", \"OTko\", \"OTma\", \"OTG2\",\n    \"OTG3\", \"OTG1\", \"OTG4\", \"OTGR\", \"OTGL\", \"OTGU\", \"OTGD\", \"OTGH\", \"OTGV\", \"OTGC\", \"meml\", \"memu\",\n    \"box1\"];\n\nfn read_le_u16(r: &mut dyn io::Read) -> io::Result<u16> {\n    let mut b = [0; 2];\n    r.read_exact(&mut b)?;\n    Ok((b[0] as u16) | ((b[1] as u16) << 8))\n}\n\nfn read_le_u32(r: &mut dyn io::Read) -> io::Result<u32> {\n    let mut b = [0; 4];\n    r.read_exact(&mut b)?;\n    Ok((b[0] as u32) | ((b[1] as u32) << 8) | ((b[2] as u32) << 16) | ((b[3] as u32) << 24))\n}\n\nfn read_byte(r: &mut dyn io::Read) -> io::Result<u8> {\n    match r.bytes().next() {\n        Some(s) => s,\n        None => Err(io::Error::new(io::ErrorKind::Other, \"end of file\")),\n    }\n}\n\n/// Parse a compiled terminfo entry, using long capability names if `longnames`\n/// is true\npub fn parse(file: &mut dyn io::Read, longnames: bool) -> Result<TermInfo, String> {\n    macro_rules! t( ($e:expr) => (\n        match $e {\n            Ok(e) => e,\n            Err(e) => return Err(e.to_string())\n        }\n    ) );\n\n    let (bnames, snames, nnames) = if longnames {\n        (boolfnames, stringfnames, numfnames)\n    } else {\n        (boolnames, stringnames, numnames)\n    };\n\n    // Check magic number\n    let magic = t!(read_le_u16(file));\n\n    let extended = match magic {\n        0o0432 => false,\n        0o01036 => true,\n        _ => return Err(format!(\"invalid magic number, found {:o}\", magic)),\n    };\n\n    // According to the spec, these fields must be >= -1 where -1 means that the feature is not\n    // supported. Using 0 instead of -1 works because we skip sections with length 0.\n    macro_rules! read_nonneg {\n        () => {{\n            match t!(read_le_u16(file)) as i16 {\n                n if n >= 0 => n as usize,\n                -1 => 0,\n                _ => return Err(\"incompatible file: length fields must be  >= -1\".to_string()),\n            }\n        }};\n    }\n\n    let names_bytes = read_nonneg!();\n    let bools_bytes = read_nonneg!();\n    let numbers_count = read_nonneg!();\n    let string_offsets_count = read_nonneg!();\n    let string_table_bytes = read_nonneg!();\n\n    if names_bytes == 0 {\n        return Err(\"incompatible file: names field must be at least 1 byte wide\".to_string());\n    }\n\n    if bools_bytes > boolnames.len() {\n        return Err(\"incompatible file: more booleans than expected\".to_string());\n    }\n\n    if numbers_count > numnames.len() {\n        return Err(\"incompatible file: more numbers than expected\".to_string());\n    }\n\n    if string_offsets_count > stringnames.len() {\n        return Err(\"incompatible file: more string offsets than expected\".to_string());\n    }\n\n    // don't read NUL\n    let mut bytes = Vec::new();\n    t!(file.take((names_bytes - 1) as u64).read_to_end(&mut bytes));\n    let names_str = match String::from_utf8(bytes) {\n        Ok(s) => s,\n        Err(_) => return Err(\"input not utf-8\".to_string()),\n    };\n\n    let term_names: Vec<String> = names_str.split('|').map(|s| s.to_string()).collect();\n    // consume NUL\n    if t!(read_byte(file)) != b'\\0' {\n        return Err(\"incompatible file: missing null terminator for names section\".to_string());\n    }\n\n    let bools_map: HashMap<String, bool> = t! {\n        (0..bools_bytes).filter_map(|i| match read_byte(file) {\n            Err(e) => Some(Err(e)),\n            Ok(1) => Some(Ok((bnames[i].to_string(), true))),\n            Ok(_) => None\n        }).collect()\n    };\n\n    if (bools_bytes + names_bytes) % 2 == 1 {\n        t!(read_byte(file)); // compensate for padding\n    }\n\n    let numbers_map: HashMap<String, u32> = t! {\n        (0..numbers_count).filter_map(|i| {\n            let number = if extended { read_le_u32(file) } else { read_le_u16(file).map(Into::into) };\n\n            match number {\n                Ok(0xFFFF) => None,\n                Ok(n) => Some(Ok((nnames[i].to_string(), n))),\n                Err(e) => Some(Err(e))\n            }\n        }).collect()\n    };\n\n    let string_map: HashMap<String, Vec<u8>> = if string_offsets_count > 0 {\n        let string_offsets: Vec<u16> =\n            t!((0..string_offsets_count).map(|_| read_le_u16(file)).collect());\n\n        let mut string_table = Vec::new();\n        t!(file.take(string_table_bytes as u64).read_to_end(&mut string_table));\n\n        t!(string_offsets\n            .into_iter()\n            .enumerate()\n            .filter(|&(_, offset)| {\n                // non-entry\n                offset != 0xFFFF\n            })\n            .map(|(i, offset)| {\n                let offset = offset as usize;\n\n                let name = if snames[i] == \"_\" { stringfnames[i] } else { snames[i] };\n\n                if offset == 0xFFFE {\n                    // undocumented: FFFE indicates cap@, which means the capability is not present\n                    // unsure if the handling for this is correct\n                    return Ok((name.to_string(), Vec::new()));\n                }\n\n                // Find the offset of the NUL we want to go to\n                let nulpos = string_table[offset..string_table_bytes].iter().position(|&b| b == 0);\n                match nulpos {\n                    Some(len) => {\n                        Ok((name.to_string(), string_table[offset..offset + len].to_vec()))\n                    }\n                    None => Err(\"invalid file: missing NUL in string_table\".to_string()),\n                }\n            })\n            .collect())\n    } else {\n        HashMap::new()\n    };\n\n    // And that's all there is to it\n    Ok(TermInfo { names: term_names, bools: bools_map, numbers: numbers_map, strings: string_map })\n}\n\n/// Creates a dummy TermInfo struct for msys terminals\npub fn msys_terminfo() -> TermInfo {\n    let mut strings = HashMap::new();\n    strings.insert(\"sgr0\".to_string(), b\"\\x1B[0m\".to_vec());\n    strings.insert(\"bold\".to_string(), b\"\\x1B[1m\".to_vec());\n    strings.insert(\"setaf\".to_string(), b\"\\x1B[3%p1%dm\".to_vec());\n    strings.insert(\"setab\".to_string(), b\"\\x1B[4%p1%dm\".to_vec());\n\n    let mut numbers = HashMap::new();\n    numbers.insert(\"colors\".to_string(), 8);\n\n    TermInfo {\n        names: vec![\"cygwin\".to_string()], // msys is a fork of an older cygwin version\n        bools: HashMap::new(),\n        numbers,\n        strings,\n    }\n}\n"],["2633","use super::*;\n\n#[test]\nfn test_veclens() {\n    assert_eq!(boolfnames.len(), boolnames.len());\n    assert_eq!(numfnames.len(), numnames.len());\n    assert_eq!(stringfnames.len(), stringnames.len());\n}\n"],["2634","use super::*;\n\nuse std::result::Result::Ok;\n\n#[test]\nfn test_basic_setabf() {\n    let s = b\"\\\\E[48;5;%p1%dm\";\n    assert_eq!(\n        expand(s, &[Number(1)], &mut Variables::new()).unwrap(),\n        \"\\\\E[48;5;1m\".bytes().collect::<Vec<_>>()\n    );\n}\n\n#[test]\nfn test_multiple_int_constants() {\n    assert_eq!(\n        expand(b\"%{1}%{2}%d%d\", &[], &mut Variables::new()).unwrap(),\n        \"21\".bytes().collect::<Vec<_>>()\n    );\n}\n\n#[test]\nfn test_op_i() {\n    let mut vars = Variables::new();\n    assert_eq!(\n        expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\", &[Number(1), Number(2), Number(3)], &mut vars),\n        Ok(\"123233\".bytes().collect::<Vec<_>>())\n    );\n    assert_eq!(\n        expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n        Ok(\"0011\".bytes().collect::<Vec<_>>())\n    );\n}\n\n#[test]\nfn test_param_stack_failure_conditions() {\n    let mut varstruct = Variables::new();\n    let vars = &mut varstruct;\n    fn get_res(\n        fmt: &str,\n        cap: &str,\n        params: &[Param],\n        vars: &mut Variables,\n    ) -> Result<Vec<u8>, String> {\n        let mut u8v: Vec<_> = fmt.bytes().collect();\n        u8v.extend(cap.as_bytes().iter().map(|&b| b));\n        expand(&u8v, params, vars)\n    }\n\n    let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n    for &cap in caps.iter() {\n        let res = get_res(\"\", cap, &[], vars);\n        assert!(res.is_err(), \"Op {} succeeded incorrectly with 0 stack entries\", cap);\n        let p = if cap == \"%s\" || cap == \"%l\" { Words(\"foo\".to_string()) } else { Number(97) };\n        let res = get_res(\"%p1\", cap, &[p], vars);\n        assert!(res.is_ok(), \"Op {} failed with 1 stack entry: {}\", cap, res.unwrap_err());\n    }\n    let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n    for &cap in caps.iter() {\n        let res = expand(cap.as_bytes(), &[], vars);\n        assert!(res.is_err(), \"Binop {} succeeded incorrectly with 0 stack entries\", cap);\n        let res = get_res(\"%{1}\", cap, &[], vars);\n        assert!(res.is_err(), \"Binop {} succeeded incorrectly with 1 stack entry\", cap);\n        let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n        assert!(res.is_ok(), \"Binop {} failed with 2 stack entries: {}\", cap, res.unwrap_err());\n    }\n}\n\n#[test]\nfn test_push_bad_param() {\n    assert!(expand(b\"%pa\", &[], &mut Variables::new()).is_err());\n}\n\n#[test]\nfn test_comparison_ops() {\n    let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n    for &(op, bs) in v.iter() {\n        let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n        assert!(res.is_ok(), \"{}\", res.unwrap_err());\n        assert_eq!(res.unwrap(), vec![b'0' + bs[0]]);\n        let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n        assert!(res.is_ok(), \"{}\", res.unwrap_err());\n        assert_eq!(res.unwrap(), vec![b'0' + bs[1]]);\n        let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n        assert!(res.is_ok(), \"{}\", res.unwrap_err());\n        assert_eq!(res.unwrap(), vec![b'0' + bs[2]]);\n    }\n}\n\n#[test]\nfn test_conditionals() {\n    let mut vars = Variables::new();\n    let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n    let res = expand(s, &[Number(1)], &mut vars);\n    assert!(res.is_ok(), \"{}\", res.unwrap_err());\n    assert_eq!(res.unwrap(), \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n    let res = expand(s, &[Number(8)], &mut vars);\n    assert!(res.is_ok(), \"{}\", res.unwrap_err());\n    assert_eq!(res.unwrap(), \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n    let res = expand(s, &[Number(42)], &mut vars);\n    assert!(res.is_ok(), \"{}\", res.unwrap_err());\n    assert_eq!(res.unwrap(), \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n}\n\n#[test]\nfn test_format() {\n    let mut varstruct = Variables::new();\n    let vars = &mut varstruct;\n    assert_eq!(\n        expand(\n            b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n            &[\n                Words(\"foo\".to_string()),\n                Words(\"foo\".to_string()),\n                Words(\"f\".to_string()),\n                Words(\"foo\".to_string())\n            ],\n            vars\n        ),\n        Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>())\n    );\n    assert_eq!(\n        expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n        Ok(\"fo  \".bytes().collect::<Vec<_>>())\n    );\n\n    assert_eq!(\n        expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n        Ok(\"1001    1+1\".bytes().collect::<Vec<_>>())\n    );\n    assert_eq!(\n        expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\", &[Number(15), Number(27)], vars),\n        Ok(\"17017  001b0X001B\".bytes().collect::<Vec<_>>())\n    );\n}\n"],["2635","//! Parameterized string expansion\n\nuse self::Param::*;\nuse self::States::*;\n\nuse std::iter::repeat;\n\n#[cfg(test)]\nmod tests;\n\n#[derive(Clone, Copy, PartialEq)]\nenum States {\n    Nothing,\n    Percent,\n    SetVar,\n    GetVar,\n    PushParam,\n    CharConstant,\n    CharClose,\n    IntConstant(i32),\n    FormatPattern(Flags, FormatState),\n    SeekIfElse(usize),\n    SeekIfElsePercent(usize),\n    SeekIfEnd(usize),\n    SeekIfEndPercent(usize),\n}\n\n#[derive(Copy, PartialEq, Clone)]\nenum FormatState {\n    Flags,\n    Width,\n    Precision,\n}\n\n/// Types of parameters a capability can use\n#[allow(missing_docs)]\n#[derive(Clone)]\npub enum Param {\n    Words(String),\n    Number(i32),\n}\n\n/// Container for static and dynamic variable arrays\npub struct Variables {\n    /// Static variables A-Z\n    sta_va: [Param; 26],\n    /// Dynamic variables a-z\n    dyn_va: [Param; 26],\n}\n\nimpl Variables {\n    /// Returns a new zero-initialized Variables\n    pub fn new() -> Variables {\n        Variables {\n            sta_va: [\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n            ],\n            dyn_va: [\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n            ],\n        }\n    }\n}\n\n/// Expand a parameterized capability\n///\n/// # Arguments\n/// * `cap`    - string to expand\n/// * `params` - vector of params for %p1 etc\n/// * `vars`   - Variables struct for %Pa etc\n///\n/// To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n/// multiple capabilities for the same terminal.\npub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<u8>, String> {\n    let mut state = Nothing;\n\n    // expanded cap will only rarely be larger than the cap itself\n    let mut output = Vec::with_capacity(cap.len());\n\n    let mut stack: Vec<Param> = Vec::new();\n\n    // Copy parameters into a local vector for mutability\n    let mut mparams = [\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n    ];\n    for (dst, src) in mparams.iter_mut().zip(params.iter()) {\n        *dst = (*src).clone();\n    }\n\n    for &c in cap.iter() {\n        let cur = c as char;\n        let mut old_state = state;\n        match state {\n            Nothing => {\n                if cur == '%' {\n                    state = Percent;\n                } else {\n                    output.push(c);\n                }\n            }\n            Percent => {\n                match cur {\n                    '%' => {\n                        output.push(c);\n                        state = Nothing\n                    }\n                    'c' => {\n                        match stack.pop() {\n                            // if c is 0, use 0200 (128) for ncurses compatibility\n                            Some(Number(0)) => output.push(128u8),\n                            // Don't check bounds. ncurses just casts and truncates.\n                            Some(Number(c)) => output.push(c as u8),\n                            Some(_) => return Err(\"a non-char was used with %c\".to_string()),\n                            None => return Err(\"stack is empty\".to_string()),\n                        }\n                    }\n                    'p' => state = PushParam,\n                    'P' => state = SetVar,\n                    'g' => state = GetVar,\n                    '\\'' => state = CharConstant,\n                    '{' => state = IntConstant(0),\n                    'l' => match stack.pop() {\n                        Some(Words(s)) => stack.push(Number(s.len() as i32)),\n                        Some(_) => return Err(\"a non-str was used with %l\".to_string()),\n                        None => return Err(\"stack is empty\".to_string()),\n                    },\n                    '+' | '-' | '/' | '*' | '^' | '&' | '|' | 'm' => {\n                        match (stack.pop(), stack.pop()) {\n                            (Some(Number(y)), Some(Number(x))) => stack.push(Number(match cur {\n                                '+' => x + y,\n                                '-' => x - y,\n                                '*' => x * y,\n                                '/' => x / y,\n                                '|' => x | y,\n                                '&' => x & y,\n                                '^' => x ^ y,\n                                'm' => x % y,\n                                _ => unreachable!(\"All cases handled\"),\n                            })),\n                            (Some(_), Some(_)) => {\n                                return Err(format!(\"non-numbers on stack with {}\", cur));\n                            }\n                            _ => return Err(\"stack is empty\".to_string()),\n                        }\n                    }\n                    '=' | '>' | '<' | 'A' | 'O' => match (stack.pop(), stack.pop()) {\n                        (Some(Number(y)), Some(Number(x))) => stack.push(Number(\n                            if match cur {\n                                '=' => x == y,\n                                '<' => x < y,\n                                '>' => x > y,\n                                'A' => x > 0 && y > 0,\n                                'O' => x > 0 || y > 0,\n                                _ => unreachable!(),\n                            } {\n                                1\n                            } else {\n                                0\n                            },\n                        )),\n                        (Some(_), Some(_)) => {\n                            return Err(format!(\"non-numbers on stack with {}\", cur));\n                        }\n                        _ => return Err(\"stack is empty\".to_string()),\n                    },\n                    '!' | '~' => match stack.pop() {\n                        Some(Number(x)) => stack.push(Number(match cur {\n                            '!' if x > 0 => 0,\n                            '!' => 1,\n                            '~' => !x,\n                            _ => unreachable!(),\n                        })),\n                        Some(_) => return Err(format!(\"non-numbers on stack with {}\", cur)),\n                        None => return Err(\"stack is empty\".to_string()),\n                    },\n                    'i' => match (&mparams[0], &mparams[1]) {\n                        (&Number(x), &Number(y)) => {\n                            mparams[0] = Number(x + 1);\n                            mparams[1] = Number(y + 1);\n                        }\n                        _ => return Err(\"first two params not numbers with %i\".to_string()),\n                    },\n\n                    // printf-style support for %doxXs\n                    'd' | 'o' | 'x' | 'X' | 's' => {\n                        if let Some(arg) = stack.pop() {\n                            let flags = Flags::new();\n                            let res = format(arg, FormatOp::from_char(cur), flags)?;\n                            output.extend(res.iter().cloned());\n                        } else {\n                            return Err(\"stack is empty\".to_string());\n                        }\n                    }\n                    ':' | '#' | ' ' | '.' | '0'..='9' => {\n                        let mut flags = Flags::new();\n                        let mut fstate = FormatState::Flags;\n                        match cur {\n                            ':' => (),\n                            '#' => flags.alternate = true,\n                            ' ' => flags.space = true,\n                            '.' => fstate = FormatState::Precision,\n                            '0'..='9' => {\n                                flags.width = cur as usize - '0' as usize;\n                                fstate = FormatState::Width;\n                            }\n                            _ => unreachable!(),\n                        }\n                        state = FormatPattern(flags, fstate);\n                    }\n\n                    // conditionals\n                    '?' => (),\n                    't' => match stack.pop() {\n                        Some(Number(0)) => state = SeekIfElse(0),\n                        Some(Number(_)) => (),\n                        Some(_) => return Err(\"non-number on stack with conditional\".to_string()),\n                        None => return Err(\"stack is empty\".to_string()),\n                    },\n                    'e' => state = SeekIfEnd(0),\n                    ';' => (),\n                    _ => return Err(format!(\"unrecognized format option {}\", cur)),\n                }\n            }\n            PushParam => {\n                // params are 1-indexed\n                stack.push(\n                    mparams[match cur.to_digit(10) {\n                        Some(d) => d as usize - 1,\n                        None => return Err(\"bad param number\".to_string()),\n                    }]\n                    .clone(),\n                );\n            }\n            SetVar => {\n                if cur >= 'A' && cur <= 'Z' {\n                    if let Some(arg) = stack.pop() {\n                        let idx = (cur as u8) - b'A';\n                        vars.sta_va[idx as usize] = arg;\n                    } else {\n                        return Err(\"stack is empty\".to_string());\n                    }\n                } else if cur >= 'a' && cur <= 'z' {\n                    if let Some(arg) = stack.pop() {\n                        let idx = (cur as u8) - b'a';\n                        vars.dyn_va[idx as usize] = arg;\n                    } else {\n                        return Err(\"stack is empty\".to_string());\n                    }\n                } else {\n                    return Err(\"bad variable name in %P\".to_string());\n                }\n            }\n            GetVar => {\n                if cur >= 'A' && cur <= 'Z' {\n                    let idx = (cur as u8) - b'A';\n                    stack.push(vars.sta_va[idx as usize].clone());\n                } else if cur >= 'a' && cur <= 'z' {\n                    let idx = (cur as u8) - b'a';\n                    stack.push(vars.dyn_va[idx as usize].clone());\n                } else {\n                    return Err(\"bad variable name in %g\".to_string());\n                }\n            }\n            CharConstant => {\n                stack.push(Number(c as i32));\n                state = CharClose;\n            }\n            CharClose => {\n                if cur != '\\'' {\n                    return Err(\"malformed character constant\".to_string());\n                }\n            }\n            IntConstant(i) => {\n                if cur == '}' {\n                    stack.push(Number(i));\n                    state = Nothing;\n                } else if let Some(digit) = cur.to_digit(10) {\n                    match i.checked_mul(10).and_then(|i_ten| i_ten.checked_add(digit as i32)) {\n                        Some(i) => {\n                            state = IntConstant(i);\n                            old_state = Nothing;\n                        }\n                        None => return Err(\"int constant too large\".to_string()),\n                    }\n                } else {\n                    return Err(\"bad int constant\".to_string());\n                }\n            }\n            FormatPattern(ref mut flags, ref mut fstate) => {\n                old_state = Nothing;\n                match (*fstate, cur) {\n                    (_, 'd') | (_, 'o') | (_, 'x') | (_, 'X') | (_, 's') => {\n                        if let Some(arg) = stack.pop() {\n                            let res = format(arg, FormatOp::from_char(cur), *flags)?;\n                            output.extend(res.iter().cloned());\n                            // will cause state to go to Nothing\n                            old_state = FormatPattern(*flags, *fstate);\n                        } else {\n                            return Err(\"stack is empty\".to_string());\n                        }\n                    }\n                    (FormatState::Flags, '#') => {\n                        flags.alternate = true;\n                    }\n                    (FormatState::Flags, '-') => {\n                        flags.left = true;\n                    }\n                    (FormatState::Flags, '+') => {\n                        flags.sign = true;\n                    }\n                    (FormatState::Flags, ' ') => {\n                        flags.space = true;\n                    }\n                    (FormatState::Flags, '0'..='9') => {\n                        flags.width = cur as usize - '0' as usize;\n                        *fstate = FormatState::Width;\n                    }\n                    (FormatState::Flags, '.') => {\n                        *fstate = FormatState::Precision;\n                    }\n                    (FormatState::Width, '0'..='9') => {\n                        let old = flags.width;\n                        flags.width = flags.width * 10 + (cur as usize - '0' as usize);\n                        if flags.width < old {\n                            return Err(\"format width overflow\".to_string());\n                        }\n                    }\n                    (FormatState::Width, '.') => {\n                        *fstate = FormatState::Precision;\n                    }\n                    (FormatState::Precision, '0'..='9') => {\n                        let old = flags.precision;\n                        flags.precision = flags.precision * 10 + (cur as usize - '0' as usize);\n                        if flags.precision < old {\n                            return Err(\"format precision overflow\".to_string());\n                        }\n                    }\n                    _ => return Err(\"invalid format specifier\".to_string()),\n                }\n            }\n            SeekIfElse(level) => {\n                if cur == '%' {\n                    state = SeekIfElsePercent(level);\n                }\n                old_state = Nothing;\n            }\n            SeekIfElsePercent(level) => {\n                if cur == ';' {\n                    if level == 0 {\n                        state = Nothing;\n                    } else {\n                        state = SeekIfElse(level - 1);\n                    }\n                } else if cur == 'e' && level == 0 {\n                    state = Nothing;\n                } else if cur == '?' {\n                    state = SeekIfElse(level + 1);\n                } else {\n                    state = SeekIfElse(level);\n                }\n            }\n            SeekIfEnd(level) => {\n                if cur == '%' {\n                    state = SeekIfEndPercent(level);\n                }\n                old_state = Nothing;\n            }\n            SeekIfEndPercent(level) => {\n                if cur == ';' {\n                    if level == 0 {\n                        state = Nothing;\n                    } else {\n                        state = SeekIfEnd(level - 1);\n                    }\n                } else if cur == '?' {\n                    state = SeekIfEnd(level + 1);\n                } else {\n                    state = SeekIfEnd(level);\n                }\n            }\n        }\n        if state == old_state {\n            state = Nothing;\n        }\n    }\n    Ok(output)\n}\n\n#[derive(Copy, PartialEq, Clone)]\nstruct Flags {\n    width: usize,\n    precision: usize,\n    alternate: bool,\n    left: bool,\n    sign: bool,\n    space: bool,\n}\n\nimpl Flags {\n    fn new() -> Flags {\n        Flags { width: 0, precision: 0, alternate: false, left: false, sign: false, space: false }\n    }\n}\n\n#[derive(Copy, Clone)]\nenum FormatOp {\n    Digit,\n    Octal,\n    LowerHex,\n    UpperHex,\n    String,\n}\n\nimpl FormatOp {\n    fn from_char(c: char) -> FormatOp {\n        match c {\n            'd' => FormatOp::Digit,\n            'o' => FormatOp::Octal,\n            'x' => FormatOp::LowerHex,\n            'X' => FormatOp::UpperHex,\n            's' => FormatOp::String,\n            _ => panic!(\"bad FormatOp char\"),\n        }\n    }\n    fn to_char(self) -> char {\n        match self {\n            FormatOp::Digit => 'd',\n            FormatOp::Octal => 'o',\n            FormatOp::LowerHex => 'x',\n            FormatOp::UpperHex => 'X',\n            FormatOp::String => 's',\n        }\n    }\n}\n\nfn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n    let mut s = match val {\n        Number(d) => {\n            match op {\n                FormatOp::Digit => {\n                    if flags.sign {\n                        format!(\"{:+01$}\", d, flags.precision)\n                    } else if d < 0 {\n                        // C doesn't take sign into account in precision calculation.\n                        format!(\"{:01$}\", d, flags.precision + 1)\n                    } else if flags.space {\n                        format!(\" {:01$}\", d, flags.precision)\n                    } else {\n                        format!(\"{:01$}\", d, flags.precision)\n                    }\n                }\n                FormatOp::Octal => {\n                    if flags.alternate {\n                        // Leading octal zero counts against precision.\n                        format!(\"0{:01$o}\", d, flags.precision.saturating_sub(1))\n                    } else {\n                        format!(\"{:01$o}\", d, flags.precision)\n                    }\n                }\n                FormatOp::LowerHex => {\n                    if flags.alternate && d != 0 {\n                        format!(\"0x{:01$x}\", d, flags.precision)\n                    } else {\n                        format!(\"{:01$x}\", d, flags.precision)\n                    }\n                }\n                FormatOp::UpperHex => {\n                    if flags.alternate && d != 0 {\n                        format!(\"0X{:01$X}\", d, flags.precision)\n                    } else {\n                        format!(\"{:01$X}\", d, flags.precision)\n                    }\n                }\n                FormatOp::String => return Err(\"non-number on stack with %s\".to_string()),\n            }\n            .into_bytes()\n        }\n        Words(s) => match op {\n            FormatOp::String => {\n                let mut s = s.into_bytes();\n                if flags.precision > 0 && flags.precision < s.len() {\n                    s.truncate(flags.precision);\n                }\n                s\n            }\n            _ => return Err(format!(\"non-string on stack with %{}\", op.to_char())),\n        },\n    };\n    if flags.width > s.len() {\n        let n = flags.width - s.len();\n        if flags.left {\n            s.extend(repeat(b' ').take(n));\n        } else {\n            let mut s_ = Vec::with_capacity(flags.width);\n            s_.extend(repeat(b' ').take(n));\n            s_.extend(s.into_iter());\n            s = s_;\n        }\n    }\n    Ok(s)\n}\n"],["2636","//! Terminfo database interface.\n\nuse std::collections::HashMap;\nuse std::env;\nuse std::error;\nuse std::fmt;\nuse std::fs::File;\nuse std::io::{self, prelude::*, BufReader};\nuse std::path::Path;\n\nuse crate::color;\nuse crate::Attr;\nuse crate::Terminal;\n\nuse parm::{expand, Param, Variables};\nuse parser::compiled::{msys_terminfo, parse};\nuse searcher::get_dbpath_for_term;\n\n/// A parsed terminfo database entry.\n#[derive(Debug)]\npub struct TermInfo {\n    /// Names for the terminal\n    pub names: Vec<String>,\n    /// Map of capability name to boolean value\n    pub bools: HashMap<String, bool>,\n    /// Map of capability name to numeric value\n    pub numbers: HashMap<String, u32>,\n    /// Map of capability name to raw (unexpanded) string\n    pub strings: HashMap<String, Vec<u8>>,\n}\n\n/// A terminfo creation error.\n#[derive(Debug)]\npub enum Error {\n    /// TermUnset Indicates that the environment doesn't include enough information to find\n    /// the terminfo entry.\n    TermUnset,\n    /// MalformedTerminfo indicates that parsing the terminfo entry failed.\n    MalformedTerminfo(String),\n    /// io::Error forwards any io::Errors encountered when finding or reading the terminfo entry.\n    IoError(io::Error),\n}\n\nimpl error::Error for Error {\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        use Error::*;\n        match self {\n            IoError(e) => Some(e),\n            _ => None,\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use Error::*;\n        match *self {\n            TermUnset => Ok(()),\n            MalformedTerminfo(ref e) => e.fmt(f),\n            IoError(ref e) => e.fmt(f),\n        }\n    }\n}\n\nimpl TermInfo {\n    /// Creates a TermInfo based on current environment.\n    pub fn from_env() -> Result<TermInfo, Error> {\n        let term = match env::var(\"TERM\") {\n            Ok(name) => TermInfo::from_name(&name),\n            Err(..) => return Err(Error::TermUnset),\n        };\n\n        if term.is_err() && env::var(\"MSYSCON\").map_or(false, |s| \"mintty.exe\" == s) {\n            // msys terminal\n            Ok(msys_terminfo())\n        } else {\n            term\n        }\n    }\n\n    /// Creates a TermInfo for the named terminal.\n    pub fn from_name(name: &str) -> Result<TermInfo, Error> {\n        get_dbpath_for_term(name)\n            .ok_or_else(|| {\n                Error::IoError(io::Error::new(io::ErrorKind::NotFound, \"terminfo file not found\"))\n            })\n            .and_then(|p| TermInfo::from_path(&(*p)))\n    }\n\n    /// Parse the given TermInfo.\n    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<TermInfo, Error> {\n        Self::_from_path(path.as_ref())\n    }\n    // Keep the metadata small\n    fn _from_path(path: &Path) -> Result<TermInfo, Error> {\n        let file = File::open(path).map_err(Error::IoError)?;\n        let mut reader = BufReader::new(file);\n        parse(&mut reader, false).map_err(Error::MalformedTerminfo)\n    }\n}\n\npub mod searcher;\n\n/// TermInfo format parsing.\npub mod parser {\n    //! ncurses-compatible compiled terminfo format parsing (term(5))\n    pub mod compiled;\n}\npub mod parm;\n\nfn cap_for_attr(attr: Attr) -> &'static str {\n    match attr {\n        Attr::Bold => \"bold\",\n        Attr::Dim => \"dim\",\n        Attr::Italic(true) => \"sitm\",\n        Attr::Italic(false) => \"ritm\",\n        Attr::Underline(true) => \"smul\",\n        Attr::Underline(false) => \"rmul\",\n        Attr::Blink => \"blink\",\n        Attr::Standout(true) => \"smso\",\n        Attr::Standout(false) => \"rmso\",\n        Attr::Reverse => \"rev\",\n        Attr::Secure => \"invis\",\n        Attr::ForegroundColor(_) => \"setaf\",\n        Attr::BackgroundColor(_) => \"setab\",\n    }\n}\n\n/// A Terminal that knows how many colors it supports, with a reference to its\n/// parsed Terminfo database record.\npub struct TerminfoTerminal<T> {\n    num_colors: u32,\n    out: T,\n    ti: TermInfo,\n}\n\nimpl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n    type Output = T;\n    fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n        let color = self.dim_if_necessary(color);\n        if self.num_colors > color {\n            return self.apply_cap(\"setaf\", &[Param::Number(color as i32)]);\n        }\n        Ok(false)\n    }\n\n    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n        let color = self.dim_if_necessary(color);\n        if self.num_colors > color {\n            return self.apply_cap(\"setab\", &[Param::Number(color as i32)]);\n        }\n        Ok(false)\n    }\n\n    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n        match attr {\n            Attr::ForegroundColor(c) => self.fg(c),\n            Attr::BackgroundColor(c) => self.bg(c),\n            _ => self.apply_cap(cap_for_attr(attr), &[]),\n        }\n    }\n\n    fn supports_attr(&self, attr: Attr) -> bool {\n        match attr {\n            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => self.num_colors > 0,\n            _ => {\n                let cap = cap_for_attr(attr);\n                self.ti.strings.get(cap).is_some()\n            }\n        }\n    }\n\n    fn reset(&mut self) -> io::Result<bool> {\n        // are there any terminals that have color/attrs and not sgr0?\n        // Try falling back to sgr, then op\n        let cmd = match [\"sgr0\", \"sgr\", \"op\"].iter().find_map(|cap| self.ti.strings.get(*cap)) {\n            Some(op) => match expand(&op, &[], &mut Variables::new()) {\n                Ok(cmd) => cmd,\n                Err(e) => return Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n            },\n            None => return Ok(false),\n        };\n        self.out.write_all(&cmd).and(Ok(true))\n    }\n\n    fn get_ref(&self) -> &T {\n        &self.out\n    }\n\n    fn get_mut(&mut self) -> &mut T {\n        &mut self.out\n    }\n\n    fn into_inner(self) -> T\n    where\n        Self: Sized,\n    {\n        self.out\n    }\n}\n\nimpl<T: Write + Send> TerminfoTerminal<T> {\n    /// Creates a new TerminfoTerminal with the given TermInfo and Write.\n    pub fn new_with_terminfo(out: T, terminfo: TermInfo) -> TerminfoTerminal<T> {\n        let nc = if terminfo.strings.contains_key(\"setaf\") && terminfo.strings.contains_key(\"setab\")\n        {\n            terminfo.numbers.get(\"colors\").map_or(0, |&n| n)\n        } else {\n            0\n        };\n\n        TerminfoTerminal { out, ti: terminfo, num_colors: nc }\n    }\n\n    /// Creates a new TerminfoTerminal for the current environment with the given Write.\n    ///\n    /// Returns `None` when the terminfo cannot be found or parsed.\n    pub fn new(out: T) -> Option<TerminfoTerminal<T>> {\n        TermInfo::from_env().map(move |ti| TerminfoTerminal::new_with_terminfo(out, ti)).ok()\n    }\n\n    fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n        if color >= self.num_colors && color >= 8 && color < 16 { color - 8 } else { color }\n    }\n\n    fn apply_cap(&mut self, cmd: &str, params: &[Param]) -> io::Result<bool> {\n        match self.ti.strings.get(cmd) {\n            Some(cmd) => match expand(&cmd, params, &mut Variables::new()) {\n                Ok(s) => self.out.write_all(&s).and(Ok(true)),\n                Err(e) => Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n            },\n            None => Ok(false),\n        }\n    }\n}\n\nimpl<T: Write> Write for TerminfoTerminal<T> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.out.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.out.flush()\n    }\n}\n"],["2637","//! Windows console handling\n\n// FIXME (#13400): this is only a tiny fraction of the Windows console api\n\nuse std::io;\nuse std::io::prelude::*;\n\nuse crate::color;\nuse crate::Attr;\nuse crate::Terminal;\n\n/// A Terminal implementation that uses the Win32 Console API.\npub struct WinConsole<T> {\n    buf: T,\n    def_foreground: color::Color,\n    def_background: color::Color,\n    foreground: color::Color,\n    background: color::Color,\n}\n\ntype SHORT = i16;\ntype WORD = u16;\ntype DWORD = u32;\ntype BOOL = i32;\ntype HANDLE = *mut u8;\n\n#[allow(non_snake_case)]\n#[repr(C)]\nstruct SMALL_RECT {\n    Left: SHORT,\n    Top: SHORT,\n    Right: SHORT,\n    Bottom: SHORT,\n}\n\n#[allow(non_snake_case)]\n#[repr(C)]\nstruct COORD {\n    X: SHORT,\n    Y: SHORT,\n}\n\n#[allow(non_snake_case)]\n#[repr(C)]\nstruct CONSOLE_SCREEN_BUFFER_INFO {\n    dwSize: COORD,\n    dwCursorPosition: COORD,\n    wAttributes: WORD,\n    srWindow: SMALL_RECT,\n    dwMaximumWindowSize: COORD,\n}\n\n#[allow(non_snake_case)]\n#[link(name = \"kernel32\")]\nextern \"system\" {\n    fn SetConsoleTextAttribute(handle: HANDLE, attr: WORD) -> BOOL;\n    fn GetStdHandle(which: DWORD) -> HANDLE;\n    fn GetConsoleScreenBufferInfo(handle: HANDLE, info: *mut CONSOLE_SCREEN_BUFFER_INFO) -> BOOL;\n}\n\nfn color_to_bits(color: color::Color) -> u16 {\n    // magic numbers from mingw-w64's wincon.h\n\n    let bits = match color % 8 {\n        color::BLACK => 0,\n        color::BLUE => 0x1,\n        color::GREEN => 0x2,\n        color::RED => 0x4,\n        color::YELLOW => 0x2 | 0x4,\n        color::MAGENTA => 0x1 | 0x4,\n        color::CYAN => 0x1 | 0x2,\n        color::WHITE => 0x1 | 0x2 | 0x4,\n        _ => unreachable!(),\n    };\n\n    if color >= 8 { bits | 0x8 } else { bits }\n}\n\nfn bits_to_color(bits: u16) -> color::Color {\n    let color = match bits & 0x7 {\n        0 => color::BLACK,\n        0x1 => color::BLUE,\n        0x2 => color::GREEN,\n        0x4 => color::RED,\n        0x6 => color::YELLOW,\n        0x5 => color::MAGENTA,\n        0x3 => color::CYAN,\n        0x7 => color::WHITE,\n        _ => unreachable!(),\n    };\n\n    color | (u32::from(bits) & 0x8) // copy the hi-intensity bit\n}\n\nimpl<T: Write + Send + 'static> WinConsole<T> {\n    fn apply(&mut self) {\n        let _unused = self.buf.flush();\n        let mut accum: WORD = 0;\n        accum |= color_to_bits(self.foreground);\n        accum |= color_to_bits(self.background) << 4;\n\n        unsafe {\n            // Magic -11 means stdout, from\n            // https://docs.microsoft.com/en-us/windows/console/getstdhandle\n            //\n            // You may be wondering, \"but what about stderr?\", and the answer\n            // to that is that setting terminal attributes on the stdout\n            // handle also sets them for stderr, since they go to the same\n            // terminal! Admittedly, this is fragile, since stderr could be\n            // redirected to a different console. This is good enough for\n            // rustc though. See #13400.\n            let out = GetStdHandle(-11i32 as DWORD);\n            SetConsoleTextAttribute(out, accum);\n        }\n    }\n\n    /// Returns `None` whenever the terminal cannot be created for some reason.\n    pub fn new(out: T) -> io::Result<WinConsole<T>> {\n        use std::mem::MaybeUninit;\n\n        let fg;\n        let bg;\n        unsafe {\n            let mut buffer_info = MaybeUninit::<CONSOLE_SCREEN_BUFFER_INFO>::uninit();\n            if GetConsoleScreenBufferInfo(GetStdHandle(-11i32 as DWORD), buffer_info.as_mut_ptr())\n                != 0\n            {\n                let buffer_info = buffer_info.assume_init();\n                fg = bits_to_color(buffer_info.wAttributes);\n                bg = bits_to_color(buffer_info.wAttributes >> 4);\n            } else {\n                fg = color::WHITE;\n                bg = color::BLACK;\n            }\n        }\n        Ok(WinConsole {\n            buf: out,\n            def_foreground: fg,\n            def_background: bg,\n            foreground: fg,\n            background: bg,\n        })\n    }\n}\n\nimpl<T: Write> Write for WinConsole<T> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.buf.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.buf.flush()\n    }\n}\n\nimpl<T: Write + Send + 'static> Terminal for WinConsole<T> {\n    type Output = T;\n\n    fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n        self.foreground = color;\n        self.apply();\n\n        Ok(true)\n    }\n\n    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n        self.background = color;\n        self.apply();\n\n        Ok(true)\n    }\n\n    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n        match attr {\n            Attr::ForegroundColor(f) => {\n                self.foreground = f;\n                self.apply();\n                Ok(true)\n            }\n            Attr::BackgroundColor(b) => {\n                self.background = b;\n                self.apply();\n                Ok(true)\n            }\n            _ => Ok(false),\n        }\n    }\n\n    fn supports_attr(&self, attr: Attr) -> bool {\n        // it claims support for underscore and reverse video, but I can't get\n        // it to do anything -cmr\n        match attr {\n            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => true,\n            _ => false,\n        }\n    }\n\n    fn reset(&mut self) -> io::Result<bool> {\n        self.foreground = self.def_foreground;\n        self.background = self.def_background;\n        self.apply();\n\n        Ok(true)\n    }\n\n    fn get_ref(&self) -> &T {\n        &self.buf\n    }\n\n    fn get_mut(&mut self) -> &mut T {\n        &mut self.buf\n    }\n\n    fn into_inner(self) -> T\n    where\n        Self: Sized,\n    {\n        self.buf\n    }\n}\n"],["2638","//! Enums denoting options for test execution.\n\n/// Whether to execute tests concurrently or not\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub enum Concurrent {\n    Yes,\n    No,\n}\n\n/// Number of times to run a benchmarked function\n#[derive(Clone, PartialEq, Eq)]\npub enum BenchMode {\n    Auto,\n    Single,\n}\n\n/// Whether test is expected to panic or not\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\npub enum ShouldPanic {\n    No,\n    Yes,\n    YesWithMessage(&'static str),\n}\n\n/// Whether should console output be colored or not\n#[derive(Copy, Clone, Debug)]\npub enum ColorConfig {\n    AutoColor,\n    AlwaysColor,\n    NeverColor,\n}\n\n/// Format of the test results output\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub enum OutputFormat {\n    /// Verbose output\n    Pretty,\n    /// Quiet output\n    Terse,\n    /// JSON output\n    Json,\n    /// JUnit output\n    Junit,\n}\n\n/// Whether ignored test should be run or not\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub enum RunIgnored {\n    Yes,\n    No,\n    /// Run only ignored tests\n    Only,\n}\n\n#[derive(Clone, Copy)]\npub enum RunStrategy {\n    /// Runs the test in the current process, and sends the result back over the\n    /// supplied channel.\n    InProcess,\n\n    /// Spawns a subprocess to run the test, and sends the result back over the\n    /// supplied channel. Requires `argv[0]` to exist and point to the binary\n    /// that's currently running.\n    SpawnPrimary,\n}\n\n/// Options for the test run defined by the caller (instead of CLI arguments).\n/// In case we want to add other options as well, just add them in this struct.\n#[derive(Copy, Clone, Debug)]\npub struct Options {\n    pub display_output: bool,\n    pub panic_abort: bool,\n}\n\nimpl Options {\n    pub fn new() -> Options {\n        Options { display_output: false, panic_abort: false }\n    }\n\n    pub fn display_output(mut self, display_output: bool) -> Options {\n        self.display_output = display_output;\n        self\n    }\n\n    pub fn panic_abort(mut self, panic_abort: bool) -> Options {\n        self.panic_abort = panic_abort;\n        self\n    }\n}\n"],["2639","use std::any::Any;\n\nuse super::bench::BenchSamples;\nuse super::options::ShouldPanic;\nuse super::time;\nuse super::types::TestDesc;\n\npub use self::TestResult::*;\n\n// Return codes for secondary process.\n// Start somewhere other than 0 so we know the return code means what we think\n// it means.\npub const TR_OK: i32 = 50;\npub const TR_FAILED: i32 = 51;\n\n#[derive(Debug, Clone, PartialEq)]\npub enum TestResult {\n    TrOk,\n    TrFailed,\n    TrFailedMsg(String),\n    TrIgnored,\n    TrAllowedFail,\n    TrBench(BenchSamples),\n    TrTimedFail,\n}\n\n/// Creates a `TestResult` depending on the raw result of test execution\n/// and associated data.\npub fn calc_result<'a>(\n    desc: &TestDesc,\n    task_result: Result<(), &'a (dyn Any + 'static + Send)>,\n    time_opts: &Option<time::TestTimeOptions>,\n    exec_time: &Option<time::TestExecTime>,\n) -> TestResult {\n    let result = match (&desc.should_panic, task_result) {\n        (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TestResult::TrOk,\n        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n            let maybe_panic_str = err\n                .downcast_ref::<String>()\n                .map(|e| &**e)\n                .or_else(|| err.downcast_ref::<&'static str>().copied());\n\n            if maybe_panic_str.map(|e| e.contains(msg)).unwrap_or(false) {\n                TestResult::TrOk\n            } else if desc.allow_fail {\n                TestResult::TrAllowedFail\n            } else if let Some(panic_str) = maybe_panic_str {\n                TestResult::TrFailedMsg(format!(\n                    r#\"panic did not contain expected string\n      panic message: `{:?}`,\n expected substring: `{:?}`\"#,\n                    panic_str, msg\n                ))\n            } else {\n                TestResult::TrFailedMsg(format!(\n                    r#\"expected panic with string value,\n found non-string value: `{:?}`\n     expected substring: `{:?}`\"#,\n                    (**err).type_id(),\n                    msg\n                ))\n            }\n        }\n        (&ShouldPanic::Yes, Ok(())) | (&ShouldPanic::YesWithMessage(_), Ok(())) => {\n            TestResult::TrFailedMsg(\"test did not panic as expected\".to_string())\n        }\n        _ if desc.allow_fail => TestResult::TrAllowedFail,\n        _ => TestResult::TrFailed,\n    };\n\n    // If test is already failed (or allowed to fail), do not change the result.\n    if result != TestResult::TrOk {\n        return result;\n    }\n\n    // Check if test is failed due to timeout.\n    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n        if opts.error_on_excess && opts.is_critical(desc, time) {\n            return TestResult::TrTimedFail;\n        }\n    }\n\n    result\n}\n\n/// Creates a `TestResult` depending on the exit code of test subprocess.\npub fn get_result_from_exit_code(\n    desc: &TestDesc,\n    code: i32,\n    time_opts: &Option<time::TestTimeOptions>,\n    exec_time: &Option<time::TestExecTime>,\n) -> TestResult {\n    let result = match (desc.allow_fail, code) {\n        (_, TR_OK) => TestResult::TrOk,\n        (true, TR_FAILED) => TestResult::TrAllowedFail,\n        (false, TR_FAILED) => TestResult::TrFailed,\n        (_, _) => TestResult::TrFailedMsg(format!(\"got unexpected return code {}\", code)),\n    };\n\n    // If test is already failed (or allowed to fail), do not change the result.\n    if result != TestResult::TrOk {\n        return result;\n    }\n\n    // Check if test is failed due to timeout.\n    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n        if opts.error_on_excess && opts.is_critical(desc, time) {\n            return TestResult::TrTimedFail;\n        }\n    }\n\n    result\n}\n"],["2640","//! Module converting command-line arguments into test configuration.\n\nuse std::env;\nuse std::path::PathBuf;\n\nuse super::helpers::isatty;\nuse super::options::{ColorConfig, Options, OutputFormat, RunIgnored};\nuse super::time::TestTimeOptions;\n\n#[derive(Debug)]\npub struct TestOpts {\n    pub list: bool,\n    pub filters: Vec<String>,\n    pub filter_exact: bool,\n    pub force_run_in_process: bool,\n    pub exclude_should_panic: bool,\n    pub run_ignored: RunIgnored,\n    pub run_tests: bool,\n    pub bench_benchmarks: bool,\n    pub logfile: Option<PathBuf>,\n    pub nocapture: bool,\n    pub color: ColorConfig,\n    pub format: OutputFormat,\n    pub test_threads: Option<usize>,\n    pub skip: Vec<String>,\n    pub time_options: Option<TestTimeOptions>,\n    pub options: Options,\n}\n\nimpl TestOpts {\n    pub fn use_color(&self) -> bool {\n        match self.color {\n            ColorConfig::AutoColor => !self.nocapture && isatty::stdout_isatty(),\n            ColorConfig::AlwaysColor => true,\n            ColorConfig::NeverColor => false,\n        }\n    }\n}\n\n/// Result of parsing the options.\npub type OptRes = Result<TestOpts, String>;\n/// Result of parsing the option part.\ntype OptPartRes<T> = Result<T, String>;\n\nfn optgroups() -> getopts::Options {\n    let mut opts = getopts::Options::new();\n    opts.optflag(\"\", \"include-ignored\", \"Run ignored and not ignored tests\")\n        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n        .optflag(\"\", \"force-run-in-process\", \"Forces tests to run in-process when panic=abort\")\n        .optflag(\"\", \"exclude-should-panic\", \"Excludes tests marked as should_panic\")\n        .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n        .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n        .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n        .optflag(\"h\", \"help\", \"Display this message\")\n        .optopt(\"\", \"logfile\", \"Write logs to the specified file\", \"PATH\")\n        .optflag(\n            \"\",\n            \"nocapture\",\n            \"don't capture stdout/stderr of each \\\n             task, allow printing directly\",\n        )\n        .optopt(\n            \"\",\n            \"test-threads\",\n            \"Number of threads used for running tests \\\n             in parallel\",\n            \"n_threads\",\n        )\n        .optmulti(\n            \"\",\n            \"skip\",\n            \"Skip tests whose names contain FILTER (this flag can \\\n             be used multiple times)\",\n            \"FILTER\",\n        )\n        .optflag(\n            \"q\",\n            \"quiet\",\n            \"Display one character per test instead of one line. \\\n             Alias to --format=terse\",\n        )\n        .optflag(\"\", \"exact\", \"Exactly match filters rather than by substring\")\n        .optopt(\n            \"\",\n            \"color\",\n            \"Configure coloring of output:\n            auto   = colorize if stdout is a tty and tests are run on serially (default);\n            always = always colorize output;\n            never  = never colorize output;\",\n            \"auto|always|never\",\n        )\n        .optopt(\n            \"\",\n            \"format\",\n            \"Configure formatting of output:\n            pretty = Print verbose output;\n            terse  = Display one character per test;\n            json   = Output a json document;\n            junit  = Output a JUnit document\",\n            \"pretty|terse|json|junit\",\n        )\n        .optflag(\"\", \"show-output\", \"Show captured stdout of successful tests\")\n        .optopt(\n            \"Z\",\n            \"\",\n            \"Enable nightly-only flags:\n            unstable-options = Allow use of experimental features\",\n            \"unstable-options\",\n        )\n        .optflagopt(\n            \"\",\n            \"report-time\",\n            \"Show execution time of each test. Available values:\n            plain   = do not colorize the execution time (default);\n            colored = colorize output according to the `color` parameter value;\n\n            Threshold values for colorized output can be configured via\n            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n            `RUST_TEST_TIME_DOCTEST` environment variables.\n\n            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n            Durations must be specified in milliseconds, e.g. `500,2000` means that the warn time\n            is 0.5 seconds, and the critical time is 2 seconds.\n\n            Not available for --format=terse\",\n            \"plain|colored\",\n        )\n        .optflag(\n            \"\",\n            \"ensure-time\",\n            \"Treat excess of the test execution time limit as error.\n\n            Threshold values for this option can be configured via\n            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n            `RUST_TEST_TIME_DOCTEST` environment variables.\n\n            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n\n            `CRITICAL_TIME` here means the limit that should not be exceeded by test.\n            \",\n        );\n    opts\n}\n\nfn usage(binary: &str, options: &getopts::Options) {\n    let message = format!(\"Usage: {} [OPTIONS] [FILTERS...]\", binary);\n    println!(\n        r#\"{usage}\n\nThe FILTER string is tested against the name of all tests, and only those\ntests whose names contain the filter are run. Multiple filter strings may\nbe passed, which will run all tests matching any of the filters.\n\nBy default, all tests are run in parallel. This can be altered with the\n--test-threads flag or the RUST_TEST_THREADS environment variable when running\ntests (set it to 1).\n\nAll tests have their standard output and standard error captured by default.\nThis can be overridden with the --nocapture flag or setting RUST_TEST_NOCAPTURE\nenvironment variable to a value other than \"0\". Logging is not captured by default.\n\nTest Attributes:\n\n    `#[test]`        - Indicates a function is a test to be run. This function\n                       takes no arguments.\n    `#[bench]`       - Indicates a function is a benchmark to be run. This\n                       function takes one argument (test::Bencher).\n    `#[should_panic]` - This function (also labeled with `#[test]`) will only pass if\n                        the code causes a panic (an assertion failure or panic!)\n                        A message may be provided, which the failure string must\n                        contain: #[should_panic(expected = \"foo\")].\n    `#[ignore]`       - When applied to a function which is already attributed as a\n                        test, then the test runner will ignore these tests during\n                        normal test runs. Running with --ignored or --include-ignored will run\n                        these tests.\"#,\n        usage = options.usage(&message)\n    );\n}\n\n/// Parses command line arguments into test options.\n/// Returns `None` if help was requested (since we only show help message and don't run tests),\n/// returns `Some(Err(..))` if provided arguments are incorrect,\n/// otherwise creates a `TestOpts` object and returns it.\npub fn parse_opts(args: &[String]) -> Option<OptRes> {\n    // Parse matches.\n    let opts = optgroups();\n    let args = args.get(1..).unwrap_or(args);\n    let matches = match opts.parse(args) {\n        Ok(m) => m,\n        Err(f) => return Some(Err(f.to_string())),\n    };\n\n    // Check if help was requested.\n    if matches.opt_present(\"h\") {\n        // Show help and do nothing more.\n        usage(&args[0], &opts);\n        return None;\n    }\n\n    // Actually parse the opts.\n    let opts_result = parse_opts_impl(matches);\n\n    Some(opts_result)\n}\n\n// Gets the option value and checks if unstable features are enabled.\nmacro_rules! unstable_optflag {\n    ($matches:ident, $allow_unstable:ident, $option_name:literal) => {{\n        let opt = $matches.opt_present($option_name);\n        if !$allow_unstable && opt {\n            return Err(format!(\n                \"The \\\"{}\\\" flag is only accepted on the nightly compiler with -Z unstable-options\",\n                $option_name\n            ));\n        }\n\n        opt\n    }};\n}\n\n// Implementation of `parse_opts` that doesn't care about help message\n// and returns a `Result`.\nfn parse_opts_impl(matches: getopts::Matches) -> OptRes {\n    let allow_unstable = get_allow_unstable(&matches)?;\n\n    // Unstable flags\n    let force_run_in_process = unstable_optflag!(matches, allow_unstable, \"force-run-in-process\");\n    let exclude_should_panic = unstable_optflag!(matches, allow_unstable, \"exclude-should-panic\");\n    let time_options = get_time_options(&matches, allow_unstable)?;\n\n    let include_ignored = matches.opt_present(\"include-ignored\");\n    let quiet = matches.opt_present(\"quiet\");\n    let exact = matches.opt_present(\"exact\");\n    let list = matches.opt_present(\"list\");\n    let skip = matches.opt_strs(\"skip\");\n\n    let bench_benchmarks = matches.opt_present(\"bench\");\n    let run_tests = !bench_benchmarks || matches.opt_present(\"test\");\n\n    let logfile = get_log_file(&matches)?;\n    let run_ignored = get_run_ignored(&matches, include_ignored)?;\n    let filters = matches.free.clone();\n    let nocapture = get_nocapture(&matches)?;\n    let test_threads = get_test_threads(&matches)?;\n    let color = get_color_config(&matches)?;\n    let format = get_format(&matches, quiet, allow_unstable)?;\n\n    let options = Options::new().display_output(matches.opt_present(\"show-output\"));\n\n    let test_opts = TestOpts {\n        list,\n        filters,\n        filter_exact: exact,\n        force_run_in_process,\n        exclude_should_panic,\n        run_ignored,\n        run_tests,\n        bench_benchmarks,\n        logfile,\n        nocapture,\n        color,\n        format,\n        test_threads,\n        skip,\n        time_options,\n        options,\n    };\n\n    Ok(test_opts)\n}\n\n// FIXME: Copied from librustc_ast until linkage errors are resolved. Issue #47566\nfn is_nightly() -> bool {\n    // Whether this is a feature-staged build, i.e., on the beta or stable channel\n    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n    // Whether we should enable unstable features for bootstrapping\n    let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n\n    bootstrap || !disable_unstable_features\n}\n\n// Gets the CLI options associated with `report-time` feature.\nfn get_time_options(\n    matches: &getopts::Matches,\n    allow_unstable: bool,\n) -> OptPartRes<Option<TestTimeOptions>> {\n    let report_time = unstable_optflag!(matches, allow_unstable, \"report-time\");\n    let colored_opt_str = matches.opt_str(\"report-time\");\n    let mut report_time_colored = report_time && colored_opt_str == Some(\"colored\".into());\n    let ensure_test_time = unstable_optflag!(matches, allow_unstable, \"ensure-time\");\n\n    // If `ensure-test-time` option is provided, time output is enforced,\n    // so user won't be confused if any of tests will silently fail.\n    let options = if report_time || ensure_test_time {\n        if ensure_test_time && !report_time {\n            report_time_colored = true;\n        }\n        Some(TestTimeOptions::new_from_env(ensure_test_time, report_time_colored))\n    } else {\n        None\n    };\n\n    Ok(options)\n}\n\nfn get_test_threads(matches: &getopts::Matches) -> OptPartRes<Option<usize>> {\n    let test_threads = match matches.opt_str(\"test-threads\") {\n        Some(n_str) => match n_str.parse::<usize>() {\n            Ok(0) => return Err(\"argument for --test-threads must not be 0\".to_string()),\n            Ok(n) => Some(n),\n            Err(e) => {\n                return Err(format!(\n                    \"argument for --test-threads must be a number > 0 \\\n                     (error: {})\",\n                    e\n                ));\n            }\n        },\n        None => None,\n    };\n\n    Ok(test_threads)\n}\n\nfn get_format(\n    matches: &getopts::Matches,\n    quiet: bool,\n    allow_unstable: bool,\n) -> OptPartRes<OutputFormat> {\n    let format = match matches.opt_str(\"format\").as_deref() {\n        None if quiet => OutputFormat::Terse,\n        Some(\"pretty\") | None => OutputFormat::Pretty,\n        Some(\"terse\") => OutputFormat::Terse,\n        Some(\"json\") => {\n            if !allow_unstable {\n                return Err(\"The \\\"json\\\" format is only accepted on the nightly compiler\".into());\n            }\n            OutputFormat::Json\n        }\n        Some(\"junit\") => {\n            if !allow_unstable {\n                return Err(\"The \\\"junit\\\" format is only accepted on the nightly compiler\".into());\n            }\n            OutputFormat::Junit\n        }\n        Some(v) => {\n            return Err(format!(\n                \"argument for --format must be pretty, terse, json or junit (was \\\n                 {})\",\n                v\n            ));\n        }\n    };\n\n    Ok(format)\n}\n\nfn get_color_config(matches: &getopts::Matches) -> OptPartRes<ColorConfig> {\n    let color = match matches.opt_str(\"color\").as_deref() {\n        Some(\"auto\") | None => ColorConfig::AutoColor,\n        Some(\"always\") => ColorConfig::AlwaysColor,\n        Some(\"never\") => ColorConfig::NeverColor,\n\n        Some(v) => {\n            return Err(format!(\n                \"argument for --color must be auto, always, or never (was \\\n                 {})\",\n                v\n            ));\n        }\n    };\n\n    Ok(color)\n}\n\nfn get_nocapture(matches: &getopts::Matches) -> OptPartRes<bool> {\n    let mut nocapture = matches.opt_present(\"nocapture\");\n    if !nocapture {\n        nocapture = match env::var(\"RUST_TEST_NOCAPTURE\") {\n            Ok(val) => &val != \"0\",\n            Err(_) => false,\n        };\n    }\n\n    Ok(nocapture)\n}\n\nfn get_run_ignored(matches: &getopts::Matches, include_ignored: bool) -> OptPartRes<RunIgnored> {\n    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n        (true, true) => {\n            return Err(\"the options --include-ignored and --ignored are mutually exclusive\".into());\n        }\n        (true, false) => RunIgnored::Yes,\n        (false, true) => RunIgnored::Only,\n        (false, false) => RunIgnored::No,\n    };\n\n    Ok(run_ignored)\n}\n\nfn get_allow_unstable(matches: &getopts::Matches) -> OptPartRes<bool> {\n    let mut allow_unstable = false;\n\n    if let Some(opt) = matches.opt_str(\"Z\") {\n        if !is_nightly() {\n            return Err(\"the option `Z` is only accepted on the nightly compiler\".into());\n        }\n\n        match &*opt {\n            \"unstable-options\" => {\n                allow_unstable = true;\n            }\n            _ => {\n                return Err(\"Unrecognized option to `Z`\".into());\n            }\n        }\n    };\n\n    Ok(allow_unstable)\n}\n\nfn get_log_file(matches: &getopts::Matches) -> OptPartRes<Option<PathBuf>> {\n    let logfile = matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s));\n\n    Ok(logfile)\n}\n"],["2641","//! Module with common helpers not directly related to tests\n//! but used in `libtest`.\n\npub mod concurrency;\npub mod exit_code;\npub mod isatty;\npub mod metrics;\n"],["2642","//! Benchmark metrics.\nuse std::collections::BTreeMap;\n\n#[derive(Clone, PartialEq, Debug, Copy)]\npub struct Metric {\n    value: f64,\n    noise: f64,\n}\n\nimpl Metric {\n    pub fn new(value: f64, noise: f64) -> Metric {\n        Metric { value, noise }\n    }\n}\n\n#[derive(Clone, PartialEq)]\npub struct MetricMap(BTreeMap<String, Metric>);\n\nimpl MetricMap {\n    pub fn new() -> MetricMap {\n        MetricMap(BTreeMap::new())\n    }\n\n    /// Insert a named `value` (+/- `noise`) metric into the map. The value\n    /// must be non-negative. The `noise` indicates the uncertainty of the\n    /// metric, which doubles as the \"noise range\" of acceptable\n    /// pairwise-regressions on this named value, when comparing from one\n    /// metric to the next using `compare_to_old`.\n    ///\n    /// If `noise` is positive, then it means this metric is of a value\n    /// you want to see grow smaller, so a change larger than `noise` in the\n    /// positive direction represents a regression.\n    ///\n    /// If `noise` is negative, then it means this metric is of a value\n    /// you want to see grow larger, so a change larger than `noise` in the\n    /// negative direction represents a regression.\n    pub fn insert_metric(&mut self, name: &str, value: f64, noise: f64) {\n        let m = Metric { value, noise };\n        self.0.insert(name.to_owned(), m);\n    }\n\n    pub fn fmt_metrics(&self) -> String {\n        let v = self\n            .0\n            .iter()\n            .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n            .collect::<Vec<_>>();\n        v.join(\", \")\n    }\n}\n"],["2643","//! Helper module to detect subprocess exit code.\n\nuse std::process::ExitStatus;\n\n#[cfg(not(unix))]\npub fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n    status.code().ok_or_else(|| \"received no exit code from child process\".into())\n}\n\n#[cfg(unix)]\npub fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n    use std::os::unix::process::ExitStatusExt;\n    match status.code() {\n        Some(code) => Ok(code),\n        None => match status.signal() {\n            Some(signal) => Err(format!(\"child process exited with signal {}\", signal)),\n            None => Err(\"child process exited with unknown signal\".into()),\n        },\n    }\n}\n"],["2644","//! Helper module which provides a function to test\n//! if stdout is a tty.\n\ncfg_if::cfg_if! {\n    if #[cfg(unix)] {\n        pub fn stdout_isatty() -> bool {\n            unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n        }\n    } else if #[cfg(windows)] {\n        pub fn stdout_isatty() -> bool {\n            type DWORD = u32;\n            type BOOL = i32;\n            type HANDLE = *mut u8;\n            type LPDWORD = *mut u32;\n            const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n            extern \"system\" {\n                fn GetStdHandle(which: DWORD) -> HANDLE;\n                fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n            }\n            unsafe {\n                let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n                let mut out = 0;\n                GetConsoleMode(handle, &mut out) != 0\n            }\n        }\n    } else {\n        // FIXME: Implement isatty on SGX\n        pub fn stdout_isatty() -> bool {\n            false\n        }\n    }\n}\n"],["2645","//! Helper module which helps to determine amount of threads to be used\n//! during tests execution.\nuse std::{env, num::NonZeroUsize, thread};\n\npub fn get_concurrency() -> usize {\n    if let Ok(value) = env::var(\"RUST_TEST_THREADS\") {\n        match value.parse::<NonZeroUsize>().ok() {\n            Some(n) => n.get(),\n            _ => panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\", value),\n        }\n    } else {\n        thread::available_concurrency().map(|n| n.get()).unwrap_or(1)\n    }\n}\n"],["2646","//! Module containing different events that can occur\n//! during tests execution process.\n\nuse super::test_result::TestResult;\nuse super::time::TestExecTime;\nuse super::types::{TestDesc, TestId};\n\n#[derive(Debug, Clone)]\npub struct CompletedTest {\n    pub id: TestId,\n    pub desc: TestDesc,\n    pub result: TestResult,\n    pub exec_time: Option<TestExecTime>,\n    pub stdout: Vec<u8>,\n}\n\nimpl CompletedTest {\n    pub fn new(\n        id: TestId,\n        desc: TestDesc,\n        result: TestResult,\n        exec_time: Option<TestExecTime>,\n        stdout: Vec<u8>,\n    ) -> Self {\n        Self { id, desc, result, exec_time, stdout }\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum TestEvent {\n    TeFiltered(Vec<TestDesc>),\n    TeWait(TestDesc),\n    TeResult(CompletedTest),\n    TeTimeout(TestDesc),\n    TeFilteredOut(usize),\n}\n"],["2647","use super::*;\n\nextern crate test;\nuse self::test::test::Bencher;\nuse std::io;\nuse std::io::prelude::*;\n\n// Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n\nmacro_rules! assert_approx_eq {\n    ($a: expr, $b: expr) => {{\n        let (a, b) = (&$a, &$b);\n        assert!((*a - *b).abs() < 1.0e-6, \"{} is not approximately equal to {}\", *a, *b);\n    }};\n}\n\nfn check(samples: &[f64], summ: &Summary) {\n    let summ2 = Summary::new(samples);\n\n    let mut w = io::sink();\n    let w = &mut w;\n    (write!(w, \"\\n\")).unwrap();\n\n    assert_eq!(summ.sum, summ2.sum);\n    assert_eq!(summ.min, summ2.min);\n    assert_eq!(summ.max, summ2.max);\n    assert_eq!(summ.mean, summ2.mean);\n    assert_eq!(summ.median, summ2.median);\n\n    // We needed a few more digits to get exact equality on these\n    // but they're within float epsilon, which is 1.0e-6.\n    assert_approx_eq!(summ.var, summ2.var);\n    assert_approx_eq!(summ.std_dev, summ2.std_dev);\n    assert_approx_eq!(summ.std_dev_pct, summ2.std_dev_pct);\n    assert_approx_eq!(summ.median_abs_dev, summ2.median_abs_dev);\n    assert_approx_eq!(summ.median_abs_dev_pct, summ2.median_abs_dev_pct);\n\n    assert_eq!(summ.quartiles, summ2.quartiles);\n    assert_eq!(summ.iqr, summ2.iqr);\n}\n\n#[test]\nfn test_min_max_nan() {\n    let xs = &[1.0, 2.0, f64::NAN, 3.0, 4.0];\n    let summary = Summary::new(xs);\n    assert_eq!(summary.min, 1.0);\n    assert_eq!(summary.max, 4.0);\n}\n\n#[test]\nfn test_norm2() {\n    let val = &[958.0000000000, 924.0000000000];\n    let summ = &Summary {\n        sum: 1882.0000000000,\n        min: 924.0000000000,\n        max: 958.0000000000,\n        mean: 941.0000000000,\n        median: 941.0000000000,\n        var: 578.0000000000,\n        std_dev: 24.0416305603,\n        std_dev_pct: 2.5549022912,\n        median_abs_dev: 25.2042000000,\n        median_abs_dev_pct: 2.6784484591,\n        quartiles: (932.5000000000, 941.0000000000, 949.5000000000),\n        iqr: 17.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_norm10narrow() {\n    let val = &[\n        966.0000000000,\n        985.0000000000,\n        1110.0000000000,\n        848.0000000000,\n        821.0000000000,\n        975.0000000000,\n        962.0000000000,\n        1157.0000000000,\n        1217.0000000000,\n        955.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 9996.0000000000,\n        min: 821.0000000000,\n        max: 1217.0000000000,\n        mean: 999.6000000000,\n        median: 970.5000000000,\n        var: 16050.7111111111,\n        std_dev: 126.6914010938,\n        std_dev_pct: 12.6742097933,\n        median_abs_dev: 102.2994000000,\n        median_abs_dev_pct: 10.5408964451,\n        quartiles: (956.7500000000, 970.5000000000, 1078.7500000000),\n        iqr: 122.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_norm10medium() {\n    let val = &[\n        954.0000000000,\n        1064.0000000000,\n        855.0000000000,\n        1000.0000000000,\n        743.0000000000,\n        1084.0000000000,\n        704.0000000000,\n        1023.0000000000,\n        357.0000000000,\n        869.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 8653.0000000000,\n        min: 357.0000000000,\n        max: 1084.0000000000,\n        mean: 865.3000000000,\n        median: 911.5000000000,\n        var: 48628.4555555556,\n        std_dev: 220.5186059170,\n        std_dev_pct: 25.4846418487,\n        median_abs_dev: 195.7032000000,\n        median_abs_dev_pct: 21.4704552935,\n        quartiles: (771.0000000000, 911.5000000000, 1017.2500000000),\n        iqr: 246.2500000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_norm10wide() {\n    let val = &[\n        505.0000000000,\n        497.0000000000,\n        1591.0000000000,\n        887.0000000000,\n        1026.0000000000,\n        136.0000000000,\n        1580.0000000000,\n        940.0000000000,\n        754.0000000000,\n        1433.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 9349.0000000000,\n        min: 136.0000000000,\n        max: 1591.0000000000,\n        mean: 934.9000000000,\n        median: 913.5000000000,\n        var: 239208.9888888889,\n        std_dev: 489.0899599142,\n        std_dev_pct: 52.3146817750,\n        median_abs_dev: 611.5725000000,\n        median_abs_dev_pct: 66.9482758621,\n        quartiles: (567.2500000000, 913.5000000000, 1331.2500000000),\n        iqr: 764.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_norm25verynarrow() {\n    let val = &[\n        991.0000000000,\n        1018.0000000000,\n        998.0000000000,\n        1013.0000000000,\n        974.0000000000,\n        1007.0000000000,\n        1014.0000000000,\n        999.0000000000,\n        1011.0000000000,\n        978.0000000000,\n        985.0000000000,\n        999.0000000000,\n        983.0000000000,\n        982.0000000000,\n        1015.0000000000,\n        1002.0000000000,\n        977.0000000000,\n        948.0000000000,\n        1040.0000000000,\n        974.0000000000,\n        996.0000000000,\n        989.0000000000,\n        1015.0000000000,\n        994.0000000000,\n        1024.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 24926.0000000000,\n        min: 948.0000000000,\n        max: 1040.0000000000,\n        mean: 997.0400000000,\n        median: 998.0000000000,\n        var: 393.2066666667,\n        std_dev: 19.8294393937,\n        std_dev_pct: 1.9888308788,\n        median_abs_dev: 22.2390000000,\n        median_abs_dev_pct: 2.2283567134,\n        quartiles: (983.0000000000, 998.0000000000, 1013.0000000000),\n        iqr: 30.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_exp10a() {\n    let val = &[\n        23.0000000000,\n        11.0000000000,\n        2.0000000000,\n        57.0000000000,\n        4.0000000000,\n        12.0000000000,\n        5.0000000000,\n        29.0000000000,\n        3.0000000000,\n        21.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 167.0000000000,\n        min: 2.0000000000,\n        max: 57.0000000000,\n        mean: 16.7000000000,\n        median: 11.5000000000,\n        var: 287.7888888889,\n        std_dev: 16.9643416875,\n        std_dev_pct: 101.5828843560,\n        median_abs_dev: 13.3434000000,\n        median_abs_dev_pct: 116.0295652174,\n        quartiles: (4.2500000000, 11.5000000000, 22.5000000000),\n        iqr: 18.2500000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_exp10b() {\n    let val = &[\n        24.0000000000,\n        17.0000000000,\n        6.0000000000,\n        38.0000000000,\n        25.0000000000,\n        7.0000000000,\n        51.0000000000,\n        2.0000000000,\n        61.0000000000,\n        32.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 263.0000000000,\n        min: 2.0000000000,\n        max: 61.0000000000,\n        mean: 26.3000000000,\n        median: 24.5000000000,\n        var: 383.5666666667,\n        std_dev: 19.5848580967,\n        std_dev_pct: 74.4671410520,\n        median_abs_dev: 22.9803000000,\n        median_abs_dev_pct: 93.7971428571,\n        quartiles: (9.5000000000, 24.5000000000, 36.5000000000),\n        iqr: 27.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_exp10c() {\n    let val = &[\n        71.0000000000,\n        2.0000000000,\n        32.0000000000,\n        1.0000000000,\n        6.0000000000,\n        28.0000000000,\n        13.0000000000,\n        37.0000000000,\n        16.0000000000,\n        36.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 242.0000000000,\n        min: 1.0000000000,\n        max: 71.0000000000,\n        mean: 24.2000000000,\n        median: 22.0000000000,\n        var: 458.1777777778,\n        std_dev: 21.4050876611,\n        std_dev_pct: 88.4507754589,\n        median_abs_dev: 21.4977000000,\n        median_abs_dev_pct: 97.7168181818,\n        quartiles: (7.7500000000, 22.0000000000, 35.0000000000),\n        iqr: 27.2500000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_exp25() {\n    let val = &[\n        3.0000000000,\n        24.0000000000,\n        1.0000000000,\n        19.0000000000,\n        7.0000000000,\n        5.0000000000,\n        30.0000000000,\n        39.0000000000,\n        31.0000000000,\n        13.0000000000,\n        25.0000000000,\n        48.0000000000,\n        1.0000000000,\n        6.0000000000,\n        42.0000000000,\n        63.0000000000,\n        2.0000000000,\n        12.0000000000,\n        108.0000000000,\n        26.0000000000,\n        1.0000000000,\n        7.0000000000,\n        44.0000000000,\n        25.0000000000,\n        11.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 593.0000000000,\n        min: 1.0000000000,\n        max: 108.0000000000,\n        mean: 23.7200000000,\n        median: 19.0000000000,\n        var: 601.0433333333,\n        std_dev: 24.5161851301,\n        std_dev_pct: 103.3565983562,\n        median_abs_dev: 19.2738000000,\n        median_abs_dev_pct: 101.4410526316,\n        quartiles: (6.0000000000, 19.0000000000, 31.0000000000),\n        iqr: 25.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_binom25() {\n    let val = &[\n        18.0000000000,\n        17.0000000000,\n        27.0000000000,\n        15.0000000000,\n        21.0000000000,\n        25.0000000000,\n        17.0000000000,\n        24.0000000000,\n        25.0000000000,\n        24.0000000000,\n        26.0000000000,\n        26.0000000000,\n        23.0000000000,\n        15.0000000000,\n        23.0000000000,\n        17.0000000000,\n        18.0000000000,\n        18.0000000000,\n        21.0000000000,\n        16.0000000000,\n        15.0000000000,\n        31.0000000000,\n        20.0000000000,\n        17.0000000000,\n        15.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 514.0000000000,\n        min: 15.0000000000,\n        max: 31.0000000000,\n        mean: 20.5600000000,\n        median: 20.0000000000,\n        var: 20.8400000000,\n        std_dev: 4.5650848842,\n        std_dev_pct: 22.2037202539,\n        median_abs_dev: 5.9304000000,\n        median_abs_dev_pct: 29.6520000000,\n        quartiles: (17.0000000000, 20.0000000000, 24.0000000000),\n        iqr: 7.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_pois25lambda30() {\n    let val = &[\n        27.0000000000,\n        33.0000000000,\n        34.0000000000,\n        34.0000000000,\n        24.0000000000,\n        39.0000000000,\n        28.0000000000,\n        27.0000000000,\n        31.0000000000,\n        28.0000000000,\n        38.0000000000,\n        21.0000000000,\n        33.0000000000,\n        36.0000000000,\n        29.0000000000,\n        37.0000000000,\n        32.0000000000,\n        34.0000000000,\n        31.0000000000,\n        39.0000000000,\n        25.0000000000,\n        31.0000000000,\n        32.0000000000,\n        40.0000000000,\n        24.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 787.0000000000,\n        min: 21.0000000000,\n        max: 40.0000000000,\n        mean: 31.4800000000,\n        median: 32.0000000000,\n        var: 26.5933333333,\n        std_dev: 5.1568724372,\n        std_dev_pct: 16.3814245145,\n        median_abs_dev: 5.9304000000,\n        median_abs_dev_pct: 18.5325000000,\n        quartiles: (28.0000000000, 32.0000000000, 34.0000000000),\n        iqr: 6.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_pois25lambda40() {\n    let val = &[\n        42.0000000000,\n        50.0000000000,\n        42.0000000000,\n        46.0000000000,\n        34.0000000000,\n        45.0000000000,\n        34.0000000000,\n        49.0000000000,\n        39.0000000000,\n        28.0000000000,\n        40.0000000000,\n        35.0000000000,\n        37.0000000000,\n        39.0000000000,\n        46.0000000000,\n        44.0000000000,\n        32.0000000000,\n        45.0000000000,\n        42.0000000000,\n        37.0000000000,\n        48.0000000000,\n        42.0000000000,\n        33.0000000000,\n        42.0000000000,\n        48.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 1019.0000000000,\n        min: 28.0000000000,\n        max: 50.0000000000,\n        mean: 40.7600000000,\n        median: 42.0000000000,\n        var: 34.4400000000,\n        std_dev: 5.8685603004,\n        std_dev_pct: 14.3978417577,\n        median_abs_dev: 5.9304000000,\n        median_abs_dev_pct: 14.1200000000,\n        quartiles: (37.0000000000, 42.0000000000, 45.0000000000),\n        iqr: 8.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_pois25lambda50() {\n    let val = &[\n        45.0000000000,\n        43.0000000000,\n        44.0000000000,\n        61.0000000000,\n        51.0000000000,\n        53.0000000000,\n        59.0000000000,\n        52.0000000000,\n        49.0000000000,\n        51.0000000000,\n        51.0000000000,\n        50.0000000000,\n        49.0000000000,\n        56.0000000000,\n        42.0000000000,\n        52.0000000000,\n        51.0000000000,\n        43.0000000000,\n        48.0000000000,\n        48.0000000000,\n        50.0000000000,\n        42.0000000000,\n        43.0000000000,\n        42.0000000000,\n        60.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 1235.0000000000,\n        min: 42.0000000000,\n        max: 61.0000000000,\n        mean: 49.4000000000,\n        median: 50.0000000000,\n        var: 31.6666666667,\n        std_dev: 5.6273143387,\n        std_dev_pct: 11.3913245723,\n        median_abs_dev: 4.4478000000,\n        median_abs_dev_pct: 8.8956000000,\n        quartiles: (44.0000000000, 50.0000000000, 52.0000000000),\n        iqr: 8.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_unif25() {\n    let val = &[\n        99.0000000000,\n        55.0000000000,\n        92.0000000000,\n        79.0000000000,\n        14.0000000000,\n        2.0000000000,\n        33.0000000000,\n        49.0000000000,\n        3.0000000000,\n        32.0000000000,\n        84.0000000000,\n        59.0000000000,\n        22.0000000000,\n        86.0000000000,\n        76.0000000000,\n        31.0000000000,\n        29.0000000000,\n        11.0000000000,\n        41.0000000000,\n        53.0000000000,\n        45.0000000000,\n        44.0000000000,\n        98.0000000000,\n        98.0000000000,\n        7.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 1242.0000000000,\n        min: 2.0000000000,\n        max: 99.0000000000,\n        mean: 49.6800000000,\n        median: 45.0000000000,\n        var: 1015.6433333333,\n        std_dev: 31.8691595957,\n        std_dev_pct: 64.1488719719,\n        median_abs_dev: 45.9606000000,\n        median_abs_dev_pct: 102.1346666667,\n        quartiles: (29.0000000000, 45.0000000000, 79.0000000000),\n        iqr: 50.0000000000,\n    };\n    check(val, summ);\n}\n\n#[test]\nfn test_sum_f64s() {\n    assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(), 5.2999);\n}\n#[test]\nfn test_sum_f64_between_ints_that_sum_to_0() {\n    assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n}\n\n#[bench]\npub fn sum_three_items(b: &mut Bencher) {\n    b.iter(|| {\n        [1e20f64, 1.5f64, -1e20f64].sum();\n    })\n}\n#[bench]\npub fn sum_many_f64(b: &mut Bencher) {\n    let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n    let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n\n    b.iter(|| {\n        v.sum();\n    })\n}\n\n#[bench]\npub fn no_iter(_: &mut Bencher) {}\n"],["2648","use super::*;\n\nuse crate::{\n    bench::Bencher,\n    console::OutputLocation,\n    formatters::PrettyFormatter,\n    options::OutputFormat,\n    test::{\n        filter_tests,\n        parse_opts,\n        run_test,\n        DynTestFn,\n        DynTestName,\n        MetricMap,\n        RunIgnored,\n        RunStrategy,\n        ShouldPanic,\n        StaticTestName,\n        TestDesc,\n        TestDescAndFn,\n        TestOpts,\n        TrIgnored,\n        TrOk,\n        // FIXME (introduced by #65251)\n        // ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TestTimeOptions,\n        // TestType, TrFailedMsg, TrIgnored, TrOk,\n    },\n    time::{TestTimeOptions, TimeThreshold},\n};\nuse std::sync::mpsc::channel;\nuse std::time::Duration;\n\nimpl TestOpts {\n    fn new() -> TestOpts {\n        TestOpts {\n            list: false,\n            filters: vec![],\n            filter_exact: false,\n            force_run_in_process: false,\n            exclude_should_panic: false,\n            run_ignored: RunIgnored::No,\n            run_tests: false,\n            bench_benchmarks: false,\n            logfile: None,\n            nocapture: false,\n            color: AutoColor,\n            format: OutputFormat::Pretty,\n            test_threads: None,\n            skip: vec![],\n            time_options: None,\n            options: Options::new(),\n        }\n    }\n}\n\nfn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n    vec![\n        TestDescAndFn {\n            desc: TestDesc {\n                name: StaticTestName(\"1\"),\n                ignore: true,\n                should_panic: ShouldPanic::No,\n                allow_fail: false,\n                #[cfg(not(bootstrap))]\n                compile_fail: false,\n                #[cfg(not(bootstrap))]\n                no_run: false,\n                test_type: TestType::Unknown,\n            },\n            testfn: DynTestFn(Box::new(move || {})),\n        },\n        TestDescAndFn {\n            desc: TestDesc {\n                name: StaticTestName(\"2\"),\n                ignore: false,\n                should_panic: ShouldPanic::No,\n                allow_fail: false,\n                #[cfg(not(bootstrap))]\n                compile_fail: false,\n                #[cfg(not(bootstrap))]\n                no_run: false,\n                test_type: TestType::Unknown,\n            },\n            testfn: DynTestFn(Box::new(move || {})),\n        },\n    ]\n}\n\n#[test]\npub fn do_not_run_ignored_tests() {\n    fn f() {\n        panic!();\n    }\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: true,\n            should_panic: ShouldPanic::No,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_ne!(result, TrOk);\n}\n\n#[test]\npub fn ignored_tests_result_in_ignored() {\n    fn f() {}\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: true,\n            should_panic: ShouldPanic::No,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrIgnored);\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic() {\n    fn f() {\n        panic!();\n    }\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::Yes,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrOk);\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic_good_message() {\n    fn f() {\n        panic!(\"an error message\");\n    }\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrOk);\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic_bad_message() {\n    use crate::tests::TrFailedMsg;\n    fn f() {\n        panic!(\"an error message\");\n    }\n    let expected = \"foobar\";\n    let failed_msg = r#\"panic did not contain expected string\n      panic message: `\"an error message\"`,\n expected substring: `\"foobar\"`\"#;\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::YesWithMessage(expected),\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrFailedMsg(failed_msg.to_string()));\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic_non_string_message_type() {\n    use crate::tests::TrFailedMsg;\n    use std::any::TypeId;\n    fn f() {\n        std::panic::panic_any(1i32);\n    }\n    let expected = \"foobar\";\n    let failed_msg = format!(\n        r#\"expected panic with string value,\n found non-string value: `{:?}`\n     expected substring: `\"foobar\"`\"#,\n        TypeId::of::<i32>()\n    );\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::YesWithMessage(expected),\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrFailedMsg(failed_msg));\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic_but_succeeds() {\n    let should_panic_variants = [ShouldPanic::Yes, ShouldPanic::YesWithMessage(\"error message\")];\n\n    for &should_panic in should_panic_variants.iter() {\n        fn f() {}\n        let desc = TestDescAndFn {\n            desc: TestDesc {\n                name: StaticTestName(\"whatever\"),\n                ignore: false,\n                should_panic,\n                allow_fail: false,\n                #[cfg(not(bootstrap))]\n                compile_fail: false,\n                #[cfg(not(bootstrap))]\n                no_run: false,\n                test_type: TestType::Unknown,\n            },\n            testfn: DynTestFn(Box::new(f)),\n        };\n        let (tx, rx) = channel();\n        run_test(\n            &TestOpts::new(),\n            false,\n            TestId(0),\n            desc,\n            RunStrategy::InProcess,\n            tx,\n            Concurrent::No,\n        );\n        let result = rx.recv().unwrap().result;\n        assert_eq!(\n            result,\n            TrFailedMsg(\"test did not panic as expected\".to_string()),\n            \"should_panic == {:?}\",\n            should_panic\n        );\n    }\n}\n\nfn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n    fn f() {}\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::No,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let time_options = if report_time { Some(TestTimeOptions::default()) } else { None };\n\n    let test_opts = TestOpts { time_options, ..TestOpts::new() };\n    let (tx, rx) = channel();\n    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let exec_time = rx.recv().unwrap().exec_time;\n    exec_time\n}\n\n#[test]\nfn test_should_not_report_time() {\n    let exec_time = report_time_test_template(false);\n    assert!(exec_time.is_none());\n}\n\n#[test]\nfn test_should_report_time() {\n    let exec_time = report_time_test_template(true);\n    assert!(exec_time.is_some());\n}\n\nfn time_test_failure_template(test_type: TestType) -> TestResult {\n    fn f() {}\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::No,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    // `Default` will initialize all the thresholds to 0 milliseconds.\n    let mut time_options = TestTimeOptions::default();\n    time_options.error_on_excess = true;\n\n    let test_opts = TestOpts { time_options: Some(time_options), ..TestOpts::new() };\n    let (tx, rx) = channel();\n    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n\n    result\n}\n\n#[test]\nfn test_error_on_exceed() {\n    let types = [TestType::UnitTest, TestType::IntegrationTest, TestType::DocTest];\n\n    for test_type in types.iter() {\n        let result = time_test_failure_template(*test_type);\n\n        assert_eq!(result, TestResult::TrTimedFail);\n    }\n\n    // Check that for unknown tests thresholds aren't applied.\n    let result = time_test_failure_template(TestType::Unknown);\n    assert_eq!(result, TestResult::TrOk);\n}\n\nfn typed_test_desc(test_type: TestType) -> TestDesc {\n    TestDesc {\n        name: StaticTestName(\"whatever\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type,\n    }\n}\n\nfn test_exec_time(millis: u64) -> TestExecTime {\n    TestExecTime(Duration::from_millis(millis))\n}\n\n#[test]\nfn test_time_options_threshold() {\n    let unit = TimeThreshold::new(Duration::from_millis(50), Duration::from_millis(100));\n    let integration = TimeThreshold::new(Duration::from_millis(500), Duration::from_millis(1000));\n    let doc = TimeThreshold::new(Duration::from_millis(5000), Duration::from_millis(10000));\n\n    let options = TestTimeOptions {\n        error_on_excess: false,\n        colored: false,\n        unit_threshold: unit.clone(),\n        integration_threshold: integration.clone(),\n        doctest_threshold: doc.clone(),\n    };\n\n    let test_vector = [\n        (TestType::UnitTest, unit.warn.as_millis() - 1, false, false),\n        (TestType::UnitTest, unit.warn.as_millis(), true, false),\n        (TestType::UnitTest, unit.critical.as_millis(), true, true),\n        (TestType::IntegrationTest, integration.warn.as_millis() - 1, false, false),\n        (TestType::IntegrationTest, integration.warn.as_millis(), true, false),\n        (TestType::IntegrationTest, integration.critical.as_millis(), true, true),\n        (TestType::DocTest, doc.warn.as_millis() - 1, false, false),\n        (TestType::DocTest, doc.warn.as_millis(), true, false),\n        (TestType::DocTest, doc.critical.as_millis(), true, true),\n    ];\n\n    for (test_type, time, expected_warn, expected_critical) in test_vector.iter() {\n        let test_desc = typed_test_desc(*test_type);\n        let exec_time = test_exec_time(*time as u64);\n\n        assert_eq!(options.is_warn(&test_desc, &exec_time), *expected_warn);\n        assert_eq!(options.is_critical(&test_desc, &exec_time), *expected_critical);\n    }\n}\n\n#[test]\nfn parse_ignored_flag() {\n    let args = vec![\"progname\".to_string(), \"filter\".to_string(), \"--ignored\".to_string()];\n    let opts = parse_opts(&args).unwrap().unwrap();\n    assert_eq!(opts.run_ignored, RunIgnored::Only);\n}\n\n#[test]\nfn parse_show_output_flag() {\n    let args = vec![\"progname\".to_string(), \"filter\".to_string(), \"--show-output\".to_string()];\n    let opts = parse_opts(&args).unwrap().unwrap();\n    assert!(opts.options.display_output);\n}\n\n#[test]\nfn parse_include_ignored_flag() {\n    let args = vec![\"progname\".to_string(), \"filter\".to_string(), \"--include-ignored\".to_string()];\n    let opts = parse_opts(&args).unwrap().unwrap();\n    assert_eq!(opts.run_ignored, RunIgnored::Yes);\n}\n\n#[test]\npub fn filter_for_ignored_option() {\n    // When we run ignored tests the test filter should filter out all the\n    // unignored tests and flip the ignore flag on the rest to false\n\n    let mut opts = TestOpts::new();\n    opts.run_tests = true;\n    opts.run_ignored = RunIgnored::Only;\n\n    let tests = one_ignored_one_unignored_test();\n    let filtered = filter_tests(&opts, tests);\n\n    assert_eq!(filtered.len(), 1);\n    assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n    assert!(!filtered[0].desc.ignore);\n}\n\n#[test]\npub fn run_include_ignored_option() {\n    // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n    // all tests and no test filtered out\n\n    let mut opts = TestOpts::new();\n    opts.run_tests = true;\n    opts.run_ignored = RunIgnored::Yes;\n\n    let tests = one_ignored_one_unignored_test();\n    let filtered = filter_tests(&opts, tests);\n\n    assert_eq!(filtered.len(), 2);\n    assert!(!filtered[0].desc.ignore);\n    assert!(!filtered[1].desc.ignore);\n}\n\n#[test]\npub fn exclude_should_panic_option() {\n    let mut opts = TestOpts::new();\n    opts.run_tests = true;\n    opts.exclude_should_panic = true;\n\n    let mut tests = one_ignored_one_unignored_test();\n    tests.push(TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"3\"),\n            ignore: false,\n            should_panic: ShouldPanic::Yes,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(move || {})),\n    });\n\n    let filtered = filter_tests(&opts, tests);\n\n    assert_eq!(filtered.len(), 2);\n    assert!(filtered.iter().all(|test| test.desc.should_panic == ShouldPanic::No));\n}\n\n#[test]\npub fn exact_filter_match() {\n    fn tests() -> Vec<TestDescAndFn> {\n        vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n            .into_iter()\n            .map(|name| TestDescAndFn {\n                desc: TestDesc {\n                    name: StaticTestName(name),\n                    ignore: false,\n                    should_panic: ShouldPanic::No,\n                    allow_fail: false,\n                    #[cfg(not(bootstrap))]\n                    compile_fail: false,\n                    #[cfg(not(bootstrap))]\n                    no_run: false,\n                    test_type: TestType::Unknown,\n                },\n                testfn: DynTestFn(Box::new(move || {})),\n            })\n            .collect()\n    }\n\n    let substr =\n        filter_tests(&TestOpts { filters: vec![\"base\".into()], ..TestOpts::new() }, tests());\n    assert_eq!(substr.len(), 4);\n\n    let substr =\n        filter_tests(&TestOpts { filters: vec![\"bas\".into()], ..TestOpts::new() }, tests());\n    assert_eq!(substr.len(), 4);\n\n    let substr =\n        filter_tests(&TestOpts { filters: vec![\"::test\".into()], ..TestOpts::new() }, tests());\n    assert_eq!(substr.len(), 3);\n\n    let substr =\n        filter_tests(&TestOpts { filters: vec![\"base::test\".into()], ..TestOpts::new() }, tests());\n    assert_eq!(substr.len(), 3);\n\n    let substr = filter_tests(\n        &TestOpts { filters: vec![\"test1\".into(), \"test2\".into()], ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(substr.len(), 2);\n\n    let exact = filter_tests(\n        &TestOpts { filters: vec![\"base\".into()], filter_exact: true, ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(exact.len(), 1);\n\n    let exact = filter_tests(\n        &TestOpts { filters: vec![\"bas\".into()], filter_exact: true, ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(exact.len(), 0);\n\n    let exact = filter_tests(\n        &TestOpts { filters: vec![\"::test\".into()], filter_exact: true, ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(exact.len(), 0);\n\n    let exact = filter_tests(\n        &TestOpts { filters: vec![\"base::test\".into()], filter_exact: true, ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(exact.len(), 1);\n\n    let exact = filter_tests(\n        &TestOpts {\n            filters: vec![\"base\".into(), \"base::test\".into()],\n            filter_exact: true,\n            ..TestOpts::new()\n        },\n        tests(),\n    );\n    assert_eq!(exact.len(), 2);\n}\n\n#[test]\npub fn sort_tests() {\n    let mut opts = TestOpts::new();\n    opts.run_tests = true;\n\n    let names = vec![\n        \"sha1::test\".to_string(),\n        \"isize::test_to_str\".to_string(),\n        \"isize::test_pow\".to_string(),\n        \"test::do_not_run_ignored_tests\".to_string(),\n        \"test::ignored_tests_result_in_ignored\".to_string(),\n        \"test::first_free_arg_should_be_a_filter\".to_string(),\n        \"test::parse_ignored_flag\".to_string(),\n        \"test::parse_include_ignored_flag\".to_string(),\n        \"test::filter_for_ignored_option\".to_string(),\n        \"test::run_include_ignored_option\".to_string(),\n        \"test::sort_tests\".to_string(),\n    ];\n    let tests = {\n        fn testfn() {}\n        let mut tests = Vec::new();\n        for name in &names {\n            let test = TestDescAndFn {\n                desc: TestDesc {\n                    name: DynTestName((*name).clone()),\n                    ignore: false,\n                    should_panic: ShouldPanic::No,\n                    allow_fail: false,\n                    #[cfg(not(bootstrap))]\n                    compile_fail: false,\n                    #[cfg(not(bootstrap))]\n                    no_run: false,\n                    test_type: TestType::Unknown,\n                },\n                testfn: DynTestFn(Box::new(testfn)),\n            };\n            tests.push(test);\n        }\n        tests\n    };\n    let filtered = filter_tests(&opts, tests);\n\n    let expected = vec![\n        \"isize::test_pow\".to_string(),\n        \"isize::test_to_str\".to_string(),\n        \"sha1::test\".to_string(),\n        \"test::do_not_run_ignored_tests\".to_string(),\n        \"test::filter_for_ignored_option\".to_string(),\n        \"test::first_free_arg_should_be_a_filter\".to_string(),\n        \"test::ignored_tests_result_in_ignored\".to_string(),\n        \"test::parse_ignored_flag\".to_string(),\n        \"test::parse_include_ignored_flag\".to_string(),\n        \"test::run_include_ignored_option\".to_string(),\n        \"test::sort_tests\".to_string(),\n    ];\n\n    for (a, b) in expected.iter().zip(filtered) {\n        assert_eq!(*a, b.desc.name.to_string());\n    }\n}\n\n#[test]\npub fn test_metricmap_compare() {\n    let mut m1 = MetricMap::new();\n    let mut m2 = MetricMap::new();\n    m1.insert_metric(\"in-both-noise\", 1000.0, 200.0);\n    m2.insert_metric(\"in-both-noise\", 1100.0, 200.0);\n\n    m1.insert_metric(\"in-first-noise\", 1000.0, 2.0);\n    m2.insert_metric(\"in-second-noise\", 1000.0, 2.0);\n\n    m1.insert_metric(\"in-both-want-downwards-but-regressed\", 1000.0, 10.0);\n    m2.insert_metric(\"in-both-want-downwards-but-regressed\", 2000.0, 10.0);\n\n    m1.insert_metric(\"in-both-want-downwards-and-improved\", 2000.0, 10.0);\n    m2.insert_metric(\"in-both-want-downwards-and-improved\", 1000.0, 10.0);\n\n    m1.insert_metric(\"in-both-want-upwards-but-regressed\", 2000.0, -10.0);\n    m2.insert_metric(\"in-both-want-upwards-but-regressed\", 1000.0, -10.0);\n\n    m1.insert_metric(\"in-both-want-upwards-and-improved\", 1000.0, -10.0);\n    m2.insert_metric(\"in-both-want-upwards-and-improved\", 2000.0, -10.0);\n}\n\n#[test]\npub fn test_bench_once_no_iter() {\n    fn f(_: &mut Bencher) {}\n    bench::run_once(f);\n}\n\n#[test]\npub fn test_bench_once_iter() {\n    fn f(b: &mut Bencher) {\n        b.iter(|| {})\n    }\n    bench::run_once(f);\n}\n\n#[test]\npub fn test_bench_no_iter() {\n    fn f(_: &mut Bencher) {}\n\n    let (tx, rx) = channel();\n\n    let desc = TestDesc {\n        name: StaticTestName(\"f\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type: TestType::Unknown,\n    };\n\n    crate::bench::benchmark(TestId(0), desc, tx, true, f);\n    rx.recv().unwrap();\n}\n\n#[test]\npub fn test_bench_iter() {\n    fn f(b: &mut Bencher) {\n        b.iter(|| {})\n    }\n\n    let (tx, rx) = channel();\n\n    let desc = TestDesc {\n        name: StaticTestName(\"f\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type: TestType::Unknown,\n    };\n\n    crate::bench::benchmark(TestId(0), desc, tx, true, f);\n    rx.recv().unwrap();\n}\n\n#[test]\nfn should_sort_failures_before_printing_them() {\n    let test_a = TestDesc {\n        name: StaticTestName(\"a\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type: TestType::Unknown,\n    };\n\n    let test_b = TestDesc {\n        name: StaticTestName(\"b\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type: TestType::Unknown,\n    };\n\n    let mut out = PrettyFormatter::new(OutputLocation::Raw(Vec::new()), false, 10, false, None);\n\n    let st = console::ConsoleTestState {\n        log_out: None,\n        total: 0,\n        passed: 0,\n        failed: 0,\n        ignored: 0,\n        allowed_fail: 0,\n        filtered_out: 0,\n        measured: 0,\n        exec_time: None,\n        metrics: MetricMap::new(),\n        failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n        options: Options::new(),\n        not_failures: Vec::new(),\n        time_failures: Vec::new(),\n    };\n\n    out.write_failures(&st).unwrap();\n    let s = match out.output_location() {\n        &OutputLocation::Raw(ref m) => String::from_utf8_lossy(&m[..]),\n        &OutputLocation::Pretty(_) => unreachable!(),\n    };\n\n    let apos = s.find(\"a\").unwrap();\n    let bpos = s.find(\"b\").unwrap();\n    assert!(apos < bpos);\n}\n"],["2649","//! Benchmarking module.\nuse super::{\n    event::CompletedTest,\n    options::BenchMode,\n    test_result::TestResult,\n    types::{TestDesc, TestId},\n    Sender,\n};\n\nuse crate::stats;\nuse std::cmp;\nuse std::io;\nuse std::panic::{catch_unwind, AssertUnwindSafe};\nuse std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\n\n/// An identity function that *__hints__* to the compiler to be maximally pessimistic about what\n/// `black_box` could do.\n///\n/// See [`std::hint::black_box`] for details.\n#[inline(always)]\npub fn black_box<T>(dummy: T) -> T {\n    std::hint::black_box(dummy)\n}\n\n/// Manager of the benchmarking runs.\n///\n/// This is fed into functions marked with `#[bench]` to allow for\n/// set-up & tear-down before running a piece of code repeatedly via a\n/// call to `iter`.\n#[derive(Clone)]\npub struct Bencher {\n    mode: BenchMode,\n    summary: Option<stats::Summary>,\n    pub bytes: u64,\n}\n\nimpl Bencher {\n    /// Callback for benchmark functions to run in their body.\n    pub fn iter<T, F>(&mut self, mut inner: F)\n    where\n        F: FnMut() -> T,\n    {\n        if self.mode == BenchMode::Single {\n            ns_iter_inner(&mut inner, 1);\n            return;\n        }\n\n        self.summary = Some(iter(&mut inner));\n    }\n\n    pub fn bench<F>(&mut self, mut f: F) -> Option<stats::Summary>\n    where\n        F: FnMut(&mut Bencher),\n    {\n        f(self);\n        self.summary\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct BenchSamples {\n    pub ns_iter_summ: stats::Summary,\n    pub mb_s: usize,\n}\n\npub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n    use std::fmt::Write;\n    let mut output = String::new();\n\n    let median = bs.ns_iter_summ.median as usize;\n    let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n\n    write!(\n        output,\n        \"{:>11} ns/iter (+/- {})\",\n        fmt_thousands_sep(median, ','),\n        fmt_thousands_sep(deviation, ',')\n    )\n    .unwrap();\n    if bs.mb_s != 0 {\n        write!(output, \" = {} MB/s\", bs.mb_s).unwrap();\n    }\n    output\n}\n\n// Format a number with thousands separators\nfn fmt_thousands_sep(mut n: usize, sep: char) -> String {\n    use std::fmt::Write;\n    let mut output = String::new();\n    let mut trailing = false;\n    for &pow in &[9, 6, 3, 0] {\n        let base = 10_usize.pow(pow);\n        if pow == 0 || trailing || n / base != 0 {\n            if !trailing {\n                write!(output, \"{}\", n / base).unwrap();\n            } else {\n                write!(output, \"{:03}\", n / base).unwrap();\n            }\n            if pow != 0 {\n                output.push(sep);\n            }\n            trailing = true;\n        }\n        n %= base;\n    }\n\n    output\n}\n\nfn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\nwhere\n    F: FnMut() -> T,\n{\n    let start = Instant::now();\n    for _ in 0..k {\n        black_box(inner());\n    }\n    start.elapsed().as_nanos() as u64\n}\n\npub fn iter<T, F>(inner: &mut F) -> stats::Summary\nwhere\n    F: FnMut() -> T,\n{\n    // Initial bench run to get ballpark figure.\n    let ns_single = ns_iter_inner(inner, 1);\n\n    // Try to estimate iter count for 1ms falling back to 1m\n    // iterations if first run took < 1ns.\n    let ns_target_total = 1_000_000; // 1ms\n    let mut n = ns_target_total / cmp::max(1, ns_single);\n\n    // if the first run took more than 1ms we don't want to just\n    // be left doing 0 iterations on every loop. The unfortunate\n    // side effect of not being able to do as many runs is\n    // automatically handled by the statistical analysis below\n    // (i.e., larger error bars).\n    n = cmp::max(1, n);\n\n    let mut total_run = Duration::new(0, 0);\n    let samples: &mut [f64] = &mut [0.0_f64; 50];\n    loop {\n        let loop_start = Instant::now();\n\n        for p in &mut *samples {\n            *p = ns_iter_inner(inner, n) as f64 / n as f64;\n        }\n\n        stats::winsorize(samples, 5.0);\n        let summ = stats::Summary::new(samples);\n\n        for p in &mut *samples {\n            let ns = ns_iter_inner(inner, 5 * n);\n            *p = ns as f64 / (5 * n) as f64;\n        }\n\n        stats::winsorize(samples, 5.0);\n        let summ5 = stats::Summary::new(samples);\n\n        let loop_run = loop_start.elapsed();\n\n        // If we've run for 100ms and seem to have converged to a\n        // stable median.\n        if loop_run > Duration::from_millis(100)\n            && summ.median_abs_dev_pct < 1.0\n            && summ.median - summ5.median < summ5.median_abs_dev\n        {\n            return summ5;\n        }\n\n        total_run += loop_run;\n        // Longest we ever run for is 3s.\n        if total_run > Duration::from_secs(3) {\n            return summ5;\n        }\n\n        // If we overflow here just return the results so far. We check a\n        // multiplier of 10 because we're about to multiply by 2 and the\n        // next iteration of the loop will also multiply by 5 (to calculate\n        // the summ5 result)\n        n = match n.checked_mul(10) {\n            Some(_) => n * 2,\n            None => {\n                return summ5;\n            }\n        };\n    }\n}\n\npub fn benchmark<F>(\n    id: TestId,\n    desc: TestDesc,\n    monitor_ch: Sender<CompletedTest>,\n    nocapture: bool,\n    f: F,\n) where\n    F: FnMut(&mut Bencher),\n{\n    let mut bs = Bencher { mode: BenchMode::Auto, summary: None, bytes: 0 };\n\n    let data = Arc::new(Mutex::new(Vec::new()));\n\n    if !nocapture {\n        io::set_output_capture(Some(data.clone()));\n    }\n\n    let result = catch_unwind(AssertUnwindSafe(|| bs.bench(f)));\n\n    io::set_output_capture(None);\n\n    let test_result = match result {\n        //bs.bench(f) {\n        Ok(Some(ns_iter_summ)) => {\n            let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n            let mb_s = bs.bytes * 1000 / ns_iter;\n\n            let bs = BenchSamples { ns_iter_summ, mb_s: mb_s as usize };\n            TestResult::TrBench(bs)\n        }\n        Ok(None) => {\n            // iter not called, so no data.\n            // FIXME: error in this case?\n            let samples: &mut [f64] = &mut [0.0_f64; 1];\n            let bs = BenchSamples { ns_iter_summ: stats::Summary::new(samples), mb_s: 0 };\n            TestResult::TrBench(bs)\n        }\n        Err(_) => TestResult::TrFailed,\n    };\n\n    let stdout = data.lock().unwrap().to_vec();\n    let message = CompletedTest::new(id, desc, test_result, None, stdout);\n    monitor_ch.send(message).unwrap();\n}\n\npub fn run_once<F>(f: F)\nwhere\n    F: FnMut(&mut Bencher),\n{\n    let mut bs = Bencher { mode: BenchMode::Single, summary: None, bytes: 0 };\n    bs.bench(f);\n}\n"],["2650","//! Module providing interface for running tests in the console.\n\nuse std::fs::File;\nuse std::io;\nuse std::io::prelude::Write;\nuse std::time::Instant;\n\nuse super::{\n    bench::fmt_bench_samples,\n    cli::TestOpts,\n    event::{CompletedTest, TestEvent},\n    filter_tests,\n    formatters::{JsonFormatter, JunitFormatter, OutputFormatter, PrettyFormatter, TerseFormatter},\n    helpers::{concurrency::get_concurrency, metrics::MetricMap},\n    options::{Options, OutputFormat},\n    run_tests,\n    test_result::TestResult,\n    time::{TestExecTime, TestSuiteExecTime},\n    types::{NamePadding, TestDesc, TestDescAndFn},\n};\n\n/// Generic wrapper over stdout.\npub enum OutputLocation<T> {\n    Pretty(Box<term::StdoutTerminal>),\n    Raw(T),\n}\n\nimpl<T: Write> Write for OutputLocation<T> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        match *self {\n            OutputLocation::Pretty(ref mut term) => term.write(buf),\n            OutputLocation::Raw(ref mut stdout) => stdout.write(buf),\n        }\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        match *self {\n            OutputLocation::Pretty(ref mut term) => term.flush(),\n            OutputLocation::Raw(ref mut stdout) => stdout.flush(),\n        }\n    }\n}\n\npub struct ConsoleTestState {\n    pub log_out: Option<File>,\n    pub total: usize,\n    pub passed: usize,\n    pub failed: usize,\n    pub ignored: usize,\n    pub allowed_fail: usize,\n    pub filtered_out: usize,\n    pub measured: usize,\n    pub exec_time: Option<TestSuiteExecTime>,\n    pub metrics: MetricMap,\n    pub failures: Vec<(TestDesc, Vec<u8>)>,\n    pub not_failures: Vec<(TestDesc, Vec<u8>)>,\n    pub time_failures: Vec<(TestDesc, Vec<u8>)>,\n    pub options: Options,\n}\n\nimpl ConsoleTestState {\n    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestState> {\n        let log_out = match opts.logfile {\n            Some(ref path) => Some(File::create(path)?),\n            None => None,\n        };\n\n        Ok(ConsoleTestState {\n            log_out,\n            total: 0,\n            passed: 0,\n            failed: 0,\n            ignored: 0,\n            allowed_fail: 0,\n            filtered_out: 0,\n            measured: 0,\n            exec_time: None,\n            metrics: MetricMap::new(),\n            failures: Vec::new(),\n            not_failures: Vec::new(),\n            time_failures: Vec::new(),\n            options: opts.options,\n        })\n    }\n\n    pub fn write_log<F, S>(&mut self, msg: F) -> io::Result<()>\n    where\n        S: AsRef<str>,\n        F: FnOnce() -> S,\n    {\n        match self.log_out {\n            None => Ok(()),\n            Some(ref mut o) => {\n                let msg = msg();\n                let msg = msg.as_ref();\n                o.write_all(msg.as_bytes())\n            }\n        }\n    }\n\n    pub fn write_log_result(\n        &mut self,\n        test: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&TestExecTime>,\n    ) -> io::Result<()> {\n        self.write_log(|| {\n            format!(\n                \"{} {}\",\n                match *result {\n                    TestResult::TrOk => \"ok\".to_owned(),\n                    TestResult::TrFailed => \"failed\".to_owned(),\n                    TestResult::TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n                    TestResult::TrIgnored => \"ignored\".to_owned(),\n                    TestResult::TrAllowedFail => \"failed (allowed)\".to_owned(),\n                    TestResult::TrBench(ref bs) => fmt_bench_samples(bs),\n                    TestResult::TrTimedFail => \"failed (time limit exceeded)\".to_owned(),\n                },\n                test.name,\n            )\n        })?;\n        if let Some(exec_time) = exec_time {\n            self.write_log(|| format!(\" <{}>\", exec_time))?;\n        }\n        self.write_log(|| \"\\n\")\n    }\n\n    fn current_test_count(&self) -> usize {\n        self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n    }\n}\n\n// List the tests to console, and optionally to logfile. Filters are honored.\npub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n    let mut output = match term::stdout() {\n        None => OutputLocation::Raw(io::stdout()),\n        Some(t) => OutputLocation::Pretty(t),\n    };\n\n    let quiet = opts.format == OutputFormat::Terse;\n    let mut st = ConsoleTestState::new(opts)?;\n\n    let mut ntest = 0;\n    let mut nbench = 0;\n\n    for test in filter_tests(&opts, tests) {\n        use crate::TestFn::*;\n\n        let TestDescAndFn { desc: TestDesc { name, .. }, testfn } = test;\n\n        let fntype = match testfn {\n            StaticTestFn(..) | DynTestFn(..) => {\n                ntest += 1;\n                \"test\"\n            }\n            StaticBenchFn(..) | DynBenchFn(..) => {\n                nbench += 1;\n                \"benchmark\"\n            }\n        };\n\n        writeln!(output, \"{}: {}\", name, fntype)?;\n        st.write_log(|| format!(\"{} {}\\n\", fntype, name))?;\n    }\n\n    fn plural(count: u32, s: &str) -> String {\n        match count {\n            1 => format!(\"{} {}\", 1, s),\n            n => format!(\"{} {}s\", n, s),\n        }\n    }\n\n    if !quiet {\n        if ntest != 0 || nbench != 0 {\n            writeln!(output)?;\n        }\n\n        writeln!(output, \"{}, {}\", plural(ntest, \"test\"), plural(nbench, \"benchmark\"))?;\n    }\n\n    Ok(())\n}\n\n// Updates `ConsoleTestState` depending on result of the test execution.\nfn handle_test_result(st: &mut ConsoleTestState, completed_test: CompletedTest) {\n    let test = completed_test.desc;\n    let stdout = completed_test.stdout;\n    match completed_test.result {\n        TestResult::TrOk => {\n            st.passed += 1;\n            st.not_failures.push((test, stdout));\n        }\n        TestResult::TrIgnored => st.ignored += 1,\n        TestResult::TrAllowedFail => st.allowed_fail += 1,\n        TestResult::TrBench(bs) => {\n            st.metrics.insert_metric(\n                test.name.as_slice(),\n                bs.ns_iter_summ.median,\n                bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n            );\n            st.measured += 1\n        }\n        TestResult::TrFailed => {\n            st.failed += 1;\n            st.failures.push((test, stdout));\n        }\n        TestResult::TrFailedMsg(msg) => {\n            st.failed += 1;\n            let mut stdout = stdout;\n            stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n            st.failures.push((test, stdout));\n        }\n        TestResult::TrTimedFail => {\n            st.failed += 1;\n            st.time_failures.push((test, stdout));\n        }\n    }\n}\n\n// Handler for events that occur during test execution.\n// It is provided as a callback to the `run_tests` function.\nfn on_test_event(\n    event: &TestEvent,\n    st: &mut ConsoleTestState,\n    out: &mut dyn OutputFormatter,\n) -> io::Result<()> {\n    match (*event).clone() {\n        TestEvent::TeFiltered(ref filtered_tests) => {\n            st.total = filtered_tests.len();\n            out.write_run_start(filtered_tests.len())?;\n        }\n        TestEvent::TeFilteredOut(filtered_out) => {\n            st.filtered_out = filtered_out;\n        }\n        TestEvent::TeWait(ref test) => out.write_test_start(test)?,\n        TestEvent::TeTimeout(ref test) => out.write_timeout(test)?,\n        TestEvent::TeResult(completed_test) => {\n            let test = &completed_test.desc;\n            let result = &completed_test.result;\n            let exec_time = &completed_test.exec_time;\n            let stdout = &completed_test.stdout;\n\n            st.write_log_result(test, result, exec_time.as_ref())?;\n            out.write_result(test, result, exec_time.as_ref(), &*stdout, st)?;\n            handle_test_result(st, completed_test);\n        }\n    }\n\n    Ok(())\n}\n\n/// A simple console test runner.\n/// Runs provided tests reporting process and results to the stdout.\npub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n    let output = match term::stdout() {\n        None => OutputLocation::Raw(io::stdout()),\n        Some(t) => OutputLocation::Pretty(t),\n    };\n\n    let max_name_len = tests\n        .iter()\n        .max_by_key(|t| len_if_padded(*t))\n        .map(|t| t.desc.name.as_slice().len())\n        .unwrap_or(0);\n\n    let is_multithreaded = opts.test_threads.unwrap_or_else(get_concurrency) > 1;\n\n    let mut out: Box<dyn OutputFormatter> = match opts.format {\n        OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n            output,\n            opts.use_color(),\n            max_name_len,\n            is_multithreaded,\n            opts.time_options,\n        )),\n        OutputFormat::Terse => {\n            Box::new(TerseFormatter::new(output, opts.use_color(), max_name_len, is_multithreaded))\n        }\n        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n        OutputFormat::Junit => Box::new(JunitFormatter::new(output)),\n    };\n    let mut st = ConsoleTestState::new(opts)?;\n\n    // Prevent the usage of `Instant` in some cases:\n    // - It's currently not supported for wasm targets.\n    // - We disable it for miri because it's not available when isolation is enabled.\n    let is_instant_supported = !cfg!(target_arch = \"wasm32\") && !cfg!(miri);\n\n    let start_time = is_instant_supported.then(Instant::now);\n    run_tests(opts, tests, |x| on_test_event(&x, &mut st, &mut *out))?;\n    st.exec_time = start_time.map(|t| TestSuiteExecTime(t.elapsed()));\n\n    assert!(st.current_test_count() == st.total);\n\n    out.write_run_finish(&st)\n}\n\n// Calculates padding for given test description.\nfn len_if_padded(t: &TestDescAndFn) -> usize {\n    match t.testfn.padding() {\n        NamePadding::PadNone => 0,\n        NamePadding::PadOnRight => t.desc.name.as_slice().len(),\n    }\n}\n"],["2651","//! Common types used by `libtest`.\n\nuse std::borrow::Cow;\nuse std::fmt;\n\nuse super::bench::Bencher;\nuse super::options;\n\npub use NamePadding::*;\npub use TestFn::*;\npub use TestName::*;\n\n/// Type of the test according to the [rust book](https://doc.rust-lang.org/cargo/guide/tests.html)\n/// conventions.\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\npub enum TestType {\n    /// Unit-tests are expected to be in the `src` folder of the crate.\n    UnitTest,\n    /// Integration-style tests are expected to be in the `tests` folder of the crate.\n    IntegrationTest,\n    /// Doctests are created by the `librustdoc` manually, so it's a different type of test.\n    DocTest,\n    /// Tests for the sources that don't follow the project layout convention\n    /// (e.g. tests in raw `main.rs` compiled by calling `rustc --test` directly).\n    Unknown,\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\npub enum NamePadding {\n    PadNone,\n    PadOnRight,\n}\n\n// The name of a test. By convention this follows the rules for rust\n// paths; i.e., it should be a series of identifiers separated by double\n// colons. This way if some test runner wants to arrange the tests\n// hierarchically it may.\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum TestName {\n    StaticTestName(&'static str),\n    DynTestName(String),\n    AlignedTestName(Cow<'static, str>, NamePadding),\n}\n\nimpl TestName {\n    pub fn as_slice(&self) -> &str {\n        match *self {\n            StaticTestName(s) => s,\n            DynTestName(ref s) => s,\n            AlignedTestName(ref s, _) => &*s,\n        }\n    }\n\n    pub fn padding(&self) -> NamePadding {\n        match self {\n            &AlignedTestName(_, p) => p,\n            _ => PadNone,\n        }\n    }\n\n    pub fn with_padding(&self, padding: NamePadding) -> TestName {\n        let name = match *self {\n            TestName::StaticTestName(name) => Cow::Borrowed(name),\n            TestName::DynTestName(ref name) => Cow::Owned(name.clone()),\n            TestName::AlignedTestName(ref name, _) => name.clone(),\n        };\n\n        TestName::AlignedTestName(name, padding)\n    }\n}\nimpl fmt::Display for TestName {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.as_slice(), f)\n    }\n}\n\n/// Represents a benchmark function.\npub trait TDynBenchFn: Send {\n    fn run(&self, harness: &mut Bencher);\n}\n\n// A function that runs a test. If the function returns successfully,\n// the test succeeds; if the function panics then the test fails. We\n// may need to come up with a more clever definition of test in order\n// to support isolation of tests into threads.\npub enum TestFn {\n    StaticTestFn(fn()),\n    StaticBenchFn(fn(&mut Bencher)),\n    DynTestFn(Box<dyn FnOnce() + Send>),\n    DynBenchFn(Box<dyn TDynBenchFn + 'static>),\n}\n\nimpl TestFn {\n    pub fn padding(&self) -> NamePadding {\n        match *self {\n            StaticTestFn(..) => PadNone,\n            StaticBenchFn(..) => PadOnRight,\n            DynTestFn(..) => PadNone,\n            DynBenchFn(..) => PadOnRight,\n        }\n    }\n}\n\nimpl fmt::Debug for TestFn {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(match *self {\n            StaticTestFn(..) => \"StaticTestFn(..)\",\n            StaticBenchFn(..) => \"StaticBenchFn(..)\",\n            DynTestFn(..) => \"DynTestFn(..)\",\n            DynBenchFn(..) => \"DynBenchFn(..)\",\n        })\n    }\n}\n\n// A unique integer associated with each test.\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct TestId(pub usize);\n\n// The definition of a single test. A test runner will run a list of\n// these.\n#[derive(Clone, Debug)]\npub struct TestDesc {\n    pub name: TestName,\n    pub ignore: bool,\n    pub should_panic: options::ShouldPanic,\n    pub allow_fail: bool,\n    #[cfg(not(bootstrap))]\n    pub compile_fail: bool,\n    #[cfg(not(bootstrap))]\n    pub no_run: bool,\n    pub test_type: TestType,\n}\n\nimpl TestDesc {\n    pub fn padded_name(&self, column_count: usize, align: NamePadding) -> String {\n        let mut name = String::from(self.name.as_slice());\n        let fill = column_count.saturating_sub(name.len());\n        let pad = \" \".repeat(fill);\n        match align {\n            PadNone => name,\n            PadOnRight => {\n                name.push_str(&pad);\n                name\n            }\n        }\n    }\n\n    /// Returns None for ignored test or that that are just run, otherwise give a description of the type of test.\n    /// Descriptions include \"should panic\", \"compile fail\" and \"compile\".\n    #[cfg(not(bootstrap))]\n    pub fn test_mode(&self) -> Option<&'static str> {\n        if self.ignore {\n            return None;\n        }\n        match self.should_panic {\n            options::ShouldPanic::Yes | options::ShouldPanic::YesWithMessage(_) => {\n                return Some(\"should panic\");\n            }\n            options::ShouldPanic::No => {}\n        }\n        if self.allow_fail {\n            return Some(\"allow fail\");\n        }\n        if self.compile_fail {\n            return Some(\"compile fail\");\n        }\n        if self.no_run {\n            return Some(\"compile\");\n        }\n        None\n    }\n\n    #[cfg(bootstrap)]\n    pub fn test_mode(&self) -> Option<&'static str> {\n        None\n    }\n}\n\n#[derive(Debug)]\npub struct TestDescAndFn {\n    pub desc: TestDesc,\n    pub testfn: TestFn,\n}\n"],["2652","use std::{io, io::prelude::Write};\n\nuse super::OutputFormatter;\nuse crate::{\n    bench::fmt_bench_samples,\n    console::{ConsoleTestState, OutputLocation},\n    test_result::TestResult,\n    time,\n    types::NamePadding,\n    types::TestDesc,\n};\n\n// insert a '\\n' after 100 tests in quiet mode\nconst QUIET_MODE_MAX_COLUMN: usize = 100;\n\npub(crate) struct TerseFormatter<T> {\n    out: OutputLocation<T>,\n    use_color: bool,\n    is_multithreaded: bool,\n    /// Number of columns to fill when aligning names\n    max_name_len: usize,\n\n    test_count: usize,\n    total_test_count: usize,\n}\n\nimpl<T: Write> TerseFormatter<T> {\n    pub fn new(\n        out: OutputLocation<T>,\n        use_color: bool,\n        max_name_len: usize,\n        is_multithreaded: bool,\n    ) -> Self {\n        TerseFormatter {\n            out,\n            use_color,\n            max_name_len,\n            is_multithreaded,\n            test_count: 0,\n            total_test_count: 0, // initialized later, when write_run_start is called\n        }\n    }\n\n    pub fn write_ok(&mut self) -> io::Result<()> {\n        self.write_short_result(\".\", term::color::GREEN)\n    }\n\n    pub fn write_failed(&mut self) -> io::Result<()> {\n        self.write_short_result(\"F\", term::color::RED)\n    }\n\n    pub fn write_ignored(&mut self) -> io::Result<()> {\n        self.write_short_result(\"i\", term::color::YELLOW)\n    }\n\n    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n        self.write_short_result(\"a\", term::color::YELLOW)\n    }\n\n    pub fn write_bench(&mut self) -> io::Result<()> {\n        self.write_pretty(\"bench\", term::color::CYAN)\n    }\n\n    pub fn write_short_result(\n        &mut self,\n        result: &str,\n        color: term::color::Color,\n    ) -> io::Result<()> {\n        self.write_pretty(result, color)?;\n        if self.test_count % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n            // we insert a new line every 100 dots in order to flush the\n            // screen when dealing with line-buffered output (e.g., piping to\n            // `stamp` in the rust CI).\n            let out = format!(\" {}/{}\\n\", self.test_count + 1, self.total_test_count);\n            self.write_plain(&out)?;\n        }\n\n        self.test_count += 1;\n        Ok(())\n    }\n\n    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n        match self.out {\n            OutputLocation::Pretty(ref mut term) => {\n                if self.use_color {\n                    term.fg(color)?;\n                }\n                term.write_all(word.as_bytes())?;\n                if self.use_color {\n                    term.reset()?;\n                }\n                term.flush()\n            }\n            OutputLocation::Raw(ref mut stdout) => {\n                stdout.write_all(word.as_bytes())?;\n                stdout.flush()\n            }\n        }\n    }\n\n    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n        let s = s.as_ref();\n        self.out.write_all(s.as_bytes())?;\n        self.out.flush()\n    }\n\n    pub fn write_outputs(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_plain(\"\\nsuccesses:\\n\")?;\n        let mut successes = Vec::new();\n        let mut stdouts = String::new();\n        for &(ref f, ref stdout) in &state.not_failures {\n            successes.push(f.name.to_string());\n            if !stdout.is_empty() {\n                stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                let output = String::from_utf8_lossy(stdout);\n                stdouts.push_str(&output);\n                stdouts.push('\\n');\n            }\n        }\n        if !stdouts.is_empty() {\n            self.write_plain(\"\\n\")?;\n            self.write_plain(&stdouts)?;\n        }\n\n        self.write_plain(\"\\nsuccesses:\\n\")?;\n        successes.sort();\n        for name in &successes {\n            self.write_plain(&format!(\"    {}\\n\", name))?;\n        }\n        Ok(())\n    }\n\n    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_plain(\"\\nfailures:\\n\")?;\n        let mut failures = Vec::new();\n        let mut fail_out = String::new();\n        for &(ref f, ref stdout) in &state.failures {\n            failures.push(f.name.to_string());\n            if !stdout.is_empty() {\n                fail_out.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                let output = String::from_utf8_lossy(stdout);\n                fail_out.push_str(&output);\n                fail_out.push('\\n');\n            }\n        }\n        if !fail_out.is_empty() {\n            self.write_plain(\"\\n\")?;\n            self.write_plain(&fail_out)?;\n        }\n\n        self.write_plain(\"\\nfailures:\\n\")?;\n        failures.sort();\n        for name in &failures {\n            self.write_plain(&format!(\"    {}\\n\", name))?;\n        }\n        Ok(())\n    }\n\n    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n        if let Some(test_mode) = desc.test_mode() {\n            self.write_plain(&format!(\"test {} - {} ... \", name, test_mode))?;\n        } else {\n            self.write_plain(&format!(\"test {} ... \", name))?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl<T: Write> OutputFormatter for TerseFormatter<T> {\n    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n        self.total_test_count = test_count;\n        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n    }\n\n    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n        // Remnants from old libtest code that used the padding value\n        // in order to indicate benchmarks.\n        // When running benchmarks, terse-mode should still print their name as if\n        // it is the Pretty formatter.\n        if !self.is_multithreaded && desc.name.padding() == NamePadding::PadOnRight {\n            self.write_test_name(desc)?;\n        }\n\n        Ok(())\n    }\n\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        _: Option<&time::TestExecTime>,\n        _: &[u8],\n        _: &ConsoleTestState,\n    ) -> io::Result<()> {\n        match *result {\n            TestResult::TrOk => self.write_ok(),\n            TestResult::TrFailed | TestResult::TrFailedMsg(_) | TestResult::TrTimedFail => {\n                self.write_failed()\n            }\n            TestResult::TrIgnored => self.write_ignored(),\n            TestResult::TrAllowedFail => self.write_allowed_fail(),\n            TestResult::TrBench(ref bs) => {\n                if self.is_multithreaded {\n                    self.write_test_name(desc)?;\n                }\n                self.write_bench()?;\n                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n            }\n        }\n    }\n\n    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n        self.write_plain(&format!(\n            \"test {} has been running for over {} seconds\\n\",\n            desc.name,\n            time::TEST_WARN_TIMEOUT_S\n        ))\n    }\n\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n        if state.options.display_output {\n            self.write_outputs(state)?;\n        }\n        let success = state.failed == 0;\n        if !success {\n            self.write_failures(state)?;\n        }\n\n        self.write_plain(\"\\ntest result: \")?;\n\n        if success {\n            // There's no parallelism at this point so it's safe to use color\n            self.write_pretty(\"ok\", term::color::GREEN)?;\n        } else {\n            self.write_pretty(\"FAILED\", term::color::RED)?;\n        }\n\n        let s = if state.allowed_fail > 0 {\n            format!(\n                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\",\n                state.passed,\n                state.failed + state.allowed_fail,\n                state.allowed_fail,\n                state.ignored,\n                state.measured,\n                state.filtered_out\n            )\n        } else {\n            format!(\n                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\",\n                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n            )\n        };\n\n        self.write_plain(&s)?;\n\n        if let Some(ref exec_time) = state.exec_time {\n            let time_str = format!(\"; finished in {}\", exec_time);\n            self.write_plain(&time_str)?;\n        }\n\n        self.write_plain(\"\\n\\n\")?;\n\n        Ok(success)\n    }\n}\n"],["2653","use std::{io, io::prelude::Write};\n\nuse crate::{\n    console::ConsoleTestState,\n    test_result::TestResult,\n    time,\n    types::{TestDesc, TestName},\n};\n\nmod json;\nmod junit;\nmod pretty;\nmod terse;\n\npub(crate) use self::json::JsonFormatter;\npub(crate) use self::junit::JunitFormatter;\npub(crate) use self::pretty::PrettyFormatter;\npub(crate) use self::terse::TerseFormatter;\n\npub(crate) trait OutputFormatter {\n    fn write_run_start(&mut self, test_count: usize) -> io::Result<()>;\n    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()>;\n    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&time::TestExecTime>,\n        stdout: &[u8],\n        state: &ConsoleTestState,\n    ) -> io::Result<()>;\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n}\n\npub(crate) fn write_stderr_delimiter(test_output: &mut Vec<u8>, test_name: &TestName) {\n    match test_output.last() {\n        Some(b'\\n') => (),\n        Some(_) => test_output.push(b'\\n'),\n        None => (),\n    }\n    writeln!(test_output, \"---- {} stderr ----\", test_name).unwrap();\n}\n"],["2654","use std::io::{self, prelude::Write};\nuse std::time::Duration;\n\nuse super::OutputFormatter;\nuse crate::{\n    console::{ConsoleTestState, OutputLocation},\n    test_result::TestResult,\n    time,\n    types::{TestDesc, TestType},\n};\n\npub struct JunitFormatter<T> {\n    out: OutputLocation<T>,\n    results: Vec<(TestDesc, TestResult, Duration)>,\n}\n\nimpl<T: Write> JunitFormatter<T> {\n    pub fn new(out: OutputLocation<T>) -> Self {\n        Self { out, results: Vec::new() }\n    }\n\n    fn write_message(&mut self, s: &str) -> io::Result<()> {\n        assert!(!s.contains('\\n'));\n\n        self.out.write_all(s.as_ref())\n    }\n}\n\nimpl<T: Write> OutputFormatter for JunitFormatter<T> {\n    fn write_run_start(&mut self, _test_count: usize) -> io::Result<()> {\n        // We write xml header on run start\n        self.write_message(&\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\")\n    }\n\n    fn write_test_start(&mut self, _desc: &TestDesc) -> io::Result<()> {\n        // We do not output anything on test start.\n        Ok(())\n    }\n\n    fn write_timeout(&mut self, _desc: &TestDesc) -> io::Result<()> {\n        // We do not output anything on test timeout.\n        Ok(())\n    }\n\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&time::TestExecTime>,\n        _stdout: &[u8],\n        _state: &ConsoleTestState,\n    ) -> io::Result<()> {\n        // Because the testsuit node holds some of the information as attributes, we can't write it\n        // until all of the tests has ran. Instead of writting every result as they come in, we add\n        // them to a Vec and write them all at once when run is complete.\n        let duration = exec_time.map(|t| t.0.clone()).unwrap_or_default();\n        self.results.push((desc.clone(), result.clone(), duration));\n        Ok(())\n    }\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n        self.write_message(\"<testsuites>\")?;\n\n        self.write_message(&*format!(\n            \"<testsuite name=\\\"test\\\" package=\\\"test\\\" id=\\\"0\\\" \\\n             errors=\\\"0\\\" \\\n             failures=\\\"{}\\\" \\\n             tests=\\\"{}\\\" \\\n             skipped=\\\"{}\\\" \\\n             >\",\n            state.failed, state.total, state.ignored\n        ))?;\n        for (desc, result, duration) in std::mem::replace(&mut self.results, Vec::new()) {\n            let (class_name, test_name) = parse_class_name(&desc);\n            match result {\n                TestResult::TrIgnored => { /* no-op */ }\n                TestResult::TrFailed => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\">\",\n                        class_name,\n                        test_name,\n                        duration.as_secs_f64()\n                    ))?;\n                    self.write_message(\"<failure type=\\\"assert\\\"/>\")?;\n                    self.write_message(\"</testcase>\")?;\n                }\n\n                TestResult::TrFailedMsg(ref m) => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\">\",\n                        class_name,\n                        test_name,\n                        duration.as_secs_f64()\n                    ))?;\n                    self.write_message(&*format!(\"<failure message=\\\"{}\\\" type=\\\"assert\\\"/>\", m))?;\n                    self.write_message(\"</testcase>\")?;\n                }\n\n                TestResult::TrTimedFail => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\">\",\n                        class_name,\n                        test_name,\n                        duration.as_secs_f64()\n                    ))?;\n                    self.write_message(\"<failure type=\\\"timeout\\\"/>\")?;\n                    self.write_message(\"</testcase>\")?;\n                }\n\n                TestResult::TrBench(ref b) => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"benchmark::{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\" />\",\n                        class_name, test_name, b.ns_iter_summ.sum\n                    ))?;\n                }\n\n                TestResult::TrOk | TestResult::TrAllowedFail => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\"/>\",\n                        class_name,\n                        test_name,\n                        duration.as_secs_f64()\n                    ))?;\n                }\n            }\n        }\n        self.write_message(\"<system-out/>\")?;\n        self.write_message(\"<system-err/>\")?;\n        self.write_message(\"</testsuite>\")?;\n        self.write_message(\"</testsuites>\")?;\n\n        Ok(state.failed == 0)\n    }\n}\n\nfn parse_class_name(desc: &TestDesc) -> (String, String) {\n    match desc.test_type {\n        TestType::UnitTest => parse_class_name_unit(desc),\n        TestType::DocTest => parse_class_name_doc(desc),\n        TestType::IntegrationTest => parse_class_name_integration(desc),\n        TestType::Unknown => (String::from(\"unknown\"), String::from(desc.name.as_slice())),\n    }\n}\n\nfn parse_class_name_unit(desc: &TestDesc) -> (String, String) {\n    // Module path => classname\n    // Function name => name\n    let module_segments: Vec<&str> = desc.name.as_slice().split(\"::\").collect();\n    let (class_name, test_name) = match module_segments[..] {\n        [test] => (String::from(\"crate\"), String::from(test)),\n        [ref path @ .., test] => (path.join(\"::\"), String::from(test)),\n        [..] => unreachable!(),\n    };\n    (class_name, test_name)\n}\n\nfn parse_class_name_doc(desc: &TestDesc) -> (String, String) {\n    // File path => classname\n    // Line # => test name\n    let segments: Vec<&str> = desc.name.as_slice().split(\" - \").collect();\n    let (class_name, test_name) = match segments[..] {\n        [file, line] => (String::from(file.trim()), String::from(line.trim())),\n        [..] => unreachable!(),\n    };\n    (class_name, test_name)\n}\n\nfn parse_class_name_integration(desc: &TestDesc) -> (String, String) {\n    (String::from(\"integration\"), String::from(desc.name.as_slice()))\n}\n"],["2655","use std::{io, io::prelude::Write};\n\nuse super::OutputFormatter;\nuse crate::{\n    bench::fmt_bench_samples,\n    console::{ConsoleTestState, OutputLocation},\n    test_result::TestResult,\n    time,\n    types::TestDesc,\n};\n\npub(crate) struct PrettyFormatter<T> {\n    out: OutputLocation<T>,\n    use_color: bool,\n    time_options: Option<time::TestTimeOptions>,\n\n    /// Number of columns to fill when aligning names\n    max_name_len: usize,\n\n    is_multithreaded: bool,\n}\n\nimpl<T: Write> PrettyFormatter<T> {\n    pub fn new(\n        out: OutputLocation<T>,\n        use_color: bool,\n        max_name_len: usize,\n        is_multithreaded: bool,\n        time_options: Option<time::TestTimeOptions>,\n    ) -> Self {\n        PrettyFormatter { out, use_color, max_name_len, is_multithreaded, time_options }\n    }\n\n    #[cfg(test)]\n    pub fn output_location(&self) -> &OutputLocation<T> {\n        &self.out\n    }\n\n    pub fn write_ok(&mut self) -> io::Result<()> {\n        self.write_short_result(\"ok\", term::color::GREEN)\n    }\n\n    pub fn write_failed(&mut self) -> io::Result<()> {\n        self.write_short_result(\"FAILED\", term::color::RED)\n    }\n\n    pub fn write_ignored(&mut self) -> io::Result<()> {\n        self.write_short_result(\"ignored\", term::color::YELLOW)\n    }\n\n    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n        self.write_short_result(\"FAILED (allowed)\", term::color::YELLOW)\n    }\n\n    pub fn write_time_failed(&mut self) -> io::Result<()> {\n        self.write_short_result(\"FAILED (time limit exceeded)\", term::color::RED)\n    }\n\n    pub fn write_bench(&mut self) -> io::Result<()> {\n        self.write_pretty(\"bench\", term::color::CYAN)\n    }\n\n    pub fn write_short_result(\n        &mut self,\n        result: &str,\n        color: term::color::Color,\n    ) -> io::Result<()> {\n        self.write_pretty(result, color)\n    }\n\n    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n        match self.out {\n            OutputLocation::Pretty(ref mut term) => {\n                if self.use_color {\n                    term.fg(color)?;\n                }\n                term.write_all(word.as_bytes())?;\n                if self.use_color {\n                    term.reset()?;\n                }\n                term.flush()\n            }\n            OutputLocation::Raw(ref mut stdout) => {\n                stdout.write_all(word.as_bytes())?;\n                stdout.flush()\n            }\n        }\n    }\n\n    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n        let s = s.as_ref();\n        self.out.write_all(s.as_bytes())?;\n        self.out.flush()\n    }\n\n    fn write_time(\n        &mut self,\n        desc: &TestDesc,\n        exec_time: Option<&time::TestExecTime>,\n    ) -> io::Result<()> {\n        if let (Some(opts), Some(time)) = (self.time_options, exec_time) {\n            let time_str = format!(\" <{}>\", time);\n\n            let color = if opts.colored {\n                if opts.is_critical(desc, time) {\n                    Some(term::color::RED)\n                } else if opts.is_warn(desc, time) {\n                    Some(term::color::YELLOW)\n                } else {\n                    None\n                }\n            } else {\n                None\n            };\n\n            match color {\n                Some(color) => self.write_pretty(&time_str, color)?,\n                None => self.write_plain(&time_str)?,\n            }\n        }\n\n        Ok(())\n    }\n\n    fn write_results(\n        &mut self,\n        inputs: &Vec<(TestDesc, Vec<u8>)>,\n        results_type: &str,\n    ) -> io::Result<()> {\n        let results_out_str = format!(\"\\n{}:\\n\", results_type);\n\n        self.write_plain(&results_out_str)?;\n\n        let mut results = Vec::new();\n        let mut stdouts = String::new();\n        for &(ref f, ref stdout) in inputs {\n            results.push(f.name.to_string());\n            if !stdout.is_empty() {\n                stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                let output = String::from_utf8_lossy(stdout);\n                stdouts.push_str(&output);\n                stdouts.push('\\n');\n            }\n        }\n        if !stdouts.is_empty() {\n            self.write_plain(\"\\n\")?;\n            self.write_plain(&stdouts)?;\n        }\n\n        self.write_plain(&results_out_str)?;\n        results.sort();\n        for name in &results {\n            self.write_plain(&format!(\"    {}\\n\", name))?;\n        }\n        Ok(())\n    }\n\n    pub fn write_successes(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_results(&state.not_failures, \"successes\")\n    }\n\n    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_results(&state.failures, \"failures\")\n    }\n\n    pub fn write_time_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_results(&state.time_failures, \"failures (time limit exceeded)\")\n    }\n\n    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n        if let Some(test_mode) = desc.test_mode() {\n            self.write_plain(&format!(\"test {} - {} ... \", name, test_mode))?;\n        } else {\n            self.write_plain(&format!(\"test {} ... \", name))?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl<T: Write> OutputFormatter for PrettyFormatter<T> {\n    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n    }\n\n    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n        // When running tests concurrently, we should not print\n        // the test's name as the result will be mis-aligned.\n        // When running the tests serially, we print the name here so\n        // that the user can see which test hangs.\n        if !self.is_multithreaded {\n            self.write_test_name(desc)?;\n        }\n\n        Ok(())\n    }\n\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&time::TestExecTime>,\n        _: &[u8],\n        _: &ConsoleTestState,\n    ) -> io::Result<()> {\n        if self.is_multithreaded {\n            self.write_test_name(desc)?;\n        }\n\n        match *result {\n            TestResult::TrOk => self.write_ok()?,\n            TestResult::TrFailed | TestResult::TrFailedMsg(_) => self.write_failed()?,\n            TestResult::TrIgnored => self.write_ignored()?,\n            TestResult::TrAllowedFail => self.write_allowed_fail()?,\n            TestResult::TrBench(ref bs) => {\n                self.write_bench()?;\n                self.write_plain(&format!(\": {}\", fmt_bench_samples(bs)))?;\n            }\n            TestResult::TrTimedFail => self.write_time_failed()?,\n        }\n\n        self.write_time(desc, exec_time)?;\n        self.write_plain(\"\\n\")\n    }\n\n    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n        self.write_plain(&format!(\n            \"test {} has been running for over {} seconds\\n\",\n            desc.name,\n            time::TEST_WARN_TIMEOUT_S\n        ))\n    }\n\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n        if state.options.display_output {\n            self.write_successes(state)?;\n        }\n        let success = state.failed == 0;\n        if !success {\n            if !state.failures.is_empty() {\n                self.write_failures(state)?;\n            }\n\n            if !state.time_failures.is_empty() {\n                self.write_time_failures(state)?;\n            }\n        }\n\n        self.write_plain(\"\\ntest result: \")?;\n\n        if success {\n            // There's no parallelism at this point so it's safe to use color\n            self.write_pretty(\"ok\", term::color::GREEN)?;\n        } else {\n            self.write_pretty(\"FAILED\", term::color::RED)?;\n        }\n\n        let s = if state.allowed_fail > 0 {\n            format!(\n                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\",\n                state.passed,\n                state.failed + state.allowed_fail,\n                state.allowed_fail,\n                state.ignored,\n                state.measured,\n                state.filtered_out\n            )\n        } else {\n            format!(\n                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\",\n                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n            )\n        };\n\n        self.write_plain(&s)?;\n\n        if let Some(ref exec_time) = state.exec_time {\n            let time_str = format!(\"; finished in {}\", exec_time);\n            self.write_plain(&time_str)?;\n        }\n\n        self.write_plain(\"\\n\\n\")?;\n\n        Ok(success)\n    }\n}\n"],["2656","use std::{borrow::Cow, io, io::prelude::Write};\n\nuse super::OutputFormatter;\nuse crate::{\n    console::{ConsoleTestState, OutputLocation},\n    test_result::TestResult,\n    time,\n    types::TestDesc,\n};\n\npub(crate) struct JsonFormatter<T> {\n    out: OutputLocation<T>,\n}\n\nimpl<T: Write> JsonFormatter<T> {\n    pub fn new(out: OutputLocation<T>) -> Self {\n        Self { out }\n    }\n\n    fn writeln_message(&mut self, s: &str) -> io::Result<()> {\n        assert!(!s.contains('\\n'));\n\n        self.out.write_all(s.as_ref())?;\n        self.out.write_all(b\"\\n\")\n    }\n\n    fn write_message(&mut self, s: &str) -> io::Result<()> {\n        assert!(!s.contains('\\n'));\n\n        self.out.write_all(s.as_ref())\n    }\n\n    fn write_event(\n        &mut self,\n        ty: &str,\n        name: &str,\n        evt: &str,\n        exec_time: Option<&time::TestExecTime>,\n        stdout: Option<Cow<'_, str>>,\n        extra: Option<&str>,\n    ) -> io::Result<()> {\n        // A doc test's name includes a filename which must be escaped for correct json.\n        self.write_message(&*format!(\n            r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\"\"#,\n            ty,\n            EscapedString(name),\n            evt\n        ))?;\n        if let Some(exec_time) = exec_time {\n            self.write_message(&*format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64()))?;\n        }\n        if let Some(stdout) = stdout {\n            self.write_message(&*format!(r#\", \"stdout\": \"{}\"\"#, EscapedString(stdout)))?;\n        }\n        if let Some(extra) = extra {\n            self.write_message(&*format!(r#\", {}\"#, extra))?;\n        }\n        self.writeln_message(\" }\")\n    }\n}\n\nimpl<T: Write> OutputFormatter for JsonFormatter<T> {\n    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n        self.writeln_message(&*format!(\n            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {} }}\"#,\n            test_count\n        ))\n    }\n\n    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n        self.writeln_message(&*format!(\n            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n            EscapedString(desc.name.as_slice())\n        ))\n    }\n\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&time::TestExecTime>,\n        stdout: &[u8],\n        state: &ConsoleTestState,\n    ) -> io::Result<()> {\n        let display_stdout = state.options.display_output || *result != TestResult::TrOk;\n        let stdout = if display_stdout && !stdout.is_empty() {\n            Some(String::from_utf8_lossy(stdout))\n        } else {\n            None\n        };\n        match *result {\n            TestResult::TrOk => {\n                self.write_event(\"test\", desc.name.as_slice(), \"ok\", exec_time, stdout, None)\n            }\n\n            TestResult::TrFailed => {\n                self.write_event(\"test\", desc.name.as_slice(), \"failed\", exec_time, stdout, None)\n            }\n\n            TestResult::TrTimedFail => self.write_event(\n                \"test\",\n                desc.name.as_slice(),\n                \"failed\",\n                exec_time,\n                stdout,\n                Some(r#\"\"reason\": \"time limit exceeded\"\"#),\n            ),\n\n            TestResult::TrFailedMsg(ref m) => self.write_event(\n                \"test\",\n                desc.name.as_slice(),\n                \"failed\",\n                exec_time,\n                stdout,\n                Some(&*format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n            ),\n\n            TestResult::TrIgnored => {\n                self.write_event(\"test\", desc.name.as_slice(), \"ignored\", exec_time, stdout, None)\n            }\n\n            TestResult::TrAllowedFail => self.write_event(\n                \"test\",\n                desc.name.as_slice(),\n                \"allowed_failure\",\n                exec_time,\n                stdout,\n                None,\n            ),\n\n            TestResult::TrBench(ref bs) => {\n                let median = bs.ns_iter_summ.median as usize;\n                let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n\n                let mbps = if bs.mb_s == 0 {\n                    String::new()\n                } else {\n                    format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n                };\n\n                let line = format!(\n                    \"{{ \\\"type\\\": \\\"bench\\\", \\\n                     \\\"name\\\": \\\"{}\\\", \\\n                     \\\"median\\\": {}, \\\n                     \\\"deviation\\\": {}{} }}\",\n                    EscapedString(desc.name.as_slice()),\n                    median,\n                    deviation,\n                    mbps\n                );\n\n                self.writeln_message(&*line)\n            }\n        }\n    }\n\n    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n        self.writeln_message(&*format!(\n            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n            EscapedString(desc.name.as_slice())\n        ))\n    }\n\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n        self.write_message(&*format!(\n            \"{{ \\\"type\\\": \\\"suite\\\", \\\n             \\\"event\\\": \\\"{}\\\", \\\n             \\\"passed\\\": {}, \\\n             \\\"failed\\\": {}, \\\n             \\\"allowed_fail\\\": {}, \\\n             \\\"ignored\\\": {}, \\\n             \\\"measured\\\": {}, \\\n             \\\"filtered_out\\\": {}\",\n            if state.failed == 0 { \"ok\" } else { \"failed\" },\n            state.passed,\n            state.failed + state.allowed_fail,\n            state.allowed_fail,\n            state.ignored,\n            state.measured,\n            state.filtered_out,\n        ))?;\n\n        if let Some(ref exec_time) = state.exec_time {\n            let time_str = format!(\", \\\"exec_time\\\": {}\", exec_time.0.as_secs_f64());\n            self.write_message(&time_str)?;\n        }\n\n        self.writeln_message(\" }\")?;\n\n        Ok(state.failed == 0)\n    }\n}\n\n/// A formatting utility used to print strings with characters in need of escaping.\n/// Base code taken form `libserialize::json::escape_str`\nstruct EscapedString<S: AsRef<str>>(S);\n\nimpl<S: AsRef<str>> std::fmt::Display for EscapedString<S> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n        let mut start = 0;\n\n        for (i, byte) in self.0.as_ref().bytes().enumerate() {\n            let escaped = match byte {\n                b'\"' => \"\\\\\\\"\",\n                b'\\\\' => \"\\\\\\\\\",\n                b'\\x00' => \"\\\\u0000\",\n                b'\\x01' => \"\\\\u0001\",\n                b'\\x02' => \"\\\\u0002\",\n                b'\\x03' => \"\\\\u0003\",\n                b'\\x04' => \"\\\\u0004\",\n                b'\\x05' => \"\\\\u0005\",\n                b'\\x06' => \"\\\\u0006\",\n                b'\\x07' => \"\\\\u0007\",\n                b'\\x08' => \"\\\\b\",\n                b'\\t' => \"\\\\t\",\n                b'\\n' => \"\\\\n\",\n                b'\\x0b' => \"\\\\u000b\",\n                b'\\x0c' => \"\\\\f\",\n                b'\\r' => \"\\\\r\",\n                b'\\x0e' => \"\\\\u000e\",\n                b'\\x0f' => \"\\\\u000f\",\n                b'\\x10' => \"\\\\u0010\",\n                b'\\x11' => \"\\\\u0011\",\n                b'\\x12' => \"\\\\u0012\",\n                b'\\x13' => \"\\\\u0013\",\n                b'\\x14' => \"\\\\u0014\",\n                b'\\x15' => \"\\\\u0015\",\n                b'\\x16' => \"\\\\u0016\",\n                b'\\x17' => \"\\\\u0017\",\n                b'\\x18' => \"\\\\u0018\",\n                b'\\x19' => \"\\\\u0019\",\n                b'\\x1a' => \"\\\\u001a\",\n                b'\\x1b' => \"\\\\u001b\",\n                b'\\x1c' => \"\\\\u001c\",\n                b'\\x1d' => \"\\\\u001d\",\n                b'\\x1e' => \"\\\\u001e\",\n                b'\\x1f' => \"\\\\u001f\",\n                b'\\x7f' => \"\\\\u007f\",\n                _ => {\n                    continue;\n                }\n            };\n\n            if start < i {\n                f.write_str(&self.0.as_ref()[start..i])?;\n            }\n\n            f.write_str(escaped)?;\n\n            start = i + 1;\n        }\n\n        if start != self.0.as_ref().len() {\n            f.write_str(&self.0.as_ref()[start..])?;\n        }\n\n        Ok(())\n    }\n}\n"],["2657","//! Module `time` contains everything related to the time measurement of unit tests\n//! execution.\n//! The purposes of this module:\n//! - Check whether test is timed out.\n//! - Provide helpers for `report-time` and `measure-time` options.\n//! - Provide newtypes for executions times.\n\nuse std::env;\nuse std::fmt;\nuse std::str::FromStr;\nuse std::time::{Duration, Instant};\n\nuse super::types::{TestDesc, TestType};\n\npub const TEST_WARN_TIMEOUT_S: u64 = 60;\n\n/// This small module contains constants used by `report-time` option.\n/// Those constants values will be used if corresponding environment variables are not set.\n///\n/// To override values for unit-tests, use a constant `RUST_TEST_TIME_UNIT`,\n/// To override values for integration tests, use a constant `RUST_TEST_TIME_INTEGRATION`,\n/// To override values for doctests, use a constant `RUST_TEST_TIME_DOCTEST`.\n///\n/// Example of the expected format is `RUST_TEST_TIME_xxx=100,200`, where 100 means\n/// warn time, and 200 means critical time.\npub mod time_constants {\n    use super::TEST_WARN_TIMEOUT_S;\n    use std::time::Duration;\n\n    /// Environment variable for overriding default threshold for unit-tests.\n    pub const UNIT_ENV_NAME: &str = \"RUST_TEST_TIME_UNIT\";\n\n    // Unit tests are supposed to be really quick.\n    pub const UNIT_WARN: Duration = Duration::from_millis(50);\n    pub const UNIT_CRITICAL: Duration = Duration::from_millis(100);\n\n    /// Environment variable for overriding default threshold for unit-tests.\n    pub const INTEGRATION_ENV_NAME: &str = \"RUST_TEST_TIME_INTEGRATION\";\n\n    // Integration tests may have a lot of work, so they can take longer to execute.\n    pub const INTEGRATION_WARN: Duration = Duration::from_millis(500);\n    pub const INTEGRATION_CRITICAL: Duration = Duration::from_millis(1000);\n\n    /// Environment variable for overriding default threshold for unit-tests.\n    pub const DOCTEST_ENV_NAME: &str = \"RUST_TEST_TIME_DOCTEST\";\n\n    // Doctests are similar to integration tests, because they can include a lot of\n    // initialization code.\n    pub const DOCTEST_WARN: Duration = INTEGRATION_WARN;\n    pub const DOCTEST_CRITICAL: Duration = INTEGRATION_CRITICAL;\n\n    // Do not suppose anything about unknown tests, base limits on the\n    // `TEST_WARN_TIMEOUT_S` constant.\n    pub const UNKNOWN_WARN: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S);\n    pub const UNKNOWN_CRITICAL: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S * 2);\n}\n\n/// Returns an `Instance` object denoting when the test should be considered\n/// timed out.\npub fn get_default_test_timeout() -> Instant {\n    Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S)\n}\n\n/// The measured execution time of a unit test.\n#[derive(Debug, Clone, PartialEq)]\npub struct TestExecTime(pub Duration);\n\nimpl fmt::Display for TestExecTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:.3}s\", self.0.as_secs_f64())\n    }\n}\n\n/// The measured execution time of the whole test suite.\n#[derive(Debug, Clone, Default, PartialEq)]\npub struct TestSuiteExecTime(pub Duration);\n\nimpl fmt::Display for TestSuiteExecTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:.2}s\", self.0.as_secs_f64())\n    }\n}\n\n/// Structure denoting time limits for test execution.\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\npub struct TimeThreshold {\n    pub warn: Duration,\n    pub critical: Duration,\n}\n\nimpl TimeThreshold {\n    /// Creates a new `TimeThreshold` instance with provided durations.\n    pub fn new(warn: Duration, critical: Duration) -> Self {\n        Self { warn, critical }\n    }\n\n    /// Attempts to create a `TimeThreshold` instance with values obtained\n    /// from the environment variable, and returns `None` if the variable\n    /// is not set.\n    /// Environment variable format is expected to match `\\d+,\\d+`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if variable with provided name is set but contains inappropriate\n    /// value.\n    pub fn from_env_var(env_var_name: &str) -> Option<Self> {\n        let durations_str = env::var(env_var_name).ok()?;\n        let (warn_str, critical_str) = durations_str.split_once(',').unwrap_or_else(|| {\n            panic!(\n                \"Duration variable {} expected to have 2 numbers separated by comma, but got {}\",\n                env_var_name, durations_str\n            )\n        });\n\n        let parse_u64 = |v| {\n            u64::from_str(v).unwrap_or_else(|_| {\n                panic!(\n                    \"Duration value in variable {} is expected to be a number, but got {}\",\n                    env_var_name, v\n                )\n            })\n        };\n\n        let warn = parse_u64(warn_str);\n        let critical = parse_u64(critical_str);\n        if warn > critical {\n            panic!(\"Test execution warn time should be less or equal to the critical time\");\n        }\n\n        Some(Self::new(Duration::from_millis(warn), Duration::from_millis(critical)))\n    }\n}\n\n/// Structure with parameters for calculating test execution time.\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\npub struct TestTimeOptions {\n    /// Denotes if the test critical execution time limit excess should be considered\n    /// a test failure.\n    pub error_on_excess: bool,\n    pub colored: bool,\n    pub unit_threshold: TimeThreshold,\n    pub integration_threshold: TimeThreshold,\n    pub doctest_threshold: TimeThreshold,\n}\n\nimpl TestTimeOptions {\n    pub fn new_from_env(error_on_excess: bool, colored: bool) -> Self {\n        let unit_threshold = TimeThreshold::from_env_var(time_constants::UNIT_ENV_NAME)\n            .unwrap_or_else(Self::default_unit);\n\n        let integration_threshold =\n            TimeThreshold::from_env_var(time_constants::INTEGRATION_ENV_NAME)\n                .unwrap_or_else(Self::default_integration);\n\n        let doctest_threshold = TimeThreshold::from_env_var(time_constants::DOCTEST_ENV_NAME)\n            .unwrap_or_else(Self::default_doctest);\n\n        Self { error_on_excess, colored, unit_threshold, integration_threshold, doctest_threshold }\n    }\n\n    pub fn is_warn(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n        exec_time.0 >= self.warn_time(test)\n    }\n\n    pub fn is_critical(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n        exec_time.0 >= self.critical_time(test)\n    }\n\n    fn warn_time(&self, test: &TestDesc) -> Duration {\n        match test.test_type {\n            TestType::UnitTest => self.unit_threshold.warn,\n            TestType::IntegrationTest => self.integration_threshold.warn,\n            TestType::DocTest => self.doctest_threshold.warn,\n            TestType::Unknown => time_constants::UNKNOWN_WARN,\n        }\n    }\n\n    fn critical_time(&self, test: &TestDesc) -> Duration {\n        match test.test_type {\n            TestType::UnitTest => self.unit_threshold.critical,\n            TestType::IntegrationTest => self.integration_threshold.critical,\n            TestType::DocTest => self.doctest_threshold.critical,\n            TestType::Unknown => time_constants::UNKNOWN_CRITICAL,\n        }\n    }\n\n    fn default_unit() -> TimeThreshold {\n        TimeThreshold::new(time_constants::UNIT_WARN, time_constants::UNIT_CRITICAL)\n    }\n\n    fn default_integration() -> TimeThreshold {\n        TimeThreshold::new(time_constants::INTEGRATION_WARN, time_constants::INTEGRATION_CRITICAL)\n    }\n\n    fn default_doctest() -> TimeThreshold {\n        TimeThreshold::new(time_constants::DOCTEST_WARN, time_constants::DOCTEST_CRITICAL)\n    }\n}\n"],["2658","#![allow(missing_docs)]\n#![allow(deprecated)] // Float\n\nuse std::mem;\n\n#[cfg(test)]\nmod tests;\n\nfn local_sort(v: &mut [f64]) {\n    v.sort_by(|x: &f64, y: &f64| x.total_cmp(y));\n}\n\n/// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\npub trait Stats {\n    /// Sum of the samples.\n    ///\n    /// Note: this method sacrifices performance at the altar of accuracy\n    /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n    /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric\n    /// Predicates\"][paper]\n    ///\n    /// [paper]: https://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps\n    fn sum(&self) -> f64;\n\n    /// Minimum value of the samples.\n    fn min(&self) -> f64;\n\n    /// Maximum value of the samples.\n    fn max(&self) -> f64;\n\n    /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Arithmetic_mean>\n    fn mean(&self) -> f64;\n\n    /// Median of the samples: value separating the lower half of the samples from the higher half.\n    /// Equal to `self.percentile(50.0)`.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Median>\n    fn median(&self) -> f64;\n\n    /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n    /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n    /// population variance, which is assumed to be unknown. It therefore corrects the `(n-1)/n`\n    /// bias that would appear if we calculated a population variance, by dividing by `(n-1)` rather\n    /// than `n`.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Variance>\n    fn var(&self) -> f64;\n\n    /// Standard deviation: the square root of the sample variance.\n    ///\n    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n    /// `median_abs_dev` for unknown distributions.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Standard_deviation>\n    fn std_dev(&self) -> f64;\n\n    /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n    ///\n    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n    /// `median_abs_dev_pct` for unknown distributions.\n    fn std_dev_pct(&self) -> f64;\n\n    /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n    /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n    /// `std_dev` if you cannot assume your sample is normally distributed. Note that this is scaled\n    /// by the constant `1.4826` to allow its use as a consistent estimator for the standard\n    /// deviation.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Median_absolute_deviation>\n    fn median_abs_dev(&self) -> f64;\n\n    /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n    fn median_abs_dev_pct(&self) -> f64;\n\n    /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n    /// percentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\n    /// satisfy `s <= v`.\n    ///\n    /// Calculated by linear interpolation between closest ranks.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Percentile>\n    fn percentile(&self, pct: f64) -> f64;\n\n    /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n    /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n    /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n    /// is otherwise equivalent.\n    ///\n    /// See also: <https://en.wikipedia.org/wiki/Quartile>\n    fn quartiles(&self) -> (f64, f64, f64);\n\n    /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n    /// percentile (3rd quartile). See `quartiles`.\n    ///\n    /// See also: <https://en.wikipedia.org/wiki/Interquartile_range>\n    fn iqr(&self) -> f64;\n}\n\n/// Extracted collection of all the summary statistics of a sample set.\n#[derive(Debug, Clone, PartialEq, Copy)]\n#[allow(missing_docs)]\npub struct Summary {\n    pub sum: f64,\n    pub min: f64,\n    pub max: f64,\n    pub mean: f64,\n    pub median: f64,\n    pub var: f64,\n    pub std_dev: f64,\n    pub std_dev_pct: f64,\n    pub median_abs_dev: f64,\n    pub median_abs_dev_pct: f64,\n    pub quartiles: (f64, f64, f64),\n    pub iqr: f64,\n}\n\nimpl Summary {\n    /// Construct a new summary of a sample set.\n    pub fn new(samples: &[f64]) -> Summary {\n        Summary {\n            sum: samples.sum(),\n            min: samples.min(),\n            max: samples.max(),\n            mean: samples.mean(),\n            median: samples.median(),\n            var: samples.var(),\n            std_dev: samples.std_dev(),\n            std_dev_pct: samples.std_dev_pct(),\n            median_abs_dev: samples.median_abs_dev(),\n            median_abs_dev_pct: samples.median_abs_dev_pct(),\n            quartiles: samples.quartiles(),\n            iqr: samples.iqr(),\n        }\n    }\n}\n\nimpl Stats for [f64] {\n    // FIXME #11059 handle NaN, inf and overflow\n    fn sum(&self) -> f64 {\n        let mut partials = vec![];\n\n        for &x in self {\n            let mut x = x;\n            let mut j = 0;\n            // This inner loop applies `hi`/`lo` summation to each\n            // partial so that the list of partial sums remains exact.\n            for i in 0..partials.len() {\n                let mut y: f64 = partials[i];\n                if x.abs() < y.abs() {\n                    mem::swap(&mut x, &mut y);\n                }\n                // Rounded `x+y` is stored in `hi` with round-off stored in\n                // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n                let hi = x + y;\n                let lo = y - (hi - x);\n                if lo != 0.0 {\n                    partials[j] = lo;\n                    j += 1;\n                }\n                x = hi;\n            }\n            if j >= partials.len() {\n                partials.push(x);\n            } else {\n                partials[j] = x;\n                partials.truncate(j + 1);\n            }\n        }\n        let zero: f64 = 0.0;\n        partials.iter().fold(zero, |p, q| p + *q)\n    }\n\n    fn min(&self) -> f64 {\n        assert!(!self.is_empty());\n        self.iter().fold(self[0], |p, q| p.min(*q))\n    }\n\n    fn max(&self) -> f64 {\n        assert!(!self.is_empty());\n        self.iter().fold(self[0], |p, q| p.max(*q))\n    }\n\n    fn mean(&self) -> f64 {\n        assert!(!self.is_empty());\n        self.sum() / (self.len() as f64)\n    }\n\n    fn median(&self) -> f64 {\n        self.percentile(50_f64)\n    }\n\n    fn var(&self) -> f64 {\n        if self.len() < 2 {\n            0.0\n        } else {\n            let mean = self.mean();\n            let mut v: f64 = 0.0;\n            for s in self {\n                let x = *s - mean;\n                v += x * x;\n            }\n            // N.B., this is _supposed to be_ len-1, not len. If you\n            // change it back to len, you will be calculating a\n            // population variance, not a sample variance.\n            let denom = (self.len() - 1) as f64;\n            v / denom\n        }\n    }\n\n    fn std_dev(&self) -> f64 {\n        self.var().sqrt()\n    }\n\n    fn std_dev_pct(&self) -> f64 {\n        let hundred = 100_f64;\n        (self.std_dev() / self.mean()) * hundred\n    }\n\n    fn median_abs_dev(&self) -> f64 {\n        let med = self.median();\n        let abs_devs: Vec<f64> = self.iter().map(|&v| (med - v).abs()).collect();\n        // This constant is derived by smarter statistics brains than me, but it is\n        // consistent with how R and other packages treat the MAD.\n        let number = 1.4826;\n        abs_devs.median() * number\n    }\n\n    fn median_abs_dev_pct(&self) -> f64 {\n        let hundred = 100_f64;\n        (self.median_abs_dev() / self.median()) * hundred\n    }\n\n    fn percentile(&self, pct: f64) -> f64 {\n        let mut tmp = self.to_vec();\n        local_sort(&mut tmp);\n        percentile_of_sorted(&tmp, pct)\n    }\n\n    fn quartiles(&self) -> (f64, f64, f64) {\n        let mut tmp = self.to_vec();\n        local_sort(&mut tmp);\n        let first = 25_f64;\n        let a = percentile_of_sorted(&tmp, first);\n        let second = 50_f64;\n        let b = percentile_of_sorted(&tmp, second);\n        let third = 75_f64;\n        let c = percentile_of_sorted(&tmp, third);\n        (a, b, c)\n    }\n\n    fn iqr(&self) -> f64 {\n        let (a, _, c) = self.quartiles();\n        c - a\n    }\n}\n\n// Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n// linear interpolation. If samples are not sorted, return nonsensical value.\nfn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n    assert!(!sorted_samples.is_empty());\n    if sorted_samples.len() == 1 {\n        return sorted_samples[0];\n    }\n    let zero: f64 = 0.0;\n    assert!(zero <= pct);\n    let hundred = 100_f64;\n    assert!(pct <= hundred);\n    if pct == hundred {\n        return sorted_samples[sorted_samples.len() - 1];\n    }\n    let length = (sorted_samples.len() - 1) as f64;\n    let rank = (pct / hundred) * length;\n    let lrank = rank.floor();\n    let d = rank - lrank;\n    let n = lrank as usize;\n    let lo = sorted_samples[n];\n    let hi = sorted_samples[n + 1];\n    lo + (hi - lo) * d\n}\n\n/// Winsorize a set of samples, replacing values above the `100-pct` percentile\n/// and below the `pct` percentile with those percentiles themselves. This is a\n/// way of minimizing the effect of outliers, at the cost of biasing the sample.\n/// It differs from trimming in that it does not change the number of samples,\n/// just changes the values of those that are outliers.\n///\n/// See: <https://en.wikipedia.org/wiki/Winsorising>\npub fn winsorize(samples: &mut [f64], pct: f64) {\n    let mut tmp = samples.to_vec();\n    local_sort(&mut tmp);\n    let lo = percentile_of_sorted(&tmp, pct);\n    let hundred = 100_f64;\n    let hi = percentile_of_sorted(&tmp, hundred - pct);\n    for samp in samples {\n        if *samp > hi {\n            *samp = hi\n        } else if *samp < lo {\n            *samp = lo\n        }\n    }\n}\n"],["2659","#![allow(nonstandard_style)]\n\nuse libc::{c_int, c_void, uintptr_t};\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum _Unwind_Reason_Code {\n    _URC_NO_REASON = 0,\n    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n    _URC_FATAL_PHASE2_ERROR = 2,\n    _URC_FATAL_PHASE1_ERROR = 3,\n    _URC_NORMAL_STOP = 4,\n    _URC_END_OF_STACK = 5,\n    _URC_HANDLER_FOUND = 6,\n    _URC_INSTALL_CONTEXT = 7,\n    _URC_CONTINUE_UNWIND = 8,\n    _URC_FAILURE = 9, // used only by ARM EHABI\n}\npub use _Unwind_Reason_Code::*;\n\npub type _Unwind_Exception_Class = u64;\npub type _Unwind_Word = uintptr_t;\npub type _Unwind_Ptr = uintptr_t;\npub type _Unwind_Trace_Fn =\n    extern \"C\" fn(ctx: *mut _Unwind_Context, arg: *mut c_void) -> _Unwind_Reason_Code;\n\n#[cfg(target_arch = \"x86\")]\npub const unwinder_private_data_size: usize = 5;\n\n#[cfg(target_arch = \"x86_64\")]\npub const unwinder_private_data_size: usize = 6;\n\n#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\npub const unwinder_private_data_size: usize = 20;\n\n#[cfg(all(target_arch = \"arm\", target_os = \"ios\"))]\npub const unwinder_private_data_size: usize = 5;\n\n#[cfg(all(target_arch = \"aarch64\", target_pointer_width = \"64\"))]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(all(target_arch = \"aarch64\", target_pointer_width = \"32\"))]\npub const unwinder_private_data_size: usize = 5;\n\n#[cfg(target_arch = \"mips\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_arch = \"mips64\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_arch = \"s390x\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(any(target_arch = \"sparc\", target_arch = \"sparc64\"))]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(any(target_arch = \"riscv64\", target_arch = \"riscv32\"))]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_os = \"emscripten\")]\npub const unwinder_private_data_size: usize = 20;\n\n#[cfg(all(target_arch = \"hexagon\", target_os = \"linux\"))]\npub const unwinder_private_data_size: usize = 35;\n\n#[repr(C)]\npub struct _Unwind_Exception {\n    pub exception_class: _Unwind_Exception_Class,\n    pub exception_cleanup: _Unwind_Exception_Cleanup_Fn,\n    pub private: [_Unwind_Word; unwinder_private_data_size],\n}\n\npub enum _Unwind_Context {}\n\npub type _Unwind_Exception_Cleanup_Fn =\n    extern \"C\" fn(unwind_code: _Unwind_Reason_Code, exception: *mut _Unwind_Exception);\n#[cfg_attr(\n    all(feature = \"llvm-libunwind\", any(target_os = \"fuchsia\", target_os = \"linux\")),\n    link(name = \"unwind\", kind = \"static\")\n)]\nextern \"C\" {\n    #[unwind(allowed)]\n    pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;\n    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);\n    pub fn _Unwind_GetLanguageSpecificData(ctx: *mut _Unwind_Context) -> *mut c_void;\n    pub fn _Unwind_GetRegionStart(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n    pub fn _Unwind_GetTextRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n    pub fn _Unwind_GetDataRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n}\n\ncfg_if::cfg_if! {\nif #[cfg(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\")))] {\n    // Not ARM EHABI\n    #[repr(C)]\n    #[derive(Copy, Clone, PartialEq)]\n    pub enum _Unwind_Action {\n        _UA_SEARCH_PHASE = 1,\n        _UA_CLEANUP_PHASE = 2,\n        _UA_HANDLER_FRAME = 4,\n        _UA_FORCE_UNWIND = 8,\n        _UA_END_OF_STACK = 16,\n    }\n    pub use _Unwind_Action::*;\n\n    #[cfg_attr(all(feature = \"llvm-libunwind\",\n                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n               link(name = \"unwind\", kind = \"static\"))]\n    extern \"C\" {\n        pub fn _Unwind_GetGR(ctx: *mut _Unwind_Context, reg_index: c_int) -> _Unwind_Word;\n        pub fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: c_int, value: _Unwind_Word);\n        pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> _Unwind_Word;\n        pub fn _Unwind_SetIP(ctx: *mut _Unwind_Context, value: _Unwind_Word);\n        pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context, ip_before_insn: *mut c_int)\n                                 -> _Unwind_Word;\n        pub fn _Unwind_FindEnclosingFunction(pc: *mut c_void) -> *mut c_void;\n    }\n\n} else {\n    // ARM EHABI\n    #[repr(C)]\n    #[derive(Copy, Clone, PartialEq)]\n    pub enum _Unwind_State {\n        _US_VIRTUAL_UNWIND_FRAME = 0,\n        _US_UNWIND_FRAME_STARTING = 1,\n        _US_UNWIND_FRAME_RESUME = 2,\n        _US_ACTION_MASK = 3,\n        _US_FORCE_UNWIND = 8,\n        _US_END_OF_STACK = 16,\n    }\n    pub use _Unwind_State::*;\n\n    #[repr(C)]\n    enum _Unwind_VRS_Result {\n        _UVRSR_OK = 0,\n        _UVRSR_NOT_IMPLEMENTED = 1,\n        _UVRSR_FAILED = 2,\n    }\n    #[repr(C)]\n    enum _Unwind_VRS_RegClass {\n        _UVRSC_CORE = 0,\n        _UVRSC_VFP = 1,\n        _UVRSC_FPA = 2,\n        _UVRSC_WMMXD = 3,\n        _UVRSC_WMMXC = 4,\n    }\n    use _Unwind_VRS_RegClass::*;\n    #[repr(C)]\n    enum _Unwind_VRS_DataRepresentation {\n        _UVRSD_UINT32 = 0,\n        _UVRSD_VFPX = 1,\n        _UVRSD_FPAX = 2,\n        _UVRSD_UINT64 = 3,\n        _UVRSD_FLOAT = 4,\n        _UVRSD_DOUBLE = 5,\n    }\n    use _Unwind_VRS_DataRepresentation::*;\n\n    pub const UNWIND_POINTER_REG: c_int = 12;\n    pub const UNWIND_SP_REG: c_int = 13;\n    pub const UNWIND_IP_REG: c_int = 15;\n\n    #[cfg_attr(all(feature = \"llvm-libunwind\",\n                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n               link(name = \"unwind\", kind = \"static\"))]\n    extern \"C\" {\n        fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n                           regclass: _Unwind_VRS_RegClass,\n                           regno: _Unwind_Word,\n                           repr: _Unwind_VRS_DataRepresentation,\n                           data: *mut c_void)\n                           -> _Unwind_VRS_Result;\n\n        fn _Unwind_VRS_Set(ctx: *mut _Unwind_Context,\n                           regclass: _Unwind_VRS_RegClass,\n                           regno: _Unwind_Word,\n                           repr: _Unwind_VRS_DataRepresentation,\n                           data: *mut c_void)\n                           -> _Unwind_VRS_Result;\n    }\n\n    // On Android or ARM/Linux, these are implemented as macros:\n\n    pub unsafe fn _Unwind_GetGR(ctx: *mut _Unwind_Context, reg_index: c_int) -> _Unwind_Word {\n        let mut val: _Unwind_Word = 0;\n        _Unwind_VRS_Get(ctx, _UVRSC_CORE, reg_index as _Unwind_Word, _UVRSD_UINT32,\n                        &mut val as *mut _ as *mut c_void);\n        val\n    }\n\n    pub unsafe fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: c_int, value: _Unwind_Word) {\n        let mut value = value;\n        _Unwind_VRS_Set(ctx, _UVRSC_CORE, reg_index as _Unwind_Word, _UVRSD_UINT32,\n                        &mut value as *mut _ as *mut c_void);\n    }\n\n    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context)\n                                -> _Unwind_Word {\n        let val = _Unwind_GetGR(ctx, UNWIND_IP_REG);\n        (val & !1) as _Unwind_Word\n    }\n\n    pub unsafe fn _Unwind_SetIP(ctx: *mut _Unwind_Context,\n                                value: _Unwind_Word) {\n        // Propagate thumb bit to instruction pointer\n        let thumb_state = _Unwind_GetGR(ctx, UNWIND_IP_REG) & 1;\n        let value = value | thumb_state;\n        _Unwind_SetGR(ctx, UNWIND_IP_REG, value);\n    }\n\n    pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n                                    ip_before_insn: *mut c_int)\n                                    -> _Unwind_Word {\n        *ip_before_insn = 0;\n        _Unwind_GetIP(ctx)\n    }\n\n    // This function also doesn't exist on Android or ARM/Linux, so make it a no-op\n    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut c_void) -> *mut c_void {\n        pc\n    }\n}\n} // cfg_if!\n\ncfg_if::cfg_if! {\nif #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n    // Not 32-bit iOS\n    #[cfg_attr(all(feature = \"llvm-libunwind\",\n                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n               link(name = \"unwind\", kind = \"static\"))]\n    extern \"C\" {\n        #[unwind(allowed)]\n        pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n                                 trace_argument: *mut c_void)\n                                 -> _Unwind_Reason_Code;\n    }\n} else {\n    // 32-bit iOS uses SjLj and does not provide _Unwind_Backtrace()\n    #[cfg_attr(all(feature = \"llvm-libunwind\",\n                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n               link(name = \"unwind\", kind = \"static\"))]\n    extern \"C\" {\n        #[unwind(allowed)]\n        pub fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n    }\n\n    #[inline]\n    pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception) -> _Unwind_Reason_Code {\n        _Unwind_SjLj_RaiseException(exc)\n    }\n}\n} // cfg_if!\n\ncfg_if::cfg_if! {\nif #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n    // We declare these as opaque types. This is fine since you just need to\n    // pass them to _GCC_specific_handler and forget about them.\n    pub enum EXCEPTION_RECORD {}\n    pub type LPVOID = *mut c_void;\n    pub enum CONTEXT {}\n    pub enum DISPATCHER_CONTEXT {}\n    pub type EXCEPTION_DISPOSITION = c_int;\n    type PersonalityFn = unsafe extern \"C\" fn(version: c_int,\n                                              actions: _Unwind_Action,\n                                              exception_class: _Unwind_Exception_Class,\n                                              exception_object: *mut _Unwind_Exception,\n                                              context: *mut _Unwind_Context)\n                                              -> _Unwind_Reason_Code;\n\n    extern \"C\" {\n        pub fn _GCC_specific_handler(exceptionRecord: *mut EXCEPTION_RECORD,\n                                establisherFrame: LPVOID,\n                                contextRecord: *mut CONTEXT,\n                                dispatcherContext: *mut DISPATCHER_CONTEXT,\n                                personality: PersonalityFn)\n                                -> EXCEPTION_DISPOSITION;\n    }\n}\n} // cfg_if!\n"]]}