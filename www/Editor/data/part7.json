{"files_changed":[["2408","pub type Key = usize;\n\n#[inline]\npub unsafe fn create(_dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n    panic!(\"should not be used on this target\");\n}\n\n#[inline]\npub unsafe fn set(_key: Key, _value: *mut u8) {\n    panic!(\"should not be used on this target\");\n}\n\n#[inline]\npub unsafe fn get(_key: Key) -> *mut u8 {\n    panic!(\"should not be used on this target\");\n}\n\n#[inline]\npub unsafe fn destroy(_key: Key) {\n    panic!(\"should not be used on this target\");\n}\n\n#[inline]\npub fn requires_synchronized_create() -> bool {\n    panic!(\"should not be used on this target\");\n}\n"],["2409","use super::unsupported;\nuse crate::ffi::CStr;\nuse crate::io;\nuse crate::time::Duration;\n\npub struct Thread(!);\n\npub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n\nimpl Thread {\n    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        unsupported()\n    }\n\n    pub fn yield_now() {\n        // do nothing\n    }\n\n    pub fn set_name(_name: &CStr) {\n        // nope\n    }\n\n    pub fn sleep(_dur: Duration) {\n        panic!(\"can't sleep\");\n    }\n\n    pub fn join(self) {\n        self.0\n    }\n}\n\npub mod guard {\n    pub type Guard = !;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n"],["2410","use crate::io::{self, IoSlice, IoSliceMut};\n\npub struct AnonPipe(!);\n\nimpl AnonPipe {\n    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn is_read_vectored(&self) -> bool {\n        self.0\n    }\n\n    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn is_write_vectored(&self) -> bool {\n        self.0\n    }\n\n    pub fn diverge(&self) -> ! {\n        self.0\n    }\n}\n\npub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n    match p1.0 {}\n}\n"],["2411","use crate::io;\n\npub struct Stdin;\npub struct Stdout;\npub struct Stderr;\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n        Ok(0)\n    }\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\npub const STDIN_BUF_SIZE: usize = 0;\n\npub fn is_ebadf(_err: &io::Error) -> bool {\n    true\n}\n\npub fn panic_output() -> Option<Vec<u8>> {\n    None\n}\n"],["2412","use crate::alloc::{GlobalAlloc, Layout, System};\n\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, _layout: Layout) -> *mut u8 {\n        0 as *mut u8\n    }\n\n    #[inline]\n    unsafe fn alloc_zeroed(&self, _layout: Layout) -> *mut u8 {\n        0 as *mut u8\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n\n    #[inline]\n    unsafe fn realloc(&self, _ptr: *mut u8, _layout: Layout, _new_size: usize) -> *mut u8 {\n        0 as *mut u8\n    }\n}\n"],["2413","use crate::mem;\n\n#[derive(Copy, Clone)]\npub struct IoSlice<'a>(&'a [u8]);\n\nimpl<'a> IoSlice<'a> {\n    #[inline]\n    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n        IoSlice(buf)\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        self.0 = &self.0[n..]\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        self.0\n    }\n}\n\npub struct IoSliceMut<'a>(&'a mut [u8]);\n\nimpl<'a> IoSliceMut<'a> {\n    #[inline]\n    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n        IoSliceMut(buf)\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        let slice = mem::replace(&mut self.0, &mut []);\n        let (_, remaining) = slice.split_at_mut(n);\n        self.0 = remaining;\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        self.0\n    }\n\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n        self.0\n    }\n}\n"],["2414","use crate::sys::mutex::Mutex;\nuse crate::time::Duration;\n\npub struct Condvar {}\n\npub type MovableCondvar = Condvar;\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        Condvar {}\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {}\n\n    #[inline]\n    pub unsafe fn notify_one(&self) {}\n\n    #[inline]\n    pub unsafe fn notify_all(&self) {}\n\n    pub unsafe fn wait(&self, _mutex: &Mutex) {\n        panic!(\"condvar wait not supported\")\n    }\n\n    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n        panic!(\"condvar wait not supported\");\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n"],["2415","use crate::ffi::OsStr;\nuse crate::fmt;\nuse crate::io;\nuse crate::marker::PhantomData;\nuse crate::num::NonZeroI32;\nuse crate::path::Path;\nuse crate::sys::fs::File;\nuse crate::sys::pipe::AnonPipe;\nuse crate::sys::unsupported;\nuse crate::sys_common::process::{CommandEnv, CommandEnvs};\n\npub use crate::ffi::OsString as EnvKey;\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\npub struct Command {\n    env: CommandEnv,\n}\n\n// passed back to std::process with the pipes connected to the child, if any\n// were requested\npub struct StdioPipes {\n    pub stdin: Option<AnonPipe>,\n    pub stdout: Option<AnonPipe>,\n    pub stderr: Option<AnonPipe>,\n}\n\npub enum Stdio {\n    Inherit,\n    Null,\n    MakePipe,\n}\n\nimpl Command {\n    pub fn new(_program: &OsStr) -> Command {\n        Command { env: Default::default() }\n    }\n\n    pub fn arg(&mut self, _arg: &OsStr) {}\n\n    pub fn env_mut(&mut self) -> &mut CommandEnv {\n        &mut self.env\n    }\n\n    pub fn cwd(&mut self, _dir: &OsStr) {}\n\n    pub fn stdin(&mut self, _stdin: Stdio) {}\n\n    pub fn stdout(&mut self, _stdout: Stdio) {}\n\n    pub fn stderr(&mut self, _stderr: Stdio) {}\n\n    pub fn get_program(&self) -> &OsStr {\n        panic!(\"unsupported\")\n    }\n\n    pub fn get_args(&self) -> CommandArgs<'_> {\n        CommandArgs { _p: PhantomData }\n    }\n\n    pub fn get_envs(&self) -> CommandEnvs<'_> {\n        self.env.iter()\n    }\n\n    pub fn get_current_dir(&self) -> Option<&Path> {\n        None\n    }\n\n    pub fn spawn(\n        &mut self,\n        _default: Stdio,\n        _needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        unsupported()\n    }\n}\n\nimpl From<AnonPipe> for Stdio {\n    fn from(pipe: AnonPipe) -> Stdio {\n        pipe.diverge()\n    }\n}\n\nimpl From<File> for Stdio {\n    fn from(_file: File) -> Stdio {\n        panic!(\"unsupported\")\n    }\n}\n\nimpl fmt::Debug for Command {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        Ok(())\n    }\n}\n\npub struct ExitStatus(!);\n\nimpl ExitStatus {\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        self.0\n    }\n\n    pub fn code(&self) -> Option<i32> {\n        self.0\n    }\n}\n\nimpl Clone for ExitStatus {\n    fn clone(&self) -> ExitStatus {\n        self.0\n    }\n}\n\nimpl Copy for ExitStatus {}\n\nimpl PartialEq for ExitStatus {\n    fn eq(&self, _other: &ExitStatus) -> bool {\n        self.0\n    }\n}\n\nimpl Eq for ExitStatus {}\n\nimpl fmt::Debug for ExitStatus {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatusError(ExitStatus);\n\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        self.0.0\n    }\n}\n\nimpl ExitStatusError {\n    pub fn code(self) -> Option<NonZeroI32> {\n        self.0.0\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitCode(bool);\n\nimpl ExitCode {\n    pub const SUCCESS: ExitCode = ExitCode(false);\n    pub const FAILURE: ExitCode = ExitCode(true);\n\n    pub fn as_i32(&self) -> i32 {\n        self.0 as i32\n    }\n}\n\npub struct Process(!);\n\nimpl Process {\n    pub fn id(&self) -> u32 {\n        self.0\n    }\n\n    pub fn kill(&mut self) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        self.0\n    }\n\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        self.0\n    }\n}\n\npub struct CommandArgs<'a> {\n    _p: PhantomData<&'a ()>,\n}\n\nimpl<'a> Iterator for CommandArgs<'a> {\n    type Item = &'a OsStr;\n    fn next(&mut self) -> Option<&'a OsStr> {\n        None\n    }\n}\n\nimpl<'a> ExactSizeIterator for CommandArgs<'a> {}\n\nimpl<'a> fmt::Debug for CommandArgs<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().finish()\n    }\n}\n"],["2416","use crate::alloc::{GlobalAlloc, Layout, System};\nuse crate::cmp;\nuse crate::ptr;\n\n// The minimum alignment guaranteed by the architecture. This value is used to\n// add fast paths for low alignment values.\n#[cfg(all(any(\n    target_arch = \"x86\",\n    target_arch = \"arm\",\n    target_arch = \"mips\",\n    target_arch = \"powerpc\",\n    target_arch = \"powerpc64\",\n    target_arch = \"sparc\",\n    target_arch = \"asmjs\",\n    target_arch = \"wasm32\",\n    target_arch = \"hexagon\",\n    target_arch = \"riscv32\"\n)))]\npub const MIN_ALIGN: usize = 8;\n#[cfg(all(any(\n    target_arch = \"x86_64\",\n    target_arch = \"aarch64\",\n    target_arch = \"mips64\",\n    target_arch = \"s390x\",\n    target_arch = \"sparc64\",\n    target_arch = \"riscv64\"\n)))]\npub const MIN_ALIGN: usize = 16;\n\npub unsafe fn realloc_fallback(\n    alloc: &System,\n    ptr: *mut u8,\n    old_layout: Layout,\n    new_size: usize,\n) -> *mut u8 {\n    // Docs for GlobalAlloc::realloc require this to be valid:\n    let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n\n    let new_ptr = GlobalAlloc::alloc(alloc, new_layout);\n    if !new_ptr.is_null() {\n        let size = cmp::min(old_layout.size(), new_size);\n        ptr::copy_nonoverlapping(ptr, new_ptr, size);\n        GlobalAlloc::dealloc(alloc, ptr, old_layout);\n    }\n    new_ptr\n}\n"],["2417","// This module contains code that is shared between all platforms, mostly utility or fallback code.\n// This explicitly does not include code that is shared between only a few platforms,\n// such as when reusing an implementation from `unix` or `unsupported`.\n// In those cases the desired code should be included directly using the #[path] attribute,\n// not moved to this module.\n//\n// Currently `sys_common` contains a lot of code that should live in this module,\n// ideally `sys_common` would only contain platform-independent abstractions on top of `sys`.\n// Progress on this is tracked in #84187.\n\n#![allow(dead_code)]\n\npub mod alloc;\n"],["2418","use crate::arch::wasm32;\nuse crate::convert::TryInto;\nuse crate::sync::atomic::AtomicI32;\nuse crate::time::Duration;\n\npub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n    let timeout = timeout.and_then(|t| t.as_nanos().try_into().ok()).unwrap_or(-1);\n    unsafe {\n        wasm32::memory_atomic_wait32(futex as *const AtomicI32 as *mut i32, expected, timeout);\n    }\n}\n\npub fn futex_wake(futex: &AtomicI32) {\n    unsafe {\n        wasm32::memory_atomic_notify(futex as *const AtomicI32 as *mut i32, 1);\n    }\n}\n"],["2419","use crate::arch::wasm32;\nuse crate::cell::UnsafeCell;\nuse crate::mem;\nuse crate::sync::atomic::{AtomicU32, AtomicUsize, Ordering::SeqCst};\nuse crate::sys::thread;\n\npub struct Mutex {\n    locked: AtomicUsize,\n}\n\npub type MovableMutex = Mutex;\n\n// Mutexes have a pretty simple implementation where they contain an `i32`\n// internally that is 0 when unlocked and 1 when the mutex is locked.\n// Acquisition has a fast path where it attempts to cmpxchg the 0 to a 1, and\n// if it fails it then waits for a notification. Releasing a lock is then done\n// by swapping in 0 and then notifying any waiters, if present.\n\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        Mutex { locked: AtomicUsize::new(0) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {\n        // nothing to do\n    }\n\n    pub unsafe fn lock(&self) {\n        while !self.try_lock() {\n            // SAFETY: the caller must uphold the safety contract for `memory_atomic_wait32`.\n            let val = unsafe {\n                wasm32::memory_atomic_wait32(\n                    self.ptr(),\n                    1,  // we expect our mutex is locked\n                    -1, // wait infinitely\n                )\n            };\n            // we should have either woke up (0) or got a not-equal due to a\n            // race (1). We should never time out (2)\n            debug_assert!(val == 0 || val == 1);\n        }\n    }\n\n    pub unsafe fn unlock(&self) {\n        let prev = self.locked.swap(0, SeqCst);\n        debug_assert_eq!(prev, 1);\n        wasm32::memory_atomic_notify(self.ptr(), 1); // wake up one waiter, if any\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        self.locked.compare_exchange(0, 1, SeqCst, SeqCst).is_ok()\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        // nothing to do\n    }\n\n    #[inline]\n    fn ptr(&self) -> *mut i32 {\n        assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n        self.locked.as_mut_ptr() as *mut i32\n    }\n}\n\npub struct ReentrantMutex {\n    owner: AtomicU32,\n    recursions: UnsafeCell<u32>,\n}\n\nunsafe impl Send for ReentrantMutex {}\nunsafe impl Sync for ReentrantMutex {}\n\n// Reentrant mutexes are similarly implemented to mutexs above except that\n// instead of \"1\" meaning unlocked we use the id of a thread to represent\n// whether it has locked a mutex. That way we have an atomic counter which\n// always holds the id of the thread that currently holds the lock (or 0 if the\n// lock is unlocked).\n//\n// Once a thread acquires a lock recursively, which it detects by looking at\n// the value that's already there, it will update a local `recursions` counter\n// in a nonatomic fashion (as we hold the lock). The lock is then fully\n// released when this recursion counter reaches 0.\n\nimpl ReentrantMutex {\n    pub const unsafe fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex { owner: AtomicU32::new(0), recursions: UnsafeCell::new(0) }\n    }\n\n    pub unsafe fn init(&self) {\n        // nothing to do...\n    }\n\n    pub unsafe fn lock(&self) {\n        let me = thread::my_id();\n        while let Err(owner) = self._try_lock(me) {\n            // SAFETY: the caller must gurantee that `self.ptr()` and `owner` are valid i32.\n            let val = unsafe { wasm32::memory_atomic_wait32(self.ptr(), owner as i32, -1) };\n            debug_assert!(val == 0 || val == 1);\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        unsafe { self._try_lock(thread::my_id()).is_ok() }\n    }\n\n    #[inline]\n    unsafe fn _try_lock(&self, id: u32) -> Result<(), u32> {\n        let id = id.checked_add(1).unwrap();\n        match self.owner.compare_exchange(0, id, SeqCst, SeqCst) {\n            // we transitioned from unlocked to locked\n            Ok(_) => {\n                debug_assert_eq!(*self.recursions.get(), 0);\n                Ok(())\n            }\n\n            // we currently own this lock, so let's update our count and return\n            // true.\n            Err(n) if n == id => {\n                *self.recursions.get() += 1;\n                Ok(())\n            }\n\n            // Someone else owns the lock, let our caller take care of it\n            Err(other) => Err(other),\n        }\n    }\n\n    pub unsafe fn unlock(&self) {\n        // If we didn't ever recursively lock the lock then we fully unlock the\n        // mutex and wake up a waiter, if any. Otherwise we decrement our\n        // recursive counter and let some one else take care of the zero.\n        match *self.recursions.get() {\n            0 => {\n                self.owner.swap(0, SeqCst);\n                // SAFETY: the caller must gurantee that `self.ptr()` is valid i32.\n                unsafe {\n                    wasm32::memory_atomic_notify(self.ptr() as *mut i32, 1);\n                } // wake up one waiter, if any\n            }\n            ref mut n => *n -= 1,\n        }\n    }\n\n    pub unsafe fn destroy(&self) {\n        // nothing to do...\n    }\n\n    #[inline]\n    fn ptr(&self) -> *mut i32 {\n        self.owner.as_mut_ptr() as *mut i32\n    }\n}\n"],["2420","use crate::arch::wasm32;\nuse crate::cmp;\nuse crate::mem;\nuse crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nuse crate::sys::mutex::Mutex;\nuse crate::time::Duration;\n\npub struct Condvar {\n    cnt: AtomicUsize,\n}\n\npub type MovableCondvar = Condvar;\n\n// Condition variables are implemented with a simple counter internally that is\n// likely to cause spurious wakeups. Blocking on a condition variable will first\n// read the value of the internal counter, unlock the given mutex, and then\n// block if and only if the counter's value is still the same. Notifying a\n// condition variable will modify the counter (add one for now) and then wake up\n// a thread waiting on the address of the counter.\n//\n// A thread waiting on the condition variable will as a result avoid going to\n// sleep if it's notified after the lock is unlocked but before it fully goes to\n// sleep. A sleeping thread is guaranteed to be woken up at some point as it can\n// only be woken up with a call to `wake`.\n//\n// Note that it's possible for 2 or more threads to be woken up by a call to\n// `notify_one` with this implementation. That can happen where the modification\n// of `cnt` causes any threads in the middle of `wait` to avoid going to sleep,\n// and the subsequent `wake` may wake up a thread that's actually blocking. We\n// consider this a spurious wakeup, though, which all users of condition\n// variables must already be prepared to handle. As a result, this source of\n// spurious wakeups is currently though to be ok, although it may be problematic\n// later on if it causes too many spurious wakeups.\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        Condvar { cnt: AtomicUsize::new(0) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {\n        // nothing to do\n    }\n\n    pub unsafe fn notify_one(&self) {\n        self.cnt.fetch_add(1, SeqCst);\n        // SAFETY: ptr() is always valid\n        unsafe {\n            wasm32::memory_atomic_notify(self.ptr(), 1);\n        }\n    }\n\n    #[inline]\n    pub unsafe fn notify_all(&self) {\n        self.cnt.fetch_add(1, SeqCst);\n        // SAFETY: ptr() is always valid\n        unsafe {\n            wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n        }\n    }\n\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n        // \"atomically block and unlock\" implemented by loading our current\n        // counter's value, unlocking the mutex, and blocking if the counter\n        // still has the same value.\n        //\n        // Notifications happen by incrementing the counter and then waking a\n        // thread. Incrementing the counter after we unlock the mutex will\n        // prevent us from sleeping and otherwise the call to `wake` will\n        // wake us up once we're asleep.\n        let ticket = self.cnt.load(SeqCst) as i32;\n        mutex.unlock();\n        let val = wasm32::memory_atomic_wait32(self.ptr(), ticket, -1);\n        // 0 == woken, 1 == not equal to `ticket`, 2 == timeout (shouldn't happen)\n        debug_assert!(val == 0 || val == 1);\n        mutex.lock();\n    }\n\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n        let ticket = self.cnt.load(SeqCst) as i32;\n        mutex.unlock();\n        let nanos = dur.as_nanos();\n        let nanos = cmp::min(i64::MAX as u128, nanos);\n\n        // If the return value is 2 then a timeout happened, so we return\n        // `false` as we weren't actually notified.\n        let ret = wasm32::memory_atomic_wait32(self.ptr(), ticket, nanos as i64) != 2;\n        mutex.lock();\n        return ret;\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        // nothing to do\n    }\n\n    #[inline]\n    fn ptr(&self) -> *mut i32 {\n        assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n        self.cnt.as_mut_ptr() as *mut i32\n    }\n}\n"],["2421","use crate::cell::UnsafeCell;\nuse crate::sys::condvar::Condvar;\nuse crate::sys::mutex::Mutex;\n\npub struct RWLock {\n    lock: Mutex,\n    cond: Condvar,\n    state: UnsafeCell<State>,\n}\n\npub type MovableRWLock = RWLock;\n\nenum State {\n    Unlocked,\n    Reading(usize),\n    Writing,\n}\n\nunsafe impl Send for RWLock {}\nunsafe impl Sync for RWLock {}\n\n// This rwlock implementation is a relatively simple implementation which has a\n// condition variable for readers/writers as well as a mutex protecting the\n// internal state of the lock. A current downside of the implementation is that\n// unlocking the lock will notify *all* waiters rather than just readers or just\n// writers. This can cause lots of \"thundering stampede\" problems. While\n// hopefully correct this implementation is very likely to want to be changed in\n// the future.\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock { lock: Mutex::new(), cond: Condvar::new(), state: UnsafeCell::new(State::Unlocked) }\n    }\n\n    #[inline]\n    pub unsafe fn read(&self) {\n        self.lock.lock();\n        while !(*self.state.get()).inc_readers() {\n            self.cond.wait(&self.lock);\n        }\n        self.lock.unlock();\n    }\n\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        self.lock.lock();\n        let ok = (*self.state.get()).inc_readers();\n        self.lock.unlock();\n        return ok;\n    }\n\n    #[inline]\n    pub unsafe fn write(&self) {\n        self.lock.lock();\n        while !(*self.state.get()).inc_writers() {\n            self.cond.wait(&self.lock);\n        }\n        self.lock.unlock();\n    }\n\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        self.lock.lock();\n        let ok = (*self.state.get()).inc_writers();\n        self.lock.unlock();\n        return ok;\n    }\n\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        self.lock.lock();\n        let notify = (*self.state.get()).dec_readers();\n        self.lock.unlock();\n        if notify {\n            // FIXME: should only wake up one of these some of the time\n            self.cond.notify_all();\n        }\n    }\n\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        self.lock.lock();\n        (*self.state.get()).dec_writers();\n        self.lock.unlock();\n        // FIXME: should only wake up one of these some of the time\n        self.cond.notify_all();\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        self.lock.destroy();\n        self.cond.destroy();\n    }\n}\n\nimpl State {\n    fn inc_readers(&mut self) -> bool {\n        match *self {\n            State::Unlocked => {\n                *self = State::Reading(1);\n                true\n            }\n            State::Reading(ref mut cnt) => {\n                *cnt += 1;\n                true\n            }\n            State::Writing => false,\n        }\n    }\n\n    fn inc_writers(&mut self) -> bool {\n        match *self {\n            State::Unlocked => {\n                *self = State::Writing;\n                true\n            }\n            State::Reading(_) | State::Writing => false,\n        }\n    }\n\n    fn dec_readers(&mut self) -> bool {\n        let zero = match *self {\n            State::Reading(ref mut cnt) => {\n                *cnt -= 1;\n                *cnt == 0\n            }\n            State::Unlocked | State::Writing => invalid(),\n        };\n        if zero {\n            *self = State::Unlocked;\n        }\n        zero\n    }\n\n    fn dec_writers(&mut self) {\n        match *self {\n            State::Writing => {}\n            State::Unlocked | State::Reading(_) => invalid(),\n        }\n        *self = State::Unlocked;\n    }\n}\n\nfn invalid() -> ! {\n    panic!(\"inconsistent rwlock\");\n}\n"],["2422","use crate::ffi::CStr;\nuse crate::io;\nuse crate::sys::unsupported;\nuse crate::time::Duration;\n\npub struct Thread(!);\n\npub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n\nimpl Thread {\n    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        unsupported()\n    }\n\n    pub fn yield_now() {}\n\n    pub fn set_name(_name: &CStr) {}\n\n    pub fn sleep(dur: Duration) {\n        use crate::arch::wasm32;\n        use crate::cmp;\n\n        // Use an atomic wait to block the current thread artificially with a\n        // timeout listed. Note that we should never be notified (return value\n        // of 0) or our comparison should never fail (return value of 1) so we\n        // should always only resume execution through a timeout (return value\n        // 2).\n        let mut nanos = dur.as_nanos();\n        while nanos > 0 {\n            let amt = cmp::min(i64::MAX as u128, nanos);\n            let mut x = 0;\n            let val = unsafe { wasm32::memory_atomic_wait32(&mut x, 0, amt as i64) };\n            debug_assert_eq!(val, 2);\n            nanos -= amt;\n        }\n    }\n\n    pub fn join(self) {}\n}\n\npub mod guard {\n    pub type Guard = !;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n\n// We currently just use our own thread-local to store our\n// current thread's ID, and then we lazily initialize it to something allocated\n// from a global counter.\npub fn my_id() -> u32 {\n    use crate::sync::atomic::{AtomicU32, Ordering::SeqCst};\n\n    static NEXT_ID: AtomicU32 = AtomicU32::new(0);\n\n    #[thread_local]\n    static mut MY_ID: u32 = 0;\n\n    unsafe {\n        // If our thread ID isn't set yet then we need to allocate one. Do so\n        // with with a simple \"atomically add to a global counter\" strategy.\n        // This strategy doesn't handled what happens when the counter\n        // overflows, however, so just abort everything once the counter\n        // overflows and eventually we could have some sort of recycling scheme\n        // (or maybe this is all totally irrelevant by that point!). In any case\n        // though we're using a CAS loop instead of a `fetch_add` to ensure that\n        // the global counter never overflows.\n        if MY_ID == 0 {\n            let mut cur = NEXT_ID.load(SeqCst);\n            MY_ID = loop {\n                let next = cur.checked_add(1).unwrap_or_else(|| crate::process::abort());\n                match NEXT_ID.compare_exchange(cur, next, SeqCst, SeqCst) {\n                    Ok(_) => break next,\n                    Err(i) => cur = i,\n                }\n            };\n        }\n        MY_ID\n    }\n}\n"],["2423","pub mod os {\n    pub const FAMILY: &str = \"\";\n    pub const OS: &str = \"\";\n    pub const DLL_PREFIX: &str = \"\";\n    pub const DLL_SUFFIX: &str = \".wasm\";\n    pub const DLL_EXTENSION: &str = \"wasm\";\n    pub const EXE_SUFFIX: &str = \".wasm\";\n    pub const EXE_EXTENSION: &str = \"wasm\";\n}\n"],["2424","//! System bindings for the wasm/web platform\n//!\n//! This module contains the facade (aka platform-specific) implementations of\n//! OS level functionality for wasm. Note that this wasm is *not* the emscripten\n//! wasm, so we have no runtime here.\n//!\n//! This is all super highly experimental and not actually intended for\n//! wide/production use yet, it's still all in the experimental category. This\n//! will likely change over time.\n//!\n//! Currently all functions here are basically stubs that immediately return\n//! errors. The hope is that with a portability lint we can turn actually just\n//! remove all this and just omit parts of the standard library if we're\n//! compiling for wasm. That way it's a compile time error for something that's\n//! guaranteed to be a runtime error!\n\n#![deny(unsafe_op_in_unsafe_fn)]\n\npub mod alloc;\n#[path = \"../unsupported/args.rs\"]\npub mod args;\n#[path = \"../unix/cmath.rs\"]\npub mod cmath;\npub mod env;\n#[path = \"../unsupported/fs.rs\"]\npub mod fs;\n#[path = \"../unsupported/io.rs\"]\npub mod io;\n#[path = \"../unsupported/net.rs\"]\npub mod net;\n#[path = \"../unsupported/os.rs\"]\npub mod os;\n#[path = \"../unix/path.rs\"]\npub mod path;\n#[path = \"../unsupported/pipe.rs\"]\npub mod pipe;\n#[path = \"../unsupported/process.rs\"]\npub mod process;\n#[path = \"../unsupported/stdio.rs\"]\npub mod stdio;\n#[path = \"../unsupported/thread_local_dtor.rs\"]\npub mod thread_local_dtor;\n#[path = \"../unsupported/thread_local_key.rs\"]\npub mod thread_local_key;\n#[path = \"../unsupported/time.rs\"]\npub mod time;\n\npub use crate::sys_common::os_str_bytes as os_str;\n\ncfg_if::cfg_if! {\n    if #[cfg(target_feature = \"atomics\")] {\n        #[path = \"atomics/condvar.rs\"]\n        pub mod condvar;\n        #[path = \"atomics/mutex.rs\"]\n        pub mod mutex;\n        #[path = \"atomics/rwlock.rs\"]\n        pub mod rwlock;\n        #[path = \"atomics/futex.rs\"]\n        pub mod futex;\n        #[path = \"atomics/thread.rs\"]\n        pub mod thread;\n    } else {\n        #[path = \"../unsupported/condvar.rs\"]\n        pub mod condvar;\n        #[path = \"../unsupported/mutex.rs\"]\n        pub mod mutex;\n        #[path = \"../unsupported/rwlock.rs\"]\n        pub mod rwlock;\n        #[path = \"../unsupported/thread.rs\"]\n        pub mod thread;\n    }\n}\n\n#[path = \"../unsupported/common.rs\"]\n#[deny(unsafe_op_in_unsafe_fn)]\nmod common;\npub use common::*;\n"],["2425","//! This is an implementation of a global allocator on the wasm32 platform when\n//! emscripten is not in use. In that situation there's no actual runtime for us\n//! to lean on for allocation, so instead we provide our own!\n//!\n//! The wasm32 instruction set has two instructions for getting the current\n//! amount of memory and growing the amount of memory. These instructions are the\n//! foundation on which we're able to build an allocator, so we do so! Note that\n//! the instructions are also pretty \"global\" and this is the \"global\" allocator\n//! after all!\n//!\n//! The current allocator here is the `dlmalloc` crate which we've got included\n//! in the rust-lang/rust repository as a submodule. The crate is a port of\n//! dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n//! for now which is currently technically required (can't link with C yet).\n//!\n//! The crate itself provides a global allocator which on wasm has no\n//! synchronization as there are no threads!\n\nuse crate::alloc::{GlobalAlloc, Layout, System};\n\nstatic mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::Dlmalloc::new();\n\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n        // Calling malloc() is safe because preconditions on this function match the trait method preconditions.\n        let _lock = lock::lock();\n        unsafe { DLMALLOC.malloc(layout.size(), layout.align()) }\n    }\n\n    #[inline]\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n        // Calling calloc() is safe because preconditions on this function match the trait method preconditions.\n        let _lock = lock::lock();\n        unsafe { DLMALLOC.calloc(layout.size(), layout.align()) }\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n        // Calling free() is safe because preconditions on this function match the trait method preconditions.\n        let _lock = lock::lock();\n        unsafe { DLMALLOC.free(ptr, layout.size(), layout.align()) }\n    }\n\n    #[inline]\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        // SAFETY: DLMALLOC access is guranteed to be safe because the lock gives us unique and non-reentrant access.\n        // Calling realloc() is safe because preconditions on this function match the trait method preconditions.\n        let _lock = lock::lock();\n        unsafe { DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size) }\n    }\n}\n\n#[cfg(target_feature = \"atomics\")]\nmod lock {\n    use crate::sync::atomic::{AtomicI32, Ordering::SeqCst};\n\n    static LOCKED: AtomicI32 = AtomicI32::new(0);\n\n    pub struct DropLock;\n\n    pub fn lock() -> DropLock {\n        loop {\n            if LOCKED.swap(1, SeqCst) == 0 {\n                return DropLock;\n            }\n            // Ok so here's where things get a little depressing. At this point\n            // in time we need to synchronously acquire a lock, but we're\n            // contending with some other thread. Typically we'd execute some\n            // form of `i32.atomic.wait` like so:\n            //\n            //     unsafe {\n            //         let r = core::arch::wasm32::i32_atomic_wait(\n            //             LOCKED.as_mut_ptr(),\n            //             1,  //     expected value\n            //             -1, //     timeout\n            //         );\n            //         debug_assert!(r == 0 || r == 1);\n            //     }\n            //\n            // Unfortunately though in doing so we would cause issues for the\n            // main thread. The main thread in a web browser *cannot ever\n            // block*, no exceptions. This means that the main thread can't\n            // actually execute the `i32.atomic.wait` instruction.\n            //\n            // As a result if we want to work within the context of browsers we\n            // need to figure out some sort of allocation scheme for the main\n            // thread where when there's contention on the global malloc lock we\n            // do... something.\n            //\n            // Possible ideas include:\n            //\n            // 1. Attempt to acquire the global lock. If it fails, fall back to\n            //    memory allocation via `memory.grow`. Later just ... somehow\n            //    ... inject this raw page back into the main allocator as it\n            //    gets sliced up over time. This strategy has the downside of\n            //    forcing allocation of a page to happen whenever the main\n            //    thread contents with other threads, which is unfortunate.\n            //\n            // 2. Maintain a form of \"two level\" allocator scheme where the main\n            //    thread has its own allocator. Somehow this allocator would\n            //    also be balanced with a global allocator, not only to have\n            //    allocations cross between threads but also to ensure that the\n            //    two allocators stay \"balanced\" in terms of free'd memory and\n            //    such. This, however, seems significantly complicated.\n            //\n            // Out of a lack of other ideas, the current strategy implemented\n            // here is to simply spin. Typical spin loop algorithms have some\n            // form of \"hint\" here to the CPU that it's what we're doing to\n            // ensure that the CPU doesn't get too hot, but wasm doesn't have\n            // such an instruction.\n            //\n            // To be clear, spinning here is not a great solution.\n            // Another thread with the lock may take quite a long time to wake\n            // up. For example it could be in `memory.grow` or it could be\n            // evicted from the CPU for a timeslice like 10ms. For these periods\n            // of time our thread will \"helpfully\" sit here and eat CPU time\n            // until it itself is evicted or the lock holder finishes. This\n            // means we're just burning and wasting CPU time to no one's\n            // benefit.\n            //\n            // Spinning does have the nice properties, though, of being\n            // semantically correct, being fair to all threads for memory\n            // allocation, and being simple enough to implement.\n            //\n            // This will surely (hopefully) be replaced in the future with a\n            // real memory allocator that can handle the restriction of the main\n            // thread.\n            //\n            //\n            // FIXME: We can also possibly add an optimization here to detect\n            // when a thread is the main thread or not and block on all\n            // non-main-thread threads. Currently, however, we have no way\n            // of knowing which wasm thread is on the browser main thread, but\n            // if we could figure out we could at least somewhat mitigate the\n            // cost of this spinning.\n        }\n    }\n\n    impl Drop for DropLock {\n        fn drop(&mut self) {\n            let r = LOCKED.swap(0, SeqCst);\n            debug_assert_eq!(r, 1);\n\n            // Note that due to the above logic we don't actually need to wake\n            // anyone up, but if we did it'd likely look something like this:\n            //\n            //     unsafe {\n            //         core::arch::wasm32::atomic_notify(\n            //             LOCKED.as_mut_ptr(),\n            //             1, //     only one thread\n            //         );\n            //     }\n        }\n    }\n}\n\n#[cfg(not(target_feature = \"atomics\"))]\nmod lock {\n    #[inline]\n    pub fn lock() {} // no atomics, no threads, that's easy!\n}\n"],["2426","use crate::alloc::{GlobalAlloc, Layout, System};\nuse crate::ptr;\nuse crate::sys::sgx::abi::mem as sgx_mem;\nuse core::sync::atomic::{AtomicBool, Ordering};\n\nuse super::waitqueue::SpinMutex;\n\n// Using a SpinMutex because we never want to exit the enclave waiting for the\n// allocator.\n//\n// The current allocator here is the `dlmalloc` crate which we've got included\n// in the rust-lang/rust repository as a submodule. The crate is a port of\n// dlmalloc.c from C to Rust.\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx5alloc8DLMALLOCE\"]\nstatic DLMALLOC: SpinMutex<dlmalloc::Dlmalloc<Sgx>> =\n    SpinMutex::new(dlmalloc::Dlmalloc::new_with_allocator(Sgx {}));\n\nstruct Sgx;\n\nunsafe impl dlmalloc::Allocator for Sgx {\n    /// Allocs system resources\n    fn alloc(&self, _size: usize) -> (*mut u8, usize, u32) {\n        static INIT: AtomicBool = AtomicBool::new(false);\n\n        // No ordering requirement since this function is protected by the global lock.\n        if !INIT.swap(true, Ordering::Relaxed) {\n            (sgx_mem::heap_base() as _, sgx_mem::heap_size(), 0)\n        } else {\n            (ptr::null_mut(), 0, 0)\n        }\n    }\n\n    fn remap(&self, _ptr: *mut u8, _oldsize: usize, _newsize: usize, _can_move: bool) -> *mut u8 {\n        ptr::null_mut()\n    }\n\n    fn free_part(&self, _ptr: *mut u8, _oldsize: usize, _newsize: usize) -> bool {\n        false\n    }\n\n    fn free(&self, _ptr: *mut u8, _size: usize) -> bool {\n        return false;\n    }\n\n    fn can_release_part(&self, _flags: u32) -> bool {\n        false\n    }\n\n    fn allocates_zeros(&self) -> bool {\n        false\n    }\n\n    fn page_size(&self) -> usize {\n        0x1000\n    }\n}\n\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: the caller must uphold the safety contract for `malloc`\n        unsafe { DLMALLOC.lock().malloc(layout.size(), layout.align()) }\n    }\n\n    #[inline]\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: the caller must uphold the safety contract for `malloc`\n        unsafe { DLMALLOC.lock().calloc(layout.size(), layout.align()) }\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n        // SAFETY: the caller must uphold the safety contract for `malloc`\n        unsafe { DLMALLOC.lock().free(ptr, layout.size(), layout.align()) }\n    }\n\n    #[inline]\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        // SAFETY: the caller must uphold the safety contract for `malloc`\n        unsafe { DLMALLOC.lock().realloc(ptr, layout.size(), layout.align(), new_size) }\n    }\n}\n\n// The following functions are needed by libunwind. These symbols are named\n// in pre-link args for the target specification, so keep that in sync.\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_c_alloc(size: usize, align: usize) -> *mut u8 {\n    unsafe { crate::alloc::alloc(Layout::from_size_align_unchecked(size, align)) }\n}\n\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_c_dealloc(ptr: *mut u8, size: usize, align: usize) {\n    unsafe { crate::alloc::dealloc(ptr, Layout::from_size_align_unchecked(size, align)) }\n}\n"],["2427","pub mod os {\n    pub const FAMILY: &str = \"\";\n    pub const OS: &str = \"\";\n    pub const DLL_PREFIX: &str = \"\";\n    pub const DLL_SUFFIX: &str = \".sgxs\";\n    pub const DLL_EXTENSION: &str = \"sgxs\";\n    pub const EXE_SUFFIX: &str = \".sgxs\";\n    pub const EXE_EXTENSION: &str = \"sgxs\";\n}\n"],["2428","//! System bindings for the Fortanix SGX platform\n//!\n//! This module contains the facade (aka platform-specific) implementations of\n//! OS level functionality for Fortanix SGX.\n#![deny(unsafe_op_in_unsafe_fn)]\n\nuse crate::io::ErrorKind;\nuse crate::os::raw::c_char;\nuse crate::sync::atomic::{AtomicBool, Ordering};\n\npub mod abi;\nmod waitqueue;\n\npub mod alloc;\npub mod args;\n#[path = \"../unix/cmath.rs\"]\npub mod cmath;\npub mod condvar;\npub mod env;\npub mod fd;\n#[path = \"../unsupported/fs.rs\"]\npub mod fs;\n#[path = \"../unsupported/io.rs\"]\npub mod io;\npub mod memchr;\npub mod mutex;\npub mod net;\npub mod os;\npub mod path;\n#[path = \"../unsupported/pipe.rs\"]\npub mod pipe;\n#[path = \"../unsupported/process.rs\"]\npub mod process;\npub mod rwlock;\npub mod stdio;\npub mod thread;\npub mod thread_local_key;\npub mod time;\n\npub use crate::sys_common::os_str_bytes as os_str;\n\n// SAFETY: must be called only once during runtime initialization.\n// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    unsafe {\n        args::init(argc, argv);\n    }\n}\n\n// SAFETY: must be called only once during runtime cleanup.\n// NOTE: this is not guaranteed to run, for example when the program aborts.\npub unsafe fn cleanup() {}\n\n/// This function is used to implement functionality that simply doesn't exist.\n/// Programs relying on this functionality will need to deal with the error.\npub fn unsupported<T>() -> crate::io::Result<T> {\n    Err(unsupported_err())\n}\n\npub fn unsupported_err() -> crate::io::Error {\n    crate::io::Error::new_const(ErrorKind::Unsupported, &\"operation not supported on SGX yet\")\n}\n\n/// This function is used to implement various functions that doesn't exist,\n/// but the lack of which might not be reason for error. If no error is\n/// returned, the program might very well be able to function normally. This is\n/// what happens when `SGX_INEFFECTIVE_ERROR` is set to `true`. If it is\n/// `false`, the behavior is the same as `unsupported`.\npub fn sgx_ineffective<T>(v: T) -> crate::io::Result<T> {\n    static SGX_INEFFECTIVE_ERROR: AtomicBool = AtomicBool::new(false);\n    if SGX_INEFFECTIVE_ERROR.load(Ordering::Relaxed) {\n        Err(crate::io::Error::new_const(\n            ErrorKind::Other,\n            &\"operation can't be trusted to have any effect on SGX\",\n        ))\n    } else {\n        Ok(v)\n    }\n}\n\npub fn decode_error_kind(code: i32) -> ErrorKind {\n    use fortanix_sgx_abi::Error;\n\n    // FIXME: not sure how to make sure all variants of Error are covered\n    if code == Error::NotFound as _ {\n        ErrorKind::NotFound\n    } else if code == Error::PermissionDenied as _ {\n        ErrorKind::PermissionDenied\n    } else if code == Error::ConnectionRefused as _ {\n        ErrorKind::ConnectionRefused\n    } else if code == Error::ConnectionReset as _ {\n        ErrorKind::ConnectionReset\n    } else if code == Error::ConnectionAborted as _ {\n        ErrorKind::ConnectionAborted\n    } else if code == Error::NotConnected as _ {\n        ErrorKind::NotConnected\n    } else if code == Error::AddrInUse as _ {\n        ErrorKind::AddrInUse\n    } else if code == Error::AddrNotAvailable as _ {\n        ErrorKind::AddrNotAvailable\n    } else if code == Error::BrokenPipe as _ {\n        ErrorKind::BrokenPipe\n    } else if code == Error::AlreadyExists as _ {\n        ErrorKind::AlreadyExists\n    } else if code == Error::WouldBlock as _ {\n        ErrorKind::WouldBlock\n    } else if code == Error::InvalidInput as _ {\n        ErrorKind::InvalidInput\n    } else if code == Error::InvalidData as _ {\n        ErrorKind::InvalidData\n    } else if code == Error::TimedOut as _ {\n        ErrorKind::TimedOut\n    } else if code == Error::WriteZero as _ {\n        ErrorKind::WriteZero\n    } else if code == Error::Interrupted as _ {\n        ErrorKind::Interrupted\n    } else if code == Error::Other as _ {\n        ErrorKind::Other\n    } else if code == Error::UnexpectedEof as _ {\n        ErrorKind::UnexpectedEof\n    } else {\n        ErrorKind::Other\n    }\n}\n\npub unsafe fn strlen(mut s: *const c_char) -> usize {\n    let mut n = 0;\n    while unsafe { *s } != 0 {\n        n += 1;\n        s = unsafe { s.offset(1) };\n    }\n    return n;\n}\n\npub fn abort_internal() -> ! {\n    abi::usercalls::exit(true)\n}\n\n// This function is needed by the panic runtime. The symbol is named in\n// pre-link args for the target specification, so keep that in sync.\n#[cfg(not(test))]\n#[no_mangle]\n// NB. used by both libunwind and libpanic_abort\npub extern \"C\" fn __rust_abort() {\n    abort_internal();\n}\n\npub mod rand {\n    pub fn rdrand64() -> u64 {\n        unsafe {\n            let mut ret: u64 = 0;\n            for _ in 0..10 {\n                if crate::arch::x86_64::_rdrand64_step(&mut ret) == 1 {\n                    return ret;\n                }\n            }\n            rtabort!(\"Failed to obtain random data\");\n        }\n    }\n}\n\npub fn hashmap_random_keys() -> (u64, u64) {\n    (self::rand::rdrand64(), self::rand::rdrand64())\n}\n\npub use crate::sys_common::{AsInner, FromInner, IntoInner};\n\npub trait TryIntoInner<Inner>: Sized {\n    fn try_into_inner(self) -> Result<Inner, Self>;\n}\n"],["2429","use crate::convert::TryFrom;\nuse crate::error;\nuse crate::fmt;\nuse crate::io::{self, IoSlice, IoSliceMut};\nuse crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr, ToSocketAddrs};\nuse crate::sync::Arc;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::{sgx_ineffective, unsupported, AsInner, FromInner, IntoInner, TryIntoInner};\nuse crate::time::Duration;\n\nuse super::abi::usercalls;\n\nconst DEFAULT_FAKE_TTL: u32 = 64;\n\n#[derive(Debug, Clone)]\npub struct Socket {\n    inner: Arc<FileDesc>,\n    local_addr: Option<String>,\n}\n\nimpl Socket {\n    fn new(fd: usercalls::raw::Fd, local_addr: String) -> Socket {\n        Socket { inner: Arc::new(FileDesc::new(fd)), local_addr: Some(local_addr) }\n    }\n}\n\nimpl AsInner<FileDesc> for Socket {\n    fn as_inner(&self) -> &FileDesc {\n        &self.inner\n    }\n}\n\nimpl TryIntoInner<FileDesc> for Socket {\n    fn try_into_inner(self) -> Result<FileDesc, Socket> {\n        let Socket { inner, local_addr } = self;\n        Arc::try_unwrap(inner).map_err(|inner| Socket { inner, local_addr })\n    }\n}\n\nimpl FromInner<(FileDesc, Option<String>)> for Socket {\n    fn from_inner((inner, local_addr): (FileDesc, Option<String>)) -> Socket {\n        Socket { inner: Arc::new(inner), local_addr }\n    }\n}\n\n#[derive(Clone)]\npub struct TcpStream {\n    inner: Socket,\n    peer_addr: Option<String>,\n}\n\nimpl fmt::Debug for TcpStream {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut res = f.debug_struct(\"TcpStream\");\n\n        if let Some(ref addr) = self.inner.local_addr {\n            res.field(\"addr\", addr);\n        }\n\n        if let Some(ref peer) = self.peer_addr {\n            res.field(\"peer\", peer);\n        }\n\n        res.field(\"fd\", &self.inner.inner.as_inner()).finish()\n    }\n}\n\nfn io_err_to_addr(result: io::Result<&SocketAddr>) -> io::Result<String> {\n    match result {\n        Ok(saddr) => Ok(saddr.to_string()),\n        // need to downcast twice because io::Error::into_inner doesn't return the original\n        // value if the conversion fails\n        Err(e) => {\n            if e.get_ref().and_then(|e| e.downcast_ref::<NonIpSockAddr>()).is_some() {\n                Ok(e.into_inner().unwrap().downcast::<NonIpSockAddr>().unwrap().host)\n            } else {\n                Err(e)\n            }\n        }\n    }\n}\n\nfn addr_to_sockaddr(addr: &Option<String>) -> io::Result<SocketAddr> {\n    addr.as_ref()\n        .ok_or(io::ErrorKind::AddrNotAvailable)?\n        .to_socket_addrs()\n        // unwrap OK: if an iterator is returned, we're guaranteed to get exactly one entry\n        .map(|mut it| it.next().unwrap())\n}\n\nimpl TcpStream {\n    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n        let addr = io_err_to_addr(addr)?;\n        let (fd, local_addr, peer_addr) = usercalls::connect_stream(&addr)?;\n        Ok(TcpStream { inner: Socket::new(fd, local_addr), peer_addr: Some(peer_addr) })\n    }\n\n    pub fn connect_timeout(addr: &SocketAddr, dur: Duration) -> io::Result<TcpStream> {\n        if dur == Duration::default() {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidInput,\n                &\"cannot set a 0 duration timeout\",\n            ));\n        }\n        Self::connect(Ok(addr)) // FIXME: ignoring timeout\n    }\n\n    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        match dur {\n            Some(dur) if dur == Duration::default() => {\n                return Err(io::Error::new_const(\n                    io::ErrorKind::InvalidInput,\n                    &\"cannot set a 0 duration timeout\",\n                ));\n            }\n            _ => sgx_ineffective(()),\n        }\n    }\n\n    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n        match dur {\n            Some(dur) if dur == Duration::default() => {\n                return Err(io::Error::new_const(\n                    io::ErrorKind::InvalidInput,\n                    &\"cannot set a 0 duration timeout\",\n                ));\n            }\n            _ => sgx_ineffective(()),\n        }\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        sgx_ineffective(None)\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        sgx_ineffective(None)\n    }\n\n    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n        Ok(0)\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.inner.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.inner.inner.is_read_vectored()\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.inner.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.inner.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.inner.inner.is_write_vectored()\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        addr_to_sockaddr(&self.peer_addr)\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        addr_to_sockaddr(&self.inner.local_addr)\n    }\n\n    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpStream> {\n        Ok(self.clone())\n    }\n\n    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn nodelay(&self) -> io::Result<bool> {\n        sgx_ineffective(false)\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        sgx_ineffective(DEFAULT_FAKE_TTL)\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        Ok(None)\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n}\n\nimpl AsInner<Socket> for TcpStream {\n    fn as_inner(&self) -> &Socket {\n        &self.inner\n    }\n}\n\n// `Inner` includes `peer_addr` so that a `TcpStream` maybe correctly\n// reconstructed if `Socket::try_into_inner` fails.\nimpl IntoInner<(Socket, Option<String>)> for TcpStream {\n    fn into_inner(self) -> (Socket, Option<String>) {\n        (self.inner, self.peer_addr)\n    }\n}\n\nimpl FromInner<(Socket, Option<String>)> for TcpStream {\n    fn from_inner((inner, peer_addr): (Socket, Option<String>)) -> TcpStream {\n        TcpStream { inner, peer_addr }\n    }\n}\n\n#[derive(Clone)]\npub struct TcpListener {\n    inner: Socket,\n}\n\nimpl fmt::Debug for TcpListener {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut res = f.debug_struct(\"TcpListener\");\n\n        if let Some(ref addr) = self.inner.local_addr {\n            res.field(\"addr\", addr);\n        }\n\n        res.field(\"fd\", &self.inner.inner.as_inner()).finish()\n    }\n}\n\nimpl TcpListener {\n    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n        let addr = io_err_to_addr(addr)?;\n        let (fd, local_addr) = usercalls::bind_stream(&addr)?;\n        Ok(TcpListener { inner: Socket::new(fd, local_addr) })\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        addr_to_sockaddr(&self.inner.local_addr)\n    }\n\n    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n        let (fd, local_addr, peer_addr) = usercalls::accept_stream(self.inner.inner.raw())?;\n        let peer_addr = Some(peer_addr);\n        let ret_peer = addr_to_sockaddr(&peer_addr).unwrap_or_else(|_| ([0; 4], 0).into());\n        Ok((TcpStream { inner: Socket::new(fd, local_addr), peer_addr }, ret_peer))\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpListener> {\n        Ok(self.clone())\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        sgx_ineffective(DEFAULT_FAKE_TTL)\n    }\n\n    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n\n    pub fn only_v6(&self) -> io::Result<bool> {\n        sgx_ineffective(false)\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        Ok(None)\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        sgx_ineffective(())\n    }\n}\n\nimpl AsInner<Socket> for TcpListener {\n    fn as_inner(&self) -> &Socket {\n        &self.inner\n    }\n}\n\nimpl IntoInner<Socket> for TcpListener {\n    fn into_inner(self) -> Socket {\n        self.inner\n    }\n}\n\nimpl FromInner<Socket> for TcpListener {\n    fn from_inner(inner: Socket) -> TcpListener {\n        TcpListener { inner }\n    }\n}\n\npub struct UdpSocket(!);\n\nimpl UdpSocket {\n    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n        unsupported()\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        self.0\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        self.0\n    }\n\n    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.0\n    }\n\n    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.0\n    }\n\n    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n        self.0\n    }\n\n    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        self.0\n    }\n\n    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn broadcast(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n        self.0\n    }\n\n    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n        self.0\n    }\n\n    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        self.0\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.0\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        self.0\n    }\n\n    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n        self.0\n    }\n\n    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n        self.0\n    }\n}\n\nimpl fmt::Debug for UdpSocket {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\n#[derive(Debug)]\npub struct NonIpSockAddr {\n    host: String,\n}\n\nimpl error::Error for NonIpSockAddr {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"Failed to convert address to SocketAddr\"\n    }\n}\n\nimpl fmt::Display for NonIpSockAddr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Failed to convert address to SocketAddr: {}\", self.host)\n    }\n}\n\npub struct LookupHost(!);\n\nimpl LookupHost {\n    fn new(host: String) -> io::Result<LookupHost> {\n        Err(io::Error::new(io::ErrorKind::Other, NonIpSockAddr { host }))\n    }\n\n    pub fn port(&self) -> u16 {\n        self.0\n    }\n}\n\nimpl Iterator for LookupHost {\n    type Item = SocketAddr;\n    fn next(&mut self) -> Option<SocketAddr> {\n        self.0\n    }\n}\n\nimpl TryFrom<&str> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from(v: &str) -> io::Result<LookupHost> {\n        LookupHost::new(v.to_owned())\n    }\n}\n\nimpl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from((host, port): (&'a str, u16)) -> io::Result<LookupHost> {\n        LookupHost::new(format!(\"{}:{}\", host, port))\n    }\n}\n\n#[allow(bad_style)]\npub mod netc {\n    pub const AF_INET: u8 = 0;\n    pub const AF_INET6: u8 = 1;\n    pub type sa_family_t = u8;\n\n    #[derive(Copy, Clone)]\n    pub struct in_addr {\n        pub s_addr: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in {\n        pub sin_family: sa_family_t,\n        pub sin_port: u16,\n        pub sin_addr: in_addr,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct in6_addr {\n        pub s6_addr: [u8; 16],\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in6 {\n        pub sin6_family: sa_family_t,\n        pub sin6_port: u16,\n        pub sin6_addr: in6_addr,\n        pub sin6_flowinfo: u32,\n        pub sin6_scope_id: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr {}\n\n    pub type socklen_t = usize;\n}\n"],["2430","use super::*;\nuse crate::sync::Arc;\nuse crate::thread;\n\n#[test]\nfn queue() {\n    let wq = Arc::new(SpinMutex::<WaitVariable<()>>::default());\n    let wq2 = wq.clone();\n\n    let locked = wq.lock();\n\n    let t1 = thread::spawn(move || {\n        // if we obtain the lock, the main thread should be waiting\n        assert!(WaitQueue::notify_one(wq2.lock()).is_ok());\n    });\n\n    WaitQueue::wait(locked, || {});\n\n    t1.join().unwrap();\n}\n"],["2431","use super::*;\nuse crate::cell::Cell;\n\n/// # Safety\n/// List must be valid.\nunsafe fn assert_empty<T>(list: &mut UnsafeList<T>) {\n    assert!(unsafe { list.pop() }.is_none(), \"assertion failed: list is not empty\");\n}\n\n#[test]\nfn init_empty() {\n    unsafe {\n        assert_empty(&mut UnsafeList::<i32>::new());\n    }\n}\n\n#[test]\nfn push_pop() {\n    unsafe {\n        let mut node = UnsafeListEntry::new(1234);\n        let mut list = UnsafeList::new();\n        assert_eq!(list.push(&mut node), &1234);\n        assert_eq!(list.pop().unwrap(), &1234);\n        assert_empty(&mut list);\n    }\n}\n\n#[test]\nfn push_remove() {\n    unsafe {\n        let mut node = UnsafeListEntry::new(1234);\n        let mut list = UnsafeList::new();\n        assert_eq!(list.push(&mut node), &1234);\n        list.remove(&mut node);\n        assert_empty(&mut list);\n    }\n}\n\n#[test]\nfn push_remove_pop() {\n    unsafe {\n        let mut node1 = UnsafeListEntry::new(11);\n        let mut node2 = UnsafeListEntry::new(12);\n        let mut node3 = UnsafeListEntry::new(13);\n        let mut node4 = UnsafeListEntry::new(14);\n        let mut node5 = UnsafeListEntry::new(15);\n        let mut list = UnsafeList::new();\n        assert_eq!(list.push(&mut node1), &11);\n        assert_eq!(list.push(&mut node2), &12);\n        assert_eq!(list.push(&mut node3), &13);\n        assert_eq!(list.push(&mut node4), &14);\n        assert_eq!(list.push(&mut node5), &15);\n\n        list.remove(&mut node1);\n        assert_eq!(list.pop().unwrap(), &12);\n        list.remove(&mut node3);\n        assert_eq!(list.pop().unwrap(), &14);\n        list.remove(&mut node5);\n        assert_empty(&mut list);\n\n        assert_eq!(list.push(&mut node1), &11);\n        assert_eq!(list.pop().unwrap(), &11);\n        assert_empty(&mut list);\n\n        assert_eq!(list.push(&mut node3), &13);\n        assert_eq!(list.push(&mut node4), &14);\n        list.remove(&mut node3);\n        list.remove(&mut node4);\n        assert_empty(&mut list);\n    }\n}\n\n#[test]\nfn complex_pushes_pops() {\n    unsafe {\n        let mut node1 = UnsafeListEntry::new(1234);\n        let mut node2 = UnsafeListEntry::new(4567);\n        let mut node3 = UnsafeListEntry::new(9999);\n        let mut node4 = UnsafeListEntry::new(8642);\n        let mut list = UnsafeList::new();\n        list.push(&mut node1);\n        list.push(&mut node2);\n        assert_eq!(list.pop().unwrap(), &1234);\n        list.push(&mut node3);\n        assert_eq!(list.pop().unwrap(), &4567);\n        assert_eq!(list.pop().unwrap(), &9999);\n        assert_empty(&mut list);\n        list.push(&mut node4);\n        assert_eq!(list.pop().unwrap(), &8642);\n        assert_empty(&mut list);\n    }\n}\n\n#[test]\nfn cell() {\n    unsafe {\n        let mut node = UnsafeListEntry::new(Cell::new(0));\n        let mut list = UnsafeList::new();\n        let noderef = list.push(&mut node);\n        assert_eq!(noderef.get(), 0);\n        list.pop().unwrap().set(1);\n        assert_empty(&mut list);\n        assert_eq!(noderef.get(), 1);\n    }\n}\n"],["2432","//! A simple queue implementation for synchronization primitives.\n//!\n//! This queue is used to implement condition variable and mutexes.\n//!\n//! Users of this API are expected to use the `WaitVariable<T>` type. Since\n//! that type is not `Sync`, it needs to be protected by e.g., a `SpinMutex` to\n//! allow shared access.\n//!\n//! Since userspace may send spurious wake-ups, the wakeup event state is\n//! recorded in the enclave. The wakeup event state is protected by a spinlock.\n//! The queue and associated wait state are stored in a `WaitVariable`.\n\n#[cfg(test)]\nmod tests;\n\nmod spin_mutex;\nmod unsafe_list;\n\nuse crate::num::NonZeroUsize;\nuse crate::ops::{Deref, DerefMut};\nuse crate::time::Duration;\n\nuse super::abi::thread;\nuse super::abi::usercalls;\nuse fortanix_sgx_abi::{Tcs, EV_UNPARK, WAIT_INDEFINITE};\n\npub use self::spin_mutex::{try_lock_or_false, SpinMutex, SpinMutexGuard};\nuse self::unsafe_list::{UnsafeList, UnsafeListEntry};\n\n/// An queue entry in a `WaitQueue`.\nstruct WaitEntry {\n    /// TCS address of the thread that is waiting\n    tcs: Tcs,\n    /// Whether this thread has been notified to be awoken\n    wake: bool,\n}\n\n/// Data stored with a `WaitQueue` alongside it. This ensures accesses to the\n/// queue and the data are synchronized, since the type itself is not `Sync`.\n///\n/// Consumers of this API should use a synchronization primitive for shared\n/// access, such as `SpinMutex`.\n#[derive(Default)]\npub struct WaitVariable<T> {\n    queue: WaitQueue,\n    lock: T,\n}\n\nimpl<T> WaitVariable<T> {\n    pub const fn new(var: T) -> Self {\n        WaitVariable { queue: WaitQueue::new(), lock: var }\n    }\n\n    pub fn queue_empty(&self) -> bool {\n        self.queue.is_empty()\n    }\n\n    pub fn lock_var(&self) -> &T {\n        &self.lock\n    }\n\n    pub fn lock_var_mut(&mut self) -> &mut T {\n        &mut self.lock\n    }\n}\n\n#[derive(Copy, Clone)]\npub enum NotifiedTcs {\n    Single(Tcs),\n    All { count: NonZeroUsize },\n}\n\n/// An RAII guard that will notify a set of target threads as well as unlock\n/// a mutex on drop.\npub struct WaitGuard<'a, T: 'a> {\n    mutex_guard: Option<SpinMutexGuard<'a, WaitVariable<T>>>,\n    notified_tcs: NotifiedTcs,\n}\n\n/// A queue of threads that are waiting on some synchronization primitive.\n///\n/// `UnsafeList` entries are allocated on the waiting thread's stack. This\n/// avoids any global locking that might happen in the heap allocator. This is\n/// safe because the waiting thread will not return from that stack frame until\n/// after it is notified. The notifying thread ensures to clean up any\n/// references to the list entries before sending the wakeup event.\npub struct WaitQueue {\n    // We use an inner Mutex here to protect the data in the face of spurious\n    // wakeups.\n    inner: UnsafeList<SpinMutex<WaitEntry>>,\n}\nunsafe impl Send for WaitQueue {}\n\nimpl Default for WaitQueue {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<'a, T> WaitGuard<'a, T> {\n    /// Returns which TCSes will be notified when this guard drops.\n    pub fn notified_tcs(&self) -> NotifiedTcs {\n        self.notified_tcs\n    }\n\n    /// Drop this `WaitGuard`, after dropping another `guard`.\n    pub fn drop_after<U>(self, guard: U) {\n        drop(guard);\n        drop(self);\n    }\n}\n\nimpl<'a, T> Deref for WaitGuard<'a, T> {\n    type Target = SpinMutexGuard<'a, WaitVariable<T>>;\n\n    fn deref(&self) -> &Self::Target {\n        self.mutex_guard.as_ref().unwrap()\n    }\n}\n\nimpl<'a, T> DerefMut for WaitGuard<'a, T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        self.mutex_guard.as_mut().unwrap()\n    }\n}\n\nimpl<'a, T> Drop for WaitGuard<'a, T> {\n    fn drop(&mut self) {\n        drop(self.mutex_guard.take());\n        let target_tcs = match self.notified_tcs {\n            NotifiedTcs::Single(tcs) => Some(tcs),\n            NotifiedTcs::All { .. } => None,\n        };\n        rtunwrap!(Ok, usercalls::send(EV_UNPARK, target_tcs));\n    }\n}\n\nimpl WaitQueue {\n    pub const fn new() -> Self {\n        WaitQueue { inner: UnsafeList::new() }\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.inner.is_empty()\n    }\n\n    /// Adds the calling thread to the `WaitVariable`'s wait queue, then wait\n    /// until a wakeup event.\n    ///\n    /// This function does not return until this thread has been awoken.\n    pub fn wait<T, F: FnOnce()>(mut guard: SpinMutexGuard<'_, WaitVariable<T>>, before_wait: F) {\n        // very unsafe: check requirements of UnsafeList::push\n        unsafe {\n            let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n                tcs: thread::current(),\n                wake: false,\n            }));\n            let entry = guard.queue.inner.push(&mut entry);\n            drop(guard);\n            before_wait();\n            while !entry.lock().wake {\n                // don't panic, this would invalidate `entry` during unwinding\n                let eventset = rtunwrap!(Ok, usercalls::wait(EV_UNPARK, WAIT_INDEFINITE));\n                rtassert!(eventset & EV_UNPARK == EV_UNPARK);\n            }\n        }\n    }\n\n    /// Adds the calling thread to the `WaitVariable`'s wait queue, then wait\n    /// until a wakeup event or timeout. If event was observed, returns true.\n    /// If not, it will remove the calling thread from the wait queue.\n    pub fn wait_timeout<T, F: FnOnce()>(\n        lock: &SpinMutex<WaitVariable<T>>,\n        timeout: Duration,\n        before_wait: F,\n    ) -> bool {\n        // very unsafe: check requirements of UnsafeList::push\n        unsafe {\n            let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n                tcs: thread::current(),\n                wake: false,\n            }));\n            let entry_lock = lock.lock().queue.inner.push(&mut entry);\n            before_wait();\n            usercalls::wait_timeout(EV_UNPARK, timeout, || entry_lock.lock().wake);\n            // acquire the wait queue's lock first to avoid deadlock.\n            let mut guard = lock.lock();\n            let success = entry_lock.lock().wake;\n            if !success {\n                // nobody is waking us up, so remove our entry from the wait queue.\n                guard.queue.inner.remove(&mut entry);\n            }\n            success\n        }\n    }\n\n    /// Either find the next waiter on the wait queue, or return the mutex\n    /// guard unchanged.\n    ///\n    /// If a waiter is found, a `WaitGuard` is returned which will notify the\n    /// waiter when it is dropped.\n    pub fn notify_one<T>(\n        mut guard: SpinMutexGuard<'_, WaitVariable<T>>,\n    ) -> Result<WaitGuard<'_, T>, SpinMutexGuard<'_, WaitVariable<T>>> {\n        unsafe {\n            if let Some(entry) = guard.queue.inner.pop() {\n                let mut entry_guard = entry.lock();\n                let tcs = entry_guard.tcs;\n                entry_guard.wake = true;\n                drop(entry);\n                Ok(WaitGuard { mutex_guard: Some(guard), notified_tcs: NotifiedTcs::Single(tcs) })\n            } else {\n                Err(guard)\n            }\n        }\n    }\n\n    /// Either find any and all waiters on the wait queue, or return the mutex\n    /// guard unchanged.\n    ///\n    /// If at least one waiter is found, a `WaitGuard` is returned which will\n    /// notify all waiters when it is dropped.\n    pub fn notify_all<T>(\n        mut guard: SpinMutexGuard<'_, WaitVariable<T>>,\n    ) -> Result<WaitGuard<'_, T>, SpinMutexGuard<'_, WaitVariable<T>>> {\n        unsafe {\n            let mut count = 0;\n            while let Some(entry) = guard.queue.inner.pop() {\n                count += 1;\n                let mut entry_guard = entry.lock();\n                entry_guard.wake = true;\n            }\n            if let Some(count) = NonZeroUsize::new(count) {\n                Ok(WaitGuard { mutex_guard: Some(guard), notified_tcs: NotifiedTcs::All { count } })\n            } else {\n                Err(guard)\n            }\n        }\n    }\n}\n"],["2433","//! A doubly-linked list where callers are in charge of memory allocation\n//! of the nodes in the list.\n\n#[cfg(test)]\nmod tests;\n\nuse crate::mem;\nuse crate::ptr::NonNull;\n\npub struct UnsafeListEntry<T> {\n    next: NonNull<UnsafeListEntry<T>>,\n    prev: NonNull<UnsafeListEntry<T>>,\n    value: Option<T>,\n}\n\nimpl<T> UnsafeListEntry<T> {\n    fn dummy() -> Self {\n        UnsafeListEntry { next: NonNull::dangling(), prev: NonNull::dangling(), value: None }\n    }\n\n    pub fn new(value: T) -> Self {\n        UnsafeListEntry { value: Some(value), ..Self::dummy() }\n    }\n}\n\npub struct UnsafeList<T> {\n    head_tail: NonNull<UnsafeListEntry<T>>,\n    head_tail_entry: Option<UnsafeListEntry<T>>,\n}\n\nimpl<T> UnsafeList<T> {\n    pub const fn new() -> Self {\n        unsafe { UnsafeList { head_tail: NonNull::new_unchecked(1 as _), head_tail_entry: None } }\n    }\n\n    /// # Safety\n    unsafe fn init(&mut self) {\n        if self.head_tail_entry.is_none() {\n            self.head_tail_entry = Some(UnsafeListEntry::dummy());\n            // SAFETY: `head_tail_entry` must be non-null, which it is because we assign it above.\n            self.head_tail =\n                unsafe { NonNull::new_unchecked(self.head_tail_entry.as_mut().unwrap()) };\n            // SAFETY: `self.head_tail` must meet all requirements for a mutable reference.\n            unsafe { self.head_tail.as_mut() }.next = self.head_tail;\n            unsafe { self.head_tail.as_mut() }.prev = self.head_tail;\n        }\n    }\n\n    pub fn is_empty(&self) -> bool {\n        if self.head_tail_entry.is_some() {\n            let first = unsafe { self.head_tail.as_ref() }.next;\n            if first == self.head_tail {\n                // ,-------> /---------\\ next ---,\n                // |         |head_tail|         |\n                // `--- prev \\---------/ <-------`\n                // SAFETY: `self.head_tail` must meet all requirements for a reference.\n                unsafe { rtassert!(self.head_tail.as_ref().prev == first) };\n                true\n            } else {\n                false\n            }\n        } else {\n            true\n        }\n    }\n\n    /// Pushes an entry onto the back of the list.\n    ///\n    /// # Safety\n    ///\n    /// The entry must remain allocated until the entry is removed from the\n    /// list AND the caller who popped is done using the entry. Special\n    /// care must be taken in the caller of `push` to ensure unwinding does\n    /// not destroy the stack frame containing the entry.\n    pub unsafe fn push<'a>(&mut self, entry: &'a mut UnsafeListEntry<T>) -> &'a T {\n        unsafe { self.init() };\n\n        // BEFORE:\n        //     /---------\\ next ---> /---------\\\n        // ... |prev_tail|           |head_tail| ...\n        //     \\---------/ <--- prev \\---------/\n        //\n        // AFTER:\n        //     /---------\\ next ---> /-----\\ next ---> /---------\\\n        // ... |prev_tail|           |entry|           |head_tail| ...\n        //     \\---------/ <--- prev \\-----/ <--- prev \\---------/\n        let mut entry = unsafe { NonNull::new_unchecked(entry) };\n        let mut prev_tail = mem::replace(&mut unsafe { self.head_tail.as_mut() }.prev, entry);\n        // SAFETY: `entry` must meet all requirements for a mutable reference.\n        unsafe { entry.as_mut() }.prev = prev_tail;\n        unsafe { entry.as_mut() }.next = self.head_tail;\n        // SAFETY: `prev_tail` must meet all requirements for a mutable reference.\n        unsafe { prev_tail.as_mut() }.next = entry;\n        // unwrap ok: always `Some` on non-dummy entries\n        unsafe { (*entry.as_ptr()).value.as_ref() }.unwrap()\n    }\n\n    /// Pops an entry from the front of the list.\n    ///\n    /// # Safety\n    ///\n    /// The caller must make sure to synchronize ending the borrow of the\n    /// return value and deallocation of the containing entry.\n    pub unsafe fn pop<'a>(&mut self) -> Option<&'a T> {\n        unsafe { self.init() };\n\n        if self.is_empty() {\n            None\n        } else {\n            // BEFORE:\n            //     /---------\\ next ---> /-----\\ next ---> /------\\\n            // ... |head_tail|           |first|           |second| ...\n            //     \\---------/ <--- prev \\-----/ <--- prev \\------/\n            //\n            // AFTER:\n            //     /---------\\ next ---> /------\\\n            // ... |head_tail|           |second| ...\n            //     \\---------/ <--- prev \\------/\n            let mut first = unsafe { self.head_tail.as_mut() }.next;\n            let mut second = unsafe { first.as_mut() }.next;\n            unsafe { self.head_tail.as_mut() }.next = second;\n            unsafe { second.as_mut() }.prev = self.head_tail;\n            unsafe { first.as_mut() }.next = NonNull::dangling();\n            unsafe { first.as_mut() }.prev = NonNull::dangling();\n            // unwrap ok: always `Some` on non-dummy entries\n            Some(unsafe { (*first.as_ptr()).value.as_ref() }.unwrap())\n        }\n    }\n\n    /// Removes an entry from the list.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that `entry` has been pushed onto `self`\n    /// prior to this call and has not moved since then.\n    pub unsafe fn remove(&mut self, entry: &mut UnsafeListEntry<T>) {\n        rtassert!(!self.is_empty());\n        // BEFORE:\n        //     /----\\ next ---> /-----\\ next ---> /----\\\n        // ... |prev|           |entry|           |next| ...\n        //     \\----/ <--- prev \\-----/ <--- prev \\----/\n        //\n        // AFTER:\n        //     /----\\ next ---> /----\\\n        // ... |prev|           |next| ...\n        //     \\----/ <--- prev \\----/\n        let mut prev = entry.prev;\n        let mut next = entry.next;\n        // SAFETY: `prev` and `next` must meet all requirements for a mutable reference.entry\n        unsafe { prev.as_mut() }.next = next;\n        unsafe { next.as_mut() }.prev = prev;\n        entry.next = NonNull::dangling();\n        entry.prev = NonNull::dangling();\n    }\n}\n"],["2434","#![allow(deprecated)]\n\nuse super::*;\nuse crate::sync::Arc;\nuse crate::thread;\nuse crate::time::Duration;\n\n#[test]\nfn sleep() {\n    let mutex = Arc::new(SpinMutex::<i32>::default());\n    let mutex2 = mutex.clone();\n    let guard = mutex.lock();\n    let t1 = thread::spawn(move || {\n        *mutex2.lock() = 1;\n    });\n\n    thread::sleep(Duration::from_millis(50));\n\n    assert_eq!(*guard, 0);\n    drop(guard);\n    t1.join().unwrap();\n    assert_eq!(*mutex.lock(), 1);\n}\n"],["2435","//! Trivial spinlock-based implementation of `sync::Mutex`.\n// FIXME: Perhaps use Intel TSX to avoid locking?\n\n#[cfg(test)]\nmod tests;\n\nuse crate::cell::UnsafeCell;\nuse crate::hint;\nuse crate::ops::{Deref, DerefMut};\nuse crate::sync::atomic::{AtomicBool, Ordering};\n\n#[derive(Default)]\npub struct SpinMutex<T> {\n    value: UnsafeCell<T>,\n    lock: AtomicBool,\n}\n\nunsafe impl<T: Send> Send for SpinMutex<T> {}\nunsafe impl<T: Send> Sync for SpinMutex<T> {}\n\npub struct SpinMutexGuard<'a, T: 'a> {\n    mutex: &'a SpinMutex<T>,\n}\n\nimpl<'a, T> !Send for SpinMutexGuard<'a, T> {}\nunsafe impl<'a, T: Sync> Sync for SpinMutexGuard<'a, T> {}\n\nimpl<T> SpinMutex<T> {\n    pub const fn new(value: T) -> Self {\n        SpinMutex { value: UnsafeCell::new(value), lock: AtomicBool::new(false) }\n    }\n\n    #[inline(always)]\n    pub fn lock(&self) -> SpinMutexGuard<'_, T> {\n        loop {\n            match self.try_lock() {\n                None => {\n                    while self.lock.load(Ordering::Relaxed) {\n                        hint::spin_loop()\n                    }\n                }\n                Some(guard) => return guard,\n            }\n        }\n    }\n\n    #[inline(always)]\n    pub fn try_lock(&self) -> Option<SpinMutexGuard<'_, T>> {\n        if self.lock.compare_exchange(false, true, Ordering::Acquire, Ordering::Acquire).is_ok() {\n            Some(SpinMutexGuard { mutex: self })\n        } else {\n            None\n        }\n    }\n}\n\n/// Lock the Mutex or return false.\npub macro try_lock_or_false($e:expr) {\n    if let Some(v) = $e.try_lock() { v } else { return false }\n}\n\nimpl<'a, T> Deref for SpinMutexGuard<'a, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        unsafe { &*self.mutex.value.get() }\n    }\n}\n\nimpl<'a, T> DerefMut for SpinMutexGuard<'a, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        unsafe { &mut *self.mutex.value.get() }\n    }\n}\n\nimpl<'a, T> Drop for SpinMutexGuard<'a, T> {\n    fn drop(&mut self) {\n        self.mutex.lock.store(false, Ordering::Release)\n    }\n}\n"],["2436","use crate::ffi::OsStr;\nuse crate::path::Prefix;\n\n#[inline]\npub fn is_sep_byte(b: u8) -> bool {\n    b == b'/'\n}\n\n#[inline]\npub fn is_verbatim_sep(b: u8) -> bool {\n    b == b'/'\n}\n\npub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n    None\n}\n\npub const MAIN_SEP_STR: &str = \"/\";\npub const MAIN_SEP: char = '/';\n"],["2437","use crate::sys::mutex::Mutex;\nuse crate::time::Duration;\n\nuse super::waitqueue::{SpinMutex, WaitQueue, WaitVariable};\n\npub struct Condvar {\n    inner: SpinMutex<WaitVariable<()>>,\n}\n\npub type MovableCondvar = Box<Condvar>;\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        Condvar { inner: SpinMutex::new(WaitVariable::new(())) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {}\n\n    #[inline]\n    pub unsafe fn notify_one(&self) {\n        let _ = WaitQueue::notify_one(self.inner.lock());\n    }\n\n    #[inline]\n    pub unsafe fn notify_all(&self) {\n        let _ = WaitQueue::notify_all(self.inner.lock());\n    }\n\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n        let guard = self.inner.lock();\n        WaitQueue::wait(guard, || unsafe { mutex.unlock() });\n        unsafe { mutex.lock() }\n    }\n\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n        let success = WaitQueue::wait_timeout(&self.inner, dur, || unsafe { mutex.unlock() });\n        unsafe { mutex.lock() };\n        success\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n"],["2438","use super::mem;\nuse crate::slice::from_raw_parts;\n\nconst R_X86_64_RELATIVE: u32 = 8;\n\n#[repr(packed)]\nstruct Rela<T> {\n    offset: T,\n    info: T,\n    addend: T,\n}\n\npub fn relocate_elf_rela() {\n    extern \"C\" {\n        static RELA: u64;\n        static RELACOUNT: usize;\n    }\n\n    if unsafe { RELACOUNT } == 0 {\n        return;\n    } // unsafe ok: link-time constant\n\n    let relas = unsafe {\n        from_raw_parts::<Rela<u64>>(mem::rel_ptr(RELA), RELACOUNT) // unsafe ok: link-time constant\n    };\n    for rela in relas {\n        if rela.info != (/*0 << 32 |*/R_X86_64_RELATIVE as u64) {\n            rtabort!(\"Invalid relocation\");\n        }\n        unsafe { *mem::rel_ptr_mut::<*const ()>(rela.offset) = mem::rel_ptr(rela.addend) };\n    }\n}\n"],["2439","use super::usercalls::alloc::UserRef;\nuse crate::cmp;\nuse crate::io::{self, Write};\nuse crate::mem;\n\nextern \"C\" {\n    fn take_debug_panic_buf_ptr() -> *mut u8;\n    static DEBUG: u8;\n}\n\npub(crate) struct SgxPanicOutput(Option<&'static mut UserRef<[u8]>>);\n\nfn empty_user_slice() -> &'static mut UserRef<[u8]> {\n    unsafe { UserRef::from_raw_parts_mut(1 as *mut u8, 0) }\n}\n\nimpl SgxPanicOutput {\n    pub(crate) fn new() -> Option<Self> {\n        if unsafe { DEBUG == 0 } { None } else { Some(SgxPanicOutput(None)) }\n    }\n\n    fn init(&mut self) -> &mut &'static mut UserRef<[u8]> {\n        self.0.get_or_insert_with(|| unsafe {\n            let ptr = take_debug_panic_buf_ptr();\n            if ptr.is_null() { empty_user_slice() } else { UserRef::from_raw_parts_mut(ptr, 1024) }\n        })\n    }\n}\n\nimpl Write for SgxPanicOutput {\n    fn write(&mut self, src: &[u8]) -> io::Result<usize> {\n        let dst = mem::replace(self.init(), empty_user_slice());\n        let written = cmp::min(src.len(), dst.len());\n        dst[..written].copy_from_enclave(&src[..written]);\n        self.0 = Some(&mut dst[written..]);\n        Ok(written)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n"],["2440","#![allow(unused)]\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub use fortanix_sgx_abi::*;\n\nuse crate::num::NonZeroU64;\nuse crate::ptr::NonNull;\n\n#[repr(C)]\nstruct UsercallReturn(u64, u64);\n\nextern \"C\" {\n    fn usercall(nr: NonZeroU64, p1: u64, p2: u64, abort: u64, p3: u64, p4: u64) -> UsercallReturn;\n}\n\n/// Performs the raw usercall operation as defined in the ABI calling convention.\n///\n/// # Safety\n///\n/// The caller must ensure to pass parameters appropriate for the usercall `nr`\n/// and to observe all requirements specified in the ABI.\n///\n/// # Panics\n///\n/// Panics if `nr` is `0`.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n#[inline]\npub unsafe fn do_usercall(\n    nr: NonZeroU64,\n    p1: u64,\n    p2: u64,\n    p3: u64,\n    p4: u64,\n    abort: bool,\n) -> (u64, u64) {\n    let UsercallReturn(a, b) = unsafe { usercall(nr, p1, p2, abort as _, p3, p4) };\n    (a, b)\n}\n\ntype Register = u64;\n\ntrait RegisterArgument {\n    fn from_register(_: Register) -> Self;\n    fn into_register(self) -> Register;\n}\n\ntrait ReturnValue {\n    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self;\n}\n\nmacro_rules! define_usercalls {\n    ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:tt)*; )*) => {\n        /// Usercall numbers as per the ABI.\n        #[repr(u64)]\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n        #[allow(missing_docs, non_camel_case_types)]\n        #[non_exhaustive]\n        pub enum Usercalls {\n            #[doc(hidden)]\n            __enclave_usercalls_invalid = 0,\n            $($f,)*\n        }\n\n        $(enclave_usercalls_internal_define_usercalls!(def fn $f($($n: $t),*) $(-> $r)*);)*\n    };\n}\n\nmacro_rules! define_ra {\n    (< $i:ident > $t:ty) => {\n        impl<$i> RegisterArgument for $t {\n            fn from_register(a: Register) -> Self {\n                a as _\n            }\n            fn into_register(self) -> Register {\n                self as _\n            }\n        }\n    };\n    ($i:ty as $t:ty) => {\n        impl RegisterArgument for $t {\n            fn from_register(a: Register) -> Self {\n                a as $i as _\n            }\n            fn into_register(self) -> Register {\n                self as $i as _\n            }\n        }\n    };\n    ($t:ty) => {\n        impl RegisterArgument for $t {\n            fn from_register(a: Register) -> Self {\n                a as _\n            }\n            fn into_register(self) -> Register {\n                self as _\n            }\n        }\n    };\n}\n\ndefine_ra!(Register);\ndefine_ra!(i64);\ndefine_ra!(u32);\ndefine_ra!(u32 as i32);\ndefine_ra!(u16);\ndefine_ra!(u16 as i16);\ndefine_ra!(u8);\ndefine_ra!(u8 as i8);\ndefine_ra!(usize);\ndefine_ra!(usize as isize);\ndefine_ra!(<T> *const T);\ndefine_ra!(<T> *mut T);\n\nimpl RegisterArgument for bool {\n    fn from_register(a: Register) -> bool {\n        if a != 0 { true } else { false }\n    }\n    fn into_register(self) -> Register {\n        self as _\n    }\n}\n\nimpl<T: RegisterArgument> RegisterArgument for Option<NonNull<T>> {\n    fn from_register(a: Register) -> Option<NonNull<T>> {\n        NonNull::new(a as _)\n    }\n    fn into_register(self) -> Register {\n        self.map_or(0 as _, NonNull::as_ptr) as _\n    }\n}\n\nimpl ReturnValue for ! {\n    fn from_registers(call: &'static str, _regs: (Register, Register)) -> Self {\n        rtabort!(\"Usercall {}: did not expect to be re-entered\", call);\n    }\n}\n\nimpl ReturnValue for () {\n    fn from_registers(call: &'static str, usercall_retval: (Register, Register)) -> Self {\n        rtassert!(usercall_retval.0 == 0);\n        rtassert!(usercall_retval.1 == 0);\n        ()\n    }\n}\n\nimpl<T: RegisterArgument> ReturnValue for T {\n    fn from_registers(call: &'static str, usercall_retval: (Register, Register)) -> Self {\n        rtassert!(usercall_retval.1 == 0);\n        T::from_register(usercall_retval.0)\n    }\n}\n\nimpl<T: RegisterArgument, U: RegisterArgument> ReturnValue for (T, U) {\n    fn from_registers(_call: &'static str, regs: (Register, Register)) -> Self {\n        (T::from_register(regs.0), U::from_register(regs.1))\n    }\n}\n\nmacro_rules! return_type_is_abort {\n    (!) => {\n        true\n    };\n    ($r:ty) => {\n        false\n    };\n}\n\n// In this macro: using `$r:tt` because `$r:ty` doesn't match ! in `return_type_is_abort`\nmacro_rules! enclave_usercalls_internal_define_usercalls {\n    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty,\n                     $n3:ident: $t3:ty, $n4:ident: $t4:ty) -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    RegisterArgument::into_register($n1),\n                    RegisterArgument::into_register($n2),\n                    RegisterArgument::into_register($n3),\n                    RegisterArgument::into_register($n4),\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty, $n3:ident: $t3:ty) -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    RegisterArgument::into_register($n1),\n                    RegisterArgument::into_register($n2),\n                    RegisterArgument::into_register($n3),\n                    0,\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty) -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    RegisterArgument::into_register($n1),\n                    RegisterArgument::into_register($n2),\n                    0,0,\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident($n1:ident: $t1:ty) -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f($n1: $t1) -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    RegisterArgument::into_register($n1),\n                    0,0,0,\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident() -> $r:tt) => (\n        /// This is the raw function definition, see the ABI documentation for\n        /// more information.\n        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n        #[inline(always)]\n        pub unsafe fn $f() -> $r {\n            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                    0,0,0,0,\n                    return_type_is_abort!($r)\n            ) })\n        }\n    );\n    (def fn $f:ident($($n:ident: $t:ty),*)) => (\n        enclave_usercalls_internal_define_usercalls!(def fn $f($($n: $t),*) -> ());\n    );\n}\n\ninvoke_with_usercalls!(define_usercalls);\n"],["2441","use crate::cmp;\nuse crate::convert::TryFrom;\nuse crate::io::{Error as IoError, ErrorKind, IoSlice, IoSliceMut, Result as IoResult};\nuse crate::sys::rand::rdrand64;\nuse crate::time::{Duration, Instant};\n\npub(crate) mod alloc;\n#[macro_use]\npub(crate) mod raw;\n\nuse self::raw::*;\n\n/// Usercall `read`. See the ABI documentation for more information.\n///\n/// This will do a single `read` usercall and scatter the read data among\n/// `bufs`. To read to a single buffer, just pass a slice of length one.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn read(fd: Fd, bufs: &mut [IoSliceMut<'_>]) -> IoResult<usize> {\n    unsafe {\n        let total_len = bufs.iter().fold(0usize, |sum, buf| sum.saturating_add(buf.len()));\n        let mut userbuf = alloc::User::<[u8]>::uninitialized(total_len);\n        let ret_len = raw::read(fd, userbuf.as_mut_ptr(), userbuf.len()).from_sgx_result()?;\n        let userbuf = &userbuf[..ret_len];\n        let mut index = 0;\n        for buf in bufs {\n            let end = cmp::min(index + buf.len(), userbuf.len());\n            if let Some(buflen) = end.checked_sub(index) {\n                userbuf[index..end].copy_to_enclave(&mut buf[..buflen]);\n                index += buf.len();\n            } else {\n                break;\n            }\n        }\n        Ok(userbuf.len())\n    }\n}\n\n/// Usercall `read_alloc`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn read_alloc(fd: Fd) -> IoResult<Vec<u8>> {\n    unsafe {\n        let userbuf = ByteBuffer { data: crate::ptr::null_mut(), len: 0 };\n        let mut userbuf = alloc::User::new_from_enclave(&userbuf);\n        raw::read_alloc(fd, userbuf.as_raw_mut_ptr()).from_sgx_result()?;\n        Ok(userbuf.copy_user_buffer())\n    }\n}\n\n/// Usercall `write`. See the ABI documentation for more information.\n///\n/// This will do a single `write` usercall and gather the written data from\n/// `bufs`. To write from a single buffer, just pass a slice of length one.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn write(fd: Fd, bufs: &[IoSlice<'_>]) -> IoResult<usize> {\n    unsafe {\n        let total_len = bufs.iter().fold(0usize, |sum, buf| sum.saturating_add(buf.len()));\n        let mut userbuf = alloc::User::<[u8]>::uninitialized(total_len);\n        let mut index = 0;\n        for buf in bufs {\n            let end = cmp::min(index + buf.len(), userbuf.len());\n            if let Some(buflen) = end.checked_sub(index) {\n                userbuf[index..end].copy_from_enclave(&buf[..buflen]);\n                index += buf.len();\n            } else {\n                break;\n            }\n        }\n        raw::write(fd, userbuf.as_ptr(), userbuf.len()).from_sgx_result()\n    }\n}\n\n/// Usercall `flush`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn flush(fd: Fd) -> IoResult<()> {\n    unsafe { raw::flush(fd).from_sgx_result() }\n}\n\n/// Usercall `close`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn close(fd: Fd) {\n    unsafe { raw::close(fd) }\n}\n\nfn string_from_bytebuffer(buf: &alloc::UserRef<ByteBuffer>, usercall: &str, arg: &str) -> String {\n    String::from_utf8(buf.copy_user_buffer())\n        .unwrap_or_else(|_| rtabort!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n}\n\n/// Usercall `bind_stream`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n    unsafe {\n        let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n        let mut local = alloc::User::<ByteBuffer>::uninitialized();\n        let fd = raw::bind_stream(addr_user.as_ptr(), addr_user.len(), local.as_raw_mut_ptr())\n            .from_sgx_result()?;\n        let local = string_from_bytebuffer(&local, \"bind_stream\", \"local_addr\");\n        Ok((fd, local))\n    }\n}\n\n/// Usercall `accept_stream`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n    unsafe {\n        let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n        let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n        // without forcing coercion?\n        let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n        let fd = raw::accept_stream(fd, local.as_raw_mut_ptr(), peer.as_raw_mut_ptr())\n            .from_sgx_result()?;\n        let local = string_from_bytebuffer(&local, \"accept_stream\", \"local_addr\");\n        let peer = string_from_bytebuffer(&peer, \"accept_stream\", \"peer_addr\");\n        Ok((fd, local, peer))\n    }\n}\n\n/// Usercall `connect_stream`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n    unsafe {\n        let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n        let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n        let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n        // without forcing coercion?\n        let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n        let fd = raw::connect_stream(\n            addr_user.as_ptr(),\n            addr_user.len(),\n            local.as_raw_mut_ptr(),\n            peer.as_raw_mut_ptr(),\n        )\n        .from_sgx_result()?;\n        let local = string_from_bytebuffer(&local, \"connect_stream\", \"local_addr\");\n        let peer = string_from_bytebuffer(&peer, \"connect_stream\", \"peer_addr\");\n        Ok((fd, local, peer))\n    }\n}\n\n/// Usercall `launch_thread`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub unsafe fn launch_thread() -> IoResult<()> {\n    // SAFETY: The caller must uphold the safety contract for `launch_thread`.\n    unsafe { raw::launch_thread().from_sgx_result() }\n}\n\n/// Usercall `exit`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn exit(panic: bool) -> ! {\n    unsafe { raw::exit(panic) }\n}\n\n/// Usercall `wait`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn wait(event_mask: u64, mut timeout: u64) -> IoResult<u64> {\n    if timeout != WAIT_NO && timeout != WAIT_INDEFINITE {\n        // We don't want people to rely on accuracy of timeouts to make\n        // security decisions in an SGX enclave. That's why we add a random\n        // amount not exceeding +/- 10% to the timeout value to discourage\n        // people from relying on accuracy of timeouts while providing a way\n        // to make things work in other cases. Note that in the SGX threat\n        // model the enclave runner which is serving the wait usercall is not\n        // trusted to ensure accurate timeouts.\n        if let Ok(timeout_signed) = i64::try_from(timeout) {\n            let tenth = timeout_signed / 10;\n            let deviation = (rdrand64() as i64).checked_rem(tenth).unwrap_or(0);\n            timeout = timeout_signed.saturating_add(deviation) as _;\n        }\n    }\n    unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n}\n\n/// This function makes an effort to wait for a non-spurious event at least as\n/// long as `duration`. Note that in general there is no guarantee about accuracy\n/// of time and timeouts in SGX model. The enclave runner serving usercalls may\n/// lie about current time and/or ignore timeout values.\n///\n/// Once the event is observed, `should_wake_up` will be used to determine\n/// whether or not the event was spurious.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn wait_timeout<F>(event_mask: u64, duration: Duration, should_wake_up: F)\nwhere\n    F: Fn() -> bool,\n{\n    // Calls the wait usercall and checks the result. Returns true if event was\n    // returned, and false if WouldBlock/TimedOut was returned.\n    // If duration is None, it will use WAIT_NO.\n    fn wait_checked(event_mask: u64, duration: Option<Duration>) -> bool {\n        let timeout = duration.map_or(raw::WAIT_NO, |duration| {\n            cmp::min((u64::MAX - 1) as u128, duration.as_nanos()) as u64\n        });\n        match wait(event_mask, timeout) {\n            Ok(eventset) => {\n                if event_mask == 0 {\n                    rtabort!(\"expected wait() to return Err, found Ok.\");\n                }\n                rtassert!(eventset != 0 && eventset & !event_mask == 0);\n                true\n            }\n            Err(e) => {\n                rtassert!(e.kind() == ErrorKind::TimedOut || e.kind() == ErrorKind::WouldBlock);\n                false\n            }\n        }\n    }\n\n    match wait_checked(event_mask, Some(duration)) {\n        false => return,                    // timed out\n        true if should_wake_up() => return, // woken up\n        true => {}                          // spurious event\n    }\n\n    // Drain all cached events.\n    // Note that `event_mask != 0` is implied if we get here.\n    loop {\n        match wait_checked(event_mask, None) {\n            false => break,                     // no more cached events\n            true if should_wake_up() => return, // woken up\n            true => {}                          // spurious event\n        }\n    }\n\n    // Continue waiting, but take note of time spent waiting so we don't wait\n    // forever. We intentionally don't call `Instant::now()` before this point\n    // to avoid the cost of the `insecure_time` usercall in case there are no\n    // spurious wakeups.\n\n    let start = Instant::now();\n    let mut remaining = duration;\n    loop {\n        match wait_checked(event_mask, Some(remaining)) {\n            false => return,                    // timed out\n            true if should_wake_up() => return, // woken up\n            true => {}                          // spurious event\n        }\n        remaining = match duration.checked_sub(start.elapsed()) {\n            Some(remaining) => remaining,\n            None => break,\n        }\n    }\n}\n\n/// Usercall `send`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {\n    unsafe { raw::send(event_set, tcs).from_sgx_result() }\n}\n\n/// Usercall `insecure_time`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn insecure_time() -> Duration {\n    let t = unsafe { raw::insecure_time() };\n    Duration::new(t / 1_000_000_000, (t % 1_000_000_000) as _)\n}\n\n/// Usercall `alloc`. See the ABI documentation for more information.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn alloc(size: usize, alignment: usize) -> IoResult<*mut u8> {\n    unsafe { raw::alloc(size, alignment).from_sgx_result() }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n#[doc(inline)]\npub use self::raw::free;\n\nfn check_os_error(err: Result) -> i32 {\n    // FIXME: not sure how to make sure all variants of Error are covered\n    if err == Error::NotFound as _\n        || err == Error::PermissionDenied as _\n        || err == Error::ConnectionRefused as _\n        || err == Error::ConnectionReset as _\n        || err == Error::ConnectionAborted as _\n        || err == Error::NotConnected as _\n        || err == Error::AddrInUse as _\n        || err == Error::AddrNotAvailable as _\n        || err == Error::BrokenPipe as _\n        || err == Error::AlreadyExists as _\n        || err == Error::WouldBlock as _\n        || err == Error::InvalidInput as _\n        || err == Error::InvalidData as _\n        || err == Error::TimedOut as _\n        || err == Error::WriteZero as _\n        || err == Error::Interrupted as _\n        || err == Error::Other as _\n        || err == Error::UnexpectedEof as _\n        || ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&err)\n    {\n        err\n    } else {\n        rtabort!(\"Usercall: returned invalid error value {}\", err)\n    }\n}\n\ntrait FromSgxResult {\n    type Return;\n\n    fn from_sgx_result(self) -> IoResult<Self::Return>;\n}\n\nimpl<T> FromSgxResult for (Result, T) {\n    type Return = T;\n\n    fn from_sgx_result(self) -> IoResult<Self::Return> {\n        if self.0 == RESULT_SUCCESS {\n            Ok(self.1)\n        } else {\n            Err(IoError::from_raw_os_error(check_os_error(self.0)))\n        }\n    }\n}\n\nimpl FromSgxResult for Result {\n    type Return = ();\n\n    fn from_sgx_result(self) -> IoResult<Self::Return> {\n        if self == RESULT_SUCCESS {\n            Ok(())\n        } else {\n            Err(IoError::from_raw_os_error(check_os_error(self)))\n        }\n    }\n}\n"],["2442","#![allow(unused)]\n\nuse crate::cell::UnsafeCell;\nuse crate::mem;\nuse crate::ops::{CoerceUnsized, Deref, DerefMut, Index, IndexMut};\nuse crate::ptr::{self, NonNull};\nuse crate::slice;\nuse crate::slice::SliceIndex;\n\nuse super::super::mem::is_user_range;\nuse fortanix_sgx_abi::*;\n\n/// A type that can be safely read from or written to userspace.\n///\n/// Non-exhaustive list of specific requirements for reading and writing:\n/// * **Type is `Copy`** (and therefore also not `Drop`). Copies will be\n///   created when copying from/to userspace. Destructors will not be called.\n/// * **No references or Rust-style owned pointers** (`Vec`, `Arc`, etc.). When\n///   reading from userspace, references into enclave memory must not be\n///   created. Also, only enclave memory is considered managed by the Rust\n///   compiler's static analysis. When reading from userspace, there can be no\n///   guarantee that the value correctly adheres to the expectations of the\n///   type. When writing to userspace, memory addresses of data in enclave\n///   memory must not be leaked for confidentiality reasons. `User` and\n///   `UserRef` are also not allowed for the same reasons.\n/// * **No fat pointers.** When reading from userspace, the size or vtable\n///   pointer could be automatically interpreted and used by the code. When\n///   writing to userspace, memory addresses of data in enclave memory (such\n///   as vtable pointers) must not be leaked for confidentiality reasons.\n///\n/// Non-exhaustive list of specific requirements for reading from userspace:\n/// * **Any bit pattern is valid** for this type (no `enum`s). There can be no\n///   guarantee that the value correctly adheres to the expectations of the\n///   type, so any value must be valid for this type.\n///\n/// Non-exhaustive list of specific requirements for writing to userspace:\n/// * **No pointers to enclave memory.** Memory addresses of data in enclave\n///   memory must not be leaked for confidentiality reasons.\n/// * **No internal padding.** Padding might contain previously-initialized\n///   secret data stored at that memory location and must not be leaked for\n///   confidentiality reasons.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub unsafe trait UserSafeSized: Copy + Sized {}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl UserSafeSized for u8 {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl<T> UserSafeSized for FifoDescriptor<T> {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl UserSafeSized for ByteBuffer {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl UserSafeSized for Usercall {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl UserSafeSized for Return {}\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl<T: UserSafeSized> UserSafeSized for [T; 2] {}\n\n/// A type that can be represented in memory as one or more `UserSafeSized`s.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub unsafe trait UserSafe {\n    /// Equivalent to `mem::align_of::<Self>`.\n    fn align_of() -> usize;\n\n    /// Construct a pointer to `Self` given a memory range in user space.\n    ///\n    /// N.B., this takes a size, not a length!\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure the memory range is in user memory, is the\n    /// correct size and is correctly aligned and points to the right type.\n    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self;\n\n    /// Construct a pointer to `Self` given a memory range.\n    ///\n    /// N.B., this takes a size, not a length!\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure the memory range points to the correct type.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if:\n    ///\n    /// * the pointer is not aligned.\n    /// * the pointer is null.\n    /// * the pointed-to range does not fit in the address space.\n    /// * the pointed-to range is not in user memory.\n    unsafe fn from_raw_sized(ptr: *mut u8, size: usize) -> NonNull<Self> {\n        assert!(ptr.wrapping_add(size) >= ptr);\n        // SAFETY: The caller has guaranteed the pointer is valid\n        let ret = unsafe { Self::from_raw_sized_unchecked(ptr, size) };\n        unsafe {\n            Self::check_ptr(ret);\n            NonNull::new_unchecked(ret as _)\n        }\n    }\n\n    /// Checks if a pointer may point to `Self` in user memory.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure the memory range points to the correct type and\n    /// length (if this is a slice).\n    ///\n    /// # Panics\n    ///\n    /// This function panics if:\n    ///\n    /// * the pointer is not aligned.\n    /// * the pointer is null.\n    /// * the pointed-to range is not in user memory.\n    unsafe fn check_ptr(ptr: *const Self) {\n        let is_aligned = |p| -> bool { 0 == (p as usize) & (Self::align_of() - 1) };\n\n        assert!(is_aligned(ptr as *const u8));\n        assert!(is_user_range(ptr as _, mem::size_of_val(unsafe { &*ptr })));\n        assert!(!ptr.is_null());\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl<T: UserSafeSized> UserSafe for T {\n    fn align_of() -> usize {\n        mem::align_of::<T>()\n    }\n\n    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self {\n        assert_eq!(size, mem::size_of::<T>());\n        ptr as _\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nunsafe impl<T: UserSafeSized> UserSafe for [T] {\n    fn align_of() -> usize {\n        mem::align_of::<T>()\n    }\n\n    /// # Safety\n    /// Behavior is undefined if any of these conditions are violated:\n    /// * `ptr` must be [valid] for writes of `size` many bytes, and it must be\n    ///   properly aligned.\n    ///\n    /// [valid]: core::ptr#safety\n    /// # Panics\n    ///\n    /// This function panics if:\n    ///\n    /// * the element size is not a factor of the size\n    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self {\n        let elem_size = mem::size_of::<T>();\n        assert_eq!(size % elem_size, 0);\n        let len = size / elem_size;\n        // SAFETY: The caller must uphold the safety contract for `from_raw_sized_unchecked`\n        unsafe { slice::from_raw_parts_mut(ptr as _, len) }\n    }\n}\n\n/// A reference to some type in userspace memory. `&UserRef<T>` is equivalent\n/// to `&T` in enclave memory. Access to the memory is only allowed by copying\n/// to avoid TOCTTOU issues. After copying, code should make sure to completely\n/// check the value before use.\n///\n/// It is also possible to obtain a mutable reference `&mut UserRef<T>`. Unlike\n/// regular mutable references, these are not exclusive. Userspace may always\n/// write to the backing memory at any time, so it can't be assumed that there\n/// the pointed-to memory is uniquely borrowed. The two different reference types\n/// are used solely to indicate intent: a mutable reference is for writing to\n/// user memory, an immutable reference for reading from user memory.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub struct UserRef<T: ?Sized>(UnsafeCell<T>);\n/// An owned type in userspace memory. `User<T>` is equivalent to `Box<T>` in\n/// enclave memory. Access to the memory is only allowed by copying to avoid\n/// TOCTTOU issues. The user memory will be freed when the value is dropped.\n/// After copying, code should make sure to completely check the value before\n/// use.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub struct User<T: UserSafe + ?Sized>(NonNull<UserRef<T>>);\n\ntrait NewUserRef<T: ?Sized> {\n    unsafe fn new_userref(v: T) -> Self;\n}\n\nimpl<T: ?Sized> NewUserRef<*mut T> for NonNull<UserRef<T>> {\n    unsafe fn new_userref(v: *mut T) -> Self {\n        // SAFETY: The caller has guaranteed the pointer is valid\n        unsafe { NonNull::new_unchecked(v as _) }\n    }\n}\n\nimpl<T: ?Sized> NewUserRef<NonNull<T>> for NonNull<UserRef<T>> {\n    unsafe fn new_userref(v: NonNull<T>) -> Self {\n        // SAFETY: The caller has guaranteed the pointer is valid\n        unsafe { NonNull::new_userref(v.as_ptr()) }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> User<T>\nwhere\n    T: UserSafe,\n{\n    // This function returns memory that is practically uninitialized, but is\n    // not considered \"unspecified\" or \"undefined\" for purposes of an\n    // optimizing compiler. This is achieved by returning a pointer from\n    // from outside as obtained by `super::alloc`.\n    fn new_uninit_bytes(size: usize) -> Self {\n        unsafe {\n            // Mustn't call alloc with size 0.\n            let ptr = if size > 0 {\n                rtunwrap!(Ok, super::alloc(size, T::align_of())) as _\n            } else {\n                T::align_of() as _ // dangling pointer ok for size 0\n            };\n            if let Ok(v) = crate::panic::catch_unwind(|| T::from_raw_sized(ptr, size)) {\n                User(NonNull::new_userref(v))\n            } else {\n                rtabort!(\"Got invalid pointer from alloc() usercall\")\n            }\n        }\n    }\n\n    /// Copies `val` into freshly allocated space in user memory.\n    pub fn new_from_enclave(val: &T) -> Self {\n        unsafe {\n            let ret = Self::new_uninit_bytes(mem::size_of_val(val));\n            ptr::copy(\n                val as *const T as *const u8,\n                ret.0.as_ptr() as *mut u8,\n                mem::size_of_val(val),\n            );\n            ret\n        }\n    }\n\n    /// Creates an owned `User<T>` from a raw pointer.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `T`, is freeable with the `free`\n    /// usercall and the alignment of `T`, and is uniquely owned.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n        // SAFETY: the caller must uphold the safety contract for `from_raw`.\n        unsafe { T::check_ptr(ptr) };\n        User(unsafe { NonNull::new_userref(ptr) })\n    }\n\n    /// Converts this value into a raw pointer. The value will no longer be\n    /// automatically freed.\n    pub fn into_raw(self) -> *mut T {\n        let ret = self.0;\n        mem::forget(self);\n        ret.as_ptr() as _\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T> User<T>\nwhere\n    T: UserSafe,\n{\n    /// Allocate space for `T` in user memory.\n    pub fn uninitialized() -> Self {\n        Self::new_uninit_bytes(mem::size_of::<T>())\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T> User<[T]>\nwhere\n    [T]: UserSafe,\n{\n    /// Allocate space for a `[T]` of `n` elements in user memory.\n    pub fn uninitialized(n: usize) -> Self {\n        Self::new_uninit_bytes(n * mem::size_of::<T>())\n    }\n\n    /// Creates an owned `User<[T]>` from a raw thin pointer and a slice length.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `len` elements of `T`, is\n    /// freeable with the `free` usercall and the alignment of `T`, and is\n    /// uniquely owned.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range does not fit in the address space\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self {\n        User(unsafe {\n            NonNull::new_userref(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()))\n        })\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> UserRef<T>\nwhere\n    T: UserSafe,\n{\n    /// Creates a `&UserRef<[T]>` from a raw pointer.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `T`.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_ptr<'a>(ptr: *const T) -> &'a Self {\n        // SAFETY: The caller must uphold the safety contract for `from_ptr`.\n        unsafe { T::check_ptr(ptr) };\n        unsafe { &*(ptr as *const Self) }\n    }\n\n    /// Creates a `&mut UserRef<[T]>` from a raw pointer. See the struct\n    /// documentation for the nuances regarding a `&mut UserRef<T>`.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `T`.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_mut_ptr<'a>(ptr: *mut T) -> &'a mut Self {\n        // SAFETY: The caller must uphold the safety contract for `from_mut_ptr`.\n        unsafe { T::check_ptr(ptr) };\n        unsafe { &mut *(ptr as *mut Self) }\n    }\n\n    /// Copies `val` into user memory.\n    ///\n    /// # Panics\n    /// This function panics if the destination doesn't have the same size as\n    /// the source. This can happen for dynamically-sized types such as slices.\n    pub fn copy_from_enclave(&mut self, val: &T) {\n        unsafe {\n            assert_eq!(mem::size_of_val(val), mem::size_of_val(&*self.0.get()));\n            ptr::copy(\n                val as *const T as *const u8,\n                self.0.get() as *mut T as *mut u8,\n                mem::size_of_val(val),\n            );\n        }\n    }\n\n    /// Copies the value from user memory and place it into `dest`.\n    ///\n    /// # Panics\n    /// This function panics if the destination doesn't have the same size as\n    /// the source. This can happen for dynamically-sized types such as slices.\n    pub fn copy_to_enclave(&self, dest: &mut T) {\n        unsafe {\n            assert_eq!(mem::size_of_val(dest), mem::size_of_val(&*self.0.get()));\n            ptr::copy(\n                self.0.get() as *const T as *const u8,\n                dest as *mut T as *mut u8,\n                mem::size_of_val(dest),\n            );\n        }\n    }\n\n    /// Obtain a raw pointer from this reference.\n    pub fn as_raw_ptr(&self) -> *const T {\n        self as *const _ as _\n    }\n\n    /// Obtain a raw pointer from this reference.\n    pub fn as_raw_mut_ptr(&mut self) -> *mut T {\n        self as *mut _ as _\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T> UserRef<T>\nwhere\n    T: UserSafe,\n{\n    /// Copies the value from user memory into enclave memory.\n    pub fn to_enclave(&self) -> T {\n        unsafe { ptr::read(self.0.get()) }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T> UserRef<[T]>\nwhere\n    [T]: UserSafe,\n{\n    /// Creates a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `n` elements of `T`.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range does not fit in the address space\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_raw_parts<'a>(ptr: *const T, len: usize) -> &'a Self {\n        // SAFETY: The caller must uphold the safety contract for `from_raw_parts`.\n        unsafe {\n            &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *const Self)\n        }\n    }\n\n    /// Creates a `&mut UserRef<[T]>` from a raw thin pointer and a slice length.\n    /// See the struct documentation for the nuances regarding a\n    /// `&mut UserRef<T>`.\n    ///\n    /// # Safety\n    /// The caller must ensure `ptr` points to `n` elements of `T`.\n    ///\n    /// # Panics\n    /// This function panics if:\n    ///\n    /// * The pointer is not aligned\n    /// * The pointer is null\n    /// * The pointed-to range does not fit in the address space\n    /// * The pointed-to range is not in user memory\n    pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n        // SAFETY: The caller must uphold the safety contract for `from_raw_parts_mut`.\n        unsafe {\n            &mut *(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n        }\n    }\n\n    /// Obtain a raw pointer to the first element of this user slice.\n    pub fn as_ptr(&self) -> *const T {\n        self.0.get() as _\n    }\n\n    /// Obtain a raw pointer to the first element of this user slice.\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n        self.0.get() as _\n    }\n\n    /// Obtain the number of elements in this user slice.\n    pub fn len(&self) -> usize {\n        unsafe { (*self.0.get()).len() }\n    }\n\n    /// Copies the value from user memory and place it into `dest`. Afterwards,\n    /// `dest` will contain exactly `self.len()` elements.\n    ///\n    /// # Panics\n    /// This function panics if the destination doesn't have the same size as\n    /// the source. This can happen for dynamically-sized types such as slices.\n    pub fn copy_to_enclave_vec(&self, dest: &mut Vec<T>) {\n        if let Some(missing) = self.len().checked_sub(dest.capacity()) {\n            dest.reserve(missing)\n        }\n        // SAFETY: We reserve enough space above.\n        unsafe { dest.set_len(self.len()) };\n        self.copy_to_enclave(&mut dest[..]);\n    }\n\n    /// Copies the value from user memory into a vector in enclave memory.\n    pub fn to_enclave(&self) -> Vec<T> {\n        let mut ret = Vec::with_capacity(self.len());\n        self.copy_to_enclave_vec(&mut ret);\n        ret\n    }\n\n    /// Returns an iterator over the slice.\n    pub fn iter(&self) -> Iter<'_, T>\n    where\n        T: UserSafe, // FIXME: should be implied by [T]: UserSafe?\n    {\n        unsafe { Iter((&*self.as_raw_ptr()).iter()) }\n    }\n\n    /// Returns an iterator that allows modifying each value.\n    pub fn iter_mut(&mut self) -> IterMut<'_, T>\n    where\n        T: UserSafe, // FIXME: should be implied by [T]: UserSafe?\n    {\n        unsafe { IterMut((&mut *self.as_raw_mut_ptr()).iter_mut()) }\n    }\n}\n\n/// Immutable user slice iterator\n///\n/// This struct is created by the `iter` method on `UserRef<[T]>`.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub struct Iter<'a, T: 'a + UserSafe>(slice::Iter<'a, T>);\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n    type Item = &'a UserRef<T>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe { self.0.next().map(|e| UserRef::from_ptr(e)) }\n    }\n}\n\n/// Mutable user slice iterator\n///\n/// This struct is created by the `iter_mut` method on `UserRef<[T]>`.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub struct IterMut<'a, T: 'a + UserSafe>(slice::IterMut<'a, T>);\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n    type Item = &'a mut UserRef<T>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe { self.0.next().map(|e| UserRef::from_mut_ptr(e)) }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> Deref for User<T>\nwhere\n    T: UserSafe,\n{\n    type Target = UserRef<T>;\n\n    fn deref(&self) -> &Self::Target {\n        unsafe { &*self.0.as_ptr() }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> DerefMut for User<T>\nwhere\n    T: UserSafe,\n{\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        unsafe { &mut *self.0.as_ptr() }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: ?Sized> Drop for User<T>\nwhere\n    T: UserSafe,\n{\n    fn drop(&mut self) {\n        unsafe {\n            let ptr = (*self.0.as_ptr()).0.get();\n            super::free(ptr as _, mem::size_of_val(&mut *ptr), T::align_of());\n        }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T: CoerceUnsized<U>, U> CoerceUnsized<UserRef<U>> for UserRef<T> {}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T, I> Index<I> for UserRef<[T]>\nwhere\n    [T]: UserSafe,\n    I: SliceIndex<[T], Output: UserSafe>,\n{\n    type Output = UserRef<I::Output>;\n\n    #[inline]\n    fn index(&self, index: I) -> &UserRef<I::Output> {\n        unsafe {\n            if let Some(slice) = index.get(&*self.as_raw_ptr()) {\n                UserRef::from_ptr(slice)\n            } else {\n                rtabort!(\"index out of range for user slice\");\n            }\n        }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl<T, I> IndexMut<I> for UserRef<[T]>\nwhere\n    [T]: UserSafe,\n    I: SliceIndex<[T], Output: UserSafe>,\n{\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n        unsafe {\n            if let Some(slice) = index.get_mut(&mut *self.as_raw_mut_ptr()) {\n                UserRef::from_mut_ptr(slice)\n            } else {\n                rtabort!(\"index out of range for user slice\");\n            }\n        }\n    }\n}\n\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\nimpl UserRef<super::raw::ByteBuffer> {\n    /// Copies the user memory range pointed to by the user `ByteBuffer` to\n    /// enclave memory.\n    ///\n    /// # Panics\n    /// This function panics if, in the user `ByteBuffer`:\n    ///\n    /// * The pointer is null\n    /// * The pointed-to range does not fit in the address space\n    /// * The pointed-to range is not in user memory\n    pub fn copy_user_buffer(&self) -> Vec<u8> {\n        unsafe {\n            let buf = self.to_enclave();\n            if buf.len > 0 {\n                User::from_raw_parts(buf.data as _, buf.len).to_enclave()\n            } else {\n                // Mustn't look at `data` or call `free` if `len` is `0`.\n                Vec::with_capacity(0)\n            }\n        }\n    }\n}\n"],["2443","use fortanix_sgx_abi::Tcs;\n\n/// Gets the ID for the current thread. The ID is guaranteed to be unique among\n/// all currently running threads in the enclave, and it is guaranteed to be\n/// constant for the lifetime of the thread. More specifically for SGX, there\n/// is a one-to-one correspondence of the ID to the address of the TCS.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn current() -> Tcs {\n    extern \"C\" {\n        fn get_tcs_addr() -> Tcs;\n    }\n    unsafe { get_tcs_addr() }\n}\n"],["2444","#![cfg_attr(test, allow(unused))] // RT initialization logic is not compiled for test\n\nuse crate::io::Write;\nuse core::sync::atomic::{AtomicUsize, Ordering};\n\n// runtime features\npub(super) mod panic;\nmod reloc;\n\n// library features\npub mod mem;\npub mod thread;\npub mod tls;\n#[macro_use]\npub mod usercalls;\n\n#[cfg(not(test))]\nglobal_asm!(include_str!(\"entry.S\"), options(att_syntax));\n\n#[repr(C)]\nstruct EntryReturn(u64, u64);\n\n#[cfg(not(test))]\n#[no_mangle]\nunsafe extern \"C\" fn tcs_init(secondary: bool) {\n    // Be very careful when changing this code: it runs before the binary has been\n    // relocated. Any indirect accesses to symbols will likely fail.\n    const UNINIT: usize = 0;\n    const BUSY: usize = 1;\n    const DONE: usize = 2;\n    // Three-state spin-lock\n    static RELOC_STATE: AtomicUsize = AtomicUsize::new(UNINIT);\n\n    if secondary && RELOC_STATE.load(Ordering::Relaxed) != DONE {\n        rtabort!(\"Entered secondary TCS before main TCS!\")\n    }\n\n    // Try to atomically swap UNINIT with BUSY. The returned state can be:\n    match RELOC_STATE.compare_exchange(UNINIT, BUSY, Ordering::Acquire, Ordering::Acquire) {\n        // This thread just obtained the lock and other threads will observe BUSY\n        Ok(_) => {\n            reloc::relocate_elf_rela();\n            RELOC_STATE.store(DONE, Ordering::Release);\n        }\n        // We need to wait until the initialization is done.\n        Err(BUSY) => {\n            while RELOC_STATE.load(Ordering::Acquire) == BUSY {\n                core::hint::spin_loop();\n            }\n        }\n        // Initialization is done.\n        Err(DONE) => {}\n        _ => unreachable!(),\n    }\n}\n\n// FIXME: this item should only exist if this is linked into an executable\n// (main function exists). If this is a library, the crate author should be\n// able to specify this\n#[cfg(not(test))]\n#[no_mangle]\nextern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> EntryReturn {\n    // FIXME: how to support TLS in library mode?\n    let tls = Box::new(tls::Tls::new());\n    let tls_guard = unsafe { tls.activate() };\n\n    if secondary {\n        let join_notifier = super::thread::Thread::entry();\n        drop(tls_guard);\n        drop(join_notifier);\n\n        EntryReturn(0, 0)\n    } else {\n        extern \"C\" {\n            fn main(argc: isize, argv: *const *const u8) -> isize;\n        }\n\n        // check entry is being called according to ABI\n        rtassert!(p3 == 0);\n        rtassert!(p4 == 0);\n        rtassert!(p5 == 0);\n\n        unsafe {\n            // The actual types of these arguments are `p1: *const Arg, p2:\n            // usize`. We can't currently customize the argument list of Rust's\n            // main function, so we pass these in as the standard pointer-sized\n            // values in `argc` and `argv`.\n            let ret = main(p2 as _, p1 as _);\n            exit_with_code(ret)\n        }\n    }\n}\n\npub(super) fn exit_with_code(code: isize) -> ! {\n    if code != 0 {\n        if let Some(mut out) = panic::SgxPanicOutput::new() {\n            let _ = write!(out, \"Exited with status code {}\", code);\n        }\n    }\n    usercalls::exit(code != 0);\n}\n\n#[cfg(not(test))]\n#[no_mangle]\nextern \"C\" fn abort_reentry() -> ! {\n    usercalls::exit(false)\n}\n"],["2445","#[cfg(test)]\nmod tests;\n\nuse super::{TLS_KEYS_BITSET_SIZE, USIZE_BITS};\nuse crate::iter::{Enumerate, Peekable};\nuse crate::slice::Iter;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\n\n/// A bitset that can be used synchronously.\npub(super) struct SyncBitset([AtomicUsize; TLS_KEYS_BITSET_SIZE]);\n\npub(super) const SYNC_BITSET_INIT: SyncBitset =\n    SyncBitset([AtomicUsize::new(0), AtomicUsize::new(0)]);\n\nimpl SyncBitset {\n    pub fn get(&self, index: usize) -> bool {\n        let (hi, lo) = Self::split(index);\n        (self.0[hi].load(Ordering::Relaxed) & lo) != 0\n    }\n\n    /// Not atomic.\n    pub fn iter(&self) -> SyncBitsetIter<'_> {\n        SyncBitsetIter { iter: self.0.iter().enumerate().peekable(), elem_idx: 0 }\n    }\n\n    pub fn clear(&self, index: usize) {\n        let (hi, lo) = Self::split(index);\n        self.0[hi].fetch_and(!lo, Ordering::Relaxed);\n    }\n\n    /// Sets any unset bit. Not atomic. Returns `None` if all bits were\n    /// observed to be set.\n    pub fn set(&self) -> Option<usize> {\n        'elems: for (idx, elem) in self.0.iter().enumerate() {\n            let mut current = elem.load(Ordering::Relaxed);\n            loop {\n                if 0 == !current {\n                    continue 'elems;\n                }\n                let trailing_ones = (!current).trailing_zeros() as usize;\n                match elem.compare_exchange(\n                    current,\n                    current | (1 << trailing_ones),\n                    Ordering::AcqRel,\n                    Ordering::Relaxed,\n                ) {\n                    Ok(_) => return Some(idx * USIZE_BITS + trailing_ones),\n                    Err(previous) => current = previous,\n                }\n            }\n        }\n        None\n    }\n\n    fn split(index: usize) -> (usize, usize) {\n        (index / USIZE_BITS, 1 << (index % USIZE_BITS))\n    }\n}\n\npub(super) struct SyncBitsetIter<'a> {\n    iter: Peekable<Enumerate<Iter<'a, AtomicUsize>>>,\n    elem_idx: usize,\n}\n\nimpl<'a> Iterator for SyncBitsetIter<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        self.iter.peek().cloned().and_then(|(idx, elem)| {\n            let elem = elem.load(Ordering::Relaxed);\n            let low_mask = (1 << self.elem_idx) - 1;\n            let next = elem & !low_mask;\n            let next_idx = next.trailing_zeros() as usize;\n            self.elem_idx = next_idx + 1;\n            if self.elem_idx >= 64 {\n                self.elem_idx = 0;\n                self.iter.next();\n            }\n            match next_idx {\n                64 => self.next(),\n                _ => Some(idx * USIZE_BITS + next_idx),\n            }\n        })\n    }\n}\n"],["2446","mod sync_bitset;\n\nuse self::sync_bitset::*;\nuse crate::cell::Cell;\nuse crate::mem;\nuse crate::num::NonZeroUsize;\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\n\n#[cfg(target_pointer_width = \"64\")]\nconst USIZE_BITS: usize = 64;\nconst TLS_KEYS: usize = 128; // Same as POSIX minimum\nconst TLS_KEYS_BITSET_SIZE: usize = (TLS_KEYS + (USIZE_BITS - 1)) / USIZE_BITS;\n\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx3abi3tls14TLS_KEY_IN_USEE\"]\nstatic TLS_KEY_IN_USE: SyncBitset = SYNC_BITSET_INIT;\nmacro_rules! dup {\n    ((* $($exp:tt)*) $($val:tt)*) => (dup!( ($($exp)*) $($val)* $($val)* ));\n    (() $($val:tt)*) => ([$($val),*])\n}\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx3abi3tls14TLS_DESTRUCTORE\"]\nstatic TLS_DESTRUCTOR: [AtomicUsize; TLS_KEYS] = dup!((* * * * * * *) (AtomicUsize::new(0)));\n\nextern \"C\" {\n    fn get_tls_ptr() -> *const u8;\n    fn set_tls_ptr(tls: *const u8);\n}\n\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct Key(NonZeroUsize);\n\nimpl Key {\n    fn to_index(self) -> usize {\n        self.0.get() - 1\n    }\n\n    fn from_index(index: usize) -> Self {\n        Key(NonZeroUsize::new(index + 1).unwrap())\n    }\n\n    pub fn as_usize(self) -> usize {\n        self.0.get()\n    }\n\n    pub fn from_usize(index: usize) -> Self {\n        Key(NonZeroUsize::new(index).unwrap())\n    }\n}\n\n#[repr(C)]\npub struct Tls {\n    data: [Cell<*mut u8>; TLS_KEYS],\n}\n\npub struct ActiveTls<'a> {\n    tls: &'a Tls,\n}\n\nimpl<'a> Drop for ActiveTls<'a> {\n    fn drop(&mut self) {\n        let value_with_destructor = |key: usize| {\n            let ptr = TLS_DESTRUCTOR[key].load(Ordering::Relaxed);\n            unsafe { mem::transmute::<_, Option<unsafe extern \"C\" fn(*mut u8)>>(ptr) }\n                .map(|dtor| (&self.tls.data[key], dtor))\n        };\n\n        let mut any_non_null_dtor = true;\n        while any_non_null_dtor {\n            any_non_null_dtor = false;\n            for (value, dtor) in TLS_KEY_IN_USE.iter().filter_map(&value_with_destructor) {\n                let value = value.replace(ptr::null_mut());\n                if !value.is_null() {\n                    any_non_null_dtor = true;\n                    unsafe { dtor(value) }\n                }\n            }\n        }\n    }\n}\n\nimpl Tls {\n    pub fn new() -> Tls {\n        Tls { data: dup!((* * * * * * *) (Cell::new(ptr::null_mut()))) }\n    }\n\n    pub unsafe fn activate(&self) -> ActiveTls<'_> {\n        // FIXME: Needs safety information. See entry.S for `set_tls_ptr` definition.\n        unsafe { set_tls_ptr(self as *const Tls as _) };\n        ActiveTls { tls: self }\n    }\n\n    #[allow(unused)]\n    pub unsafe fn activate_persistent(self: Box<Self>) {\n        // FIXME: Needs safety information. See entry.S for `set_tls_ptr` definition.\n        unsafe { set_tls_ptr((&*self) as *const Tls as _) };\n        mem::forget(self);\n    }\n\n    unsafe fn current<'a>() -> &'a Tls {\n        // FIXME: Needs safety information. See entry.S for `set_tls_ptr` definition.\n        unsafe { &*(get_tls_ptr() as *const Tls) }\n    }\n\n    pub fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n        let index = if let Some(index) = TLS_KEY_IN_USE.set() {\n            index\n        } else {\n            rtabort!(\"TLS limit exceeded\")\n        };\n        TLS_DESTRUCTOR[index].store(dtor.map_or(0, |f| f as usize), Ordering::Relaxed);\n        Key::from_index(index)\n    }\n\n    pub fn set(key: Key, value: *mut u8) {\n        let index = key.to_index();\n        rtassert!(TLS_KEY_IN_USE.get(index));\n        unsafe { Self::current() }.data[index].set(value);\n    }\n\n    pub fn get(key: Key) -> *mut u8 {\n        let index = key.to_index();\n        rtassert!(TLS_KEY_IN_USE.get(index));\n        unsafe { Self::current() }.data[index].get()\n    }\n\n    pub fn destroy(key: Key) {\n        TLS_KEY_IN_USE.clear(key.to_index());\n    }\n}\n"],["2447","use super::*;\n\nfn test_data(bitset: [usize; 2], bit_indices: &[usize]) {\n    let set = SyncBitset([AtomicUsize::new(bitset[0]), AtomicUsize::new(bitset[1])]);\n    assert_eq!(set.iter().collect::<Vec<_>>(), bit_indices);\n    for &i in bit_indices {\n        assert!(set.get(i));\n    }\n}\n\n#[test]\nfn iter() {\n    test_data([0b0110_1001, 0], &[0, 3, 5, 6]);\n    test_data([0x8000_0000_0000_0000, 0x8000_0000_0000_0001], &[63, 64, 127]);\n    test_data([0, 0], &[]);\n}\n\n#[test]\nfn set_get_clear() {\n    let set = SYNC_BITSET_INIT;\n    let key = set.set().unwrap();\n    assert!(set.get(key));\n    set.clear(key);\n    assert!(!set.get(key));\n}\n"],["2448","// Do not remove inline: will result in relocation failure\n#[inline(always)]\npub(crate) unsafe fn rel_ptr<T>(offset: u64) -> *const T {\n    (image_base() + offset) as *const T\n}\n\n// Do not remove inline: will result in relocation failure\n#[inline(always)]\npub(crate) unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n    (image_base() + offset) as *mut T\n}\n\nextern \"C\" {\n    static ENCLAVE_SIZE: usize;\n    static HEAP_BASE: u64;\n    static HEAP_SIZE: usize;\n}\n\n/// Returns the base memory address of the heap\npub(crate) fn heap_base() -> *const u8 {\n    unsafe { rel_ptr_mut(HEAP_BASE) }\n}\n\n/// Returns the size of the heap\npub(crate) fn heap_size() -> usize {\n    unsafe { HEAP_SIZE }\n}\n\n// Do not remove inline: will result in relocation failure\n// For the same reason we use inline ASM here instead of an extern static to\n// locate the base\n/// Returns address at which current enclave is loaded.\n#[inline(always)]\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn image_base() -> u64 {\n    let base: u64;\n    unsafe {\n        asm!(\n            \"lea {}, qword ptr [rip + IMAGE_BASE]\",\n            lateout(reg) base,\n            options(nostack, preserves_flags, nomem, pure),\n        )\n    };\n    base\n}\n\n/// Returns `true` if the specified memory range is in the enclave.\n///\n/// For safety, this function also checks whether the range given overflows,\n/// returning `false` if so.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n    let start = p as usize;\n\n    // Subtract one from `len` when calculating `end` in case `p + len` is\n    // exactly at the end of addressable memory (`p + len` would overflow, but\n    // the range is still valid).\n    let end = if len == 0 {\n        start\n    } else if let Some(end) = start.checked_add(len - 1) {\n        end\n    } else {\n        return false;\n    };\n\n    let base = image_base() as usize;\n    start >= base && end <= base + (unsafe { ENCLAVE_SIZE } - 1) // unsafe ok: link-time constant\n}\n\n/// Returns `true` if the specified memory range is in userspace.\n///\n/// For safety, this function also checks whether the range given overflows,\n/// returning `false` if so.\n#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\npub fn is_user_range(p: *const u8, len: usize) -> bool {\n    let start = p as usize;\n\n    // Subtract one from `len` when calculating `end` in case `p + len` is\n    // exactly at the end of addressable memory (`p + len` would overflow, but\n    // the range is still valid).\n    let end = if len == 0 {\n        start\n    } else if let Some(end) = start.checked_add(len - 1) {\n        end\n    } else {\n        return false;\n    };\n\n    let base = image_base() as usize;\n    end < base || start > base + (unsafe { ENCLAVE_SIZE } - 1) // unsafe ok: link-time constant\n}\n"],["2449","use super::*;\n\n// Verify that the byte pattern libunwind uses to initialize an RWLock is\n// equivalent to the value of RWLock::new(). If the value changes,\n// `src/UnwindRustSgx.h` in libunwind needs to be changed too.\n#[test]\nfn test_c_rwlock_initializer() {\n    #[rustfmt::skip]\n    const C_RWLOCK_INIT: &[u8] = &[\n        /* 0x00 */ 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x10 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x20 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x30 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x40 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x50 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x60 */ 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x70 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n        /* 0x80 */ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    ];\n\n    // For the test to work, we need the padding/unused bytes in RWLock to be\n    // initialized as 0. In practice, this is the case with statics.\n    static RUST_RWLOCK_INIT: RWLock = RWLock::new();\n\n    unsafe {\n        // If the assertion fails, that not necessarily an issue with the value\n        // of C_RWLOCK_INIT. It might just be an issue with the way padding\n        // bytes are initialized in the test code.\n        assert_eq!(&crate::mem::transmute_copy::<_, [u8; 144]>(&RUST_RWLOCK_INIT), C_RWLOCK_INIT);\n    };\n}\n"],["2450","use fortanix_sgx_abi as abi;\n\nuse crate::io;\n#[cfg(not(test))]\nuse crate::slice;\n#[cfg(not(test))]\nuse crate::str;\nuse crate::sys::fd::FileDesc;\n\npub struct Stdin(());\npub struct Stdout(());\npub struct Stderr(());\n\nfn with_std_fd<F: FnOnce(&FileDesc) -> R, R>(fd: abi::Fd, f: F) -> R {\n    let fd = FileDesc::new(fd);\n    let ret = f(&fd);\n    fd.into_raw();\n    ret\n}\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin(())\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        with_std_fd(abi::FD_STDIN, |fd| fd.read(buf))\n    }\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout(())\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        with_std_fd(abi::FD_STDOUT, |fd| fd.write(buf))\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        with_std_fd(abi::FD_STDOUT, |fd| fd.flush())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr(())\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        with_std_fd(abi::FD_STDERR, |fd| fd.write(buf))\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        with_std_fd(abi::FD_STDERR, |fd| fd.flush())\n    }\n}\n\npub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n\npub fn is_ebadf(err: &io::Error) -> bool {\n    // FIXME: Rust normally maps Unix EBADF to `Other`\n    err.raw_os_error() == Some(abi::Error::BrokenPipe as _)\n}\n\npub fn panic_output() -> Option<impl io::Write> {\n    super::abi::panic::SgxPanicOutput::new()\n}\n\n// This function is needed by libunwind. The symbol is named in pre-link args\n// for the target specification, so keep that in sync.\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n    if s < 0 {\n        return;\n    }\n    let buf = unsafe { slice::from_raw_parts(m as *const u8, s as _) };\n    if let Ok(s) = str::from_utf8(&buf[..buf.iter().position(|&b| b == 0).unwrap_or(buf.len())]) {\n        eprint!(\"{}\", s);\n    }\n}\n"],["2451","#[cfg(test)]\nmod tests;\n\nuse crate::num::NonZeroUsize;\n\nuse super::waitqueue::{\n    try_lock_or_false, NotifiedTcs, SpinMutex, SpinMutexGuard, WaitQueue, WaitVariable,\n};\nuse crate::mem;\n\npub struct RWLock {\n    readers: SpinMutex<WaitVariable<Option<NonZeroUsize>>>,\n    writer: SpinMutex<WaitVariable<bool>>,\n}\n\npub type MovableRWLock = Box<RWLock>;\n\n// Check at compile time that RWLock size matches C definition (see test_c_rwlock_initializer below)\n//\n// # Safety\n// Never called, as it is a compile time check.\n#[allow(dead_code)]\nunsafe fn rw_lock_size_assert(r: RWLock) {\n    unsafe { mem::transmute::<RWLock, [u8; 144]>(r) };\n}\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock {\n            readers: SpinMutex::new(WaitVariable::new(None)),\n            writer: SpinMutex::new(WaitVariable::new(false)),\n        }\n    }\n\n    #[inline]\n    pub unsafe fn read(&self) {\n        let mut rguard = self.readers.lock();\n        let wguard = self.writer.lock();\n        if *wguard.lock_var() || !wguard.queue_empty() {\n            // Another thread has or is waiting for the write lock, wait\n            drop(wguard);\n            WaitQueue::wait(rguard, || {});\n        // Another thread has passed the lock to us\n        } else {\n            // No waiting writers, acquire the read lock\n            *rguard.lock_var_mut() =\n                NonZeroUsize::new(rguard.lock_var().map_or(0, |n| n.get()) + 1);\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        let mut rguard = try_lock_or_false!(self.readers);\n        let wguard = try_lock_or_false!(self.writer);\n        if *wguard.lock_var() || !wguard.queue_empty() {\n            // Another thread has or is waiting for the write lock\n            false\n        } else {\n            // No waiting writers, acquire the read lock\n            *rguard.lock_var_mut() =\n                NonZeroUsize::new(rguard.lock_var().map_or(0, |n| n.get()) + 1);\n            true\n        }\n    }\n\n    #[inline]\n    pub unsafe fn write(&self) {\n        let rguard = self.readers.lock();\n        let mut wguard = self.writer.lock();\n        if *wguard.lock_var() || rguard.lock_var().is_some() {\n            // Another thread has the lock, wait\n            drop(rguard);\n            WaitQueue::wait(wguard, || {});\n        // Another thread has passed the lock to us\n        } else {\n            // We are just now obtaining the lock\n            *wguard.lock_var_mut() = true;\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        let rguard = try_lock_or_false!(self.readers);\n        let mut wguard = try_lock_or_false!(self.writer);\n        if *wguard.lock_var() || rguard.lock_var().is_some() {\n            // Another thread has the lock\n            false\n        } else {\n            // We are just now obtaining the lock\n            *wguard.lock_var_mut() = true;\n            true\n        }\n    }\n\n    #[inline]\n    unsafe fn __read_unlock(\n        &self,\n        mut rguard: SpinMutexGuard<'_, WaitVariable<Option<NonZeroUsize>>>,\n        wguard: SpinMutexGuard<'_, WaitVariable<bool>>,\n    ) {\n        *rguard.lock_var_mut() = NonZeroUsize::new(rguard.lock_var().unwrap().get() - 1);\n        if rguard.lock_var().is_some() {\n            // There are other active readers\n        } else {\n            if let Ok(mut wguard) = WaitQueue::notify_one(wguard) {\n                // A writer was waiting, pass the lock\n                *wguard.lock_var_mut() = true;\n                wguard.drop_after(rguard);\n            } else {\n                // No writers were waiting, the lock is released\n                rtassert!(rguard.queue_empty());\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        let rguard = self.readers.lock();\n        let wguard = self.writer.lock();\n        unsafe { self.__read_unlock(rguard, wguard) };\n    }\n\n    #[inline]\n    unsafe fn __write_unlock(\n        &self,\n        rguard: SpinMutexGuard<'_, WaitVariable<Option<NonZeroUsize>>>,\n        wguard: SpinMutexGuard<'_, WaitVariable<bool>>,\n    ) {\n        match WaitQueue::notify_one(wguard) {\n            Err(mut wguard) => {\n                // No writers waiting, release the write lock\n                *wguard.lock_var_mut() = false;\n                if let Ok(mut rguard) = WaitQueue::notify_all(rguard) {\n                    // One or more readers were waiting, pass the lock to them\n                    if let NotifiedTcs::All { count } = rguard.notified_tcs() {\n                        *rguard.lock_var_mut() = Some(count)\n                    } else {\n                        unreachable!() // called notify_all\n                    }\n                    rguard.drop_after(wguard);\n                } else {\n                    // No readers waiting, the lock is released\n                }\n            }\n            Ok(wguard) => {\n                // There was a thread waiting for write, just pass the lock\n                wguard.drop_after(rguard);\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        let rguard = self.readers.lock();\n        let wguard = self.writer.lock();\n        unsafe { self.__write_unlock(rguard, wguard) };\n    }\n\n    // only used by __rust_rwlock_unlock below\n    #[inline]\n    #[cfg_attr(test, allow(dead_code))]\n    unsafe fn unlock(&self) {\n        let rguard = self.readers.lock();\n        let wguard = self.writer.lock();\n        if *wguard.lock_var() == true {\n            unsafe { self.__write_unlock(rguard, wguard) };\n        } else {\n            unsafe { self.__read_unlock(rguard, wguard) };\n        }\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n\n// The following functions are needed by libunwind. These symbols are named\n// in pre-link args for the target specification, so keep that in sync.\n#[cfg(not(test))]\nconst EINVAL: i32 = 22;\n\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_rwlock_rdlock(p: *mut RWLock) -> i32 {\n    if p.is_null() {\n        return EINVAL;\n    }\n    unsafe { (*p).read() };\n    return 0;\n}\n\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_rwlock_wrlock(p: *mut RWLock) -> i32 {\n    if p.is_null() {\n        return EINVAL;\n    }\n    unsafe { (*p).write() };\n    return 0;\n}\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RWLock) -> i32 {\n    if p.is_null() {\n        return EINVAL;\n    }\n    unsafe { (*p).unlock() };\n    return 0;\n}\n"],["2452","use super::abi::tls::{Key as AbiKey, Tls};\n\npub type Key = usize;\n\n#[inline]\npub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n    Tls::create(dtor).as_usize()\n}\n\n#[inline]\npub unsafe fn set(key: Key, value: *mut u8) {\n    Tls::set(AbiKey::from_usize(key), value)\n}\n\n#[inline]\npub unsafe fn get(key: Key) -> *mut u8 {\n    Tls::get(AbiKey::from_usize(key))\n}\n\n#[inline]\npub unsafe fn destroy(key: Key) {\n    Tls::destroy(AbiKey::from_usize(key))\n}\n\n#[inline]\npub fn requires_synchronized_create() -> bool {\n    false\n}\n"],["2453","pub use core::slice::memchr::{memchr, memrchr};\n"],["2454","use super::abi::usercalls;\nuse crate::time::Duration;\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\npub struct Instant(Duration);\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\npub struct SystemTime(Duration);\n\npub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n\nimpl Instant {\n    pub fn now() -> Instant {\n        Instant(usercalls::insecure_time())\n    }\n\n    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n        self.0.checked_sub(other.0)\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant(self.0.checked_add(*other)?))\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant(self.0.checked_sub(*other)?))\n    }\n\n    pub fn actually_monotonic() -> bool {\n        false\n    }\n\n    pub const fn zero() -> Instant {\n        Instant(Duration::from_secs(0))\n    }\n}\n\nimpl SystemTime {\n    pub fn now() -> SystemTime {\n        SystemTime(usercalls::insecure_time())\n    }\n\n    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n        self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime(self.0.checked_add(*other)?))\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime(self.0.checked_sub(*other)?))\n    }\n}\n"],["2455","use super::abi::usercalls::{alloc, raw::ByteBuffer};\nuse crate::ffi::OsString;\nuse crate::fmt;\nuse crate::slice;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sys::os_str::Buf;\nuse crate::sys_common::FromInner;\n\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx4args4ARGSE\"]\nstatic ARGS: AtomicUsize = AtomicUsize::new(0);\ntype ArgsStore = Vec<OsString>;\n\n#[cfg_attr(test, allow(dead_code))]\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    if argc != 0 {\n        let args = unsafe { alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _) };\n        let args = args\n            .iter()\n            .map(|a| OsString::from_inner(Buf { inner: a.copy_user_buffer() }))\n            .collect::<ArgsStore>();\n        ARGS.store(Box::into_raw(Box::new(args)) as _, Ordering::Relaxed);\n    }\n}\n\npub fn args() -> Args {\n    let args = unsafe { (ARGS.load(Ordering::Relaxed) as *const ArgsStore).as_ref() };\n    if let Some(args) = args { Args(args.iter()) } else { Args([].iter()) }\n}\n\npub struct Args(slice::Iter<'static, OsString>);\n\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.as_slice().fmt(f)\n    }\n}\n\nimpl Iterator for Args {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> {\n        self.0.next().cloned()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}\n\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n}\n\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<OsString> {\n        self.0.next_back().cloned()\n    }\n}\n"],["2456","use fortanix_sgx_abi::Fd;\n\nuse super::abi::usercalls;\nuse crate::io::{self, IoSlice, IoSliceMut};\nuse crate::mem;\nuse crate::sys::{AsInner, FromInner, IntoInner};\n\n#[derive(Debug)]\npub struct FileDesc {\n    fd: Fd,\n}\n\nimpl FileDesc {\n    pub fn new(fd: Fd) -> FileDesc {\n        FileDesc { fd: fd }\n    }\n\n    pub fn raw(&self) -> Fd {\n        self.fd\n    }\n\n    /// Extracts the actual file descriptor without closing it.\n    pub fn into_raw(self) -> Fd {\n        let fd = self.fd;\n        mem::forget(self);\n        fd\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        usercalls::read(self.fd, &mut [IoSliceMut::new(buf)])\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        usercalls::read(self.fd, bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        usercalls::write(self.fd, &[IoSlice::new(buf)])\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        usercalls::write(self.fd, bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        usercalls::flush(self.fd)\n    }\n}\n\nimpl AsInner<Fd> for FileDesc {\n    fn as_inner(&self) -> &Fd {\n        &self.fd\n    }\n}\n\nimpl IntoInner<Fd> for FileDesc {\n    fn into_inner(self) -> Fd {\n        let fd = self.fd;\n        mem::forget(self);\n        fd\n    }\n}\n\nimpl FromInner<Fd> for FileDesc {\n    fn from_inner(fd: Fd) -> FileDesc {\n        FileDesc { fd }\n    }\n}\n\nimpl Drop for FileDesc {\n    fn drop(&mut self) {\n        usercalls::close(self.fd)\n    }\n}\n"],["2457","use fortanix_sgx_abi::{Error, RESULT_SUCCESS};\n\nuse crate::collections::HashMap;\nuse crate::error::Error as StdError;\nuse crate::ffi::{OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::marker::PhantomData;\nuse crate::path::{self, PathBuf};\nuse crate::str;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sync::Mutex;\nuse crate::sync::Once;\nuse crate::sys::{decode_error_kind, sgx_ineffective, unsupported};\nuse crate::vec;\n\npub fn errno() -> i32 {\n    RESULT_SUCCESS\n}\n\npub fn error_string(errno: i32) -> String {\n    if errno == RESULT_SUCCESS {\n        \"operation successful\".into()\n    } else if ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&errno) {\n        format!(\"user-specified error {:08x}\", errno)\n    } else {\n        decode_error_kind(errno).as_str().into()\n    }\n}\n\npub fn getcwd() -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub fn chdir(_: &path::Path) -> io::Result<()> {\n    sgx_ineffective(())\n}\n\npub struct SplitPaths<'a>(!, PhantomData<&'a ()>);\n\npub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {\n    panic!(\"unsupported\")\n}\n\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> {\n        self.0\n    }\n}\n\n#[derive(Debug)]\npub struct JoinPathsError;\n\npub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: Iterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n    Err(JoinPathsError)\n}\n\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"not supported in SGX yet\".fmt(f)\n    }\n}\n\nimpl StdError for JoinPathsError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"not supported in SGX yet\"\n    }\n}\n\npub fn current_exe() -> io::Result<PathBuf> {\n    unsupported()\n}\n\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx2os3ENVE\"]\nstatic ENV: AtomicUsize = AtomicUsize::new(0);\n#[cfg_attr(test, linkage = \"available_externally\")]\n#[export_name = \"_ZN16__rust_internals3std3sys3sgx2os8ENV_INITE\"]\nstatic ENV_INIT: Once = Once::new();\ntype EnvStore = Mutex<HashMap<OsString, OsString>>;\n\nfn get_env_store() -> Option<&'static EnvStore> {\n    unsafe { (ENV.load(Ordering::Relaxed) as *const EnvStore).as_ref() }\n}\n\nfn create_env_store() -> &'static EnvStore {\n    ENV_INIT.call_once(|| {\n        ENV.store(Box::into_raw(Box::new(EnvStore::default())) as _, Ordering::Relaxed)\n    });\n    unsafe { &*(ENV.load(Ordering::Relaxed) as *const EnvStore) }\n}\n\npub type Env = vec::IntoIter<(OsString, OsString)>;\n\npub fn env() -> Env {\n    let clone_to_vec = |map: &HashMap<OsString, OsString>| -> Vec<_> {\n        map.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n    };\n\n    get_env_store().map(|env| clone_to_vec(&env.lock().unwrap())).unwrap_or_default().into_iter()\n}\n\npub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n    Ok(get_env_store().and_then(|s| s.lock().unwrap().get(k).cloned()))\n}\n\npub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n    let (k, v) = (k.to_owned(), v.to_owned());\n    create_env_store().lock().unwrap().insert(k, v);\n    Ok(())\n}\n\npub fn unsetenv(k: &OsStr) -> io::Result<()> {\n    if let Some(env) = get_env_store() {\n        env.lock().unwrap().remove(k);\n    }\n    Ok(())\n}\n\npub fn temp_dir() -> PathBuf {\n    panic!(\"no filesystem in SGX\")\n}\n\npub fn home_dir() -> Option<PathBuf> {\n    None\n}\n\npub fn exit(code: i32) -> ! {\n    super::abi::exit_with_code(code as _)\n}\n\npub fn getpid() -> u32 {\n    panic!(\"no pids in SGX\")\n}\n"],["2458","#![cfg_attr(test, allow(dead_code))] // why is this necessary?\nuse crate::ffi::CStr;\nuse crate::io;\nuse crate::time::Duration;\n\nuse super::abi::usercalls;\n\npub struct Thread(task_queue::JoinHandle);\n\npub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n\npub use self::task_queue::JoinNotifier;\n\nmod task_queue {\n    use super::wait_notify;\n    use crate::sync::{Mutex, MutexGuard, Once};\n\n    pub type JoinHandle = wait_notify::Waiter;\n\n    pub struct JoinNotifier(Option<wait_notify::Notifier>);\n\n    impl Drop for JoinNotifier {\n        fn drop(&mut self) {\n            self.0.take().unwrap().notify();\n        }\n    }\n\n    pub(super) struct Task {\n        p: Box<dyn FnOnce()>,\n        done: JoinNotifier,\n    }\n\n    impl Task {\n        pub(super) fn new(p: Box<dyn FnOnce()>) -> (Task, JoinHandle) {\n            let (done, recv) = wait_notify::new();\n            let done = JoinNotifier(Some(done));\n            (Task { p, done }, recv)\n        }\n\n        pub(super) fn run(self) -> JoinNotifier {\n            (self.p)();\n            self.done\n        }\n    }\n\n    #[cfg_attr(test, linkage = \"available_externally\")]\n    #[export_name = \"_ZN16__rust_internals3std3sys3sgx6thread15TASK_QUEUE_INITE\"]\n    static TASK_QUEUE_INIT: Once = Once::new();\n    #[cfg_attr(test, linkage = \"available_externally\")]\n    #[export_name = \"_ZN16__rust_internals3std3sys3sgx6thread10TASK_QUEUEE\"]\n    static mut TASK_QUEUE: Option<Mutex<Vec<Task>>> = None;\n\n    pub(super) fn lock() -> MutexGuard<'static, Vec<Task>> {\n        unsafe {\n            TASK_QUEUE_INIT.call_once(|| TASK_QUEUE = Some(Default::default()));\n            TASK_QUEUE.as_ref().unwrap().lock().unwrap()\n        }\n    }\n}\n\n/// This module provides a synchronization primitive that does not use thread\n/// local variables. This is needed for signaling that a thread has finished\n/// execution. The signal is sent once all TLS destructors have finished at\n/// which point no new thread locals should be created.\npub mod wait_notify {\n    use super::super::waitqueue::{SpinMutex, WaitQueue, WaitVariable};\n    use crate::sync::Arc;\n\n    pub struct Notifier(Arc<SpinMutex<WaitVariable<bool>>>);\n\n    impl Notifier {\n        /// Notify the waiter. The waiter is either notified right away (if\n        /// currently blocked in `Waiter::wait()`) or later when it calls the\n        /// `Waiter::wait()` method.\n        pub fn notify(self) {\n            let mut guard = self.0.lock();\n            *guard.lock_var_mut() = true;\n            let _ = WaitQueue::notify_one(guard);\n        }\n    }\n\n    pub struct Waiter(Arc<SpinMutex<WaitVariable<bool>>>);\n\n    impl Waiter {\n        /// Wait for a notification. If `Notifier::notify()` has already been\n        /// called, this will return immediately, otherwise the current thread\n        /// is blocked until notified.\n        pub fn wait(self) {\n            let guard = self.0.lock();\n            if *guard.lock_var() {\n                return;\n            }\n            WaitQueue::wait(guard, || {});\n        }\n    }\n\n    pub fn new() -> (Notifier, Waiter) {\n        let inner = Arc::new(SpinMutex::new(WaitVariable::new(false)));\n        (Notifier(inner.clone()), Waiter(inner))\n    }\n}\n\nimpl Thread {\n    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n    pub unsafe fn new(_stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        let mut queue_lock = task_queue::lock();\n        unsafe { usercalls::launch_thread()? };\n        let (task, handle) = task_queue::Task::new(p);\n        queue_lock.push(task);\n        Ok(Thread(handle))\n    }\n\n    pub(super) fn entry() -> JoinNotifier {\n        let mut pending_tasks = task_queue::lock();\n        let task = rtunwrap!(Some, pending_tasks.pop());\n        drop(pending_tasks); // make sure to not hold the task queue lock longer than necessary\n        task.run()\n    }\n\n    pub fn yield_now() {\n        let wait_error = rtunwrap!(Err, usercalls::wait(0, usercalls::raw::WAIT_NO));\n        rtassert!(wait_error.kind() == io::ErrorKind::WouldBlock);\n    }\n\n    pub fn set_name(_name: &CStr) {\n        // FIXME: could store this pointer in TLS somewhere\n    }\n\n    pub fn sleep(dur: Duration) {\n        usercalls::wait_timeout(0, dur, || true);\n    }\n\n    pub fn join(self) {\n        self.0.wait();\n    }\n}\n\npub mod guard {\n    pub type Guard = !;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n"],["2459","use fortanix_sgx_abi::Tcs;\n\nuse super::abi::thread;\n\nuse super::waitqueue::{try_lock_or_false, NotifiedTcs, SpinMutex, WaitQueue, WaitVariable};\n\npub struct Mutex {\n    inner: SpinMutex<WaitVariable<bool>>,\n}\n\npub type MovableMutex = Mutex;\n\n// Implementation according to Operating Systems: Three Easy Pieces, chapter 28\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        Mutex { inner: SpinMutex::new(WaitVariable::new(false)) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {}\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        let mut guard = self.inner.lock();\n        if *guard.lock_var() {\n            // Another thread has the lock, wait\n            WaitQueue::wait(guard, || {})\n        // Another thread has passed the lock to us\n        } else {\n            // We are just now obtaining the lock\n            *guard.lock_var_mut() = true;\n        }\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let guard = self.inner.lock();\n        if let Err(mut guard) = WaitQueue::notify_one(guard) {\n            // No other waiters, unlock\n            *guard.lock_var_mut() = false;\n        } else {\n            // There was a thread waiting, just pass the lock\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        let mut guard = try_lock_or_false!(self.inner);\n        if *guard.lock_var() {\n            // Another thread has the lock\n            false\n        } else {\n            // We are just now obtaining the lock\n            *guard.lock_var_mut() = true;\n            true\n        }\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n\nstruct ReentrantLock {\n    owner: Option<Tcs>,\n    count: usize,\n}\n\npub struct ReentrantMutex {\n    inner: SpinMutex<WaitVariable<ReentrantLock>>,\n}\n\nimpl ReentrantMutex {\n    pub const fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex {\n            inner: SpinMutex::new(WaitVariable::new(ReentrantLock { owner: None, count: 0 })),\n        }\n    }\n\n    #[inline]\n    pub unsafe fn init(&self) {}\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        let mut guard = self.inner.lock();\n        match guard.lock_var().owner {\n            Some(tcs) if tcs != thread::current() => {\n                // Another thread has the lock, wait\n                WaitQueue::wait(guard, || {});\n                // Another thread has passed the lock to us\n            }\n            _ => {\n                // We are just now obtaining the lock\n                guard.lock_var_mut().owner = Some(thread::current());\n                guard.lock_var_mut().count += 1;\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let mut guard = self.inner.lock();\n        if guard.lock_var().count > 1 {\n            guard.lock_var_mut().count -= 1;\n        } else {\n            match WaitQueue::notify_one(guard) {\n                Err(mut guard) => {\n                    // No other waiters, unlock\n                    guard.lock_var_mut().count = 0;\n                    guard.lock_var_mut().owner = None;\n                }\n                Ok(mut guard) => {\n                    // There was a thread waiting, just pass the lock\n                    if let NotifiedTcs::Single(tcs) = guard.notified_tcs() {\n                        guard.lock_var_mut().owner = Some(tcs)\n                    } else {\n                        unreachable!() // called notify_one\n                    }\n                }\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        let mut guard = try_lock_or_false!(self.inner);\n        match guard.lock_var().owner {\n            Some(tcs) if tcs != thread::current() => {\n                // Another thread has the lock\n                false\n            }\n            _ => {\n                // We are just now obtaining the lock\n                guard.lock_var_mut().owner = Some(thread::current());\n                guard.lock_var_mut().count += 1;\n                true\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n"],["2460","#[cfg(target_os = \"linux\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"linux\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"macos\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"macos\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".dylib\";\n    pub const DLL_EXTENSION: &str = \"dylib\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"ios\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"ios\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".dylib\";\n    pub const DLL_EXTENSION: &str = \"dylib\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"freebsd\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"freebsd\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"dragonfly\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"dragonfly\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"netbsd\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"netbsd\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"openbsd\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"openbsd\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"android\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"android\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"solaris\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"solaris\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"illumos\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"illumos\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"haiku\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"haiku\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(all(target_os = \"emscripten\", target_arch = \"asmjs\"))]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"emscripten\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \".js\";\n    pub const EXE_EXTENSION: &str = \"js\";\n}\n\n#[cfg(all(target_os = \"emscripten\", target_arch = \"wasm32\"))]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"emscripten\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \".js\";\n    pub const EXE_EXTENSION: &str = \"js\";\n}\n\n#[cfg(target_os = \"fuchsia\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"fuchsia\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"l4re\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"l4re\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"redox\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"redox\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n\n#[cfg(target_os = \"vxworks\")]\npub mod os {\n    pub const FAMILY: &str = \"unix\";\n    pub const OS: &str = \"vxworks\";\n    pub const DLL_PREFIX: &str = \"lib\";\n    pub const DLL_SUFFIX: &str = \".so\";\n    pub const DLL_EXTENSION: &str = \"so\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n"],["2461","use crate::cmp;\nuse crate::ffi::CStr;\nuse crate::io::{self, IoSlice, IoSliceMut};\nuse crate::mem;\nuse crate::net::{Shutdown, SocketAddr};\nuse crate::str;\nuse crate::sys::fd::FileDesc;\nuse crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\nuse crate::time::{Duration, Instant};\n\nuse libc::{c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n\npub use crate::sys::{cvt, cvt_r};\n\n#[allow(unused_extern_crates)]\npub extern crate libc as netc;\n\npub type wrlen_t = size_t;\n\npub struct Socket(FileDesc);\n\npub fn init() {}\n\npub fn cvt_gai(err: c_int) -> io::Result<()> {\n    if err == 0 {\n        return Ok(());\n    }\n\n    // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n    on_resolver_failure();\n\n    if err == EAI_SYSTEM {\n        return Err(io::Error::last_os_error());\n    }\n\n    let detail = unsafe {\n        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()\n    };\n    Err(io::Error::new(\n        io::ErrorKind::Other,\n        &format!(\"failed to lookup address information: {}\", detail)[..],\n    ))\n}\n\nimpl Socket {\n    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n        let fam = match *addr {\n            SocketAddr::V4(..) => libc::AF_INET,\n            SocketAddr::V6(..) => libc::AF_INET6,\n        };\n        Socket::new_raw(fam, ty)\n    }\n\n    pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n        unsafe {\n            cfg_if::cfg_if! {\n                if #[cfg(any(\n                    target_os = \"android\",\n                    target_os = \"dragonfly\",\n                    target_os = \"freebsd\",\n                    target_os = \"illumos\",\n                    target_os = \"linux\",\n                    target_os = \"netbsd\",\n                    target_os = \"openbsd\",\n                ))] {\n                    // On platforms that support it we pass the SOCK_CLOEXEC\n                    // flag to atomically create the socket and set it as\n                    // CLOEXEC. On Linux this was added in 2.6.27.\n                    let fd = cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0))?;\n                    Ok(Socket(FileDesc::new(fd)))\n                } else {\n                    let fd = cvt(libc::socket(fam, ty, 0))?;\n                    let fd = FileDesc::new(fd);\n                    fd.set_cloexec()?;\n                    let socket = Socket(fd);\n\n                    // macOS and iOS use `SO_NOSIGPIPE` as a `setsockopt`\n                    // flag to disable `SIGPIPE` emission on socket.\n                    #[cfg(target_vendor = \"apple\")]\n                    setsockopt(&socket, libc::SOL_SOCKET, libc::SO_NOSIGPIPE, 1)?;\n\n                    Ok(socket)\n                }\n            }\n        }\n    }\n\n    #[cfg(not(target_os = \"vxworks\"))]\n    pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> {\n        unsafe {\n            let mut fds = [0, 0];\n\n            cfg_if::cfg_if! {\n                if #[cfg(any(\n                    target_os = \"android\",\n                    target_os = \"dragonfly\",\n                    target_os = \"freebsd\",\n                    target_os = \"illumos\",\n                    target_os = \"linux\",\n                    target_os = \"netbsd\",\n                    target_os = \"openbsd\",\n                ))] {\n                    // Like above, set cloexec atomically\n                    cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr()))?;\n                    Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))))\n                } else {\n                    cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr()))?;\n                    let a = FileDesc::new(fds[0]);\n                    let b = FileDesc::new(fds[1]);\n                    a.set_cloexec()?;\n                    b.set_cloexec()?;\n                    Ok((Socket(a), Socket(b)))\n                }\n            }\n        }\n    }\n\n    #[cfg(target_os = \"vxworks\")]\n    pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {\n        unimplemented!()\n    }\n\n    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n        self.set_nonblocking(true)?;\n        let r = unsafe {\n            let (addrp, len) = addr.into_inner();\n            cvt(libc::connect(self.0.raw(), addrp, len))\n        };\n        self.set_nonblocking(false)?;\n\n        match r {\n            Ok(_) => return Ok(()),\n            // there's no ErrorKind for EINPROGRESS :(\n            Err(ref e) if e.raw_os_error() == Some(libc::EINPROGRESS) => {}\n            Err(e) => return Err(e),\n        }\n\n        let mut pollfd = libc::pollfd { fd: self.0.raw(), events: libc::POLLOUT, revents: 0 };\n\n        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidInput,\n                &\"cannot set a 0 duration timeout\",\n            ));\n        }\n\n        let start = Instant::now();\n\n        loop {\n            let elapsed = start.elapsed();\n            if elapsed >= timeout {\n                return Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\"));\n            }\n\n            let timeout = timeout - elapsed;\n            let mut timeout = timeout\n                .as_secs()\n                .saturating_mul(1_000)\n                .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n            if timeout == 0 {\n                timeout = 1;\n            }\n\n            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n\n            match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n                -1 => {\n                    let err = io::Error::last_os_error();\n                    if err.kind() != io::ErrorKind::Interrupted {\n                        return Err(err);\n                    }\n                }\n                0 => {}\n                _ => {\n                    // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n                    // for POLLHUP rather than read readiness\n                    if pollfd.revents & libc::POLLHUP != 0 {\n                        let e = self.take_error()?.unwrap_or_else(|| {\n                            io::Error::new_const(\n                                io::ErrorKind::Other,\n                                &\"no error set after POLLHUP\",\n                            )\n                        });\n                        return Err(e);\n                    }\n\n                    return Ok(());\n                }\n            }\n        }\n    }\n\n    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n        // Unfortunately the only known way right now to accept a socket and\n        // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n        // platforms that support it. On Linux, this was added in 2.6.28,\n        // glibc 2.10 and musl 0.9.5.\n        cfg_if::cfg_if! {\n            if #[cfg(any(\n                target_os = \"android\",\n                target_os = \"dragonfly\",\n                target_os = \"freebsd\",\n                target_os = \"illumos\",\n                target_os = \"linux\",\n                target_os = \"netbsd\",\n                target_os = \"openbsd\",\n            ))] {\n                let fd = cvt_r(|| unsafe {\n                    libc::accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC)\n                })?;\n                Ok(Socket(FileDesc::new(fd)))\n            } else {\n                let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n                let fd = FileDesc::new(fd);\n                fd.set_cloexec()?;\n                Ok(Socket(fd))\n            }\n        }\n    }\n\n    pub fn duplicate(&self) -> io::Result<Socket> {\n        self.0.duplicate().map(Socket)\n    }\n\n    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.recv_with_flags(buf, 0)\n    }\n\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.recv_with_flags(buf, MSG_PEEK)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.0.is_read_vectored()\n    }\n\n    fn recv_from_with_flags(\n        &self,\n        buf: &mut [u8],\n        flags: c_int,\n    ) -> io::Result<(usize, SocketAddr)> {\n        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n        let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n\n        let n = cvt(unsafe {\n            libc::recvfrom(\n                self.0.raw(),\n                buf.as_mut_ptr() as *mut c_void,\n                buf.len(),\n                flags,\n                &mut storage as *mut _ as *mut _,\n                &mut addrlen,\n            )\n        })?;\n        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n    }\n\n    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.recv_from_with_flags(buf, 0)\n    }\n\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"dragonfly\",\n        target_os = \"emscripten\",\n        target_os = \"freebsd\",\n        target_os = \"linux\",\n        target_os = \"netbsd\",\n        target_os = \"openbsd\",\n    ))]\n    pub fn recv_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {\n        let n = cvt(unsafe { libc::recvmsg(self.0.raw(), msg, libc::MSG_CMSG_CLOEXEC) })?;\n        Ok(n as usize)\n    }\n\n    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.recv_from_with_flags(buf, MSG_PEEK)\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"dragonfly\",\n        target_os = \"emscripten\",\n        target_os = \"freebsd\",\n        target_os = \"linux\",\n        target_os = \"netbsd\",\n        target_os = \"openbsd\",\n    ))]\n    pub fn send_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {\n        let n = cvt(unsafe { libc::sendmsg(self.0.raw(), msg, 0) })?;\n        Ok(n as usize)\n    }\n\n    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n        let timeout = match dur {\n            Some(dur) => {\n                if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n                    return Err(io::Error::new_const(\n                        io::ErrorKind::InvalidInput,\n                        &\"cannot set a 0 duration timeout\",\n                    ));\n                }\n\n                let secs = if dur.as_secs() > libc::time_t::MAX as u64 {\n                    libc::time_t::MAX\n                } else {\n                    dur.as_secs() as libc::time_t\n                };\n                let mut timeout = libc::timeval {\n                    tv_sec: secs,\n                    tv_usec: dur.subsec_micros() as libc::suseconds_t,\n                };\n                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n                    timeout.tv_usec = 1;\n                }\n                timeout\n            }\n            None => libc::timeval { tv_sec: 0, tv_usec: 0 },\n        };\n        setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n    }\n\n    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> {\n        let raw: libc::timeval = getsockopt(self, libc::SOL_SOCKET, kind)?;\n        if raw.tv_sec == 0 && raw.tv_usec == 0 {\n            Ok(None)\n        } else {\n            let sec = raw.tv_sec as u64;\n            let nsec = (raw.tv_usec as u32) * 1000;\n            Ok(Some(Duration::new(sec, nsec)))\n        }\n    }\n\n    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n        let how = match how {\n            Shutdown::Write => libc::SHUT_WR,\n            Shutdown::Read => libc::SHUT_RD,\n            Shutdown::Both => libc::SHUT_RDWR,\n        };\n        cvt(unsafe { libc::shutdown(self.0.raw(), how) })?;\n        Ok(())\n    }\n\n    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n        setsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY, nodelay as c_int)\n    }\n\n    pub fn nodelay(&self) -> io::Result<bool> {\n        let raw: c_int = getsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY)?;\n        Ok(raw != 0)\n    }\n\n    #[cfg(any(target_os = \"android\", target_os = \"linux\",))]\n    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {\n        setsockopt(self, libc::SOL_SOCKET, libc::SO_PASSCRED, passcred as libc::c_int)\n    }\n\n    #[cfg(any(target_os = \"android\", target_os = \"linux\",))]\n    pub fn passcred(&self) -> io::Result<bool> {\n        let passcred: libc::c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_PASSCRED)?;\n        Ok(passcred != 0)\n    }\n\n    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        let mut nonblocking = nonblocking as libc::c_int;\n        cvt(unsafe { libc::ioctl(*self.as_inner(), libc::FIONBIO, &mut nonblocking) }).map(drop)\n    }\n\n    #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        // FIONBIO is inadequate for sockets on illumos/Solaris, so use the\n        // fcntl(F_[GS]ETFL)-based method provided by FileDesc instead.\n        self.0.set_nonblocking(nonblocking)\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n        if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n    }\n}\n\nimpl AsInner<c_int> for Socket {\n    fn as_inner(&self) -> &c_int {\n        self.0.as_inner()\n    }\n}\n\nimpl FromInner<c_int> for Socket {\n    fn from_inner(fd: c_int) -> Socket {\n        Socket(FileDesc::new(fd))\n    }\n}\n\nimpl IntoInner<c_int> for Socket {\n    fn into_inner(self) -> c_int {\n        self.0.into_raw()\n    }\n}\n\n// In versions of glibc prior to 2.26, there's a bug where the DNS resolver\n// will cache the contents of /etc/resolv.conf, so changes to that file on disk\n// can be ignored by a long-running program. That can break DNS lookups on e.g.\n// laptops where the network comes and goes. See\n// https://sourceware.org/bugzilla/show_bug.cgi?id=984. Note however that some\n// distros including Debian have patched glibc to fix this for a long time.\n//\n// A workaround for this bug is to call the res_init libc function, to clear\n// the cached configs. Unfortunately, while we believe glibc's implementation\n// of res_init is thread-safe, we know that other implementations are not\n// (https://github.com/rust-lang/rust/issues/43592). Code here in libstd could\n// try to synchronize its res_init calls with a Mutex, but that wouldn't\n// protect programs that call into libc in other ways. So instead of calling\n// res_init unconditionally, we call it only when we detect we're linking\n// against glibc version < 2.26. (That is, when we both know its needed and\n// believe it's thread-safe).\n#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\nfn on_resolver_failure() {\n    use crate::sys;\n\n    // If the version fails to parse, we treat it the same as \"not glibc\".\n    if let Some(version) = sys::os::glibc_version() {\n        if version < (2, 26) {\n            unsafe { libc::res_init() };\n        }\n    }\n}\n\n#[cfg(any(not(target_env = \"gnu\"), target_os = \"vxworks\"))]\nfn on_resolver_failure() {}\n"],["2462","#![cfg_attr(test, allow(dead_code))]\n\nuse self::imp::{drop_handler, make_handler};\n\npub use self::imp::cleanup;\npub use self::imp::init;\n\npub struct Handler {\n    _data: *mut libc::c_void,\n}\n\nimpl Handler {\n    pub unsafe fn new() -> Handler {\n        make_handler()\n    }\n\n    fn null() -> Handler {\n        Handler { _data: crate::ptr::null_mut() }\n    }\n}\n\nimpl Drop for Handler {\n    fn drop(&mut self) {\n        unsafe {\n            drop_handler(self);\n        }\n    }\n}\n\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"macos\",\n    target_os = \"dragonfly\",\n    target_os = \"freebsd\",\n    target_os = \"solaris\",\n    target_os = \"illumos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\"\n))]\nmod imp {\n    use super::Handler;\n    use crate::io;\n    use crate::mem;\n    use crate::ptr;\n    use crate::thread;\n\n    use libc::MAP_FAILED;\n    use libc::{mmap, munmap};\n    use libc::{sigaction, sighandler_t, SA_ONSTACK, SA_SIGINFO, SIGBUS, SIG_DFL};\n    use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n    use libc::{MAP_ANON, MAP_PRIVATE, PROT_NONE, PROT_READ, PROT_WRITE, SIGSEGV};\n\n    use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n    use crate::sys::unix::os::page_size;\n    use crate::sys_common::thread_info;\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n        #[repr(C)]\n        struct siginfo_t {\n            a: [libc::c_int; 3], // si_signo, si_errno, si_code\n            si_addr: *mut libc::c_void,\n        }\n\n        (*(info as *const siginfo_t)).si_addr as usize\n    }\n\n    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n        (*info).si_addr as usize\n    }\n\n    // Signal handler for the SIGSEGV and SIGBUS handlers. We've got guard pages\n    // (unmapped pages) at the end of every thread's stack, so if a thread ends\n    // up running into the guard page it'll trigger this handler. We want to\n    // detect these cases and print out a helpful error saying that the stack\n    // has overflowed. All other signals, however, should go back to what they\n    // were originally supposed to do.\n    //\n    // This handler currently exists purely to print an informative message\n    // whenever a thread overflows its stack. We then abort to exit and\n    // indicate a crash, but to avoid a misleading SIGSEGV that might lead\n    // users to believe that unsafe code has accessed an invalid pointer; the\n    // SIGSEGV encountered when overflowing the stack is expected and\n    // well-defined.\n    //\n    // If this is not a stack overflow, the handler un-registers itself and\n    // then returns (to allow the original signal to be delivered again).\n    // Returning from this kind of signal handler is technically not defined\n    // to work when reading the POSIX spec strictly, but in practice it turns\n    // out many large systems and all implementations allow returning from a\n    // signal handler to work. For a more detailed explanation see the\n    // comments on #26458.\n    unsafe extern \"C\" fn signal_handler(\n        signum: libc::c_int,\n        info: *mut libc::siginfo_t,\n        _data: *mut libc::c_void,\n    ) {\n        let guard = thread_info::stack_guard().unwrap_or(0..0);\n        let addr = siginfo_si_addr(info);\n\n        // If the faulting address is within the guard page, then we print a\n        // message saying so and abort.\n        if guard.start <= addr && addr < guard.end {\n            rtprintpanic!(\n                \"\\nthread '{}' has overflowed its stack\\n\",\n                thread::current().name().unwrap_or(\"<unknown>\")\n            );\n            rtabort!(\"stack overflow\");\n        } else {\n            // Unregister ourselves by reverting back to the default behavior.\n            let mut action: sigaction = mem::zeroed();\n            action.sa_sigaction = SIG_DFL;\n            sigaction(signum, &action, ptr::null_mut());\n\n            // See comment above for why this function returns.\n        }\n    }\n\n    static MAIN_ALTSTACK: AtomicPtr<libc::c_void> = AtomicPtr::new(ptr::null_mut());\n    static NEED_ALTSTACK: AtomicBool = AtomicBool::new(false);\n\n    pub unsafe fn init() {\n        let mut action: sigaction = mem::zeroed();\n        for &signal in &[SIGSEGV, SIGBUS] {\n            sigaction(signal, ptr::null_mut(), &mut action);\n            // Configure our signal handler if one is not already set.\n            if action.sa_sigaction == SIG_DFL {\n                action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n                action.sa_sigaction = signal_handler as sighandler_t;\n                sigaction(signal, &action, ptr::null_mut());\n                NEED_ALTSTACK.store(true, Ordering::Relaxed);\n            }\n        }\n\n        let handler = make_handler();\n        MAIN_ALTSTACK.store(handler._data, Ordering::Relaxed);\n        mem::forget(handler);\n    }\n\n    pub unsafe fn cleanup() {\n        Handler { _data: MAIN_ALTSTACK.load(Ordering::Relaxed) };\n    }\n\n    unsafe fn get_stackp() -> *mut libc::c_void {\n        let stackp = mmap(\n            ptr::null_mut(),\n            SIGSTKSZ + page_size(),\n            PROT_READ | PROT_WRITE,\n            MAP_PRIVATE | MAP_ANON,\n            -1,\n            0,\n        );\n        if stackp == MAP_FAILED {\n            panic!(\"failed to allocate an alternative stack: {}\", io::Error::last_os_error());\n        }\n        let guard_result = libc::mprotect(stackp, page_size(), PROT_NONE);\n        if guard_result != 0 {\n            panic!(\"failed to set up alternative stack guard page: {}\", io::Error::last_os_error());\n        }\n        stackp.add(page_size())\n    }\n\n    #[cfg(any(\n        target_os = \"linux\",\n        target_os = \"macos\",\n        target_os = \"freebsd\",\n        target_os = \"netbsd\",\n        target_os = \"openbsd\",\n        target_os = \"solaris\",\n        target_os = \"illumos\"\n    ))]\n    unsafe fn get_stack() -> libc::stack_t {\n        libc::stack_t { ss_sp: get_stackp(), ss_flags: 0, ss_size: SIGSTKSZ }\n    }\n\n    #[cfg(target_os = \"dragonfly\")]\n    unsafe fn get_stack() -> libc::stack_t {\n        libc::stack_t { ss_sp: get_stackp() as *mut i8, ss_flags: 0, ss_size: SIGSTKSZ }\n    }\n\n    pub unsafe fn make_handler() -> Handler {\n        if !NEED_ALTSTACK.load(Ordering::Relaxed) {\n            return Handler::null();\n        }\n        let mut stack = mem::zeroed();\n        sigaltstack(ptr::null(), &mut stack);\n        // Configure alternate signal stack, if one is not already set.\n        if stack.ss_flags & SS_DISABLE != 0 {\n            stack = get_stack();\n            sigaltstack(&stack, ptr::null_mut());\n            Handler { _data: stack.ss_sp as *mut libc::c_void }\n        } else {\n            Handler::null()\n        }\n    }\n\n    pub unsafe fn drop_handler(handler: &mut Handler) {\n        if !handler._data.is_null() {\n            let stack = libc::stack_t {\n                ss_sp: ptr::null_mut(),\n                ss_flags: SS_DISABLE,\n                // Workaround for bug in macOS implementation of sigaltstack\n                // UNIX2003 which returns ENOMEM when disabling a stack while\n                // passing ss_size smaller than MINSIGSTKSZ. According to POSIX\n                // both ss_sp and ss_size should be ignored in this case.\n                ss_size: SIGSTKSZ,\n            };\n            sigaltstack(&stack, ptr::null_mut());\n            // We know from `get_stackp` that the alternate stack we installed is part of a mapping\n            // that started one page earlier, so walk back a page and unmap from there.\n            munmap(handler._data.sub(page_size()), SIGSTKSZ + page_size());\n        }\n    }\n}\n\n#[cfg(not(any(\n    target_os = \"linux\",\n    target_os = \"macos\",\n    target_os = \"dragonfly\",\n    target_os = \"freebsd\",\n    target_os = \"solaris\",\n    target_os = \"illumos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n)))]\nmod imp {\n    pub unsafe fn init() {}\n\n    pub unsafe fn cleanup() {}\n\n    pub unsafe fn make_handler() -> super::Handler {\n        super::Handler::null()\n    }\n\n    pub unsafe fn drop_handler(_handler: &mut super::Handler) {}\n}\n"],["2463","#![allow(missing_docs, nonstandard_style)]\n\nuse crate::io::ErrorKind;\n\npub use self::rand::hashmap_random_keys;\npub use libc::strlen;\n\n#[macro_use]\npub mod weak;\n\npub mod alloc;\npub mod android;\npub mod args;\n#[path = \"../unix/cmath.rs\"]\npub mod cmath;\npub mod condvar;\npub mod env;\npub mod fd;\npub mod fs;\npub mod futex;\npub mod io;\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\npub mod kernel_copy;\n#[cfg(target_os = \"l4re\")]\nmod l4re;\npub mod memchr;\npub mod mutex;\n#[cfg(not(target_os = \"l4re\"))]\npub mod net;\n#[cfg(target_os = \"l4re\")]\npub use self::l4re::net;\npub mod os;\npub mod path;\npub mod pipe;\npub mod process;\npub mod rand;\npub mod rwlock;\npub mod stack_overflow;\npub mod stdio;\npub mod thread;\npub mod thread_local_dtor;\npub mod thread_local_key;\npub mod time;\n\npub use crate::sys_common::os_str_bytes as os_str;\n\n// SAFETY: must be called only once during runtime initialization.\n// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    // The standard streams might be closed on application startup. To prevent\n    // std::io::{stdin, stdout,stderr} objects from using other unrelated file\n    // resources opened later, we reopen standards streams when they are closed.\n    sanitize_standard_fds();\n\n    // By default, some platforms will send a *signal* when an EPIPE error\n    // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n    // handler, causing it to kill the program, which isn't exactly what we\n    // want!\n    //\n    // Hence, we set SIGPIPE to ignore when the program starts up in order\n    // to prevent this problem.\n    reset_sigpipe();\n\n    stack_overflow::init();\n    args::init(argc, argv);\n\n    unsafe fn sanitize_standard_fds() {\n        #[cfg(not(miri))]\n        // The standard fds are always available in Miri.\n        cfg_if::cfg_if! {\n            if #[cfg(not(any(\n                target_os = \"emscripten\",\n                target_os = \"fuchsia\",\n                target_os = \"vxworks\",\n                // The poll on Darwin doesn't set POLLNVAL for closed fds.\n                target_os = \"macos\",\n                target_os = \"ios\",\n                target_os = \"redox\",\n            )))] {\n                use crate::sys::os::errno;\n                let pfds: &mut [_] = &mut [\n                    libc::pollfd { fd: 0, events: 0, revents: 0 },\n                    libc::pollfd { fd: 1, events: 0, revents: 0 },\n                    libc::pollfd { fd: 2, events: 0, revents: 0 },\n                ];\n                while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n                    if errno() == libc::EINTR {\n                        continue;\n                    }\n                    libc::abort();\n                }\n                for pfd in pfds {\n                    if pfd.revents & libc::POLLNVAL == 0 {\n                        continue;\n                    }\n                    if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n                        // If the stream is closed but we failed to reopen it, abort the\n                        // process. Otherwise we wouldn't preserve the safety of\n                        // operations on the corresponding Rust object Stdin, Stdout, or\n                        // Stderr.\n                        libc::abort();\n                    }\n                }\n            } else if #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"redox\"))] {\n                use crate::sys::os::errno;\n                for fd in 0..3 {\n                    if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n                        if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n                            libc::abort();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    unsafe fn reset_sigpipe() {\n        #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\")))]\n        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);\n    }\n}\n\n// SAFETY: must be called only once during runtime cleanup.\n// NOTE: this is not guaranteed to run, for example when the program aborts.\npub unsafe fn cleanup() {\n    args::cleanup();\n    stack_overflow::cleanup();\n}\n\n#[cfg(target_os = \"android\")]\npub use crate::sys::android::signal;\n#[cfg(not(target_os = \"android\"))]\npub use libc::signal;\n\npub fn decode_error_kind(errno: i32) -> ErrorKind {\n    match errno as libc::c_int {\n        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n        libc::ECONNRESET => ErrorKind::ConnectionReset,\n        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n        libc::EPIPE => ErrorKind::BrokenPipe,\n        libc::ENOTCONN => ErrorKind::NotConnected,\n        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n        libc::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n        libc::EADDRINUSE => ErrorKind::AddrInUse,\n        libc::ENOENT => ErrorKind::NotFound,\n        libc::EINTR => ErrorKind::Interrupted,\n        libc::EINVAL => ErrorKind::InvalidInput,\n        libc::ETIMEDOUT => ErrorKind::TimedOut,\n        libc::EEXIST => ErrorKind::AlreadyExists,\n        libc::ENOSYS => ErrorKind::Unsupported,\n        libc::ENOMEM => ErrorKind::OutOfMemory,\n\n        // These two constants can have the same value on some systems,\n        // but different values on others, so we can't use a match\n        // clause\n        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK => ErrorKind::WouldBlock,\n\n        _ => ErrorKind::Other,\n    }\n}\n\n#[doc(hidden)]\npub trait IsMinusOne {\n    fn is_minus_one(&self) -> bool;\n}\n\nmacro_rules! impl_is_minus_one {\n    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n        fn is_minus_one(&self) -> bool {\n            *self == -1\n        }\n    })*)\n}\n\nimpl_is_minus_one! { i8 i16 i32 i64 isize }\n\npub fn cvt<T: IsMinusOne>(t: T) -> crate::io::Result<T> {\n    if t.is_minus_one() { Err(crate::io::Error::last_os_error()) } else { Ok(t) }\n}\n\npub fn cvt_r<T, F>(mut f: F) -> crate::io::Result<T>\nwhere\n    T: IsMinusOne,\n    F: FnMut() -> T,\n{\n    loop {\n        match cvt(f()) {\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            other => return other,\n        }\n    }\n}\n\npub fn cvt_nz(error: libc::c_int) -> crate::io::Result<()> {\n    if error == 0 { Ok(()) } else { Err(crate::io::Error::from_raw_os_error(error)) }\n}\n\n// On Unix-like platforms, libc::abort will unregister signal handlers\n// including the SIGABRT handler, preventing the abort from being blocked, and\n// fclose streams, with the side effect of flushing them so libc buffered\n// output will be printed.  Additionally the shell will generally print a more\n// understandable error message like \"Abort trap\" rather than \"Illegal\n// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n// implemented as an illegal instruction.\npub fn abort_internal() -> ! {\n    unsafe { libc::abort() }\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"android\")] {\n        #[link(name = \"dl\")]\n        #[link(name = \"log\")]\n        extern \"C\" {}\n    } else if #[cfg(target_os = \"freebsd\")] {\n        #[link(name = \"execinfo\")]\n        #[link(name = \"pthread\")]\n        extern \"C\" {}\n    } else if #[cfg(target_os = \"netbsd\")] {\n        #[link(name = \"pthread\")]\n        #[link(name = \"rt\")]\n        extern \"C\" {}\n    } else if #[cfg(any(target_os = \"dragonfly\", target_os = \"openbsd\"))] {\n        #[link(name = \"pthread\")]\n        extern \"C\" {}\n    } else if #[cfg(target_os = \"solaris\")] {\n        #[link(name = \"socket\")]\n        #[link(name = \"posix4\")]\n        #[link(name = \"pthread\")]\n        #[link(name = \"resolv\")]\n        extern \"C\" {}\n    } else if #[cfg(target_os = \"illumos\")] {\n        #[link(name = \"socket\")]\n        #[link(name = \"posix4\")]\n        #[link(name = \"pthread\")]\n        #[link(name = \"resolv\")]\n        #[link(name = \"nsl\")]\n        // Use libumem for the (malloc-compatible) allocator\n        #[link(name = \"umem\")]\n        extern \"C\" {}\n    } else if #[cfg(target_os = \"macos\")] {\n        #[link(name = \"System\")]\n        // res_init and friends require -lresolv on macOS/iOS.\n        // See #41582 and http://blog.achernya.com/2013/03/os-x-has-silly-libsystem.html\n        #[link(name = \"resolv\")]\n        extern \"C\" {}\n    } else if #[cfg(target_os = \"ios\")] {\n        #[link(name = \"System\")]\n        #[link(name = \"objc\")]\n        #[link(name = \"Security\", kind = \"framework\")]\n        #[link(name = \"Foundation\", kind = \"framework\")]\n        #[link(name = \"resolv\")]\n        extern \"C\" {}\n    } else if #[cfg(target_os = \"fuchsia\")] {\n        #[link(name = \"zircon\")]\n        #[link(name = \"fdio\")]\n        extern \"C\" {}\n    }\n}\n"],["2464","//! Android ABI-compatibility module\n//!\n//! The ABI of Android has changed quite a bit over time, and libstd attempts to\n//! be both forwards and backwards compatible as much as possible. We want to\n//! always work with the most recent version of Android, but we also want to\n//! work with older versions of Android for whenever projects need to.\n//!\n//! Our current minimum supported Android version is `android-9`, e.g., Android\n//! with API level 9. We then in theory want to work on that and all future\n//! versions of Android!\n//!\n//! Some of the detection here is done at runtime via `dlopen` and\n//! introspection. Other times no detection is performed at all and we just\n//! provide a fallback implementation as some versions of Android we support\n//! don't have the function.\n//!\n//! You'll find more details below about why each compatibility shim is needed.\n\n#![cfg(target_os = \"android\")]\n\nuse libc::{c_int, c_void, sighandler_t, size_t, ssize_t};\nuse libc::{ftruncate, pread, pwrite};\n\nuse super::{cvt, cvt_r};\nuse crate::io;\n\n// The `log2` and `log2f` functions apparently appeared in android-18, or at\n// least you can see they're not present in the android-17 header [1] and they\n// are present in android-18 [2].\n//\n// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n//                                       /android-17/arch-arm/usr/include/math.h\n// [2]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n//                                       /android-18/arch-arm/usr/include/math.h\n//\n// Note that these shims are likely less precise than directly calling `log2`,\n// but hopefully that should be enough for now...\n//\n// Note that mathematically, for any arbitrary `y`:\n//\n//      log_2(x) = log_y(x) / log_y(2)\n//               = log_y(x) / (1 / log_2(y))\n//               = log_y(x) * log_2(y)\n//\n// Hence because `ln` (log_e) is available on all Android we just choose `y = e`\n// and get:\n//\n//      log_2(x) = ln(x) * log_2(e)\n\n#[cfg(not(test))]\npub fn log2f32(f: f32) -> f32 {\n    f.ln() * crate::f32::consts::LOG2_E\n}\n\n#[cfg(not(test))]\npub fn log2f64(f: f64) -> f64 {\n    f.ln() * crate::f64::consts::LOG2_E\n}\n\n// Back in the day [1] the `signal` function was just an inline wrapper\n// around `bsd_signal`, but starting in API level android-20 the `signal`\n// symbols was introduced [2]. Finally, in android-21 the API `bsd_signal` was\n// removed [3].\n//\n// Basically this means that if we want to be binary compatible with multiple\n// Android releases (oldest being 9 and newest being 21) then we need to check\n// for both symbols and not actually link against either.\n//\n// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n//                                       /android-18/arch-arm/usr/include/signal.h\n// [2]: https://chromium.googlesource.com/android_tools/+/fbd420/ndk_experimental\n//                                       /platforms/android-20/arch-arm\n//                                       /usr/include/signal.h\n// [3]: https://chromium.googlesource.com/android_tools/+/20ee6d/ndk/platforms\n//                                       /android-21/arch-arm/usr/include/signal.h\npub unsafe fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t {\n    weak!(fn signal(c_int, sighandler_t) -> sighandler_t);\n    weak!(fn bsd_signal(c_int, sighandler_t) -> sighandler_t);\n\n    let f = signal.get().or_else(|| bsd_signal.get());\n    let f = f.expect(\"neither `signal` nor `bsd_signal` symbols found\");\n    f(signum, handler)\n}\n\n// The `ftruncate64` symbol apparently appeared in android-12, so we do some\n// dynamic detection to see if we can figure out whether `ftruncate64` exists.\n//\n// If it doesn't we just fall back to `ftruncate`, generating an error for\n// too-large values.\n#[cfg(target_pointer_width = \"32\")]\npub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n    weak!(fn ftruncate64(c_int, i64) -> c_int);\n\n    unsafe {\n        match ftruncate64.get() {\n            Some(f) => cvt_r(|| f(fd, size as i64)).map(drop),\n            None => {\n                if size > i32::MAX as u64 {\n                    Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot truncate >2GB\"))\n                } else {\n                    cvt_r(|| ftruncate(fd, size as i32)).map(drop)\n                }\n            }\n        }\n    }\n}\n\n#[cfg(target_pointer_width = \"64\")]\npub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n    unsafe { cvt_r(|| ftruncate(fd, size as i64)).map(drop) }\n}\n\n#[cfg(target_pointer_width = \"32\")]\npub unsafe fn cvt_pread64(\n    fd: c_int,\n    buf: *mut c_void,\n    count: size_t,\n    offset: i64,\n) -> io::Result<ssize_t> {\n    use crate::convert::TryInto;\n    weak!(fn pread64(c_int, *mut c_void, size_t, i64) -> ssize_t);\n    pread64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n        if let Ok(o) = offset.try_into() {\n            cvt(pread(fd, buf, count, o))\n        } else {\n            Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot pread >2GB\"))\n        }\n    })\n}\n\n#[cfg(target_pointer_width = \"32\")]\npub unsafe fn cvt_pwrite64(\n    fd: c_int,\n    buf: *const c_void,\n    count: size_t,\n    offset: i64,\n) -> io::Result<ssize_t> {\n    use crate::convert::TryInto;\n    weak!(fn pwrite64(c_int, *const c_void, size_t, i64) -> ssize_t);\n    pwrite64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n        if let Ok(o) = offset.try_into() {\n            cvt(pwrite(fd, buf, count, o))\n        } else {\n            Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot pwrite >2GB\"))\n        }\n    })\n}\n\n#[cfg(target_pointer_width = \"64\")]\npub unsafe fn cvt_pread64(\n    fd: c_int,\n    buf: *mut c_void,\n    count: size_t,\n    offset: i64,\n) -> io::Result<ssize_t> {\n    cvt(pread(fd, buf, count, offset))\n}\n\n#[cfg(target_pointer_width = \"64\")]\npub unsafe fn cvt_pwrite64(\n    fd: c_int,\n    buf: *const c_void,\n    count: size_t,\n    offset: i64,\n) -> io::Result<ssize_t> {\n    cvt(pwrite(fd, buf, count, offset))\n}\n"],["2465","macro_rules! unimpl {\n    () => {\n        return Err(io::Error::new_const(\n            io::ErrorKind::Unsupported,\n            &\"No networking available on L4Re.\",\n        ));\n    };\n}\n\npub mod net {\n    #![allow(warnings)]\n    use crate::convert::TryFrom;\n    use crate::fmt;\n    use crate::io::{self, IoSlice, IoSliceMut};\n    use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n    use crate::sys::fd::FileDesc;\n    use crate::sys_common::{AsInner, FromInner, IntoInner};\n    use crate::time::Duration;\n\n    #[allow(unused_extern_crates)]\n    pub extern crate libc as netc;\n\n    pub struct Socket(FileDesc);\n    impl Socket {\n        pub fn new(_: &SocketAddr, _: libc::c_int) -> io::Result<Socket> {\n            unimpl!();\n        }\n\n        pub fn new_raw(_: libc::c_int, _: libc::c_int) -> io::Result<Socket> {\n            unimpl!();\n        }\n\n        pub fn new_pair(_: libc::c_int, _: libc::c_int) -> io::Result<(Socket, Socket)> {\n            unimpl!();\n        }\n\n        pub fn connect_timeout(&self, _: &SocketAddr, _: Duration) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn accept(\n            &self,\n            _: *mut libc::sockaddr,\n            _: *mut libc::socklen_t,\n        ) -> io::Result<Socket> {\n            unimpl!();\n        }\n\n        pub fn duplicate(&self) -> io::Result<Socket> {\n            unimpl!();\n        }\n\n        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn is_read_vectored(&self) -> bool {\n            unimpl!();\n        }\n\n        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn is_write_vectored(&self) -> bool {\n            unimpl!();\n        }\n\n        pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn timeout(&self, _: libc::c_int) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn nodelay(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n            unimpl!();\n        }\n    }\n\n    impl AsInner<libc::c_int> for Socket {\n        fn as_inner(&self) -> &libc::c_int {\n            self.0.as_inner()\n        }\n    }\n\n    impl FromInner<libc::c_int> for Socket {\n        fn from_inner(fd: libc::c_int) -> Socket {\n            Socket(FileDesc::new(fd))\n        }\n    }\n\n    impl IntoInner<libc::c_int> for Socket {\n        fn into_inner(self) -> libc::c_int {\n            self.0.into_raw()\n        }\n    }\n\n    pub struct TcpStream {\n        inner: Socket,\n    }\n\n    impl TcpStream {\n        pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n            unimpl!();\n        }\n\n        pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n            unimpl!();\n        }\n\n        pub fn socket(&self) -> &Socket {\n            &self.inner\n        }\n\n        pub fn into_socket(self) -> Socket {\n            self.inner\n        }\n\n        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn is_read_vectored(&self) -> bool {\n            unimpl!();\n        }\n\n        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn is_write_vectored(&self) -> bool {\n            unimpl!();\n        }\n\n        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn duplicate(&self) -> io::Result<TcpStream> {\n            unimpl!();\n        }\n\n        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn nodelay(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn ttl(&self) -> io::Result<u32> {\n            unimpl!();\n        }\n\n        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n            unimpl!();\n        }\n\n        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n    }\n\n    impl FromInner<Socket> for TcpStream {\n        fn from_inner(socket: Socket) -> TcpStream {\n            TcpStream { inner: socket }\n        }\n    }\n\n    impl fmt::Debug for TcpStream {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"No networking support available on L4Re\")\n        }\n    }\n\n    pub struct TcpListener {\n        inner: Socket,\n    }\n\n    impl TcpListener {\n        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n            unimpl!();\n        }\n\n        pub fn socket(&self) -> &Socket {\n            &self.inner\n        }\n\n        pub fn into_socket(self) -> Socket {\n            self.inner\n        }\n\n        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn duplicate(&self) -> io::Result<TcpListener> {\n            unimpl!();\n        }\n\n        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn ttl(&self) -> io::Result<u32> {\n            unimpl!();\n        }\n\n        pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn only_v6(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n            unimpl!();\n        }\n\n        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n    }\n\n    impl FromInner<Socket> for TcpListener {\n        fn from_inner(socket: Socket) -> TcpListener {\n            TcpListener { inner: socket }\n        }\n    }\n\n    impl fmt::Debug for TcpListener {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"No networking support available on L4Re.\")\n        }\n    }\n\n    pub struct UdpSocket {\n        inner: Socket,\n    }\n\n    impl UdpSocket {\n        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n            unimpl!();\n        }\n\n        pub fn socket(&self) -> &Socket {\n            &self.inner\n        }\n\n        pub fn into_socket(self) -> Socket {\n            self.inner\n        }\n\n        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n            unimpl!();\n        }\n\n        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n            unimpl!();\n        }\n\n        pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn duplicate(&self) -> io::Result<UdpSocket> {\n            unimpl!();\n        }\n\n        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n            unimpl!();\n        }\n\n        pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn broadcast(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n            unimpl!();\n        }\n\n        pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n            unimpl!();\n        }\n\n        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn ttl(&self) -> io::Result<u32> {\n            unimpl!();\n        }\n\n        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n            unimpl!();\n        }\n\n        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n            unimpl!();\n        }\n\n        pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n            unimpl!();\n        }\n\n        pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n            unimpl!();\n        }\n    }\n\n    impl FromInner<Socket> for UdpSocket {\n        fn from_inner(socket: Socket) -> UdpSocket {\n            UdpSocket { inner: socket }\n        }\n    }\n\n    impl fmt::Debug for UdpSocket {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"No networking support on L4Re available.\")\n        }\n    }\n\n    pub struct LookupHost {\n        original: *mut libc::addrinfo,\n        cur: *mut libc::addrinfo,\n    }\n\n    impl Iterator for LookupHost {\n        type Item = SocketAddr;\n        fn next(&mut self) -> Option<SocketAddr> {\n            None\n        }\n    }\n\n    impl LookupHost {\n        pub fn port(&self) -> u16 {\n            unimpl!();\n        }\n    }\n\n    unsafe impl Sync for LookupHost {}\n    unsafe impl Send for LookupHost {}\n\n    impl TryFrom<&str> for LookupHost {\n        type Error = io::Error;\n\n        fn try_from(_v: &str) -> io::Result<LookupHost> {\n            unimpl!();\n        }\n    }\n\n    impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n        type Error = io::Error;\n\n        fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n            unimpl!();\n        }\n    }\n}\n"],["2466","//! This module contains specializations that can offload `io::copy()` operations on file descriptor\n//! containing types (`File`, `TcpStream`, etc.) to more efficient syscalls than `read(2)` and `write(2)`.\n//!\n//! Specialization is only applied to wholly std-owned types so that user code can't observe\n//! that the `Read` and `Write` traits are not used.\n//!\n//! Since a copy operation involves a reader and writer side where each can consist of different types\n//! and also involve generic wrappers (e.g. `Take`, `BufReader`) it is not practical to specialize\n//! a single method on all possible combinations.\n//!\n//! Instead readers and writers are handled separately by the `CopyRead` and `CopyWrite` specialization\n//! traits and then specialized on by the `Copier::copy` method.\n//!\n//! `Copier` uses the specialization traits to unpack the underlying file descriptors and\n//! additional prerequisites and constraints imposed by the wrapper types.\n//!\n//! Once it has obtained all necessary pieces and brought any wrapper types into a state where they\n//! can be safely bypassed it will attempt to use the `copy_file_range(2)`,\n//! `sendfile(2)` or `splice(2)` syscalls to move data directly between file descriptors.\n//! Since those syscalls have requirements that cannot be fully checked in advance and\n//! gathering additional information about file descriptors would require additional syscalls\n//! anyway it simply attempts to use them one after another (guided by inaccurate hints) to\n//! figure out which one works and and falls back to the generic read-write copy loop if none of them\n//! does.\n//! Once a working syscall is found for a pair of file descriptors it will be called in a loop\n//! until the copy operation is completed.\n//!\n//! Advantages of using these syscalls:\n//!\n//! * fewer context switches since reads and writes are coalesced into a single syscall\n//!   and more bytes are transferred per syscall. This translates to higher throughput\n//!   and fewer CPU cycles, at least for sufficiently large transfers to amortize the initial probing.\n//! * `copy_file_range` creates reflink copies on CoW filesystems, thus moving less data and\n//!   consuming less disk space\n//! * `sendfile` and `splice` can perform zero-copy IO under some circumstances while\n//!   a naive copy loop would move every byte through the CPU.\n//!\n//! Drawbacks:\n//!\n//! * copy operations smaller than the default buffer size can under some circumstances, especially\n//!   on older kernels, incur more syscalls than the naive approach would. As mentioned above\n//!   the syscall selection is guided by hints to minimize this possibility but they are not perfect.\n//! * optimizations only apply to std types. If a user adds a custom wrapper type, e.g. to report\n//!   progress, they can hit a performance cliff.\n//! * complexity\n\nuse crate::cmp::min;\nuse crate::convert::TryInto;\nuse crate::fs::{File, Metadata};\nuse crate::io::copy::generic_copy;\nuse crate::io::{\n    BufRead, BufReader, BufWriter, Error, Read, Result, StderrLock, StdinLock, StdoutLock, Take,\n    Write,\n};\nuse crate::mem::ManuallyDrop;\nuse crate::net::TcpStream;\nuse crate::os::unix::fs::FileTypeExt;\nuse crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\nuse crate::os::unix::net::UnixStream;\nuse crate::process::{ChildStderr, ChildStdin, ChildStdout};\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicBool, AtomicU8, Ordering};\nuse crate::sys::cvt;\nuse libc::{EBADF, EINVAL, ENOSYS, EOPNOTSUPP, EOVERFLOW, EPERM, EXDEV};\n\n#[cfg(test)]\nmod tests;\n\npub(crate) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n    read: &mut R,\n    write: &mut W,\n) -> Result<u64> {\n    let copier = Copier { read, write };\n    SpecCopy::copy(copier)\n}\n\n/// This type represents either the inferred `FileType` of a `RawFd` based on the source\n/// type from which it was extracted or the actual metadata\n///\n/// The methods on this type only provide hints, due to `AsRawFd` and `FromRawFd` the inferred\n/// type may be wrong.\nenum FdMeta {\n    /// We obtained the FD from a type that can contain any type of `FileType` and queried the metadata\n    /// because it is cheaper than probing all possible syscalls (reader side)\n    Metadata(Metadata),\n    Socket,\n    Pipe,\n    /// We don't have any metadata, e.g. because the original type was `File` which can represent\n    /// any `FileType` and we did not query the metadata either since it did not seem beneficial\n    /// (writer side)\n    NoneObtained,\n}\n\nimpl FdMeta {\n    fn maybe_fifo(&self) -> bool {\n        match self {\n            FdMeta::Metadata(meta) => meta.file_type().is_fifo(),\n            FdMeta::Socket => false,\n            FdMeta::Pipe => true,\n            FdMeta::NoneObtained => true,\n        }\n    }\n\n    fn potential_sendfile_source(&self) -> bool {\n        match self {\n            // procfs erronously shows 0 length on non-empty readable files.\n            // and if a file is truly empty then a `read` syscall will determine that and skip the write syscall\n            // thus there would be benefit from attempting sendfile\n            FdMeta::Metadata(meta)\n                if meta.file_type().is_file() && meta.len() > 0\n                    || meta.file_type().is_block_device() =>\n            {\n                true\n            }\n            _ => false,\n        }\n    }\n\n    fn copy_file_range_candidate(&self) -> bool {\n        match self {\n            // copy_file_range will fail on empty procfs files. `read` can determine whether EOF has been reached\n            // without extra cost and skip the write, thus there is no benefit in attempting copy_file_range\n            FdMeta::Metadata(meta) if meta.is_file() && meta.len() > 0 => true,\n            FdMeta::NoneObtained => true,\n            _ => false,\n        }\n    }\n}\n\nstruct CopyParams(FdMeta, Option<RawFd>);\n\nstruct Copier<'a, 'b, R: Read + ?Sized, W: Write + ?Sized> {\n    read: &'a mut R,\n    write: &'b mut W,\n}\n\ntrait SpecCopy {\n    fn copy(self) -> Result<u64>;\n}\n\nimpl<R: Read + ?Sized, W: Write + ?Sized> SpecCopy for Copier<'_, '_, R, W> {\n    default fn copy(self) -> Result<u64> {\n        generic_copy(self.read, self.write)\n    }\n}\n\nimpl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n    fn copy(self) -> Result<u64> {\n        let (reader, writer) = (self.read, self.write);\n        let r_cfg = reader.properties();\n        let w_cfg = writer.properties();\n\n        // before direct operations on file descriptors ensure that all source and sink buffers are empty\n        let mut flush = || -> crate::io::Result<u64> {\n            let bytes = reader.drain_to(writer, u64::MAX)?;\n            // BufWriter buffered bytes have already been accounted for in earlier write() calls\n            writer.flush()?;\n            Ok(bytes)\n        };\n\n        let mut written = 0u64;\n\n        if let (CopyParams(input_meta, Some(readfd)), CopyParams(output_meta, Some(writefd))) =\n            (r_cfg, w_cfg)\n        {\n            written += flush()?;\n            let max_write = reader.min_limit();\n\n            if input_meta.copy_file_range_candidate() && output_meta.copy_file_range_candidate() {\n                let result = copy_regular_files(readfd, writefd, max_write);\n                result.update_take(reader);\n\n                match result {\n                    CopyResult::Ended(bytes_copied) => return Ok(bytes_copied + written),\n                    CopyResult::Error(e, _) => return Err(e),\n                    CopyResult::Fallback(bytes) => written += bytes,\n                }\n            }\n\n            // on modern kernels sendfile can copy from any mmapable type (some but not all regular files and block devices)\n            // to any writable file descriptor. On older kernels the writer side can only be a socket.\n            // So we just try and fallback if needed.\n            // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n            // fall back to the generic copy loop.\n            if input_meta.potential_sendfile_source() {\n                let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n                result.update_take(reader);\n\n                match result {\n                    CopyResult::Ended(bytes_copied) => return Ok(bytes_copied + written),\n                    CopyResult::Error(e, _) => return Err(e),\n                    CopyResult::Fallback(bytes) => written += bytes,\n                }\n            }\n\n            if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n                let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n                result.update_take(reader);\n\n                match result {\n                    CopyResult::Ended(bytes_copied) => return Ok(bytes_copied + written),\n                    CopyResult::Error(e, _) => return Err(e),\n                    CopyResult::Fallback(0) => { /* use the fallback below */ }\n                    CopyResult::Fallback(_) => {\n                        unreachable!(\"splice should not return > 0 bytes on the fallback path\")\n                    }\n                }\n            }\n        }\n\n        // fallback if none of the more specialized syscalls wants to work with these file descriptors\n        match generic_copy(reader, writer) {\n            Ok(bytes) => Ok(bytes + written),\n            err => err,\n        }\n    }\n}\n\n#[rustc_specialization_trait]\ntrait CopyRead: Read {\n    /// Implementations that contain buffers (i.e. `BufReader`) must transfer data from their internal\n    /// buffers into `writer` until either the buffers are emptied or `limit` bytes have been\n    /// transferred, whichever occurs sooner.\n    /// If nested buffers are present the outer buffers must be drained first.\n    ///\n    /// This is necessary to directly bypass the wrapper types while preserving the data order\n    /// when operating directly on the underlying file descriptors.\n    fn drain_to<W: Write>(&mut self, _writer: &mut W, _limit: u64) -> Result<u64> {\n        Ok(0)\n    }\n\n    /// Updates `Take` wrappers to remove the number of bytes copied.\n    fn taken(&mut self, _bytes: u64) {}\n\n    /// The minimum of the limit of all `Take<_>` wrappers, `u64::MAX` otherwise.\n    /// This method does not account for data `BufReader` buffers and would underreport\n    /// the limit of a `Take<BufReader<Take<_>>>` type. Thus its result is only valid\n    /// after draining the buffers via `drain_to`.\n    fn min_limit(&self) -> u64 {\n        u64::MAX\n    }\n\n    /// Extracts the file descriptor and hints/metadata, delegating through wrappers if necessary.\n    fn properties(&self) -> CopyParams;\n}\n\n#[rustc_specialization_trait]\ntrait CopyWrite: Write {\n    /// Extracts the file descriptor and hints/metadata, delegating through wrappers if necessary.\n    fn properties(&self) -> CopyParams;\n}\n\nimpl<T> CopyRead for &mut T\nwhere\n    T: CopyRead,\n{\n    fn drain_to<W: Write>(&mut self, writer: &mut W, limit: u64) -> Result<u64> {\n        (**self).drain_to(writer, limit)\n    }\n\n    fn taken(&mut self, bytes: u64) {\n        (**self).taken(bytes);\n    }\n\n    fn min_limit(&self) -> u64 {\n        (**self).min_limit()\n    }\n\n    fn properties(&self) -> CopyParams {\n        (**self).properties()\n    }\n}\n\nimpl<T> CopyWrite for &mut T\nwhere\n    T: CopyWrite,\n{\n    fn properties(&self) -> CopyParams {\n        (**self).properties()\n    }\n}\n\nimpl CopyRead for File {\n    fn properties(&self) -> CopyParams {\n        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for &File {\n    fn properties(&self) -> CopyParams {\n        CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for File {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for &File {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for TcpStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for &TcpStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for TcpStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for &TcpStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for UnixStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for &UnixStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for UnixStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for &UnixStream {\n    fn properties(&self) -> CopyParams {\n        // avoid the stat syscall since we can be fairly sure it's a socket\n        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for ChildStdin {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for ChildStdout {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for ChildStderr {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyRead for StdinLock<'_> {\n    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n        let buf_reader = self.as_mut_buf();\n        let buf = buf_reader.buffer();\n        let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n        let bytes_drained = buf.len();\n        writer.write_all(buf)?;\n        buf_reader.consume(bytes_drained);\n\n        Ok(bytes_drained as u64)\n    }\n\n    fn properties(&self) -> CopyParams {\n        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for StdoutLock<'_> {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n    }\n}\n\nimpl CopyWrite for StderrLock<'_> {\n    fn properties(&self) -> CopyParams {\n        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n    }\n}\n\nimpl<T: CopyRead> CopyRead for Take<T> {\n    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n        let local_limit = self.limit();\n        let combined_limit = min(outer_limit, local_limit);\n        let bytes_drained = self.get_mut().drain_to(writer, combined_limit)?;\n        // update limit since read() was bypassed\n        self.set_limit(local_limit - bytes_drained);\n\n        Ok(bytes_drained)\n    }\n\n    fn taken(&mut self, bytes: u64) {\n        self.set_limit(self.limit() - bytes);\n        self.get_mut().taken(bytes);\n    }\n\n    fn min_limit(&self) -> u64 {\n        min(Take::limit(self), self.get_ref().min_limit())\n    }\n\n    fn properties(&self) -> CopyParams {\n        self.get_ref().properties()\n    }\n}\n\nimpl<T: CopyRead> CopyRead for BufReader<T> {\n    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n        let buf = self.buffer();\n        let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n        let bytes = buf.len();\n        writer.write_all(buf)?;\n        self.consume(bytes);\n\n        let remaining = outer_limit - bytes as u64;\n\n        // in case of nested bufreaders we also need to drain the ones closer to the source\n        let inner_bytes = self.get_mut().drain_to(writer, remaining)?;\n\n        Ok(bytes as u64 + inner_bytes)\n    }\n\n    fn taken(&mut self, bytes: u64) {\n        self.get_mut().taken(bytes);\n    }\n\n    fn min_limit(&self) -> u64 {\n        self.get_ref().min_limit()\n    }\n\n    fn properties(&self) -> CopyParams {\n        self.get_ref().properties()\n    }\n}\n\nimpl<T: CopyWrite> CopyWrite for BufWriter<T> {\n    fn properties(&self) -> CopyParams {\n        self.get_ref().properties()\n    }\n}\n\nfn fd_to_meta<T: AsRawFd>(fd: &T) -> FdMeta {\n    let fd = fd.as_raw_fd();\n    let file: ManuallyDrop<File> = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });\n    match file.metadata() {\n        Ok(meta) => FdMeta::Metadata(meta),\n        Err(_) => FdMeta::NoneObtained,\n    }\n}\n\npub(super) enum CopyResult {\n    Ended(u64),\n    Error(Error, u64),\n    Fallback(u64),\n}\n\nimpl CopyResult {\n    fn update_take(&self, reader: &mut impl CopyRead) {\n        match *self {\n            CopyResult::Fallback(bytes)\n            | CopyResult::Ended(bytes)\n            | CopyResult::Error(_, bytes) => reader.taken(bytes),\n        }\n    }\n}\n\n/// Invalid file descriptor.\n///\n/// Valid file descriptors are guaranteed to be positive numbers (see `open()` manpage)\n/// while negative values are used to indicate errors.\n/// Thus -1 will never be overlap with a valid open file.\nconst INVALID_FD: RawFd = -1;\n\n/// Linux-specific implementation that will attempt to use copy_file_range for copy offloading.\n/// As the name says, it only works on regular files.\n///\n/// Callers must handle fallback to a generic copy loop.\n/// `Fallback` may indicate non-zero number of bytes already written\n/// if one of the files' cursor +`max_len` would exceed u64::MAX (`EOVERFLOW`).\npub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n    use crate::cmp;\n\n    const NOT_PROBED: u8 = 0;\n    const UNAVAILABLE: u8 = 1;\n    const AVAILABLE: u8 = 2;\n\n    // Kernel prior to 4.5 don't have copy_file_range\n    // We store the availability in a global to avoid unnecessary syscalls\n    static HAS_COPY_FILE_RANGE: AtomicU8 = AtomicU8::new(NOT_PROBED);\n\n    syscall! {\n        fn copy_file_range(\n            fd_in: libc::c_int,\n            off_in: *mut libc::loff_t,\n            fd_out: libc::c_int,\n            off_out: *mut libc::loff_t,\n            len: libc::size_t,\n            flags: libc::c_uint\n        ) -> libc::ssize_t\n    }\n\n    match HAS_COPY_FILE_RANGE.load(Ordering::Relaxed) {\n        NOT_PROBED => {\n            // EPERM can indicate seccomp filters or an immutable file.\n            // To distinguish these cases we probe with invalid file descriptors which should result in EBADF if the syscall is supported\n            // and some other error (ENOSYS or EPERM) if it's not available\n            let result = unsafe {\n                cvt(copy_file_range(INVALID_FD, ptr::null_mut(), INVALID_FD, ptr::null_mut(), 1, 0))\n            };\n\n            if matches!(result.map_err(|e| e.raw_os_error()), Err(Some(EBADF))) {\n                HAS_COPY_FILE_RANGE.store(AVAILABLE, Ordering::Relaxed);\n            } else {\n                HAS_COPY_FILE_RANGE.store(UNAVAILABLE, Ordering::Relaxed);\n                return CopyResult::Fallback(0);\n            }\n        }\n        UNAVAILABLE => return CopyResult::Fallback(0),\n        _ => {}\n    };\n\n    let mut written = 0u64;\n    while written < max_len {\n        let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n        // cap to 1GB chunks in case u64::MAX is passed as max_len and the file has a non-zero seek position\n        // this allows us to copy large chunks without hitting EOVERFLOW,\n        // unless someone sets a file offset close to u64::MAX - 1GB, in which case a fallback would be required\n        let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x4000_0000usize);\n        let copy_result = unsafe {\n            // We actually don't have to adjust the offsets,\n            // because copy_file_range adjusts the file offset automatically\n            cvt(copy_file_range(reader, ptr::null_mut(), writer, ptr::null_mut(), bytes_to_copy, 0))\n        };\n\n        match copy_result {\n            Ok(0) if written == 0 => {\n                // fallback to work around several kernel bugs where copy_file_range will fail to\n                // copy any bytes and return 0 instead of an error if\n                // - reading virtual files from the proc filesystem which appear to have 0 size\n                //   but are not empty. noted in coreutils to affect kernels at least up to 5.6.19.\n                // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n                return CopyResult::Fallback(0);\n            }\n            Ok(0) => return CopyResult::Ended(written), // reached EOF\n            Ok(ret) => written += ret as u64,\n            Err(err) => {\n                return match err.raw_os_error() {\n                    // when file offset + max_length > u64::MAX\n                    Some(EOVERFLOW) => CopyResult::Fallback(written),\n                    Some(ENOSYS | EXDEV | EINVAL | EPERM | EOPNOTSUPP | EBADF) => {\n                        // Try fallback io::copy if either:\n                        // - Kernel version is < 4.5 (ENOSYS)\n                        // - Files are mounted on different fs (EXDEV)\n                        // - copy_file_range is broken in various ways on RHEL/CentOS 7 (EOPNOTSUPP)\n                        // - copy_file_range file is immutable or syscall is blocked by seccomp (EPERM)\n                        // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n                        // - the writer fd was opened with O_APPEND (EBADF)\n                        //\n                        //  these cases should be detected by the initial probe but we handle them here\n                        //   anyway in case syscall interception changes during runtime\n                        //  actually invalid file descriptors would cause this too, but in that case\n                        //   the fallback code path is expected to encounter the same error again\n                        assert_eq!(written, 0);\n                        CopyResult::Fallback(0)\n                    }\n                    _ => CopyResult::Error(err, written),\n                };\n            }\n        }\n    }\n    CopyResult::Ended(written)\n}\n\n#[derive(PartialEq)]\nenum SpliceMode {\n    Sendfile,\n    Splice,\n}\n\n/// performs splice or sendfile between file descriptors\n/// Does _not_ fall back to a generic copy loop.\nfn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) -> CopyResult {\n    static HAS_SENDFILE: AtomicBool = AtomicBool::new(true);\n    static HAS_SPLICE: AtomicBool = AtomicBool::new(true);\n\n    syscall! {\n        fn splice(\n            srcfd: libc::c_int,\n            src_offset: *const i64,\n            dstfd: libc::c_int,\n            dst_offset: *const i64,\n            len: libc::size_t,\n            flags: libc::c_int\n        ) -> libc::ssize_t\n    }\n\n    match mode {\n        SpliceMode::Sendfile if !HAS_SENDFILE.load(Ordering::Relaxed) => {\n            return CopyResult::Fallback(0);\n        }\n        SpliceMode::Splice if !HAS_SPLICE.load(Ordering::Relaxed) => {\n            return CopyResult::Fallback(0);\n        }\n        _ => (),\n    }\n\n    let mut written = 0u64;\n    while written < len {\n        // according to its manpage that's the maximum size sendfile() will copy per invocation\n        let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n\n        let result = match mode {\n            SpliceMode::Sendfile => {\n                cvt(unsafe { libc::sendfile(writer, reader, ptr::null_mut(), chunk_size) })\n            }\n            SpliceMode::Splice => cvt(unsafe {\n                splice(reader, ptr::null_mut(), writer, ptr::null_mut(), chunk_size, 0)\n            }),\n        };\n\n        match result {\n            Ok(0) => break, // EOF\n            Ok(ret) => written += ret as u64,\n            Err(err) => {\n                return match err.raw_os_error() {\n                    Some(ENOSYS | EPERM) => {\n                        // syscall not supported (ENOSYS)\n                        // syscall is disallowed, e.g. by seccomp (EPERM)\n                        match mode {\n                            SpliceMode::Sendfile => HAS_SENDFILE.store(false, Ordering::Relaxed),\n                            SpliceMode::Splice => HAS_SPLICE.store(false, Ordering::Relaxed),\n                        }\n                        assert_eq!(written, 0);\n                        CopyResult::Fallback(0)\n                    }\n                    Some(EINVAL) => {\n                        // splice/sendfile do not support this particular file descriptor (EINVAL)\n                        assert_eq!(written, 0);\n                        CopyResult::Fallback(0)\n                    }\n                    Some(os_err) if mode == SpliceMode::Sendfile && os_err == EOVERFLOW => {\n                        CopyResult::Fallback(written)\n                    }\n                    _ => CopyResult::Error(err, written),\n                };\n            }\n        }\n    }\n    CopyResult::Ended(written)\n}\n"],["2467","#![cfg(not(test))]\n\n// These symbols are all defined by `libm`,\n// or by `compiler-builtins` on unsupported platforms.\n\nextern \"C\" {\n    pub fn acos(n: f64) -> f64;\n    pub fn acosf(n: f32) -> f32;\n    pub fn asin(n: f64) -> f64;\n    pub fn asinf(n: f32) -> f32;\n    pub fn atan(n: f64) -> f64;\n    pub fn atan2(a: f64, b: f64) -> f64;\n    pub fn atan2f(a: f32, b: f32) -> f32;\n    pub fn atanf(n: f32) -> f32;\n    pub fn cbrt(n: f64) -> f64;\n    pub fn cbrtf(n: f32) -> f32;\n    pub fn cosh(n: f64) -> f64;\n    pub fn coshf(n: f32) -> f32;\n    pub fn expm1(n: f64) -> f64;\n    pub fn expm1f(n: f32) -> f32;\n    pub fn fdim(a: f64, b: f64) -> f64;\n    pub fn fdimf(a: f32, b: f32) -> f32;\n    pub fn hypot(x: f64, y: f64) -> f64;\n    pub fn hypotf(x: f32, y: f32) -> f32;\n    pub fn log1p(n: f64) -> f64;\n    pub fn log1pf(n: f32) -> f32;\n    pub fn sinh(n: f64) -> f64;\n    pub fn sinhf(n: f32) -> f32;\n    pub fn tan(n: f64) -> f64;\n    pub fn tanf(n: f32) -> f32;\n    pub fn tanh(n: f64) -> f64;\n    pub fn tanhf(n: f32) -> f32;\n}\n"],["2468","//! Global initialization and retrieval of command line arguments.\n//!\n//! On some platforms these are stored during runtime startup,\n//! and on some they are retrieved from the system on demand.\n\n#![allow(dead_code)] // runtime init functions not used during testing\n\nuse crate::ffi::OsString;\nuse crate::fmt;\nuse crate::vec;\n\n/// One-time global initialization.\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    imp::init(argc, argv)\n}\n\n/// One-time global cleanup.\npub unsafe fn cleanup() {\n    imp::cleanup()\n}\n\n/// Returns the command line arguments\npub fn args() -> Args {\n    imp::args()\n}\n\npub struct Args {\n    iter: vec::IntoIter<OsString>,\n}\n\nimpl !Send for Args {}\nimpl !Sync for Args {}\n\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.iter.as_slice().fmt(f)\n    }\n}\n\nimpl Iterator for Args {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}\n\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<OsString> {\n        self.iter.next_back()\n    }\n}\n\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"android\",\n    target_os = \"freebsd\",\n    target_os = \"dragonfly\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n    target_os = \"solaris\",\n    target_os = \"illumos\",\n    target_os = \"emscripten\",\n    target_os = \"haiku\",\n    target_os = \"l4re\",\n    target_os = \"fuchsia\",\n    target_os = \"redox\",\n    target_os = \"vxworks\"\n))]\nmod imp {\n    use super::Args;\n    use crate::ffi::{CStr, OsString};\n    use crate::os::unix::prelude::*;\n    use crate::ptr;\n    use crate::sync::atomic::{AtomicIsize, AtomicPtr, Ordering};\n\n    use crate::sys_common::mutex::StaticMutex;\n\n    static ARGC: AtomicIsize = AtomicIsize::new(0);\n    static ARGV: AtomicPtr<*const u8> = AtomicPtr::new(ptr::null_mut());\n    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n    // acquire this mutex reentrantly!\n    static LOCK: StaticMutex = StaticMutex::new();\n\n    unsafe fn really_init(argc: isize, argv: *const *const u8) {\n        let _guard = LOCK.lock();\n        ARGC.store(argc, Ordering::Relaxed);\n        ARGV.store(argv as *mut _, Ordering::Relaxed);\n    }\n\n    #[inline(always)]\n    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n        // On Linux-GNU, we rely on `ARGV_INIT_ARRAY` below to initialize\n        // `ARGC` and `ARGV`. But in Miri that does not actually happen so we\n        // still initialize here.\n        #[cfg(any(miri, not(all(target_os = \"linux\", target_env = \"gnu\"))))]\n        really_init(_argc, _argv);\n    }\n\n    /// glibc passes argc, argv, and envp to functions in .init_array, as a non-standard extension.\n    /// This allows `std::env::args` to work even in a `cdylib`, as it does on macOS and Windows.\n    #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n    #[used]\n    #[link_section = \".init_array.00099\"]\n    static ARGV_INIT_ARRAY: extern \"C\" fn(\n        crate::os::raw::c_int,\n        *const *const u8,\n        *const *const u8,\n    ) = {\n        extern \"C\" fn init_wrapper(\n            argc: crate::os::raw::c_int,\n            argv: *const *const u8,\n            _envp: *const *const u8,\n        ) {\n            unsafe {\n                really_init(argc as isize, argv);\n            }\n        }\n        init_wrapper\n    };\n\n    pub unsafe fn cleanup() {\n        let _guard = LOCK.lock();\n        ARGC.store(0, Ordering::Relaxed);\n        ARGV.store(ptr::null_mut(), Ordering::Relaxed);\n    }\n\n    pub fn args() -> Args {\n        Args { iter: clone().into_iter() }\n    }\n\n    fn clone() -> Vec<OsString> {\n        unsafe {\n            let _guard = LOCK.lock();\n            let argc = ARGC.load(Ordering::Relaxed);\n            let argv = ARGV.load(Ordering::Relaxed);\n            (0..argc)\n                .map(|i| {\n                    let cstr = CStr::from_ptr(*argv.offset(i) as *const libc::c_char);\n                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n                })\n                .collect()\n        }\n    }\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\nmod imp {\n    use super::Args;\n    use crate::ffi::CStr;\n\n    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n\n    pub fn cleanup() {}\n\n    #[cfg(target_os = \"macos\")]\n    pub fn args() -> Args {\n        use crate::os::unix::prelude::*;\n        extern \"C\" {\n            // These functions are in crt_externs.h.\n            fn _NSGetArgc() -> *mut libc::c_int;\n            fn _NSGetArgv() -> *mut *mut *mut libc::c_char;\n        }\n\n        let vec = unsafe {\n            let (argc, argv) =\n                (*_NSGetArgc() as isize, *_NSGetArgv() as *const *const libc::c_char);\n            (0..argc as isize)\n                .map(|i| {\n                    let bytes = CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec();\n                    OsStringExt::from_vec(bytes)\n                })\n                .collect::<Vec<_>>()\n        };\n        Args { iter: vec.into_iter() }\n    }\n\n    // As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n    // and use underscores in their names - they're most probably\n    // are considered private and therefore should be avoided\n    // Here is another way to get arguments using Objective C\n    // runtime\n    //\n    // In general it looks like:\n    // res = Vec::new()\n    // let args = [[NSProcessInfo processInfo] arguments]\n    // for i in (0..[args count])\n    //      res.push([args objectAtIndex:i])\n    // res\n    #[cfg(target_os = \"ios\")]\n    pub fn args() -> Args {\n        use crate::ffi::OsString;\n        use crate::mem;\n        use crate::str;\n\n        extern \"C\" {\n            fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n            fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n        }\n\n        #[cfg(target_arch = \"aarch64\")]\n        extern \"C\" {\n            fn objc_msgSend(obj: NsId, sel: Sel) -> NsId;\n            #[allow(clashing_extern_declarations)]\n            #[link_name = \"objc_msgSend\"]\n            fn objc_msgSend_ul(obj: NsId, sel: Sel, i: libc::c_ulong) -> NsId;\n        }\n\n        #[cfg(not(target_arch = \"aarch64\"))]\n        extern \"C\" {\n            fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n            #[allow(clashing_extern_declarations)]\n            #[link_name = \"objc_msgSend\"]\n            fn objc_msgSend_ul(obj: NsId, sel: Sel, ...) -> NsId;\n        }\n\n        type Sel = *const libc::c_void;\n        type NsId = *const libc::c_void;\n\n        let mut res = Vec::new();\n\n        unsafe {\n            let process_info_sel = sel_registerName(\"processInfo\\0\".as_ptr());\n            let arguments_sel = sel_registerName(\"arguments\\0\".as_ptr());\n            let utf8_sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n            let count_sel = sel_registerName(\"count\\0\".as_ptr());\n            let object_at_sel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n\n            let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n            let info = objc_msgSend(klass, process_info_sel);\n            let args = objc_msgSend(info, arguments_sel);\n\n            let cnt: usize = mem::transmute(objc_msgSend(args, count_sel));\n            for i in 0..cnt {\n                let tmp = objc_msgSend_ul(args, object_at_sel, i as libc::c_ulong);\n                let utf_c_str: *const libc::c_char = mem::transmute(objc_msgSend(tmp, utf8_sel));\n                let bytes = CStr::from_ptr(utf_c_str).to_bytes();\n                res.push(OsString::from(str::from_utf8(bytes).unwrap()))\n            }\n        }\n\n        Args { iter: res.into_iter() }\n    }\n}\n"],["2469","use crate::cmp::Ordering;\nuse crate::time::Duration;\n\nuse core::hash::{Hash, Hasher};\n\npub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\nuse crate::convert::TryInto;\n\nconst NSEC_PER_SEC: u64 = 1_000_000_000;\n\n#[derive(Copy, Clone)]\nstruct Timespec {\n    t: libc::timespec,\n}\n\nimpl Timespec {\n    const fn zero() -> Timespec {\n        Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } }\n    }\n\n    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n        if self >= other {\n            // NOTE(eddyb) two aspects of this `if`-`else` are required for LLVM\n            // to optimize it into a branchless form (see also #75545):\n            //\n            // 1. `self.t.tv_sec - other.t.tv_sec` shows up as a common expression\n            //    in both branches, i.e. the `else` must have its `- 1`\n            //    subtraction after the common one, not interleaved with it\n            //    (it used to be `self.t.tv_sec - 1 - other.t.tv_sec`)\n            //\n            // 2. the `Duration::new` call (or any other additional complexity)\n            //    is outside of the `if`-`else`, not duplicated in both branches\n            //\n            // Ideally this code could be rearranged such that it more\n            // directly expresses the lower-cost behavior we want from it.\n            let (secs, nsec) = if self.t.tv_nsec >= other.t.tv_nsec {\n                ((self.t.tv_sec - other.t.tv_sec) as u64, (self.t.tv_nsec - other.t.tv_nsec) as u32)\n            } else {\n                (\n                    (self.t.tv_sec - other.t.tv_sec - 1) as u64,\n                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n                )\n            };\n\n            Ok(Duration::new(secs, nsec))\n        } else {\n            match other.sub_timespec(self) {\n                Ok(d) => Err(d),\n                Err(d) => Ok(d),\n            }\n        }\n    }\n\n    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n        let mut secs = other\n            .as_secs()\n            .try_into() // <- target type would be `libc::time_t`\n            .ok()\n            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n\n        // Nano calculations can't overflow because nanos are <1B which fit\n        // in a u32.\n        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n        if nsec >= NSEC_PER_SEC as u32 {\n            nsec -= NSEC_PER_SEC as u32;\n            secs = secs.checked_add(1)?;\n        }\n        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n    }\n\n    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n        let mut secs = other\n            .as_secs()\n            .try_into() // <- target type would be `libc::time_t`\n            .ok()\n            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n\n        // Similar to above, nanos can't overflow.\n        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n        if nsec < 0 {\n            nsec += NSEC_PER_SEC as i32;\n            secs = secs.checked_sub(1)?;\n        }\n        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n    }\n}\n\nimpl PartialEq for Timespec {\n    fn eq(&self, other: &Timespec) -> bool {\n        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n    }\n}\n\nimpl Eq for Timespec {}\n\nimpl PartialOrd for Timespec {\n    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Timespec {\n    fn cmp(&self, other: &Timespec) -> Ordering {\n        let me = (self.t.tv_sec, self.t.tv_nsec);\n        let other = (other.t.tv_sec, other.t.tv_nsec);\n        me.cmp(&other)\n    }\n}\n\nimpl Hash for Timespec {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.t.tv_sec.hash(state);\n        self.t.tv_nsec.hash(state);\n    }\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\nmod inner {\n    use crate::fmt;\n    use crate::sync::atomic::{AtomicU64, Ordering};\n    use crate::sys::cvt;\n    use crate::sys_common::mul_div_u64;\n    use crate::time::Duration;\n\n    use super::Timespec;\n    use super::NSEC_PER_SEC;\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n    pub struct Instant {\n        t: u64,\n    }\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct SystemTime {\n        t: Timespec,\n    }\n\n    pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n\n    #[repr(C)]\n    #[derive(Copy, Clone)]\n    struct mach_timebase_info {\n        numer: u32,\n        denom: u32,\n    }\n    type mach_timebase_info_t = *mut mach_timebase_info;\n    type kern_return_t = libc::c_int;\n\n    impl Instant {\n        pub fn now() -> Instant {\n            extern \"C\" {\n                fn mach_absolute_time() -> u64;\n            }\n            Instant { t: unsafe { mach_absolute_time() } }\n        }\n\n        pub const fn zero() -> Instant {\n            Instant { t: 0 }\n        }\n\n        pub fn actually_monotonic() -> bool {\n            true\n        }\n\n        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n            let diff = self.t.checked_sub(other.t)?;\n            let info = info();\n            let nanos = mul_div_u64(diff, info.numer as u64, info.denom as u64);\n            Some(Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32))\n        }\n\n        pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n            Some(Instant { t: self.t.checked_add(checked_dur2intervals(other)?)? })\n        }\n\n        pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n            Some(Instant { t: self.t.checked_sub(checked_dur2intervals(other)?)? })\n        }\n    }\n\n    impl SystemTime {\n        pub fn now() -> SystemTime {\n            use crate::ptr;\n\n            let mut s = libc::timeval { tv_sec: 0, tv_usec: 0 };\n            cvt(unsafe { libc::gettimeofday(&mut s, ptr::null_mut()) }).unwrap();\n            return SystemTime::from(s);\n        }\n\n        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n            self.t.sub_timespec(&other.t)\n        }\n\n        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n            Some(SystemTime { t: self.t.checked_add_duration(other)? })\n        }\n\n        pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n            Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n        }\n    }\n\n    impl From<libc::timeval> for SystemTime {\n        fn from(t: libc::timeval) -> SystemTime {\n            SystemTime::from(libc::timespec {\n                tv_sec: t.tv_sec,\n                tv_nsec: (t.tv_usec * 1000) as libc::c_long,\n            })\n        }\n    }\n\n    impl From<libc::timespec> for SystemTime {\n        fn from(t: libc::timespec) -> SystemTime {\n            SystemTime { t: Timespec { t } }\n        }\n    }\n\n    impl fmt::Debug for SystemTime {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"SystemTime\")\n                .field(\"tv_sec\", &self.t.t.tv_sec)\n                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n                .finish()\n        }\n    }\n\n    fn checked_dur2intervals(dur: &Duration) -> Option<u64> {\n        let nanos =\n            dur.as_secs().checked_mul(NSEC_PER_SEC)?.checked_add(dur.subsec_nanos() as u64)?;\n        let info = info();\n        Some(mul_div_u64(nanos, info.denom as u64, info.numer as u64))\n    }\n\n    fn info() -> mach_timebase_info {\n        // INFO_BITS conceptually is an `Option<mach_timebase_info>`. We can do\n        // this in 64 bits because we know 0 is never a valid value for the\n        // `denom` field.\n        //\n        // Encoding this as a single `AtomicU64` allows us to use `Relaxed`\n        // operations, as we are only interested in the effects on a single\n        // memory location.\n        static INFO_BITS: AtomicU64 = AtomicU64::new(0);\n\n        // If a previous thread has initialized `INFO_BITS`, use it.\n        let info_bits = INFO_BITS.load(Ordering::Relaxed);\n        if info_bits != 0 {\n            return info_from_bits(info_bits);\n        }\n\n        // ... otherwise learn for ourselves ...\n        extern \"C\" {\n            fn mach_timebase_info(info: mach_timebase_info_t) -> kern_return_t;\n        }\n\n        let mut info = info_from_bits(0);\n        unsafe {\n            mach_timebase_info(&mut info);\n        }\n        INFO_BITS.store(info_to_bits(info), Ordering::Relaxed);\n        info\n    }\n\n    #[inline]\n    fn info_to_bits(info: mach_timebase_info) -> u64 {\n        ((info.denom as u64) << 32) | (info.numer as u64)\n    }\n\n    #[inline]\n    fn info_from_bits(bits: u64) -> mach_timebase_info {\n        mach_timebase_info { numer: bits as u32, denom: (bits >> 32) as u32 }\n    }\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\nmod inner {\n    use crate::fmt;\n    use crate::sys::cvt;\n    use crate::time::Duration;\n\n    use super::Timespec;\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct Instant {\n        t: Timespec,\n    }\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct SystemTime {\n        t: Timespec,\n    }\n\n    pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n\n    impl Instant {\n        pub fn now() -> Instant {\n            Instant { t: now(libc::CLOCK_MONOTONIC) }\n        }\n\n        pub const fn zero() -> Instant {\n            Instant { t: Timespec::zero() }\n        }\n\n        pub fn actually_monotonic() -> bool {\n            (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86_64\"))\n                || (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86\"))\n                || cfg!(target_os = \"fuchsia\")\n        }\n\n        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n            self.t.sub_timespec(&other.t).ok()\n        }\n\n        pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n            Some(Instant { t: self.t.checked_add_duration(other)? })\n        }\n\n        pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n            Some(Instant { t: self.t.checked_sub_duration(other)? })\n        }\n    }\n\n    impl fmt::Debug for Instant {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"Instant\")\n                .field(\"tv_sec\", &self.t.t.tv_sec)\n                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n                .finish()\n        }\n    }\n\n    impl SystemTime {\n        pub fn now() -> SystemTime {\n            SystemTime { t: now(libc::CLOCK_REALTIME) }\n        }\n\n        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n            self.t.sub_timespec(&other.t)\n        }\n\n        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n            Some(SystemTime { t: self.t.checked_add_duration(other)? })\n        }\n\n        pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n            Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n        }\n    }\n\n    impl From<libc::timespec> for SystemTime {\n        fn from(t: libc::timespec) -> SystemTime {\n            SystemTime { t: Timespec { t } }\n        }\n    }\n\n    impl fmt::Debug for SystemTime {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"SystemTime\")\n                .field(\"tv_sec\", &self.t.t.tv_sec)\n                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n                .finish()\n        }\n    }\n\n    #[cfg(not(target_os = \"dragonfly\"))]\n    pub type clock_t = libc::c_int;\n    #[cfg(target_os = \"dragonfly\")]\n    pub type clock_t = libc::c_ulong;\n\n    fn now(clock: clock_t) -> Timespec {\n        let mut t = Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } };\n        cvt(unsafe { libc::clock_gettime(clock, &mut t.t) }).unwrap();\n        t\n    }\n}\n"],["2470","#![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::cmp;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\nuse crate::mem;\nuse crate::sys::cvt;\nuse crate::sys_common::AsInner;\n\nuse libc::{c_int, c_void};\n\n#[derive(Debug)]\n#[rustc_layout_scalar_valid_range_start(0)]\n// libstd/os/raw/mod.rs assures me that every libstd-supported platform has a\n// 32-bit c_int. Below is -2, in two's complement, but that only works out\n// because c_int is 32 bits.\n#[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\npub struct FileDesc {\n    fd: c_int,\n}\n\n// The maximum read limit on most POSIX-like systems is `SSIZE_MAX`,\n// with the man page quoting that if the count of bytes to read is\n// greater than `SSIZE_MAX` the result is \"unspecified\".\n//\n// On macOS, however, apparently the 64-bit libc is either buggy or\n// intentionally showing odd behavior by rejecting any read with a size\n// larger than or equal to INT_MAX. To handle both of these the read\n// size is capped on both platforms.\n#[cfg(target_os = \"macos\")]\nconst READ_LIMIT: usize = c_int::MAX as usize - 1;\n#[cfg(not(target_os = \"macos\"))]\nconst READ_LIMIT: usize = libc::ssize_t::MAX as usize;\n\n#[cfg(any(\n    target_os = \"dragonfly\",\n    target_os = \"freebsd\",\n    target_os = \"ios\",\n    target_os = \"macos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n))]\nconst fn max_iov() -> usize {\n    libc::IOV_MAX as usize\n}\n\n#[cfg(any(target_os = \"android\", target_os = \"emscripten\", target_os = \"linux\"))]\nconst fn max_iov() -> usize {\n    libc::UIO_MAXIOV as usize\n}\n\n#[cfg(not(any(\n    target_os = \"android\",\n    target_os = \"dragonfly\",\n    target_os = \"emscripten\",\n    target_os = \"freebsd\",\n    target_os = \"ios\",\n    target_os = \"linux\",\n    target_os = \"macos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n)))]\nconst fn max_iov() -> usize {\n    16 // The minimum value required by POSIX.\n}\n\nimpl FileDesc {\n    pub fn new(fd: c_int) -> FileDesc {\n        assert_ne!(fd, -1i32);\n        // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n        unsafe { FileDesc { fd } }\n    }\n\n    pub fn raw(&self) -> c_int {\n        self.fd\n    }\n\n    /// Extracts the actual file descriptor without closing it.\n    pub fn into_raw(self) -> c_int {\n        let fd = self.fd;\n        mem::forget(self);\n        fd\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), READ_LIMIT))\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::readv(\n                self.fd,\n                bufs.as_ptr() as *const libc::iovec,\n                cmp::min(bufs.len(), max_iov()) as c_int,\n            )\n        })?;\n        Ok(ret as usize)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        let mut me = self;\n        (&mut me).read_to_end(buf)\n    }\n\n    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n        #[cfg(target_os = \"android\")]\n        use super::android::cvt_pread64;\n\n        #[cfg(not(target_os = \"android\"))]\n        unsafe fn cvt_pread64(\n            fd: c_int,\n            buf: *mut c_void,\n            count: usize,\n            offset: i64,\n        ) -> io::Result<isize> {\n            #[cfg(not(target_os = \"linux\"))]\n            use libc::pread as pread64;\n            #[cfg(target_os = \"linux\")]\n            use libc::pread64;\n            cvt(pread64(fd, buf, count, offset))\n        }\n\n        unsafe {\n            cvt_pread64(\n                self.fd,\n                buf.as_mut_ptr() as *mut c_void,\n                cmp::min(buf.len(), READ_LIMIT),\n                offset as i64,\n            )\n            .map(|n| n as usize)\n        }\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), READ_LIMIT))\n        })?;\n        Ok(ret as usize)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let ret = cvt(unsafe {\n            libc::writev(\n                self.fd,\n                bufs.as_ptr() as *const libc::iovec,\n                cmp::min(bufs.len(), max_iov()) as c_int,\n            )\n        })?;\n        Ok(ret as usize)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n        #[cfg(target_os = \"android\")]\n        use super::android::cvt_pwrite64;\n\n        #[cfg(not(target_os = \"android\"))]\n        unsafe fn cvt_pwrite64(\n            fd: c_int,\n            buf: *const c_void,\n            count: usize,\n            offset: i64,\n        ) -> io::Result<isize> {\n            #[cfg(not(target_os = \"linux\"))]\n            use libc::pwrite as pwrite64;\n            #[cfg(target_os = \"linux\")]\n            use libc::pwrite64;\n            cvt(pwrite64(fd, buf, count, offset))\n        }\n\n        unsafe {\n            cvt_pwrite64(\n                self.fd,\n                buf.as_ptr() as *const c_void,\n                cmp::min(buf.len(), READ_LIMIT),\n                offset as i64,\n            )\n            .map(|n| n as usize)\n        }\n    }\n\n    #[cfg(target_os = \"linux\")]\n    pub fn get_cloexec(&self) -> io::Result<bool> {\n        unsafe { Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n    }\n\n    #[cfg(not(any(\n        target_env = \"newlib\",\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"emscripten\",\n        target_os = \"fuchsia\",\n        target_os = \"l4re\",\n        target_os = \"linux\",\n        target_os = \"haiku\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    )))]\n    pub fn set_cloexec(&self) -> io::Result<()> {\n        unsafe {\n            cvt(libc::ioctl(self.fd, libc::FIOCLEX))?;\n            Ok(())\n        }\n    }\n    #[cfg(any(\n        target_env = \"newlib\",\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"emscripten\",\n        target_os = \"fuchsia\",\n        target_os = \"l4re\",\n        target_os = \"linux\",\n        target_os = \"haiku\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    ))]\n    pub fn set_cloexec(&self) -> io::Result<()> {\n        unsafe {\n            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n            let new = previous | libc::FD_CLOEXEC;\n            if new != previous {\n                cvt(libc::fcntl(self.fd, libc::F_SETFD, new))?;\n            }\n            Ok(())\n        }\n    }\n\n    #[cfg(target_os = \"linux\")]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        unsafe {\n            let v = nonblocking as c_int;\n            cvt(libc::ioctl(self.fd, libc::FIONBIO, &v))?;\n            Ok(())\n        }\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        unsafe {\n            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFL))?;\n            let new = if nonblocking {\n                previous | libc::O_NONBLOCK\n            } else {\n                previous & !libc::O_NONBLOCK\n            };\n            if new != previous {\n                cvt(libc::fcntl(self.fd, libc::F_SETFL, new))?;\n            }\n            Ok(())\n        }\n    }\n\n    pub fn duplicate(&self) -> io::Result<FileDesc> {\n        // We want to atomically duplicate this file descriptor and set the\n        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n        // is a POSIX flag that was added to Linux in 2.6.24.\n        let fd = cvt(unsafe { libc::fcntl(self.raw(), libc::F_DUPFD_CLOEXEC, 0) })?;\n        Ok(FileDesc::new(fd))\n    }\n}\n\nimpl<'a> Read for &'a FileDesc {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\n\nimpl AsInner<c_int> for FileDesc {\n    fn as_inner(&self) -> &c_int {\n        &self.fd\n    }\n}\n\nimpl Drop for FileDesc {\n    fn drop(&mut self) {\n        // Note that errors are ignored when closing a file descriptor. The\n        // reason for this is that if an error occurs we don't actually know if\n        // the file descriptor was closed or not, and if we retried (for\n        // something like EINTR), we might close another valid file descriptor\n        // opened after we closed ours.\n        let _ = unsafe { libc::close(self.fd) };\n    }\n}\n"],["2471","use crate::mem;\nuse crate::slice;\n\npub fn hashmap_random_keys() -> (u64, u64) {\n    let mut v = (0, 0);\n    unsafe {\n        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8, mem::size_of_val(&v));\n        imp::fill_bytes(view);\n    }\n    v\n}\n\n#[cfg(all(\n    unix,\n    not(target_os = \"macos\"),\n    not(target_os = \"ios\"),\n    not(target_os = \"openbsd\"),\n    not(target_os = \"freebsd\"),\n    not(target_os = \"netbsd\"),\n    not(target_os = \"fuchsia\"),\n    not(target_os = \"redox\"),\n    not(target_os = \"vxworks\")\n))]\nmod imp {\n    use crate::fs::File;\n    use crate::io::Read;\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    fn getrandom(buf: &mut [u8]) -> libc::ssize_t {\n        // A weak symbol allows interposition, e.g. for perf measurements that want to\n        // disable randomness for consistency. Otherwise, we'll try a raw syscall.\n        // (`getrandom` was added in glibc 2.25, musl 1.1.20, android API level 28)\n        syscall! {\n            fn getrandom(\n                buffer: *mut libc::c_void,\n                length: libc::size_t,\n                flags: libc::c_uint\n            ) -> libc::ssize_t\n        }\n\n        unsafe { getrandom(buf.as_mut_ptr().cast(), buf.len(), libc::GRND_NONBLOCK) }\n    }\n\n    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n    fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool {\n        false\n    }\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n        use crate::sync::atomic::{AtomicBool, Ordering};\n        use crate::sys::os::errno;\n\n        static GETRANDOM_UNAVAILABLE: AtomicBool = AtomicBool::new(false);\n        if GETRANDOM_UNAVAILABLE.load(Ordering::Relaxed) {\n            return false;\n        }\n\n        let mut read = 0;\n        while read < v.len() {\n            let result = getrandom(&mut v[read..]);\n            if result == -1 {\n                let err = errno() as libc::c_int;\n                if err == libc::EINTR {\n                    continue;\n                } else if err == libc::ENOSYS || err == libc::EPERM {\n                    // Fall back to reading /dev/urandom if `getrandom` is not\n                    // supported on the current kernel.\n                    //\n                    // Also fall back in case it is disabled by something like\n                    // seccomp or inside of virtual machines.\n                    GETRANDOM_UNAVAILABLE.store(true, Ordering::Relaxed);\n                    return false;\n                } else if err == libc::EAGAIN {\n                    return false;\n                } else {\n                    panic!(\"unexpected getrandom error: {}\", err);\n                }\n            } else {\n                read += result as usize;\n            }\n        }\n        true\n    }\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        // getrandom_fill_bytes here can fail if getrandom() returns EAGAIN,\n        // meaning it would have blocked because the non-blocking pool (urandom)\n        // has not initialized in the kernel yet due to a lack of entropy. The\n        // fallback we do here is to avoid blocking applications which could\n        // depend on this call without ever knowing they do and don't have a\n        // work around. The PRNG of /dev/urandom will still be used but over a\n        // possibly predictable entropy pool.\n        if getrandom_fill_bytes(v) {\n            return;\n        }\n\n        // getrandom failed because it is permanently or temporarily (because\n        // of missing entropy) unavailable. Open /dev/urandom, read from it,\n        // and close it again.\n        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n    }\n}\n\n#[cfg(target_os = \"macos\")]\nmod imp {\n    use crate::fs::File;\n    use crate::io::Read;\n    use crate::sys::os::errno;\n    use libc::{c_int, c_void, size_t};\n\n    fn getentropy_fill_bytes(v: &mut [u8]) -> bool {\n        weak!(fn getentropy(*mut c_void, size_t) -> c_int);\n\n        getentropy\n            .get()\n            .map(|f| {\n                // getentropy(2) permits a maximum buffer size of 256 bytes\n                for s in v.chunks_mut(256) {\n                    let ret = unsafe { f(s.as_mut_ptr() as *mut c_void, s.len()) };\n                    if ret == -1 {\n                        panic!(\"unexpected getentropy error: {}\", errno());\n                    }\n                }\n                true\n            })\n            .unwrap_or(false)\n    }\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        if getentropy_fill_bytes(v) {\n            return;\n        }\n\n        // for older macos which doesn't support getentropy\n        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n    }\n}\n\n#[cfg(target_os = \"openbsd\")]\nmod imp {\n    use crate::sys::os::errno;\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        // getentropy(2) permits a maximum buffer size of 256 bytes\n        for s in v.chunks_mut(256) {\n            let ret = unsafe { libc::getentropy(s.as_mut_ptr() as *mut libc::c_void, s.len()) };\n            if ret == -1 {\n                panic!(\"unexpected getentropy error: {}\", errno());\n            }\n        }\n    }\n}\n\n// On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n// `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n// from `/dev/random` and which runs on its own thread accessed via GCD.\n// This seems needlessly heavyweight for the purposes of generating two u64s\n// once per thread in `hashmap_random_keys`. Therefore `SecRandomCopyBytes` is\n// only used on iOS where direct access to `/dev/urandom` is blocked by the\n// sandbox.\n#[cfg(target_os = \"ios\")]\nmod imp {\n    use crate::io;\n    use crate::ptr;\n    use libc::{c_int, size_t};\n\n    enum SecRandom {}\n\n    #[allow(non_upper_case_globals)]\n    const kSecRandomDefault: *const SecRandom = ptr::null();\n\n    extern \"C\" {\n        fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n    }\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n        if ret == -1 {\n            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n        }\n    }\n}\n\n#[cfg(any(target_os = \"freebsd\", target_os = \"netbsd\"))]\nmod imp {\n    use crate::ptr;\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        let mib = [libc::CTL_KERN, libc::KERN_ARND];\n        // kern.arandom permits a maximum buffer size of 256 bytes\n        for s in v.chunks_mut(256) {\n            let mut s_len = s.len();\n            let ret = unsafe {\n                libc::sysctl(\n                    mib.as_ptr(),\n                    mib.len() as libc::c_uint,\n                    s.as_mut_ptr() as *mut _,\n                    &mut s_len,\n                    ptr::null(),\n                    0,\n                )\n            };\n            if ret == -1 || s_len != s.len() {\n                panic!(\n                    \"kern.arandom sysctl failed! (returned {}, s.len() {}, oldlenp {})\",\n                    ret,\n                    s.len(),\n                    s_len\n                );\n            }\n        }\n    }\n}\n\n#[cfg(target_os = \"fuchsia\")]\nmod imp {\n    #[link(name = \"zircon\")]\n    extern \"C\" {\n        fn zx_cprng_draw(buffer: *mut u8, len: usize);\n    }\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        unsafe { zx_cprng_draw(v.as_mut_ptr(), v.len()) }\n    }\n}\n\n#[cfg(target_os = \"redox\")]\nmod imp {\n    use crate::fs::File;\n    use crate::io::Read;\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        // Open rand:, read from it, and close it again.\n        let mut file = File::open(\"rand:\").expect(\"failed to open rand:\");\n        file.read_exact(v).expect(\"failed to read rand:\")\n    }\n}\n\n#[cfg(target_os = \"vxworks\")]\nmod imp {\n    use crate::io;\n    use core::sync::atomic::{AtomicBool, Ordering::Relaxed};\n\n    pub fn fill_bytes(v: &mut [u8]) {\n        static RNG_INIT: AtomicBool = AtomicBool::new(false);\n        while !RNG_INIT.load(Relaxed) {\n            let ret = unsafe { libc::randSecure() };\n            if ret < 0 {\n                panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n            } else if ret > 0 {\n                RNG_INIT.store(true, Relaxed);\n                break;\n            }\n            unsafe { libc::usleep(10) };\n        }\n        let ret = unsafe {\n            libc::randABytes(v.as_mut_ptr() as *mut libc::c_uchar, v.len() as libc::c_int)\n        };\n        if ret < 0 {\n            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n        }\n    }\n}\n"],["2472","use crate::os::unix::prelude::*;\n\nuse crate::ffi::{CStr, CString, OsStr, OsString};\nuse crate::fmt;\nuse crate::io::{self, Error, IoSlice, IoSliceMut, SeekFrom};\nuse crate::mem;\nuse crate::path::{Path, PathBuf};\nuse crate::ptr;\nuse crate::sync::Arc;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::time::SystemTime;\nuse crate::sys::{cvt, cvt_r};\nuse crate::sys_common::{AsInner, FromInner};\n\nuse libc::{c_int, mode_t};\n\n#[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\nuse libc::dirfd;\n#[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\nuse libc::fstatat64;\n#[cfg(not(any(\n    target_os = \"linux\",\n    target_os = \"emscripten\",\n    target_os = \"solaris\",\n    target_os = \"illumos\",\n    target_os = \"l4re\",\n    target_os = \"fuchsia\",\n    target_os = \"redox\"\n)))]\nuse libc::readdir_r as readdir64_r;\n#[cfg(target_os = \"android\")]\nuse libc::{\n    dirent as dirent64, fstat as fstat64, fstatat as fstatat64, lseek64, lstat as lstat64,\n    open as open64, stat as stat64,\n};\n#[cfg(not(any(\n    target_os = \"linux\",\n    target_os = \"emscripten\",\n    target_os = \"l4re\",\n    target_os = \"android\"\n)))]\nuse libc::{\n    dirent as dirent64, fstat as fstat64, ftruncate as ftruncate64, lseek as lseek64,\n    lstat as lstat64, off_t as off64_t, open as open64, stat as stat64,\n};\n#[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"l4re\"))]\nuse libc::{\n    dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, readdir64_r, stat64,\n};\n\npub use crate::sys_common::fs::{remove_dir_all, try_exists};\n\npub struct File(FileDesc);\n\n// FIXME: This should be available on Linux with all `target_env`.\n// But currently only glibc exposes `statx` fn and structs.\n// We don't want to import unverified raw C structs here directly.\n// https://github.com/rust-lang/rust/pull/67774\nmacro_rules! cfg_has_statx {\n    ({ $($then_tt:tt)* } else { $($else_tt:tt)* }) => {\n        cfg_if::cfg_if! {\n            if #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))] {\n                $($then_tt)*\n            } else {\n                $($else_tt)*\n            }\n        }\n    };\n    ($($block_inner:tt)*) => {\n        #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n        {\n            $($block_inner)*\n        }\n    };\n}\n\ncfg_has_statx! {{\n    #[derive(Clone)]\n    pub struct FileAttr {\n        stat: stat64,\n        statx_extra_fields: Option<StatxExtraFields>,\n    }\n\n    #[derive(Clone)]\n    struct StatxExtraFields {\n        // This is needed to check if btime is supported by the filesystem.\n        stx_mask: u32,\n        stx_btime: libc::statx_timestamp,\n    }\n\n    // We prefer `statx` on Linux if available, which contains file creation time.\n    // Default `stat64` contains no creation time.\n    unsafe fn try_statx(\n        fd: c_int,\n        path: *const libc::c_char,\n        flags: i32,\n        mask: u32,\n    ) -> Option<io::Result<FileAttr>> {\n        use crate::sync::atomic::{AtomicU8, Ordering};\n\n        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n        // We store the availability in global to avoid unnecessary syscalls.\n        // 0: Unknown\n        // 1: Not available\n        // 2: Available\n        static STATX_STATE: AtomicU8 = AtomicU8::new(0);\n        syscall! {\n            fn statx(\n                fd: c_int,\n                pathname: *const libc::c_char,\n                flags: c_int,\n                mask: libc::c_uint,\n                statxbuf: *mut libc::statx\n            ) -> c_int\n        }\n\n        match STATX_STATE.load(Ordering::Relaxed) {\n            0 => {\n                // It is a trick to call `statx` with null pointers to check if the syscall\n                // is available. According to the manual, it is expected to fail with EFAULT.\n                // We do this mainly for performance, since it is nearly hundreds times\n                // faster than a normal successful call.\n                let err = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n                    .err()\n                    .and_then(|e| e.raw_os_error());\n                // We don't check `err == Some(libc::ENOSYS)` because the syscall may be limited\n                // and returns `EPERM`. Listing all possible errors seems not a good idea.\n                // See: https://github.com/rust-lang/rust/issues/65662\n                if err != Some(libc::EFAULT) {\n                    STATX_STATE.store(1, Ordering::Relaxed);\n                    return None;\n                }\n                STATX_STATE.store(2, Ordering::Relaxed);\n            }\n            1 => return None,\n            _ => {}\n        }\n\n        let mut buf: libc::statx = mem::zeroed();\n        if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n            return Some(Err(err));\n        }\n\n        // We cannot fill `stat64` exhaustively because of private padding fields.\n        let mut stat: stat64 = mem::zeroed();\n        // `c_ulong` on gnu-mips, `dev_t` otherwise\n        stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n        stat.st_ino = buf.stx_ino as libc::ino64_t;\n        stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n        stat.st_mode = buf.stx_mode as libc::mode_t;\n        stat.st_uid = buf.stx_uid as libc::uid_t;\n        stat.st_gid = buf.stx_gid as libc::gid_t;\n        stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n        stat.st_size = buf.stx_size as off64_t;\n        stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n        stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n        stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n        // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n        stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n        stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n        stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n        stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n        stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n\n        let extra = StatxExtraFields {\n            stx_mask: buf.stx_mask,\n            stx_btime: buf.stx_btime,\n        };\n\n        Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n    }\n\n} else {\n    #[derive(Clone)]\n    pub struct FileAttr {\n        stat: stat64,\n    }\n}}\n\n// all DirEntry's will have a reference to this struct\nstruct InnerReadDir {\n    dirp: Dir,\n    root: PathBuf,\n}\n\npub struct ReadDir {\n    inner: Arc<InnerReadDir>,\n    #[cfg(not(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n    )))]\n    end_of_stream: bool,\n}\n\nstruct Dir(*mut libc::DIR);\n\nunsafe impl Send for Dir {}\nunsafe impl Sync for Dir {}\n\npub struct DirEntry {\n    entry: dirent64,\n    dir: Arc<InnerReadDir>,\n    // We need to store an owned copy of the entry name\n    // on Solaris and Fuchsia because a) it uses a zero-length\n    // array to store the name, b) its lifetime between readdir\n    // calls is not guaranteed.\n    #[cfg(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\"\n    ))]\n    name: Box<[u8]>,\n}\n\n#[derive(Clone, Debug)]\npub struct OpenOptions {\n    // generic\n    read: bool,\n    write: bool,\n    append: bool,\n    truncate: bool,\n    create: bool,\n    create_new: bool,\n    // system-specific\n    custom_flags: i32,\n    mode: mode_t,\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct FilePermissions {\n    mode: mode_t,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\npub struct FileType {\n    mode: mode_t,\n}\n\n#[derive(Debug)]\npub struct DirBuilder {\n    mode: mode_t,\n}\n\ncfg_has_statx! {{\n    impl FileAttr {\n        fn from_stat64(stat: stat64) -> Self {\n            Self { stat, statx_extra_fields: None }\n        }\n    }\n} else {\n    impl FileAttr {\n        fn from_stat64(stat: stat64) -> Self {\n            Self { stat }\n        }\n    }\n}}\n\nimpl FileAttr {\n    pub fn size(&self) -> u64 {\n        self.stat.st_size as u64\n    }\n    pub fn perm(&self) -> FilePermissions {\n        FilePermissions { mode: (self.stat.st_mode as mode_t) }\n    }\n\n    pub fn file_type(&self) -> FileType {\n        FileType { mode: self.stat.st_mode as mode_t }\n    }\n}\n\n#[cfg(target_os = \"netbsd\")]\nimpl FileAttr {\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_mtime as libc::time_t,\n            tv_nsec: self.stat.st_mtimensec as libc::c_long,\n        }))\n    }\n\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_atime as libc::time_t,\n            tv_nsec: self.stat.st_atimensec as libc::c_long,\n        }))\n    }\n\n    pub fn created(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_birthtime as libc::time_t,\n            tv_nsec: self.stat.st_birthtimensec as libc::c_long,\n        }))\n    }\n}\n\n#[cfg(not(target_os = \"netbsd\"))]\nimpl FileAttr {\n    #[cfg(not(target_os = \"vxworks\"))]\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_mtime as libc::time_t,\n            tv_nsec: self.stat.st_mtime_nsec as _,\n        }))\n    }\n\n    #[cfg(target_os = \"vxworks\")]\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_mtime as libc::time_t,\n            tv_nsec: 0,\n        }))\n    }\n\n    #[cfg(not(target_os = \"vxworks\"))]\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_atime as libc::time_t,\n            tv_nsec: self.stat.st_atime_nsec as _,\n        }))\n    }\n\n    #[cfg(target_os = \"vxworks\")]\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_atime as libc::time_t,\n            tv_nsec: 0,\n        }))\n    }\n\n    #[cfg(any(\n        target_os = \"freebsd\",\n        target_os = \"openbsd\",\n        target_os = \"macos\",\n        target_os = \"ios\"\n    ))]\n    pub fn created(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(libc::timespec {\n            tv_sec: self.stat.st_birthtime as libc::time_t,\n            tv_nsec: self.stat.st_birthtime_nsec as libc::c_long,\n        }))\n    }\n\n    #[cfg(not(any(\n        target_os = \"freebsd\",\n        target_os = \"openbsd\",\n        target_os = \"macos\",\n        target_os = \"ios\"\n    )))]\n    pub fn created(&self) -> io::Result<SystemTime> {\n        cfg_has_statx! {\n            if let Some(ext) = &self.statx_extra_fields {\n                return if (ext.stx_mask & libc::STATX_BTIME) != 0 {\n                    Ok(SystemTime::from(libc::timespec {\n                        tv_sec: ext.stx_btime.tv_sec as libc::time_t,\n                        tv_nsec: ext.stx_btime.tv_nsec as _,\n                    }))\n                } else {\n                    Err(io::Error::new_const(\n                        io::ErrorKind::Other,\n                        &\"creation time is not available for the filesystem\",\n                    ))\n                };\n            }\n        }\n\n        Err(io::Error::new_const(\n            io::ErrorKind::Unsupported,\n            &\"creation time is not available on this platform \\\n                            currently\",\n        ))\n    }\n}\n\nimpl AsInner<stat64> for FileAttr {\n    fn as_inner(&self) -> &stat64 {\n        &self.stat\n    }\n}\n\nimpl FilePermissions {\n    pub fn readonly(&self) -> bool {\n        // check if any class (owner, group, others) has write permission\n        self.mode & 0o222 == 0\n    }\n\n    pub fn set_readonly(&mut self, readonly: bool) {\n        if readonly {\n            // remove write permission for all classes; equivalent to `chmod a-w <file>`\n            self.mode &= !0o222;\n        } else {\n            // add write permission for all classes; equivalent to `chmod a+w <file>`\n            self.mode |= 0o222;\n        }\n    }\n    pub fn mode(&self) -> u32 {\n        self.mode as u32\n    }\n}\n\nimpl FileType {\n    pub fn is_dir(&self) -> bool {\n        self.is(libc::S_IFDIR)\n    }\n    pub fn is_file(&self) -> bool {\n        self.is(libc::S_IFREG)\n    }\n    pub fn is_symlink(&self) -> bool {\n        self.is(libc::S_IFLNK)\n    }\n\n    pub fn is(&self, mode: mode_t) -> bool {\n        self.mode & libc::S_IFMT == mode\n    }\n}\n\nimpl FromInner<u32> for FilePermissions {\n    fn from_inner(mode: u32) -> FilePermissions {\n        FilePermissions { mode: mode as mode_t }\n    }\n}\n\nimpl fmt::Debug for ReadDir {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n        // Thus the result will be e g 'ReadDir(\"/home\")'\n        fmt::Debug::fmt(&*self.inner.root, f)\n    }\n}\n\nimpl Iterator for ReadDir {\n    type Item = io::Result<DirEntry>;\n\n    #[cfg(any(\n        target_os = \"solaris\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n        target_os = \"illumos\"\n    ))]\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        use crate::slice;\n\n        unsafe {\n            loop {\n                // Although readdir_r(3) would be a correct function to use here because\n                // of the thread safety, on Illumos and Fuchsia the readdir(3C) function\n                // is safe to use in threaded applications and it is generally preferred\n                // over the readdir_r(3C) function.\n                super::os::set_errno(0);\n                let entry_ptr = libc::readdir(self.inner.dirp.0);\n                if entry_ptr.is_null() {\n                    // null can mean either the end is reached or an error occurred.\n                    // So we had to clear errno beforehand to check for an error now.\n                    return match super::os::errno() {\n                        0 => None,\n                        e => Some(Err(Error::from_raw_os_error(e))),\n                    };\n                }\n\n                let name = (*entry_ptr).d_name.as_ptr();\n                let namelen = libc::strlen(name) as usize;\n\n                let ret = DirEntry {\n                    entry: *entry_ptr,\n                    name: slice::from_raw_parts(name as *const u8, namelen as usize)\n                        .to_owned()\n                        .into_boxed_slice(),\n                    dir: Arc::clone(&self.inner),\n                };\n                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n                    return Some(Ok(ret));\n                }\n            }\n        }\n    }\n\n    #[cfg(not(any(\n        target_os = \"solaris\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n        target_os = \"illumos\"\n    )))]\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        if self.end_of_stream {\n            return None;\n        }\n\n        unsafe {\n            let mut ret = DirEntry { entry: mem::zeroed(), dir: Arc::clone(&self.inner) };\n            let mut entry_ptr = ptr::null_mut();\n            loop {\n                if readdir64_r(self.inner.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n                    if entry_ptr.is_null() {\n                        // We encountered an error (which will be returned in this iteration), but\n                        // we also reached the end of the directory stream. The `end_of_stream`\n                        // flag is enabled to make sure that we return `None` in the next iteration\n                        // (instead of looping forever)\n                        self.end_of_stream = true;\n                    }\n                    return Some(Err(Error::last_os_error()));\n                }\n                if entry_ptr.is_null() {\n                    return None;\n                }\n                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n                    return Some(Ok(ret));\n                }\n            }\n        }\n    }\n}\n\nimpl Drop for Dir {\n    fn drop(&mut self) {\n        let r = unsafe { libc::closedir(self.0) };\n        debug_assert_eq!(r, 0);\n    }\n}\n\nimpl DirEntry {\n    pub fn path(&self) -> PathBuf {\n        self.dir.root.join(OsStr::from_bytes(self.name_bytes()))\n    }\n\n    pub fn file_name(&self) -> OsString {\n        OsStr::from_bytes(self.name_bytes()).to_os_string()\n    }\n\n    #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n    pub fn metadata(&self) -> io::Result<FileAttr> {\n        let fd = cvt(unsafe { dirfd(self.dir.dirp.0) })?;\n        let name = self.entry.d_name.as_ptr();\n\n        cfg_has_statx! {\n            if let Some(ret) = unsafe { try_statx(\n                fd,\n                name,\n                libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n                libc::STATX_ALL,\n            ) } {\n                return ret;\n            }\n        }\n\n        let mut stat: stat64 = unsafe { mem::zeroed() };\n        cvt(unsafe { fstatat64(fd, name, &mut stat, libc::AT_SYMLINK_NOFOLLOW) })?;\n        Ok(FileAttr::from_stat64(stat))\n    }\n\n    #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\")))]\n    pub fn metadata(&self) -> io::Result<FileAttr> {\n        lstat(&self.path())\n    }\n\n    #[cfg(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"haiku\",\n        target_os = \"vxworks\"\n    ))]\n    pub fn file_type(&self) -> io::Result<FileType> {\n        lstat(&self.path()).map(|m| m.file_type())\n    }\n\n    #[cfg(not(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"haiku\",\n        target_os = \"vxworks\"\n    )))]\n    pub fn file_type(&self) -> io::Result<FileType> {\n        match self.entry.d_type {\n            libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n            libc::DT_FIFO => Ok(FileType { mode: libc::S_IFIFO }),\n            libc::DT_LNK => Ok(FileType { mode: libc::S_IFLNK }),\n            libc::DT_REG => Ok(FileType { mode: libc::S_IFREG }),\n            libc::DT_SOCK => Ok(FileType { mode: libc::S_IFSOCK }),\n            libc::DT_DIR => Ok(FileType { mode: libc::S_IFDIR }),\n            libc::DT_BLK => Ok(FileType { mode: libc::S_IFBLK }),\n            _ => lstat(&self.path()).map(|m| m.file_type()),\n        }\n    }\n\n    #[cfg(any(\n        target_os = \"macos\",\n        target_os = \"ios\",\n        target_os = \"linux\",\n        target_os = \"emscripten\",\n        target_os = \"android\",\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"haiku\",\n        target_os = \"l4re\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    ))]\n    pub fn ino(&self) -> u64 {\n        self.entry.d_ino as u64\n    }\n\n    #[cfg(any(\n        target_os = \"freebsd\",\n        target_os = \"openbsd\",\n        target_os = \"netbsd\",\n        target_os = \"dragonfly\"\n    ))]\n    pub fn ino(&self) -> u64 {\n        self.entry.d_fileno as u64\n    }\n\n    #[cfg(any(\n        target_os = \"macos\",\n        target_os = \"ios\",\n        target_os = \"netbsd\",\n        target_os = \"openbsd\",\n        target_os = \"freebsd\",\n        target_os = \"dragonfly\"\n    ))]\n    fn name_bytes(&self) -> &[u8] {\n        use crate::slice;\n        unsafe {\n            slice::from_raw_parts(\n                self.entry.d_name.as_ptr() as *const u8,\n                self.entry.d_namlen as usize,\n            )\n        }\n    }\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"linux\",\n        target_os = \"emscripten\",\n        target_os = \"l4re\",\n        target_os = \"haiku\",\n        target_os = \"vxworks\"\n    ))]\n    fn name_bytes(&self) -> &[u8] {\n        unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes() }\n    }\n    #[cfg(any(\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\"\n    ))]\n    fn name_bytes(&self) -> &[u8] {\n        &*self.name\n    }\n}\n\nimpl OpenOptions {\n    pub fn new() -> OpenOptions {\n        OpenOptions {\n            // generic\n            read: false,\n            write: false,\n            append: false,\n            truncate: false,\n            create: false,\n            create_new: false,\n            // system-specific\n            custom_flags: 0,\n            mode: 0o666,\n        }\n    }\n\n    pub fn read(&mut self, read: bool) {\n        self.read = read;\n    }\n    pub fn write(&mut self, write: bool) {\n        self.write = write;\n    }\n    pub fn append(&mut self, append: bool) {\n        self.append = append;\n    }\n    pub fn truncate(&mut self, truncate: bool) {\n        self.truncate = truncate;\n    }\n    pub fn create(&mut self, create: bool) {\n        self.create = create;\n    }\n    pub fn create_new(&mut self, create_new: bool) {\n        self.create_new = create_new;\n    }\n\n    pub fn custom_flags(&mut self, flags: i32) {\n        self.custom_flags = flags;\n    }\n    pub fn mode(&mut self, mode: u32) {\n        self.mode = mode as mode_t;\n    }\n\n    fn get_access_mode(&self) -> io::Result<c_int> {\n        match (self.read, self.write, self.append) {\n            (true, false, false) => Ok(libc::O_RDONLY),\n            (false, true, false) => Ok(libc::O_WRONLY),\n            (true, true, false) => Ok(libc::O_RDWR),\n            (false, _, true) => Ok(libc::O_WRONLY | libc::O_APPEND),\n            (true, _, true) => Ok(libc::O_RDWR | libc::O_APPEND),\n            (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n        }\n    }\n\n    fn get_creation_mode(&self) -> io::Result<c_int> {\n        match (self.write, self.append) {\n            (true, false) => {}\n            (false, false) => {\n                if self.truncate || self.create || self.create_new {\n                    return Err(Error::from_raw_os_error(libc::EINVAL));\n                }\n            }\n            (_, true) => {\n                if self.truncate && !self.create_new {\n                    return Err(Error::from_raw_os_error(libc::EINVAL));\n                }\n            }\n        }\n\n        Ok(match (self.create, self.truncate, self.create_new) {\n            (false, false, false) => 0,\n            (true, false, false) => libc::O_CREAT,\n            (false, true, false) => libc::O_TRUNC,\n            (true, true, false) => libc::O_CREAT | libc::O_TRUNC,\n            (_, _, true) => libc::O_CREAT | libc::O_EXCL,\n        })\n    }\n}\n\nimpl File {\n    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n        let path = cstr(path)?;\n        File::open_c(&path, opts)\n    }\n\n    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n        let flags = libc::O_CLOEXEC\n            | opts.get_access_mode()?\n            | opts.get_creation_mode()?\n            | (opts.custom_flags as c_int & !libc::O_ACCMODE);\n        // The third argument of `open64` is documented to have type `mode_t`. On\n        // some platforms (like macOS, where `open64` is actually `open`), `mode_t` is `u16`.\n        // However, since this is a variadic function, C integer promotion rules mean that on\n        // the ABI level, this still gets passed as `c_int` (aka `u32` on Unix platforms).\n        let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;\n        Ok(File(FileDesc::new(fd)))\n    }\n\n    pub fn file_attr(&self) -> io::Result<FileAttr> {\n        let fd = self.0.raw();\n\n        cfg_has_statx! {\n            if let Some(ret) = unsafe { try_statx(\n                fd,\n                b\"\\0\" as *const _ as *const libc::c_char,\n                libc::AT_EMPTY_PATH | libc::AT_STATX_SYNC_AS_STAT,\n                libc::STATX_ALL,\n            ) } {\n                return ret;\n            }\n        }\n\n        let mut stat: stat64 = unsafe { mem::zeroed() };\n        cvt(unsafe { fstat64(fd, &mut stat) })?;\n        Ok(FileAttr::from_stat64(stat))\n    }\n\n    pub fn fsync(&self) -> io::Result<()> {\n        cvt_r(|| unsafe { os_fsync(self.0.raw()) })?;\n        return Ok(());\n\n        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n        unsafe fn os_fsync(fd: c_int) -> c_int {\n            libc::fcntl(fd, libc::F_FULLFSYNC)\n        }\n        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n        unsafe fn os_fsync(fd: c_int) -> c_int {\n            libc::fsync(fd)\n        }\n    }\n\n    pub fn datasync(&self) -> io::Result<()> {\n        cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n        return Ok(());\n\n        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n        unsafe fn os_datasync(fd: c_int) -> c_int {\n            libc::fcntl(fd, libc::F_FULLFSYNC)\n        }\n        #[cfg(any(\n            target_os = \"freebsd\",\n            target_os = \"linux\",\n            target_os = \"android\",\n            target_os = \"netbsd\",\n            target_os = \"openbsd\"\n        ))]\n        unsafe fn os_datasync(fd: c_int) -> c_int {\n            libc::fdatasync(fd)\n        }\n        #[cfg(not(any(\n            target_os = \"android\",\n            target_os = \"freebsd\",\n            target_os = \"ios\",\n            target_os = \"linux\",\n            target_os = \"macos\",\n            target_os = \"netbsd\",\n            target_os = \"openbsd\"\n        )))]\n        unsafe fn os_datasync(fd: c_int) -> c_int {\n            libc::fsync(fd)\n        }\n    }\n\n    pub fn truncate(&self, size: u64) -> io::Result<()> {\n        #[cfg(target_os = \"android\")]\n        return crate::sys::android::ftruncate64(self.0.raw(), size);\n\n        #[cfg(not(target_os = \"android\"))]\n        {\n            use crate::convert::TryInto;\n            let size: off64_t =\n                size.try_into().map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;\n            cvt_r(|| unsafe { ftruncate64(self.0.raw(), size) }).map(drop)\n        }\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.0.is_read_vectored()\n    }\n\n    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n        self.0.read_at(buf, offset)\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n        self.0.write_at(buf, offset)\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        Ok(())\n    }\n\n    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n        let (whence, pos) = match pos {\n            // Casting to `i64` is fine, too large values will end up as\n            // negative which will cause an error in `lseek64`.\n            SeekFrom::Start(off) => (libc::SEEK_SET, off as i64),\n            SeekFrom::End(off) => (libc::SEEK_END, off),\n            SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n        };\n        let n = cvt(unsafe { lseek64(self.0.raw(), pos, whence) })?;\n        Ok(n as u64)\n    }\n\n    pub fn duplicate(&self) -> io::Result<File> {\n        self.0.duplicate().map(File)\n    }\n\n    pub fn fd(&self) -> &FileDesc {\n        &self.0\n    }\n\n    pub fn into_fd(self) -> FileDesc {\n        self.0\n    }\n\n    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n        cvt_r(|| unsafe { libc::fchmod(self.0.raw(), perm.mode) })?;\n        Ok(())\n    }\n}\n\nimpl DirBuilder {\n    pub fn new() -> DirBuilder {\n        DirBuilder { mode: 0o777 }\n    }\n\n    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n        let p = cstr(p)?;\n        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;\n        Ok(())\n    }\n\n    pub fn set_mode(&mut self, mode: u32) {\n        self.mode = mode as mode_t;\n    }\n}\n\nfn cstr(path: &Path) -> io::Result<CString> {\n    Ok(CString::new(path.as_os_str().as_bytes())?)\n}\n\nimpl FromInner<c_int> for File {\n    fn from_inner(fd: c_int) -> File {\n        File(FileDesc::new(fd))\n    }\n}\n\nimpl fmt::Debug for File {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        #[cfg(target_os = \"linux\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let mut p = PathBuf::from(\"/proc/self/fd\");\n            p.push(&fd.to_string());\n            readlink(&p).ok()\n        }\n\n        #[cfg(target_os = \"macos\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            // FIXME: The use of PATH_MAX is generally not encouraged, but it\n            // is inevitable in this case because macOS defines `fcntl` with\n            // `F_GETPATH` in terms of `MAXPATHLEN`, and there are no\n            // alternatives. If a better method is invented, it should be used\n            // instead.\n            let mut buf = vec![0; libc::PATH_MAX as usize];\n            let n = unsafe { libc::fcntl(fd, libc::F_GETPATH, buf.as_ptr()) };\n            if n == -1 {\n                return None;\n            }\n            let l = buf.iter().position(|&c| c == 0).unwrap();\n            buf.truncate(l as usize);\n            buf.shrink_to_fit();\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(target_os = \"vxworks\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let mut buf = vec![0; libc::PATH_MAX as usize];\n            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n            if n == -1 {\n                return None;\n            }\n            let l = buf.iter().position(|&c| c == 0).unwrap();\n            buf.truncate(l as usize);\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n        fn get_path(_fd: c_int) -> Option<PathBuf> {\n            // FIXME(#24570): implement this for other Unix platforms\n            None\n        }\n\n        #[cfg(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\"))]\n        fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n            let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n            if mode == -1 {\n                return None;\n            }\n            match mode & libc::O_ACCMODE {\n                libc::O_RDONLY => Some((true, false)),\n                libc::O_RDWR => Some((true, true)),\n                libc::O_WRONLY => Some((false, true)),\n                _ => None,\n            }\n        }\n\n        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n        fn get_mode(_fd: c_int) -> Option<(bool, bool)> {\n            // FIXME(#24570): implement this for other Unix platforms\n            None\n        }\n\n        let fd = self.0.raw();\n        let mut b = f.debug_struct(\"File\");\n        b.field(\"fd\", &fd);\n        if let Some(path) = get_path(fd) {\n            b.field(\"path\", &path);\n        }\n        if let Some((read, write)) = get_mode(fd) {\n            b.field(\"read\", &read).field(\"write\", &write);\n        }\n        b.finish()\n    }\n}\n\npub fn readdir(p: &Path) -> io::Result<ReadDir> {\n    let root = p.to_path_buf();\n    let p = cstr(p)?;\n    unsafe {\n        let ptr = libc::opendir(p.as_ptr());\n        if ptr.is_null() {\n            Err(Error::last_os_error())\n        } else {\n            let inner = InnerReadDir { dirp: Dir(ptr), root };\n            Ok(ReadDir {\n                inner: Arc::new(inner),\n                #[cfg(not(any(\n                    target_os = \"solaris\",\n                    target_os = \"illumos\",\n                    target_os = \"fuchsia\",\n                    target_os = \"redox\",\n                )))]\n                end_of_stream: false,\n            })\n        }\n    }\n}\n\npub fn unlink(p: &Path) -> io::Result<()> {\n    let p = cstr(p)?;\n    cvt(unsafe { libc::unlink(p.as_ptr()) })?;\n    Ok(())\n}\n\npub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n    let old = cstr(old)?;\n    let new = cstr(new)?;\n    cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })?;\n    Ok(())\n}\n\npub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n    let p = cstr(p)?;\n    cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) })?;\n    Ok(())\n}\n\npub fn rmdir(p: &Path) -> io::Result<()> {\n    let p = cstr(p)?;\n    cvt(unsafe { libc::rmdir(p.as_ptr()) })?;\n    Ok(())\n}\n\npub fn readlink(p: &Path) -> io::Result<PathBuf> {\n    let c_path = cstr(p)?;\n    let p = c_path.as_ptr();\n\n    let mut buf = Vec::with_capacity(256);\n\n    loop {\n        let buf_read =\n            cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })? as usize;\n\n        unsafe {\n            buf.set_len(buf_read);\n        }\n\n        if buf_read != buf.capacity() {\n            buf.shrink_to_fit();\n\n            return Ok(PathBuf::from(OsString::from_vec(buf)));\n        }\n\n        // Trigger the internal buffer resizing logic of `Vec` by requiring\n        // more space than the current capacity. The length is guaranteed to be\n        // the same as the capacity due to the if statement above.\n        buf.reserve(1);\n    }\n}\n\npub fn symlink(original: &Path, link: &Path) -> io::Result<()> {\n    let original = cstr(original)?;\n    let link = cstr(link)?;\n    cvt(unsafe { libc::symlink(original.as_ptr(), link.as_ptr()) })?;\n    Ok(())\n}\n\npub fn link(original: &Path, link: &Path) -> io::Result<()> {\n    let original = cstr(original)?;\n    let link = cstr(link)?;\n    cfg_if::cfg_if! {\n        if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\"))] {\n            // VxWorks, Redox, and old versions of Android lack `linkat`, so use\n            // `link` instead. POSIX leaves it implementation-defined whether\n            // `link` follows symlinks, so rely on the `symlink_hard_link` test\n            // in library/std/src/fs/tests.rs to check the behavior.\n            cvt(unsafe { libc::link(original.as_ptr(), link.as_ptr()) })?;\n        } else {\n            // Use `linkat` with `AT_FDCWD` instead of `link` as `linkat` gives\n            // us a flag to specify how symlinks should be handled. Pass 0 as\n            // the flags argument, meaning don't follow symlinks.\n            cvt(unsafe { libc::linkat(libc::AT_FDCWD, original.as_ptr(), libc::AT_FDCWD, link.as_ptr(), 0) })?;\n        }\n    }\n    Ok(())\n}\n\npub fn stat(p: &Path) -> io::Result<FileAttr> {\n    let p = cstr(p)?;\n\n    cfg_has_statx! {\n        if let Some(ret) = unsafe { try_statx(\n            libc::AT_FDCWD,\n            p.as_ptr(),\n            libc::AT_STATX_SYNC_AS_STAT,\n            libc::STATX_ALL,\n        ) } {\n            return ret;\n        }\n    }\n\n    let mut stat: stat64 = unsafe { mem::zeroed() };\n    cvt(unsafe { stat64(p.as_ptr(), &mut stat) })?;\n    Ok(FileAttr::from_stat64(stat))\n}\n\npub fn lstat(p: &Path) -> io::Result<FileAttr> {\n    let p = cstr(p)?;\n\n    cfg_has_statx! {\n        if let Some(ret) = unsafe { try_statx(\n            libc::AT_FDCWD,\n            p.as_ptr(),\n            libc::AT_SYMLINK_NOFOLLOW | libc::AT_STATX_SYNC_AS_STAT,\n            libc::STATX_ALL,\n        ) } {\n            return ret;\n        }\n    }\n\n    let mut stat: stat64 = unsafe { mem::zeroed() };\n    cvt(unsafe { lstat64(p.as_ptr(), &mut stat) })?;\n    Ok(FileAttr::from_stat64(stat))\n}\n\npub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n    let path = CString::new(p.as_os_str().as_bytes())?;\n    let buf;\n    unsafe {\n        let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n        if r.is_null() {\n            return Err(io::Error::last_os_error());\n        }\n        buf = CStr::from_ptr(r).to_bytes().to_vec();\n        libc::free(r as *mut _);\n    }\n    Ok(PathBuf::from(OsString::from_vec(buf)))\n}\n\nfn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n    use crate::fs::File;\n    use crate::sys_common::fs::NOT_FILE_ERROR;\n\n    let reader = File::open(from)?;\n    let metadata = reader.metadata()?;\n    if !metadata.is_file() {\n        return Err(NOT_FILE_ERROR);\n    }\n    Ok((reader, metadata))\n}\n\nfn open_to_and_set_permissions(\n    to: &Path,\n    reader_metadata: crate::fs::Metadata,\n) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n    use crate::fs::OpenOptions;\n    use crate::os::unix::fs::{OpenOptionsExt, PermissionsExt};\n\n    let perm = reader_metadata.permissions();\n    let writer = OpenOptions::new()\n        // create the file with the correct mode right away\n        .mode(perm.mode())\n        .write(true)\n        .create(true)\n        .truncate(true)\n        .open(to)?;\n    let writer_metadata = writer.metadata()?;\n    if writer_metadata.is_file() {\n        // Set the correct file permissions, in case the file already existed.\n        // Don't set the permissions on already existing non-files like\n        // pipes/FIFOs or device nodes.\n        writer.set_permissions(perm)?;\n    }\n    Ok((writer, writer_metadata))\n}\n\n#[cfg(not(any(\n    target_os = \"linux\",\n    target_os = \"android\",\n    target_os = \"macos\",\n    target_os = \"ios\"\n)))]\npub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n    let (mut reader, reader_metadata) = open_from(from)?;\n    let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n\n    io::copy(&mut reader, &mut writer)\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\npub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n    let (mut reader, reader_metadata) = open_from(from)?;\n    let max_len = u64::MAX;\n    let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n\n    use super::kernel_copy::{copy_regular_files, CopyResult};\n\n    match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {\n        CopyResult::Ended(bytes) => Ok(bytes),\n        CopyResult::Error(e, _) => Err(e),\n        CopyResult::Fallback(written) => match io::copy::generic_copy(&mut reader, &mut writer) {\n            Ok(bytes) => Ok(bytes + written),\n            Err(e) => Err(e),\n        },\n    }\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\npub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n    use crate::sync::atomic::{AtomicBool, Ordering};\n\n    const COPYFILE_ACL: u32 = 1 << 0;\n    const COPYFILE_STAT: u32 = 1 << 1;\n    const COPYFILE_XATTR: u32 = 1 << 2;\n    const COPYFILE_DATA: u32 = 1 << 3;\n\n    const COPYFILE_SECURITY: u32 = COPYFILE_STAT | COPYFILE_ACL;\n    const COPYFILE_METADATA: u32 = COPYFILE_SECURITY | COPYFILE_XATTR;\n    const COPYFILE_ALL: u32 = COPYFILE_METADATA | COPYFILE_DATA;\n\n    const COPYFILE_STATE_COPIED: u32 = 8;\n\n    #[allow(non_camel_case_types)]\n    type copyfile_state_t = *mut libc::c_void;\n    #[allow(non_camel_case_types)]\n    type copyfile_flags_t = u32;\n\n    extern \"C\" {\n        fn fcopyfile(\n            from: libc::c_int,\n            to: libc::c_int,\n            state: copyfile_state_t,\n            flags: copyfile_flags_t,\n        ) -> libc::c_int;\n        fn copyfile_state_alloc() -> copyfile_state_t;\n        fn copyfile_state_free(state: copyfile_state_t) -> libc::c_int;\n        fn copyfile_state_get(\n            state: copyfile_state_t,\n            flag: u32,\n            dst: *mut libc::c_void,\n        ) -> libc::c_int;\n    }\n\n    struct FreeOnDrop(copyfile_state_t);\n    impl Drop for FreeOnDrop {\n        fn drop(&mut self) {\n            // The code below ensures that `FreeOnDrop` is never a null pointer\n            unsafe {\n                // `copyfile_state_free` returns -1 if the `to` or `from` files\n                // cannot be closed. However, this is not considered this an\n                // error.\n                copyfile_state_free(self.0);\n            }\n        }\n    }\n\n    // MacOS prior to 10.12 don't support `fclonefileat`\n    // We store the availability in a global to avoid unnecessary syscalls\n    static HAS_FCLONEFILEAT: AtomicBool = AtomicBool::new(true);\n    syscall! {\n        fn fclonefileat(\n            srcfd: libc::c_int,\n            dst_dirfd: libc::c_int,\n            dst: *const libc::c_char,\n            flags: libc::c_int\n        ) -> libc::c_int\n    }\n\n    let (reader, reader_metadata) = open_from(from)?;\n\n    // Opportunistically attempt to create a copy-on-write clone of `from`\n    // using `fclonefileat`.\n    if HAS_FCLONEFILEAT.load(Ordering::Relaxed) {\n        let to = cstr(to)?;\n        let clonefile_result =\n            cvt(unsafe { fclonefileat(reader.as_raw_fd(), libc::AT_FDCWD, to.as_ptr(), 0) });\n        match clonefile_result {\n            Ok(_) => return Ok(reader_metadata.len()),\n            Err(err) => match err.raw_os_error() {\n                // `fclonefileat` will fail on non-APFS volumes, if the\n                // destination already exists, or if the source and destination\n                // are on different devices. In all these cases `fcopyfile`\n                // should succeed.\n                Some(libc::ENOTSUP) | Some(libc::EEXIST) | Some(libc::EXDEV) => (),\n                Some(libc::ENOSYS) => HAS_FCLONEFILEAT.store(false, Ordering::Relaxed),\n                _ => return Err(err),\n            },\n        }\n    }\n\n    // Fall back to using `fcopyfile` if `fclonefileat` does not succeed.\n    let (writer, writer_metadata) = open_to_and_set_permissions(to, reader_metadata)?;\n\n    // We ensure that `FreeOnDrop` never contains a null pointer so it is\n    // always safe to call `copyfile_state_free`\n    let state = unsafe {\n        let state = copyfile_state_alloc();\n        if state.is_null() {\n            return Err(crate::io::Error::last_os_error());\n        }\n        FreeOnDrop(state)\n    };\n\n    let flags = if writer_metadata.is_file() { COPYFILE_ALL } else { COPYFILE_DATA };\n\n    cvt(unsafe { fcopyfile(reader.as_raw_fd(), writer.as_raw_fd(), state.0, flags) })?;\n\n    let mut bytes_copied: libc::off_t = 0;\n    cvt(unsafe {\n        copyfile_state_get(\n            state.0,\n            COPYFILE_STATE_COPIED,\n            &mut bytes_copied as *mut libc::off_t as *mut libc::c_void,\n        )\n    })?;\n    Ok(bytes_copied as u64)\n}\n\n#[cfg(not(any(target_os = \"fuchsia\", target_os = \"vxworks\")))]\npub fn chroot(dir: &Path) -> io::Result<()> {\n    let dir = cstr(dir)?;\n    cvt(unsafe { libc::chroot(dir.as_ptr()) })?;\n    Ok(())\n}\n"],["2473","#![cfg(any(\n    target_os = \"linux\",\n    target_os = \"android\",\n    all(target_os = \"emscripten\", target_feature = \"atomics\")\n))]\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\nuse crate::convert::TryInto;\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\nuse crate::ptr::null;\nuse crate::sync::atomic::AtomicI32;\nuse crate::time::Duration;\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\npub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n    let timespec = timeout.and_then(|d| {\n        Some(libc::timespec {\n            // Sleep forever if the timeout is longer than fits in a timespec.\n            tv_sec: d.as_secs().try_into().ok()?,\n            // This conversion never truncates, as subsec_nanos is always <1e9.\n            tv_nsec: d.subsec_nanos() as _,\n        })\n    });\n    unsafe {\n        libc::syscall(\n            libc::SYS_futex,\n            futex as *const AtomicI32,\n            libc::FUTEX_WAIT | libc::FUTEX_PRIVATE_FLAG,\n            expected,\n            timespec.as_ref().map_or(null(), |d| d as *const libc::timespec),\n        );\n    }\n}\n\n#[cfg(target_os = \"emscripten\")]\npub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n    extern \"C\" {\n        fn emscripten_futex_wait(\n            addr: *const AtomicI32,\n            val: libc::c_uint,\n            max_wait_ms: libc::c_double,\n        ) -> libc::c_int;\n    }\n\n    unsafe {\n        emscripten_futex_wait(\n            futex as *const AtomicI32,\n            // `val` is declared unsigned to match the Emscripten headers, but since it's used as\n            // an opaque value, we can ignore the meaning of signed vs. unsigned and cast here.\n            expected as libc::c_uint,\n            timeout.map_or(crate::f64::INFINITY, |d| d.as_secs_f64() * 1000.0),\n        );\n    }\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\npub fn futex_wake(futex: &AtomicI32) {\n    unsafe {\n        libc::syscall(\n            libc::SYS_futex,\n            futex as *const AtomicI32,\n            libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n            1,\n        );\n    }\n}\n\n#[cfg(target_os = \"emscripten\")]\npub fn futex_wake(futex: &AtomicI32) {\n    extern \"C\" {\n        fn emscripten_futex_wake(addr: *const AtomicI32, count: libc::c_int) -> libc::c_int;\n    }\n\n    unsafe {\n        emscripten_futex_wake(futex as *const AtomicI32, 1);\n    }\n}\n"],["2474","//! Implementation of `std::os` functionality for unix systems\n\n#![allow(unused_imports)] // lots of cfg code here\n\n#[cfg(all(test, target_env = \"gnu\"))]\nmod tests;\n\nuse crate::os::unix::prelude::*;\n\nuse crate::error::Error as StdError;\nuse crate::ffi::{CStr, CString, OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::iter;\nuse crate::mem;\nuse crate::path::{self, PathBuf};\nuse crate::ptr;\nuse crate::slice;\nuse crate::str;\nuse crate::sys::cvt;\nuse crate::sys::fd;\nuse crate::sys::memchr;\nuse crate::sys_common::rwlock::{StaticRWLock, StaticRWLockReadGuard};\nuse crate::vec;\n\nuse libc::{c_char, c_int, c_void};\n\nconst TMPBUF_SZ: usize = 128;\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"redox\")] {\n        const PATH_SEPARATOR: u8 = b';';\n    } else {\n        const PATH_SEPARATOR: u8 = b':';\n    }\n}\n\nextern \"C\" {\n    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\n    #[cfg_attr(\n        any(\n            target_os = \"linux\",\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"l4re\"\n        ),\n        link_name = \"__errno_location\"\n    )]\n    #[cfg_attr(\n        any(\n            target_os = \"netbsd\",\n            target_os = \"openbsd\",\n            target_os = \"android\",\n            target_os = \"redox\",\n            target_env = \"newlib\"\n        ),\n        link_name = \"__errno\"\n    )]\n    #[cfg_attr(any(target_os = \"solaris\", target_os = \"illumos\"), link_name = \"___errno\")]\n    #[cfg_attr(\n        any(target_os = \"macos\", target_os = \"ios\", target_os = \"freebsd\"),\n        link_name = \"__error\"\n    )]\n    #[cfg_attr(target_os = \"haiku\", link_name = \"_errnop\")]\n    fn errno_location() -> *mut c_int;\n}\n\n/// Returns the platform-specific value of errno\n#[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\npub fn errno() -> i32 {\n    unsafe { (*errno_location()) as i32 }\n}\n\n/// Sets the platform-specific value of errno\n#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\"), not(target_os = \"vxworks\")))] // needed for readdir and syscall!\n#[allow(dead_code)] // but not all target cfgs actually end up using it\npub fn set_errno(e: i32) {\n    unsafe { *errno_location() = e as c_int }\n}\n\n#[cfg(target_os = \"vxworks\")]\npub fn errno() -> i32 {\n    unsafe { libc::errnoGet() }\n}\n\n#[cfg(target_os = \"dragonfly\")]\npub fn errno() -> i32 {\n    extern \"C\" {\n        #[thread_local]\n        static errno: c_int;\n    }\n\n    unsafe { errno as i32 }\n}\n\n#[cfg(target_os = \"dragonfly\")]\npub fn set_errno(e: i32) {\n    extern \"C\" {\n        #[thread_local]\n        static mut errno: c_int;\n    }\n\n    unsafe {\n        errno = e;\n    }\n}\n\n/// Gets a detailed string description for the given error number.\npub fn error_string(errno: i32) -> String {\n    extern \"C\" {\n        #[cfg_attr(any(target_os = \"linux\", target_env = \"newlib\"), link_name = \"__xpg_strerror_r\")]\n        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t) -> c_int;\n    }\n\n    let mut buf = [0 as c_char; TMPBUF_SZ];\n\n    let p = buf.as_mut_ptr();\n    unsafe {\n        if strerror_r(errno as c_int, p, buf.len()) < 0 {\n            panic!(\"strerror_r failure\");\n        }\n\n        let p = p as *const _;\n        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n    }\n}\n\npub fn getcwd() -> io::Result<PathBuf> {\n    let mut buf = Vec::with_capacity(512);\n    loop {\n        unsafe {\n            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n            if !libc::getcwd(ptr, buf.capacity()).is_null() {\n                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n                buf.set_len(len);\n                buf.shrink_to_fit();\n                return Ok(PathBuf::from(OsString::from_vec(buf)));\n            } else {\n                let error = io::Error::last_os_error();\n                if error.raw_os_error() != Some(libc::ERANGE) {\n                    return Err(error);\n                }\n            }\n\n            // Trigger the internal buffer resizing logic of `Vec` by requiring\n            // more space than the current capacity.\n            let cap = buf.capacity();\n            buf.set_len(cap);\n            buf.reserve(1);\n        }\n    }\n}\n\npub fn chdir(p: &path::Path) -> io::Result<()> {\n    let p: &OsStr = p.as_ref();\n    let p = CString::new(p.as_bytes())?;\n    if unsafe { libc::chdir(p.as_ptr()) } != 0 {\n        return Err(io::Error::last_os_error());\n    }\n    Ok(())\n}\n\npub struct SplitPaths<'a> {\n    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>, fn(&'a [u8]) -> PathBuf>,\n}\n\npub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {\n    fn bytes_to_path(b: &[u8]) -> PathBuf {\n        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n    }\n    fn is_separator(b: &u8) -> bool {\n        *b == PATH_SEPARATOR\n    }\n    let unparsed = unparsed.as_bytes();\n    SplitPaths {\n        iter: unparsed\n            .split(is_separator as fn(&u8) -> bool)\n            .map(bytes_to_path as fn(&[u8]) -> PathBuf),\n    }\n}\n\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[derive(Debug)]\npub struct JoinPathsError;\n\npub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: Iterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n    let mut joined = Vec::new();\n\n    for (i, path) in paths.enumerate() {\n        let path = path.as_ref().as_bytes();\n        if i > 0 {\n            joined.push(PATH_SEPARATOR)\n        }\n        if path.contains(&PATH_SEPARATOR) {\n            return Err(JoinPathsError);\n        }\n        joined.extend_from_slice(path);\n    }\n    Ok(OsStringExt::from_vec(joined))\n}\n\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"path segment contains separator `{}`\", char::from(PATH_SEPARATOR))\n    }\n}\n\nimpl StdError for JoinPathsError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"failed to join paths\"\n    }\n}\n\n#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    unsafe {\n        let mut mib = [\n            libc::CTL_KERN as c_int,\n            libc::KERN_PROC as c_int,\n            libc::KERN_PROC_PATHNAME as c_int,\n            -1 as c_int,\n        ];\n        let mut sz = 0;\n        cvt(libc::sysctl(\n            mib.as_mut_ptr(),\n            mib.len() as libc::c_uint,\n            ptr::null_mut(),\n            &mut sz,\n            ptr::null_mut(),\n            0,\n        ))?;\n        if sz == 0 {\n            return Err(io::Error::last_os_error());\n        }\n        let mut v: Vec<u8> = Vec::with_capacity(sz);\n        cvt(libc::sysctl(\n            mib.as_mut_ptr(),\n            mib.len() as libc::c_uint,\n            v.as_mut_ptr() as *mut libc::c_void,\n            &mut sz,\n            ptr::null_mut(),\n            0,\n        ))?;\n        if sz == 0 {\n            return Err(io::Error::last_os_error());\n        }\n        v.set_len(sz - 1); // chop off trailing NUL\n        Ok(PathBuf::from(OsString::from_vec(v)))\n    }\n}\n\n#[cfg(target_os = \"netbsd\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    fn sysctl() -> io::Result<PathBuf> {\n        unsafe {\n            let mib = [libc::CTL_KERN, libc::KERN_PROC_ARGS, -1, libc::KERN_PROC_PATHNAME];\n            let mut path_len: usize = 0;\n            cvt(libc::sysctl(\n                mib.as_ptr(),\n                mib.len() as libc::c_uint,\n                ptr::null_mut(),\n                &mut path_len,\n                ptr::null(),\n                0,\n            ))?;\n            if path_len <= 1 {\n                return Err(io::Error::new_const(\n                    io::ErrorKind::Other,\n                    &\"KERN_PROC_PATHNAME sysctl returned zero-length string\",\n                ));\n            }\n            let mut path: Vec<u8> = Vec::with_capacity(path_len);\n            cvt(libc::sysctl(\n                mib.as_ptr(),\n                mib.len() as libc::c_uint,\n                path.as_ptr() as *mut libc::c_void,\n                &mut path_len,\n                ptr::null(),\n                0,\n            ))?;\n            path.set_len(path_len - 1); // chop off NUL\n            Ok(PathBuf::from(OsString::from_vec(path)))\n        }\n    }\n    fn procfs() -> io::Result<PathBuf> {\n        let curproc_exe = path::Path::new(\"/proc/curproc/exe\");\n        if curproc_exe.is_file() {\n            return crate::fs::read_link(curproc_exe);\n        }\n        Err(io::Error::new_const(\n            io::ErrorKind::Other,\n            &\"/proc/curproc/exe doesn't point to regular file.\",\n        ))\n    }\n    sysctl().or_else(|_| procfs())\n}\n\n#[cfg(target_os = \"openbsd\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    unsafe {\n        let mut mib = [libc::CTL_KERN, libc::KERN_PROC_ARGS, libc::getpid(), libc::KERN_PROC_ARGV];\n        let mib = mib.as_mut_ptr();\n        let mut argv_len = 0;\n        cvt(libc::sysctl(mib, 4, ptr::null_mut(), &mut argv_len, ptr::null_mut(), 0))?;\n        let mut argv = Vec::<*const libc::c_char>::with_capacity(argv_len as usize);\n        cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _, &mut argv_len, ptr::null_mut(), 0))?;\n        argv.set_len(argv_len as usize);\n        if argv[0].is_null() {\n            return Err(io::Error::new_const(io::ErrorKind::Other, &\"no current exe available\"));\n        }\n        let argv0 = CStr::from_ptr(argv[0]).to_bytes();\n        if argv0[0] == b'.' || argv0.iter().any(|b| *b == b'/') {\n            crate::fs::canonicalize(OsStr::from_bytes(argv0))\n        } else {\n            Ok(PathBuf::from(OsStr::from_bytes(argv0)))\n        }\n    }\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"emscripten\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    match crate::fs::read_link(\"/proc/self/exe\") {\n        Err(ref e) if e.kind() == io::ErrorKind::NotFound => Err(io::Error::new_const(\n            io::ErrorKind::Other,\n            &\"no /proc/self/exe available. Is /proc mounted?\",\n        )),\n        other => other,\n    }\n}\n\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    extern \"C\" {\n        fn _NSGetExecutablePath(buf: *mut libc::c_char, bufsize: *mut u32) -> libc::c_int;\n    }\n    unsafe {\n        let mut sz: u32 = 0;\n        _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n        if sz == 0 {\n            return Err(io::Error::last_os_error());\n        }\n        let mut v: Vec<u8> = Vec::with_capacity(sz as usize);\n        let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n        if err != 0 {\n            return Err(io::Error::last_os_error());\n        }\n        v.set_len(sz as usize - 1); // chop off trailing NUL\n        Ok(PathBuf::from(OsString::from_vec(v)))\n    }\n}\n\n#[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    extern \"C\" {\n        fn getexecname() -> *const c_char;\n    }\n    unsafe {\n        let path = getexecname();\n        if path.is_null() {\n            Err(io::Error::last_os_error())\n        } else {\n            let filename = CStr::from_ptr(path).to_bytes();\n            let path = PathBuf::from(<OsStr as OsStrExt>::from_bytes(filename));\n\n            // Prepend a current working directory to the path if\n            // it doesn't contain an absolute pathname.\n            if filename[0] == b'/' { Ok(path) } else { getcwd().map(|cwd| cwd.join(path)) }\n        }\n    }\n}\n\n#[cfg(target_os = \"haiku\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    // Use Haiku's image info functions\n    #[repr(C)]\n    struct image_info {\n        id: i32,\n        type_: i32,\n        sequence: i32,\n        init_order: i32,\n        init_routine: *mut libc::c_void, // function pointer\n        term_routine: *mut libc::c_void, // function pointer\n        device: libc::dev_t,\n        node: libc::ino_t,\n        name: [libc::c_char; 1024], // MAXPATHLEN\n        text: *mut libc::c_void,\n        data: *mut libc::c_void,\n        text_size: i32,\n        data_size: i32,\n        api_version: i32,\n        abi: i32,\n    }\n\n    unsafe {\n        extern \"C\" {\n            fn _get_next_image_info(\n                team_id: i32,\n                cookie: *mut i32,\n                info: *mut image_info,\n                size: i32,\n            ) -> i32;\n        }\n\n        let mut info: image_info = mem::zeroed();\n        let mut cookie: i32 = 0;\n        // the executable can be found at team id 0\n        let result =\n            _get_next_image_info(0, &mut cookie, &mut info, mem::size_of::<image_info>() as i32);\n        if result != 0 {\n            use crate::io::ErrorKind;\n            Err(io::Error::new_const(ErrorKind::Other, &\"Error getting executable path\"))\n        } else {\n            let name = CStr::from_ptr(info.name.as_ptr()).to_bytes();\n            Ok(PathBuf::from(OsStr::from_bytes(name)))\n        }\n    }\n}\n\n#[cfg(target_os = \"redox\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    crate::fs::read_to_string(\"sys:exe\").map(PathBuf::from)\n}\n\n#[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\"))]\npub fn current_exe() -> io::Result<PathBuf> {\n    use crate::io::ErrorKind;\n    Err(io::Error::new_const(ErrorKind::Unsupported, &\"Not yet implemented!\"))\n}\n\n#[cfg(target_os = \"vxworks\")]\npub fn current_exe() -> io::Result<PathBuf> {\n    #[cfg(test)]\n    use realstd::env;\n\n    #[cfg(not(test))]\n    use crate::env;\n\n    let exe_path = env::args().next().unwrap();\n    let path = path::Path::new(&exe_path);\n    path.canonicalize()\n}\n\npub struct Env {\n    iter: vec::IntoIter<(OsString, OsString)>,\n}\n\nimpl !Send for Env {}\nimpl !Sync for Env {}\n\nimpl Iterator for Env {\n    type Item = (OsString, OsString);\n    fn next(&mut self) -> Option<(OsString, OsString)> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[cfg(target_os = \"macos\")]\npub unsafe fn environ() -> *mut *const *const c_char {\n    extern \"C\" {\n        fn _NSGetEnviron() -> *mut *const *const c_char;\n    }\n    _NSGetEnviron()\n}\n\n#[cfg(not(target_os = \"macos\"))]\npub unsafe fn environ() -> *mut *const *const c_char {\n    extern \"C\" {\n        static mut environ: *const *const c_char;\n    }\n    ptr::addr_of_mut!(environ)\n}\n\nstatic ENV_LOCK: StaticRWLock = StaticRWLock::new();\n\npub fn env_read_lock() -> StaticRWLockReadGuard {\n    ENV_LOCK.read()\n}\n\n/// Returns a vector of (variable, value) byte-vector pairs for all the\n/// environment variables of the current process.\npub fn env() -> Env {\n    unsafe {\n        let _guard = env_read_lock();\n        let mut environ = *environ();\n        let mut result = Vec::new();\n        if !environ.is_null() {\n            while !(*environ).is_null() {\n                if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n                    result.push(key_value);\n                }\n                environ = environ.add(1);\n            }\n        }\n        return Env { iter: result.into_iter() };\n    }\n\n    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n        // Strategy (copied from glibc): Variable name and value are separated\n        // by an ASCII equals sign '='. Since a variable name must not be\n        // empty, allow variable names starting with an equals sign. Skip all\n        // malformed lines.\n        if input.is_empty() {\n            return None;\n        }\n        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n        pos.map(|p| {\n            (\n                OsStringExt::from_vec(input[..p].to_vec()),\n                OsStringExt::from_vec(input[p + 1..].to_vec()),\n            )\n        })\n    }\n}\n\npub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n    // environment variables with a nul byte can't be set, so their value is\n    // always None as well\n    let k = CString::new(k.as_bytes())?;\n    unsafe {\n        let _guard = env_read_lock();\n        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n        let ret = if s.is_null() {\n            None\n        } else {\n            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n        };\n        Ok(ret)\n    }\n}\n\npub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n    let k = CString::new(k.as_bytes())?;\n    let v = CString::new(v.as_bytes())?;\n\n    unsafe {\n        let _guard = ENV_LOCK.write();\n        cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n    }\n}\n\npub fn unsetenv(n: &OsStr) -> io::Result<()> {\n    let nbuf = CString::new(n.as_bytes())?;\n\n    unsafe {\n        let _guard = ENV_LOCK.write();\n        cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n    }\n}\n\npub fn page_size() -> usize {\n    unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }\n}\n\npub fn temp_dir() -> PathBuf {\n    crate::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| {\n        if cfg!(target_os = \"android\") {\n            PathBuf::from(\"/data/local/tmp\")\n        } else {\n            PathBuf::from(\"/tmp\")\n        }\n    })\n}\n\npub fn home_dir() -> Option<PathBuf> {\n    return crate::env::var_os(\"HOME\").or_else(|| unsafe { fallback() }).map(PathBuf::from);\n\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"ios\",\n        target_os = \"emscripten\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    ))]\n    unsafe fn fallback() -> Option<OsString> {\n        None\n    }\n    #[cfg(not(any(\n        target_os = \"android\",\n        target_os = \"ios\",\n        target_os = \"emscripten\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    )))]\n    unsafe fn fallback() -> Option<OsString> {\n        let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {\n            n if n < 0 => 512 as usize,\n            n => n as usize,\n        };\n        let mut buf = Vec::with_capacity(amt);\n        let mut passwd: libc::passwd = mem::zeroed();\n        let mut result = ptr::null_mut();\n        match libc::getpwuid_r(\n            libc::getuid(),\n            &mut passwd,\n            buf.as_mut_ptr(),\n            buf.capacity(),\n            &mut result,\n        ) {\n            0 if !result.is_null() => {\n                let ptr = passwd.pw_dir as *const _;\n                let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n                Some(OsStringExt::from_vec(bytes))\n            }\n            _ => None,\n        }\n    }\n}\n\npub fn exit(code: i32) -> ! {\n    unsafe { libc::exit(code as c_int) }\n}\n\npub fn getpid() -> u32 {\n    unsafe { libc::getpid() as u32 }\n}\n\npub fn getppid() -> u32 {\n    unsafe { libc::getppid() as u32 }\n}\n\n#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\npub fn glibc_version() -> Option<(usize, usize)> {\n    if let Some(Ok(version_str)) = glibc_version_cstr().map(CStr::to_str) {\n        parse_glibc_version(version_str)\n    } else {\n        None\n    }\n}\n\n#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\nfn glibc_version_cstr() -> Option<&'static CStr> {\n    weak! {\n        fn gnu_get_libc_version() -> *const libc::c_char\n    }\n    if let Some(f) = gnu_get_libc_version.get() {\n        unsafe { Some(CStr::from_ptr(f())) }\n    } else {\n        None\n    }\n}\n\n// Returns Some((major, minor)) if the string is a valid \"x.y\" version,\n// ignoring any extra dot-separated parts. Otherwise return None.\n#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\nfn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n    let mut parsed_ints = version.split('.').map(str::parse::<usize>).fuse();\n    match (parsed_ints.next(), parsed_ints.next()) {\n        (Some(Ok(major)), Some(Ok(minor))) => Some((major, minor)),\n        _ => None,\n    }\n}\n"],["2475","use crate::cell::UnsafeCell;\nuse crate::mem::MaybeUninit;\nuse crate::sys::cvt_nz;\n\npub struct Mutex {\n    inner: UnsafeCell<libc::pthread_mutex_t>,\n}\n\npub type MovableMutex = Box<Mutex>;\n\n#[inline]\npub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n    m.inner.get()\n}\n\nunsafe impl Send for Mutex {}\nunsafe impl Sync for Mutex {}\n\n#[allow(dead_code)] // sys isn't exported yet\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        // Might be moved to a different address, so it is better to avoid\n        // initialization of potentially opaque OS data before it landed.\n        // Be very careful using this newly constructed `Mutex`, reentrant\n        // locking is undefined behavior until `init` is called!\n        Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n    }\n    #[inline]\n    pub unsafe fn init(&mut self) {\n        // Issue #33770\n        //\n        // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n        // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n        // try to re-lock it from the same thread when you already hold a lock\n        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html).\n        // This is the case even if PTHREAD_MUTEX_DEFAULT == PTHREAD_MUTEX_NORMAL\n        // (https://github.com/rust-lang/rust/issues/33770#issuecomment-220847521) -- in that\n        // case, `pthread_mutexattr_settype(PTHREAD_MUTEX_DEFAULT)` will of course be the same\n        // as setting it to `PTHREAD_MUTEX_NORMAL`, but not setting any mode will result in\n        // a Mutex where re-locking is UB.\n        //\n        // In practice, glibc takes advantage of this undefined behavior to\n        // implement hardware lock elision, which uses hardware transactional\n        // memory to avoid acquiring the lock. While a transaction is in\n        // progress, the lock appears to be unlocked. This isn't a problem for\n        // other threads since the transactional memory will abort if a conflict\n        // is detected, however no abort is generated when re-locking from the\n        // same thread.\n        //\n        // Since locking the same mutex twice will result in two aliasing &mut\n        // references, we instead create the mutex with type\n        // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n        // re-lock it from the same thread, thus avoiding undefined behavior.\n        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n        let attr = PthreadMutexAttr(&mut attr);\n        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL))\n            .unwrap();\n        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n    }\n    #[inline]\n    pub unsafe fn lock(&self) {\n        let r = libc::pthread_mutex_lock(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let r = libc::pthread_mutex_unlock(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        libc::pthread_mutex_trylock(self.inner.get()) == 0\n    }\n    #[inline]\n    #[cfg(not(target_os = \"dragonfly\"))]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_mutex_destroy(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    #[cfg(target_os = \"dragonfly\")]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_mutex_destroy(self.inner.get());\n        // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n        // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n        // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n        // this behaviour no longer occurs.\n        debug_assert!(r == 0 || r == libc::EINVAL);\n    }\n}\n\npub struct ReentrantMutex {\n    inner: UnsafeCell<libc::pthread_mutex_t>,\n}\n\nunsafe impl Send for ReentrantMutex {}\nunsafe impl Sync for ReentrantMutex {}\n\nimpl ReentrantMutex {\n    pub const unsafe fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n    }\n\n    pub unsafe fn init(&self) {\n        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n        let attr = PthreadMutexAttr(&mut attr);\n        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE))\n            .unwrap();\n        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n    }\n\n    pub unsafe fn lock(&self) {\n        let result = libc::pthread_mutex_lock(self.inner.get());\n        debug_assert_eq!(result, 0);\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        libc::pthread_mutex_trylock(self.inner.get()) == 0\n    }\n\n    pub unsafe fn unlock(&self) {\n        let result = libc::pthread_mutex_unlock(self.inner.get());\n        debug_assert_eq!(result, 0);\n    }\n\n    pub unsafe fn destroy(&self) {\n        let result = libc::pthread_mutex_destroy(self.inner.get());\n        debug_assert_eq!(result, 0);\n    }\n}\n\nstruct PthreadMutexAttr<'a>(&'a mut MaybeUninit<libc::pthread_mutexattr_t>);\n\nimpl Drop for PthreadMutexAttr<'_> {\n    fn drop(&mut self) {\n        unsafe {\n            let result = libc::pthread_mutexattr_destroy(self.0.as_mut_ptr());\n            debug_assert_eq!(result, 0);\n        }\n    }\n}\n"],["2476","use crate::fs::OpenOptions;\nuse crate::io;\nuse crate::io::Result;\nuse crate::io::SeekFrom;\nuse crate::io::{BufRead, Read, Seek, Write};\nuse crate::os::unix::io::AsRawFd;\nuse crate::sys_common::io::test::tmpdir;\n\n#[test]\nfn copy_specialization() -> Result<()> {\n    use crate::io::{BufReader, BufWriter};\n\n    let tmp_path = tmpdir();\n    let source_path = tmp_path.join(\"copy-spec.source\");\n    let sink_path = tmp_path.join(\"copy-spec.sink\");\n\n    let result: Result<()> = try {\n        let mut source = crate::fs::OpenOptions::new()\n            .read(true)\n            .write(true)\n            .create(true)\n            .truncate(true)\n            .open(&source_path)?;\n        source.write_all(b\"abcdefghiklmnopqr\")?;\n        source.seek(SeekFrom::Start(8))?;\n        let mut source = BufReader::with_capacity(8, source.take(5));\n        source.fill_buf()?;\n        assert_eq!(source.buffer(), b\"iklmn\");\n        source.get_mut().set_limit(6);\n        source.get_mut().get_mut().seek(SeekFrom::Start(1))?; // \"bcdefg\"\n        let mut source = source.take(10); // \"iklmnbcdef\"\n\n        let mut sink = crate::fs::OpenOptions::new()\n            .read(true)\n            .write(true)\n            .create(true)\n            .truncate(true)\n            .open(&sink_path)?;\n        sink.write_all(b\"000000\")?;\n        let mut sink = BufWriter::with_capacity(5, sink);\n        sink.write_all(b\"wxyz\")?;\n        assert_eq!(sink.buffer(), b\"wxyz\");\n\n        let copied = crate::io::copy(&mut source, &mut sink)?;\n        assert_eq!(copied, 10, \"copy obeyed limit imposed by Take\");\n        assert_eq!(sink.buffer().len(), 0, \"sink buffer was flushed\");\n        assert_eq!(source.limit(), 0, \"outer Take was exhausted\");\n        assert_eq!(source.get_ref().buffer().len(), 0, \"source buffer should be drained\");\n        assert_eq!(\n            source.get_ref().get_ref().limit(),\n            1,\n            \"inner Take allowed reading beyond end of file, some bytes should be left\"\n        );\n\n        let mut sink = sink.into_inner()?;\n        sink.seek(SeekFrom::Start(0))?;\n        let mut copied = Vec::new();\n        sink.read_to_end(&mut copied)?;\n        assert_eq!(&copied, b\"000000wxyziklmnbcdef\");\n    };\n\n    let rm1 = crate::fs::remove_file(source_path);\n    let rm2 = crate::fs::remove_file(sink_path);\n\n    result.and(rm1).and(rm2)\n}\n\n#[test]\nfn copies_append_mode_sink() -> Result<()> {\n    let tmp_path = tmpdir();\n    let source_path = tmp_path.join(\"copies_append_mode.source\");\n    let sink_path = tmp_path.join(\"copies_append_mode.sink\");\n    let mut source =\n        OpenOptions::new().create(true).truncate(true).write(true).read(true).open(&source_path)?;\n    write!(source, \"not empty\")?;\n    source.seek(SeekFrom::Start(0))?;\n    let mut sink = OpenOptions::new().create(true).append(true).open(&sink_path)?;\n\n    let copied = crate::io::copy(&mut source, &mut sink)?;\n\n    assert_eq!(copied, 9);\n\n    Ok(())\n}\n\n#[bench]\nfn bench_file_to_file_copy(b: &mut test::Bencher) {\n    const BYTES: usize = 128 * 1024;\n    let temp_path = tmpdir();\n    let src_path = temp_path.join(\"file-copy-bench-src\");\n    let mut src = crate::fs::OpenOptions::new()\n        .create(true)\n        .truncate(true)\n        .read(true)\n        .write(true)\n        .open(src_path)\n        .unwrap();\n    src.write(&vec![0u8; BYTES]).unwrap();\n\n    let sink_path = temp_path.join(\"file-copy-bench-sink\");\n    let mut sink = crate::fs::OpenOptions::new()\n        .create(true)\n        .truncate(true)\n        .write(true)\n        .open(sink_path)\n        .unwrap();\n\n    b.bytes = BYTES as u64;\n    b.iter(|| {\n        src.seek(SeekFrom::Start(0)).unwrap();\n        sink.seek(SeekFrom::Start(0)).unwrap();\n        assert_eq!(BYTES as u64, io::copy(&mut src, &mut sink).unwrap());\n    });\n}\n\n#[bench]\nfn bench_file_to_socket_copy(b: &mut test::Bencher) {\n    const BYTES: usize = 128 * 1024;\n    let temp_path = tmpdir();\n    let src_path = temp_path.join(\"pipe-copy-bench-src\");\n    let mut src = OpenOptions::new()\n        .create(true)\n        .truncate(true)\n        .read(true)\n        .write(true)\n        .open(src_path)\n        .unwrap();\n    src.write(&vec![0u8; BYTES]).unwrap();\n\n    let sink_drainer = crate::net::TcpListener::bind(\"localhost:0\").unwrap();\n    let mut sink = crate::net::TcpStream::connect(sink_drainer.local_addr().unwrap()).unwrap();\n    let mut sink_drainer = sink_drainer.accept().unwrap().0;\n\n    crate::thread::spawn(move || {\n        let mut sink_buf = vec![0u8; 1024 * 1024];\n        loop {\n            sink_drainer.read(&mut sink_buf[..]).unwrap();\n        }\n    });\n\n    b.bytes = BYTES as u64;\n    b.iter(|| {\n        src.seek(SeekFrom::Start(0)).unwrap();\n        assert_eq!(BYTES as u64, io::copy(&mut src, &mut sink).unwrap());\n    });\n}\n\n#[bench]\nfn bench_file_to_uds_copy(b: &mut test::Bencher) {\n    const BYTES: usize = 128 * 1024;\n    let temp_path = tmpdir();\n    let src_path = temp_path.join(\"uds-copy-bench-src\");\n    let mut src = OpenOptions::new()\n        .create(true)\n        .truncate(true)\n        .read(true)\n        .write(true)\n        .open(src_path)\n        .unwrap();\n    src.write(&vec![0u8; BYTES]).unwrap();\n\n    let (mut sink, mut sink_drainer) = crate::os::unix::net::UnixStream::pair().unwrap();\n\n    crate::thread::spawn(move || {\n        let mut sink_buf = vec![0u8; 1024 * 1024];\n        loop {\n            sink_drainer.read(&mut sink_buf[..]).unwrap();\n        }\n    });\n\n    b.bytes = BYTES as u64;\n    b.iter(|| {\n        src.seek(SeekFrom::Start(0)).unwrap();\n        assert_eq!(BYTES as u64, io::copy(&mut src, &mut sink).unwrap());\n    });\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n#[bench]\nfn bench_socket_pipe_socket_copy(b: &mut test::Bencher) {\n    use super::CopyResult;\n    use crate::io::ErrorKind;\n    use crate::process::{ChildStdin, ChildStdout};\n    use crate::sys_common::FromInner;\n\n    let (read_end, write_end) = crate::sys::pipe::anon_pipe().unwrap();\n\n    let mut read_end = ChildStdout::from_inner(read_end);\n    let write_end = ChildStdin::from_inner(write_end);\n\n    let acceptor = crate::net::TcpListener::bind(\"localhost:0\").unwrap();\n    let mut remote_end = crate::net::TcpStream::connect(acceptor.local_addr().unwrap()).unwrap();\n\n    let local_end = crate::sync::Arc::new(acceptor.accept().unwrap().0);\n\n    // the data flow in this benchmark:\n    //\n    //                      socket(tx)  local_source\n    // remote_end (write)  +-------->   (splice to)\n    //                                  write_end\n    //                                     +\n    //                                     |\n    //                                     | pipe\n    //                                     v\n    //                                  read_end\n    // remote_end (read)   <---------+  (splice to) *\n    //                      socket(rx)  local_end\n    //\n    // * benchmark loop using io::copy\n\n    crate::thread::spawn(move || {\n        let mut sink_buf = vec![0u8; 1024 * 1024];\n        remote_end.set_nonblocking(true).unwrap();\n        loop {\n            match remote_end.write(&mut sink_buf[..]) {\n                Err(err) if err.kind() == ErrorKind::WouldBlock => {}\n                Ok(_) => {}\n                err => {\n                    err.expect(\"write failed\");\n                }\n            };\n            match remote_end.read(&mut sink_buf[..]) {\n                Err(err) if err.kind() == ErrorKind::WouldBlock => {}\n                Ok(_) => {}\n                err => {\n                    err.expect(\"read failed\");\n                }\n            };\n        }\n    });\n\n    // check that splice works, otherwise the benchmark would hang\n    let probe = super::sendfile_splice(\n        super::SpliceMode::Splice,\n        local_end.as_raw_fd(),\n        write_end.as_raw_fd(),\n        1,\n    );\n\n    match probe {\n        CopyResult::Ended(1) => {\n            // splice works\n        }\n        _ => {\n            eprintln!(\"splice failed, skipping benchmark\");\n            return;\n        }\n    }\n\n    let local_source = local_end.clone();\n    crate::thread::spawn(move || {\n        loop {\n            super::sendfile_splice(\n                super::SpliceMode::Splice,\n                local_source.as_raw_fd(),\n                write_end.as_raw_fd(),\n                u64::MAX,\n            );\n        }\n    });\n\n    const BYTES: usize = 128 * 1024;\n    b.bytes = BYTES as u64;\n    b.iter(|| {\n        assert_eq!(\n            BYTES as u64,\n            io::copy(&mut (&mut read_end).take(BYTES as u64), &mut &*local_end).unwrap()\n        );\n    });\n}\n"],["2477","//! Support for \"weak linkage\" to symbols on Unix\n//!\n//! Some I/O operations we do in libstd require newer versions of OSes but we\n//! need to maintain binary compatibility with older releases for now. In order\n//! to use the new functionality when available we use this module for\n//! detection.\n//!\n//! One option to use here is weak linkage, but that is unfortunately only\n//! really workable on Linux. Hence, use dlsym to get the symbol value at\n//! runtime. This is also done for compatibility with older versions of glibc,\n//! and to avoid creating dependencies on GLIBC_PRIVATE symbols. It assumes that\n//! we've been dynamically linked to the library the symbol comes from, but that\n//! is currently always the case for things like libpthread/libc.\n//!\n//! A long time ago this used weak linkage for the __pthread_get_minstack\n//! symbol, but that caused Debian to detect an unnecessarily strict versioned\n//! dependency on libc6 (#23628).\n\n// There are a variety of `#[cfg]`s controlling which targets are involved in\n// each instance of `weak!` and `syscall!`. Rather than trying to unify all of\n// that, we'll just allow that some unix targets don't use this module at all.\n#![allow(dead_code, unused_macros)]\n\nuse crate::ffi::CStr;\nuse crate::marker;\nuse crate::mem;\nuse crate::sync::atomic::{self, AtomicUsize, Ordering};\n\nmacro_rules! weak {\n    (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n        static $name: crate::sys::weak::Weak<unsafe extern \"C\" fn($($t),*) -> $ret> =\n            crate::sys::weak::Weak::new(concat!(stringify!($name), '\\0'));\n    )\n}\n\npub struct Weak<F> {\n    name: &'static str,\n    addr: AtomicUsize,\n    _marker: marker::PhantomData<F>,\n}\n\nimpl<F> Weak<F> {\n    pub const fn new(name: &'static str) -> Weak<F> {\n        Weak { name, addr: AtomicUsize::new(1), _marker: marker::PhantomData }\n    }\n\n    pub fn get(&self) -> Option<F> {\n        assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n        unsafe {\n            // Relaxed is fine here because we fence before reading through the\n            // pointer (see the comment below).\n            match self.addr.load(Ordering::Relaxed) {\n                1 => self.initialize(),\n                0 => None,\n                addr => {\n                    let func = mem::transmute_copy::<usize, F>(&addr);\n                    // The caller is presumably going to read through this value\n                    // (by calling the function we've dlsymed). This means we'd\n                    // need to have loaded it with at least C11's consume\n                    // ordering in order to be guaranteed that the data we read\n                    // from the pointer isn't from before the pointer was\n                    // stored. Rust has no equivalent to memory_order_consume,\n                    // so we use an acquire fence (sorry, ARM).\n                    //\n                    // Now, in practice this likely isn't needed even on CPUs\n                    // where relaxed and consume mean different things. The\n                    // symbols we're loading are probably present (or not) at\n                    // init, and even if they aren't the runtime dynamic loader\n                    // is extremely likely have sufficient barriers internally\n                    // (possibly implicitly, for example the ones provided by\n                    // invoking `mprotect`).\n                    //\n                    // That said, none of that's *guaranteed*, and so we fence.\n                    atomic::fence(Ordering::Acquire);\n                    Some(func)\n                }\n            }\n        }\n    }\n\n    // Cold because it should only happen during first-time initalization.\n    #[cold]\n    unsafe fn initialize(&self) -> Option<F> {\n        let val = fetch(self.name);\n        // This synchronizes with the acquire fence in `get`.\n        self.addr.store(val, Ordering::Release);\n\n        match val {\n            0 => None,\n            addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n        }\n    }\n}\n\nunsafe fn fetch(name: &str) -> usize {\n    let name = match CStr::from_bytes_with_nul(name.as_bytes()) {\n        Ok(cstr) => cstr,\n        Err(..) => return 0,\n    };\n    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n}\n\n#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\nmacro_rules! syscall {\n    (fn $name:ident($($arg_name:ident: $t:ty),*) -> $ret:ty) => (\n        unsafe fn $name($($arg_name: $t),*) -> $ret {\n            use super::os;\n\n            weak! { fn $name($($t),*) -> $ret }\n\n            if let Some(fun) = $name.get() {\n                fun($($arg_name),*)\n            } else {\n                os::set_errno(libc::ENOSYS);\n                -1\n            }\n        }\n    )\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\nmacro_rules! syscall {\n    (fn $name:ident($($arg_name:ident: $t:ty),*) -> $ret:ty) => (\n        unsafe fn $name($($arg_name:$t),*) -> $ret {\n            // This looks like a hack, but concat_idents only accepts idents\n            // (not paths).\n            use libc::*;\n\n            weak! { fn $name($($t),*) -> $ret }\n\n            // Use a weak symbol from libc when possible, allowing `LD_PRELOAD`\n            // interposition, but if it's not found just use a raw syscall.\n            if let Some(fun) = $name.get() {\n                fun($($arg_name),*)\n            } else {\n                syscall(\n                    concat_idents!(SYS_, $name),\n                    $($arg_name),*\n                ) as $ret\n            }\n        }\n    )\n}\n"],["2478","use crate::cell::UnsafeCell;\nuse crate::sys::mutex::{self, Mutex};\nuse crate::time::Duration;\n\npub struct Condvar {\n    inner: UnsafeCell<libc::pthread_cond_t>,\n}\n\npub type MovableCondvar = Box<Condvar>;\n\nunsafe impl Send for Condvar {}\nunsafe impl Sync for Condvar {}\n\nconst TIMESPEC_MAX: libc::timespec =\n    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n\nfn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n}\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        // Might be moved and address is changing it is better to avoid\n        // initialization of potentially opaque OS data before it landed\n        Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n    }\n\n    #[cfg(any(\n        target_os = \"macos\",\n        target_os = \"ios\",\n        target_os = \"l4re\",\n        target_os = \"android\",\n        target_os = \"redox\"\n    ))]\n    pub unsafe fn init(&mut self) {}\n\n    #[cfg(not(any(\n        target_os = \"macos\",\n        target_os = \"ios\",\n        target_os = \"l4re\",\n        target_os = \"android\",\n        target_os = \"redox\"\n    )))]\n    pub unsafe fn init(&mut self) {\n        use crate::mem::MaybeUninit;\n        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n        assert_eq!(r, 0);\n        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n        assert_eq!(r, 0);\n        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n        assert_eq!(r, 0);\n        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n        assert_eq!(r, 0);\n    }\n\n    #[inline]\n    pub unsafe fn notify_one(&self) {\n        let r = libc::pthread_cond_signal(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n\n    #[inline]\n    pub unsafe fn notify_all(&self) {\n        let r = libc::pthread_cond_broadcast(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n\n    #[inline]\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n        let r = libc::pthread_cond_wait(self.inner.get(), mutex::raw(mutex));\n        debug_assert_eq!(r, 0);\n    }\n\n    // This implementation is used on systems that support pthread_condattr_setclock\n    // where we configure condition variable to use monotonic clock (instead of\n    // default system clock). This approach avoids all problems that result\n    // from changes made to the system time.\n    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\")))]\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n        use crate::mem;\n\n        let mut now: libc::timespec = mem::zeroed();\n        let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n        assert_eq!(r, 0);\n\n        // Nanosecond calculations can't overflow because both values are below 1e9.\n        let nsec = dur.subsec_nanos() + now.tv_nsec as u32;\n\n        let sec = saturating_cast_to_time_t(dur.as_secs())\n            .checked_add((nsec / 1_000_000_000) as libc::time_t)\n            .and_then(|s| s.checked_add(now.tv_sec));\n        let nsec = nsec % 1_000_000_000;\n\n        let timeout =\n            sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n\n        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n        assert!(r == libc::ETIMEDOUT || r == 0);\n        r == 0\n    }\n\n    // This implementation is modeled after libcxx's condition_variable\n    // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n    // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n        use crate::ptr;\n        use crate::time::Instant;\n\n        // 1000 years\n        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n\n        if dur > max_dur {\n            // OSX implementation of `pthread_cond_timedwait` is buggy\n            // with super long durations. When duration is greater than\n            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n            // in macOS Sierra return error 316.\n            //\n            // This program demonstrates the issue:\n            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n            //\n            // To work around this issue, and possible bugs of other OSes, timeout\n            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n            // because of spurious wakeups.\n\n            dur = max_dur;\n        }\n\n        // First, figure out what time it currently is, in both system and\n        // stable time.  pthread_cond_timedwait uses system time, but we want to\n        // report timeout based on stable time.\n        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n        let stable_now = Instant::now();\n        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n        debug_assert_eq!(r, 0);\n\n        let nsec = dur.subsec_nanos() as libc::c_long + (sys_now.tv_usec * 1000) as libc::c_long;\n        let extra = (nsec / 1_000_000_000) as libc::time_t;\n        let nsec = nsec % 1_000_000_000;\n        let seconds = saturating_cast_to_time_t(dur.as_secs());\n\n        let timeout = sys_now\n            .tv_sec\n            .checked_add(extra)\n            .and_then(|s| s.checked_add(seconds))\n            .map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec })\n            .unwrap_or(TIMESPEC_MAX);\n\n        // And wait!\n        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n        debug_assert!(r == libc::ETIMEDOUT || r == 0);\n\n        // ETIMEDOUT is not a totally reliable method of determining timeout due\n        // to clock shifts, so do the check ourselves\n        stable_now.elapsed() < dur\n    }\n\n    #[inline]\n    #[cfg(not(target_os = \"dragonfly\"))]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_cond_destroy(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n\n    #[inline]\n    #[cfg(target_os = \"dragonfly\")]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_cond_destroy(self.inner.get());\n        // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n        // a condvar that was just initialized with\n        // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n        // pthread_cond_init() is called, this behaviour no longer occurs.\n        debug_assert!(r == 0 || r == libc::EINVAL);\n    }\n}\n"],["2479","use crate::convert::{TryFrom, TryInto};\nuse crate::fmt;\nuse crate::io::{self, Error, ErrorKind};\nuse crate::num::NonZeroI32;\nuse crate::os::raw::NonZero_c_int;\nuse crate::sys;\nuse crate::sys::cvt;\nuse crate::sys::process::process_common::*;\nuse crate::sys_common::thread;\nuse libc::RTP_ID;\nuse libc::{self, c_char, c_int};\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Command {\n    pub fn spawn(\n        &mut self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        use crate::sys::cvt_r;\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return Err(io::Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            ));\n        }\n        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n        let mut p = Process { pid: 0, status: None };\n\n        unsafe {\n            macro_rules! t {\n                ($e:expr) => {\n                    match $e {\n                        Ok(e) => e,\n                        Err(e) => return Err(e.into()),\n                    }\n                };\n            }\n\n            let mut orig_stdin = libc::STDIN_FILENO;\n            let mut orig_stdout = libc::STDOUT_FILENO;\n            let mut orig_stderr = libc::STDERR_FILENO;\n\n            if let Some(fd) = theirs.stdin.fd() {\n                orig_stdin = t!(cvt_r(|| libc::dup(libc::STDIN_FILENO)));\n                t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n            }\n            if let Some(fd) = theirs.stdout.fd() {\n                orig_stdout = t!(cvt_r(|| libc::dup(libc::STDOUT_FILENO)));\n                t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n            }\n            if let Some(fd) = theirs.stderr.fd() {\n                orig_stderr = t!(cvt_r(|| libc::dup(libc::STDERR_FILENO)));\n                t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n            }\n\n            if let Some(ref cwd) = *self.get_cwd() {\n                t!(cvt(libc::chdir(cwd.as_ptr())));\n            }\n\n            // pre_exec closures are ignored on VxWorks\n            let _ = self.get_closures();\n\n            let c_envp = envp\n                .as_ref()\n                .map(|c| c.as_ptr())\n                .unwrap_or_else(|| *sys::os::environ() as *const _);\n            let stack_size = thread::min_stack();\n\n            // ensure that access to the environment is synchronized\n            let _lock = sys::os::env_read_lock();\n\n            let ret = libc::rtpSpawn(\n                self.get_program_cstr().as_ptr(),\n                self.get_argv().as_ptr() as *mut *const c_char, // argv\n                c_envp as *mut *const c_char,\n                100 as c_int, // initial priority\n                stack_size,   // initial stack size.\n                0,            // options\n                0,            // task options\n            );\n\n            // Because FileDesc was not used, each duplicated file descriptor\n            // needs to be closed manually\n            if orig_stdin != libc::STDIN_FILENO {\n                t!(cvt_r(|| libc::dup2(orig_stdin, libc::STDIN_FILENO)));\n                libc::close(orig_stdin);\n            }\n            if orig_stdout != libc::STDOUT_FILENO {\n                t!(cvt_r(|| libc::dup2(orig_stdout, libc::STDOUT_FILENO)));\n                libc::close(orig_stdout);\n            }\n            if orig_stderr != libc::STDERR_FILENO {\n                t!(cvt_r(|| libc::dup2(orig_stderr, libc::STDERR_FILENO)));\n                libc::close(orig_stderr);\n            }\n\n            if ret != libc::RTP_ID_ERROR {\n                p.pid = ret;\n                Ok((p, ours))\n            } else {\n                Err(io::Error::last_os_error())\n            }\n        }\n    }\n\n    pub fn exec(&mut self, default: Stdio) -> io::Error {\n        let ret = Command::spawn(self, default, false);\n        match ret {\n            Ok(t) => unsafe {\n                let mut status = 0 as c_int;\n                libc::waitpid(t.0.pid, &mut status, 0);\n                libc::exit(0);\n            },\n            Err(e) => e,\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Processes\n////////////////////////////////////////////////////////////////////////////////\n\n/// The unique id of the process (this should never be negative).\npub struct Process {\n    pid: RTP_ID,\n    status: Option<ExitStatus>,\n}\n\nimpl Process {\n    pub fn id(&self) -> u32 {\n        self.pid as u32\n    }\n\n    pub fn kill(&mut self) -> io::Result<()> {\n        // If we've already waited on this process then the pid can be recycled\n        // and used for another process, and we probably shouldn't be killing\n        // random processes, so just return an error.\n        if self.status.is_some() {\n            Err(Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"invalid argument: can't kill an exited process\",\n            ))\n        } else {\n            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)\n        }\n    }\n\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        use crate::sys::cvt_r;\n        if let Some(status) = self.status {\n            return Ok(status);\n        }\n        let mut status = 0 as c_int;\n        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n        self.status = Some(ExitStatus::new(status));\n        Ok(ExitStatus::new(status))\n    }\n\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        if let Some(status) = self.status {\n            return Ok(Some(status));\n        }\n        let mut status = 0 as c_int;\n        let pid = cvt(unsafe { libc::waitpid(self.pid, &mut status, libc::WNOHANG) })?;\n        if pid == 0 {\n            Ok(None)\n        } else {\n            self.status = Some(ExitStatus::new(status));\n            Ok(Some(ExitStatus::new(status)))\n        }\n    }\n}\n\n/// Unix exit statuses\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatus(c_int);\n\nimpl ExitStatus {\n    pub fn new(status: c_int) -> ExitStatus {\n        ExitStatus(status)\n    }\n\n    fn exited(&self) -> bool {\n        libc::WIFEXITED(self.0)\n    }\n\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n        // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n        // true for a platform pretending to be Unix, the tests (our doctests, and also\n        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n        match NonZero_c_int::try_from(self.0) {\n            Ok(failure) => Err(ExitStatusError(failure)),\n            Err(_) => Ok(()),\n        }\n    }\n\n    pub fn code(&self) -> Option<i32> {\n        if self.exited() { Some(libc::WEXITSTATUS(self.0)) } else { None }\n    }\n\n    pub fn signal(&self) -> Option<i32> {\n        if !self.exited() { Some(libc::WTERMSIG(self.0)) } else { None }\n    }\n\n    pub fn core_dumped(&self) -> bool {\n        // This method is not yet properly implemented on VxWorks\n        false\n    }\n\n    pub fn stopped_signal(&self) -> Option<i32> {\n        if libc::WIFSTOPPED(self.0) { Some(libc::WSTOPSIG(self.0)) } else { None }\n    }\n\n    pub fn continued(&self) -> bool {\n        // This method is not yet properly implemented on VxWorks\n        false\n    }\n\n    pub fn into_raw(&self) -> c_int {\n        self.0\n    }\n}\n\n/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\nimpl From<c_int> for ExitStatus {\n    fn from(a: c_int) -> ExitStatus {\n        ExitStatus(a)\n    }\n}\n\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(code) = self.code() {\n            write!(f, \"exit code: {}\", code)\n        } else {\n            let signal = self.signal().unwrap();\n            write!(f, \"signal: {}\", signal)\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatusError(NonZero_c_int);\n\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        ExitStatus(self.0.into())\n    }\n}\n\nimpl ExitStatusError {\n    pub fn code(self) -> Option<NonZeroI32> {\n        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n    }\n}\n"],["2480","pub use self::process_common::{Command, CommandArgs, ExitCode, Stdio, StdioPipes};\npub use self::process_inner::{ExitStatus, ExitStatusError, Process};\npub use crate::ffi::OsString as EnvKey;\npub use crate::sys_common::process::CommandEnvs;\n\nmod process_common;\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"fuchsia\")] {\n        #[path = \"process_fuchsia.rs\"]\n        mod process_inner;\n        mod zircon;\n    } else if #[cfg(target_os = \"vxworks\")] {\n        #[path = \"process_vxworks.rs\"]\n        mod process_inner;\n    } else {\n        #[path = \"process_unix.rs\"]\n        mod process_inner;\n    }\n}\n"],["2481","#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\nuse crate::os::unix::prelude::*;\n\nuse crate::collections::BTreeMap;\nuse crate::ffi::{CStr, CString, OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::path::Path;\nuse crate::ptr;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::fs::File;\nuse crate::sys::pipe::{self, AnonPipe};\nuse crate::sys_common::process::{CommandEnv, CommandEnvs};\n\n#[cfg(not(target_os = \"fuchsia\"))]\nuse crate::sys::fs::OpenOptions;\n\nuse libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"fuchsia\")] {\n        // fuchsia doesn't have /dev/null\n    } else if #[cfg(target_os = \"redox\")] {\n        const DEV_NULL: &str = \"null:\\0\";\n    } else if #[cfg(target_os = \"vxworks\")] {\n        const DEV_NULL: &str = \"/null\\0\";\n    } else {\n        const DEV_NULL: &str = \"/dev/null\\0\";\n    }\n}\n\n// Android with api less than 21 define sig* functions inline, so it is not\n// available for dynamic link. Implementing sigemptyset and sigaddset allow us\n// to support older Android version (independent of libc version).\n// The following implementations are based on https://git.io/vSkNf\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"android\")] {\n        pub unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n            set.write_bytes(0u8, 1);\n            return 0;\n        }\n        #[allow(dead_code)]\n        pub unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n            use crate::{slice, mem};\n\n            let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n            let bit = (signum - 1) as usize;\n            raw[bit / 8] |= 1 << (bit % 8);\n            return 0;\n        }\n    } else if #[cfg(not(target_os = \"vxworks\"))] {\n        pub use libc::{sigemptyset, sigaddset};\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\npub struct Command {\n    program: CString,\n    args: Vec<CString>,\n    /// Exactly what will be passed to `execvp`.\n    ///\n    /// First element is a pointer to `program`, followed by pointers to\n    /// `args`, followed by a `null`. Be careful when modifying `program` or\n    /// `args` to properly update this as well.\n    argv: Argv,\n    env: CommandEnv,\n\n    cwd: Option<CString>,\n    uid: Option<uid_t>,\n    gid: Option<gid_t>,\n    saw_nul: bool,\n    closures: Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>>,\n    groups: Option<Box<[gid_t]>>,\n    stdin: Option<Stdio>,\n    stdout: Option<Stdio>,\n    stderr: Option<Stdio>,\n}\n\n// Create a new type for argv, so that we can make it `Send` and `Sync`\nstruct Argv(Vec<*const c_char>);\n\n// It is safe to make `Argv` `Send` and `Sync`, because it contains\n// pointers to memory owned by `Command.args`\nunsafe impl Send for Argv {}\nunsafe impl Sync for Argv {}\n\n// passed back to std::process with the pipes connected to the child, if any\n// were requested\npub struct StdioPipes {\n    pub stdin: Option<AnonPipe>,\n    pub stdout: Option<AnonPipe>,\n    pub stderr: Option<AnonPipe>,\n}\n\n// passed to do_exec() with configuration of what the child stdio should look\n// like\npub struct ChildPipes {\n    pub stdin: ChildStdio,\n    pub stdout: ChildStdio,\n    pub stderr: ChildStdio,\n}\n\npub enum ChildStdio {\n    Inherit,\n    Explicit(c_int),\n    Owned(FileDesc),\n\n    // On Fuchsia, null stdio is the default, so we simply don't specify\n    // any actions at the time of spawning.\n    #[cfg(target_os = \"fuchsia\")]\n    Null,\n}\n\npub enum Stdio {\n    Inherit,\n    Null,\n    MakePipe,\n    Fd(FileDesc),\n}\n\nimpl Command {\n    pub fn new(program: &OsStr) -> Command {\n        let mut saw_nul = false;\n        let program = os2c(program, &mut saw_nul);\n        Command {\n            argv: Argv(vec![program.as_ptr(), ptr::null()]),\n            args: vec![program.clone()],\n            program,\n            env: Default::default(),\n            cwd: None,\n            uid: None,\n            gid: None,\n            saw_nul,\n            closures: Vec::new(),\n            groups: None,\n            stdin: None,\n            stdout: None,\n            stderr: None,\n        }\n    }\n\n    pub fn set_arg_0(&mut self, arg: &OsStr) {\n        // Set a new arg0\n        let arg = os2c(arg, &mut self.saw_nul);\n        debug_assert!(self.argv.0.len() > 1);\n        self.argv.0[0] = arg.as_ptr();\n        self.args[0] = arg;\n    }\n\n    pub fn arg(&mut self, arg: &OsStr) {\n        // Overwrite the trailing null pointer in `argv` and then add a new null\n        // pointer.\n        let arg = os2c(arg, &mut self.saw_nul);\n        self.argv.0[self.args.len()] = arg.as_ptr();\n        self.argv.0.push(ptr::null());\n\n        // Also make sure we keep track of the owned value to schedule a\n        // destructor for this memory.\n        self.args.push(arg);\n    }\n\n    pub fn cwd(&mut self, dir: &OsStr) {\n        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n    }\n    pub fn uid(&mut self, id: uid_t) {\n        self.uid = Some(id);\n    }\n    pub fn gid(&mut self, id: gid_t) {\n        self.gid = Some(id);\n    }\n    pub fn groups(&mut self, groups: &[gid_t]) {\n        self.groups = Some(Box::from(groups));\n    }\n\n    pub fn saw_nul(&self) -> bool {\n        self.saw_nul\n    }\n\n    pub fn get_program(&self) -> &OsStr {\n        OsStr::from_bytes(self.program.as_bytes())\n    }\n\n    pub fn get_args(&self) -> CommandArgs<'_> {\n        let mut iter = self.args.iter();\n        iter.next();\n        CommandArgs { iter }\n    }\n\n    pub fn get_envs(&self) -> CommandEnvs<'_> {\n        self.env.iter()\n    }\n\n    pub fn get_current_dir(&self) -> Option<&Path> {\n        self.cwd.as_ref().map(|cs| Path::new(OsStr::from_bytes(cs.as_bytes())))\n    }\n\n    pub fn get_argv(&self) -> &Vec<*const c_char> {\n        &self.argv.0\n    }\n\n    pub fn get_program_cstr(&self) -> &CStr {\n        &*self.program\n    }\n\n    #[allow(dead_code)]\n    pub fn get_cwd(&self) -> &Option<CString> {\n        &self.cwd\n    }\n    #[allow(dead_code)]\n    pub fn get_uid(&self) -> Option<uid_t> {\n        self.uid\n    }\n    #[allow(dead_code)]\n    pub fn get_gid(&self) -> Option<gid_t> {\n        self.gid\n    }\n    #[allow(dead_code)]\n    pub fn get_groups(&self) -> Option<&[gid_t]> {\n        self.groups.as_deref()\n    }\n\n    pub fn get_closures(&mut self) -> &mut Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>> {\n        &mut self.closures\n    }\n\n    pub unsafe fn pre_exec(&mut self, f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n        self.closures.push(f);\n    }\n\n    pub fn stdin(&mut self, stdin: Stdio) {\n        self.stdin = Some(stdin);\n    }\n\n    pub fn stdout(&mut self, stdout: Stdio) {\n        self.stdout = Some(stdout);\n    }\n\n    pub fn stderr(&mut self, stderr: Stdio) {\n        self.stderr = Some(stderr);\n    }\n\n    pub fn env_mut(&mut self) -> &mut CommandEnv {\n        &mut self.env\n    }\n\n    pub fn capture_env(&mut self) -> Option<CStringArray> {\n        let maybe_env = self.env.capture_if_changed();\n        maybe_env.map(|env| construct_envp(env, &mut self.saw_nul))\n    }\n\n    #[allow(dead_code)]\n    pub fn env_saw_path(&self) -> bool {\n        self.env.have_changed_path()\n    }\n\n    #[allow(dead_code)]\n    pub fn program_is_path(&self) -> bool {\n        self.program.to_bytes().contains(&b'/')\n    }\n\n    pub fn setup_io(\n        &self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(StdioPipes, ChildPipes)> {\n        let null = Stdio::Null;\n        let default_stdin = if needs_stdin { &default } else { &null };\n        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n        let stdout = self.stdout.as_ref().unwrap_or(&default);\n        let stderr = self.stderr.as_ref().unwrap_or(&default);\n        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n        Ok((ours, theirs))\n    }\n}\n\nfn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n        *saw_nul = true;\n        CString::new(\"<string-with-nul>\").unwrap()\n    })\n}\n\n// Helper type to manage ownership of the strings within a C-style array.\npub struct CStringArray {\n    items: Vec<CString>,\n    ptrs: Vec<*const c_char>,\n}\n\nimpl CStringArray {\n    pub fn with_capacity(capacity: usize) -> Self {\n        let mut result = CStringArray {\n            items: Vec::with_capacity(capacity),\n            ptrs: Vec::with_capacity(capacity + 1),\n        };\n        result.ptrs.push(ptr::null());\n        result\n    }\n    pub fn push(&mut self, item: CString) {\n        let l = self.ptrs.len();\n        self.ptrs[l - 1] = item.as_ptr();\n        self.ptrs.push(ptr::null());\n        self.items.push(item);\n    }\n    pub fn as_ptr(&self) -> *const *const c_char {\n        self.ptrs.as_ptr()\n    }\n}\n\nfn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStringArray {\n    let mut result = CStringArray::with_capacity(env.len());\n    for (mut k, v) in env {\n        // Reserve additional space for '=' and null terminator\n        k.reserve_exact(v.len() + 2);\n        k.push(\"=\");\n        k.push(&v);\n\n        // Add the new entry into the array\n        if let Ok(item) = CString::new(k.into_vec()) {\n            result.push(item);\n        } else {\n            *saw_nul = true;\n        }\n    }\n\n    result\n}\n\nimpl Stdio {\n    pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n        match *self {\n            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n\n            // Make sure that the source descriptors are not an stdio\n            // descriptor, otherwise the order which we set the child's\n            // descriptors may blow away a descriptor which we are hoping to\n            // save. For example, suppose we want the child's stderr to be the\n            // parent's stdout, and the child's stdout to be the parent's\n            // stderr. No matter which we dup first, the second will get\n            // overwritten prematurely.\n            Stdio::Fd(ref fd) => {\n                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n                } else {\n                    Ok((ChildStdio::Explicit(fd.raw()), None))\n                }\n            }\n\n            Stdio::MakePipe => {\n                let (reader, writer) = pipe::anon_pipe()?;\n                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n            }\n\n            #[cfg(not(target_os = \"fuchsia\"))]\n            Stdio::Null => {\n                let mut opts = OpenOptions::new();\n                opts.read(readable);\n                opts.write(!readable);\n                let path = unsafe { CStr::from_ptr(DEV_NULL.as_ptr() as *const _) };\n                let fd = File::open_c(&path, &opts)?;\n                Ok((ChildStdio::Owned(fd.into_fd()), None))\n            }\n\n            #[cfg(target_os = \"fuchsia\")]\n            Stdio::Null => Ok((ChildStdio::Null, None)),\n        }\n    }\n}\n\nimpl From<AnonPipe> for Stdio {\n    fn from(pipe: AnonPipe) -> Stdio {\n        Stdio::Fd(pipe.into_fd())\n    }\n}\n\nimpl From<File> for Stdio {\n    fn from(file: File) -> Stdio {\n        Stdio::Fd(file.into_fd())\n    }\n}\n\nimpl ChildStdio {\n    pub fn fd(&self) -> Option<c_int> {\n        match *self {\n            ChildStdio::Inherit => None,\n            ChildStdio::Explicit(fd) => Some(fd),\n            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n\n            #[cfg(target_os = \"fuchsia\")]\n            ChildStdio::Null => None,\n        }\n    }\n}\n\nimpl fmt::Debug for Command {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.program != self.args[0] {\n            write!(f, \"[{:?}] \", self.program)?;\n        }\n        write!(f, \"{:?}\", self.args[0])?;\n\n        for arg in &self.args[1..] {\n            write!(f, \" {:?}\", arg)?;\n        }\n        Ok(())\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitCode(u8);\n\nimpl ExitCode {\n    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n\n    #[inline]\n    pub fn as_i32(&self) -> i32 {\n        self.0 as i32\n    }\n}\n\npub struct CommandArgs<'a> {\n    iter: crate::slice::Iter<'a, CString>,\n}\n\nimpl<'a> Iterator for CommandArgs<'a> {\n    type Item = &'a OsStr;\n    fn next(&mut self) -> Option<&'a OsStr> {\n        self.iter.next().map(|cs| OsStr::from_bytes(cs.as_bytes()))\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<'a> ExactSizeIterator for CommandArgs<'a> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\nimpl<'a> fmt::Debug for CommandArgs<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter.clone()).finish()\n    }\n}\n"],["2482","use crate::os::unix::process::{CommandExt, ExitStatusExt};\nuse crate::panic::catch_unwind;\nuse crate::process::Command;\n\n// Many of the other aspects of this situation, including heap alloc concurrency\n// safety etc., are tested in src/test/ui/process/process-panic-after-fork.rs\n\n#[test]\nfn exitstatus_display_tests() {\n    // In practice this is the same on every Unix.\n    // If some weird platform turns out to be different, and this test fails, use #[cfg].\n    use crate::os::unix::process::ExitStatusExt;\n    use crate::process::ExitStatus;\n\n    let t = |v, s| assert_eq!(s, format!(\"{}\", <ExitStatus as ExitStatusExt>::from_raw(v)));\n\n    t(0x0000f, \"signal: 15\");\n    t(0x0008b, \"signal: 11 (core dumped)\");\n    t(0x00000, \"exit status: 0\");\n    t(0x0ff00, \"exit status: 255\");\n\n    // On MacOS, 0x0137f is WIFCONTINUED, not WIFSTOPPED.  Probably *BSD is similar.\n    //   https://github.com/rust-lang/rust/pull/82749#issuecomment-790525956\n    // The purpose of this test is to test our string formatting, not our understanding of the wait\n    // status magic numbers.  So restrict these to Linux.\n    if cfg!(target_os = \"linux\") {\n        t(0x0137f, \"stopped (not terminated) by signal: 19\");\n        t(0x0ffff, \"continued (WIFCONTINUED)\");\n    }\n\n    // Testing \"unrecognised wait status\" is hard because the wait.h macros typically\n    // assume that the value came from wait and isn't mad.  With the glibc I have here\n    // this works:\n    if cfg!(all(target_os = \"linux\", target_env = \"gnu\")) {\n        t(0x000ff, \"unrecognised wait status: 255 0xff\");\n    }\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn test_command_fork_no_unwind() {\n    let got = catch_unwind(|| {\n        let mut c = Command::new(\"echo\");\n        c.arg(\"hi\");\n        unsafe {\n            c.pre_exec(|| panic!(\"{}\", \"crash now!\"));\n        }\n        let st = c.status().expect(\"failed to get command status\");\n        dbg!(st);\n        st\n    });\n    dbg!(&got);\n    let status = got.expect(\"panic unexpectedly propagated\");\n    dbg!(status);\n    let signal = status.signal().expect(\"expected child process to die of signal\");\n    assert!(signal == libc::SIGABRT || signal == libc::SIGILL || signal == libc::SIGTRAP);\n}\n"],["2483","use crate::convert::{TryFrom, TryInto};\nuse crate::fmt;\nuse crate::io;\nuse crate::mem;\nuse crate::num::{NonZeroI32, NonZeroI64};\nuse crate::ptr;\n\nuse crate::sys::process::process_common::*;\nuse crate::sys::process::zircon::{zx_handle_t, Handle};\n\nuse libc::{c_int, size_t};\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Command {\n    pub fn spawn(\n        &mut self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            ));\n        }\n\n        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n\n        let process_handle = unsafe { self.do_exec(theirs, envp.as_ref())? };\n\n        Ok((Process { handle: Handle::new(process_handle) }, ours))\n    }\n\n    pub fn exec(&mut self, default: Stdio) -> io::Error {\n        if self.saw_nul() {\n            return io::Error::new_const(\n                io::ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            );\n        }\n\n        match self.setup_io(default, true) {\n            Ok((_, _)) => {\n                // FIXME: This is tough because we don't support the exec syscalls\n                unimplemented!();\n            }\n            Err(e) => e,\n        }\n    }\n\n    unsafe fn do_exec(\n        &mut self,\n        stdio: ChildPipes,\n        maybe_envp: Option<&CStringArray>,\n    ) -> io::Result<zx_handle_t> {\n        use crate::sys::process::zircon::*;\n\n        let envp = match maybe_envp {\n            // None means to clone the current environment, which is done in the\n            // flags below.\n            None => ptr::null(),\n            Some(envp) => envp.as_ptr(),\n        };\n\n        let make_action = |local_io: &ChildStdio, target_fd| -> io::Result<fdio_spawn_action_t> {\n            if let Some(local_fd) = local_io.fd() {\n                Ok(fdio_spawn_action_t {\n                    action: FDIO_SPAWN_ACTION_TRANSFER_FD,\n                    local_fd,\n                    target_fd,\n                    ..Default::default()\n                })\n            } else {\n                if let ChildStdio::Null = local_io {\n                    // acts as no-op\n                    return Ok(Default::default());\n                }\n\n                let mut handle = ZX_HANDLE_INVALID;\n                let status = fdio_fd_clone(target_fd, &mut handle);\n                if status == ERR_INVALID_ARGS || status == ERR_NOT_SUPPORTED {\n                    // This descriptor is closed; skip it rather than generating an\n                    // error.\n                    return Ok(Default::default());\n                }\n                zx_cvt(status)?;\n\n                let mut cloned_fd = 0;\n                zx_cvt(fdio_fd_create(handle, &mut cloned_fd))?;\n\n                Ok(fdio_spawn_action_t {\n                    action: FDIO_SPAWN_ACTION_TRANSFER_FD,\n                    local_fd: cloned_fd as i32,\n                    target_fd,\n                    ..Default::default()\n                })\n            }\n        };\n\n        // Clone stdin, stdout, and stderr\n        let action1 = make_action(&stdio.stdin, 0)?;\n        let action2 = make_action(&stdio.stdout, 1)?;\n        let action3 = make_action(&stdio.stderr, 2)?;\n        let actions = [action1, action2, action3];\n\n        // We don't want FileDesc::drop to be called on any stdio. fdio_spawn_etc\n        // always consumes transferred file descriptors.\n        mem::forget(stdio);\n\n        for callback in self.get_closures().iter_mut() {\n            callback()?;\n        }\n\n        let mut process_handle: zx_handle_t = 0;\n        zx_cvt(fdio_spawn_etc(\n            ZX_HANDLE_INVALID,\n            FDIO_SPAWN_CLONE_JOB\n                | FDIO_SPAWN_CLONE_LDSVC\n                | FDIO_SPAWN_CLONE_NAMESPACE\n                | FDIO_SPAWN_CLONE_ENVIRON // this is ignored when envp is non-null\n                | FDIO_SPAWN_CLONE_UTC_CLOCK,\n            self.get_program_cstr().as_ptr(),\n            self.get_argv().as_ptr(),\n            envp,\n            actions.len() as size_t,\n            actions.as_ptr(),\n            &mut process_handle,\n            ptr::null_mut(),\n        ))?;\n        // FIXME: See if we want to do something with that err_msg\n\n        Ok(process_handle)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Processes\n////////////////////////////////////////////////////////////////////////////////\n\npub struct Process {\n    handle: Handle,\n}\n\nimpl Process {\n    pub fn id(&self) -> u32 {\n        self.handle.raw() as u32\n    }\n\n    pub fn kill(&mut self) -> io::Result<()> {\n        use crate::sys::process::zircon::*;\n\n        unsafe {\n            zx_cvt(zx_task_kill(self.handle.raw()))?;\n        }\n\n        Ok(())\n    }\n\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        use crate::default::Default;\n        use crate::sys::process::zircon::*;\n\n        let mut proc_info: zx_info_process_t = Default::default();\n        let mut actual: size_t = 0;\n        let mut avail: size_t = 0;\n\n        unsafe {\n            zx_cvt(zx_object_wait_one(\n                self.handle.raw(),\n                ZX_TASK_TERMINATED,\n                ZX_TIME_INFINITE,\n                ptr::null_mut(),\n            ))?;\n            zx_cvt(zx_object_get_info(\n                self.handle.raw(),\n                ZX_INFO_PROCESS,\n                &mut proc_info as *mut _ as *mut libc::c_void,\n                mem::size_of::<zx_info_process_t>(),\n                &mut actual,\n                &mut avail,\n            ))?;\n        }\n        if actual != 1 {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidData,\n                &\"Failed to get exit status of process\",\n            ));\n        }\n        Ok(ExitStatus(proc_info.return_code))\n    }\n\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        use crate::default::Default;\n        use crate::sys::process::zircon::*;\n\n        let mut proc_info: zx_info_process_t = Default::default();\n        let mut actual: size_t = 0;\n        let mut avail: size_t = 0;\n\n        unsafe {\n            let status =\n                zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED, 0, ptr::null_mut());\n            match status {\n                0 => {} // Success\n                x if x == ERR_TIMED_OUT => {\n                    return Ok(None);\n                }\n                _ => {\n                    panic!(\"Failed to wait on process handle: {}\", status);\n                }\n            }\n            zx_cvt(zx_object_get_info(\n                self.handle.raw(),\n                ZX_INFO_PROCESS,\n                &mut proc_info as *mut _ as *mut libc::c_void,\n                mem::size_of::<zx_info_process_t>(),\n                &mut actual,\n                &mut avail,\n            ))?;\n        }\n        if actual != 1 {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidData,\n                &\"Failed to get exit status of process\",\n            ));\n        }\n        Ok(Some(ExitStatus(proc_info.return_code)))\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatus(i64);\n\nimpl ExitStatus {\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        match NonZeroI64::try_from(self.0) {\n            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n            /* was zero, couldn't convert */ Err(_) => Ok(()),\n        }\n    }\n\n    pub fn code(&self) -> Option<i32> {\n        // FIXME: support extracting return code as an i64\n        self.0.try_into().ok()\n    }\n\n    pub fn signal(&self) -> Option<i32> {\n        None\n    }\n\n    // FIXME: The actually-Unix implementation in process_unix.rs uses WSTOPSIG, WCOREDUMP et al.\n    // I infer from the implementation of `success`, `code` and `signal` above that these are not\n    // available on Fuchsia.\n    //\n    // It does not appear that Fuchsia is Unix-like enough to implement ExitStatus (or indeed many\n    // other things from std::os::unix) properly.  This veneer is always going to be a bodge.  So\n    // while I don't know if these implementations are actually correct, I think they will do for\n    // now at least.\n    pub fn core_dumped(&self) -> bool {\n        false\n    }\n    pub fn stopped_signal(&self) -> Option<i32> {\n        None\n    }\n    pub fn continued(&self) -> bool {\n        false\n    }\n\n    pub fn into_raw(&self) -> c_int {\n        // We don't know what someone who calls into_raw() will do with this value, but it should\n        // have the conventional Unix representation.  Despite the fact that this is not\n        // standardised in SuS or POSIX, all Unix systems encode the signal and exit status the\n        // same way.  (Ie the WIFEXITED, WEXITSTATUS etc. macros have identical behaviour on every\n        // Unix.)\n        //\n        // The caller of `std::os::unix::into_raw` is probably wanting a Unix exit status, and may\n        // do their own shifting and masking, or even pass the status to another computer running a\n        // different Unix variant.\n        //\n        // The other view would be to say that the caller on Fuchsia ought to know that `into_raw`\n        // will give a raw Fuchsia status (whatever that is - I don't know, personally).  That is\n        // not possible here becaause we must return a c_int because that's what Unix (including\n        // SuS and POSIX) say a wait status is, but Fuchsia apparently uses a u64, so it won't\n        // necessarily fit.\n        //\n        // It seems to me that that the right answer would be to provide std::os::fuchsia with its\n        // own ExitStatusExt, rather that trying to provide a not very convincing imitation of\n        // Unix.  Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia.  But\n        // fixing this up that is beyond the scope of my efforts now.\n        let exit_status_as_if_unix: u8 = self.0.try_into().expect(\"Fuchsia process return code bigger than 8 bits, but std::os::unix::ExitStatusExt::into_raw() was called to try to convert the value into a traditional Unix-style wait status, which cannot represent values greater than 255.\");\n        let wait_status_as_if_unix = (exit_status_as_if_unix as c_int) << 8;\n        wait_status_as_if_unix\n    }\n}\n\n/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\nimpl From<c_int> for ExitStatus {\n    fn from(a: c_int) -> ExitStatus {\n        ExitStatus(a as i64)\n    }\n}\n\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"exit code: {}\", self.0)\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatusError(NonZeroI64);\n\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        ExitStatus(self.0.into())\n    }\n}\n\nimpl ExitStatusError {\n    pub fn code(self) -> Option<NonZeroI32> {\n        // fixme: affected by the same bug as ExitStatus::code()\n        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n    }\n}\n"],["2484","use super::*;\n\nuse crate::ffi::OsStr;\nuse crate::mem;\nuse crate::ptr;\nuse crate::sys::cvt;\n\nmacro_rules! t {\n    ($e:expr) => {\n        match $e {\n            Ok(t) => t,\n            Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n        }\n    };\n}\n\n#[test]\n#[cfg_attr(\n    any(\n        // See #14232 for more information, but it appears that signal delivery to a\n        // newly spawned process may just be raced in the macOS, so to prevent this\n        // test from being flaky we ignore it on macOS.\n        target_os = \"macos\",\n        // When run under our current QEMU emulation test suite this test fails,\n        // although the reason isn't very clear as to why. For now this test is\n        // ignored there.\n        target_arch = \"arm\",\n        target_arch = \"aarch64\",\n        target_arch = \"riscv64\",\n    ),\n    ignore\n)]\nfn test_process_mask() {\n    unsafe {\n        // Test to make sure that a signal mask does not get inherited.\n        let mut cmd = Command::new(OsStr::new(\"cat\"));\n\n        let mut set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n        let mut old_set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n        t!(cvt(sigemptyset(set.as_mut_ptr())));\n        t!(cvt(sigaddset(set.as_mut_ptr(), libc::SIGINT)));\n        t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), old_set.as_mut_ptr())));\n\n        cmd.stdin(Stdio::MakePipe);\n        cmd.stdout(Stdio::MakePipe);\n\n        let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n        let stdin_write = pipes.stdin.take().unwrap();\n        let stdout_read = pipes.stdout.take().unwrap();\n\n        t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(), ptr::null_mut())));\n\n        t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n        // We need to wait until SIGINT is definitely delivered. The\n        // easiest way is to write something to cat, and try to read it\n        // back: if SIGINT is unmasked, it'll get delivered when cat is\n        // next scheduled.\n        let _ = stdin_write.write(b\"Hello\");\n        drop(stdin_write);\n\n        // Either EOF or failure (EPIPE) is okay.\n        let mut buf = [0; 5];\n        if let Ok(ret) = stdout_read.read(&mut buf) {\n            assert_eq!(ret, 0);\n        }\n\n        t!(cat.wait());\n    }\n}\n"],["2485","use crate::convert::{TryFrom, TryInto};\nuse crate::fmt;\nuse crate::io::{self, Error, ErrorKind};\nuse crate::mem;\nuse crate::num::NonZeroI32;\nuse crate::os::raw::NonZero_c_int;\nuse crate::ptr;\nuse crate::sys;\nuse crate::sys::cvt;\nuse crate::sys::process::process_common::*;\n\n#[cfg(target_os = \"vxworks\")]\nuse libc::RTP_ID as pid_t;\n\n#[cfg(not(target_os = \"vxworks\"))]\nuse libc::{c_int, gid_t, pid_t, uid_t};\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Command {\n    pub fn spawn(\n        &mut self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        const CLOEXEC_MSG_FOOTER: [u8; 4] = *b\"NOEX\";\n\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return Err(io::Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            ));\n        }\n\n        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n\n        if let Some(ret) = self.posix_spawn(&theirs, envp.as_ref())? {\n            return Ok((ret, ours));\n        }\n\n        let (input, output) = sys::pipe::anon_pipe()?;\n\n        // Whatever happens after the fork is almost for sure going to touch or\n        // look at the environment in one way or another (PATH in `execvp` or\n        // accessing the `environ` pointer ourselves). Make sure no other thread\n        // is accessing the environment when we do the fork itself.\n        //\n        // Note that as soon as we're done with the fork there's no need to hold\n        // a lock any more because the parent won't do anything and the child is\n        // in its own process. Thus the parent drops the lock guard while the child\n        // forgets it to avoid unlocking it on a new thread, which would be invalid.\n        let (env_lock, pid) = unsafe { (sys::os::env_read_lock(), cvt(libc::fork())?) };\n\n        if pid == 0 {\n            crate::panic::always_abort();\n            mem::forget(env_lock);\n            drop(input);\n            let Err(err) = unsafe { self.do_exec(theirs, envp.as_ref()) };\n            let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n            let errno = errno.to_be_bytes();\n            let bytes = [\n                errno[0],\n                errno[1],\n                errno[2],\n                errno[3],\n                CLOEXEC_MSG_FOOTER[0],\n                CLOEXEC_MSG_FOOTER[1],\n                CLOEXEC_MSG_FOOTER[2],\n                CLOEXEC_MSG_FOOTER[3],\n            ];\n            // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n            // we want to be sure we *don't* run at_exit destructors as\n            // we're being torn down regardless\n            rtassert!(output.write(&bytes).is_ok());\n            unsafe { libc::_exit(1) }\n        }\n\n        drop(env_lock);\n        drop(output);\n\n        let mut p = Process { pid, status: None };\n        let mut bytes = [0; 8];\n\n        // loop to handle EINTR\n        loop {\n            match input.read(&mut bytes) {\n                Ok(0) => return Ok((p, ours)),\n                Ok(8) => {\n                    let (errno, footer) = bytes.split_at(4);\n                    assert_eq!(\n                        CLOEXEC_MSG_FOOTER, footer,\n                        \"Validation on the CLOEXEC pipe failed: {:?}\",\n                        bytes\n                    );\n                    let errno = i32::from_be_bytes(errno.try_into().unwrap());\n                    assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                    return Err(Error::from_raw_os_error(errno));\n                }\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => {\n                    assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n                }\n                Ok(..) => {\n                    // pipe I/O up to PIPE_BUF bytes should be atomic\n                    assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                    panic!(\"short read on the CLOEXEC pipe\")\n                }\n            }\n        }\n    }\n\n    pub fn exec(&mut self, default: Stdio) -> io::Error {\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return io::Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"nul byte found in provided data\",\n            );\n        }\n\n        match self.setup_io(default, true) {\n            Ok((_, theirs)) => {\n                unsafe {\n                    // Similar to when forking, we want to ensure that access to\n                    // the environment is synchronized, so make sure to grab the\n                    // environment lock before we try to exec.\n                    let _lock = sys::os::env_read_lock();\n\n                    let Err(e) = self.do_exec(theirs, envp.as_ref());\n                    e\n                }\n            }\n            Err(e) => e,\n        }\n    }\n\n    // And at this point we've reached a special time in the life of the\n    // child. The child must now be considered hamstrung and unable to\n    // do anything other than syscalls really. Consider the following\n    // scenario:\n    //\n    //      1. Thread A of process 1 grabs the malloc() mutex\n    //      2. Thread B of process 1 forks(), creating thread C\n    //      3. Thread C of process 2 then attempts to malloc()\n    //      4. The memory of process 2 is the same as the memory of\n    //         process 1, so the mutex is locked.\n    //\n    // This situation looks a lot like deadlock, right? It turns out\n    // that this is what pthread_atfork() takes care of, which is\n    // presumably implemented across platforms. The first thing that\n    // threads to *before* forking is to do things like grab the malloc\n    // mutex, and then after the fork they unlock it.\n    //\n    // Despite this information, libnative's spawn has been witnessed to\n    // deadlock on both macOS and FreeBSD. I'm not entirely sure why, but\n    // all collected backtraces point at malloc/free traffic in the\n    // child spawned process.\n    //\n    // For this reason, the block of code below should contain 0\n    // invocations of either malloc of free (or their related friends).\n    //\n    // As an example of not having malloc/free traffic, we don't close\n    // this file descriptor by dropping the FileDesc (which contains an\n    // allocation). Instead we just close it manually. This will never\n    // have the drop glue anyway because this code never returns (the\n    // child will either exec() or invoke libc::exit)\n    unsafe fn do_exec(\n        &mut self,\n        stdio: ChildPipes,\n        maybe_envp: Option<&CStringArray>,\n    ) -> Result<!, io::Error> {\n        use crate::sys::{self, cvt_r};\n\n        if let Some(fd) = stdio.stdin.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO))?;\n        }\n        if let Some(fd) = stdio.stdout.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO))?;\n        }\n        if let Some(fd) = stdio.stderr.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n        }\n\n        #[cfg(not(target_os = \"l4re\"))]\n        {\n            if let Some(_g) = self.get_groups() {\n                //FIXME: Redox kernel does not support setgroups yet\n                #[cfg(not(target_os = \"redox\"))]\n                cvt(libc::setgroups(_g.len().try_into().unwrap(), _g.as_ptr()))?;\n            }\n            if let Some(u) = self.get_gid() {\n                cvt(libc::setgid(u as gid_t))?;\n            }\n            if let Some(u) = self.get_uid() {\n                // When dropping privileges from root, the `setgroups` call\n                // will remove any extraneous groups. We only drop groups\n                // if the current uid is 0 and we weren't given an explicit\n                // set of groups. If we don't call this, then even though our\n                // uid has dropped, we may still have groups that enable us to\n                // do super-user things.\n                //FIXME: Redox kernel does not support setgroups yet\n                #[cfg(not(target_os = \"redox\"))]\n                if libc::getuid() == 0 && self.get_groups().is_none() {\n                    cvt(libc::setgroups(0, ptr::null()))?;\n                }\n                cvt(libc::setuid(u as uid_t))?;\n            }\n        }\n        if let Some(ref cwd) = *self.get_cwd() {\n            cvt(libc::chdir(cwd.as_ptr()))?;\n        }\n\n        // emscripten has no signal support.\n        #[cfg(not(target_os = \"emscripten\"))]\n        {\n            use crate::mem::MaybeUninit;\n            // Reset signal handling so the child process starts in a\n            // standardized state. libstd ignores SIGPIPE, and signal-handling\n            // libraries often set a mask. Child processes inherit ignored\n            // signals and the signal mask from their parent, but most\n            // UNIX programs do not reset these things on their own, so we\n            // need to clean things up now to avoid confusing the program\n            // we're about to run.\n            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n            cvt(sigemptyset(set.as_mut_ptr()))?;\n            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), ptr::null_mut()))?;\n            let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n            if ret == libc::SIG_ERR {\n                return Err(io::Error::last_os_error());\n            }\n        }\n\n        for callback in self.get_closures().iter_mut() {\n            callback()?;\n        }\n\n        // Although we're performing an exec here we may also return with an\n        // error from this function (without actually exec'ing) in which case we\n        // want to be sure to restore the global environment back to what it\n        // once was, ensuring that our temporary override, when free'd, doesn't\n        // corrupt our process's environment.\n        let mut _reset = None;\n        if let Some(envp) = maybe_envp {\n            struct Reset(*const *const libc::c_char);\n\n            impl Drop for Reset {\n                fn drop(&mut self) {\n                    unsafe {\n                        *sys::os::environ() = self.0;\n                    }\n                }\n            }\n\n            _reset = Some(Reset(*sys::os::environ()));\n            *sys::os::environ() = envp.as_ptr();\n        }\n\n        libc::execvp(self.get_program_cstr().as_ptr(), self.get_argv().as_ptr());\n        Err(io::Error::last_os_error())\n    }\n\n    #[cfg(not(any(\n        target_os = \"macos\",\n        target_os = \"freebsd\",\n        all(target_os = \"linux\", target_env = \"gnu\"),\n        all(target_os = \"linux\", target_env = \"musl\"),\n    )))]\n    fn posix_spawn(\n        &mut self,\n        _: &ChildPipes,\n        _: Option<&CStringArray>,\n    ) -> io::Result<Option<Process>> {\n        Ok(None)\n    }\n\n    // Only support platforms for which posix_spawn() can return ENOENT\n    // directly.\n    #[cfg(any(\n        target_os = \"macos\",\n        target_os = \"freebsd\",\n        all(target_os = \"linux\", target_env = \"gnu\"),\n        all(target_os = \"linux\", target_env = \"musl\"),\n    ))]\n    fn posix_spawn(\n        &mut self,\n        stdio: &ChildPipes,\n        envp: Option<&CStringArray>,\n    ) -> io::Result<Option<Process>> {\n        use crate::mem::MaybeUninit;\n        use crate::sys::{self, cvt_nz};\n\n        if self.get_gid().is_some()\n            || self.get_uid().is_some()\n            || (self.env_saw_path() && !self.program_is_path())\n            || !self.get_closures().is_empty()\n            || self.get_groups().is_some()\n        {\n            return Ok(None);\n        }\n\n        // Only glibc 2.24+ posix_spawn() supports returning ENOENT directly.\n        #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n        {\n            if let Some(version) = sys::os::glibc_version() {\n                if version < (2, 24) {\n                    return Ok(None);\n                }\n            } else {\n                return Ok(None);\n            }\n        }\n\n        // Solaris, glibc 2.29+, and musl 1.24+ can set a new working directory,\n        // and maybe others will gain this non-POSIX function too. We'll check\n        // for this weak symbol as soon as it's needed, so we can return early\n        // otherwise to do a manual chdir before exec.\n        weak! {\n            fn posix_spawn_file_actions_addchdir_np(\n                *mut libc::posix_spawn_file_actions_t,\n                *const libc::c_char\n            ) -> libc::c_int\n        }\n        let addchdir = match self.get_cwd() {\n            Some(cwd) => {\n                if cfg!(target_os = \"macos\") {\n                    // There is a bug in macOS where a relative executable\n                    // path like \"../myprogram\" will cause `posix_spawn` to\n                    // successfully launch the program, but erroneously return\n                    // ENOENT when used with posix_spawn_file_actions_addchdir_np\n                    // which was introduced in macOS 10.15.\n                    return Ok(None);\n                }\n                match posix_spawn_file_actions_addchdir_np.get() {\n                    Some(f) => Some((f, cwd)),\n                    None => return Ok(None),\n                }\n            }\n            None => None,\n        };\n\n        let mut p = Process { pid: 0, status: None };\n\n        struct PosixSpawnFileActions<'a>(&'a mut MaybeUninit<libc::posix_spawn_file_actions_t>);\n\n        impl Drop for PosixSpawnFileActions<'_> {\n            fn drop(&mut self) {\n                unsafe {\n                    libc::posix_spawn_file_actions_destroy(self.0.as_mut_ptr());\n                }\n            }\n        }\n\n        struct PosixSpawnattr<'a>(&'a mut MaybeUninit<libc::posix_spawnattr_t>);\n\n        impl Drop for PosixSpawnattr<'_> {\n            fn drop(&mut self) {\n                unsafe {\n                    libc::posix_spawnattr_destroy(self.0.as_mut_ptr());\n                }\n            }\n        }\n\n        unsafe {\n            let mut attrs = MaybeUninit::uninit();\n            cvt_nz(libc::posix_spawnattr_init(attrs.as_mut_ptr()))?;\n            let attrs = PosixSpawnattr(&mut attrs);\n\n            let mut file_actions = MaybeUninit::uninit();\n            cvt_nz(libc::posix_spawn_file_actions_init(file_actions.as_mut_ptr()))?;\n            let file_actions = PosixSpawnFileActions(&mut file_actions);\n\n            if let Some(fd) = stdio.stdin.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDIN_FILENO,\n                ))?;\n            }\n            if let Some(fd) = stdio.stdout.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDOUT_FILENO,\n                ))?;\n            }\n            if let Some(fd) = stdio.stderr.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDERR_FILENO,\n                ))?;\n            }\n            if let Some((f, cwd)) = addchdir {\n                cvt_nz(f(file_actions.0.as_mut_ptr(), cwd.as_ptr()))?;\n            }\n\n            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n            cvt(sigemptyset(set.as_mut_ptr()))?;\n            cvt_nz(libc::posix_spawnattr_setsigmask(attrs.0.as_mut_ptr(), set.as_ptr()))?;\n            cvt(sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n            cvt_nz(libc::posix_spawnattr_setsigdefault(attrs.0.as_mut_ptr(), set.as_ptr()))?;\n\n            let flags = libc::POSIX_SPAWN_SETSIGDEF | libc::POSIX_SPAWN_SETSIGMASK;\n            cvt_nz(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n\n            // Make sure we synchronize access to the global `environ` resource\n            let _env_lock = sys::os::env_read_lock();\n            let envp = envp.map(|c| c.as_ptr()).unwrap_or_else(|| *sys::os::environ() as *const _);\n            cvt_nz(libc::posix_spawnp(\n                &mut p.pid,\n                self.get_program_cstr().as_ptr(),\n                file_actions.0.as_ptr(),\n                attrs.0.as_ptr(),\n                self.get_argv().as_ptr() as *const _,\n                envp as *const _,\n            ))?;\n            Ok(Some(p))\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Processes\n////////////////////////////////////////////////////////////////////////////////\n\n/// The unique ID of the process (this should never be negative).\npub struct Process {\n    pid: pid_t,\n    status: Option<ExitStatus>,\n}\n\nimpl Process {\n    pub fn id(&self) -> u32 {\n        self.pid as u32\n    }\n\n    pub fn kill(&mut self) -> io::Result<()> {\n        // If we've already waited on this process then the pid can be recycled\n        // and used for another process, and we probably shouldn't be killing\n        // random processes, so just return an error.\n        if self.status.is_some() {\n            Err(Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"invalid argument: can't kill an exited process\",\n            ))\n        } else {\n            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)\n        }\n    }\n\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        use crate::sys::cvt_r;\n        if let Some(status) = self.status {\n            return Ok(status);\n        }\n        let mut status = 0 as c_int;\n        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n        self.status = Some(ExitStatus::new(status));\n        Ok(ExitStatus::new(status))\n    }\n\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        if let Some(status) = self.status {\n            return Ok(Some(status));\n        }\n        let mut status = 0 as c_int;\n        let pid = cvt(unsafe { libc::waitpid(self.pid, &mut status, libc::WNOHANG) })?;\n        if pid == 0 {\n            Ok(None)\n        } else {\n            self.status = Some(ExitStatus::new(status));\n            Ok(Some(ExitStatus::new(status)))\n        }\n    }\n}\n\n/// Unix exit statuses\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatus(c_int);\n\nimpl ExitStatus {\n    pub fn new(status: c_int) -> ExitStatus {\n        ExitStatus(status)\n    }\n\n    fn exited(&self) -> bool {\n        libc::WIFEXITED(self.0)\n    }\n\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n        // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n        // true for a platform pretending to be Unix, the tests (our doctests, and also\n        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n        match NonZero_c_int::try_from(self.0) {\n            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n            /* was zero, couldn't convert */ Err(_) => Ok(()),\n        }\n    }\n\n    pub fn code(&self) -> Option<i32> {\n        if self.exited() { Some(libc::WEXITSTATUS(self.0)) } else { None }\n    }\n\n    pub fn signal(&self) -> Option<i32> {\n        if libc::WIFSIGNALED(self.0) { Some(libc::WTERMSIG(self.0)) } else { None }\n    }\n\n    pub fn core_dumped(&self) -> bool {\n        libc::WIFSIGNALED(self.0) && libc::WCOREDUMP(self.0)\n    }\n\n    pub fn stopped_signal(&self) -> Option<i32> {\n        if libc::WIFSTOPPED(self.0) { Some(libc::WSTOPSIG(self.0)) } else { None }\n    }\n\n    pub fn continued(&self) -> bool {\n        libc::WIFCONTINUED(self.0)\n    }\n\n    pub fn into_raw(&self) -> c_int {\n        self.0\n    }\n}\n\n/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\nimpl From<c_int> for ExitStatus {\n    fn from(a: c_int) -> ExitStatus {\n        ExitStatus(a)\n    }\n}\n\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(code) = self.code() {\n            write!(f, \"exit status: {}\", code)\n        } else if let Some(signal) = self.signal() {\n            if self.core_dumped() {\n                write!(f, \"signal: {} (core dumped)\", signal)\n            } else {\n                write!(f, \"signal: {}\", signal)\n            }\n        } else if let Some(signal) = self.stopped_signal() {\n            write!(f, \"stopped (not terminated) by signal: {}\", signal)\n        } else if self.continued() {\n            write!(f, \"continued (WIFCONTINUED)\")\n        } else {\n            write!(f, \"unrecognised wait status: {} {:#x}\", self.0, self.0)\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatusError(NonZero_c_int);\n\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        ExitStatus(self.0.into())\n    }\n}\n\nimpl ExitStatusError {\n    pub fn code(self) -> Option<NonZeroI32> {\n        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n    }\n}\n\n#[cfg(test)]\n#[path = \"process_unix/tests.rs\"]\nmod tests;\n"],["2486","#![allow(non_camel_case_types, unused)]\n\nuse crate::convert::TryInto;\nuse crate::io;\nuse crate::mem::MaybeUninit;\nuse crate::os::raw::c_char;\n\nuse libc::{c_int, c_void, size_t};\n\npub type zx_handle_t = u32;\npub type zx_vaddr_t = usize;\npub type zx_rights_t = u32;\npub type zx_status_t = i32;\n\npub const ZX_HANDLE_INVALID: zx_handle_t = 0;\n\npub type zx_time_t = i64;\npub const ZX_TIME_INFINITE: zx_time_t = i64::MAX;\n\npub type zx_signals_t = u32;\n\npub const ZX_OBJECT_SIGNAL_3: zx_signals_t = 1 << 3;\n\npub const ZX_TASK_TERMINATED: zx_signals_t = ZX_OBJECT_SIGNAL_3;\n\npub const ZX_RIGHT_SAME_RIGHTS: zx_rights_t = 1 << 31;\n\npub type zx_object_info_topic_t = u32;\n\npub const ZX_INFO_PROCESS: zx_object_info_topic_t = 3;\n\npub fn zx_cvt<T>(t: T) -> io::Result<T>\nwhere\n    T: TryInto<zx_status_t> + Copy,\n{\n    if let Ok(status) = TryInto::try_into(t) {\n        if status < 0 { Err(io::Error::from_raw_os_error(status)) } else { Ok(t) }\n    } else {\n        Err(io::Error::last_os_error())\n    }\n}\n\n// Safe wrapper around zx_handle_t\npub struct Handle {\n    raw: zx_handle_t,\n}\n\nimpl Handle {\n    pub fn new(raw: zx_handle_t) -> Handle {\n        Handle { raw }\n    }\n\n    pub fn raw(&self) -> zx_handle_t {\n        self.raw\n    }\n}\n\nimpl Drop for Handle {\n    fn drop(&mut self) {\n        unsafe {\n            zx_cvt(zx_handle_close(self.raw)).expect(\"Failed to close zx_handle_t\");\n        }\n    }\n}\n\n// Returned for topic ZX_INFO_PROCESS\n#[derive(Default)]\n#[repr(C)]\npub struct zx_info_process_t {\n    pub return_code: i64,\n    pub started: bool,\n    pub exited: bool,\n    pub debugger_attached: bool,\n}\n\nextern \"C\" {\n    pub fn zx_job_default() -> zx_handle_t;\n\n    pub fn zx_task_kill(handle: zx_handle_t) -> zx_status_t;\n\n    pub fn zx_handle_close(handle: zx_handle_t) -> zx_status_t;\n\n    pub fn zx_handle_duplicate(\n        handle: zx_handle_t,\n        rights: zx_rights_t,\n        out: *const zx_handle_t,\n    ) -> zx_handle_t;\n\n    pub fn zx_object_wait_one(\n        handle: zx_handle_t,\n        signals: zx_signals_t,\n        timeout: zx_time_t,\n        pending: *mut zx_signals_t,\n    ) -> zx_status_t;\n\n    pub fn zx_object_get_info(\n        handle: zx_handle_t,\n        topic: u32,\n        buffer: *mut c_void,\n        buffer_size: size_t,\n        actual_size: *mut size_t,\n        avail: *mut size_t,\n    ) -> zx_status_t;\n}\n\n#[derive(Default)]\n#[repr(C)]\npub struct fdio_spawn_action_t {\n    pub action: u32,\n    pub reserved0: u32,\n    pub local_fd: i32,\n    pub target_fd: i32,\n    pub reserved1: u64,\n}\n\nextern \"C\" {\n    pub fn fdio_spawn_etc(\n        job: zx_handle_t,\n        flags: u32,\n        path: *const c_char,\n        argv: *const *const c_char,\n        envp: *const *const c_char,\n        action_count: size_t,\n        actions: *const fdio_spawn_action_t,\n        process: *mut zx_handle_t,\n        err_msg: *mut c_char,\n    ) -> zx_status_t;\n\n    pub fn fdio_fd_clone(fd: c_int, out_handle: *mut zx_handle_t) -> zx_status_t;\n    pub fn fdio_fd_create(handle: zx_handle_t, fd: *mut c_int) -> zx_status_t;\n}\n\n// fdio_spawn_etc flags\n\npub const FDIO_SPAWN_CLONE_JOB: u32 = 0x0001;\npub const FDIO_SPAWN_CLONE_LDSVC: u32 = 0x0002;\npub const FDIO_SPAWN_CLONE_NAMESPACE: u32 = 0x0004;\npub const FDIO_SPAWN_CLONE_STDIO: u32 = 0x0008;\npub const FDIO_SPAWN_CLONE_ENVIRON: u32 = 0x0010;\npub const FDIO_SPAWN_CLONE_UTC_CLOCK: u32 = 0x0020;\npub const FDIO_SPAWN_CLONE_ALL: u32 = 0xFFFF;\n\n// fdio_spawn_etc actions\n\npub const FDIO_SPAWN_ACTION_CLONE_FD: u32 = 0x0001;\npub const FDIO_SPAWN_ACTION_TRANSFER_FD: u32 = 0x0002;\n\n// Errors\n\n#[allow(unused)]\npub const ERR_INTERNAL: zx_status_t = -1;\n\n// ERR_NOT_SUPPORTED: The operation is not implemented, supported,\n// or enabled.\n#[allow(unused)]\npub const ERR_NOT_SUPPORTED: zx_status_t = -2;\n\n// ERR_NO_RESOURCES: The system was not able to allocate some resource\n// needed for the operation.\n#[allow(unused)]\npub const ERR_NO_RESOURCES: zx_status_t = -3;\n\n// ERR_NO_MEMORY: The system was not able to allocate memory needed\n// for the operation.\n#[allow(unused)]\npub const ERR_NO_MEMORY: zx_status_t = -4;\n\n// ERR_CALL_FAILED: The second phase of zx_channel_call(; did not complete\n// successfully.\n#[allow(unused)]\npub const ERR_CALL_FAILED: zx_status_t = -5;\n\n// ERR_INTERRUPTED_RETRY: The system call was interrupted, but should be\n// retried.  This should not be seen outside of the VDSO.\n#[allow(unused)]\npub const ERR_INTERRUPTED_RETRY: zx_status_t = -6;\n\n// ======= Parameter errors =======\n// ERR_INVALID_ARGS: an argument is invalid, ex. null pointer\n#[allow(unused)]\npub const ERR_INVALID_ARGS: zx_status_t = -10;\n\n// ERR_BAD_HANDLE: A specified handle value does not refer to a handle.\n#[allow(unused)]\npub const ERR_BAD_HANDLE: zx_status_t = -11;\n\n// ERR_WRONG_TYPE: The subject of the operation is the wrong type to\n// perform the operation.\n// Example: Attempting a message_read on a thread handle.\n#[allow(unused)]\npub const ERR_WRONG_TYPE: zx_status_t = -12;\n\n// ERR_BAD_SYSCALL: The specified syscall number is invalid.\n#[allow(unused)]\npub const ERR_BAD_SYSCALL: zx_status_t = -13;\n\n// ERR_OUT_OF_RANGE: An argument is outside the valid range for this\n// operation.\n#[allow(unused)]\npub const ERR_OUT_OF_RANGE: zx_status_t = -14;\n\n// ERR_BUFFER_TOO_SMALL: A caller provided buffer is too small for\n// this operation.\n#[allow(unused)]\npub const ERR_BUFFER_TOO_SMALL: zx_status_t = -15;\n\n// ======= Precondition or state errors =======\n// ERR_BAD_STATE: operation failed because the current state of the\n// object does not allow it, or a precondition of the operation is\n// not satisfied\n#[allow(unused)]\npub const ERR_BAD_STATE: zx_status_t = -20;\n\n// ERR_TIMED_OUT: The time limit for the operation elapsed before\n// the operation completed.\n#[allow(unused)]\npub const ERR_TIMED_OUT: zx_status_t = -21;\n\n// ERR_SHOULD_WAIT: The operation cannot be performed currently but\n// potentially could succeed if the caller waits for a prerequisite\n// to be satisfied, for example waiting for a handle to be readable\n// or writable.\n// Example: Attempting to read from a message pipe that has no\n// messages waiting but has an open remote will return ERR_SHOULD_WAIT.\n// Attempting to read from a message pipe that has no messages waiting\n// and has a closed remote end will return ERR_REMOTE_CLOSED.\n#[allow(unused)]\npub const ERR_SHOULD_WAIT: zx_status_t = -22;\n\n// ERR_CANCELED: The in-progress operation (e.g., a wait) has been\n// // canceled.\n#[allow(unused)]\npub const ERR_CANCELED: zx_status_t = -23;\n\n// ERR_PEER_CLOSED: The operation failed because the remote end\n// of the subject of the operation was closed.\n#[allow(unused)]\npub const ERR_PEER_CLOSED: zx_status_t = -24;\n\n// ERR_NOT_FOUND: The requested entity is not found.\n#[allow(unused)]\npub const ERR_NOT_FOUND: zx_status_t = -25;\n\n// ERR_ALREADY_EXISTS: An object with the specified identifier\n// already exists.\n// Example: Attempting to create a file when a file already exists\n// with that name.\n#[allow(unused)]\npub const ERR_ALREADY_EXISTS: zx_status_t = -26;\n\n// ERR_ALREADY_BOUND: The operation failed because the named entity\n// is already owned or controlled by another entity. The operation\n// could succeed later if the current owner releases the entity.\n#[allow(unused)]\npub const ERR_ALREADY_BOUND: zx_status_t = -27;\n\n// ERR_UNAVAILABLE: The subject of the operation is currently unable\n// to perform the operation.\n// Note: This is used when there's no direct way for the caller to\n// observe when the subject will be able to perform the operation\n// and should thus retry.\n#[allow(unused)]\npub const ERR_UNAVAILABLE: zx_status_t = -28;\n\n// ======= Permission check errors =======\n// ERR_ACCESS_DENIED: The caller did not have permission to perform\n// the specified operation.\n#[allow(unused)]\npub const ERR_ACCESS_DENIED: zx_status_t = -30;\n\n// ======= Input-output errors =======\n// ERR_IO: Otherwise unspecified error occurred during I/O.\n#[allow(unused)]\npub const ERR_IO: zx_status_t = -40;\n\n// ERR_REFUSED: The entity the I/O operation is being performed on\n// rejected the operation.\n// Example: an I2C device NAK'ing a transaction or a disk controller\n// rejecting an invalid command.\n#[allow(unused)]\npub const ERR_IO_REFUSED: zx_status_t = -41;\n\n// ERR_IO_DATA_INTEGRITY: The data in the operation failed an integrity\n// check and is possibly corrupted.\n// Example: CRC or Parity error.\n#[allow(unused)]\npub const ERR_IO_DATA_INTEGRITY: zx_status_t = -42;\n\n// ERR_IO_DATA_LOSS: The data in the operation is currently unavailable\n// and may be permanently lost.\n// Example: A disk block is irrecoverably damaged.\n#[allow(unused)]\npub const ERR_IO_DATA_LOSS: zx_status_t = -43;\n\n// Filesystem specific errors\n#[allow(unused)]\npub const ERR_BAD_PATH: zx_status_t = -50;\n#[allow(unused)]\npub const ERR_NOT_DIR: zx_status_t = -51;\n#[allow(unused)]\npub const ERR_NOT_FILE: zx_status_t = -52;\n// ERR_FILE_BIG: A file exceeds a filesystem-specific size limit.\n#[allow(unused)]\npub const ERR_FILE_BIG: zx_status_t = -53;\n// ERR_NO_SPACE: Filesystem or device space is exhausted.\n#[allow(unused)]\npub const ERR_NO_SPACE: zx_status_t = -54;\n"],["2487","// Original implementation taken from rust-memchr.\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\npub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    let p = unsafe {\n        libc::memchr(\n            haystack.as_ptr() as *const libc::c_void,\n            needle as libc::c_int,\n            haystack.len(),\n        )\n    };\n    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n}\n\npub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    #[cfg(target_os = \"linux\")]\n    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n        if haystack.is_empty() {\n            return None;\n        }\n        let p = unsafe {\n            libc::memrchr(\n                haystack.as_ptr() as *const libc::c_void,\n                needle as libc::c_int,\n                haystack.len(),\n            )\n        };\n        if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n        core::slice::memchr::memrchr(needle, haystack)\n    }\n\n    memrchr_specific(needle, haystack)\n}\n"],["2488","use crate::cell::UnsafeCell;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\n\npub struct RWLock {\n    inner: UnsafeCell<libc::pthread_rwlock_t>,\n    write_locked: UnsafeCell<bool>, // guarded by the `inner` RwLock\n    num_readers: AtomicUsize,\n}\n\npub type MovableRWLock = Box<RWLock>;\n\nunsafe impl Send for RWLock {}\nunsafe impl Sync for RWLock {}\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock {\n            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n            write_locked: UnsafeCell::new(false),\n            num_readers: AtomicUsize::new(0),\n        }\n    }\n    #[inline]\n    pub unsafe fn read(&self) {\n        let r = libc::pthread_rwlock_rdlock(self.inner.get());\n\n        // According to POSIX, when a thread tries to acquire this read lock\n        // while it already holds the write lock\n        // (or vice versa, or tries to acquire the write lock twice),\n        // \"the call shall either deadlock or return [EDEADLK]\"\n        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html,\n        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_rdlock.html).\n        // So, in principle, all we have to do here is check `r == 0` to be sure we properly\n        // got the lock.\n        //\n        // However, (at least) glibc before version 2.25 does not conform to this spec,\n        // and can return `r == 0` even when this thread already holds the write lock.\n        // We thus check for this situation ourselves and panic when detecting that a thread\n        // got the write lock more than once, or got a read and a write lock.\n        if r == libc::EAGAIN {\n            panic!(\"rwlock maximum reader count exceeded\");\n        } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n            // data races.\n            if r == 0 {\n                // `pthread_rwlock_rdlock` succeeded when it should not have.\n                self.raw_unlock();\n            }\n            panic!(\"rwlock read lock would result in deadlock\");\n        } else {\n            // According to POSIX, for a properly initialized rwlock this can only\n            // return EAGAIN or EDEADLK or 0. We rely on that.\n            debug_assert_eq!(r, 0);\n            self.num_readers.fetch_add(1, Ordering::Relaxed);\n        }\n    }\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n        if r == 0 {\n            if *self.write_locked.get() {\n                // `pthread_rwlock_tryrdlock` succeeded when it should not have.\n                self.raw_unlock();\n                false\n            } else {\n                self.num_readers.fetch_add(1, Ordering::Relaxed);\n                true\n            }\n        } else {\n            false\n        }\n    }\n    #[inline]\n    pub unsafe fn write(&self) {\n        let r = libc::pthread_rwlock_wrlock(self.inner.get());\n        // See comments above for why we check for EDEADLK and write_locked. For the same reason,\n        // we also need to check that there are no readers (tracked in `num_readers`).\n        if r == libc::EDEADLK\n            || (r == 0 && *self.write_locked.get())\n            || self.num_readers.load(Ordering::Relaxed) != 0\n        {\n            // Above, we make sure to only access `write_locked` when `r == 0` to avoid\n            // data races.\n            if r == 0 {\n                // `pthread_rwlock_wrlock` succeeded when it should not have.\n                self.raw_unlock();\n            }\n            panic!(\"rwlock write lock would result in deadlock\");\n        } else {\n            // According to POSIX, for a properly initialized rwlock this can only\n            // return EDEADLK or 0. We rely on that.\n            debug_assert_eq!(r, 0);\n        }\n        *self.write_locked.get() = true;\n    }\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n        if r == 0 {\n            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n                // `pthread_rwlock_trywrlock` succeeded when it should not have.\n                self.raw_unlock();\n                false\n            } else {\n                *self.write_locked.get() = true;\n                true\n            }\n        } else {\n            false\n        }\n    }\n    #[inline]\n    unsafe fn raw_unlock(&self) {\n        let r = libc::pthread_rwlock_unlock(self.inner.get());\n        debug_assert_eq!(r, 0);\n    }\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        debug_assert!(!*self.write_locked.get());\n        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n        self.raw_unlock();\n    }\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n        debug_assert!(*self.write_locked.get());\n        *self.write_locked.get() = false;\n        self.raw_unlock();\n    }\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        let r = libc::pthread_rwlock_destroy(self.inner.get());\n        // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n        // rwlock that was just initialized with\n        // libc::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n        // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n        if cfg!(target_os = \"dragonfly\") {\n            debug_assert!(r == 0 || r == libc::EINVAL);\n        } else {\n            debug_assert_eq!(r, 0);\n        }\n    }\n}\n"],["2489","use super::{FileDesc, IoSlice};\nuse core::mem::ManuallyDrop;\n\n#[test]\nfn limit_vector_count() {\n    let stdout = ManuallyDrop::new(unsafe { FileDesc { fd: 1 } });\n    let bufs = (0..1500).map(|_| IoSlice::new(&[])).collect::<Vec<_>>();\n    assert!(stdout.write_vectored(&bufs).is_ok());\n}\n"],["2490","use super::*;\n\n#[test]\nfn test_glibc_version() {\n    // This mostly just tests that the weak linkage doesn't panic wildly...\n    glibc_version();\n}\n\n#[test]\nfn test_parse_glibc_version() {\n    let cases = [\n        (\"0.0\", Some((0, 0))),\n        (\"01.+2\", Some((1, 2))),\n        (\"3.4.5.six\", Some((3, 4))),\n        (\"1\", None),\n        (\"1.-2\", None),\n        (\"1.foo\", None),\n        (\"foo.1\", None),\n    ];\n    for &(version_str, parsed) in cases.iter() {\n        assert_eq!(parsed, parse_glibc_version(version_str));\n    }\n}\n"],["2491","use crate::alloc::{GlobalAlloc, Layout, System};\nuse crate::ptr;\nuse crate::sys::common::alloc::{realloc_fallback, MIN_ALIGN};\n\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        // jemalloc provides alignment less than MIN_ALIGN for small allocations.\n        // So only rely on MIN_ALIGN if size >= align.\n        // Also see <https://github.com/rust-lang/rust/issues/45955> and\n        // <https://github.com/rust-lang/rust/issues/62251#issuecomment-507580914>.\n        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n            libc::malloc(layout.size()) as *mut u8\n        } else {\n            #[cfg(target_os = \"macos\")]\n            {\n                if layout.align() > (1 << 31) {\n                    return ptr::null_mut();\n                }\n            }\n            aligned_malloc(&layout)\n        }\n    }\n\n    #[inline]\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        // See the comment above in `alloc` for why this check looks the way it does.\n        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n            libc::calloc(layout.size(), 1) as *mut u8\n        } else {\n            let ptr = self.alloc(layout);\n            if !ptr.is_null() {\n                ptr::write_bytes(ptr, 0, layout.size());\n            }\n            ptr\n        }\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n        libc::free(ptr as *mut libc::c_void)\n    }\n\n    #[inline]\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n        } else {\n            realloc_fallback(self, ptr, layout, new_size)\n        }\n    }\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(any(\n        target_os = \"android\",\n        target_os = \"illumos\",\n        target_os = \"redox\",\n        target_os = \"solaris\"\n    ))] {\n        #[inline]\n        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n            // On android we currently target API level 9 which unfortunately\n            // doesn't have the `posix_memalign` API used below. Instead we use\n            // `memalign`, but this unfortunately has the property on some systems\n            // where the memory returned cannot be deallocated by `free`!\n            //\n            // Upon closer inspection, however, this appears to work just fine with\n            // Android, so for this platform we should be fine to call `memalign`\n            // (which is present in API level 9). Some helpful references could\n            // possibly be chromium using memalign [1], attempts at documenting that\n            // memalign + free is ok [2] [3], or the current source of chromium\n            // which still uses memalign on android [4].\n            //\n            // [1]: https://codereview.chromium.org/10796020/\n            // [2]: https://code.google.com/p/android/issues/detail?id=35391\n            // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n            // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n            //                                       /memory/aligned_memory.cc\n            libc::memalign(layout.align(), layout.size()) as *mut u8\n        }\n    } else if #[cfg(target_os = \"wasi\")] {\n        #[inline]\n        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n            libc::aligned_alloc(layout.align(), layout.size()) as *mut u8\n        }\n    } else {\n        #[inline]\n        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n            let mut out = ptr::null_mut();\n            // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n            // Since these are all powers of 2, we can just use max.\n            let align = layout.align().max(crate::mem::size_of::<usize>());\n            let ret = libc::posix_memalign(&mut out, align, layout.size());\n            if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n        }\n    }\n}\n"],["2492","use crate::ffi::OsStr;\nuse crate::path::Prefix;\n\n#[inline]\npub fn is_sep_byte(b: u8) -> bool {\n    b == b'/'\n}\n\n#[inline]\npub fn is_verbatim_sep(b: u8) -> bool {\n    b == b'/'\n}\n\npub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n    None\n}\n\npub const MAIN_SEP_STR: &str = \"/\";\npub const MAIN_SEP: char = '/';\n"],["2493","use crate::marker::PhantomData;\nuse crate::slice;\n\nuse libc::{c_void, iovec};\n\n#[derive(Copy, Clone)]\n#[repr(transparent)]\npub struct IoSlice<'a> {\n    vec: iovec,\n    _p: PhantomData<&'a [u8]>,\n}\n\nimpl<'a> IoSlice<'a> {\n    #[inline]\n    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n        IoSlice {\n            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },\n            _p: PhantomData,\n        }\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        if self.vec.iov_len < n {\n            panic!(\"advancing IoSlice beyond its length\");\n        }\n\n        unsafe {\n            self.vec.iov_len -= n;\n            self.vec.iov_base = self.vec.iov_base.add(n);\n        }\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n    }\n}\n\n#[repr(transparent)]\npub struct IoSliceMut<'a> {\n    vec: iovec,\n    _p: PhantomData<&'a mut [u8]>,\n}\n\nimpl<'a> IoSliceMut<'a> {\n    #[inline]\n    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n        IoSliceMut {\n            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },\n            _p: PhantomData,\n        }\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        if self.vec.iov_len < n {\n            panic!(\"advancing IoSliceMut beyond its length\");\n        }\n\n        unsafe {\n            self.vec.iov_len -= n;\n            self.vec.iov_base = self.vec.iov_base.add(n);\n        }\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n    }\n\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n    }\n}\n"],["2494","use crate::io::{self, IoSlice, IoSliceMut};\nuse crate::mem::ManuallyDrop;\nuse crate::sys::fd::FileDesc;\n\npub struct Stdin(());\npub struct Stdout(());\npub struct Stderr(());\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin(())\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDIN_FILENO)).read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDIN_FILENO)).read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout(())\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDOUT_FILENO)).write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDOUT_FILENO)).write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr(())\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDERR_FILENO)).write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        ManuallyDrop::new(FileDesc::new(libc::STDERR_FILENO)).write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\npub fn is_ebadf(err: &io::Error) -> bool {\n    err.raw_os_error() == Some(libc::EBADF as i32)\n}\n\npub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n\npub fn panic_output() -> Option<impl io::Write> {\n    Some(Stderr::new())\n}\n"],["2495","#![allow(dead_code)] // not used on all platforms\n\nuse crate::mem;\n\npub type Key = libc::pthread_key_t;\n\n#[inline]\npub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n    let mut key = 0;\n    assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n    key\n}\n\n#[inline]\npub unsafe fn set(key: Key, value: *mut u8) {\n    let r = libc::pthread_setspecific(key, value as *mut _);\n    debug_assert_eq!(r, 0);\n}\n\n#[inline]\npub unsafe fn get(key: Key) -> *mut u8 {\n    libc::pthread_getspecific(key) as *mut u8\n}\n\n#[inline]\npub unsafe fn destroy(key: Key) {\n    let r = libc::pthread_key_delete(key);\n    debug_assert_eq!(r, 0);\n}\n\n#[inline]\npub fn requires_synchronized_create() -> bool {\n    false\n}\n"],["2496","use crate::cmp;\nuse crate::ffi::CStr;\nuse crate::io;\nuse crate::mem;\nuse crate::ptr;\nuse crate::sys::{os, stack_overflow};\nuse crate::time::Duration;\n\n#[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\")))]\npub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n#[cfg(target_os = \"l4re\")]\npub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n#[cfg(target_os = \"vxworks\")]\npub const DEFAULT_MIN_STACK_SIZE: usize = 256 * 1024;\n\npub struct Thread {\n    id: libc::pthread_t,\n}\n\n// Some platforms may have pthread_t as a pointer in which case we still want\n// a thread to be Send/Sync\nunsafe impl Send for Thread {}\nunsafe impl Sync for Thread {}\n\nimpl Thread {\n    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        let p = Box::into_raw(box p);\n        let mut native: libc::pthread_t = mem::zeroed();\n        let mut attr: libc::pthread_attr_t = mem::zeroed();\n        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n\n        let stack_size = cmp::max(stack, min_stack_size(&attr));\n\n        match libc::pthread_attr_setstacksize(&mut attr, stack_size) {\n            0 => {}\n            n => {\n                assert_eq!(n, libc::EINVAL);\n                // EINVAL means |stack_size| is either too small or not a\n                // multiple of the system page size.  Because it's definitely\n                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                // Round up to the nearest page and try again.\n                let page_size = os::page_size();\n                let stack_size =\n                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n            }\n        };\n\n        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n        // Note: if the thread creation fails and this assert fails, then p will\n        // be leaked. However, an alternative design could cause double-free\n        // which is clearly worse.\n        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n\n        return if ret != 0 {\n            // The thread failed to start and as a result p was not consumed. Therefore, it is\n            // safe to reconstruct the box so that it gets deallocated.\n            drop(Box::from_raw(p));\n            Err(io::Error::from_raw_os_error(ret))\n        } else {\n            Ok(Thread { id: native })\n        };\n\n        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n            unsafe {\n                // Next, set up our stack overflow handler which may get triggered if we run\n                // out of stack.\n                let _handler = stack_overflow::Handler::new();\n                // Finally, let's run some code.\n                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n            }\n            ptr::null_mut()\n        }\n    }\n\n    pub fn yield_now() {\n        let ret = unsafe { libc::sched_yield() };\n        debug_assert_eq!(ret, 0);\n    }\n\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    pub fn set_name(name: &CStr) {\n        const PR_SET_NAME: libc::c_int = 15;\n        // pthread wrapper only appeared in glibc 2.12, so we use syscall\n        // directly.\n        unsafe {\n            libc::prctl(PR_SET_NAME, name.as_ptr() as libc::c_ulong, 0, 0, 0);\n        }\n    }\n\n    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"openbsd\"))]\n    pub fn set_name(name: &CStr) {\n        unsafe {\n            libc::pthread_set_name_np(libc::pthread_self(), name.as_ptr());\n        }\n    }\n\n    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n    pub fn set_name(name: &CStr) {\n        unsafe {\n            libc::pthread_setname_np(name.as_ptr());\n        }\n    }\n\n    #[cfg(target_os = \"netbsd\")]\n    pub fn set_name(name: &CStr) {\n        use crate::ffi::CString;\n        let cname = CString::new(&b\"%s\"[..]).unwrap();\n        unsafe {\n            libc::pthread_setname_np(\n                libc::pthread_self(),\n                cname.as_ptr(),\n                name.as_ptr() as *mut libc::c_void,\n            );\n        }\n    }\n\n    #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\n    pub fn set_name(name: &CStr) {\n        weak! {\n            fn pthread_setname_np(\n                libc::pthread_t, *const libc::c_char\n            ) -> libc::c_int\n        }\n\n        if let Some(f) = pthread_setname_np.get() {\n            unsafe {\n                f(libc::pthread_self(), name.as_ptr());\n            }\n        }\n    }\n\n    #[cfg(any(\n        target_env = \"newlib\",\n        target_os = \"haiku\",\n        target_os = \"l4re\",\n        target_os = \"emscripten\",\n        target_os = \"redox\",\n        target_os = \"vxworks\"\n    ))]\n    pub fn set_name(_name: &CStr) {\n        // Newlib, Haiku, Emscripten, and VxWorks have no way to set a thread name.\n    }\n    #[cfg(target_os = \"fuchsia\")]\n    pub fn set_name(_name: &CStr) {\n        // FIXME: determine whether Fuchsia has a way to set a thread name.\n    }\n\n    pub fn sleep(dur: Duration) {\n        let mut secs = dur.as_secs();\n        let mut nsecs = dur.subsec_nanos() as _;\n\n        // If we're awoken with a signal then the return value will be -1 and\n        // nanosleep will fill in `ts` with the remaining time.\n        unsafe {\n            while secs > 0 || nsecs > 0 {\n                let mut ts = libc::timespec {\n                    tv_sec: cmp::min(libc::time_t::MAX as u64, secs) as libc::time_t,\n                    tv_nsec: nsecs,\n                };\n                secs -= ts.tv_sec as u64;\n                let ts_ptr = &mut ts as *mut _;\n                if libc::nanosleep(ts_ptr, ts_ptr) == -1 {\n                    assert_eq!(os::errno(), libc::EINTR);\n                    secs += ts.tv_sec as u64;\n                    nsecs = ts.tv_nsec;\n                } else {\n                    nsecs = 0;\n                }\n            }\n        }\n    }\n\n    pub fn join(self) {\n        unsafe {\n            let ret = libc::pthread_join(self.id, ptr::null_mut());\n            mem::forget(self);\n            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n        }\n    }\n\n    pub fn id(&self) -> libc::pthread_t {\n        self.id\n    }\n\n    pub fn into_id(self) -> libc::pthread_t {\n        let id = self.id;\n        mem::forget(self);\n        id\n    }\n}\n\nimpl Drop for Thread {\n    fn drop(&mut self) {\n        let ret = unsafe { libc::pthread_detach(self.id) };\n        debug_assert_eq!(ret, 0);\n    }\n}\n\n#[cfg(all(\n    not(target_os = \"linux\"),\n    not(target_os = \"freebsd\"),\n    not(target_os = \"macos\"),\n    not(target_os = \"netbsd\"),\n    not(target_os = \"openbsd\"),\n    not(target_os = \"solaris\")\n))]\n#[cfg_attr(test, allow(dead_code))]\npub mod guard {\n    use crate::ops::Range;\n    pub type Guard = Range<usize>;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"freebsd\",\n    target_os = \"macos\",\n    target_os = \"netbsd\",\n    target_os = \"openbsd\",\n    target_os = \"solaris\"\n))]\n#[cfg_attr(test, allow(dead_code))]\npub mod guard {\n    use libc::{mmap, mprotect};\n    use libc::{MAP_ANON, MAP_FAILED, MAP_FIXED, MAP_PRIVATE, PROT_NONE, PROT_READ, PROT_WRITE};\n\n    use crate::io;\n    use crate::ops::Range;\n    use crate::sync::atomic::{AtomicUsize, Ordering};\n    use crate::sys::os;\n\n    // This is initialized in init() and only read from after\n    static PAGE_SIZE: AtomicUsize = AtomicUsize::new(0);\n\n    pub type Guard = Range<usize>;\n\n    #[cfg(target_os = \"solaris\")]\n    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n        let mut current_stack: libc::stack_t = crate::mem::zeroed();\n        assert_eq!(libc::stack_getbounds(&mut current_stack), 0);\n        Some(current_stack.ss_sp)\n    }\n\n    #[cfg(target_os = \"macos\")]\n    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n        let th = libc::pthread_self();\n        let stackaddr =\n            libc::pthread_get_stackaddr_np(th) as usize - libc::pthread_get_stacksize_np(th);\n        Some(stackaddr as *mut libc::c_void)\n    }\n\n    #[cfg(target_os = \"openbsd\")]\n    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n        let mut current_stack: libc::stack_t = crate::mem::zeroed();\n        assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(), &mut current_stack), 0);\n\n        let stackaddr = if libc::pthread_main_np() == 1 {\n            // main thread\n            current_stack.ss_sp as usize - current_stack.ss_size + PAGE_SIZE.load(Ordering::Relaxed)\n        } else {\n            // new thread\n            current_stack.ss_sp as usize - current_stack.ss_size\n        };\n        Some(stackaddr as *mut libc::c_void)\n    }\n\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"freebsd\",\n        target_os = \"linux\",\n        target_os = \"netbsd\",\n        target_os = \"l4re\"\n    ))]\n    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n        let mut ret = None;\n        let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n        #[cfg(target_os = \"freebsd\")]\n        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n        #[cfg(target_os = \"freebsd\")]\n        let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n        #[cfg(not(target_os = \"freebsd\"))]\n        let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n        if e == 0 {\n            let mut stackaddr = crate::ptr::null_mut();\n            let mut stacksize = 0;\n            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize), 0);\n            ret = Some(stackaddr);\n        }\n        if e == 0 || cfg!(target_os = \"freebsd\") {\n            assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n        }\n        ret\n    }\n\n    // Precondition: PAGE_SIZE is initialized.\n    unsafe fn get_stack_start_aligned() -> Option<*mut libc::c_void> {\n        let page_size = PAGE_SIZE.load(Ordering::Relaxed);\n        assert!(page_size != 0);\n        let stackaddr = get_stack_start()?;\n\n        // Ensure stackaddr is page aligned! A parent process might\n        // have reset RLIMIT_STACK to be non-page aligned. The\n        // pthread_attr_getstack() reports the usable stack area\n        // stackaddr < stackaddr + stacksize, so if stackaddr is not\n        // page-aligned, calculate the fix such that stackaddr <\n        // new_page_aligned_stackaddr < stackaddr + stacksize\n        let remainder = (stackaddr as usize) % page_size;\n        Some(if remainder == 0 {\n            stackaddr\n        } else {\n            ((stackaddr as usize) + page_size - remainder) as *mut libc::c_void\n        })\n    }\n\n    pub unsafe fn init() -> Option<Guard> {\n        let page_size = os::page_size();\n        PAGE_SIZE.store(page_size, Ordering::Relaxed);\n\n        if cfg!(all(target_os = \"linux\", not(target_env = \"musl\"))) {\n            // Linux doesn't allocate the whole stack right away, and\n            // the kernel has its own stack-guard mechanism to fault\n            // when growing too close to an existing mapping.  If we map\n            // our own guard, then the kernel starts enforcing a rather\n            // large gap above that, rendering much of the possible\n            // stack space useless.  See #43052.\n            //\n            // Instead, we'll just note where we expect rlimit to start\n            // faulting, so our handler can report \"stack overflow\", and\n            // trust that the kernel's own stack guard will work.\n            let stackaddr = get_stack_start_aligned()?;\n            let stackaddr = stackaddr as usize;\n            Some(stackaddr - page_size..stackaddr)\n        } else if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n            // For the main thread, the musl's pthread_attr_getstack\n            // returns the current stack size, rather than maximum size\n            // it can eventually grow to. It cannot be used to determine\n            // the position of kernel's stack guard.\n            None\n        } else if cfg!(target_os = \"freebsd\") {\n            // FreeBSD's stack autogrows, and optionally includes a guard page\n            // at the bottom.  If we try to remap the bottom of the stack\n            // ourselves, FreeBSD's guard page moves upwards.  So we'll just use\n            // the builtin guard page.\n            let stackaddr = get_stack_start_aligned()?;\n            let guardaddr = stackaddr as usize;\n            // Technically the number of guard pages is tunable and controlled\n            // by the security.bsd.stack_guard_page sysctl, but there are\n            // few reasons to change it from the default.  The default value has\n            // been 1 ever since FreeBSD 11.1 and 10.4.\n            const GUARD_PAGES: usize = 1;\n            let guard = guardaddr..guardaddr + GUARD_PAGES * page_size;\n            Some(guard)\n        } else {\n            // Reallocate the last page of the stack.\n            // This ensures SIGBUS will be raised on\n            // stack overflow.\n            // Systems which enforce strict PAX MPROTECT do not allow\n            // to mprotect() a mapping with less restrictive permissions\n            // than the initial mmap() used, so we mmap() here with\n            // read/write permissions and only then mprotect() it to\n            // no permissions at all. See issue #50313.\n            let stackaddr = get_stack_start_aligned()?;\n            let result = mmap(\n                stackaddr,\n                page_size,\n                PROT_READ | PROT_WRITE,\n                MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n                -1,\n                0,\n            );\n            if result != stackaddr || result == MAP_FAILED {\n                panic!(\"failed to allocate a guard page: {}\", io::Error::last_os_error());\n            }\n\n            let result = mprotect(stackaddr, page_size, PROT_NONE);\n            if result != 0 {\n                panic!(\"failed to protect the guard page: {}\", io::Error::last_os_error());\n            }\n\n            let guardaddr = stackaddr as usize;\n\n            Some(guardaddr..guardaddr + page_size)\n        }\n    }\n\n    #[cfg(any(target_os = \"macos\", target_os = \"openbsd\", target_os = \"solaris\"))]\n    pub unsafe fn current() -> Option<Guard> {\n        let stackaddr = get_stack_start()? as usize;\n        Some(stackaddr - PAGE_SIZE.load(Ordering::Relaxed)..stackaddr)\n    }\n\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"freebsd\",\n        target_os = \"linux\",\n        target_os = \"netbsd\",\n        target_os = \"l4re\"\n    ))]\n    pub unsafe fn current() -> Option<Guard> {\n        let mut ret = None;\n        let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n        #[cfg(target_os = \"freebsd\")]\n        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n        #[cfg(target_os = \"freebsd\")]\n        let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n        #[cfg(not(target_os = \"freebsd\"))]\n        let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n        if e == 0 {\n            let mut guardsize = 0;\n            assert_eq!(libc::pthread_attr_getguardsize(&attr, &mut guardsize), 0);\n            if guardsize == 0 {\n                if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n                    // musl versions before 1.1.19 always reported guard\n                    // size obtained from pthread_attr_get_np as zero.\n                    // Use page size as a fallback.\n                    guardsize = PAGE_SIZE.load(Ordering::Relaxed);\n                } else {\n                    panic!(\"there is no guard page\");\n                }\n            }\n            let mut stackaddr = crate::ptr::null_mut();\n            let mut size = 0;\n            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n\n            let stackaddr = stackaddr as usize;\n            ret = if cfg!(any(target_os = \"freebsd\", target_os = \"netbsd\")) {\n                Some(stackaddr - guardsize..stackaddr)\n            } else if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n                Some(stackaddr - guardsize..stackaddr)\n            } else if cfg!(all(target_os = \"linux\", target_env = \"gnu\")) {\n                // glibc used to include the guard area within the stack, as noted in the BUGS\n                // section of `man pthread_attr_getguardsize`.  This has been corrected starting\n                // with glibc 2.27, and in some distro backports, so the guard is now placed at the\n                // end (below) the stack.  There's no easy way for us to know which we have at\n                // runtime, so we'll just match any fault in the range right above or below the\n                // stack base to call that fault a stack overflow.\n                Some(stackaddr - guardsize..stackaddr + guardsize)\n            } else {\n                Some(stackaddr..stackaddr + guardsize)\n            };\n        }\n        if e == 0 || cfg!(target_os = \"freebsd\") {\n            assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n        }\n        ret\n    }\n}\n\n// glibc >= 2.15 has a __pthread_get_minstack() function that returns\n// PTHREAD_STACK_MIN plus bytes needed for thread-local storage.\n// We need that information to avoid blowing up when a small stack\n// is created in an application with big thread-local storage requirements.\n// See #6233 for rationale and details.\n#[cfg(target_os = \"linux\")]\n#[allow(deprecated)]\nfn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n    weak!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -> libc::size_t);\n\n    match __pthread_get_minstack.get() {\n        None => libc::PTHREAD_STACK_MIN,\n        Some(f) => unsafe { f(attr) },\n    }\n}\n\n// No point in looking up __pthread_get_minstack() on non-glibc\n// platforms.\n#[cfg(all(not(target_os = \"linux\"), not(target_os = \"netbsd\")))]\nfn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n    libc::PTHREAD_STACK_MIN\n}\n\n#[cfg(target_os = \"netbsd\")]\nfn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n    2048 // just a guess\n}\n"],["2497","use crate::io::{self, IoSlice, IoSliceMut};\nuse crate::mem;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::{cvt, cvt_r};\n\n////////////////////////////////////////////////////////////////////////////////\n// Anonymous pipes\n////////////////////////////////////////////////////////////////////////////////\n\npub struct AnonPipe(FileDesc);\n\npub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n    let mut fds = [0; 2];\n\n    // The only known way right now to create atomically set the CLOEXEC flag is\n    // to use the `pipe2` syscall. This was added to Linux in 2.6.27, glibc 2.9\n    // and musl 0.9.3, and some other targets also have it.\n    cfg_if::cfg_if! {\n        if #[cfg(any(\n            target_os = \"dragonfly\",\n            target_os = \"freebsd\",\n            target_os = \"linux\",\n            target_os = \"netbsd\",\n            target_os = \"openbsd\",\n            target_os = \"redox\"\n        ))] {\n            cvt(unsafe { libc::pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) })?;\n            Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))))\n        } else {\n            cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n\n            let fd0 = FileDesc::new(fds[0]);\n            let fd1 = FileDesc::new(fds[1]);\n            fd0.set_cloexec()?;\n            fd1.set_cloexec()?;\n            Ok((AnonPipe(fd0), AnonPipe(fd1)))\n        }\n    }\n}\n\nimpl AnonPipe {\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.0.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.0.is_read_vectored()\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.0.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    pub fn fd(&self) -> &FileDesc {\n        &self.0\n    }\n    pub fn into_fd(self) -> FileDesc {\n        self.0\n    }\n}\n\npub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n    // Set both pipes into nonblocking mode as we're gonna be reading from both\n    // in the `select` loop below, and we wouldn't want one to block the other!\n    let p1 = p1.into_fd();\n    let p2 = p2.into_fd();\n    p1.set_nonblocking(true)?;\n    p2.set_nonblocking(true)?;\n\n    let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n    fds[0].fd = p1.raw();\n    fds[0].events = libc::POLLIN;\n    fds[1].fd = p2.raw();\n    fds[1].events = libc::POLLIN;\n    loop {\n        // wait for either pipe to become readable using `poll`\n        cvt_r(|| unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) })?;\n\n        if fds[0].revents != 0 && read(&p1, v1)? {\n            p2.set_nonblocking(false)?;\n            return p2.read_to_end(v2).map(drop);\n        }\n        if fds[1].revents != 0 && read(&p2, v2)? {\n            p1.set_nonblocking(false)?;\n            return p1.read_to_end(v1).map(drop);\n        }\n    }\n\n    // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n    // EAGAIN. If we hit EOF, then this will happen because the underlying\n    // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n    // this case we flip the other fd back into blocking mode and read\n    // whatever's leftover on that file descriptor.\n    fn read(fd: &FileDesc, dst: &mut Vec<u8>) -> Result<bool, io::Error> {\n        match fd.read_to_end(dst) {\n            Ok(_) => Ok(true),\n            Err(e) => {\n                if e.raw_os_error() == Some(libc::EWOULDBLOCK)\n                    || e.raw_os_error() == Some(libc::EAGAIN)\n                {\n                    Ok(false)\n                } else {\n                    Err(e)\n                }\n            }\n        }\n    }\n}\n"],["2498","#![cfg(target_thread_local)]\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n\n//! Provides thread-local destructors without an associated \"key\", which\n//! can be more efficient.\n\n// Since what appears to be glibc 2.18 this symbol has been shipped which\n// GCC and clang both use to invoke destructors in thread_local globals, so\n// let's do the same!\n//\n// Note, however, that we run on lots older linuxes, as well as cross\n// compiling from a newer linux to an older linux, so we also have a\n// fallback implementation to use as well.\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"fuchsia\",\n    target_os = \"redox\",\n    target_os = \"emscripten\"\n))]\npub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    use crate::mem;\n    use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n\n    extern \"C\" {\n        #[linkage = \"extern_weak\"]\n        static __dso_handle: *mut u8;\n        #[linkage = \"extern_weak\"]\n        static __cxa_thread_atexit_impl: *const libc::c_void;\n    }\n    if !__cxa_thread_atexit_impl.is_null() {\n        type F = unsafe extern \"C\" fn(\n            dtor: unsafe extern \"C\" fn(*mut u8),\n            arg: *mut u8,\n            dso_handle: *mut u8,\n        ) -> libc::c_int;\n        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)(\n            dtor,\n            t,\n            &__dso_handle as *const _ as *mut _,\n        );\n        return;\n    }\n    register_dtor_fallback(t, dtor);\n}\n\n// This implementation is very similar to register_dtor_fallback in\n// sys_common/thread_local.rs. The main difference is that we want to hook into\n// macOS's analog of the above linux function, _tlv_atexit. OSX will run the\n// registered dtors before any TLS slots get freed, and when the main thread\n// exits.\n//\n// Unfortunately, calling _tlv_atexit while tls dtors are running is UB. The\n// workaround below is to register, via _tlv_atexit, a custom DTOR list once per\n// thread. thread_local dtors are pushed to the DTOR list without calling\n// _tlv_atexit.\n#[cfg(target_os = \"macos\")]\npub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    use crate::cell::Cell;\n    use crate::ptr;\n\n    #[thread_local]\n    static REGISTERED: Cell<bool> = Cell::new(false);\n    if !REGISTERED.get() {\n        _tlv_atexit(run_dtors, ptr::null_mut());\n        REGISTERED.set(true);\n    }\n\n    type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n\n    #[thread_local]\n    static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n    if DTORS.get().is_null() {\n        let v: Box<List> = box Vec::new();\n        DTORS.set(Box::into_raw(v));\n    }\n\n    extern \"C\" {\n        fn _tlv_atexit(dtor: unsafe extern \"C\" fn(*mut u8), arg: *mut u8);\n    }\n\n    let list: &mut List = &mut *DTORS.get();\n    list.push((t, dtor));\n\n    unsafe extern \"C\" fn run_dtors(_: *mut u8) {\n        let mut ptr = DTORS.replace(ptr::null_mut());\n        while !ptr.is_null() {\n            let list = Box::from_raw(ptr);\n            for (ptr, dtor) in list.into_iter() {\n                dtor(ptr);\n            }\n            ptr = DTORS.replace(ptr::null_mut());\n        }\n    }\n}\n\n#[cfg(target_os = \"vxworks\")]\npub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n    register_dtor_fallback(t, dtor);\n}\n"],["2499","#![allow(dead_code)]\n\nuse crate::ffi::CStr;\nuse crate::io;\nuse crate::mem;\nuse crate::sys::hermit::abi;\nuse crate::sys::hermit::thread_local_dtor::run_dtors;\nuse crate::time::Duration;\n\npub type Tid = abi::Tid;\n\npub struct Thread {\n    tid: Tid,\n}\n\nunsafe impl Send for Thread {}\nunsafe impl Sync for Thread {}\n\npub const DEFAULT_MIN_STACK_SIZE: usize = 1 << 20;\n\nimpl Thread {\n    pub unsafe fn new_with_coreid(\n        stack: usize,\n        p: Box<dyn FnOnce()>,\n        core_id: isize,\n    ) -> io::Result<Thread> {\n        let p = Box::into_raw(box p);\n        let tid = abi::spawn2(\n            thread_start,\n            p as usize,\n            abi::Priority::into(abi::NORMAL_PRIO),\n            stack,\n            core_id,\n        );\n\n        return if tid == 0 {\n            // The thread failed to start and as a result p was not consumed. Therefore, it is\n            // safe to reconstruct the box so that it gets deallocated.\n            drop(Box::from_raw(p));\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Unable to create thread!\"))\n        } else {\n            Ok(Thread { tid: tid })\n        };\n\n        extern \"C\" fn thread_start(main: usize) {\n            unsafe {\n                // Finally, let's run some code.\n                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n\n                // run all destructors\n                run_dtors();\n            }\n        }\n    }\n\n    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        Thread::new_with_coreid(stack, p, -1 /* = no specific core */)\n    }\n\n    #[inline]\n    pub fn yield_now() {\n        unsafe {\n            abi::yield_now();\n        }\n    }\n\n    #[inline]\n    pub fn set_name(_name: &CStr) {\n        // nope\n    }\n\n    #[inline]\n    pub fn sleep(dur: Duration) {\n        unsafe {\n            abi::usleep(dur.as_micros() as u64);\n        }\n    }\n\n    pub fn join(self) {\n        unsafe {\n            let _ = abi::join(self.tid);\n        }\n    }\n\n    #[inline]\n    pub fn id(&self) -> Tid {\n        self.tid\n    }\n\n    #[inline]\n    pub fn into_id(self) -> Tid {\n        let id = self.tid;\n        mem::forget(self);\n        id\n    }\n}\n\npub mod guard {\n    pub type Guard = !;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n"],["2500","use crate::io;\nuse crate::io::{IoSlice, IoSliceMut};\nuse crate::sys::hermit::abi;\n\npub struct Stdin;\npub struct Stdout;\npub struct Stderr;\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, data: &mut [u8]) -> io::Result<usize> {\n        self.read_vectored(&mut [IoSliceMut::new(data)])\n    }\n\n    fn read_vectored(&mut self, _data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        Ok(0)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        let len;\n\n        unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n\n        if len < 0 {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stdout is not able to print\"))\n        } else {\n            Ok(len as usize)\n        }\n    }\n\n    fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n        let len;\n\n        unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n\n        if len < 0 {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stdout is not able to print\"))\n        } else {\n            Ok(len as usize)\n        }\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        let len;\n\n        unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n\n        if len < 0 {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stderr is not able to print\"))\n        } else {\n            Ok(len as usize)\n        }\n    }\n\n    fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n        let len;\n\n        unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n\n        if len < 0 {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stderr is not able to print\"))\n        } else {\n            Ok(len as usize)\n        }\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\npub const STDIN_BUF_SIZE: usize = 0;\n\npub fn is_ebadf(_err: &io::Error) -> bool {\n    true\n}\n\npub fn panic_output() -> Option<impl io::Write> {\n    Some(Stderr::new())\n}\n"],["2501","pub use core::slice::memchr::{memchr, memrchr};\n"],["2502","use crate::alloc::{GlobalAlloc, Layout, System};\nuse crate::ptr;\nuse crate::sys::hermit::abi;\n\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        abi::malloc(layout.size(), layout.align())\n    }\n\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        let addr = abi::malloc(layout.size(), layout.align());\n\n        if !addr.is_null() {\n            ptr::write_bytes(addr, 0x00, layout.size());\n        }\n\n        addr\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n        abi::free(ptr, layout.size(), layout.align())\n    }\n\n    #[inline]\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        abi::realloc(ptr, layout.size(), layout.align(), new_size)\n    }\n}\n"],["2503","#![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n\nuse crate::io::{self, Read};\nuse crate::mem;\nuse crate::sys::cvt;\nuse crate::sys::hermit::abi;\nuse crate::sys::unsupported;\nuse crate::sys_common::AsInner;\n\n#[derive(Debug)]\npub struct FileDesc {\n    fd: i32,\n}\n\nimpl FileDesc {\n    pub fn new(fd: i32) -> FileDesc {\n        FileDesc { fd }\n    }\n\n    pub fn raw(&self) -> i32 {\n        self.fd\n    }\n\n    /// Extracts the actual file descriptor without closing it.\n    pub fn into_raw(self) -> i32 {\n        let fd = self.fd;\n        mem::forget(self);\n        fd\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        let result = unsafe { abi::read(self.fd, buf.as_mut_ptr(), buf.len()) };\n        cvt(result as i32)\n    }\n\n    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        let mut me = self;\n        (&mut me).read_to_end(buf)\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        let result = unsafe { abi::write(self.fd, buf.as_ptr(), buf.len()) };\n        cvt(result as i32)\n    }\n\n    pub fn duplicate(&self) -> io::Result<FileDesc> {\n        self.duplicate_path(&[])\n    }\n    pub fn duplicate_path(&self, _path: &[u8]) -> io::Result<FileDesc> {\n        unsupported()\n    }\n\n    pub fn nonblocking(&self) -> io::Result<bool> {\n        Ok(false)\n    }\n\n    pub fn set_cloexec(&self) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn set_nonblocking(&self, _nonblocking: bool) -> io::Result<()> {\n        unsupported()\n    }\n}\n\nimpl<'a> Read for &'a FileDesc {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n}\n\nimpl AsInner<i32> for FileDesc {\n    fn as_inner(&self) -> &i32 {\n        &self.fd\n    }\n}\n\nimpl Drop for FileDesc {\n    fn drop(&mut self) {\n        // Note that errors are ignored when closing a file descriptor. The\n        // reason for this is that if an error occurs we don't actually know if\n        // the file descriptor was closed or not, and if we retried (for\n        // something like EINTR), we might close another valid file descriptor\n        // (opened after we closed ours.\n        let _ = unsafe { abi::close(self.fd) };\n    }\n}\n"],["2504","use crate::ffi::{CStr, CString, OsString};\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\nuse crate::io::{self, Error, ErrorKind};\nuse crate::io::{IoSlice, IoSliceMut, SeekFrom};\nuse crate::path::{Path, PathBuf};\nuse crate::sys::cvt;\nuse crate::sys::hermit::abi;\nuse crate::sys::hermit::abi::{O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY};\nuse crate::sys::hermit::fd::FileDesc;\nuse crate::sys::time::SystemTime;\nuse crate::sys::unsupported;\nuse crate::sys_common::os_str_bytes::OsStrExt;\n\npub use crate::sys_common::fs::{copy, try_exists};\n//pub use crate::sys_common::fs::remove_dir_all;\n\nfn cstr(path: &Path) -> io::Result<CString> {\n    Ok(CString::new(path.as_os_str().as_bytes())?)\n}\n\n#[derive(Debug)]\npub struct File(FileDesc);\n\npub struct FileAttr(!);\n\npub struct ReadDir(!);\n\npub struct DirEntry(!);\n\n#[derive(Clone, Debug)]\npub struct OpenOptions {\n    // generic\n    read: bool,\n    write: bool,\n    append: bool,\n    truncate: bool,\n    create: bool,\n    create_new: bool,\n    // system-specific\n    mode: i32,\n}\n\npub struct FilePermissions(!);\n\npub struct FileType(!);\n\n#[derive(Debug)]\npub struct DirBuilder {}\n\nimpl FileAttr {\n    pub fn size(&self) -> u64 {\n        self.0\n    }\n\n    pub fn perm(&self) -> FilePermissions {\n        self.0\n    }\n\n    pub fn file_type(&self) -> FileType {\n        self.0\n    }\n\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        self.0\n    }\n\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        self.0\n    }\n\n    pub fn created(&self) -> io::Result<SystemTime> {\n        self.0\n    }\n}\n\nimpl Clone for FileAttr {\n    fn clone(&self) -> FileAttr {\n        self.0\n    }\n}\n\nimpl FilePermissions {\n    pub fn readonly(&self) -> bool {\n        self.0\n    }\n\n    pub fn set_readonly(&mut self, _readonly: bool) {\n        self.0\n    }\n}\n\nimpl Clone for FilePermissions {\n    fn clone(&self) -> FilePermissions {\n        self.0\n    }\n}\n\nimpl PartialEq for FilePermissions {\n    fn eq(&self, _other: &FilePermissions) -> bool {\n        self.0\n    }\n}\n\nimpl Eq for FilePermissions {}\n\nimpl fmt::Debug for FilePermissions {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl FileType {\n    pub fn is_dir(&self) -> bool {\n        self.0\n    }\n\n    pub fn is_file(&self) -> bool {\n        self.0\n    }\n\n    pub fn is_symlink(&self) -> bool {\n        self.0\n    }\n}\n\nimpl Clone for FileType {\n    fn clone(&self) -> FileType {\n        self.0\n    }\n}\n\nimpl Copy for FileType {}\n\nimpl PartialEq for FileType {\n    fn eq(&self, _other: &FileType) -> bool {\n        self.0\n    }\n}\n\nimpl Eq for FileType {}\n\nimpl Hash for FileType {\n    fn hash<H: Hasher>(&self, _h: &mut H) {\n        self.0\n    }\n}\n\nimpl fmt::Debug for FileType {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl fmt::Debug for ReadDir {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0\n    }\n}\n\nimpl Iterator for ReadDir {\n    type Item = io::Result<DirEntry>;\n\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        self.0\n    }\n}\n\nimpl DirEntry {\n    pub fn path(&self) -> PathBuf {\n        self.0\n    }\n\n    pub fn file_name(&self) -> OsString {\n        self.0\n    }\n\n    pub fn metadata(&self) -> io::Result<FileAttr> {\n        self.0\n    }\n\n    pub fn file_type(&self) -> io::Result<FileType> {\n        self.0\n    }\n}\n\nimpl OpenOptions {\n    pub fn new() -> OpenOptions {\n        OpenOptions {\n            // generic\n            read: false,\n            write: false,\n            append: false,\n            truncate: false,\n            create: false,\n            create_new: false,\n            // system-specific\n            mode: 0x777,\n        }\n    }\n\n    pub fn read(&mut self, read: bool) {\n        self.read = read;\n    }\n    pub fn write(&mut self, write: bool) {\n        self.write = write;\n    }\n    pub fn append(&mut self, append: bool) {\n        self.append = append;\n    }\n    pub fn truncate(&mut self, truncate: bool) {\n        self.truncate = truncate;\n    }\n    pub fn create(&mut self, create: bool) {\n        self.create = create;\n    }\n    pub fn create_new(&mut self, create_new: bool) {\n        self.create_new = create_new;\n    }\n\n    fn get_access_mode(&self) -> io::Result<i32> {\n        match (self.read, self.write, self.append) {\n            (true, false, false) => Ok(O_RDONLY),\n            (false, true, false) => Ok(O_WRONLY),\n            (true, true, false) => Ok(O_RDWR),\n            (false, _, true) => Ok(O_WRONLY | O_APPEND),\n            (true, _, true) => Ok(O_RDWR | O_APPEND),\n            (false, false, false) => {\n                Err(io::Error::new_const(ErrorKind::InvalidInput, &\"invalid access mode\"))\n            }\n        }\n    }\n\n    fn get_creation_mode(&self) -> io::Result<i32> {\n        match (self.write, self.append) {\n            (true, false) => {}\n            (false, false) => {\n                if self.truncate || self.create || self.create_new {\n                    return Err(io::Error::new_const(\n                        ErrorKind::InvalidInput,\n                        &\"invalid creation mode\",\n                    ));\n                }\n            }\n            (_, true) => {\n                if self.truncate && !self.create_new {\n                    return Err(io::Error::new_const(\n                        ErrorKind::InvalidInput,\n                        &\"invalid creation mode\",\n                    ));\n                }\n            }\n        }\n\n        Ok(match (self.create, self.truncate, self.create_new) {\n            (false, false, false) => 0,\n            (true, false, false) => O_CREAT,\n            (false, true, false) => O_TRUNC,\n            (true, true, false) => O_CREAT | O_TRUNC,\n            (_, _, true) => O_CREAT | O_EXCL,\n        })\n    }\n}\n\nimpl File {\n    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n        let path = cstr(path)?;\n        File::open_c(&path, opts)\n    }\n\n    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n        let mut flags = opts.get_access_mode()?;\n        flags = flags | opts.get_creation_mode()?;\n\n        let mode;\n        if flags & O_CREAT == O_CREAT {\n            mode = opts.mode;\n        } else {\n            mode = 0;\n        }\n\n        let fd = unsafe { cvt(abi::open(path.as_ptr(), flags, mode))? };\n        Ok(File(FileDesc::new(fd as i32)))\n    }\n\n    pub fn file_attr(&self) -> io::Result<FileAttr> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn fsync(&self) -> io::Result<()> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn datasync(&self) -> io::Result<()> {\n        self.fsync()\n    }\n\n    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        crate::io::default_read_vectored(|buf| self.read(buf), bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        false\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.0.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        crate::io::default_write_vectored(|buf| self.write(buf), bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        false\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        Ok(())\n    }\n\n    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn duplicate(&self) -> io::Result<File> {\n        Err(Error::from_raw_os_error(22))\n    }\n\n    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n        Err(Error::from_raw_os_error(22))\n    }\n}\n\nimpl DirBuilder {\n    pub fn new() -> DirBuilder {\n        DirBuilder {}\n    }\n\n    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n        unsupported()\n    }\n}\n\npub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n    unsupported()\n}\n\npub fn unlink(path: &Path) -> io::Result<()> {\n    let name = cstr(path)?;\n    let _ = unsafe { cvt(abi::unlink(name.as_ptr()))? };\n    Ok(())\n}\n\npub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n    match perm.0 {}\n}\n\npub fn rmdir(_p: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n    //unsupported()\n    Ok(())\n}\n\npub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n    unsupported()\n}\n\npub fn stat(_p: &Path) -> io::Result<FileAttr> {\n    unsupported()\n}\n\npub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n    unsupported()\n}\n\npub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n    unsupported()\n}\n"],["2505","use crate::collections::HashMap;\nuse crate::error::Error as StdError;\nuse crate::ffi::{CStr, OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::marker::PhantomData;\nuse crate::path::{self, PathBuf};\nuse crate::str;\nuse crate::sync::Mutex;\nuse crate::sys::hermit::abi;\nuse crate::sys::memchr;\nuse crate::sys::unsupported;\nuse crate::sys_common::os_str_bytes::*;\nuse crate::vec;\n\npub fn errno() -> i32 {\n    0\n}\n\npub fn error_string(_errno: i32) -> String {\n    \"operation successful\".to_string()\n}\n\npub fn getcwd() -> io::Result<PathBuf> {\n    unsupported()\n}\n\npub fn chdir(_: &path::Path) -> io::Result<()> {\n    unsupported()\n}\n\npub struct SplitPaths<'a>(!, PhantomData<&'a ()>);\n\npub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {\n    panic!(\"unsupported\")\n}\n\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> {\n        self.0\n    }\n}\n\n#[derive(Debug)]\npub struct JoinPathsError;\n\npub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: Iterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n    Err(JoinPathsError)\n}\n\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"not supported on hermit yet\".fmt(f)\n    }\n}\n\nimpl StdError for JoinPathsError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"not supported on hermit yet\"\n    }\n}\n\npub fn current_exe() -> io::Result<PathBuf> {\n    unsupported()\n}\n\nstatic mut ENV: Option<Mutex<HashMap<OsString, OsString>>> = None;\n\npub fn init_environment(env: *const *const i8) {\n    unsafe {\n        ENV = Some(Mutex::new(HashMap::new()));\n\n        if env.is_null() {\n            return;\n        }\n\n        let mut guard = ENV.as_ref().unwrap().lock().unwrap();\n        let mut environ = env;\n        while !(*environ).is_null() {\n            if let Some((key, value)) = parse(CStr::from_ptr(*environ).to_bytes()) {\n                guard.insert(key, value);\n            }\n            environ = environ.add(1);\n        }\n    }\n\n    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n        // Strategy (copied from glibc): Variable name and value are separated\n        // by an ASCII equals sign '='. Since a variable name must not be\n        // empty, allow variable names starting with an equals sign. Skip all\n        // malformed lines.\n        if input.is_empty() {\n            return None;\n        }\n        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n        pos.map(|p| {\n            (\n                OsStringExt::from_vec(input[..p].to_vec()),\n                OsStringExt::from_vec(input[p + 1..].to_vec()),\n            )\n        })\n    }\n}\n\npub struct Env {\n    iter: vec::IntoIter<(OsString, OsString)>,\n}\n\nimpl !Send for Env {}\nimpl !Sync for Env {}\n\nimpl Iterator for Env {\n    type Item = (OsString, OsString);\n    fn next(&mut self) -> Option<(OsString, OsString)> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n/// Returns a vector of (variable, value) byte-vector pairs for all the\n/// environment variables of the current process.\npub fn env() -> Env {\n    unsafe {\n        let guard = ENV.as_ref().unwrap().lock().unwrap();\n        let mut result = Vec::new();\n\n        for (key, value) in guard.iter() {\n            result.push((key.clone(), value.clone()));\n        }\n\n        return Env { iter: result.into_iter() };\n    }\n}\n\npub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n    unsafe {\n        match ENV.as_ref().unwrap().lock().unwrap().get_mut(k) {\n            Some(value) => Ok(Some(value.clone())),\n            None => Ok(None),\n        }\n    }\n}\n\npub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n    unsafe {\n        let (k, v) = (k.to_owned(), v.to_owned());\n        ENV.as_ref().unwrap().lock().unwrap().insert(k, v);\n    }\n    Ok(())\n}\n\npub fn unsetenv(k: &OsStr) -> io::Result<()> {\n    unsafe {\n        ENV.as_ref().unwrap().lock().unwrap().remove(k);\n    }\n    Ok(())\n}\n\npub fn temp_dir() -> PathBuf {\n    panic!(\"no filesystem on hermit\")\n}\n\npub fn home_dir() -> Option<PathBuf> {\n    None\n}\n\npub fn exit(code: i32) -> ! {\n    unsafe {\n        abi::exit(code);\n    }\n}\n\npub fn getpid() -> u32 {\n    unsafe { abi::getpid() }\n}\n"],["2506","use crate::cell::UnsafeCell;\nuse crate::sys::condvar::Condvar;\nuse crate::sys::mutex::Mutex;\n\npub struct RWLock {\n    lock: Mutex,\n    cond: Condvar,\n    state: UnsafeCell<State>,\n}\n\npub type MovableRWLock = Box<RWLock>;\n\nenum State {\n    Unlocked,\n    Reading(usize),\n    Writing,\n}\n\nunsafe impl Send for RWLock {}\nunsafe impl Sync for RWLock {}\n\n// This rwlock implementation is a relatively simple implementation which has a\n// condition variable for readers/writers as well as a mutex protecting the\n// internal state of the lock. A current downside of the implementation is that\n// unlocking the lock will notify *all* waiters rather than just readers or just\n// writers. This can cause lots of \"thundering stampede\" problems. While\n// hopefully correct this implementation is very likely to want to be changed in\n// the future.\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock { lock: Mutex::new(), cond: Condvar::new(), state: UnsafeCell::new(State::Unlocked) }\n    }\n\n    #[inline]\n    pub unsafe fn read(&self) {\n        self.lock.lock();\n        while !(*self.state.get()).inc_readers() {\n            self.cond.wait(&self.lock);\n        }\n        self.lock.unlock();\n    }\n\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        self.lock.lock();\n        let ok = (*self.state.get()).inc_readers();\n        self.lock.unlock();\n        return ok;\n    }\n\n    #[inline]\n    pub unsafe fn write(&self) {\n        self.lock.lock();\n        while !(*self.state.get()).inc_writers() {\n            self.cond.wait(&self.lock);\n        }\n        self.lock.unlock();\n    }\n\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        self.lock.lock();\n        let ok = (*self.state.get()).inc_writers();\n        self.lock.unlock();\n        return ok;\n    }\n\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        self.lock.lock();\n        let notify = (*self.state.get()).dec_readers();\n        self.lock.unlock();\n        if notify {\n            // FIXME: should only wake up one of these some of the time\n            self.cond.notify_all();\n        }\n    }\n\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        self.lock.lock();\n        (*self.state.get()).dec_writers();\n        self.lock.unlock();\n        // FIXME: should only wake up one of these some of the time\n        self.cond.notify_all();\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        self.lock.destroy();\n        self.cond.destroy();\n    }\n}\n\nimpl State {\n    fn inc_readers(&mut self) -> bool {\n        match *self {\n            State::Unlocked => {\n                *self = State::Reading(1);\n                true\n            }\n            State::Reading(ref mut cnt) => {\n                *cnt += 1;\n                true\n            }\n            State::Writing => false,\n        }\n    }\n\n    fn inc_writers(&mut self) -> bool {\n        match *self {\n            State::Unlocked => {\n                *self = State::Writing;\n                true\n            }\n            State::Reading(_) | State::Writing => false,\n        }\n    }\n\n    fn dec_readers(&mut self) -> bool {\n        let zero = match *self {\n            State::Reading(ref mut cnt) => {\n                *cnt -= 1;\n                *cnt == 0\n            }\n            State::Unlocked | State::Writing => invalid(),\n        };\n        if zero {\n            *self = State::Unlocked;\n        }\n        zero\n    }\n\n    fn dec_writers(&mut self) {\n        match *self {\n            State::Writing => {}\n            State::Unlocked | State::Reading(_) => invalid(),\n        }\n        *self = State::Unlocked;\n    }\n}\n\nfn invalid() -> ! {\n    panic!(\"inconsistent rwlock\");\n}\n"],["2507","use crate::cell::UnsafeCell;\nuse crate::collections::VecDeque;\nuse crate::ffi::c_void;\nuse crate::hint;\nuse crate::ops::{Deref, DerefMut, Drop};\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sys::hermit::abi;\n\n/// This type provides a lock based on busy waiting to realize mutual exclusion\n///\n/// # Description\n///\n/// This structure behaves a lot like a common mutex. There are some differences:\n///\n/// - By using busy waiting, it can be used outside the runtime.\n/// - It is a so called ticket lock and is completly fair.\n#[cfg_attr(target_arch = \"x86_64\", repr(align(128)))]\n#[cfg_attr(not(target_arch = \"x86_64\"), repr(align(64)))]\nstruct Spinlock<T: ?Sized> {\n    queue: AtomicUsize,\n    dequeue: AtomicUsize,\n    data: UnsafeCell<T>,\n}\n\nunsafe impl<T: ?Sized + Send> Sync for Spinlock<T> {}\nunsafe impl<T: ?Sized + Send> Send for Spinlock<T> {}\n\n/// A guard to which the protected data can be accessed\n///\n/// When the guard falls out of scope it will release the lock.\nstruct SpinlockGuard<'a, T: ?Sized + 'a> {\n    dequeue: &'a AtomicUsize,\n    data: &'a mut T,\n}\n\nimpl<T> Spinlock<T> {\n    pub const fn new(user_data: T) -> Spinlock<T> {\n        Spinlock {\n            queue: AtomicUsize::new(0),\n            dequeue: AtomicUsize::new(1),\n            data: UnsafeCell::new(user_data),\n        }\n    }\n\n    #[inline]\n    fn obtain_lock(&self) {\n        let ticket = self.queue.fetch_add(1, Ordering::SeqCst) + 1;\n        while self.dequeue.load(Ordering::SeqCst) != ticket {\n            hint::spin_loop();\n        }\n    }\n\n    #[inline]\n    pub unsafe fn lock(&self) -> SpinlockGuard<'_, T> {\n        self.obtain_lock();\n        SpinlockGuard { dequeue: &self.dequeue, data: &mut *self.data.get() }\n    }\n}\n\nimpl<T: ?Sized + Default> Default for Spinlock<T> {\n    fn default() -> Spinlock<T> {\n        Spinlock::new(Default::default())\n    }\n}\n\nimpl<'a, T: ?Sized> Deref for SpinlockGuard<'a, T> {\n    type Target = T;\n    fn deref(&self) -> &T {\n        &*self.data\n    }\n}\n\nimpl<'a, T: ?Sized> DerefMut for SpinlockGuard<'a, T> {\n    fn deref_mut(&mut self) -> &mut T {\n        &mut *self.data\n    }\n}\n\nimpl<'a, T: ?Sized> Drop for SpinlockGuard<'a, T> {\n    /// The dropping of the SpinlockGuard will release the lock it was created from.\n    fn drop(&mut self) {\n        self.dequeue.fetch_add(1, Ordering::SeqCst);\n    }\n}\n\n/// Realize a priority queue for tasks\nstruct PriorityQueue {\n    queues: [Option<VecDeque<abi::Tid>>; abi::NO_PRIORITIES],\n    prio_bitmap: u64,\n}\n\nimpl PriorityQueue {\n    pub const fn new() -> PriorityQueue {\n        PriorityQueue {\n            queues: [\n                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n                None, None, None,\n            ],\n            prio_bitmap: 0,\n        }\n    }\n\n    /// Add a task id by its priority to the queue\n    pub fn push(&mut self, prio: abi::Priority, id: abi::Tid) {\n        let i: usize = prio.into().into();\n        self.prio_bitmap |= (1 << i) as u64;\n        if let Some(queue) = &mut self.queues[i] {\n            queue.push_back(id);\n        } else {\n            let mut queue = VecDeque::new();\n            queue.push_back(id);\n            self.queues[i] = Some(queue);\n        }\n    }\n\n    fn pop_from_queue(&mut self, queue_index: usize) -> Option<abi::Tid> {\n        if let Some(queue) = &mut self.queues[queue_index] {\n            let id = queue.pop_front();\n\n            if queue.is_empty() {\n                self.prio_bitmap &= !(1 << queue_index as u64);\n            }\n\n            id\n        } else {\n            None\n        }\n    }\n\n    /// Pop the task handle with the highest priority from the queue\n    pub fn pop(&mut self) -> Option<abi::Tid> {\n        for i in 0..abi::NO_PRIORITIES {\n            if self.prio_bitmap & (1 << i) != 0 {\n                return self.pop_from_queue(i);\n            }\n        }\n\n        None\n    }\n}\n\nstruct MutexInner {\n    locked: bool,\n    blocked_task: PriorityQueue,\n}\n\nimpl MutexInner {\n    pub const fn new() -> MutexInner {\n        MutexInner { locked: false, blocked_task: PriorityQueue::new() }\n    }\n}\n\npub struct Mutex {\n    inner: Spinlock<MutexInner>,\n}\n\npub type MovableMutex = Box<Mutex>;\n\nunsafe impl Send for Mutex {}\nunsafe impl Sync for Mutex {}\n\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        Mutex { inner: Spinlock::new(MutexInner::new()) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {\n        self.inner = Spinlock::new(MutexInner::new());\n    }\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        loop {\n            let mut guard = self.inner.lock();\n            if guard.locked == false {\n                guard.locked = true;\n                return;\n            } else {\n                let prio = abi::get_priority();\n                let id = abi::getpid();\n\n                guard.blocked_task.push(prio, id);\n                abi::block_current_task();\n                drop(guard);\n                abi::yield_now();\n            }\n        }\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let mut guard = self.inner.lock();\n        guard.locked = false;\n        if let Some(tid) = guard.blocked_task.pop() {\n            abi::wakeup_task(tid);\n        }\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        let mut guard = self.inner.lock();\n        if guard.locked == false {\n            guard.locked = true;\n        }\n        guard.locked\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {}\n}\n\npub struct ReentrantMutex {\n    inner: *const c_void,\n}\n\nimpl ReentrantMutex {\n    pub const unsafe fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex { inner: ptr::null() }\n    }\n\n    #[inline]\n    pub unsafe fn init(&self) {\n        let _ = abi::recmutex_init(&self.inner as *const *const c_void as *mut _);\n    }\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        let _ = abi::recmutex_lock(self.inner);\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        let _ = abi::recmutex_unlock(self.inner);\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        let _ = abi::recmutex_destroy(self.inner);\n    }\n}\n"],["2508","pub mod os {\n    pub const FAMILY: &str = \"\";\n    pub const OS: &str = \"hermit\";\n    pub const DLL_PREFIX: &str = \"\";\n    pub const DLL_SUFFIX: &str = \"\";\n    pub const DLL_EXTENSION: &str = \"\";\n    pub const EXE_SUFFIX: &str = \"\";\n    pub const EXE_EXTENSION: &str = \"\";\n}\n"],["2509","use crate::convert::TryFrom;\nuse crate::fmt;\nuse crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\nuse crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\nuse crate::str;\nuse crate::sync::Arc;\nuse crate::sys::hermit::abi;\nuse crate::sys::hermit::abi::IpAddress::{Ipv4, Ipv6};\nuse crate::sys::unsupported;\nuse crate::sys_common::AsInner;\nuse crate::time::Duration;\n\n/// Checks whether the HermitCore's socket interface has been started already, and\n/// if not, starts it.\npub fn init() -> io::Result<()> {\n    if abi::network_init() < 0 {\n        return Err(io::Error::new_const(\n            ErrorKind::Other,\n            &\"Unable to initialize network interface\",\n        ));\n    }\n\n    Ok(())\n}\n\n#[derive(Debug, Clone)]\npub struct Socket(abi::Handle);\n\nimpl AsInner<abi::Handle> for Socket {\n    fn as_inner(&self) -> &abi::Handle {\n        &self.0\n    }\n}\n\nimpl Drop for Socket {\n    fn drop(&mut self) {\n        let _ = abi::tcpstream::close(self.0);\n    }\n}\n\n// Arc is used to count the number of used sockets.\n// Only if all sockets are released, the drop\n// method will close the socket.\n#[derive(Clone)]\npub struct TcpStream(Arc<Socket>);\n\nimpl TcpStream {\n    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n        let addr = addr?;\n\n        match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n            _ => Err(io::Error::new_const(\n                ErrorKind::Other,\n                &\"Unable to initiate a connection on a socket\",\n            )),\n        }\n    }\n\n    pub fn connect_timeout(saddr: &SocketAddr, duration: Duration) -> io::Result<TcpStream> {\n        match abi::tcpstream::connect(\n            saddr.ip().to_string().as_bytes(),\n            saddr.port(),\n            Some(duration.as_millis() as u64),\n        ) {\n            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n            _ => Err(io::Error::new_const(\n                ErrorKind::Other,\n                &\"Unable to initiate a connection on a socket\",\n            )),\n        }\n    }\n\n    pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n        abi::tcpstream::set_read_timeout(*self.0.as_inner(), duration.map(|d| d.as_millis() as u64))\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"Unable to set timeout value\"))\n    }\n\n    pub fn set_write_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n        abi::tcpstream::set_write_timeout(\n            *self.0.as_inner(),\n            duration.map(|d| d.as_millis() as u64),\n        )\n        .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"Unable to set timeout value\"))\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner()).map_err(|_| {\n            io::Error::new_const(ErrorKind::Other, &\"Unable to determine timeout value\")\n        })?;\n\n        Ok(duration.map(|d| Duration::from_millis(d)))\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner()).map_err(|_| {\n            io::Error::new_const(ErrorKind::Other, &\"Unable to determine timeout value\")\n        })?;\n\n        Ok(duration.map(|d| Duration::from_millis(d)))\n    }\n\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n        abi::tcpstream::peek(*self.0.as_inner(), buf)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"set_nodelay failed\"))\n    }\n\n    pub fn read(&self, buffer: &mut [u8]) -> io::Result<usize> {\n        self.read_vectored(&mut [IoSliceMut::new(buffer)])\n    }\n\n    pub fn read_vectored(&self, ioslice: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut size: usize = 0;\n\n        for i in ioslice.iter_mut() {\n            let ret = abi::tcpstream::read(*self.0.as_inner(), &mut i[0..])\n                .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"Unable to read on socket\"))?;\n\n            if ret != 0 {\n                size += ret;\n            }\n        }\n\n        Ok(size)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn write(&self, buffer: &[u8]) -> io::Result<usize> {\n        self.write_vectored(&[IoSlice::new(buffer)])\n    }\n\n    pub fn write_vectored(&self, ioslice: &[IoSlice<'_>]) -> io::Result<usize> {\n        let mut size: usize = 0;\n\n        for i in ioslice.iter() {\n            size += abi::tcpstream::write(*self.0.as_inner(), i).map_err(|_| {\n                io::Error::new_const(ErrorKind::Other, &\"Unable to write on socket\")\n            })?;\n        }\n\n        Ok(size)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        let (ipaddr, port) = abi::tcpstream::peer_addr(*self.0.as_inner())\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"peer_addr failed\"))?;\n\n        let saddr = match ipaddr {\n            Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n            _ => {\n                return Err(io::Error::new_const(ErrorKind::Other, &\"peer_addr failed\"));\n            }\n        };\n\n        Ok(saddr)\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        unsupported()\n    }\n\n    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to shutdown socket\"))\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpStream> {\n        Ok(self.clone())\n    }\n\n    pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n        abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"set_nodelay failed\"))\n    }\n\n    pub fn nodelay(&self) -> io::Result<bool> {\n        abi::tcpstream::nodelay(*self.0.as_inner())\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"nodelay failed\"))\n    }\n\n    pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n        abi::tcpstream::set_tll(*self.0.as_inner(), tll)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to set TTL\"))\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        abi::tcpstream::get_tll(*self.0.as_inner())\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to get TTL\"))\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        unsupported()\n    }\n\n    pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n        abi::tcpstream::set_nonblocking(*self.0.as_inner(), mode)\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to set blocking mode\"))\n    }\n}\n\nimpl fmt::Debug for TcpStream {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        Ok(())\n    }\n}\n\n#[derive(Clone)]\npub struct TcpListener(SocketAddr);\n\nimpl TcpListener {\n    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n        let addr = addr?;\n\n        Ok(TcpListener(*addr))\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        Ok(self.0)\n    }\n\n    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n        let (handle, ipaddr, port) = abi::tcplistener::accept(self.0.port())\n            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"accept failed\"))?;\n        let saddr = match ipaddr {\n            Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n            _ => {\n                return Err(io::Error::new_const(ErrorKind::Other, &\"accept failed\"));\n            }\n        };\n\n        Ok((TcpStream(Arc::new(Socket(handle))), saddr))\n    }\n\n    pub fn duplicate(&self) -> io::Result<TcpListener> {\n        Ok(self.clone())\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        unsupported()\n    }\n\n    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn only_v6(&self) -> io::Result<bool> {\n        unsupported()\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        unsupported()\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n}\n\nimpl fmt::Debug for TcpListener {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        Ok(())\n    }\n}\n\npub struct UdpSocket(abi::Handle);\n\nimpl UdpSocket {\n    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n        unsupported()\n    }\n\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        unsupported()\n    }\n\n    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n        unsupported()\n    }\n\n    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        unsupported()\n    }\n\n    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        unsupported()\n    }\n\n    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n        unsupported()\n    }\n\n    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n        unsupported()\n    }\n\n    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n        unsupported()\n    }\n\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n        unsupported()\n    }\n\n    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn broadcast(&self) -> io::Result<bool> {\n        unsupported()\n    }\n\n    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n        unsupported()\n    }\n\n    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n        unsupported()\n    }\n\n    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n        unsupported()\n    }\n\n    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn ttl(&self) -> io::Result<u32> {\n        unsupported()\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        unsupported()\n    }\n\n    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n        unsupported()\n    }\n\n    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n        unsupported()\n    }\n\n    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n        unsupported()\n    }\n\n    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n        unsupported()\n    }\n\n    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n        unsupported()\n    }\n}\n\nimpl fmt::Debug for UdpSocket {\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        Ok(())\n    }\n}\n\npub struct LookupHost(!);\n\nimpl LookupHost {\n    pub fn port(&self) -> u16 {\n        self.0\n    }\n}\n\nimpl Iterator for LookupHost {\n    type Item = SocketAddr;\n    fn next(&mut self) -> Option<SocketAddr> {\n        self.0\n    }\n}\n\nimpl TryFrom<&str> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from(_v: &str) -> io::Result<LookupHost> {\n        unsupported()\n    }\n}\n\nimpl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n    type Error = io::Error;\n\n    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n        unsupported()\n    }\n}\n\n#[allow(nonstandard_style)]\npub mod netc {\n    pub const AF_INET: u8 = 0;\n    pub const AF_INET6: u8 = 1;\n    pub type sa_family_t = u8;\n\n    #[derive(Copy, Clone)]\n    pub struct in_addr {\n        pub s_addr: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in {\n        pub sin_family: sa_family_t,\n        pub sin_port: u16,\n        pub sin_addr: in_addr,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct in6_addr {\n        pub s6_addr: [u8; 16],\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr_in6 {\n        pub sin6_family: sa_family_t,\n        pub sin6_port: u16,\n        pub sin6_addr: in6_addr,\n        pub sin6_flowinfo: u32,\n        pub sin6_scope_id: u32,\n    }\n\n    #[derive(Copy, Clone)]\n    pub struct sockaddr {}\n\n    pub type socklen_t = usize;\n}\n"],["2510","//! System bindings for HermitCore\n//!\n//! This module contains the facade (aka platform-specific) implementations of\n//! OS level functionality for HermitCore.\n//!\n//! This is all super highly experimental and not actually intended for\n//! wide/production use yet, it's still all in the experimental category. This\n//! will likely change over time.\n//!\n//! Currently all functions here are basically stubs that immediately return\n//! errors. The hope is that with a portability lint we can turn actually just\n//! remove all this and just omit parts of the standard library if we're\n//! compiling for wasm. That way it's a compile time error for something that's\n//! guaranteed to be a runtime error!\n\n#![allow(unsafe_op_in_unsafe_fn)]\n\nuse crate::intrinsics;\nuse crate::os::raw::c_char;\n\npub mod alloc;\npub mod args;\n#[path = \"../unix/cmath.rs\"]\npub mod cmath;\npub mod condvar;\npub mod env;\npub mod fd;\npub mod fs;\n#[path = \"../unsupported/io.rs\"]\npub mod io;\npub mod memchr;\npub mod mutex;\npub mod net;\npub mod os;\n#[path = \"../unix/path.rs\"]\npub mod path;\n#[path = \"../unsupported/pipe.rs\"]\npub mod pipe;\n#[path = \"../unsupported/process.rs\"]\npub mod process;\npub mod rwlock;\npub mod stdio;\npub mod thread;\npub mod thread_local_dtor;\n#[path = \"../unsupported/thread_local_key.rs\"]\npub mod thread_local_key;\npub mod time;\n\nuse crate::io::ErrorKind;\npub use crate::sys_common::os_str_bytes as os_str;\n\n#[allow(unused_extern_crates)]\npub extern crate hermit_abi as abi;\n\npub fn unsupported<T>() -> crate::io::Result<T> {\n    Err(unsupported_err())\n}\n\npub fn unsupported_err() -> crate::io::Error {\n    crate::io::Error::new_const(\n        crate::io::ErrorKind::Unsupported,\n        &\"operation not supported on HermitCore yet\",\n    )\n}\n\npub unsafe fn strlen(start: *const c_char) -> usize {\n    let mut str = start;\n\n    while *str != 0 {\n        str = str.offset(1);\n    }\n\n    (str as usize) - (start as usize)\n}\n\n#[no_mangle]\npub extern \"C\" fn floor(x: f64) -> f64 {\n    unsafe { intrinsics::floorf64(x) }\n}\n\npub fn abort_internal() -> ! {\n    unsafe {\n        abi::abort();\n    }\n}\n\n// FIXME: just a workaround to test the system\npub fn hashmap_random_keys() -> (u64, u64) {\n    (1, 2)\n}\n\n// This function is needed by the panic runtime. The symbol is named in\n// pre-link args for the target specification, so keep that in sync.\n#[cfg(not(test))]\n#[no_mangle]\n// NB. used by both libunwind and libpanic_abort\npub extern \"C\" fn __rust_abort() {\n    abort_internal();\n}\n\n// SAFETY: must be called only once during runtime initialization.\n// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    let _ = net::init();\n    args::init(argc, argv);\n}\n\n// SAFETY: must be called only once during runtime cleanup.\n// NOTE: this is not guaranteed to run, for example when the program aborts.\npub unsafe fn cleanup() {\n    args::cleanup();\n}\n\n#[cfg(not(test))]\n#[no_mangle]\npub unsafe extern \"C\" fn runtime_entry(\n    argc: i32,\n    argv: *const *const c_char,\n    env: *const *const c_char,\n) -> ! {\n    use crate::sys::hermit::thread_local_dtor::run_dtors;\n    extern \"C\" {\n        fn main(argc: isize, argv: *const *const c_char) -> i32;\n    }\n\n    // initialize environment\n    os::init_environment(env as *const *const i8);\n\n    let result = main(argc as isize, argv);\n\n    run_dtors();\n    abi::exit(result);\n}\n\npub fn decode_error_kind(errno: i32) -> ErrorKind {\n    match errno {\n        x if x == 13 as i32 => ErrorKind::PermissionDenied,\n        x if x == 98 as i32 => ErrorKind::AddrInUse,\n        x if x == 99 as i32 => ErrorKind::AddrNotAvailable,\n        x if x == 11 as i32 => ErrorKind::WouldBlock,\n        x if x == 103 as i32 => ErrorKind::ConnectionAborted,\n        x if x == 111 as i32 => ErrorKind::ConnectionRefused,\n        x if x == 104 as i32 => ErrorKind::ConnectionReset,\n        x if x == 17 as i32 => ErrorKind::AlreadyExists,\n        x if x == 4 as i32 => ErrorKind::Interrupted,\n        x if x == 22 as i32 => ErrorKind::InvalidInput,\n        x if x == 2 as i32 => ErrorKind::NotFound,\n        x if x == 107 as i32 => ErrorKind::NotConnected,\n        x if x == 1 as i32 => ErrorKind::PermissionDenied,\n        x if x == 32 as i32 => ErrorKind::BrokenPipe,\n        x if x == 110 as i32 => ErrorKind::TimedOut,\n        _ => ErrorKind::Other,\n    }\n}\n\npub fn cvt(result: i32) -> crate::io::Result<usize> {\n    if result < 0 { Err(crate::io::Error::from_raw_os_error(-result)) } else { Ok(result as usize) }\n}\n"],["2511","#![cfg(target_thread_local)]\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n\n// Simplify dtor registration by using a list of destructors.\n// The this solution works like the implementation of macOS and\n// doesn't additional OS support\n\nuse crate::cell::Cell;\nuse crate::ptr;\n\n#[thread_local]\nstatic DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n\ntype List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n\npub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    if DTORS.get().is_null() {\n        let v: Box<List> = box Vec::new();\n        DTORS.set(Box::into_raw(v));\n    }\n\n    let list: &mut List = &mut *DTORS.get();\n    list.push((t, dtor));\n}\n\n// every thread call this function to run through all possible destructors\npub unsafe fn run_dtors() {\n    let mut ptr = DTORS.replace(ptr::null_mut());\n    while !ptr.is_null() {\n        let list = Box::from_raw(ptr);\n        for (ptr, dtor) in list.into_iter() {\n            dtor(ptr);\n        }\n        ptr = DTORS.replace(ptr::null_mut());\n    }\n}\n"],["2512","#![allow(dead_code)]\n\nuse crate::cmp::Ordering;\nuse crate::convert::TryInto;\nuse crate::sys::hermit::abi;\nuse crate::sys::hermit::abi::timespec;\nuse crate::sys::hermit::abi::{CLOCK_MONOTONIC, CLOCK_REALTIME, NSEC_PER_SEC};\nuse crate::time::Duration;\nuse core::hash::{Hash, Hasher};\n\n#[derive(Copy, Clone, Debug)]\nstruct Timespec {\n    t: timespec,\n}\n\nimpl Timespec {\n    const fn zero() -> Timespec {\n        Timespec { t: timespec { tv_sec: 0, tv_nsec: 0 } }\n    }\n\n    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n        if self >= other {\n            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n                Duration::new(\n                    (self.t.tv_sec - other.t.tv_sec) as u64,\n                    (self.t.tv_nsec - other.t.tv_nsec) as u32,\n                )\n            } else {\n                Duration::new(\n                    (self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n                )\n            })\n        } else {\n            match other.sub_timespec(self) {\n                Ok(d) => Err(d),\n                Err(d) => Ok(d),\n            }\n        }\n    }\n\n    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n        let mut secs = other\n            .as_secs()\n            .try_into() // <- target type would be `libc::time_t`\n            .ok()\n            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n\n        // Nano calculations can't overflow because nanos are <1B which fit\n        // in a u32.\n        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n        if nsec >= NSEC_PER_SEC as u32 {\n            nsec -= NSEC_PER_SEC as u32;\n            secs = secs.checked_add(1)?;\n        }\n        Some(Timespec { t: timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n    }\n\n    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n        let mut secs = other\n            .as_secs()\n            .try_into() // <- target type would be `libc::time_t`\n            .ok()\n            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n\n        // Similar to above, nanos can't overflow.\n        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n        if nsec < 0 {\n            nsec += NSEC_PER_SEC as i32;\n            secs = secs.checked_sub(1)?;\n        }\n        Some(Timespec { t: timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n    }\n}\n\nimpl PartialEq for Timespec {\n    fn eq(&self, other: &Timespec) -> bool {\n        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n    }\n}\n\nimpl Eq for Timespec {}\n\nimpl PartialOrd for Timespec {\n    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Timespec {\n    fn cmp(&self, other: &Timespec) -> Ordering {\n        let me = (self.t.tv_sec, self.t.tv_nsec);\n        let other = (other.t.tv_sec, other.t.tv_nsec);\n        me.cmp(&other)\n    }\n}\n\nimpl Hash for Timespec {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.t.tv_sec.hash(state);\n        self.t.tv_nsec.hash(state);\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\npub struct Instant {\n    t: Timespec,\n}\n\nimpl Instant {\n    pub fn now() -> Instant {\n        let mut time: Timespec = Timespec::zero();\n        let _ = unsafe { abi::clock_gettime(CLOCK_MONOTONIC, &mut time.t as *mut timespec) };\n\n        Instant { t: time }\n    }\n\n    pub const fn zero() -> Instant {\n        Instant { t: Timespec::zero() }\n    }\n\n    pub fn actually_monotonic() -> bool {\n        true\n    }\n\n    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n        self.t.sub_timespec(&other.t).ok()\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant { t: self.t.checked_add_duration(other)? })\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant { t: self.t.checked_sub_duration(other)? })\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub struct SystemTime {\n    t: Timespec,\n}\n\npub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n\nimpl SystemTime {\n    pub fn now() -> SystemTime {\n        let mut time: Timespec = Timespec::zero();\n        let _ = unsafe { abi::clock_gettime(CLOCK_REALTIME, &mut time.t as *mut timespec) };\n\n        SystemTime { t: time }\n    }\n\n    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n        self.t.sub_timespec(&other.t)\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime { t: self.t.checked_add_duration(other)? })\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n        Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n    }\n}\n"],["2513","use crate::ffi::OsString;\nuse crate::fmt;\nuse crate::vec;\n\n/// One-time global initialization.\npub unsafe fn init(argc: isize, argv: *const *const u8) {\n    imp::init(argc, argv)\n}\n\n/// One-time global cleanup.\npub unsafe fn cleanup() {\n    imp::cleanup()\n}\n\n/// Returns the command line arguments\npub fn args() -> Args {\n    imp::args()\n}\n\npub struct Args {\n    iter: vec::IntoIter<OsString>,\n}\n\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.iter.as_slice().fmt(f)\n    }\n}\n\nimpl !Send for Args {}\nimpl !Sync for Args {}\n\nimpl Iterator for Args {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}\n\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<OsString> {\n        self.iter.next_back()\n    }\n}\n\nmod imp {\n    use super::Args;\n    use crate::ffi::{CStr, OsString};\n    use crate::ptr;\n    use crate::sys_common::os_str_bytes::*;\n\n    use crate::sys_common::mutex::StaticMutex;\n\n    static mut ARGC: isize = 0;\n    static mut ARGV: *const *const u8 = ptr::null();\n    static LOCK: StaticMutex = StaticMutex::new();\n\n    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n        let _guard = LOCK.lock();\n        ARGC = argc;\n        ARGV = argv;\n    }\n\n    pub unsafe fn cleanup() {\n        let _guard = LOCK.lock();\n        ARGC = 0;\n        ARGV = ptr::null();\n    }\n\n    pub fn args() -> Args {\n        Args { iter: clone().into_iter() }\n    }\n\n    fn clone() -> Vec<OsString> {\n        unsafe {\n            let _guard = LOCK.lock();\n            (0..ARGC)\n                .map(|i| {\n                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const i8);\n                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n                })\n                .collect()\n        }\n    }\n}\n"],["2514","use crate::ffi::c_void;\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nuse crate::sys::hermit::abi;\nuse crate::sys::mutex::Mutex;\nuse crate::time::Duration;\n\n// The implementation is inspired by Andrew D. Birrell's paper\n// \"Implementing Condition Variables with Semaphores\"\n\npub struct Condvar {\n    counter: AtomicUsize,\n    sem1: *const c_void,\n    sem2: *const c_void,\n}\n\npub type MovableCondvar = Box<Condvar>;\n\nunsafe impl Send for Condvar {}\nunsafe impl Sync for Condvar {}\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        Condvar { counter: AtomicUsize::new(0), sem1: ptr::null(), sem2: ptr::null() }\n    }\n\n    pub unsafe fn init(&mut self) {\n        let _ = abi::sem_init(&mut self.sem1 as *mut *const c_void, 0);\n        let _ = abi::sem_init(&mut self.sem2 as *mut *const c_void, 0);\n    }\n\n    pub unsafe fn notify_one(&self) {\n        if self.counter.load(SeqCst) > 0 {\n            self.counter.fetch_sub(1, SeqCst);\n            abi::sem_post(self.sem1);\n            abi::sem_timedwait(self.sem2, 0);\n        }\n    }\n\n    pub unsafe fn notify_all(&self) {\n        let counter = self.counter.swap(0, SeqCst);\n        for _ in 0..counter {\n            abi::sem_post(self.sem1);\n        }\n        for _ in 0..counter {\n            abi::sem_timedwait(self.sem2, 0);\n        }\n    }\n\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n        self.counter.fetch_add(1, SeqCst);\n        mutex.unlock();\n        abi::sem_timedwait(self.sem1, 0);\n        abi::sem_post(self.sem2);\n        mutex.lock();\n    }\n\n    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n        panic!(\"wait_timeout not supported on hermit\");\n    }\n\n    pub unsafe fn destroy(&self) {\n        let _ = abi::sem_destroy(self.sem1);\n        let _ = abi::sem_destroy(self.sem2);\n    }\n}\n"],["2515","use crate::io;\nuse crate::mem;\nuse crate::sys::c;\n\n#[cfg(not(target_vendor = \"uwp\"))]\npub fn hashmap_random_keys() -> (u64, u64) {\n    let mut v = (0, 0);\n    let ret =\n        unsafe { c::RtlGenRandom(&mut v as *mut _ as *mut u8, mem::size_of_val(&v) as c::ULONG) };\n    if ret == 0 {\n        panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n    }\n    v\n}\n\n#[cfg(target_vendor = \"uwp\")]\npub fn hashmap_random_keys() -> (u64, u64) {\n    use crate::ptr;\n\n    let mut v = (0, 0);\n    let ret = unsafe {\n        c::BCryptGenRandom(\n            ptr::null_mut(),\n            &mut v as *mut _ as *mut u8,\n            mem::size_of_val(&v) as c::ULONG,\n            c::BCRYPT_USE_SYSTEM_PREFERRED_RNG,\n        )\n    };\n    if ret != 0 {\n        panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n    }\n    return v;\n}\n"],["2516","use crate::os::windows::prelude::*;\n\nuse crate::ffi::OsString;\nuse crate::fmt;\nuse crate::io::{self, Error, IoSlice, IoSliceMut, SeekFrom};\nuse crate::mem;\nuse crate::path::{Path, PathBuf};\nuse crate::ptr;\nuse crate::slice;\nuse crate::sync::Arc;\nuse crate::sys::handle::Handle;\nuse crate::sys::time::SystemTime;\nuse crate::sys::{c, cvt};\nuse crate::sys_common::FromInner;\n\nuse super::to_u16s;\n\npub struct File {\n    handle: Handle,\n}\n\n#[derive(Clone)]\npub struct FileAttr {\n    attributes: c::DWORD,\n    creation_time: c::FILETIME,\n    last_access_time: c::FILETIME,\n    last_write_time: c::FILETIME,\n    file_size: u64,\n    reparse_tag: c::DWORD,\n    volume_serial_number: Option<u32>,\n    number_of_links: Option<u32>,\n    file_index: Option<u64>,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\npub struct FileType {\n    attributes: c::DWORD,\n    reparse_tag: c::DWORD,\n}\n\npub struct ReadDir {\n    handle: FindNextFileHandle,\n    root: Arc<PathBuf>,\n    first: Option<c::WIN32_FIND_DATAW>,\n}\n\nstruct FindNextFileHandle(c::HANDLE);\n\nunsafe impl Send for FindNextFileHandle {}\nunsafe impl Sync for FindNextFileHandle {}\n\npub struct DirEntry {\n    root: Arc<PathBuf>,\n    data: c::WIN32_FIND_DATAW,\n}\n\n#[derive(Clone, Debug)]\npub struct OpenOptions {\n    // generic\n    read: bool,\n    write: bool,\n    append: bool,\n    truncate: bool,\n    create: bool,\n    create_new: bool,\n    // system-specific\n    custom_flags: u32,\n    access_mode: Option<c::DWORD>,\n    attributes: c::DWORD,\n    share_mode: c::DWORD,\n    security_qos_flags: c::DWORD,\n    security_attributes: usize, // FIXME: should be a reference\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct FilePermissions {\n    attrs: c::DWORD,\n}\n\n#[derive(Debug)]\npub struct DirBuilder;\n\nimpl fmt::Debug for ReadDir {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n        // Thus the result will be e g 'ReadDir(\"C:\\\")'\n        fmt::Debug::fmt(&*self.root, f)\n    }\n}\n\nimpl Iterator for ReadDir {\n    type Item = io::Result<DirEntry>;\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        if let Some(first) = self.first.take() {\n            if let Some(e) = DirEntry::new(&self.root, &first) {\n                return Some(Ok(e));\n            }\n        }\n        unsafe {\n            let mut wfd = mem::zeroed();\n            loop {\n                if c::FindNextFileW(self.handle.0, &mut wfd) == 0 {\n                    if c::GetLastError() == c::ERROR_NO_MORE_FILES {\n                        return None;\n                    } else {\n                        return Some(Err(Error::last_os_error()));\n                    }\n                }\n                if let Some(e) = DirEntry::new(&self.root, &wfd) {\n                    return Some(Ok(e));\n                }\n            }\n        }\n    }\n}\n\nimpl Drop for FindNextFileHandle {\n    fn drop(&mut self) {\n        let r = unsafe { c::FindClose(self.0) };\n        debug_assert!(r != 0);\n    }\n}\n\nimpl DirEntry {\n    fn new(root: &Arc<PathBuf>, wfd: &c::WIN32_FIND_DATAW) -> Option<DirEntry> {\n        match &wfd.cFileName[0..3] {\n            // check for '.' and '..'\n            &[46, 0, ..] | &[46, 46, 0, ..] => return None,\n            _ => {}\n        }\n\n        Some(DirEntry { root: root.clone(), data: *wfd })\n    }\n\n    pub fn path(&self) -> PathBuf {\n        self.root.join(&self.file_name())\n    }\n\n    pub fn file_name(&self) -> OsString {\n        let filename = super::truncate_utf16_at_nul(&self.data.cFileName);\n        OsString::from_wide(filename)\n    }\n\n    pub fn file_type(&self) -> io::Result<FileType> {\n        Ok(FileType::new(\n            self.data.dwFileAttributes,\n            /* reparse_tag = */ self.data.dwReserved0,\n        ))\n    }\n\n    pub fn metadata(&self) -> io::Result<FileAttr> {\n        Ok(FileAttr {\n            attributes: self.data.dwFileAttributes,\n            creation_time: self.data.ftCreationTime,\n            last_access_time: self.data.ftLastAccessTime,\n            last_write_time: self.data.ftLastWriteTime,\n            file_size: ((self.data.nFileSizeHigh as u64) << 32) | (self.data.nFileSizeLow as u64),\n            reparse_tag: if self.data.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n                // reserved unless this is a reparse point\n                self.data.dwReserved0\n            } else {\n                0\n            },\n            volume_serial_number: None,\n            number_of_links: None,\n            file_index: None,\n        })\n    }\n}\n\nimpl OpenOptions {\n    pub fn new() -> OpenOptions {\n        OpenOptions {\n            // generic\n            read: false,\n            write: false,\n            append: false,\n            truncate: false,\n            create: false,\n            create_new: false,\n            // system-specific\n            custom_flags: 0,\n            access_mode: None,\n            share_mode: c::FILE_SHARE_READ | c::FILE_SHARE_WRITE | c::FILE_SHARE_DELETE,\n            attributes: 0,\n            security_qos_flags: 0,\n            security_attributes: 0,\n        }\n    }\n\n    pub fn read(&mut self, read: bool) {\n        self.read = read;\n    }\n    pub fn write(&mut self, write: bool) {\n        self.write = write;\n    }\n    pub fn append(&mut self, append: bool) {\n        self.append = append;\n    }\n    pub fn truncate(&mut self, truncate: bool) {\n        self.truncate = truncate;\n    }\n    pub fn create(&mut self, create: bool) {\n        self.create = create;\n    }\n    pub fn create_new(&mut self, create_new: bool) {\n        self.create_new = create_new;\n    }\n\n    pub fn custom_flags(&mut self, flags: u32) {\n        self.custom_flags = flags;\n    }\n    pub fn access_mode(&mut self, access_mode: u32) {\n        self.access_mode = Some(access_mode);\n    }\n    pub fn share_mode(&mut self, share_mode: u32) {\n        self.share_mode = share_mode;\n    }\n    pub fn attributes(&mut self, attrs: u32) {\n        self.attributes = attrs;\n    }\n    pub fn security_qos_flags(&mut self, flags: u32) {\n        // We have to set `SECURITY_SQOS_PRESENT` here, because one of the valid flags we can\n        // receive is `SECURITY_ANONYMOUS = 0x0`, which we can't check for later on.\n        self.security_qos_flags = flags | c::SECURITY_SQOS_PRESENT;\n    }\n    pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) {\n        self.security_attributes = attrs as usize;\n    }\n\n    fn get_access_mode(&self) -> io::Result<c::DWORD> {\n        const ERROR_INVALID_PARAMETER: i32 = 87;\n\n        match (self.read, self.write, self.append, self.access_mode) {\n            (.., Some(mode)) => Ok(mode),\n            (true, false, false, None) => Ok(c::GENERIC_READ),\n            (false, true, false, None) => Ok(c::GENERIC_WRITE),\n            (true, true, false, None) => Ok(c::GENERIC_READ | c::GENERIC_WRITE),\n            (false, _, true, None) => Ok(c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA),\n            (true, _, true, None) => {\n                Ok(c::GENERIC_READ | (c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA))\n            }\n            (false, false, false, None) => Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER)),\n        }\n    }\n\n    fn get_creation_mode(&self) -> io::Result<c::DWORD> {\n        const ERROR_INVALID_PARAMETER: i32 = 87;\n\n        match (self.write, self.append) {\n            (true, false) => {}\n            (false, false) => {\n                if self.truncate || self.create || self.create_new {\n                    return Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n                }\n            }\n            (_, true) => {\n                if self.truncate && !self.create_new {\n                    return Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n                }\n            }\n        }\n\n        Ok(match (self.create, self.truncate, self.create_new) {\n            (false, false, false) => c::OPEN_EXISTING,\n            (true, false, false) => c::OPEN_ALWAYS,\n            (false, true, false) => c::TRUNCATE_EXISTING,\n            (true, true, false) => c::CREATE_ALWAYS,\n            (_, _, true) => c::CREATE_NEW,\n        })\n    }\n\n    fn get_flags_and_attributes(&self) -> c::DWORD {\n        self.custom_flags\n            | self.attributes\n            | self.security_qos_flags\n            | if self.create_new { c::FILE_FLAG_OPEN_REPARSE_POINT } else { 0 }\n    }\n}\n\nimpl File {\n    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n        let path = to_u16s(path)?;\n        let handle = unsafe {\n            c::CreateFileW(\n                path.as_ptr(),\n                opts.get_access_mode()?,\n                opts.share_mode,\n                opts.security_attributes as *mut _,\n                opts.get_creation_mode()?,\n                opts.get_flags_and_attributes(),\n                ptr::null_mut(),\n            )\n        };\n        if handle == c::INVALID_HANDLE_VALUE {\n            Err(Error::last_os_error())\n        } else {\n            Ok(File { handle: Handle::new(handle) })\n        }\n    }\n\n    pub fn fsync(&self) -> io::Result<()> {\n        cvt(unsafe { c::FlushFileBuffers(self.handle.raw()) })?;\n        Ok(())\n    }\n\n    pub fn datasync(&self) -> io::Result<()> {\n        self.fsync()\n    }\n\n    pub fn truncate(&self, size: u64) -> io::Result<()> {\n        let mut info = c::FILE_END_OF_FILE_INFO { EndOfFile: size as c::LARGE_INTEGER };\n        let size = mem::size_of_val(&info);\n        cvt(unsafe {\n            c::SetFileInformationByHandle(\n                self.handle.raw(),\n                c::FileEndOfFileInfo,\n                &mut info as *mut _ as *mut _,\n                size as c::DWORD,\n            )\n        })?;\n        Ok(())\n    }\n\n    #[cfg(not(target_vendor = \"uwp\"))]\n    pub fn file_attr(&self) -> io::Result<FileAttr> {\n        unsafe {\n            let mut info: c::BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n            cvt(c::GetFileInformationByHandle(self.handle.raw(), &mut info))?;\n            let mut reparse_tag = 0;\n            if info.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n                if let Ok((_, buf)) = self.reparse_point(&mut b) {\n                    reparse_tag = buf.ReparseTag;\n                }\n            }\n            Ok(FileAttr {\n                attributes: info.dwFileAttributes,\n                creation_time: info.ftCreationTime,\n                last_access_time: info.ftLastAccessTime,\n                last_write_time: info.ftLastWriteTime,\n                file_size: (info.nFileSizeLow as u64) | ((info.nFileSizeHigh as u64) << 32),\n                reparse_tag,\n                volume_serial_number: Some(info.dwVolumeSerialNumber),\n                number_of_links: Some(info.nNumberOfLinks),\n                file_index: Some(\n                    (info.nFileIndexLow as u64) | ((info.nFileIndexHigh as u64) << 32),\n                ),\n            })\n        }\n    }\n\n    #[cfg(target_vendor = \"uwp\")]\n    pub fn file_attr(&self) -> io::Result<FileAttr> {\n        unsafe {\n            let mut info: c::FILE_BASIC_INFO = mem::zeroed();\n            let size = mem::size_of_val(&info);\n            cvt(c::GetFileInformationByHandleEx(\n                self.handle.raw(),\n                c::FileBasicInfo,\n                &mut info as *mut _ as *mut libc::c_void,\n                size as c::DWORD,\n            ))?;\n            let mut attr = FileAttr {\n                attributes: info.FileAttributes,\n                creation_time: c::FILETIME {\n                    dwLowDateTime: info.CreationTime as c::DWORD,\n                    dwHighDateTime: (info.CreationTime >> 32) as c::DWORD,\n                },\n                last_access_time: c::FILETIME {\n                    dwLowDateTime: info.LastAccessTime as c::DWORD,\n                    dwHighDateTime: (info.LastAccessTime >> 32) as c::DWORD,\n                },\n                last_write_time: c::FILETIME {\n                    dwLowDateTime: info.LastWriteTime as c::DWORD,\n                    dwHighDateTime: (info.LastWriteTime >> 32) as c::DWORD,\n                },\n                file_size: 0,\n                reparse_tag: 0,\n                volume_serial_number: None,\n                number_of_links: None,\n                file_index: None,\n            };\n            let mut info: c::FILE_STANDARD_INFO = mem::zeroed();\n            let size = mem::size_of_val(&info);\n            cvt(c::GetFileInformationByHandleEx(\n                self.handle.raw(),\n                c::FileStandardInfo,\n                &mut info as *mut _ as *mut libc::c_void,\n                size as c::DWORD,\n            ))?;\n            attr.file_size = info.AllocationSize as u64;\n            attr.number_of_links = Some(info.NumberOfLinks);\n            if attr.file_type().is_reparse_point() {\n                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n                if let Ok((_, buf)) = self.reparse_point(&mut b) {\n                    attr.reparse_tag = buf.ReparseTag;\n                }\n            }\n            Ok(attr)\n        }\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.handle.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.handle.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.handle.is_read_vectored()\n    }\n\n    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n        self.handle.read_at(buf, offset)\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.handle.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.handle.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.handle.is_write_vectored()\n    }\n\n    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n        self.handle.write_at(buf, offset)\n    }\n\n    pub fn flush(&self) -> io::Result<()> {\n        Ok(())\n    }\n\n    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n        let (whence, pos) = match pos {\n            // Casting to `i64` is fine, `SetFilePointerEx` reinterprets this\n            // integer as `u64`.\n            SeekFrom::Start(n) => (c::FILE_BEGIN, n as i64),\n            SeekFrom::End(n) => (c::FILE_END, n),\n            SeekFrom::Current(n) => (c::FILE_CURRENT, n),\n        };\n        let pos = pos as c::LARGE_INTEGER;\n        let mut newpos = 0;\n        cvt(unsafe { c::SetFilePointerEx(self.handle.raw(), pos, &mut newpos, whence) })?;\n        Ok(newpos as u64)\n    }\n\n    pub fn duplicate(&self) -> io::Result<File> {\n        Ok(File { handle: self.handle.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)? })\n    }\n\n    pub fn handle(&self) -> &Handle {\n        &self.handle\n    }\n\n    pub fn into_handle(self) -> Handle {\n        self.handle\n    }\n\n    fn reparse_point<'a>(\n        &self,\n        space: &'a mut [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE],\n    ) -> io::Result<(c::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n        unsafe {\n            let mut bytes = 0;\n            cvt({\n                c::DeviceIoControl(\n                    self.handle.raw(),\n                    c::FSCTL_GET_REPARSE_POINT,\n                    ptr::null_mut(),\n                    0,\n                    space.as_mut_ptr() as *mut _,\n                    space.len() as c::DWORD,\n                    &mut bytes,\n                    ptr::null_mut(),\n                )\n            })?;\n            Ok((bytes, &*(space.as_ptr() as *const c::REPARSE_DATA_BUFFER)))\n        }\n    }\n\n    fn readlink(&self) -> io::Result<PathBuf> {\n        let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n        let (_bytes, buf) = self.reparse_point(&mut space)?;\n        unsafe {\n            let (path_buffer, subst_off, subst_len, relative) = match buf.ReparseTag {\n                c::IO_REPARSE_TAG_SYMLINK => {\n                    let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n                        &buf.rest as *const _ as *const _;\n                    (\n                        &(*info).PathBuffer as *const _ as *const u16,\n                        (*info).SubstituteNameOffset / 2,\n                        (*info).SubstituteNameLength / 2,\n                        (*info).Flags & c::SYMLINK_FLAG_RELATIVE != 0,\n                    )\n                }\n                c::IO_REPARSE_TAG_MOUNT_POINT => {\n                    let info: *const c::MOUNT_POINT_REPARSE_BUFFER =\n                        &buf.rest as *const _ as *const _;\n                    (\n                        &(*info).PathBuffer as *const _ as *const u16,\n                        (*info).SubstituteNameOffset / 2,\n                        (*info).SubstituteNameLength / 2,\n                        false,\n                    )\n                }\n                _ => {\n                    return Err(io::Error::new_const(\n                        io::ErrorKind::Other,\n                        &\"Unsupported reparse point type\",\n                    ));\n                }\n            };\n            let subst_ptr = path_buffer.offset(subst_off as isize);\n            let mut subst = slice::from_raw_parts(subst_ptr, subst_len as usize);\n            // Absolute paths start with an NT internal namespace prefix `\\??\\`\n            // We should not let it leak through.\n            if !relative && subst.starts_with(&[92u16, 63u16, 63u16, 92u16]) {\n                subst = &subst[4..];\n            }\n            Ok(PathBuf::from(OsString::from_wide(subst)))\n        }\n    }\n\n    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n        let mut info = c::FILE_BASIC_INFO {\n            CreationTime: 0,\n            LastAccessTime: 0,\n            LastWriteTime: 0,\n            ChangeTime: 0,\n            FileAttributes: perm.attrs,\n        };\n        let size = mem::size_of_val(&info);\n        cvt(unsafe {\n            c::SetFileInformationByHandle(\n                self.handle.raw(),\n                c::FileBasicInfo,\n                &mut info as *mut _ as *mut _,\n                size as c::DWORD,\n            )\n        })?;\n        Ok(())\n    }\n}\n\nimpl FromInner<c::HANDLE> for File {\n    fn from_inner(handle: c::HANDLE) -> File {\n        File { handle: Handle::new(handle) }\n    }\n}\n\nimpl fmt::Debug for File {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // FIXME(#24570): add more info here (e.g., mode)\n        let mut b = f.debug_struct(\"File\");\n        b.field(\"handle\", &self.handle.raw());\n        if let Ok(path) = get_path(&self) {\n            b.field(\"path\", &path);\n        }\n        b.finish()\n    }\n}\n\nimpl FileAttr {\n    pub fn size(&self) -> u64 {\n        self.file_size\n    }\n\n    pub fn perm(&self) -> FilePermissions {\n        FilePermissions { attrs: self.attributes }\n    }\n\n    pub fn attrs(&self) -> u32 {\n        self.attributes\n    }\n\n    pub fn file_type(&self) -> FileType {\n        FileType::new(self.attributes, self.reparse_tag)\n    }\n\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(self.last_write_time))\n    }\n\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(self.last_access_time))\n    }\n\n    pub fn created(&self) -> io::Result<SystemTime> {\n        Ok(SystemTime::from(self.creation_time))\n    }\n\n    pub fn modified_u64(&self) -> u64 {\n        to_u64(&self.last_write_time)\n    }\n\n    pub fn accessed_u64(&self) -> u64 {\n        to_u64(&self.last_access_time)\n    }\n\n    pub fn created_u64(&self) -> u64 {\n        to_u64(&self.creation_time)\n    }\n\n    pub fn volume_serial_number(&self) -> Option<u32> {\n        self.volume_serial_number\n    }\n\n    pub fn number_of_links(&self) -> Option<u32> {\n        self.number_of_links\n    }\n\n    pub fn file_index(&self) -> Option<u64> {\n        self.file_index\n    }\n}\n\nfn to_u64(ft: &c::FILETIME) -> u64 {\n    (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32)\n}\n\nimpl FilePermissions {\n    pub fn readonly(&self) -> bool {\n        self.attrs & c::FILE_ATTRIBUTE_READONLY != 0\n    }\n\n    pub fn set_readonly(&mut self, readonly: bool) {\n        if readonly {\n            self.attrs |= c::FILE_ATTRIBUTE_READONLY;\n        } else {\n            self.attrs &= !c::FILE_ATTRIBUTE_READONLY;\n        }\n    }\n}\n\nimpl FileType {\n    fn new(attrs: c::DWORD, reparse_tag: c::DWORD) -> FileType {\n        FileType { attributes: attrs, reparse_tag: reparse_tag }\n    }\n    pub fn is_dir(&self) -> bool {\n        !self.is_symlink() && self.is_directory()\n    }\n    pub fn is_file(&self) -> bool {\n        !self.is_symlink() && !self.is_directory()\n    }\n    pub fn is_symlink(&self) -> bool {\n        self.is_reparse_point() && self.is_reparse_tag_name_surrogate()\n    }\n    pub fn is_symlink_dir(&self) -> bool {\n        self.is_symlink() && self.is_directory()\n    }\n    pub fn is_symlink_file(&self) -> bool {\n        self.is_symlink() && !self.is_directory()\n    }\n    fn is_directory(&self) -> bool {\n        self.attributes & c::FILE_ATTRIBUTE_DIRECTORY != 0\n    }\n    fn is_reparse_point(&self) -> bool {\n        self.attributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0\n    }\n    fn is_reparse_tag_name_surrogate(&self) -> bool {\n        self.reparse_tag & 0x20000000 != 0\n    }\n}\n\nimpl DirBuilder {\n    pub fn new() -> DirBuilder {\n        DirBuilder\n    }\n\n    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n        let p = to_u16s(p)?;\n        cvt(unsafe { c::CreateDirectoryW(p.as_ptr(), ptr::null_mut()) })?;\n        Ok(())\n    }\n}\n\npub fn readdir(p: &Path) -> io::Result<ReadDir> {\n    let root = p.to_path_buf();\n    let star = p.join(\"*\");\n    let path = to_u16s(&star)?;\n\n    unsafe {\n        let mut wfd = mem::zeroed();\n        let find_handle = c::FindFirstFileW(path.as_ptr(), &mut wfd);\n        if find_handle != c::INVALID_HANDLE_VALUE {\n            Ok(ReadDir {\n                handle: FindNextFileHandle(find_handle),\n                root: Arc::new(root),\n                first: Some(wfd),\n            })\n        } else {\n            Err(Error::last_os_error())\n        }\n    }\n}\n\npub fn unlink(p: &Path) -> io::Result<()> {\n    let p_u16s = to_u16s(p)?;\n    cvt(unsafe { c::DeleteFileW(p_u16s.as_ptr()) })?;\n    Ok(())\n}\n\npub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n    let old = to_u16s(old)?;\n    let new = to_u16s(new)?;\n    cvt(unsafe { c::MoveFileExW(old.as_ptr(), new.as_ptr(), c::MOVEFILE_REPLACE_EXISTING) })?;\n    Ok(())\n}\n\npub fn rmdir(p: &Path) -> io::Result<()> {\n    let p = to_u16s(p)?;\n    cvt(unsafe { c::RemoveDirectoryW(p.as_ptr()) })?;\n    Ok(())\n}\n\npub fn remove_dir_all(path: &Path) -> io::Result<()> {\n    let filetype = lstat(path)?.file_type();\n    if filetype.is_symlink() {\n        // On Windows symlinks to files and directories are removed differently.\n        // rmdir only deletes dir symlinks and junctions, not file symlinks.\n        rmdir(path)\n    } else {\n        remove_dir_all_recursive(path)\n    }\n}\n\nfn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n    for child in readdir(path)? {\n        let child = child?;\n        let child_type = child.file_type()?;\n        if child_type.is_dir() {\n            remove_dir_all_recursive(&child.path())?;\n        } else if child_type.is_symlink_dir() {\n            rmdir(&child.path())?;\n        } else {\n            unlink(&child.path())?;\n        }\n    }\n    rmdir(path)\n}\n\npub fn readlink(path: &Path) -> io::Result<PathBuf> {\n    // Open the link with no access mode, instead of generic read.\n    // By default FILE_LIST_DIRECTORY is denied for the junction \"C:\\Documents and Settings\", so\n    // this is needed for a common case.\n    let mut opts = OpenOptions::new();\n    opts.access_mode(0);\n    opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT | c::FILE_FLAG_BACKUP_SEMANTICS);\n    let file = File::open(&path, &opts)?;\n    file.readlink()\n}\n\npub fn symlink(original: &Path, link: &Path) -> io::Result<()> {\n    symlink_inner(original, link, false)\n}\n\npub fn symlink_inner(original: &Path, link: &Path, dir: bool) -> io::Result<()> {\n    let original = to_u16s(original)?;\n    let link = to_u16s(link)?;\n    let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n    // Formerly, symlink creation required the SeCreateSymbolicLink privilege. For the Windows 10\n    // Creators Update, Microsoft loosened this to allow unprivileged symlink creation if the\n    // computer is in Developer Mode, but SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE must be\n    // added to dwFlags to opt into this behaviour.\n    let result = cvt(unsafe {\n        c::CreateSymbolicLinkW(\n            link.as_ptr(),\n            original.as_ptr(),\n            flags | c::SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE,\n        ) as c::BOOL\n    });\n    if let Err(err) = result {\n        if err.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32) {\n            // Older Windows objects to SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE,\n            // so if we encounter ERROR_INVALID_PARAMETER, retry without that flag.\n            cvt(unsafe {\n                c::CreateSymbolicLinkW(link.as_ptr(), original.as_ptr(), flags) as c::BOOL\n            })?;\n        } else {\n            return Err(err);\n        }\n    }\n    Ok(())\n}\n\n#[cfg(not(target_vendor = \"uwp\"))]\npub fn link(original: &Path, link: &Path) -> io::Result<()> {\n    let original = to_u16s(original)?;\n    let link = to_u16s(link)?;\n    cvt(unsafe { c::CreateHardLinkW(link.as_ptr(), original.as_ptr(), ptr::null_mut()) })?;\n    Ok(())\n}\n\n#[cfg(target_vendor = \"uwp\")]\npub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n    return Err(io::Error::new_const(\n        io::ErrorKind::Unsupported,\n        &\"hard link are not supported on UWP\",\n    ));\n}\n\npub fn stat(path: &Path) -> io::Result<FileAttr> {\n    let mut opts = OpenOptions::new();\n    // No read or write permissions are necessary\n    opts.access_mode(0);\n    // This flag is so we can open directories too\n    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n    let file = File::open(path, &opts)?;\n    file.file_attr()\n}\n\npub fn lstat(path: &Path) -> io::Result<FileAttr> {\n    let mut opts = OpenOptions::new();\n    // No read or write permissions are necessary\n    opts.access_mode(0);\n    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | c::FILE_FLAG_OPEN_REPARSE_POINT);\n    let file = File::open(path, &opts)?;\n    file.file_attr()\n}\n\npub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n    let p = to_u16s(p)?;\n    unsafe {\n        cvt(c::SetFileAttributesW(p.as_ptr(), perm.attrs))?;\n        Ok(())\n    }\n}\n\nfn get_path(f: &File) -> io::Result<PathBuf> {\n    super::fill_utf16_buf(\n        |buf, sz| unsafe {\n            c::GetFinalPathNameByHandleW(f.handle.raw(), buf, sz, c::VOLUME_NAME_DOS)\n        },\n        |buf| PathBuf::from(OsString::from_wide(buf)),\n    )\n}\n\npub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n    let mut opts = OpenOptions::new();\n    // No read or write permissions are necessary\n    opts.access_mode(0);\n    // This flag is so we can open directories too\n    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n    let f = File::open(p, &opts)?;\n    get_path(&f)\n}\n\npub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n    unsafe extern \"system\" fn callback(\n        _TotalFileSize: c::LARGE_INTEGER,\n        _TotalBytesTransferred: c::LARGE_INTEGER,\n        _StreamSize: c::LARGE_INTEGER,\n        StreamBytesTransferred: c::LARGE_INTEGER,\n        dwStreamNumber: c::DWORD,\n        _dwCallbackReason: c::DWORD,\n        _hSourceFile: c::HANDLE,\n        _hDestinationFile: c::HANDLE,\n        lpData: c::LPVOID,\n    ) -> c::DWORD {\n        if dwStreamNumber == 1 {\n            *(lpData as *mut i64) = StreamBytesTransferred;\n        }\n        c::PROGRESS_CONTINUE\n    }\n    let pfrom = to_u16s(from)?;\n    let pto = to_u16s(to)?;\n    let mut size = 0i64;\n    cvt(unsafe {\n        c::CopyFileExW(\n            pfrom.as_ptr(),\n            pto.as_ptr(),\n            Some(callback),\n            &mut size as *mut _ as *mut _,\n            ptr::null_mut(),\n            0,\n        )\n    })?;\n    Ok(size as u64)\n}\n\n#[allow(dead_code)]\npub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(\n    original: P,\n    junction: Q,\n) -> io::Result<()> {\n    symlink_junction_inner(original.as_ref(), junction.as_ref())\n}\n\n// Creating a directory junction on windows involves dealing with reparse\n// points and the DeviceIoControl function, and this code is a skeleton of\n// what can be found here:\n//\n// http://www.flexhex.com/docs/articles/hard-links.phtml\n#[allow(dead_code)]\nfn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n    let d = DirBuilder::new();\n    d.mkdir(&junction)?;\n\n    let mut opts = OpenOptions::new();\n    opts.write(true);\n    opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT | c::FILE_FLAG_BACKUP_SEMANTICS);\n    let f = File::open(junction, &opts)?;\n    let h = f.handle().raw();\n\n    unsafe {\n        let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n        let db = data.as_mut_ptr() as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n        let buf = &mut (*db).ReparseTarget as *mut c::WCHAR;\n        let mut i = 0;\n        // FIXME: this conversion is very hacky\n        let v = br\"\\??\\\";\n        let v = v.iter().map(|x| *x as u16);\n        for c in v.chain(original.as_os_str().encode_wide()) {\n            *buf.offset(i) = c;\n            i += 1;\n        }\n        *buf.offset(i) = 0;\n        i += 1;\n        (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n        (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;\n        (*db).ReparseTargetLength = ((i - 1) * 2) as c::WORD;\n        (*db).ReparseDataLength = (*db).ReparseTargetLength as c::DWORD + 12;\n\n        let mut ret = 0;\n        cvt(c::DeviceIoControl(\n            h as *mut _,\n            c::FSCTL_SET_REPARSE_POINT,\n            data.as_ptr() as *mut _,\n            (*db).ReparseDataLength + 8,\n            ptr::null_mut(),\n            0,\n            &mut ret,\n            ptr::null_mut(),\n        ))\n        .map(drop)\n    }\n}\n\n// Try to see if a file exists but, unlike `exists`, report I/O errors.\npub fn try_exists(path: &Path) -> io::Result<bool> {\n    // Open the file to ensure any symlinks are followed to their target.\n    let mut opts = OpenOptions::new();\n    // No read, write, etc access rights are needed.\n    opts.access_mode(0);\n    // Backup semantics enables opening directories as well as files.\n    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n    match File::open(path, &opts) {\n        Err(e) => match e.kind() {\n            // The file definitely does not exist\n            io::ErrorKind::NotFound => Ok(false),\n\n            // `ERROR_SHARING_VIOLATION` means that the file has been locked by\n            // another process. This is often temporary so we simply report it\n            // as the file existing.\n            io::ErrorKind::Other if e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as i32) => {\n                Ok(true)\n            }\n            // Other errors such as `ERROR_ACCESS_DENIED` may indicate that the\n            // file exists. However, these types of errors are usually more\n            // permanent so we report them here.\n            _ => Err(e),\n        },\n        // The file was opened successfully therefore it must exist,\n        Ok(_) => Ok(true),\n    }\n}\n"],["2517","#![unstable(issue = \"none\", feature = \"windows_stdio\")]\n\nuse crate::io;\nuse crate::mem::ManuallyDrop;\nuse crate::sys::c;\nuse crate::sys::handle::Handle;\n\npub struct Stdin {}\npub struct Stdout;\npub struct Stderr;\n\nconst MAX_BUFFER_SIZE: usize = 8192;\npub const STDIN_BUF_SIZE: usize = MAX_BUFFER_SIZE / 2 * 3;\n\npub fn get_handle(handle_id: c::DWORD) -> io::Result<c::HANDLE> {\n    let handle = unsafe { c::GetStdHandle(handle_id) };\n    if handle == c::INVALID_HANDLE_VALUE {\n        Err(io::Error::last_os_error())\n    } else if handle.is_null() {\n        Err(io::Error::from_raw_os_error(c::ERROR_INVALID_HANDLE as i32))\n    } else {\n        Ok(handle)\n    }\n}\n\nfn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n    let handle = get_handle(handle_id)?;\n    let handle = Handle::new(handle);\n    ManuallyDrop::new(handle).write(data)\n}\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin {}\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let handle = get_handle(c::STD_INPUT_HANDLE)?;\n        let handle = Handle::new(handle);\n        ManuallyDrop::new(handle).read(buf)\n    }\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        write(c::STD_OUTPUT_HANDLE, buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        write(c::STD_ERROR_HANDLE, buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\npub fn is_ebadf(err: &io::Error) -> bool {\n    err.raw_os_error() == Some(c::ERROR_INVALID_HANDLE as i32)\n}\n\npub fn panic_output() -> Option<impl io::Write> {\n    Some(Stderr::new())\n}\n"],["2518","use crate::ffi::CStr;\nuse crate::io;\nuse crate::ptr;\nuse crate::sys::c;\nuse crate::sys::handle::Handle;\nuse crate::sys::stack_overflow;\nuse crate::time::Duration;\n\nuse libc::c_void;\n\nuse super::to_u16s;\n\npub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n\npub struct Thread {\n    handle: Handle,\n}\n\nimpl Thread {\n    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n        let p = Box::into_raw(box p);\n\n        // FIXME On UNIX, we guard against stack sizes that are too small but\n        // that's because pthreads enforces that stacks are at least\n        // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n        // just that below a certain threshold you can't do anything useful.\n        // That threshold is application and architecture-specific, however.\n        // Round up to the next 64 kB because that's what the NT kernel does,\n        // might as well make it explicit.\n        let stack_size = (stack + 0xfffe) & (!0xfffe);\n        let ret = c::CreateThread(\n            ptr::null_mut(),\n            stack_size,\n            thread_start,\n            p as *mut _,\n            c::STACK_SIZE_PARAM_IS_A_RESERVATION,\n            ptr::null_mut(),\n        );\n\n        return if ret as usize == 0 {\n            // The thread failed to start and as a result p was not consumed. Therefore, it is\n            // safe to reconstruct the box so that it gets deallocated.\n            drop(Box::from_raw(p));\n            Err(io::Error::last_os_error())\n        } else {\n            Ok(Thread { handle: Handle::new(ret) })\n        };\n\n        extern \"system\" fn thread_start(main: *mut c_void) -> c::DWORD {\n            unsafe {\n                // Next, set up our stack overflow handler which may get triggered if we run\n                // out of stack.\n                let _handler = stack_overflow::Handler::new();\n                // Finally, let's run some code.\n                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n            }\n            0\n        }\n    }\n\n    pub fn set_name(name: &CStr) {\n        if let Ok(utf8) = name.to_str() {\n            if let Ok(utf16) = to_u16s(utf8) {\n                unsafe {\n                    c::SetThreadDescription(c::GetCurrentThread(), utf16.as_ptr());\n                };\n            };\n        };\n    }\n\n    pub fn join(self) {\n        let rc = unsafe { c::WaitForSingleObject(self.handle.raw(), c::INFINITE) };\n        if rc == c::WAIT_FAILED {\n            panic!(\"failed to join on thread: {}\", io::Error::last_os_error());\n        }\n    }\n\n    pub fn yield_now() {\n        // This function will return 0 if there are no other threads to execute,\n        // but this also means that the yield was useless so this isn't really a\n        // case that needs to be worried about.\n        unsafe {\n            c::SwitchToThread();\n        }\n    }\n\n    pub fn sleep(dur: Duration) {\n        unsafe { c::Sleep(super::dur2timeout(dur)) }\n    }\n\n    pub fn handle(&self) -> &Handle {\n        &self.handle\n    }\n\n    pub fn into_handle(self) -> Handle {\n        self.handle\n    }\n}\n\n#[cfg_attr(test, allow(dead_code))]\npub mod guard {\n    pub type Guard = !;\n    pub unsafe fn current() -> Option<Guard> {\n        None\n    }\n    pub unsafe fn init() -> Option<Guard> {\n        None\n    }\n}\n"],["2519","#![cfg(not(test))]\n\nuse libc::{c_double, c_float};\n\nextern \"C\" {\n    pub fn acos(n: c_double) -> c_double;\n    pub fn asin(n: c_double) -> c_double;\n    pub fn atan(n: c_double) -> c_double;\n    pub fn atan2(a: c_double, b: c_double) -> c_double;\n    pub fn cbrt(n: c_double) -> c_double;\n    pub fn cbrtf(n: c_float) -> c_float;\n    pub fn cosh(n: c_double) -> c_double;\n    pub fn expm1(n: c_double) -> c_double;\n    pub fn expm1f(n: c_float) -> c_float;\n    pub fn fdim(a: c_double, b: c_double) -> c_double;\n    pub fn fdimf(a: c_float, b: c_float) -> c_float;\n    #[cfg_attr(target_env = \"msvc\", link_name = \"_hypot\")]\n    pub fn hypot(x: c_double, y: c_double) -> c_double;\n    #[cfg_attr(target_env = \"msvc\", link_name = \"_hypotf\")]\n    pub fn hypotf(x: c_float, y: c_float) -> c_float;\n    pub fn log1p(n: c_double) -> c_double;\n    pub fn log1pf(n: c_float) -> c_float;\n    pub fn sinh(n: c_double) -> c_double;\n    pub fn tan(n: c_double) -> c_double;\n    pub fn tanh(n: c_double) -> c_double;\n}\n\npub use self::shims::*;\n\n#[cfg(not(all(target_env = \"msvc\", target_arch = \"x86\")))]\nmod shims {\n    use libc::c_float;\n\n    extern \"C\" {\n        pub fn acosf(n: c_float) -> c_float;\n        pub fn asinf(n: c_float) -> c_float;\n        pub fn atan2f(a: c_float, b: c_float) -> c_float;\n        pub fn atanf(n: c_float) -> c_float;\n        pub fn coshf(n: c_float) -> c_float;\n        pub fn sinhf(n: c_float) -> c_float;\n        pub fn tanf(n: c_float) -> c_float;\n        pub fn tanhf(n: c_float) -> c_float;\n    }\n}\n\n// On 32-bit x86 MSVC these functions aren't defined, so we just define shims\n// which promote everything fo f64, perform the calculation, and then demote\n// back to f32. While not precisely correct should be \"correct enough\" for now.\n#[cfg(all(target_env = \"msvc\", target_arch = \"x86\"))]\nmod shims {\n    use libc::c_float;\n\n    #[inline]\n    pub unsafe fn acosf(n: c_float) -> c_float {\n        f64::acos(n as f64) as c_float\n    }\n\n    #[inline]\n    pub unsafe fn asinf(n: c_float) -> c_float {\n        f64::asin(n as f64) as c_float\n    }\n\n    #[inline]\n    pub unsafe fn atan2f(n: c_float, b: c_float) -> c_float {\n        f64::atan2(n as f64, b as f64) as c_float\n    }\n\n    #[inline]\n    pub unsafe fn atanf(n: c_float) -> c_float {\n        f64::atan(n as f64) as c_float\n    }\n\n    #[inline]\n    pub unsafe fn coshf(n: c_float) -> c_float {\n        f64::cosh(n as f64) as c_float\n    }\n\n    #[inline]\n    pub unsafe fn sinhf(n: c_float) -> c_float {\n        f64::sinh(n as f64) as c_float\n    }\n\n    #[inline]\n    pub unsafe fn tanf(n: c_float) -> c_float {\n        f64::tan(n as f64) as c_float\n    }\n\n    #[inline]\n    pub unsafe fn tanhf(n: c_float) -> c_float {\n        f64::tanh(n as f64) as c_float\n    }\n}\n"],["2520","use crate::io::Error;\nuse crate::sys::c;\n\n// tests `error_string` above\n#[test]\nfn ntstatus_error() {\n    const STATUS_UNSUCCESSFUL: u32 = 0xc000_0001;\n    assert!(\n        !Error::from_raw_os_error((STATUS_UNSUCCESSFUL | c::FACILITY_NT_BIT) as _)\n            .to_string()\n            .contains(\"FormatMessageW() returned error\")\n    );\n}\n"],["2521","//! Implementation of `std::os` functionality for Windows.\n\n#![allow(nonstandard_style)]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::os::windows::prelude::*;\n\nuse crate::error::Error as StdError;\nuse crate::ffi::{OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::os::windows::ffi::EncodeWide;\nuse crate::path::{self, PathBuf};\nuse crate::ptr;\nuse crate::slice;\nuse crate::sys::{c, cvt};\n\nuse super::to_u16s;\n\npub fn errno() -> i32 {\n    unsafe { c::GetLastError() as i32 }\n}\n\n/// Gets a detailed string description for the given error number.\npub fn error_string(mut errnum: i32) -> String {\n    // This value is calculated from the macro\n    // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n    let langId = 0x0800 as c::DWORD;\n\n    let mut buf = [0 as c::WCHAR; 2048];\n\n    unsafe {\n        let mut module = ptr::null_mut();\n        let mut flags = 0;\n\n        // NTSTATUS errors may be encoded as HRESULT, which may returned from\n        // GetLastError. For more information about Windows error codes, see\n        // `[MS-ERREF]`: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/0642cb2f-2075-4469-918c-4441e69c548a\n        if (errnum & c::FACILITY_NT_BIT as i32) != 0 {\n            // format according to https://support.microsoft.com/en-us/help/259693\n            const NTDLL_DLL: &[u16] = &[\n                'N' as _, 'T' as _, 'D' as _, 'L' as _, 'L' as _, '.' as _, 'D' as _, 'L' as _,\n                'L' as _, 0,\n            ];\n            module = c::GetModuleHandleW(NTDLL_DLL.as_ptr());\n\n            if !module.is_null() {\n                errnum ^= c::FACILITY_NT_BIT as i32;\n                flags = c::FORMAT_MESSAGE_FROM_HMODULE;\n            }\n        }\n\n        let res = c::FormatMessageW(\n            flags | c::FORMAT_MESSAGE_FROM_SYSTEM | c::FORMAT_MESSAGE_IGNORE_INSERTS,\n            module,\n            errnum as c::DWORD,\n            langId,\n            buf.as_mut_ptr(),\n            buf.len() as c::DWORD,\n            ptr::null(),\n        ) as usize;\n        if res == 0 {\n            // Sometimes FormatMessageW can fail e.g., system doesn't like langId,\n            let fm_err = errno();\n            return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n        }\n\n        match String::from_utf16(&buf[..res]) {\n            Ok(mut msg) => {\n                // Trim trailing CRLF inserted by FormatMessageW\n                let len = msg.trim_end().len();\n                msg.truncate(len);\n                msg\n            }\n            Err(..) => format!(\n                \"OS Error {} (FormatMessageW() returned \\\n                 invalid UTF-16)\",\n                errnum\n            ),\n        }\n    }\n}\n\npub struct Env {\n    base: c::LPWCH,\n    cur: c::LPWCH,\n}\n\nimpl Iterator for Env {\n    type Item = (OsString, OsString);\n\n    fn next(&mut self) -> Option<(OsString, OsString)> {\n        loop {\n            unsafe {\n                if *self.cur == 0 {\n                    return None;\n                }\n                let p = self.cur as *const u16;\n                let mut len = 0;\n                while *p.offset(len) != 0 {\n                    len += 1;\n                }\n                let s = slice::from_raw_parts(p, len as usize);\n                self.cur = self.cur.offset(len + 1);\n\n                // Windows allows environment variables to start with an equals\n                // symbol (in any other position, this is the separator between\n                // variable name and value). Since`s` has at least length 1 at\n                // this point (because the empty string terminates the array of\n                // environment variables), we can safely slice.\n                let pos = match s[1..].iter().position(|&u| u == b'=' as u16).map(|p| p + 1) {\n                    Some(p) => p,\n                    None => continue,\n                };\n                return Some((\n                    OsStringExt::from_wide(&s[..pos]),\n                    OsStringExt::from_wide(&s[pos + 1..]),\n                ));\n            }\n        }\n    }\n}\n\nimpl Drop for Env {\n    fn drop(&mut self) {\n        unsafe {\n            c::FreeEnvironmentStringsW(self.base);\n        }\n    }\n}\n\npub fn env() -> Env {\n    unsafe {\n        let ch = c::GetEnvironmentStringsW();\n        if ch as usize == 0 {\n            panic!(\"failure getting env string from OS: {}\", io::Error::last_os_error());\n        }\n        Env { base: ch, cur: ch }\n    }\n}\n\npub struct SplitPaths<'a> {\n    data: EncodeWide<'a>,\n    must_yield: bool,\n}\n\npub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {\n    SplitPaths { data: unparsed.encode_wide(), must_yield: true }\n}\n\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> {\n        // On Windows, the PATH environment variable is semicolon separated.\n        // Double quotes are used as a way of introducing literal semicolons\n        // (since c:\\some;dir is a valid Windows path). Double quotes are not\n        // themselves permitted in path names, so there is no way to escape a\n        // double quote.  Quoted regions can appear in arbitrary locations, so\n        //\n        //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n        //\n        // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n        //\n        // (The above is based on testing; there is no clear reference available\n        // for the grammar.)\n\n        let must_yield = self.must_yield;\n        self.must_yield = false;\n\n        let mut in_progress = Vec::new();\n        let mut in_quote = false;\n        for b in self.data.by_ref() {\n            if b == '\"' as u16 {\n                in_quote = !in_quote;\n            } else if b == ';' as u16 && !in_quote {\n                self.must_yield = true;\n                break;\n            } else {\n                in_progress.push(b)\n            }\n        }\n\n        if !must_yield && in_progress.is_empty() {\n            None\n        } else {\n            Some(super::os2path(&in_progress))\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct JoinPathsError;\n\npub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: Iterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n    let mut joined = Vec::new();\n    let sep = b';' as u16;\n\n    for (i, path) in paths.enumerate() {\n        let path = path.as_ref();\n        if i > 0 {\n            joined.push(sep)\n        }\n        let v = path.encode_wide().collect::<Vec<u16>>();\n        if v.contains(&(b'\"' as u16)) {\n            return Err(JoinPathsError);\n        } else if v.contains(&sep) {\n            joined.push(b'\"' as u16);\n            joined.extend_from_slice(&v[..]);\n            joined.push(b'\"' as u16);\n        } else {\n            joined.extend_from_slice(&v[..]);\n        }\n    }\n\n    Ok(OsStringExt::from_wide(&joined[..]))\n}\n\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        \"path segment contains `\\\"`\".fmt(f)\n    }\n}\n\nimpl StdError for JoinPathsError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"failed to join paths\"\n    }\n}\n\npub fn current_exe() -> io::Result<PathBuf> {\n    super::fill_utf16_buf(\n        |buf, sz| unsafe { c::GetModuleFileNameW(ptr::null_mut(), buf, sz) },\n        super::os2path,\n    )\n}\n\npub fn getcwd() -> io::Result<PathBuf> {\n    super::fill_utf16_buf(|buf, sz| unsafe { c::GetCurrentDirectoryW(sz, buf) }, super::os2path)\n}\n\npub fn chdir(p: &path::Path) -> io::Result<()> {\n    let p: &OsStr = p.as_ref();\n    let mut p = p.encode_wide().collect::<Vec<_>>();\n    p.push(0);\n\n    cvt(unsafe { c::SetCurrentDirectoryW(p.as_ptr()) }).map(drop)\n}\n\npub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n    let k = to_u16s(k)?;\n    let res = super::fill_utf16_buf(\n        |buf, sz| unsafe { c::GetEnvironmentVariableW(k.as_ptr(), buf, sz) },\n        |buf| OsStringExt::from_wide(buf),\n    );\n    match res {\n        Ok(value) => Ok(Some(value)),\n        Err(e) => {\n            if e.raw_os_error() == Some(c::ERROR_ENVVAR_NOT_FOUND as i32) {\n                Ok(None)\n            } else {\n                Err(e)\n            }\n        }\n    }\n}\n\npub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n    let k = to_u16s(k)?;\n    let v = to_u16s(v)?;\n\n    cvt(unsafe { c::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr()) }).map(drop)\n}\n\npub fn unsetenv(n: &OsStr) -> io::Result<()> {\n    let v = to_u16s(n)?;\n    cvt(unsafe { c::SetEnvironmentVariableW(v.as_ptr(), ptr::null()) }).map(drop)\n}\n\npub fn temp_dir() -> PathBuf {\n    super::fill_utf16_buf(|buf, sz| unsafe { c::GetTempPathW(sz, buf) }, super::os2path).unwrap()\n}\n\n#[cfg(not(target_vendor = \"uwp\"))]\nfn home_dir_crt() -> Option<PathBuf> {\n    unsafe {\n        use crate::sys::handle::Handle;\n\n        let me = c::GetCurrentProcess();\n        let mut token = ptr::null_mut();\n        if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {\n            return None;\n        }\n        let _handle = Handle::new(token);\n        super::fill_utf16_buf(\n            |buf, mut sz| {\n                match c::GetUserProfileDirectoryW(token, buf, &mut sz) {\n                    0 if c::GetLastError() != c::ERROR_INSUFFICIENT_BUFFER => 0,\n                    0 => sz,\n                    _ => sz - 1, // sz includes the null terminator\n                }\n            },\n            super::os2path,\n        )\n        .ok()\n    }\n}\n\n#[cfg(target_vendor = \"uwp\")]\nfn home_dir_crt() -> Option<PathBuf> {\n    None\n}\n\npub fn home_dir() -> Option<PathBuf> {\n    crate::env::var_os(\"HOME\")\n        .or_else(|| crate::env::var_os(\"USERPROFILE\"))\n        .map(PathBuf::from)\n        .or_else(|| home_dir_crt())\n}\n\npub fn exit(code: i32) -> ! {\n    unsafe { c::ExitProcess(code as c::UINT) }\n}\n\npub fn getpid() -> u32 {\n    unsafe { c::GetCurrentProcessId() as u32 }\n}\n"],["2522","pub mod os {\n    pub const FAMILY: &str = \"windows\";\n    pub const OS: &str = \"windows\";\n    pub const DLL_PREFIX: &str = \"\";\n    pub const DLL_SUFFIX: &str = \".dll\";\n    pub const DLL_EXTENSION: &str = \"dll\";\n    pub const EXE_SUFFIX: &str = \".exe\";\n    pub const EXE_EXTENSION: &str = \"exe\";\n}\n"],["2523","#![unstable(issue = \"none\", feature = \"windows_net\")]\n\nuse crate::cmp;\nuse crate::io::{self, IoSlice, IoSliceMut, Read};\nuse crate::mem;\nuse crate::net::{Shutdown, SocketAddr};\nuse crate::ptr;\nuse crate::sync::Once;\nuse crate::sys;\nuse crate::sys::c;\nuse crate::sys_common::net;\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\nuse crate::time::Duration;\n\nuse libc::{c_int, c_long, c_ulong};\n\npub type wrlen_t = i32;\n\npub mod netc {\n    pub use crate::sys::c::ADDRESS_FAMILY as sa_family_t;\n    pub use crate::sys::c::ADDRINFOA as addrinfo;\n    pub use crate::sys::c::SOCKADDR as sockaddr;\n    pub use crate::sys::c::SOCKADDR_STORAGE_LH as sockaddr_storage;\n    pub use crate::sys::c::*;\n}\n\npub struct Socket(c::SOCKET);\n\nstatic INIT: Once = Once::new();\n\n/// Checks whether the Windows socket interface has been started already, and\n/// if not, starts it.\npub fn init() {\n    INIT.call_once(|| unsafe {\n        let mut data: c::WSADATA = mem::zeroed();\n        let ret = c::WSAStartup(\n            0x202, // version 2.2\n            &mut data,\n        );\n        assert_eq!(ret, 0);\n    });\n}\n\npub fn cleanup() {\n    if INIT.is_completed() {\n        // only close the socket interface if it has actually been started\n        unsafe {\n            c::WSACleanup();\n        }\n    }\n}\n\n/// Returns the last error from the Windows socket interface.\nfn last_error() -> io::Error {\n    io::Error::from_raw_os_error(unsafe { c::WSAGetLastError() })\n}\n\n#[doc(hidden)]\npub trait IsMinusOne {\n    fn is_minus_one(&self) -> bool;\n}\n\nmacro_rules! impl_is_minus_one {\n    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n        fn is_minus_one(&self) -> bool {\n            *self == -1\n        }\n    })*)\n}\n\nimpl_is_minus_one! { i8 i16 i32 i64 isize }\n\n/// Checks if the signed integer is the Windows constant `SOCKET_ERROR` (-1)\n/// and if so, returns the last error from the Windows socket interface. This\n/// function must be called before another call to the socket API is made.\npub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n    if t.is_minus_one() { Err(last_error()) } else { Ok(t) }\n}\n\n/// A variant of `cvt` for `getaddrinfo` which return 0 for a success.\npub fn cvt_gai(err: c_int) -> io::Result<()> {\n    if err == 0 { Ok(()) } else { Err(last_error()) }\n}\n\n/// Just to provide the same interface as sys/unix/net.rs\npub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\nwhere\n    T: IsMinusOne,\n    F: FnMut() -> T,\n{\n    cvt(f())\n}\n\nimpl Socket {\n    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n        let family = match *addr {\n            SocketAddr::V4(..) => c::AF_INET,\n            SocketAddr::V6(..) => c::AF_INET6,\n        };\n        let socket = unsafe {\n            c::WSASocketW(\n                family,\n                ty,\n                0,\n                ptr::null_mut(),\n                0,\n                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n            )\n        };\n\n        if socket != c::INVALID_SOCKET {\n            Ok(Self(socket))\n        } else {\n            let error = unsafe { c::WSAGetLastError() };\n\n            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n                return Err(io::Error::from_raw_os_error(error));\n            }\n\n            let socket =\n                unsafe { c::WSASocketW(family, ty, 0, ptr::null_mut(), 0, c::WSA_FLAG_OVERLAPPED) };\n\n            if socket == c::INVALID_SOCKET {\n                return Err(last_error());\n            }\n\n            let socket = Self(socket);\n            socket.set_no_inherit()?;\n            Ok(socket)\n        }\n    }\n\n    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n        self.set_nonblocking(true)?;\n        let result = {\n            let (addrp, len) = addr.into_inner();\n            let result = unsafe { c::connect(self.0, addrp, len) };\n            cvt(result).map(drop)\n        };\n        self.set_nonblocking(false)?;\n\n        match result {\n            Err(ref error) if error.kind() == io::ErrorKind::WouldBlock => {\n                if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n                    return Err(io::Error::new_const(\n                        io::ErrorKind::InvalidInput,\n                        &\"cannot set a 0 duration timeout\",\n                    ));\n                }\n\n                let mut timeout = c::timeval {\n                    tv_sec: timeout.as_secs() as c_long,\n                    tv_usec: (timeout.subsec_nanos() / 1000) as c_long,\n                };\n\n                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n                    timeout.tv_usec = 1;\n                }\n\n                let fds = {\n                    let mut fds = unsafe { mem::zeroed::<c::fd_set>() };\n                    fds.fd_count = 1;\n                    fds.fd_array[0] = self.0;\n                    fds\n                };\n\n                let mut writefds = fds;\n                let mut errorfds = fds;\n\n                let count = {\n                    let result = unsafe {\n                        c::select(1, ptr::null_mut(), &mut writefds, &mut errorfds, &timeout)\n                    };\n                    cvt(result)?\n                };\n\n                match count {\n                    0 => {\n                        Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\"))\n                    }\n                    _ => {\n                        if writefds.fd_count != 1 {\n                            if let Some(e) = self.take_error()? {\n                                return Err(e);\n                            }\n                        }\n\n                        Ok(())\n                    }\n                }\n            }\n            _ => result,\n        }\n    }\n\n    pub fn accept(&self, storage: *mut c::SOCKADDR, len: *mut c_int) -> io::Result<Socket> {\n        let socket = unsafe { c::accept(self.0, storage, len) };\n\n        match socket {\n            c::INVALID_SOCKET => Err(last_error()),\n            _ => Ok(Self(socket)),\n        }\n    }\n\n    pub fn duplicate(&self) -> io::Result<Socket> {\n        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n        let result = unsafe { c::WSADuplicateSocketW(self.0, c::GetCurrentProcessId(), &mut info) };\n        cvt(result)?;\n        let socket = unsafe {\n            c::WSASocketW(\n                info.iAddressFamily,\n                info.iSocketType,\n                info.iProtocol,\n                &mut info,\n                0,\n                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n            )\n        };\n\n        if socket != c::INVALID_SOCKET {\n            Ok(Self(socket))\n        } else {\n            let error = unsafe { c::WSAGetLastError() };\n\n            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n                return Err(io::Error::from_raw_os_error(error));\n            }\n\n            let socket = unsafe {\n                c::WSASocketW(\n                    info.iAddressFamily,\n                    info.iSocketType,\n                    info.iProtocol,\n                    &mut info,\n                    0,\n                    c::WSA_FLAG_OVERLAPPED,\n                )\n            };\n\n            if socket == c::INVALID_SOCKET {\n                return Err(last_error());\n            }\n\n            let socket = Self(socket);\n            socket.set_no_inherit()?;\n            Ok(socket)\n        }\n    }\n\n    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n        // On unix when a socket is shut down all further reads return 0, so we\n        // do the same on windows to map a shut down socket to returning EOF.\n        let length = cmp::min(buf.len(), i32::MAX as usize) as i32;\n        let result = unsafe { c::recv(self.0, buf.as_mut_ptr() as *mut _, length, flags) };\n\n        match result {\n            c::SOCKET_ERROR => {\n                let error = unsafe { c::WSAGetLastError() };\n\n                if error == c::WSAESHUTDOWN {\n                    Ok(0)\n                } else {\n                    Err(io::Error::from_raw_os_error(error))\n                }\n            }\n            _ => Ok(result as usize),\n        }\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.recv_with_flags(buf, 0)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        // On unix when a socket is shut down all further reads return 0, so we\n        // do the same on windows to map a shut down socket to returning EOF.\n        let length = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n        let mut nread = 0;\n        let mut flags = 0;\n        let result = unsafe {\n            c::WSARecv(\n                self.0,\n                bufs.as_mut_ptr() as *mut c::WSABUF,\n                length,\n                &mut nread,\n                &mut flags,\n                ptr::null_mut(),\n                ptr::null_mut(),\n            )\n        };\n\n        match result {\n            0 => Ok(nread as usize),\n            _ => {\n                let error = unsafe { c::WSAGetLastError() };\n\n                if error == c::WSAESHUTDOWN {\n                    Ok(0)\n                } else {\n                    Err(io::Error::from_raw_os_error(error))\n                }\n            }\n        }\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.recv_with_flags(buf, c::MSG_PEEK)\n    }\n\n    fn recv_from_with_flags(\n        &self,\n        buf: &mut [u8],\n        flags: c_int,\n    ) -> io::Result<(usize, SocketAddr)> {\n        let mut storage = unsafe { mem::zeroed::<c::SOCKADDR_STORAGE_LH>() };\n        let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n        let length = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n\n        // On unix when a socket is shut down all further reads return 0, so we\n        // do the same on windows to map a shut down socket to returning EOF.\n        let result = unsafe {\n            c::recvfrom(\n                self.0,\n                buf.as_mut_ptr() as *mut _,\n                length,\n                flags,\n                &mut storage as *mut _ as *mut _,\n                &mut addrlen,\n            )\n        };\n\n        match result {\n            c::SOCKET_ERROR => {\n                let error = unsafe { c::WSAGetLastError() };\n\n                if error == c::WSAESHUTDOWN {\n                    Ok((0, net::sockaddr_to_addr(&storage, addrlen as usize)?))\n                } else {\n                    Err(io::Error::from_raw_os_error(error))\n                }\n            }\n            _ => Ok((result as usize, net::sockaddr_to_addr(&storage, addrlen as usize)?)),\n        }\n    }\n\n    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.recv_from_with_flags(buf, 0)\n    }\n\n    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.recv_from_with_flags(buf, c::MSG_PEEK)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let length = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n        let mut nwritten = 0;\n        let result = unsafe {\n            c::WSASend(\n                self.0,\n                bufs.as_ptr() as *const c::WSABUF as *mut _,\n                length,\n                &mut nwritten,\n                0,\n                ptr::null_mut(),\n                ptr::null_mut(),\n            )\n        };\n        cvt(result).map(|_| nwritten as usize)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    pub fn set_timeout(&self, dur: Option<Duration>, kind: c_int) -> io::Result<()> {\n        let timeout = match dur {\n            Some(dur) => {\n                let timeout = sys::dur2timeout(dur);\n                if timeout == 0 {\n                    return Err(io::Error::new_const(\n                        io::ErrorKind::InvalidInput,\n                        &\"cannot set a 0 duration timeout\",\n                    ));\n                }\n                timeout\n            }\n            None => 0,\n        };\n        net::setsockopt(self, c::SOL_SOCKET, kind, timeout)\n    }\n\n    pub fn timeout(&self, kind: c_int) -> io::Result<Option<Duration>> {\n        let raw: c::DWORD = net::getsockopt(self, c::SOL_SOCKET, kind)?;\n        if raw == 0 {\n            Ok(None)\n        } else {\n            let secs = raw / 1000;\n            let nsec = (raw % 1000) * 1000000;\n            Ok(Some(Duration::new(secs as u64, nsec as u32)))\n        }\n    }\n\n    #[cfg(not(target_vendor = \"uwp\"))]\n    fn set_no_inherit(&self) -> io::Result<()> {\n        sys::cvt(unsafe { c::SetHandleInformation(self.0 as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0) })\n            .map(drop)\n    }\n\n    #[cfg(target_vendor = \"uwp\")]\n    fn set_no_inherit(&self) -> io::Result<()> {\n        Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Unavailable on UWP\"))\n    }\n\n    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n        let how = match how {\n            Shutdown::Write => c::SD_SEND,\n            Shutdown::Read => c::SD_RECEIVE,\n            Shutdown::Both => c::SD_BOTH,\n        };\n        let result = unsafe { c::shutdown(self.0, how) };\n        cvt(result).map(drop)\n    }\n\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n        let mut nonblocking = nonblocking as c_ulong;\n        let result = unsafe { c::ioctlsocket(self.0, c::FIONBIO as c_int, &mut nonblocking) };\n        cvt(result).map(drop)\n    }\n\n    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n        net::setsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY, nodelay as c::BYTE)\n    }\n\n    pub fn nodelay(&self) -> io::Result<bool> {\n        let raw: c::BYTE = net::getsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY)?;\n        Ok(raw != 0)\n    }\n\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        let raw: c_int = net::getsockopt(self, c::SOL_SOCKET, c::SO_ERROR)?;\n        if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n    }\n}\n\n#[unstable(reason = \"not public\", issue = \"none\", feature = \"fd_read\")]\nimpl<'a> Read for &'a Socket {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n}\n\nimpl Drop for Socket {\n    fn drop(&mut self) {\n        let _ = unsafe { c::closesocket(self.0) };\n    }\n}\n\nimpl AsInner<c::SOCKET> for Socket {\n    fn as_inner(&self) -> &c::SOCKET {\n        &self.0\n    }\n}\n\nimpl FromInner<c::SOCKET> for Socket {\n    fn from_inner(sock: c::SOCKET) -> Socket {\n        Socket(sock)\n    }\n}\n\nimpl IntoInner<c::SOCKET> for Socket {\n    fn into_inner(self) -> c::SOCKET {\n        let ret = self.0;\n        mem::forget(self);\n        ret\n    }\n}\n"],["2524","#![allow(missing_docs, nonstandard_style)]\n\nuse crate::ffi::{OsStr, OsString};\nuse crate::io::ErrorKind;\nuse crate::os::windows::ffi::{OsStrExt, OsStringExt};\nuse crate::path::PathBuf;\nuse crate::time::Duration;\n\npub use self::rand::hashmap_random_keys;\npub use libc::strlen;\n\n#[macro_use]\npub mod compat;\n\npub mod alloc;\npub mod args;\npub mod c;\npub mod cmath;\npub mod condvar;\npub mod env;\npub mod fs;\npub mod handle;\npub mod io;\npub mod memchr;\npub mod mutex;\npub mod net;\npub mod os;\npub mod os_str;\npub mod path;\npub mod pipe;\npub mod process;\npub mod rand;\npub mod rwlock;\npub mod thread;\npub mod thread_local_dtor;\npub mod thread_local_key;\npub mod thread_parker;\npub mod time;\ncfg_if::cfg_if! {\n    if #[cfg(not(target_vendor = \"uwp\"))] {\n        pub mod stdio;\n        pub mod stack_overflow;\n    } else {\n        pub mod stdio_uwp;\n        pub mod stack_overflow_uwp;\n        pub use self::stdio_uwp as stdio;\n        pub use self::stack_overflow_uwp as stack_overflow;\n    }\n}\n\n// SAFETY: must be called only once during runtime initialization.\n// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\npub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n    stack_overflow::init();\n}\n\n// SAFETY: must be called only once during runtime cleanup.\n// NOTE: this is not guaranteed to run, for example when the program aborts.\npub unsafe fn cleanup() {\n    net::cleanup();\n}\n\npub fn decode_error_kind(errno: i32) -> ErrorKind {\n    match errno as c::DWORD {\n        c::ERROR_ACCESS_DENIED => return ErrorKind::PermissionDenied,\n        c::ERROR_ALREADY_EXISTS => return ErrorKind::AlreadyExists,\n        c::ERROR_FILE_EXISTS => return ErrorKind::AlreadyExists,\n        c::ERROR_BROKEN_PIPE => return ErrorKind::BrokenPipe,\n        c::ERROR_FILE_NOT_FOUND => return ErrorKind::NotFound,\n        c::ERROR_PATH_NOT_FOUND => return ErrorKind::NotFound,\n        c::ERROR_NO_DATA => return ErrorKind::BrokenPipe,\n        c::ERROR_INVALID_PARAMETER => return ErrorKind::InvalidInput,\n        c::ERROR_NOT_ENOUGH_MEMORY | c::ERROR_OUTOFMEMORY => return ErrorKind::OutOfMemory,\n        c::ERROR_SEM_TIMEOUT\n        | c::WAIT_TIMEOUT\n        | c::ERROR_DRIVER_CANCEL_TIMEOUT\n        | c::ERROR_OPERATION_ABORTED\n        | c::ERROR_SERVICE_REQUEST_TIMEOUT\n        | c::ERROR_COUNTER_TIMEOUT\n        | c::ERROR_TIMEOUT\n        | c::ERROR_RESOURCE_CALL_TIMED_OUT\n        | c::ERROR_CTX_MODEM_RESPONSE_TIMEOUT\n        | c::ERROR_CTX_CLIENT_QUERY_TIMEOUT\n        | c::FRS_ERR_SYSVOL_POPULATE_TIMEOUT\n        | c::ERROR_DS_TIMELIMIT_EXCEEDED\n        | c::DNS_ERROR_RECORD_TIMED_OUT\n        | c::ERROR_IPSEC_IKE_TIMED_OUT\n        | c::ERROR_RUNLEVEL_SWITCH_TIMEOUT\n        | c::ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT => return ErrorKind::TimedOut,\n        c::ERROR_CALL_NOT_IMPLEMENTED => return ErrorKind::Unsupported,\n        _ => {}\n    }\n\n    match errno {\n        c::WSAEACCES => ErrorKind::PermissionDenied,\n        c::WSAEADDRINUSE => ErrorKind::AddrInUse,\n        c::WSAEADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n        c::WSAECONNABORTED => ErrorKind::ConnectionAborted,\n        c::WSAECONNREFUSED => ErrorKind::ConnectionRefused,\n        c::WSAECONNRESET => ErrorKind::ConnectionReset,\n        c::WSAEINVAL => ErrorKind::InvalidInput,\n        c::WSAENOTCONN => ErrorKind::NotConnected,\n        c::WSAEWOULDBLOCK => ErrorKind::WouldBlock,\n        c::WSAETIMEDOUT => ErrorKind::TimedOut,\n\n        _ => ErrorKind::Other,\n    }\n}\n\npub fn unrolled_find_u16s(needle: u16, haystack: &[u16]) -> Option<usize> {\n    let ptr = haystack.as_ptr();\n    let mut start = &haystack[..];\n\n    // For performance reasons unfold the loop eight times.\n    while start.len() >= 8 {\n        macro_rules! if_return {\n            ($($n:literal,)+) => {\n                $(\n                    if start[$n] == needle {\n                        return Some((&start[$n] as *const u16 as usize - ptr as usize) / 2);\n                    }\n                )+\n            }\n        }\n\n        if_return!(0, 1, 2, 3, 4, 5, 6, 7,);\n\n        start = &start[8..];\n    }\n\n    for c in start {\n        if *c == needle {\n            return Some((c as *const u16 as usize - ptr as usize) / 2);\n        }\n    }\n    None\n}\n\npub fn to_u16s<S: AsRef<OsStr>>(s: S) -> crate::io::Result<Vec<u16>> {\n    fn inner(s: &OsStr) -> crate::io::Result<Vec<u16>> {\n        let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n        if unrolled_find_u16s(0, &maybe_result).is_some() {\n            return Err(crate::io::Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"strings passed to WinAPI cannot contain NULs\",\n            ));\n        }\n        maybe_result.push(0);\n        Ok(maybe_result)\n    }\n    inner(s.as_ref())\n}\n\n// Many Windows APIs follow a pattern of where we hand a buffer and then they\n// will report back to us how large the buffer should be or how many bytes\n// currently reside in the buffer. This function is an abstraction over these\n// functions by making them easier to call.\n//\n// The first callback, `f1`, is yielded a (pointer, len) pair which can be\n// passed to a syscall. The `ptr` is valid for `len` items (u16 in this case).\n// The closure is expected to return what the syscall returns which will be\n// interpreted by this function to determine if the syscall needs to be invoked\n// again (with more buffer space).\n//\n// Once the syscall has completed (errors bail out early) the second closure is\n// yielded the data which has been read from the syscall. The return value\n// from this closure is then the return value of the function.\nfn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> crate::io::Result<T>\nwhere\n    F1: FnMut(*mut u16, c::DWORD) -> c::DWORD,\n    F2: FnOnce(&[u16]) -> T,\n{\n    // Start off with a stack buf but then spill over to the heap if we end up\n    // needing more space.\n    let mut stack_buf = [0u16; 512];\n    let mut heap_buf = Vec::new();\n    unsafe {\n        let mut n = stack_buf.len();\n        loop {\n            let buf = if n <= stack_buf.len() {\n                &mut stack_buf[..]\n            } else {\n                let extra = n - heap_buf.len();\n                heap_buf.reserve(extra);\n                heap_buf.set_len(n);\n                &mut heap_buf[..]\n            };\n\n            // This function is typically called on windows API functions which\n            // will return the correct length of the string, but these functions\n            // also return the `0` on error. In some cases, however, the\n            // returned \"correct length\" may actually be 0!\n            //\n            // To handle this case we call `SetLastError` to reset it to 0 and\n            // then check it again if we get the \"0 error value\". If the \"last\n            // error\" is still 0 then we interpret it as a 0 length buffer and\n            // not an actual error.\n            c::SetLastError(0);\n            let k = match f1(buf.as_mut_ptr(), n as c::DWORD) {\n                0 if c::GetLastError() == 0 => 0,\n                0 => return Err(crate::io::Error::last_os_error()),\n                n => n,\n            } as usize;\n            if k == n && c::GetLastError() == c::ERROR_INSUFFICIENT_BUFFER {\n                n *= 2;\n            } else if k >= n {\n                n = k;\n            } else {\n                return Ok(f2(&buf[..k]));\n            }\n        }\n    }\n}\n\nfn os2path(s: &[u16]) -> PathBuf {\n    PathBuf::from(OsString::from_wide(s))\n}\n\npub fn truncate_utf16_at_nul(v: &[u16]) -> &[u16] {\n    match unrolled_find_u16s(0, v) {\n        // don't include the 0\n        Some(i) => &v[..i],\n        None => v,\n    }\n}\n\npub trait IsZero {\n    fn is_zero(&self) -> bool;\n}\n\nmacro_rules! impl_is_zero {\n    ($($t:ident)*) => ($(impl IsZero for $t {\n        fn is_zero(&self) -> bool {\n            *self == 0\n        }\n    })*)\n}\n\nimpl_is_zero! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n\npub fn cvt<I: IsZero>(i: I) -> crate::io::Result<I> {\n    if i.is_zero() { Err(crate::io::Error::last_os_error()) } else { Ok(i) }\n}\n\npub fn dur2timeout(dur: Duration) -> c::DWORD {\n    // Note that a duration is a (u64, u32) (seconds, nanoseconds) pair, and the\n    // timeouts in windows APIs are typically u32 milliseconds. To translate, we\n    // have two pieces to take care of:\n    //\n    // * Nanosecond precision is rounded up\n    // * Greater than u32::MAX milliseconds (50 days) is rounded up to INFINITE\n    //   (never time out).\n    dur.as_secs()\n        .checked_mul(1000)\n        .and_then(|ms| ms.checked_add((dur.subsec_nanos() as u64) / 1_000_000))\n        .and_then(|ms| ms.checked_add(if dur.subsec_nanos() % 1_000_000 > 0 { 1 } else { 0 }))\n        .map(|ms| if ms > <c::DWORD>::MAX as u64 { c::INFINITE } else { ms as c::DWORD })\n        .unwrap_or(c::INFINITE)\n}\n\n/// Use `__fastfail` to abort the process\n///\n/// This is the same implementation as in libpanic_abort's `__rust_start_panic`. See\n/// that function for more information on `__fastfail`\n#[allow(unreachable_code)]\npub fn abort_internal() -> ! {\n    const FAST_FAIL_FATAL_APP_EXIT: usize = 7;\n    unsafe {\n        cfg_if::cfg_if! {\n            if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n                asm!(\"int $$0x29\", in(\"ecx\") FAST_FAIL_FATAL_APP_EXIT);\n                crate::intrinsics::unreachable();\n            } else if #[cfg(all(target_arch = \"arm\", target_feature = \"thumb-mode\"))] {\n                asm!(\".inst 0xDEFB\", in(\"r0\") FAST_FAIL_FATAL_APP_EXIT);\n                crate::intrinsics::unreachable();\n            } else if #[cfg(target_arch = \"aarch64\")] {\n                asm!(\"brk 0xF003\", in(\"x0\") FAST_FAIL_FATAL_APP_EXIT);\n                crate::intrinsics::unreachable();\n            }\n        }\n    }\n    crate::intrinsics::abort();\n}\n"],["2525","#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n#![cfg(target_thread_local)]\n\npub use crate::sys_common::thread_local_dtor::register_dtor_fallback as register_dtor;\n"],["2526","#![allow(dead_code)] // runtime init functions not used during testing\n\n#[cfg(test)]\nmod tests;\n\nuse crate::ffi::OsString;\nuse crate::fmt;\nuse crate::os::windows::prelude::*;\nuse crate::path::PathBuf;\nuse crate::slice;\nuse crate::sys::c;\nuse crate::sys::windows::os::current_exe;\nuse crate::vec;\n\nuse core::iter;\n\npub fn args() -> Args {\n    unsafe {\n        let lp_cmd_line = c::GetCommandLineW();\n        let parsed_args_list = parse_lp_cmd_line(lp_cmd_line as *const u16, || {\n            current_exe().map(PathBuf::into_os_string).unwrap_or_else(|_| OsString::new())\n        });\n\n        Args { parsed_args_list: parsed_args_list.into_iter() }\n    }\n}\n\n/// Implements the Windows command-line argument parsing algorithm.\n///\n/// Microsoft's documentation for the Windows CLI argument format can be found at\n/// <https://docs.microsoft.com/en-us/previous-versions//17w5ykft(v=vs.85)>.\n///\n/// Windows includes a function to do this in shell32.dll,\n/// but linking with that DLL causes the process to be registered as a GUI application.\n/// GUI applications add a bunch of overhead, even if no windows are drawn. See\n/// <https://randomascii.wordpress.com/2018/12/03/a-not-called-function-can-cause-a-5x-slowdown/>.\n///\n/// This function was tested for equivalence to the shell32.dll implementation in\n/// Windows 10 Pro v1803, using an exhaustive test suite available at\n/// <https://gist.github.com/notriddle/dde431930c392e428055b2dc22e638f5> or\n/// <https://paste.gg/p/anonymous/47d6ed5f5bd549168b1c69c799825223>.\nunsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(\n    lp_cmd_line: *const u16,\n    exe_name: F,\n) -> Vec<OsString> {\n    const BACKSLASH: u16 = '\\\\' as u16;\n    const QUOTE: u16 = '\"' as u16;\n    const TAB: u16 = '\\t' as u16;\n    const SPACE: u16 = ' ' as u16;\n    let mut ret_val = Vec::new();\n    if lp_cmd_line.is_null() || *lp_cmd_line == 0 {\n        ret_val.push(exe_name());\n        return ret_val;\n    }\n    let mut cmd_line = {\n        let mut end = 0;\n        while *lp_cmd_line.offset(end) != 0 {\n            end += 1;\n        }\n        slice::from_raw_parts(lp_cmd_line, end as usize)\n    };\n    // The executable name at the beginning is special.\n    cmd_line = match cmd_line[0] {\n        // The executable name ends at the next quote mark,\n        // no matter what.\n        QUOTE => {\n            let args = {\n                let mut cut = cmd_line[1..].splitn(2, |&c| c == QUOTE);\n                if let Some(exe) = cut.next() {\n                    ret_val.push(OsString::from_wide(exe));\n                }\n                cut.next()\n            };\n            if let Some(args) = args {\n                args\n            } else {\n                return ret_val;\n            }\n        }\n        // Implement quirk: when they say whitespace here,\n        // they include the entire ASCII control plane:\n        // \"However, if lpCmdLine starts with any amount of whitespace, CommandLineToArgvW\n        // will consider the first argument to be an empty string. Excess whitespace at the\n        // end of lpCmdLine is ignored.\"\n        0..=SPACE => {\n            ret_val.push(OsString::new());\n            &cmd_line[1..]\n        }\n        // The executable name ends at the next whitespace,\n        // no matter what.\n        _ => {\n            let args = {\n                let mut cut = cmd_line.splitn(2, |&c| c > 0 && c <= SPACE);\n                if let Some(exe) = cut.next() {\n                    ret_val.push(OsString::from_wide(exe));\n                }\n                cut.next()\n            };\n            if let Some(args) = args {\n                args\n            } else {\n                return ret_val;\n            }\n        }\n    };\n    let mut cur = Vec::new();\n    let mut in_quotes = false;\n    let mut was_in_quotes = false;\n    let mut backslash_count: usize = 0;\n    for &c in cmd_line {\n        match c {\n            // backslash\n            BACKSLASH => {\n                backslash_count += 1;\n                was_in_quotes = false;\n            }\n            QUOTE if backslash_count % 2 == 0 => {\n                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n                backslash_count = 0;\n                if was_in_quotes {\n                    cur.push('\"' as u16);\n                    was_in_quotes = false;\n                } else {\n                    was_in_quotes = in_quotes;\n                    in_quotes = !in_quotes;\n                }\n            }\n            QUOTE if backslash_count % 2 != 0 => {\n                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n                backslash_count = 0;\n                was_in_quotes = false;\n                cur.push(b'\"' as u16);\n            }\n            SPACE | TAB if !in_quotes => {\n                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n                if !cur.is_empty() || was_in_quotes {\n                    ret_val.push(OsString::from_wide(&cur[..]));\n                    cur.truncate(0);\n                }\n                backslash_count = 0;\n                was_in_quotes = false;\n            }\n            _ => {\n                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n                backslash_count = 0;\n                was_in_quotes = false;\n                cur.push(c);\n            }\n        }\n    }\n    cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n    // include empty quoted strings at the end of the arguments list\n    if !cur.is_empty() || was_in_quotes || in_quotes {\n        ret_val.push(OsString::from_wide(&cur[..]));\n    }\n    ret_val\n}\n\npub struct Args {\n    parsed_args_list: vec::IntoIter<OsString>,\n}\n\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.parsed_args_list.as_slice().fmt(f)\n    }\n}\n\nimpl Iterator for Args {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> {\n        self.parsed_args_list.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.parsed_args_list.size_hint()\n    }\n}\n\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<OsString> {\n        self.parsed_args_list.next_back()\n    }\n}\n\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize {\n        self.parsed_args_list.len()\n    }\n}\n"],["2527","use crate::cmp::Ordering;\nuse crate::convert::TryInto;\nuse crate::fmt;\nuse crate::mem;\nuse crate::sys::c;\nuse crate::time::Duration;\n\nuse core::hash::{Hash, Hasher};\n\nconst NANOS_PER_SEC: u64 = 1_000_000_000;\nconst INTERVALS_PER_SEC: u64 = NANOS_PER_SEC / 100;\n\n#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\npub struct Instant {\n    // This duration is relative to an arbitrary microsecond epoch\n    // from the winapi QueryPerformanceCounter function.\n    t: Duration,\n}\n\n#[derive(Copy, Clone)]\npub struct SystemTime {\n    t: c::FILETIME,\n}\n\nconst INTERVALS_TO_UNIX_EPOCH: u64 = 11_644_473_600 * INTERVALS_PER_SEC;\n\npub const UNIX_EPOCH: SystemTime = SystemTime {\n    t: c::FILETIME {\n        dwLowDateTime: INTERVALS_TO_UNIX_EPOCH as u32,\n        dwHighDateTime: (INTERVALS_TO_UNIX_EPOCH >> 32) as u32,\n    },\n};\n\nimpl Instant {\n    pub fn now() -> Instant {\n        // High precision timing on windows operates in \"Performance Counter\"\n        // units, as returned by the WINAPI QueryPerformanceCounter function.\n        // These relate to seconds by a factor of QueryPerformanceFrequency.\n        // In order to keep unit conversions out of normal interval math, we\n        // measure in QPC units and immediately convert to nanoseconds.\n        perf_counter::PerformanceCounterInstant::now().into()\n    }\n\n    pub fn actually_monotonic() -> bool {\n        false\n    }\n\n    pub const fn zero() -> Instant {\n        Instant { t: Duration::from_secs(0) }\n    }\n\n    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n        // On windows there's a threshold below which we consider two timestamps\n        // equivalent due to measurement error. For more details + doc link,\n        // check the docs on epsilon.\n        let epsilon = perf_counter::PerformanceCounterInstant::epsilon();\n        if other.t > self.t && other.t - self.t <= epsilon {\n            Some(Duration::new(0, 0))\n        } else {\n            self.t.checked_sub(other.t)\n        }\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant { t: self.t.checked_add(*other)? })\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n        Some(Instant { t: self.t.checked_sub(*other)? })\n    }\n}\n\nimpl SystemTime {\n    pub fn now() -> SystemTime {\n        unsafe {\n            let mut t: SystemTime = mem::zeroed();\n            c::GetSystemTimePreciseAsFileTime(&mut t.t);\n            t\n        }\n    }\n\n    fn from_intervals(intervals: i64) -> SystemTime {\n        SystemTime {\n            t: c::FILETIME {\n                dwLowDateTime: intervals as c::DWORD,\n                dwHighDateTime: (intervals >> 32) as c::DWORD,\n            },\n        }\n    }\n\n    fn intervals(&self) -> i64 {\n        (self.t.dwLowDateTime as i64) | ((self.t.dwHighDateTime as i64) << 32)\n    }\n\n    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n        let me = self.intervals();\n        let other = other.intervals();\n        if me >= other {\n            Ok(intervals2dur((me - other) as u64))\n        } else {\n            Err(intervals2dur((other - me) as u64))\n        }\n    }\n\n    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n        let intervals = self.intervals().checked_add(checked_dur2intervals(other)?)?;\n        Some(SystemTime::from_intervals(intervals))\n    }\n\n    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n        let intervals = self.intervals().checked_sub(checked_dur2intervals(other)?)?;\n        Some(SystemTime::from_intervals(intervals))\n    }\n}\n\nimpl PartialEq for SystemTime {\n    fn eq(&self, other: &SystemTime) -> bool {\n        self.intervals() == other.intervals()\n    }\n}\n\nimpl Eq for SystemTime {}\n\nimpl PartialOrd for SystemTime {\n    fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for SystemTime {\n    fn cmp(&self, other: &SystemTime) -> Ordering {\n        self.intervals().cmp(&other.intervals())\n    }\n}\n\nimpl fmt::Debug for SystemTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"SystemTime\").field(\"intervals\", &self.intervals()).finish()\n    }\n}\n\nimpl From<c::FILETIME> for SystemTime {\n    fn from(t: c::FILETIME) -> SystemTime {\n        SystemTime { t }\n    }\n}\n\nimpl Hash for SystemTime {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.intervals().hash(state)\n    }\n}\n\nfn checked_dur2intervals(dur: &Duration) -> Option<i64> {\n    dur.as_secs()\n        .checked_mul(INTERVALS_PER_SEC)?\n        .checked_add(dur.subsec_nanos() as u64 / 100)?\n        .try_into()\n        .ok()\n}\n\nfn intervals2dur(intervals: u64) -> Duration {\n    Duration::new(intervals / INTERVALS_PER_SEC, ((intervals % INTERVALS_PER_SEC) * 100) as u32)\n}\n\nmod perf_counter {\n    use super::NANOS_PER_SEC;\n    use crate::sync::atomic::{AtomicU64, Ordering};\n    use crate::sys::c;\n    use crate::sys::cvt;\n    use crate::sys_common::mul_div_u64;\n    use crate::time::Duration;\n\n    pub struct PerformanceCounterInstant {\n        ts: c::LARGE_INTEGER,\n    }\n    impl PerformanceCounterInstant {\n        pub fn now() -> Self {\n            Self { ts: query() }\n        }\n\n        // Per microsoft docs, the margin of error for cross-thread time comparisons\n        // using QueryPerformanceCounter is 1 \"tick\" -- defined as 1/frequency().\n        // Reference: https://docs.microsoft.com/en-us/windows/desktop/SysInfo\n        //                   /acquiring-high-resolution-time-stamps\n        pub fn epsilon() -> Duration {\n            let epsilon = NANOS_PER_SEC / (frequency() as u64);\n            Duration::from_nanos(epsilon)\n        }\n    }\n    impl From<PerformanceCounterInstant> for super::Instant {\n        fn from(other: PerformanceCounterInstant) -> Self {\n            let freq = frequency() as u64;\n            let instant_nsec = mul_div_u64(other.ts as u64, NANOS_PER_SEC, freq);\n            Self { t: Duration::from_nanos(instant_nsec) }\n        }\n    }\n\n    fn frequency() -> c::LARGE_INTEGER {\n        // Either the cached result of `QueryPerformanceFrequency` or `0` for\n        // uninitialized. Storing this as a single `AtomicU64` allows us to use\n        // `Relaxed` operations, as we are only interested in the effects on a\n        // single memory location.\n        static FREQUENCY: AtomicU64 = AtomicU64::new(0);\n\n        let cached = FREQUENCY.load(Ordering::Relaxed);\n        // If a previous thread has filled in this global state, use that.\n        if cached != 0 {\n            return cached as c::LARGE_INTEGER;\n        }\n        // ... otherwise learn for ourselves ...\n        let mut frequency = 0;\n        unsafe {\n            cvt(c::QueryPerformanceFrequency(&mut frequency)).unwrap();\n        }\n\n        FREQUENCY.store(frequency as u64, Ordering::Relaxed);\n        frequency\n    }\n\n    fn query() -> c::LARGE_INTEGER {\n        let mut qpc_value: c::LARGE_INTEGER = 0;\n        cvt(unsafe { c::QueryPerformanceCounter(&mut qpc_value) }).unwrap();\n        qpc_value\n    }\n}\n"],["2528","use super::{Header, MIN_ALIGN};\nuse crate::mem;\n\n#[test]\nfn alloc_header() {\n    // Header must fit in the padding before an aligned pointer\n    assert!(mem::size_of::<Header>() <= MIN_ALIGN);\n    assert!(mem::align_of::<Header>() <= MIN_ALIGN);\n}\n"],["2529","#![cfg_attr(test, allow(dead_code))]\n\nuse crate::sys::c;\nuse crate::thread;\n\npub struct Handler;\n\nimpl Handler {\n    pub unsafe fn new() -> Handler {\n        // This API isn't available on XP, so don't panic in that case and just\n        // pray it works out ok.\n        if c::SetThreadStackGuarantee(&mut 0x5000) == 0 {\n            if c::GetLastError() as u32 != c::ERROR_CALL_NOT_IMPLEMENTED as u32 {\n                panic!(\"failed to reserve stack space for exception handling\");\n            }\n        }\n        Handler\n    }\n}\n\nextern \"system\" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS) -> c::LONG {\n    unsafe {\n        let rec = &(*(*ExceptionInfo).ExceptionRecord);\n        let code = rec.ExceptionCode;\n\n        if code == c::EXCEPTION_STACK_OVERFLOW {\n            rtprintpanic!(\n                \"\\nthread '{}' has overflowed its stack\\n\",\n                thread::current().name().unwrap_or(\"<unknown>\")\n            );\n        }\n        c::EXCEPTION_CONTINUE_SEARCH\n    }\n}\n\npub unsafe fn init() {\n    if c::AddVectoredExceptionHandler(0, vectored_handler).is_null() {\n        panic!(\"failed to install exception handler\");\n    }\n    // Set the thread stack guarantee for the main thread.\n    let _h = Handler::new();\n}\n"],["2530","#![unstable(issue = \"none\", feature = \"windows_handle\")]\n\nuse crate::cmp;\nuse crate::io::{self, ErrorKind, IoSlice, IoSliceMut, Read};\nuse crate::mem;\nuse crate::ops::Deref;\nuse crate::ptr;\nuse crate::sys::c;\nuse crate::sys::cvt;\n\n/// An owned container for `HANDLE` object, closing them on Drop.\n///\n/// All methods are inherited through a `Deref` impl to `RawHandle`\npub struct Handle(RawHandle);\n\n/// A wrapper type for `HANDLE` objects to give them proper Send/Sync inference\n/// as well as Rust-y methods.\n///\n/// This does **not** drop the handle when it goes out of scope, use `Handle`\n/// instead for that.\n#[derive(Copy, Clone)]\npub struct RawHandle(c::HANDLE);\n\nunsafe impl Send for RawHandle {}\nunsafe impl Sync for RawHandle {}\n\nimpl Handle {\n    pub fn new(handle: c::HANDLE) -> Handle {\n        Handle(RawHandle::new(handle))\n    }\n\n    pub fn new_event(manual: bool, init: bool) -> io::Result<Handle> {\n        unsafe {\n            let event =\n                c::CreateEventW(ptr::null_mut(), manual as c::BOOL, init as c::BOOL, ptr::null());\n            if event.is_null() { Err(io::Error::last_os_error()) } else { Ok(Handle::new(event)) }\n        }\n    }\n\n    pub fn into_raw(self) -> c::HANDLE {\n        let ret = self.raw();\n        mem::forget(self);\n        ret\n    }\n}\n\nimpl Deref for Handle {\n    type Target = RawHandle;\n    fn deref(&self) -> &RawHandle {\n        &self.0\n    }\n}\n\nimpl Drop for Handle {\n    fn drop(&mut self) {\n        unsafe {\n            let _ = c::CloseHandle(self.raw());\n        }\n    }\n}\n\nimpl RawHandle {\n    pub fn new(handle: c::HANDLE) -> RawHandle {\n        RawHandle(handle)\n    }\n\n    pub fn raw(&self) -> c::HANDLE {\n        self.0\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        let mut read = 0;\n        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n        let res = cvt(unsafe {\n            c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID, len, &mut read, ptr::null_mut())\n        });\n\n        match res {\n            Ok(_) => Ok(read as usize),\n\n            // The special treatment of BrokenPipe is to deal with Windows\n            // pipe semantics, which yields this error when *reading* from\n            // a pipe after the other end has closed; we interpret that as\n            // EOF on the pipe.\n            Err(ref e) if e.kind() == ErrorKind::BrokenPipe => Ok(0),\n\n            Err(e) => Err(e),\n        }\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        crate::io::default_read_vectored(|buf| self.read(buf), bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        false\n    }\n\n    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n        let mut read = 0;\n        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n        let res = unsafe {\n            let mut overlapped: c::OVERLAPPED = mem::zeroed();\n            overlapped.Offset = offset as u32;\n            overlapped.OffsetHigh = (offset >> 32) as u32;\n            cvt(c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID, len, &mut read, &mut overlapped))\n        };\n        match res {\n            Ok(_) => Ok(read as usize),\n            Err(ref e) if e.raw_os_error() == Some(c::ERROR_HANDLE_EOF as i32) => Ok(0),\n            Err(e) => Err(e),\n        }\n    }\n\n    pub unsafe fn read_overlapped(\n        &self,\n        buf: &mut [u8],\n        overlapped: *mut c::OVERLAPPED,\n    ) -> io::Result<Option<usize>> {\n        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n        let mut amt = 0;\n        let res = cvt(c::ReadFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, overlapped));\n        match res {\n            Ok(_) => Ok(Some(amt as usize)),\n            Err(e) => {\n                if e.raw_os_error() == Some(c::ERROR_IO_PENDING as i32) {\n                    Ok(None)\n                } else if e.raw_os_error() == Some(c::ERROR_BROKEN_PIPE as i32) {\n                    Ok(Some(0))\n                } else {\n                    Err(e)\n                }\n            }\n        }\n    }\n\n    pub fn overlapped_result(\n        &self,\n        overlapped: *mut c::OVERLAPPED,\n        wait: bool,\n    ) -> io::Result<usize> {\n        unsafe {\n            let mut bytes = 0;\n            let wait = if wait { c::TRUE } else { c::FALSE };\n            let res = cvt(c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait));\n            match res {\n                Ok(_) => Ok(bytes as usize),\n                Err(e) => {\n                    if e.raw_os_error() == Some(c::ERROR_HANDLE_EOF as i32)\n                        || e.raw_os_error() == Some(c::ERROR_BROKEN_PIPE as i32)\n                    {\n                        Ok(0)\n                    } else {\n                        Err(e)\n                    }\n                }\n            }\n        }\n    }\n\n    pub fn cancel_io(&self) -> io::Result<()> {\n        unsafe { cvt(c::CancelIo(self.raw())).map(drop) }\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        let mut amt = 0;\n        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n        cvt(unsafe {\n            c::WriteFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, ptr::null_mut())\n        })?;\n        Ok(amt as usize)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        crate::io::default_write_vectored(|buf| self.write(buf), bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        false\n    }\n\n    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n        let mut written = 0;\n        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n        unsafe {\n            let mut overlapped: c::OVERLAPPED = mem::zeroed();\n            overlapped.Offset = offset as u32;\n            overlapped.OffsetHigh = (offset >> 32) as u32;\n            cvt(c::WriteFile(\n                self.0,\n                buf.as_ptr() as c::LPVOID,\n                len,\n                &mut written,\n                &mut overlapped,\n            ))?;\n        }\n        Ok(written as usize)\n    }\n\n    pub fn duplicate(\n        &self,\n        access: c::DWORD,\n        inherit: bool,\n        options: c::DWORD,\n    ) -> io::Result<Handle> {\n        let mut ret = 0 as c::HANDLE;\n        cvt(unsafe {\n            let cur_proc = c::GetCurrentProcess();\n            c::DuplicateHandle(\n                cur_proc,\n                self.0,\n                cur_proc,\n                &mut ret,\n                access,\n                inherit as c::BOOL,\n                options,\n            )\n        })?;\n        Ok(Handle::new(ret))\n    }\n}\n\nimpl<'a> Read for &'a RawHandle {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        (**self).read_vectored(bufs)\n    }\n}\n"],["2531","// Original implementation taken from rust-memchr.\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\n// Fallback memchr is fastest on Windows.\npub use core::slice::memchr::{memchr, memrchr};\n"],["2532","use crate::ffi::OsString;\nuse crate::sys::windows::args::*;\n\nfn chk(string: &str, parts: &[&str]) {\n    let mut wide: Vec<u16> = OsString::from(string).encode_wide().collect();\n    wide.push(0);\n    let parsed =\n        unsafe { parse_lp_cmd_line(wide.as_ptr() as *const u16, || OsString::from(\"TEST.EXE\")) };\n    let expected: Vec<OsString> = parts.iter().map(|k| OsString::from(k)).collect();\n    assert_eq!(parsed.as_slice(), expected.as_slice());\n}\n\n#[test]\nfn empty() {\n    chk(\"\", &[\"TEST.EXE\"]);\n    chk(\"\\0\", &[\"TEST.EXE\"]);\n}\n\n#[test]\nfn single_words() {\n    chk(\"EXE one_word\", &[\"EXE\", \"one_word\"]);\n    chk(\"EXE a\", &[\"EXE\", \"a\"]);\n    chk(\"EXE \", &[\"EXE\", \"\"]);\n    chk(\"EXE \", &[\"EXE\", \"\"]);\n}\n\n#[test]\nfn official_examples() {\n    chk(r#\"EXE \"abc\" d e\"#, &[\"EXE\", \"abc\", \"d\", \"e\"]);\n    chk(r#\"EXE a\\\\\\b d\"e f\"g h\"#, &[\"EXE\", r#\"a\\\\\\b\"#, \"de fg\", \"h\"]);\n    chk(r#\"EXE a\\\\\\\"b c d\"#, &[\"EXE\", r#\"a\\\"b\"#, \"c\", \"d\"]);\n    chk(r#\"EXE a\\\\\\\\\"b c\" d e\"#, &[\"EXE\", r#\"a\\\\b c\"#, \"d\", \"e\"]);\n}\n\n#[test]\nfn whitespace_behavior() {\n    chk(r#\" test\"#, &[\"\", \"test\"]);\n    chk(r#\"  test\"#, &[\"\", \"test\"]);\n    chk(r#\" test test2\"#, &[\"\", \"test\", \"test2\"]);\n    chk(r#\" test  test2\"#, &[\"\", \"test\", \"test2\"]);\n    chk(r#\"test test2 \"#, &[\"test\", \"test2\"]);\n    chk(r#\"test  test2 \"#, &[\"test\", \"test2\"]);\n    chk(r#\"test \"#, &[\"test\"]);\n}\n\n#[test]\nfn genius_quotes() {\n    chk(r#\"EXE \"\" \"\"\"#, &[\"EXE\", \"\", \"\"]);\n    chk(r#\"EXE \"\" \"\"\"\"#, &[\"EXE\", \"\", \"\\\"\"]);\n    chk(\n        r#\"EXE \"this is \"\"\"all\"\"\" in the same argument\"\"#,\n        &[\"EXE\", \"this is \\\"all\\\" in the same argument\"],\n    );\n    chk(r#\"EXE \"a\"\"\"#, &[\"EXE\", \"a\\\"\"]);\n    chk(r#\"EXE \"a\"\" a\"#, &[\"EXE\", \"a\\\"\", \"a\"]);\n    // quotes cannot be escaped in command names\n    chk(r#\"\"EXE\" check\"#, &[\"EXE\", \"check\"]);\n    chk(r#\"\"EXE check\"\"#, &[\"EXE check\"]);\n    chk(r#\"\"EXE \"\"\"for\"\"\" check\"#, &[\"EXE \", r#\"for\"\"#, \"check\"]);\n    chk(r#\"\"EXE \\\"for\\\" check\"#, &[r#\"EXE \\\"#, r#\"for\"\"#, \"check\"]);\n}\n"],["2533","// Thread parker implementation for Windows.\n//\n// This uses WaitOnAddress and WakeByAddressSingle if available (Windows 8+).\n// This modern API is exactly the same as the futex syscalls the Linux thread\n// parker uses. When These APIs are available, the implementation of this\n// thread parker matches the Linux thread parker exactly.\n//\n// However, when the modern API is not available, this implementation falls\n// back to NT Keyed Events, which are similar, but have some important\n// differences. These are available since Windows XP.\n//\n// WaitOnAddress first checks the state of the thread parker to make sure it no\n// WakeByAddressSingle calls can be missed between updating the parker state\n// and calling the function.\n//\n// NtWaitForKeyedEvent does not have this option, and unconditionally blocks\n// without checking the parker state first. Instead, NtReleaseKeyedEvent\n// (unlike WakeByAddressSingle) *blocks* until it woke up a thread waiting for\n// it by NtWaitForKeyedEvent. This way, we can be sure no events are missed,\n// but we need to be careful not to block unpark() if park_timeout() was woken\n// up by a timeout instead of unpark().\n//\n// Unlike WaitOnAddress, NtWaitForKeyedEvent/NtReleaseKeyedEvent operate on a\n// HANDLE (created with NtCreateKeyedEvent). This means that we can be sure\n// a succesfully awoken park() was awoken by unpark() and not a\n// NtReleaseKeyedEvent call from some other code, as these events are not only\n// matched by the key (address of the parker (state)), but also by this HANDLE.\n// We lazily allocate this handle the first time it is needed.\n//\n// The fast path (calling park() after unpark() was already called) and the\n// possible states are the same for both implementations. This is used here to\n// make sure the fast path does not even check which API to use, but can return\n// right away, independent of the used API. Only the slow paths (which will\n// actually block/wake a thread) check which API is available and have\n// different implementations.\n//\n// Unfortunately, NT Keyed Events are an undocumented Windows API. However:\n// - This API is relatively simple with obvious behaviour, and there are\n//   several (unofficial) articles documenting the details. [1]\n// - `parking_lot` has been using this API for years (on Windows versions\n//   before Windows 8). [2] Many big projects extensively use parking_lot,\n//   such as servo and the Rust compiler itself.\n// - It is the underlying API used by Windows SRW locks and Windows critical\n//   sections. [3] [4]\n// - The source code of the implementations of Wine, ReactOs, and Windows XP\n//   are available and match the expected behaviour.\n// - The main risk with an undocumented API is that it might change in the\n//   future. But since we only use it for older versions of Windows, that's not\n//   a problem.\n// - Even if these functions do not block or wake as we expect (which is\n//   unlikely, see all previous points), this implementation would still be\n//   memory safe. The NT Keyed Events API is only used to sleep/block in the\n//   right place.\n//\n// [1]: http://www.locklessinc.com/articles/keyed_events/\n// [2]: https://github.com/Amanieu/parking_lot/commit/43abbc964e\n// [3]: https://docs.microsoft.com/en-us/archive/msdn-magazine/2012/november/windows-with-c-the-evolution-of-synchronization-in-windows-and-c\n// [4]: Windows Internals, Part 1, ISBN 9780735671300\n\nuse crate::convert::TryFrom;\nuse crate::ptr;\nuse crate::sync::atomic::{\n    AtomicI8, AtomicUsize,\n    Ordering::{Acquire, Relaxed, Release},\n};\nuse crate::sys::{c, dur2timeout};\nuse crate::time::Duration;\n\npub struct Parker {\n    state: AtomicI8,\n}\n\nconst PARKED: i8 = -1;\nconst EMPTY: i8 = 0;\nconst NOTIFIED: i8 = 1;\n\n// Notes about memory ordering:\n//\n// Memory ordering is only relevant for the relative ordering of operations\n// between different variables. Even Ordering::Relaxed guarantees a\n// monotonic/consistent order when looking at just a single atomic variable.\n//\n// So, since this parker is just a single atomic variable, we only need to look\n// at the ordering guarantees we need to provide to the 'outside world'.\n//\n// The only memory ordering guarantee that parking and unparking provide, is\n// that things which happened before unpark() are visible on the thread\n// returning from park() afterwards. Otherwise, it was effectively unparked\n// before unpark() was called while still consuming the 'token'.\n//\n// In other words, unpark() needs to synchronize with the part of park() that\n// consumes the token and returns.\n//\n// This is done with a release-acquire synchronization, by using\n// Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using\n// Ordering::Acquire when reading this state in park() after waking up.\nimpl Parker {\n    pub fn new() -> Self {\n        Self { state: AtomicI8::new(EMPTY) }\n    }\n\n    // Assumes this is only called by the thread that owns the Parker,\n    // which means that `self.state != PARKED`.\n    pub unsafe fn park(&self) {\n        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n        // first case.\n        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n            return;\n        }\n\n        if let Some(wait_on_address) = c::WaitOnAddress::option() {\n            loop {\n                // Wait for something to happen, assuming it's still set to PARKED.\n                wait_on_address(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, c::INFINITE);\n                // Change NOTIFIED=>EMPTY but leave PARKED alone.\n                if self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Acquire).is_ok() {\n                    // Actually woken up by unpark().\n                    return;\n                } else {\n                    // Spurious wake up. We loop to try again.\n                }\n            }\n        } else {\n            // Wait for unpark() to produce this event.\n            c::NtWaitForKeyedEvent(keyed_event_handle(), self.ptr(), 0, ptr::null_mut());\n            // Set the state back to EMPTY (from either PARKED or NOTIFIED).\n            // Note that we don't just write EMPTY, but use swap() to also\n            // include an acquire-ordered read to synchronize with unpark()'s\n            // release-ordered write.\n            self.state.swap(EMPTY, Acquire);\n        }\n    }\n\n    // Assumes this is only called by the thread that owns the Parker,\n    // which means that `self.state != PARKED`.\n    pub unsafe fn park_timeout(&self, timeout: Duration) {\n        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n        // first case.\n        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n            return;\n        }\n\n        if let Some(wait_on_address) = c::WaitOnAddress::option() {\n            // Wait for something to happen, assuming it's still set to PARKED.\n            wait_on_address(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, dur2timeout(timeout));\n            // Set the state back to EMPTY (from either PARKED or NOTIFIED).\n            // Note that we don't just write EMPTY, but use swap() to also\n            // include an acquire-ordered read to synchronize with unpark()'s\n            // release-ordered write.\n            if self.state.swap(EMPTY, Acquire) == NOTIFIED {\n                // Actually woken up by unpark().\n            } else {\n                // Timeout or spurious wake up.\n                // We return either way, because we can't easily tell if it was the\n                // timeout or not.\n            }\n        } else {\n            // Need to wait for unpark() using NtWaitForKeyedEvent.\n            let handle = keyed_event_handle();\n\n            // NtWaitForKeyedEvent uses a unit of 100ns, and uses negative\n            // values to indicate a relative time on the monotonic clock.\n            // This is documented here for the underlying KeWaitForSingleObject function:\n            // https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kewaitforsingleobject\n            let mut timeout = match i64::try_from((timeout.as_nanos() + 99) / 100) {\n                Ok(t) => -t,\n                Err(_) => i64::MIN,\n            };\n\n            // Wait for unpark() to produce this event.\n            let unparked =\n                c::NtWaitForKeyedEvent(handle, self.ptr(), 0, &mut timeout) == c::STATUS_SUCCESS;\n\n            // Set the state back to EMPTY (from either PARKED or NOTIFIED).\n            let prev_state = self.state.swap(EMPTY, Acquire);\n\n            if !unparked && prev_state == NOTIFIED {\n                // We were awoken by a timeout, not by unpark(), but the state\n                // was set to NOTIFIED, which means we *just* missed an\n                // unpark(), which is now blocked on us to wait for it.\n                // Wait for it to consume the event and unblock that thread.\n                c::NtWaitForKeyedEvent(handle, self.ptr(), 0, ptr::null_mut());\n            }\n        }\n    }\n\n    pub fn unpark(&self) {\n        // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n        // wake the thread in the first case.\n        //\n        // Note that even NOTIFIED=>NOTIFIED results in a write. This is on\n        // purpose, to make sure every unpark() has a release-acquire ordering\n        // with park().\n        if self.state.swap(NOTIFIED, Release) == PARKED {\n            if let Some(wake_by_address_single) = c::WakeByAddressSingle::option() {\n                unsafe {\n                    wake_by_address_single(self.ptr());\n                }\n            } else {\n                // If we run NtReleaseKeyedEvent before the waiting thread runs\n                // NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.\n                // If the waiting thread wakes up before we run NtReleaseKeyedEvent\n                // (e.g. due to a timeout), this blocks until we do wake up a thread.\n                // To prevent this thread from blocking indefinitely in that case,\n                // park_impl() will, after seeing the state set to NOTIFIED after\n                // waking up, call NtWaitForKeyedEvent again to unblock us.\n                unsafe {\n                    c::NtReleaseKeyedEvent(keyed_event_handle(), self.ptr(), 0, ptr::null_mut());\n                }\n            }\n        }\n    }\n\n    fn ptr(&self) -> c::LPVOID {\n        &self.state as *const _ as c::LPVOID\n    }\n}\n\nfn keyed_event_handle() -> c::HANDLE {\n    const INVALID: usize = !0;\n    static HANDLE: AtomicUsize = AtomicUsize::new(INVALID);\n    match HANDLE.load(Relaxed) {\n        INVALID => {\n            let mut handle = c::INVALID_HANDLE_VALUE;\n            unsafe {\n                match c::NtCreateKeyedEvent(\n                    &mut handle,\n                    c::GENERIC_READ | c::GENERIC_WRITE,\n                    ptr::null_mut(),\n                    0,\n                ) {\n                    c::STATUS_SUCCESS => {}\n                    r => panic!(\"Unable to create keyed event handle: error {}\", r),\n                }\n            }\n            match HANDLE.compare_exchange(INVALID, handle as usize, Relaxed, Relaxed) {\n                Ok(_) => handle,\n                Err(h) => {\n                    // Lost the race to another thread initializing HANDLE before we did.\n                    // Closing our handle and using theirs instead.\n                    unsafe {\n                        c::CloseHandle(handle);\n                    }\n                    h as c::HANDLE\n                }\n            }\n        }\n        handle => handle as c::HANDLE,\n    }\n}\n"],["2534","use crate::cell::UnsafeCell;\nuse crate::sys::c;\n\npub struct RWLock {\n    inner: UnsafeCell<c::SRWLOCK>,\n}\n\npub type MovableRWLock = RWLock;\n\nunsafe impl Send for RWLock {}\nunsafe impl Sync for RWLock {}\n\nimpl RWLock {\n    pub const fn new() -> RWLock {\n        RWLock { inner: UnsafeCell::new(c::SRWLOCK_INIT) }\n    }\n    #[inline]\n    pub unsafe fn read(&self) {\n        c::AcquireSRWLockShared(self.inner.get())\n    }\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n        c::TryAcquireSRWLockShared(self.inner.get()) != 0\n    }\n    #[inline]\n    pub unsafe fn write(&self) {\n        c::AcquireSRWLockExclusive(self.inner.get())\n    }\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n        c::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n    }\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n        c::ReleaseSRWLockShared(self.inner.get())\n    }\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n        c::ReleaseSRWLockExclusive(self.inner.get())\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        // ...\n    }\n}\n"],["2535","#![cfg_attr(test, allow(dead_code))]\n\npub struct Handler;\n\nimpl Handler {\n    pub fn new() -> Handler {\n        Handler\n    }\n}\n\npub unsafe fn init() {}\n"],["2536","//! System Mutexes\n//!\n//! The Windows implementation of mutexes is a little odd and it may not be\n//! immediately obvious what's going on. The primary oddness is that SRWLock is\n//! used instead of CriticalSection, and this is done because:\n//!\n//! 1. SRWLock is several times faster than CriticalSection according to\n//!    benchmarks performed on both Windows 8 and Windows 7.\n//!\n//! 2. CriticalSection allows recursive locking while SRWLock deadlocks. The\n//!    Unix implementation deadlocks so consistency is preferred. See #19962 for\n//!    more details.\n//!\n//! 3. While CriticalSection is fair and SRWLock is not, the current Rust policy\n//!    is that there are no guarantees of fairness.\n\nuse crate::cell::UnsafeCell;\nuse crate::mem::MaybeUninit;\nuse crate::sys::c;\n\npub struct Mutex {\n    srwlock: UnsafeCell<c::SRWLOCK>,\n}\n\n// Windows SRW Locks are movable (while not borrowed).\npub type MovableMutex = Mutex;\n\nunsafe impl Send for Mutex {}\nunsafe impl Sync for Mutex {}\n\n#[inline]\npub unsafe fn raw(m: &Mutex) -> c::PSRWLOCK {\n    m.srwlock.get()\n}\n\nimpl Mutex {\n    pub const fn new() -> Mutex {\n        Mutex { srwlock: UnsafeCell::new(c::SRWLOCK_INIT) }\n    }\n    #[inline]\n    pub unsafe fn init(&mut self) {}\n\n    #[inline]\n    pub unsafe fn lock(&self) {\n        c::AcquireSRWLockExclusive(raw(self));\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        c::TryAcquireSRWLockExclusive(raw(self)) != 0\n    }\n\n    #[inline]\n    pub unsafe fn unlock(&self) {\n        c::ReleaseSRWLockExclusive(raw(self));\n    }\n\n    #[inline]\n    pub unsafe fn destroy(&self) {\n        // SRWLock does not need to be destroyed.\n    }\n}\n\npub struct ReentrantMutex {\n    inner: MaybeUninit<UnsafeCell<c::CRITICAL_SECTION>>,\n}\n\nunsafe impl Send for ReentrantMutex {}\nunsafe impl Sync for ReentrantMutex {}\n\nimpl ReentrantMutex {\n    pub const fn uninitialized() -> ReentrantMutex {\n        ReentrantMutex { inner: MaybeUninit::uninit() }\n    }\n\n    pub unsafe fn init(&self) {\n        c::InitializeCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n    }\n\n    pub unsafe fn lock(&self) {\n        c::EnterCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n    }\n\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n        c::TryEnterCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr())) != 0\n    }\n\n    pub unsafe fn unlock(&self) {\n        c::LeaveCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n    }\n\n    pub unsafe fn destroy(&self) {\n        c::DeleteCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n    }\n}\n"],["2537","/// The underlying OsString/OsStr implementation on Windows is a\n/// wrapper around the \"WTF-8\" encoding; see the `wtf8` module for more.\nuse crate::borrow::Cow;\nuse crate::fmt;\nuse crate::mem;\nuse crate::rc::Rc;\nuse crate::sync::Arc;\nuse crate::sys_common::wtf8::{Wtf8, Wtf8Buf};\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\n\n#[derive(Clone, Hash)]\npub struct Buf {\n    pub inner: Wtf8Buf,\n}\n\nimpl IntoInner<Wtf8Buf> for Buf {\n    fn into_inner(self) -> Wtf8Buf {\n        self.inner\n    }\n}\n\nimpl FromInner<Wtf8Buf> for Buf {\n    fn from_inner(inner: Wtf8Buf) -> Self {\n        Buf { inner }\n    }\n}\n\nimpl AsInner<Wtf8> for Buf {\n    fn as_inner(&self) -> &Wtf8 {\n        &self.inner\n    }\n}\n\nimpl fmt::Debug for Buf {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.as_slice(), formatter)\n    }\n}\n\nimpl fmt::Display for Buf {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.as_slice(), formatter)\n    }\n}\n\npub struct Slice {\n    pub inner: Wtf8,\n}\n\nimpl fmt::Debug for Slice {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.inner, formatter)\n    }\n}\n\nimpl fmt::Display for Slice {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(&self.inner, formatter)\n    }\n}\n\nimpl Buf {\n    pub fn with_capacity(capacity: usize) -> Buf {\n        Buf { inner: Wtf8Buf::with_capacity(capacity) }\n    }\n\n    pub fn clear(&mut self) {\n        self.inner.clear()\n    }\n\n    pub fn capacity(&self) -> usize {\n        self.inner.capacity()\n    }\n\n    pub fn from_string(s: String) -> Buf {\n        Buf { inner: Wtf8Buf::from_string(s) }\n    }\n\n    pub fn as_slice(&self) -> &Slice {\n        // SAFETY: Slice is just a wrapper for Wtf8,\n        // and self.inner.as_slice() returns &Wtf8.\n        // Therefore, transmuting &Wtf8 to &Slice is safe.\n        unsafe { mem::transmute(self.inner.as_slice()) }\n    }\n\n    pub fn as_mut_slice(&mut self) -> &mut Slice {\n        // SAFETY: Slice is just a wrapper for Wtf8,\n        // and self.inner.as_mut_slice() returns &mut Wtf8.\n        // Therefore, transmuting &mut Wtf8 to &mut Slice is safe.\n        // Additionally, care should be taken to ensure the slice\n        // is always valid Wtf8.\n        unsafe { mem::transmute(self.inner.as_mut_slice()) }\n    }\n\n    pub fn into_string(self) -> Result<String, Buf> {\n        self.inner.into_string().map_err(|buf| Buf { inner: buf })\n    }\n\n    pub fn push_slice(&mut self, s: &Slice) {\n        self.inner.push_wtf8(&s.inner)\n    }\n\n    pub fn reserve(&mut self, additional: usize) {\n        self.inner.reserve(additional)\n    }\n\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.inner.reserve_exact(additional)\n    }\n\n    pub fn shrink_to_fit(&mut self) {\n        self.inner.shrink_to_fit()\n    }\n\n    #[inline]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.inner.shrink_to(min_capacity)\n    }\n\n    #[inline]\n    pub fn into_box(self) -> Box<Slice> {\n        unsafe { mem::transmute(self.inner.into_box()) }\n    }\n\n    #[inline]\n    pub fn from_box(boxed: Box<Slice>) -> Buf {\n        let inner: Box<Wtf8> = unsafe { mem::transmute(boxed) };\n        Buf { inner: Wtf8Buf::from_box(inner) }\n    }\n\n    #[inline]\n    pub fn into_arc(&self) -> Arc<Slice> {\n        self.as_slice().into_arc()\n    }\n\n    #[inline]\n    pub fn into_rc(&self) -> Rc<Slice> {\n        self.as_slice().into_rc()\n    }\n}\n\nimpl Slice {\n    #[inline]\n    pub fn from_str(s: &str) -> &Slice {\n        unsafe { mem::transmute(Wtf8::from_str(s)) }\n    }\n\n    pub fn to_str(&self) -> Option<&str> {\n        self.inner.as_str()\n    }\n\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n        self.inner.to_string_lossy()\n    }\n\n    pub fn to_owned(&self) -> Buf {\n        let mut buf = Wtf8Buf::with_capacity(self.inner.len());\n        buf.push_wtf8(&self.inner);\n        Buf { inner: buf }\n    }\n\n    pub fn clone_into(&self, buf: &mut Buf) {\n        self.inner.clone_into(&mut buf.inner)\n    }\n\n    #[inline]\n    pub fn into_box(&self) -> Box<Slice> {\n        unsafe { mem::transmute(self.inner.into_box()) }\n    }\n\n    pub fn empty_box() -> Box<Slice> {\n        unsafe { mem::transmute(Wtf8::empty_box()) }\n    }\n\n    #[inline]\n    pub fn into_arc(&self) -> Arc<Slice> {\n        let arc = self.inner.into_arc();\n        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Slice) }\n    }\n\n    #[inline]\n    pub fn into_rc(&self) -> Rc<Slice> {\n        let rc = self.inner.into_rc();\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Slice) }\n    }\n\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        self.inner.make_ascii_lowercase()\n    }\n\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        self.inner.make_ascii_uppercase()\n    }\n\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> Buf {\n        Buf { inner: self.inner.to_ascii_lowercase() }\n    }\n\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> Buf {\n        Buf { inner: self.inner.to_ascii_uppercase() }\n    }\n\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n        self.inner.is_ascii()\n    }\n\n    #[inline]\n    pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool {\n        self.inner.eq_ignore_ascii_case(&other.inner)\n    }\n}\n"],["2538","use crate::marker::PhantomData;\nuse crate::slice;\nuse crate::sys::c;\n\n#[derive(Copy, Clone)]\n#[repr(transparent)]\npub struct IoSlice<'a> {\n    vec: c::WSABUF,\n    _p: PhantomData<&'a [u8]>,\n}\n\nimpl<'a> IoSlice<'a> {\n    #[inline]\n    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n        assert!(buf.len() <= c::ULONG::MAX as usize);\n        IoSlice {\n            vec: c::WSABUF {\n                len: buf.len() as c::ULONG,\n                buf: buf.as_ptr() as *mut u8 as *mut c::CHAR,\n            },\n            _p: PhantomData,\n        }\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        if (self.vec.len as usize) < n {\n            panic!(\"advancing IoSlice beyond its length\");\n        }\n\n        unsafe {\n            self.vec.len -= n as c::ULONG;\n            self.vec.buf = self.vec.buf.add(n);\n        }\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        unsafe { slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize) }\n    }\n}\n\n#[repr(transparent)]\npub struct IoSliceMut<'a> {\n    vec: c::WSABUF,\n    _p: PhantomData<&'a mut [u8]>,\n}\n\nimpl<'a> IoSliceMut<'a> {\n    #[inline]\n    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n        assert!(buf.len() <= c::ULONG::MAX as usize);\n        IoSliceMut {\n            vec: c::WSABUF { len: buf.len() as c::ULONG, buf: buf.as_mut_ptr() as *mut c::CHAR },\n            _p: PhantomData,\n        }\n    }\n\n    #[inline]\n    pub fn advance(&mut self, n: usize) {\n        if (self.vec.len as usize) < n {\n            panic!(\"advancing IoSliceMut beyond its length\");\n        }\n\n        unsafe {\n            self.vec.len -= n as c::ULONG;\n            self.vec.buf = self.vec.buf.add(n);\n        }\n    }\n\n    #[inline]\n    pub fn as_slice(&self) -> &[u8] {\n        unsafe { slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize) }\n    }\n\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n        unsafe { slice::from_raw_parts_mut(self.vec.buf as *mut u8, self.vec.len as usize) }\n    }\n}\n"],["2539","#![deny(unsafe_op_in_unsafe_fn)]\n\nuse crate::alloc::{GlobalAlloc, Layout, System};\nuse crate::ffi::c_void;\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicPtr, Ordering};\nuse crate::sys::c;\nuse crate::sys::common::alloc::{realloc_fallback, MIN_ALIGN};\n\n#[cfg(test)]\nmod tests;\n\n// Heap memory management on Windows is done by using the system Heap API (heapapi.h)\n// See https://docs.microsoft.com/windows/win32/api/heapapi/\n\n// Flag to indicate that the memory returned by `HeapAlloc` should be zeroed.\nconst HEAP_ZERO_MEMORY: c::DWORD = 0x00000008;\n\nextern \"system\" {\n    // Get a handle to the default heap of the current process, or null if the operation fails.\n    //\n    // SAFETY: Successful calls to this function within the same process are assumed to\n    // always return the same handle, which remains valid for the entire lifetime of the process.\n    //\n    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-getprocessheap\n    fn GetProcessHeap() -> c::HANDLE;\n\n    // Allocate a block of `dwBytes` bytes of memory from a given heap `hHeap`.\n    // The allocated memory may be uninitialized, or zeroed if `dwFlags` is\n    // set to `HEAP_ZERO_MEMORY`.\n    //\n    // Returns a pointer to the newly-allocated memory or null if the operation fails.\n    // The returned pointer will be aligned to at least `MIN_ALIGN`.\n    //\n    // SAFETY:\n    //  - `hHeap` must be a non-null handle returned by `GetProcessHeap`.\n    //  - `dwFlags` must be set to either zero or `HEAP_ZERO_MEMORY`.\n    //\n    // Note that `dwBytes` is allowed to be zero, contrary to some other allocators.\n    //\n    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heapalloc\n    fn HeapAlloc(hHeap: c::HANDLE, dwFlags: c::DWORD, dwBytes: c::SIZE_T) -> c::LPVOID;\n\n    // Reallocate a block of memory behind a given pointer `lpMem` from a given heap `hHeap`,\n    // to a block of at least `dwBytes` bytes, either shrinking the block in place,\n    // or allocating at a new location, copying memory, and freeing the original location.\n    //\n    // Returns a pointer to the reallocated memory or null if the operation fails.\n    // The returned pointer will be aligned to at least `MIN_ALIGN`.\n    // If the operation fails the given block will never have been freed.\n    //\n    // SAFETY:\n    //  - `hHeap` must be a non-null handle returned by `GetProcessHeap`.\n    //  - `dwFlags` must be set to zero.\n    //  - `lpMem` must be a non-null pointer to an allocated block returned by `HeapAlloc` or\n    //     `HeapReAlloc`, that has not already been freed.\n    // If the block was successfully reallocated at a new location, pointers pointing to\n    // the freed memory, such as `lpMem`, must not be dereferenced ever again.\n    //\n    // Note that `dwBytes` is allowed to be zero, contrary to some other allocators.\n    //\n    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heaprealloc\n    fn HeapReAlloc(\n        hHeap: c::HANDLE,\n        dwFlags: c::DWORD,\n        lpMem: c::LPVOID,\n        dwBytes: c::SIZE_T,\n    ) -> c::LPVOID;\n\n    // Free a block of memory behind a given pointer `lpMem` from a given heap `hHeap`.\n    // Returns a nonzero value if the operation is successful, and zero if the operation fails.\n    //\n    // SAFETY:\n    //  - `hHeap` must be a non-null handle returned by `GetProcessHeap`.\n    //  - `dwFlags` must be set to zero.\n    //  - `lpMem` must be a pointer to an allocated block returned by `HeapAlloc` or `HeapReAlloc`,\n    //     that has not already been freed.\n    // If the block was successfully freed, pointers pointing to the freed memory, such as `lpMem`,\n    // must not be dereferenced ever again.\n    //\n    // Note that `lpMem` is allowed to be null, which will not cause the operation to fail.\n    //\n    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heapfree\n    fn HeapFree(hHeap: c::HANDLE, dwFlags: c::DWORD, lpMem: c::LPVOID) -> c::BOOL;\n}\n\n// Cached handle to the default heap of the current process.\n// Either a non-null handle returned by `GetProcessHeap`, or null when not yet initialized or `GetProcessHeap` failed.\nstatic HEAP: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n\n// Get a handle to the default heap of the current process, or null if the operation fails.\n// If this operation is successful, `HEAP` will be successfully initialized and contain\n// a non-null handle returned by `GetProcessHeap`.\n#[inline]\nfn init_or_get_process_heap() -> c::HANDLE {\n    let heap = HEAP.load(Ordering::Relaxed);\n    if heap.is_null() {\n        // `HEAP` has not yet been successfully initialized\n        let heap = unsafe { GetProcessHeap() };\n        if !heap.is_null() {\n            // SAFETY: No locking is needed because within the same process,\n            // successful calls to `GetProcessHeap` will always return the same value, even on different threads.\n            HEAP.store(heap, Ordering::Release);\n\n            // SAFETY: `HEAP` contains a non-null handle returned by `GetProcessHeap`\n            heap\n        } else {\n            // Could not get the current process heap.\n            ptr::null_mut()\n        }\n    } else {\n        // SAFETY: `HEAP` contains a non-null handle returned by `GetProcessHeap`\n        heap\n    }\n}\n\n// Get a non-null handle to the default heap of the current process.\n// SAFETY: `HEAP` must have been successfully initialized.\n#[inline]\nunsafe fn get_process_heap() -> c::HANDLE {\n    HEAP.load(Ordering::Acquire)\n}\n\n// Header containing a pointer to the start of an allocated block.\n// SAFETY: Size and alignment must be <= `MIN_ALIGN`.\n#[repr(C)]\nstruct Header(*mut u8);\n\n// Allocate a block of optionally zeroed memory for a given `layout`.\n// SAFETY: Returns a pointer satisfying the guarantees of `System` about allocated pointers,\n// or null if the operation fails. If this returns non-null `HEAP` will have been successfully\n// initialized.\n#[inline]\nunsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n    let heap = init_or_get_process_heap();\n    if heap.is_null() {\n        // Allocation has failed, could not get the current process heap.\n        return ptr::null_mut();\n    }\n\n    // Allocated memory will be either zeroed or uninitialized.\n    let flags = if zeroed { HEAP_ZERO_MEMORY } else { 0 };\n\n    if layout.align() <= MIN_ALIGN {\n        // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`.\n        // The returned pointer points to the start of an allocated block.\n        unsafe { HeapAlloc(heap, flags, layout.size()) as *mut u8 }\n    } else {\n        // Allocate extra padding in order to be able to satisfy the alignment.\n        let total = layout.align() + layout.size();\n\n        // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`.\n        let ptr = unsafe { HeapAlloc(heap, flags, total) as *mut u8 };\n        if ptr.is_null() {\n            // Allocation has failed.\n            return ptr::null_mut();\n        }\n\n        // Create a correctly aligned pointer offset from the start of the allocated block,\n        // and write a header before it.\n\n        let offset = layout.align() - (ptr as usize & (layout.align() - 1));\n        // SAFETY: `MIN_ALIGN` <= `offset` <= `layout.align()` and the size of the allocated\n        // block is `layout.align() + layout.size()`. `aligned` will thus be a correctly aligned\n        // pointer inside the allocated block with at least `layout.size()` bytes after it and at\n        // least `MIN_ALIGN` bytes of padding before it.\n        let aligned = unsafe { ptr.add(offset) };\n        // SAFETY: Because the size and alignment of a header is <= `MIN_ALIGN` and `aligned`\n        // is aligned to at least `MIN_ALIGN` and has at least `MIN_ALIGN` bytes of padding before\n        // it, it is safe to write a header directly before it.\n        unsafe { ptr::write((aligned as *mut Header).offset(-1), Header(ptr)) };\n\n        // SAFETY: The returned pointer does not point to the to the start of an allocated block,\n        // but there is a header readable directly before it containing the location of the start\n        // of the block.\n        aligned\n    }\n}\n\n// All pointers returned by this allocator have, in addition to the guarantees of `GlobalAlloc`, the\n// following properties:\n//\n// If the pointer was allocated or reallocated with a `layout` specifying an alignment <= `MIN_ALIGN`\n// the pointer will be aligned to at least `MIN_ALIGN` and point to the start of the allocated block.\n//\n// If the pointer was allocated or reallocated with a `layout` specifying an alignment > `MIN_ALIGN`\n// the pointer will be aligned to the specified alignment and not point to the start of the allocated block.\n// Instead there will be a header readable directly before the returned pointer, containing the actual\n// location of the start of the block.\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\nunsafe impl GlobalAlloc for System {\n    #[inline]\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: Pointers returned by `allocate` satisfy the guarantees of `System`\n        let zeroed = false;\n        unsafe { allocate(layout, zeroed) }\n    }\n\n    #[inline]\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: Pointers returned by `allocate` satisfy the guarantees of `System`\n        let zeroed = true;\n        unsafe { allocate(layout, zeroed) }\n    }\n\n    #[inline]\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n        let block = {\n            if layout.align() <= MIN_ALIGN {\n                ptr\n            } else {\n                // The location of the start of the block is stored in the padding before `ptr`.\n\n                // SAFETY: Because of the contract of `System`, `ptr` is guaranteed to be non-null\n                // and have a header readable directly before it.\n                unsafe { ptr::read((ptr as *mut Header).offset(-1)).0 }\n            }\n        };\n\n        // SAFETY: because `ptr` has been successfully allocated with this allocator,\n        // `HEAP` must have been successfully initialized.\n        let heap = unsafe { get_process_heap() };\n\n        // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`,\n        // `block` is a pointer to the start of an allocated block.\n        unsafe { HeapFree(heap, 0, block as c::LPVOID) };\n    }\n\n    #[inline]\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        if layout.align() <= MIN_ALIGN {\n            // SAFETY: because `ptr` has been successfully allocated with this allocator,\n            // `HEAP` must have been successfully initialized.\n            let heap = unsafe { get_process_heap() };\n\n            // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`,\n            // `ptr` is a pointer to the start of an allocated block.\n            // The returned pointer points to the start of an allocated block.\n            unsafe { HeapReAlloc(heap, 0, ptr as c::LPVOID, new_size) as *mut u8 }\n        } else {\n            // SAFETY: `realloc_fallback` is implemented using `dealloc` and `alloc`, which will\n            // correctly handle `ptr` and return a pointer satisfying the guarantees of `System`\n            unsafe { realloc_fallback(self, ptr, layout, new_size) }\n        }\n    }\n}\n"],["2540","//! A \"compatibility layer\" for supporting older versions of Windows\n//!\n//! The standard library uses some Windows API functions that are not present\n//! on older versions of Windows.  (Note that the oldest version of Windows\n//! that Rust supports is Windows 7 (client) and Windows Server 2008 (server).)\n//! This module implements a form of delayed DLL import binding, using\n//! `GetModuleHandle` and `GetProcAddress` to look up DLL entry points at\n//! runtime.\n//!\n//! This implementation uses a static initializer to look up the DLL entry\n//! points. The CRT (C runtime) executes static initializers before `main`\n//! is called (for binaries) and before `DllMain` is called (for DLLs).\n//! This is the ideal time to look up DLL imports, because we are guaranteed\n//! that no other threads will attempt to call these entry points. Thus,\n//! we can look up the imports and store them in `static mut` fields\n//! without any synchronization.\n//!\n//! This has an additional advantage: Because the DLL import lookup happens\n//! at module initialization, the cost of these lookups is deterministic,\n//! and is removed from the code paths that actually call the DLL imports.\n//! That is, there is no unpredictable \"cache miss\" that occurs when calling\n//! a DLL import. For applications that benefit from predictable delays,\n//! this is a benefit. This also eliminates the comparison-and-branch\n//! from the hot path.\n//!\n//! Currently, the standard library uses only a small number of dynamic\n//! DLL imports. If this number grows substantially, then the cost of\n//! performing all of the lookups at initialization time might become\n//! substantial.\n//!\n//! The mechanism of registering a static initializer with the CRT is\n//! documented in\n//! [CRT Initialization](https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-160).\n//! It works by contributing a global symbol to the `.CRT$XCU` section.\n//! The linker builds a table of all static initializer functions.\n//! The CRT startup code then iterates that table, calling each\n//! initializer function.\n//!\n//! # **WARNING!!*\n//! The environment that a static initializer function runs in is highly\n//! constrained. There are **many** restrictions on what static initializers\n//! can safely do. Static initializer functions **MUST NOT** do any of the\n//! following (this list is not comprehensive):\n//! * touch any other static field that is used by a different static\n//!   initializer, because the order that static initializers run in\n//!   is not defined.\n//! * call `LoadLibrary` or any other function that acquires the DLL\n//!   loader lock.\n//! * call any Rust function or CRT function that touches any static\n//!   (global) state.\n\nmacro_rules! compat_fn {\n    ($module:literal: $(\n        $(#[$meta:meta])*\n        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $fallback_body:block\n    )*) => ($(\n        $(#[$meta])*\n        pub mod $symbol {\n            #[allow(unused_imports)]\n            use super::*;\n            use crate::mem;\n\n            type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n\n            /// Points to the DLL import, or the fallback function.\n            ///\n            /// This static can be an ordinary, unsynchronized, mutable static because\n            /// we guarantee that all of the writes finish during CRT initialization,\n            /// and all of the reads occur after CRT initialization.\n            static mut PTR: Option<F> = None;\n\n            /// This symbol is what allows the CRT to find the `init` function and call it.\n            /// It is marked `#[used]` because otherwise Rust would assume that it was not\n            /// used, and would remove it.\n            #[used]\n            #[link_section = \".CRT$XCU\"]\n            static INIT_TABLE_ENTRY: unsafe extern \"C\" fn() = init;\n\n            unsafe extern \"C\" fn init() {\n                // There is no locking here. This code is executed before main() is entered, and\n                // is guaranteed to be single-threaded.\n                //\n                // DO NOT do anything interesting or complicated in this function! DO NOT call\n                // any Rust functions or CRT functions, if those functions touch any global state,\n                // because this function runs during global initialization. For example, DO NOT\n                // do any dynamic allocation, don't call LoadLibrary, etc.\n                let module_name: *const u8 = concat!($module, \"\\0\").as_ptr();\n                let symbol_name: *const u8 = concat!(stringify!($symbol), \"\\0\").as_ptr();\n                let module_handle = $crate::sys::c::GetModuleHandleA(module_name as *const i8);\n                if !module_handle.is_null() {\n                    match $crate::sys::c::GetProcAddress(module_handle, symbol_name as *const i8) as usize {\n                        0 => {}\n                        n => {\n                            PTR = Some(mem::transmute::<usize, F>(n));\n                        }\n                    }\n                }\n            }\n\n            #[allow(dead_code)]\n            pub fn option() -> Option<F> {\n                unsafe { PTR }\n            }\n\n            #[allow(dead_code)]\n            pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n                if let Some(ptr) = PTR {\n                    ptr($($argname),*)\n                } else {\n                    $fallback_body\n                }\n            }\n        }\n\n        $(#[$meta])*\n        pub use $symbol::call as $symbol;\n    )*)\n}\n"],["2541","use crate::ffi::OsStr;\nuse crate::mem;\nuse crate::path::Prefix;\n\n#[cfg(test)]\nmod tests;\n\npub const MAIN_SEP_STR: &str = \"\\\\\";\npub const MAIN_SEP: char = '\\\\';\n\n/// # Safety\n///\n/// `bytes` must be a valid wtf8 encoded slice\n#[inline]\nunsafe fn bytes_as_os_str(bytes: &[u8]) -> &OsStr {\n    // &OsStr is layout compatible with &Slice, which is compatible with &Wtf8,\n    // which is compatible with &[u8].\n    mem::transmute(bytes)\n}\n\n#[inline]\npub fn is_sep_byte(b: u8) -> bool {\n    b == b'/' || b == b'\\\\'\n}\n\n#[inline]\npub fn is_verbatim_sep(b: u8) -> bool {\n    b == b'\\\\'\n}\n\npub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n    use Prefix::{DeviceNS, Disk, Verbatim, VerbatimDisk, VerbatimUNC, UNC};\n\n    if let Some(path) = strip_prefix(path, r\"\\\\\") {\n        // \\\\\n        if let Some(path) = strip_prefix(path, r\"?\\\") {\n            // \\\\?\\\n            if let Some(path) = strip_prefix(path, r\"UNC\\\") {\n                // \\\\?\\UNC\\server\\share\n\n                let (server, path) = parse_next_component(path, true);\n                let (share, _) = parse_next_component(path, true);\n\n                Some(VerbatimUNC(server, share))\n            } else {\n                let (prefix, _) = parse_next_component(path, true);\n\n                // in verbatim paths only recognize an exact drive prefix\n                if let Some(drive) = parse_drive_exact(prefix) {\n                    // \\\\?\\C:\n                    Some(VerbatimDisk(drive))\n                } else {\n                    // \\\\?\\prefix\n                    Some(Verbatim(prefix))\n                }\n            }\n        } else if let Some(path) = strip_prefix(path, r\".\\\") {\n            // \\\\.\\COM42\n            let (prefix, _) = parse_next_component(path, false);\n            Some(DeviceNS(prefix))\n        } else {\n            let (server, path) = parse_next_component(path, false);\n            let (share, _) = parse_next_component(path, false);\n\n            if !server.is_empty() && !share.is_empty() {\n                // \\\\server\\share\n                Some(UNC(server, share))\n            } else {\n                // no valid prefix beginning with \"\\\\\" recognized\n                None\n            }\n        }\n    } else if let Some(drive) = parse_drive(path) {\n        // C:\n        Some(Disk(drive))\n    } else {\n        // no prefix\n        None\n    }\n}\n\n// Parses a drive prefix, e.g. \"C:\" and \"C:\\whatever\"\nfn parse_drive(prefix: &OsStr) -> Option<u8> {\n    // In most DOS systems, it is not possible to have more than 26 drive letters.\n    // See <https://en.wikipedia.org/wiki/Drive_letter_assignment#Common_assignments>.\n    fn is_valid_drive_letter(drive: &u8) -> bool {\n        drive.is_ascii_alphabetic()\n    }\n\n    match prefix.bytes() {\n        [drive, b':', ..] if is_valid_drive_letter(drive) => Some(drive.to_ascii_uppercase()),\n        _ => None,\n    }\n}\n\n// Parses a drive prefix exactly, e.g. \"C:\"\nfn parse_drive_exact(prefix: &OsStr) -> Option<u8> {\n    // only parse two bytes: the drive letter and the drive separator\n    if prefix.len() == 2 { parse_drive(prefix) } else { None }\n}\n\nfn strip_prefix<'a>(path: &'a OsStr, prefix: &str) -> Option<&'a OsStr> {\n    // `path` and `prefix` are valid wtf8 and utf8 encoded slices respectively, `path[prefix.len()]`\n    // is thus a code point boundary and `path[prefix.len()..]` is a valid wtf8 encoded slice.\n    match path.bytes().strip_prefix(prefix.as_bytes()) {\n        Some(path) => unsafe { Some(bytes_as_os_str(path)) },\n        None => None,\n    }\n}\n\n// Parse the next path component.\n//\n// Returns the next component and the rest of the path excluding the component and separator.\n// Does not recognize `/` as a separator character if `verbatim` is true.\nfn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n    let separator = if verbatim { is_verbatim_sep } else { is_sep_byte };\n\n    match path.bytes().iter().position(|&x| separator(x)) {\n        Some(separator_start) => {\n            let mut separator_end = separator_start + 1;\n\n            // a series of multiple separator characters is treated as a single separator,\n            // except in verbatim paths\n            while !verbatim && separator_end < path.len() && separator(path.bytes()[separator_end])\n            {\n                separator_end += 1;\n            }\n\n            let component = &path.bytes()[..separator_start];\n\n            // Panic safe\n            // The max `separator_end` is `bytes.len()` and `bytes[bytes.len()..]` is a valid index.\n            let path = &path.bytes()[separator_end..];\n\n            // SAFETY: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n            // is encoded in a single byte, therefore `bytes[separator_start]` and\n            // `bytes[separator_end]` must be code point boundaries and thus\n            // `bytes[..separator_start]` and `bytes[separator_end..]` are valid wtf8 slices.\n            unsafe { (bytes_as_os_str(component), bytes_as_os_str(path)) }\n        }\n        None => (path, OsStr::new(\"\")),\n    }\n}\n"],["2542","use crate::cell::UnsafeCell;\nuse crate::sys::c;\nuse crate::sys::mutex::{self, Mutex};\nuse crate::sys::os;\nuse crate::time::Duration;\n\npub struct Condvar {\n    inner: UnsafeCell<c::CONDITION_VARIABLE>,\n}\n\npub type MovableCondvar = Condvar;\n\nunsafe impl Send for Condvar {}\nunsafe impl Sync for Condvar {}\n\nimpl Condvar {\n    pub const fn new() -> Condvar {\n        Condvar { inner: UnsafeCell::new(c::CONDITION_VARIABLE_INIT) }\n    }\n\n    #[inline]\n    pub unsafe fn init(&mut self) {}\n\n    #[inline]\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n        let r = c::SleepConditionVariableSRW(self.inner.get(), mutex::raw(mutex), c::INFINITE, 0);\n        debug_assert!(r != 0);\n    }\n\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n        let r = c::SleepConditionVariableSRW(\n            self.inner.get(),\n            mutex::raw(mutex),\n            super::dur2timeout(dur),\n            0,\n        );\n        if r == 0 {\n            debug_assert_eq!(os::errno() as usize, c::ERROR_TIMEOUT as usize);\n            false\n        } else {\n            true\n        }\n    }\n\n    #[inline]\n    pub unsafe fn notify_one(&self) {\n        c::WakeConditionVariable(self.inner.get())\n    }\n\n    #[inline]\n    pub unsafe fn notify_all(&self) {\n        c::WakeAllConditionVariable(self.inner.get())\n    }\n\n    pub unsafe fn destroy(&self) {\n        // ...\n    }\n}\n"],["2543","use crate::mem::ManuallyDrop;\nuse crate::ptr;\nuse crate::sync::atomic::AtomicPtr;\nuse crate::sync::atomic::Ordering::SeqCst;\nuse crate::sys::c;\n\npub type Key = c::DWORD;\npub type Dtor = unsafe extern \"C\" fn(*mut u8);\n\n// Turns out, like pretty much everything, Windows is pretty close the\n// functionality that Unix provides, but slightly different! In the case of\n// TLS, Windows does not provide an API to provide a destructor for a TLS\n// variable. This ends up being pretty crucial to this implementation, so we\n// need a way around this.\n//\n// The solution here ended up being a little obscure, but fear not, the\n// internet has informed me [1][2] that this solution is not unique (no way\n// I could have thought of it as well!). The key idea is to insert some hook\n// somewhere to run arbitrary code on thread termination. With this in place\n// we'll be able to run anything we like, including all TLS destructors!\n//\n// To accomplish this feat, we perform a number of threads, all contained\n// within this module:\n//\n// * All TLS destructors are tracked by *us*, not the windows runtime. This\n//   means that we have a global list of destructors for each TLS key that\n//   we know about.\n// * When a thread exits, we run over the entire list and run dtors for all\n//   non-null keys. This attempts to match Unix semantics in this regard.\n//\n// This ends up having the overhead of using a global list, having some\n// locks here and there, and in general just adding some more code bloat. We\n// attempt to optimize runtime by forgetting keys that don't have\n// destructors, but this only gets us so far.\n//\n// For more details and nitty-gritty, see the code sections below!\n//\n// [1]: http://www.codeproject.com/Articles/8113/Thread-Local-Storage-The-C-Way\n// [2]: https://github.com/ChromiumWebApps/chromium/blob/master/base\n//                        /threading/thread_local_storage_win.cc#L42\n\n// -------------------------------------------------------------------------\n// Native bindings\n//\n// This section is just raw bindings to the native functions that Windows\n// provides, There's a few extra calls to deal with destructors.\n\n#[inline]\npub unsafe fn create(dtor: Option<Dtor>) -> Key {\n    let key = c::TlsAlloc();\n    assert!(key != c::TLS_OUT_OF_INDEXES);\n    if let Some(f) = dtor {\n        register_dtor(key, f);\n    }\n    key\n}\n\n#[inline]\npub unsafe fn set(key: Key, value: *mut u8) {\n    let r = c::TlsSetValue(key, value as c::LPVOID);\n    debug_assert!(r != 0);\n}\n\n#[inline]\npub unsafe fn get(key: Key) -> *mut u8 {\n    c::TlsGetValue(key) as *mut u8\n}\n\n#[inline]\npub unsafe fn destroy(_key: Key) {\n    rtabort!(\"can't destroy tls keys on windows\")\n}\n\n#[inline]\npub fn requires_synchronized_create() -> bool {\n    true\n}\n\n// -------------------------------------------------------------------------\n// Dtor registration\n//\n// Windows has no native support for running destructors so we manage our own\n// list of destructors to keep track of how to destroy keys. We then install a\n// callback later to get invoked whenever a thread exits, running all\n// appropriate destructors.\n//\n// Currently unregistration from this list is not supported. A destructor can be\n// registered but cannot be unregistered. There's various simplifying reasons\n// for doing this, the big ones being:\n//\n// 1. Currently we don't even support deallocating TLS keys, so normal operation\n//    doesn't need to deallocate a destructor.\n// 2. There is no point in time where we know we can unregister a destructor\n//    because it could always be getting run by some remote thread.\n//\n// Typically processes have a statically known set of TLS keys which is pretty\n// small, and we'd want to keep this memory alive for the whole process anyway\n// really.\n//\n// Perhaps one day we can fold the `Box` here into a static allocation,\n// expanding the `StaticKey` structure to contain not only a slot for the TLS\n// key but also a slot for the destructor queue on windows. An optimization for\n// another day!\n\nstatic DTORS: AtomicPtr<Node> = AtomicPtr::new(ptr::null_mut());\n\nstruct Node {\n    dtor: Dtor,\n    key: Key,\n    next: *mut Node,\n}\n\nunsafe fn register_dtor(key: Key, dtor: Dtor) {\n    let mut node = ManuallyDrop::new(Box::new(Node { key, dtor, next: ptr::null_mut() }));\n\n    let mut head = DTORS.load(SeqCst);\n    loop {\n        node.next = head;\n        match DTORS.compare_exchange(head, &mut **node, SeqCst, SeqCst) {\n            Ok(_) => return, // nothing to drop, we successfully added the node to the list\n            Err(cur) => head = cur,\n        }\n    }\n}\n\n// -------------------------------------------------------------------------\n// Where the Magic (TM) Happens\n//\n// If you're looking at this code, and wondering \"what is this doing?\",\n// you're not alone! I'll try to break this down step by step:\n//\n// # What's up with CRT$XLB?\n//\n// For anything about TLS destructors to work on Windows, we have to be able\n// to run *something* when a thread exits. To do so, we place a very special\n// static in a very special location. If this is encoded in just the right\n// way, the kernel's loader is apparently nice enough to run some function\n// of ours whenever a thread exits! How nice of the kernel!\n//\n// Lots of detailed information can be found in source [1] above, but the\n// gist of it is that this is leveraging a feature of Microsoft's PE format\n// (executable format) which is not actually used by any compilers today.\n// This apparently translates to any callbacks in the \".CRT$XLB\" section\n// being run on certain events.\n//\n// So after all that, we use the compiler's #[link_section] feature to place\n// a callback pointer into the magic section so it ends up being called.\n//\n// # What's up with this callback?\n//\n// The callback specified receives a number of parameters from... someone!\n// (the kernel? the runtime? I'm not quite sure!) There are a few events that\n// this gets invoked for, but we're currently only interested on when a\n// thread or a process \"detaches\" (exits). The process part happens for the\n// last thread and the thread part happens for any normal thread.\n//\n// # Ok, what's up with running all these destructors?\n//\n// This will likely need to be improved over time, but this function\n// attempts a \"poor man's\" destructor callback system. Once we've got a list\n// of what to run, we iterate over all keys, check their values, and then run\n// destructors if the values turn out to be non null (setting them to null just\n// beforehand). We do this a few times in a loop to basically match Unix\n// semantics. If we don't reach a fixed point after a short while then we just\n// inevitably leak something most likely.\n//\n// # The article mentions weird stuff about \"/INCLUDE\"?\n//\n// It sure does! Specifically we're talking about this quote:\n//\n//      The Microsoft run-time library facilitates this process by defining a\n//      memory image of the TLS Directory and giving it the special name\n//      __tls_used (Intel x86 platforms) or _tls_used (other platforms). The\n//      linker looks for this memory image and uses the data there to create the\n//      TLS Directory. Other compilers that support TLS and work with the\n//      Microsoft linker must use this same technique.\n//\n// Basically what this means is that if we want support for our TLS\n// destructors/our hook being called then we need to make sure the linker does\n// not omit this symbol. Otherwise it will omit it and our callback won't be\n// wired up.\n//\n// We don't actually use the `/INCLUDE` linker flag here like the article\n// mentions because the Rust compiler doesn't propagate linker flags, but\n// instead we use a shim function which performs a volatile 1-byte load from\n// the address of the symbol to ensure it sticks around.\n\n#[link_section = \".CRT$XLB\"]\n#[allow(dead_code, unused_variables)]\n#[used] // we don't want LLVM eliminating this symbol for any reason, and\n// when the symbol makes it to the linker the linker will take over\npub static p_thread_callback: unsafe extern \"system\" fn(c::LPVOID, c::DWORD, c::LPVOID) =\n    on_tls_callback;\n\n#[allow(dead_code, unused_variables)]\nunsafe extern \"system\" fn on_tls_callback(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID) {\n    if dwReason == c::DLL_THREAD_DETACH || dwReason == c::DLL_PROCESS_DETACH {\n        run_dtors();\n    }\n\n    // See comments above for what this is doing. Note that we don't need this\n    // trickery on GNU windows, just on MSVC.\n    reference_tls_used();\n    #[cfg(target_env = \"msvc\")]\n    unsafe fn reference_tls_used() {\n        extern \"C\" {\n            static _tls_used: u8;\n        }\n        crate::intrinsics::volatile_load(&_tls_used);\n    }\n    #[cfg(not(target_env = \"msvc\"))]\n    unsafe fn reference_tls_used() {}\n}\n\n#[allow(dead_code)] // actually called above\nunsafe fn run_dtors() {\n    let mut any_run = true;\n    for _ in 0..5 {\n        if !any_run {\n            break;\n        }\n        any_run = false;\n        let mut cur = DTORS.load(SeqCst);\n        while !cur.is_null() {\n            let ptr = c::TlsGetValue((*cur).key);\n\n            if !ptr.is_null() {\n                c::TlsSetValue((*cur).key, ptr::null_mut());\n                ((*cur).dtor)(ptr as *mut _);\n                any_run = true;\n            }\n\n            cur = (*cur).next;\n        }\n    }\n}\n"],["2544","#![unstable(feature = \"process_internals\", issue = \"none\")]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::borrow::Borrow;\nuse crate::collections::BTreeMap;\nuse crate::convert::{TryFrom, TryInto};\nuse crate::env;\nuse crate::env::split_paths;\nuse crate::ffi::{OsStr, OsString};\nuse crate::fmt;\nuse crate::fs;\nuse crate::io::{self, Error, ErrorKind};\nuse crate::mem;\nuse crate::num::NonZeroI32;\nuse crate::os::windows::ffi::OsStrExt;\nuse crate::path::Path;\nuse crate::ptr;\nuse crate::sys::c;\nuse crate::sys::c::NonZeroDWORD;\nuse crate::sys::cvt;\nuse crate::sys::fs::{File, OpenOptions};\nuse crate::sys::handle::Handle;\nuse crate::sys::pipe::{self, AnonPipe};\nuse crate::sys::stdio;\nuse crate::sys_common::mutex::StaticMutex;\nuse crate::sys_common::process::{CommandEnv, CommandEnvs};\nuse crate::sys_common::AsInner;\n\nuse libc::{c_void, EXIT_FAILURE, EXIT_SUCCESS};\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\n#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n#[doc(hidden)]\npub struct EnvKey(OsString);\n\nimpl From<OsString> for EnvKey {\n    fn from(mut k: OsString) -> Self {\n        k.make_ascii_uppercase();\n        EnvKey(k)\n    }\n}\n\nimpl From<EnvKey> for OsString {\n    fn from(k: EnvKey) -> Self {\n        k.0\n    }\n}\n\nimpl Borrow<OsStr> for EnvKey {\n    fn borrow(&self) -> &OsStr {\n        &self.0\n    }\n}\n\nimpl AsRef<OsStr> for EnvKey {\n    fn as_ref(&self) -> &OsStr {\n        &self.0\n    }\n}\n\nfn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n    if str.as_ref().encode_wide().any(|b| b == 0) {\n        Err(io::Error::new_const(ErrorKind::InvalidInput, &\"nul byte found in provided data\"))\n    } else {\n        Ok(str)\n    }\n}\n\npub struct Command {\n    program: OsString,\n    args: Vec<OsString>,\n    env: CommandEnv,\n    cwd: Option<OsString>,\n    flags: u32,\n    detach: bool, // not currently exposed in std::process\n    stdin: Option<Stdio>,\n    stdout: Option<Stdio>,\n    stderr: Option<Stdio>,\n    force_quotes_enabled: bool,\n}\n\npub enum Stdio {\n    Inherit,\n    Null,\n    MakePipe,\n    Handle(Handle),\n}\n\npub struct StdioPipes {\n    pub stdin: Option<AnonPipe>,\n    pub stdout: Option<AnonPipe>,\n    pub stderr: Option<AnonPipe>,\n}\n\nimpl Command {\n    pub fn new(program: &OsStr) -> Command {\n        Command {\n            program: program.to_os_string(),\n            args: Vec::new(),\n            env: Default::default(),\n            cwd: None,\n            flags: 0,\n            detach: false,\n            stdin: None,\n            stdout: None,\n            stderr: None,\n            force_quotes_enabled: false,\n        }\n    }\n\n    pub fn arg(&mut self, arg: &OsStr) {\n        self.args.push(arg.to_os_string())\n    }\n    pub fn env_mut(&mut self) -> &mut CommandEnv {\n        &mut self.env\n    }\n    pub fn cwd(&mut self, dir: &OsStr) {\n        self.cwd = Some(dir.to_os_string())\n    }\n    pub fn stdin(&mut self, stdin: Stdio) {\n        self.stdin = Some(stdin);\n    }\n    pub fn stdout(&mut self, stdout: Stdio) {\n        self.stdout = Some(stdout);\n    }\n    pub fn stderr(&mut self, stderr: Stdio) {\n        self.stderr = Some(stderr);\n    }\n    pub fn creation_flags(&mut self, flags: u32) {\n        self.flags = flags;\n    }\n\n    pub fn force_quotes(&mut self, enabled: bool) {\n        self.force_quotes_enabled = enabled;\n    }\n\n    pub fn get_program(&self) -> &OsStr {\n        &self.program\n    }\n\n    pub fn get_args(&self) -> CommandArgs<'_> {\n        let iter = self.args.iter();\n        CommandArgs { iter }\n    }\n\n    pub fn get_envs(&self) -> CommandEnvs<'_> {\n        self.env.iter()\n    }\n\n    pub fn get_current_dir(&self) -> Option<&Path> {\n        self.cwd.as_ref().map(|cwd| Path::new(cwd))\n    }\n\n    pub fn spawn(\n        &mut self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        let maybe_env = self.env.capture_if_changed();\n        // To have the spawning semantics of unix/windows stay the same, we need\n        // to read the *child's* PATH if one is provided. See #15149 for more\n        // details.\n        let program = maybe_env.as_ref().and_then(|env| {\n            if let Some(v) = env.get(OsStr::new(\"PATH\")) {\n                // Split the value and test each path to see if the\n                // program exists.\n                for path in split_paths(&v) {\n                    let path = path\n                        .join(self.program.to_str().unwrap())\n                        .with_extension(env::consts::EXE_EXTENSION);\n                    if fs::metadata(&path).is_ok() {\n                        return Some(path.into_os_string());\n                    }\n                }\n            }\n            None\n        });\n\n        let mut si = zeroed_startupinfo();\n        si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n        si.dwFlags = c::STARTF_USESTDHANDLES;\n\n        let program = program.as_ref().unwrap_or(&self.program);\n        let mut cmd_str = make_command_line(program, &self.args, self.force_quotes_enabled)?;\n        cmd_str.push(0); // add null terminator\n\n        // stolen from the libuv code.\n        let mut flags = self.flags | c::CREATE_UNICODE_ENVIRONMENT;\n        if self.detach {\n            flags |= c::DETACHED_PROCESS | c::CREATE_NEW_PROCESS_GROUP;\n        }\n\n        let (envp, _data) = make_envp(maybe_env)?;\n        let (dirp, _data) = make_dirp(self.cwd.as_ref())?;\n        let mut pi = zeroed_process_information();\n\n        // Prepare all stdio handles to be inherited by the child. This\n        // currently involves duplicating any existing ones with the ability to\n        // be inherited by child processes. Note, however, that once an\n        // inheritable handle is created, *any* spawned child will inherit that\n        // handle. We only want our own child to inherit this handle, so we wrap\n        // the remaining portion of this spawn in a mutex.\n        //\n        // For more information, msdn also has an article about this race:\n        // http://support.microsoft.com/kb/315939\n        static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n\n        let _guard = unsafe { CREATE_PROCESS_LOCK.lock() };\n\n        let mut pipes = StdioPipes { stdin: None, stdout: None, stderr: None };\n        let null = Stdio::Null;\n        let default_stdin = if needs_stdin { &default } else { &null };\n        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n        let stdout = self.stdout.as_ref().unwrap_or(&default);\n        let stderr = self.stderr.as_ref().unwrap_or(&default);\n        let stdin = stdin.to_handle(c::STD_INPUT_HANDLE, &mut pipes.stdin)?;\n        let stdout = stdout.to_handle(c::STD_OUTPUT_HANDLE, &mut pipes.stdout)?;\n        let stderr = stderr.to_handle(c::STD_ERROR_HANDLE, &mut pipes.stderr)?;\n        si.hStdInput = stdin.raw();\n        si.hStdOutput = stdout.raw();\n        si.hStdError = stderr.raw();\n\n        unsafe {\n            cvt(c::CreateProcessW(\n                ptr::null(),\n                cmd_str.as_mut_ptr(),\n                ptr::null_mut(),\n                ptr::null_mut(),\n                c::TRUE,\n                flags,\n                envp,\n                dirp,\n                &mut si,\n                &mut pi,\n            ))\n        }?;\n\n        // We close the thread handle because we don't care about keeping\n        // the thread id valid, and we aren't keeping the thread handle\n        // around to be able to close it later.\n        drop(Handle::new(pi.hThread));\n\n        Ok((Process { handle: Handle::new(pi.hProcess) }, pipes))\n    }\n}\n\nimpl fmt::Debug for Command {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:?}\", self.program)?;\n        for arg in &self.args {\n            write!(f, \" {:?}\", arg)?;\n        }\n        Ok(())\n    }\n}\n\nimpl Stdio {\n    fn to_handle(&self, stdio_id: c::DWORD, pipe: &mut Option<AnonPipe>) -> io::Result<Handle> {\n        match *self {\n            // If no stdio handle is available, then inherit means that it\n            // should still be unavailable so propagate the\n            // INVALID_HANDLE_VALUE.\n            Stdio::Inherit => match stdio::get_handle(stdio_id) {\n                Ok(io) => {\n                    let io = Handle::new(io);\n                    let ret = io.duplicate(0, true, c::DUPLICATE_SAME_ACCESS);\n                    io.into_raw();\n                    ret\n                }\n                Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n            },\n\n            Stdio::MakePipe => {\n                let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n                let pipes = pipe::anon_pipe(ours_readable, true)?;\n                *pipe = Some(pipes.ours);\n                Ok(pipes.theirs.into_handle())\n            }\n\n            Stdio::Handle(ref handle) => handle.duplicate(0, true, c::DUPLICATE_SAME_ACCESS),\n\n            // Open up a reference to NUL with appropriate read/write\n            // permissions as well as the ability to be inherited to child\n            // processes (as this is about to be inherited).\n            Stdio::Null => {\n                let size = mem::size_of::<c::SECURITY_ATTRIBUTES>();\n                let mut sa = c::SECURITY_ATTRIBUTES {\n                    nLength: size as c::DWORD,\n                    lpSecurityDescriptor: ptr::null_mut(),\n                    bInheritHandle: 1,\n                };\n                let mut opts = OpenOptions::new();\n                opts.read(stdio_id == c::STD_INPUT_HANDLE);\n                opts.write(stdio_id != c::STD_INPUT_HANDLE);\n                opts.security_attributes(&mut sa);\n                File::open(Path::new(\"NUL\"), &opts).map(|file| file.into_handle())\n            }\n        }\n    }\n}\n\nimpl From<AnonPipe> for Stdio {\n    fn from(pipe: AnonPipe) -> Stdio {\n        Stdio::Handle(pipe.into_handle())\n    }\n}\n\nimpl From<File> for Stdio {\n    fn from(file: File) -> Stdio {\n        Stdio::Handle(file.into_handle())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Processes\n////////////////////////////////////////////////////////////////////////////////\n\n/// A value representing a child process.\n///\n/// The lifetime of this value is linked to the lifetime of the actual\n/// process - the Process destructor calls self.finish() which waits\n/// for the process to terminate.\npub struct Process {\n    handle: Handle,\n}\n\nimpl Process {\n    pub fn kill(&mut self) -> io::Result<()> {\n        cvt(unsafe { c::TerminateProcess(self.handle.raw(), 1) })?;\n        Ok(())\n    }\n\n    pub fn id(&self) -> u32 {\n        unsafe { c::GetProcessId(self.handle.raw()) as u32 }\n    }\n\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        unsafe {\n            let res = c::WaitForSingleObject(self.handle.raw(), c::INFINITE);\n            if res != c::WAIT_OBJECT_0 {\n                return Err(Error::last_os_error());\n            }\n            let mut status = 0;\n            cvt(c::GetExitCodeProcess(self.handle.raw(), &mut status))?;\n            Ok(ExitStatus(status))\n        }\n    }\n\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        unsafe {\n            match c::WaitForSingleObject(self.handle.raw(), 0) {\n                c::WAIT_OBJECT_0 => {}\n                c::WAIT_TIMEOUT => {\n                    return Ok(None);\n                }\n                _ => return Err(io::Error::last_os_error()),\n            }\n            let mut status = 0;\n            cvt(c::GetExitCodeProcess(self.handle.raw(), &mut status))?;\n            Ok(Some(ExitStatus(status)))\n        }\n    }\n\n    pub fn handle(&self) -> &Handle {\n        &self.handle\n    }\n\n    pub fn into_handle(self) -> Handle {\n        self.handle\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatus(c::DWORD);\n\nimpl ExitStatus {\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        match NonZeroDWORD::try_from(self.0) {\n            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n            /* was zero, couldn't convert */ Err(_) => Ok(()),\n        }\n    }\n    pub fn code(&self) -> Option<i32> {\n        Some(self.0 as i32)\n    }\n}\n\n/// Converts a raw `c::DWORD` to a type-safe `ExitStatus` by wrapping it without copying.\nimpl From<c::DWORD> for ExitStatus {\n    fn from(u: c::DWORD) -> ExitStatus {\n        ExitStatus(u)\n    }\n}\n\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Windows exit codes with the high bit set typically mean some form of\n        // unhandled exception or warning. In this scenario printing the exit\n        // code in decimal doesn't always make sense because it's a very large\n        // and somewhat gibberish number. The hex code is a bit more\n        // recognizable and easier to search for, so print that.\n        if self.0 & 0x80000000 != 0 {\n            write!(f, \"exit code: {:#x}\", self.0)\n        } else {\n            write!(f, \"exit code: {}\", self.0)\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitStatusError(c::NonZeroDWORD);\n\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        ExitStatus(self.0.into())\n    }\n}\n\nimpl ExitStatusError {\n    pub fn code(self) -> Option<NonZeroI32> {\n        Some((u32::from(self.0) as i32).try_into().unwrap())\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitCode(c::DWORD);\n\nimpl ExitCode {\n    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n\n    #[inline]\n    pub fn as_i32(&self) -> i32 {\n        self.0 as i32\n    }\n}\n\nfn zeroed_startupinfo() -> c::STARTUPINFO {\n    c::STARTUPINFO {\n        cb: 0,\n        lpReserved: ptr::null_mut(),\n        lpDesktop: ptr::null_mut(),\n        lpTitle: ptr::null_mut(),\n        dwX: 0,\n        dwY: 0,\n        dwXSize: 0,\n        dwYSize: 0,\n        dwXCountChars: 0,\n        dwYCountCharts: 0,\n        dwFillAttribute: 0,\n        dwFlags: 0,\n        wShowWindow: 0,\n        cbReserved2: 0,\n        lpReserved2: ptr::null_mut(),\n        hStdInput: c::INVALID_HANDLE_VALUE,\n        hStdOutput: c::INVALID_HANDLE_VALUE,\n        hStdError: c::INVALID_HANDLE_VALUE,\n    }\n}\n\nfn zeroed_process_information() -> c::PROCESS_INFORMATION {\n    c::PROCESS_INFORMATION {\n        hProcess: ptr::null_mut(),\n        hThread: ptr::null_mut(),\n        dwProcessId: 0,\n        dwThreadId: 0,\n    }\n}\n\n// Produces a wide string *without terminating null*; returns an error if\n// `prog` or any of the `args` contain a nul.\nfn make_command_line(prog: &OsStr, args: &[OsString], force_quotes: bool) -> io::Result<Vec<u16>> {\n    // Encode the command and arguments in a command line string such\n    // that the spawned process may recover them using CommandLineToArgvW.\n    let mut cmd: Vec<u16> = Vec::new();\n    // Always quote the program name so CreateProcess doesn't interpret args as\n    // part of the name if the binary wasn't found first time.\n    append_arg(&mut cmd, prog, true)?;\n    for arg in args {\n        cmd.push(' ' as u16);\n        append_arg(&mut cmd, arg, force_quotes)?;\n    }\n    return Ok(cmd);\n\n    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr, force_quotes: bool) -> io::Result<()> {\n        // If an argument has 0 characters then we need to quote it to ensure\n        // that it actually gets passed through on the command line or otherwise\n        // it will be dropped entirely when parsed on the other end.\n        ensure_no_nuls(arg)?;\n        let arg_bytes = &arg.as_inner().inner.as_inner();\n        let quote = force_quotes\n            || arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t')\n            || arg_bytes.is_empty();\n        if quote {\n            cmd.push('\"' as u16);\n        }\n\n        let mut backslashes: usize = 0;\n        for x in arg.encode_wide() {\n            if x == '\\\\' as u16 {\n                backslashes += 1;\n            } else {\n                if x == '\"' as u16 {\n                    // Add n+1 backslashes to total 2n+1 before internal '\"'.\n                    cmd.extend((0..=backslashes).map(|_| '\\\\' as u16));\n                }\n                backslashes = 0;\n            }\n            cmd.push(x);\n        }\n\n        if quote {\n            // Add n backslashes to total 2n before ending '\"'.\n            cmd.extend((0..backslashes).map(|_| '\\\\' as u16));\n            cmd.push('\"' as u16);\n        }\n        Ok(())\n    }\n}\n\nfn make_envp(maybe_env: Option<BTreeMap<EnvKey, OsString>>) -> io::Result<(*mut c_void, Vec<u16>)> {\n    // On Windows we pass an \"environment block\" which is not a char**, but\n    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n    // \\0 to terminate.\n    if let Some(env) = maybe_env {\n        let mut blk = Vec::new();\n\n        for (k, v) in env {\n            blk.extend(ensure_no_nuls(k.0)?.encode_wide());\n            blk.push('=' as u16);\n            blk.extend(ensure_no_nuls(v)?.encode_wide());\n            blk.push(0);\n        }\n        blk.push(0);\n        Ok((blk.as_mut_ptr() as *mut c_void, blk))\n    } else {\n        Ok((ptr::null_mut(), Vec::new()))\n    }\n}\n\nfn make_dirp(d: Option<&OsString>) -> io::Result<(*const u16, Vec<u16>)> {\n    match d {\n        Some(dir) => {\n            let mut dir_str: Vec<u16> = ensure_no_nuls(dir)?.encode_wide().collect();\n            dir_str.push(0);\n            Ok((dir_str.as_ptr(), dir_str))\n        }\n        None => Ok((ptr::null(), Vec::new())),\n    }\n}\n\npub struct CommandArgs<'a> {\n    iter: crate::slice::Iter<'a, OsString>,\n}\n\nimpl<'a> Iterator for CommandArgs<'a> {\n    type Item = &'a OsStr;\n    fn next(&mut self) -> Option<&'a OsStr> {\n        self.iter.next().map(|s| s.as_ref())\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<'a> ExactSizeIterator for CommandArgs<'a> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\nimpl<'a> fmt::Debug for CommandArgs<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter.clone()).finish()\n    }\n}\n"],["2545","use super::*;\n\n#[test]\nfn test_parse_next_component() {\n    assert_eq!(\n        parse_next_component(OsStr::new(r\"server\\share\"), true),\n        (OsStr::new(r\"server\"), OsStr::new(r\"share\"))\n    );\n\n    assert_eq!(\n        parse_next_component(OsStr::new(r\"server/share\"), true),\n        (OsStr::new(r\"server/share\"), OsStr::new(r\"\"))\n    );\n\n    assert_eq!(\n        parse_next_component(OsStr::new(r\"server/share\"), false),\n        (OsStr::new(r\"server\"), OsStr::new(r\"share\"))\n    );\n\n    assert_eq!(\n        parse_next_component(OsStr::new(r\"server\\\"), false),\n        (OsStr::new(r\"server\"), OsStr::new(r\"\"))\n    );\n\n    assert_eq!(\n        parse_next_component(OsStr::new(r\"\\server\\\"), false),\n        (OsStr::new(r\"\"), OsStr::new(r\"server\\\"))\n    );\n\n    assert_eq!(\n        parse_next_component(OsStr::new(r\"servershare\"), false),\n        (OsStr::new(r\"servershare\"), OsStr::new(\"\"))\n    );\n\n    assert_eq!(\n        parse_next_component(OsStr::new(r\"server/\\//\\/\\\\\\\\/////\\/share\"), false),\n        (OsStr::new(r\"server\"), OsStr::new(r\"share\"))\n    );\n\n    assert_eq!(\n        parse_next_component(OsStr::new(r\"server\\\\\\\\\\\\\\\\\\\\\\\\\\\\share\"), true),\n        (OsStr::new(r\"server\"), OsStr::new(r\"\\\\\\\\\\\\\\\\\\\\\\\\\\share\"))\n    );\n}\n"],["2546","use super::make_command_line;\nuse crate::ffi::{OsStr, OsString};\n\n#[test]\nfn test_make_command_line() {\n    fn test_wrapper(prog: &str, args: &[&str], force_quotes: bool) -> String {\n        let command_line = &make_command_line(\n            OsStr::new(prog),\n            &args.iter().map(|a| OsString::from(a)).collect::<Vec<OsString>>(),\n            force_quotes,\n        )\n        .unwrap();\n        String::from_utf16(command_line).unwrap()\n    }\n\n    assert_eq!(test_wrapper(\"prog\", &[\"aaa\", \"bbb\", \"ccc\"], false), \"\\\"prog\\\" aaa bbb ccc\");\n\n    assert_eq!(\n        test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\"], false),\n        \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n    );\n    assert_eq!(\n        test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\", \"v*\"], false),\n        \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa v*\"\n    );\n    assert_eq!(\n        test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\", \"v*\"], true),\n        \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" \\\"aaa\\\" \\\"v*\\\"\"\n    );\n    assert_eq!(\n        test_wrapper(\"C:\\\\Program Files\\\\test\", &[\"aa\\\"bb\"], false),\n        \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n    );\n    assert_eq!(test_wrapper(\"echo\", &[\"a b c\"], false), \"\\\"echo\\\" \\\"a b c\\\"\");\n    assert_eq!(\n        test_wrapper(\"echo\", &[\"\\\" \\\\\\\" \\\\\", \"\\\\\"], false),\n        \"\\\"echo\\\" \\\"\\\\\\\" \\\\\\\\\\\\\\\" \\\\\\\\\\\" \\\\\"\n    );\n    assert_eq!(\n        test_wrapper(\"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\", &[], false),\n        \"\\\"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\\\"\"\n    );\n}\n"],["2547","use crate::os::windows::prelude::*;\n\nuse crate::ffi::OsStr;\nuse crate::io::{self, IoSlice, IoSliceMut};\nuse crate::mem;\nuse crate::path::Path;\nuse crate::ptr;\nuse crate::slice;\nuse crate::sync::atomic::AtomicUsize;\nuse crate::sync::atomic::Ordering::SeqCst;\nuse crate::sys::c;\nuse crate::sys::fs::{File, OpenOptions};\nuse crate::sys::handle::Handle;\nuse crate::sys::hashmap_random_keys;\n\n////////////////////////////////////////////////////////////////////////////////\n// Anonymous pipes\n////////////////////////////////////////////////////////////////////////////////\n\npub struct AnonPipe {\n    inner: Handle,\n}\n\npub struct Pipes {\n    pub ours: AnonPipe,\n    pub theirs: AnonPipe,\n}\n\n/// Although this looks similar to `anon_pipe` in the Unix module it's actually\n/// subtly different. Here we'll return two pipes in the `Pipes` return value,\n/// but one is intended for \"us\" where as the other is intended for \"someone\n/// else\".\n///\n/// Currently the only use case for this function is pipes for stdio on\n/// processes in the standard library, so \"ours\" is the one that'll stay in our\n/// process whereas \"theirs\" will be inherited to a child.\n///\n/// The ours/theirs pipes are *not* specifically readable or writable. Each\n/// one only supports a read or a write, but which is which depends on the\n/// boolean flag given. If `ours_readable` is `true`, then `ours` is readable and\n/// `theirs` is writable. Conversely, if `ours_readable` is `false`, then `ours`\n/// is writable and `theirs` is readable.\n///\n/// Also note that the `ours` pipe is always a handle opened up in overlapped\n/// mode. This means that technically speaking it should only ever be used\n/// with `OVERLAPPED` instances, but also works out ok if it's only ever used\n/// once at a time (which we do indeed guarantee).\npub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Result<Pipes> {\n    // Note that we specifically do *not* use `CreatePipe` here because\n    // unfortunately the anonymous pipes returned do not support overlapped\n    // operations. Instead, we create a \"hopefully unique\" name and create a\n    // named pipe which has overlapped operations enabled.\n    //\n    // Once we do this, we connect do it as usual via `CreateFileW`, and then\n    // we return those reader/writer halves. Note that the `ours` pipe return\n    // value is always the named pipe, whereas `theirs` is just the normal file.\n    // This should hopefully shield us from child processes which assume their\n    // stdout is a named pipe, which would indeed be odd!\n    unsafe {\n        let ours;\n        let mut name;\n        let mut tries = 0;\n        let mut reject_remote_clients_flag = c::PIPE_REJECT_REMOTE_CLIENTS;\n        loop {\n            tries += 1;\n            name = format!(\n                r\"\\\\.\\pipe\\__rust_anonymous_pipe1__.{}.{}\",\n                c::GetCurrentProcessId(),\n                random_number()\n            );\n            let wide_name = OsStr::new(&name).encode_wide().chain(Some(0)).collect::<Vec<_>>();\n            let mut flags = c::FILE_FLAG_FIRST_PIPE_INSTANCE | c::FILE_FLAG_OVERLAPPED;\n            if ours_readable {\n                flags |= c::PIPE_ACCESS_INBOUND;\n            } else {\n                flags |= c::PIPE_ACCESS_OUTBOUND;\n            }\n\n            let handle = c::CreateNamedPipeW(\n                wide_name.as_ptr(),\n                flags,\n                c::PIPE_TYPE_BYTE\n                    | c::PIPE_READMODE_BYTE\n                    | c::PIPE_WAIT\n                    | reject_remote_clients_flag,\n                1,\n                4096,\n                4096,\n                0,\n                ptr::null_mut(),\n            );\n\n            // We pass the `FILE_FLAG_FIRST_PIPE_INSTANCE` flag above, and we're\n            // also just doing a best effort at selecting a unique name. If\n            // `ERROR_ACCESS_DENIED` is returned then it could mean that we\n            // accidentally conflicted with an already existing pipe, so we try\n            // again.\n            //\n            // Don't try again too much though as this could also perhaps be a\n            // legit error.\n            // If `ERROR_INVALID_PARAMETER` is returned, this probably means we're\n            // running on pre-Vista version where `PIPE_REJECT_REMOTE_CLIENTS` is\n            // not supported, so we continue retrying without it. This implies\n            // reduced security on Windows versions older than Vista by allowing\n            // connections to this pipe from remote machines.\n            // Proper fix would increase the number of FFI imports and introduce\n            // significant amount of Windows XP specific code with no clean\n            // testing strategy\n            // For more info, see https://github.com/rust-lang/rust/pull/37677.\n            if handle == c::INVALID_HANDLE_VALUE {\n                let err = io::Error::last_os_error();\n                let raw_os_err = err.raw_os_error();\n                if tries < 10 {\n                    if raw_os_err == Some(c::ERROR_ACCESS_DENIED as i32) {\n                        continue;\n                    } else if reject_remote_clients_flag != 0\n                        && raw_os_err == Some(c::ERROR_INVALID_PARAMETER as i32)\n                    {\n                        reject_remote_clients_flag = 0;\n                        tries -= 1;\n                        continue;\n                    }\n                }\n                return Err(err);\n            }\n            ours = Handle::new(handle);\n            break;\n        }\n\n        // Connect to the named pipe we just created. This handle is going to be\n        // returned in `theirs`, so if `ours` is readable we want this to be\n        // writable, otherwise if `ours` is writable we want this to be\n        // readable.\n        //\n        // Additionally we don't enable overlapped mode on this because most\n        // client processes aren't enabled to work with that.\n        let mut opts = OpenOptions::new();\n        opts.write(ours_readable);\n        opts.read(!ours_readable);\n        opts.share_mode(0);\n        let size = mem::size_of::<c::SECURITY_ATTRIBUTES>();\n        let mut sa = c::SECURITY_ATTRIBUTES {\n            nLength: size as c::DWORD,\n            lpSecurityDescriptor: ptr::null_mut(),\n            bInheritHandle: their_handle_inheritable as i32,\n        };\n        opts.security_attributes(&mut sa);\n        let theirs = File::open(Path::new(&name), &opts)?;\n        let theirs = AnonPipe { inner: theirs.into_handle() };\n\n        Ok(Pipes {\n            ours: AnonPipe { inner: ours },\n            theirs: AnonPipe { inner: theirs.into_handle() },\n        })\n    }\n}\n\nfn random_number() -> usize {\n    static N: AtomicUsize = AtomicUsize::new(0);\n    loop {\n        if N.load(SeqCst) != 0 {\n            return N.fetch_add(1, SeqCst);\n        }\n\n        N.store(hashmap_random_keys().0 as usize, SeqCst);\n    }\n}\n\nimpl AnonPipe {\n    pub fn handle(&self) -> &Handle {\n        &self.inner\n    }\n    pub fn into_handle(self) -> Handle {\n        self.inner\n    }\n\n    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n\n    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.write_vectored(bufs)\n    }\n\n    #[inline]\n    pub fn is_write_vectored(&self) -> bool {\n        self.inner.is_write_vectored()\n    }\n}\n\npub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n    let p1 = p1.into_handle();\n    let p2 = p2.into_handle();\n\n    let mut p1 = AsyncPipe::new(p1, v1)?;\n    let mut p2 = AsyncPipe::new(p2, v2)?;\n    let objs = [p1.event.raw(), p2.event.raw()];\n\n    // In a loop we wait for either pipe's scheduled read operation to complete.\n    // If the operation completes with 0 bytes, that means EOF was reached, in\n    // which case we just finish out the other pipe entirely.\n    //\n    // Note that overlapped I/O is in general super unsafe because we have to\n    // be careful to ensure that all pointers in play are valid for the entire\n    // duration of the I/O operation (where tons of operations can also fail).\n    // The destructor for `AsyncPipe` ends up taking care of most of this.\n    loop {\n        let res = unsafe { c::WaitForMultipleObjects(2, objs.as_ptr(), c::FALSE, c::INFINITE) };\n        if res == c::WAIT_OBJECT_0 {\n            if !p1.result()? || !p1.schedule_read()? {\n                return p2.finish();\n            }\n        } else if res == c::WAIT_OBJECT_0 + 1 {\n            if !p2.result()? || !p2.schedule_read()? {\n                return p1.finish();\n            }\n        } else {\n            return Err(io::Error::last_os_error());\n        }\n    }\n}\n\nstruct AsyncPipe<'a> {\n    pipe: Handle,\n    event: Handle,\n    overlapped: Box<c::OVERLAPPED>, // needs a stable address\n    dst: &'a mut Vec<u8>,\n    state: State,\n}\n\n#[derive(PartialEq, Debug)]\nenum State {\n    NotReading,\n    Reading,\n    Read(usize),\n}\n\nimpl<'a> AsyncPipe<'a> {\n    fn new(pipe: Handle, dst: &'a mut Vec<u8>) -> io::Result<AsyncPipe<'a>> {\n        // Create an event which we'll use to coordinate our overlapped\n        // operations, this event will be used in WaitForMultipleObjects\n        // and passed as part of the OVERLAPPED handle.\n        //\n        // Note that we do a somewhat clever thing here by flagging the\n        // event as being manually reset and setting it initially to the\n        // signaled state. This means that we'll naturally fall through the\n        // WaitForMultipleObjects call above for pipes created initially,\n        // and the only time an even will go back to \"unset\" will be once an\n        // I/O operation is successfully scheduled (what we want).\n        let event = Handle::new_event(true, true)?;\n        let mut overlapped: Box<c::OVERLAPPED> = unsafe { Box::new(mem::zeroed()) };\n        overlapped.hEvent = event.raw();\n        Ok(AsyncPipe { pipe, overlapped, event, dst, state: State::NotReading })\n    }\n\n    /// Executes an overlapped read operation.\n    ///\n    /// Must not currently be reading, and returns whether the pipe is currently\n    /// at EOF or not. If the pipe is not at EOF then `result()` must be called\n    /// to complete the read later on (may block), but if the pipe is at EOF\n    /// then `result()` should not be called as it will just block forever.\n    fn schedule_read(&mut self) -> io::Result<bool> {\n        assert_eq!(self.state, State::NotReading);\n        let amt = unsafe {\n            let slice = slice_to_end(self.dst);\n            self.pipe.read_overlapped(slice, &mut *self.overlapped)?\n        };\n\n        // If this read finished immediately then our overlapped event will\n        // remain signaled (it was signaled coming in here) and we'll progress\n        // down to the method below.\n        //\n        // Otherwise the I/O operation is scheduled and the system set our event\n        // to not signaled, so we flag ourselves into the reading state and move\n        // on.\n        self.state = match amt {\n            Some(0) => return Ok(false),\n            Some(amt) => State::Read(amt),\n            None => State::Reading,\n        };\n        Ok(true)\n    }\n\n    /// Wait for the result of the overlapped operation previously executed.\n    ///\n    /// Takes a parameter `wait` which indicates if this pipe is currently being\n    /// read whether the function should block waiting for the read to complete.\n    ///\n    /// Returns values:\n    ///\n    /// * `true` - finished any pending read and the pipe is not at EOF (keep\n    ///            going)\n    /// * `false` - finished any pending read and pipe is at EOF (stop issuing\n    ///             reads)\n    fn result(&mut self) -> io::Result<bool> {\n        let amt = match self.state {\n            State::NotReading => return Ok(true),\n            State::Reading => self.pipe.overlapped_result(&mut *self.overlapped, true)?,\n            State::Read(amt) => amt,\n        };\n        self.state = State::NotReading;\n        unsafe {\n            let len = self.dst.len();\n            self.dst.set_len(len + amt);\n        }\n        Ok(amt != 0)\n    }\n\n    /// Finishes out reading this pipe entirely.\n    ///\n    /// Waits for any pending and schedule read, and then calls `read_to_end`\n    /// if necessary to read all the remaining information.\n    fn finish(&mut self) -> io::Result<()> {\n        while self.result()? && self.schedule_read()? {\n            // ...\n        }\n        Ok(())\n    }\n}\n\nimpl<'a> Drop for AsyncPipe<'a> {\n    fn drop(&mut self) {\n        match self.state {\n            State::Reading => {}\n            _ => return,\n        }\n\n        // If we have a pending read operation, then we have to make sure that\n        // it's *done* before we actually drop this type. The kernel requires\n        // that the `OVERLAPPED` and buffer pointers are valid for the entire\n        // I/O operation.\n        //\n        // To do that, we call `CancelIo` to cancel any pending operation, and\n        // if that succeeds we wait for the overlapped result.\n        //\n        // If anything here fails, there's not really much we can do, so we leak\n        // the buffer/OVERLAPPED pointers to ensure we're at least memory safe.\n        if self.pipe.cancel_io().is_err() || self.result().is_err() {\n            let buf = mem::take(self.dst);\n            let overlapped = Box::new(unsafe { mem::zeroed() });\n            let overlapped = mem::replace(&mut self.overlapped, overlapped);\n            mem::forget((buf, overlapped));\n        }\n    }\n}\n\nunsafe fn slice_to_end(v: &mut Vec<u8>) -> &mut [u8] {\n    if v.capacity() == 0 {\n        v.reserve(16);\n    }\n    if v.capacity() == v.len() {\n        v.reserve(1);\n    }\n    slice::from_raw_parts_mut(v.as_mut_ptr().add(v.len()), v.capacity() - v.len())\n}\n"],["2548","//! C definitions used by libnative that don't belong in liblibc\n\n#![allow(nonstandard_style)]\n#![cfg_attr(test, allow(dead_code))]\n#![unstable(issue = \"none\", feature = \"windows_c\")]\n\nuse crate::os::raw::NonZero_c_ulong;\nuse crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\nuse crate::ptr;\n\nuse libc::{c_void, size_t, wchar_t};\n\npub use self::EXCEPTION_DISPOSITION::*;\npub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n\npub type DWORD = c_ulong;\npub type NonZeroDWORD = NonZero_c_ulong;\npub type HANDLE = LPVOID;\npub type HINSTANCE = HANDLE;\npub type HMODULE = HINSTANCE;\npub type HRESULT = LONG;\npub type BOOL = c_int;\npub type BYTE = u8;\npub type BOOLEAN = BYTE;\npub type GROUP = c_uint;\npub type LARGE_INTEGER = c_longlong;\npub type LONG = c_long;\npub type UINT = c_uint;\npub type WCHAR = u16;\npub type USHORT = c_ushort;\npub type SIZE_T = usize;\npub type WORD = u16;\npub type CHAR = c_char;\npub type ULONG_PTR = usize;\npub type ULONG = c_ulong;\npub type NTSTATUS = LONG;\npub type ACCESS_MASK = DWORD;\n\npub type LPBOOL = *mut BOOL;\npub type LPBYTE = *mut BYTE;\npub type LPCSTR = *const CHAR;\npub type LPCWSTR = *const WCHAR;\npub type LPDWORD = *mut DWORD;\npub type LPHANDLE = *mut HANDLE;\npub type LPOVERLAPPED = *mut OVERLAPPED;\npub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\npub type LPSECURITY_ATTRIBUTES = *mut SECURITY_ATTRIBUTES;\npub type LPSTARTUPINFO = *mut STARTUPINFO;\npub type LPVOID = *mut c_void;\npub type LPWCH = *mut WCHAR;\npub type LPWIN32_FIND_DATAW = *mut WIN32_FIND_DATAW;\npub type LPWSADATA = *mut WSADATA;\npub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\npub type LPWSTR = *mut WCHAR;\npub type LPFILETIME = *mut FILETIME;\npub type LPWSABUF = *mut WSABUF;\npub type LPWSAOVERLAPPED = *mut c_void;\npub type LPWSAOVERLAPPED_COMPLETION_ROUTINE = *mut c_void;\n\npub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\npub type PLARGE_INTEGER = *mut c_longlong;\npub type PSRWLOCK = *mut SRWLOCK;\n\npub type SOCKET = crate::os::windows::raw::SOCKET;\npub type socklen_t = c_int;\npub type ADDRESS_FAMILY = USHORT;\n\npub const TRUE: BOOL = 1;\npub const FALSE: BOOL = 0;\n\npub const FILE_ATTRIBUTE_READONLY: DWORD = 0x1;\npub const FILE_ATTRIBUTE_DIRECTORY: DWORD = 0x10;\npub const FILE_ATTRIBUTE_REPARSE_POINT: DWORD = 0x400;\n\npub const FILE_SHARE_DELETE: DWORD = 0x4;\npub const FILE_SHARE_READ: DWORD = 0x1;\npub const FILE_SHARE_WRITE: DWORD = 0x2;\n\npub const CREATE_ALWAYS: DWORD = 2;\npub const CREATE_NEW: DWORD = 1;\npub const OPEN_ALWAYS: DWORD = 4;\npub const OPEN_EXISTING: DWORD = 3;\npub const TRUNCATE_EXISTING: DWORD = 5;\n\npub const FILE_WRITE_DATA: DWORD = 0x00000002;\npub const FILE_APPEND_DATA: DWORD = 0x00000004;\npub const FILE_WRITE_EA: DWORD = 0x00000010;\npub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\npub const READ_CONTROL: DWORD = 0x00020000;\npub const SYNCHRONIZE: DWORD = 0x00100000;\npub const GENERIC_READ: DWORD = 0x80000000;\npub const GENERIC_WRITE: DWORD = 0x40000000;\npub const STANDARD_RIGHTS_WRITE: DWORD = READ_CONTROL;\npub const FILE_GENERIC_WRITE: DWORD = STANDARD_RIGHTS_WRITE\n    | FILE_WRITE_DATA\n    | FILE_WRITE_ATTRIBUTES\n    | FILE_WRITE_EA\n    | FILE_APPEND_DATA\n    | SYNCHRONIZE;\n\npub const FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\npub const FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\npub const SECURITY_SQOS_PRESENT: DWORD = 0x00100000;\n\npub const FIONBIO: c_ulong = 0x8004667e;\n\n#[repr(C)]\n#[derive(Copy)]\npub struct WIN32_FIND_DATAW {\n    pub dwFileAttributes: DWORD,\n    pub ftCreationTime: FILETIME,\n    pub ftLastAccessTime: FILETIME,\n    pub ftLastWriteTime: FILETIME,\n    pub nFileSizeHigh: DWORD,\n    pub nFileSizeLow: DWORD,\n    pub dwReserved0: DWORD,\n    pub dwReserved1: DWORD,\n    pub cFileName: [wchar_t; 260], // #define MAX_PATH 260\n    pub cAlternateFileName: [wchar_t; 14],\n}\nimpl Clone for WIN32_FIND_DATAW {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\npub const WSA_FLAG_OVERLAPPED: DWORD = 0x01;\npub const WSA_FLAG_NO_HANDLE_INHERIT: DWORD = 0x80;\n\npub const WSADESCRIPTION_LEN: usize = 256;\npub const WSASYS_STATUS_LEN: usize = 128;\npub const WSAPROTOCOL_LEN: DWORD = 255;\npub const INVALID_SOCKET: SOCKET = !0;\n\npub const WSAEACCES: c_int = 10013;\npub const WSAEINVAL: c_int = 10022;\npub const WSAEWOULDBLOCK: c_int = 10035;\npub const WSAEPROTOTYPE: c_int = 10041;\npub const WSAEADDRINUSE: c_int = 10048;\npub const WSAEADDRNOTAVAIL: c_int = 10049;\npub const WSAECONNABORTED: c_int = 10053;\npub const WSAECONNRESET: c_int = 10054;\npub const WSAENOTCONN: c_int = 10057;\npub const WSAESHUTDOWN: c_int = 10058;\npub const WSAETIMEDOUT: c_int = 10060;\npub const WSAECONNREFUSED: c_int = 10061;\n\npub const MAX_PROTOCOL_CHAIN: DWORD = 7;\n\npub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\npub const FSCTL_GET_REPARSE_POINT: DWORD = 0x900a8;\npub const IO_REPARSE_TAG_SYMLINK: DWORD = 0xa000000c;\npub const IO_REPARSE_TAG_MOUNT_POINT: DWORD = 0xa0000003;\npub const SYMLINK_FLAG_RELATIVE: DWORD = 0x00000001;\npub const FSCTL_SET_REPARSE_POINT: DWORD = 0x900a4;\n\npub const SYMBOLIC_LINK_FLAG_DIRECTORY: DWORD = 0x1;\npub const SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE: DWORD = 0x2;\n\n// Note that these are not actually HANDLEs, just values to pass to GetStdHandle\npub const STD_INPUT_HANDLE: DWORD = -10i32 as DWORD;\npub const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\npub const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n\npub const PROGRESS_CONTINUE: DWORD = 0;\n\n// List of Windows system error codes with descriptions:\n// https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes#system-error-codes\npub const ERROR_FILE_NOT_FOUND: DWORD = 2;\npub const ERROR_PATH_NOT_FOUND: DWORD = 3;\npub const ERROR_ACCESS_DENIED: DWORD = 5;\npub const ERROR_INVALID_HANDLE: DWORD = 6;\npub const ERROR_NOT_ENOUGH_MEMORY: DWORD = 8;\npub const ERROR_OUTOFMEMORY: DWORD = 14;\npub const ERROR_NO_MORE_FILES: DWORD = 18;\npub const ERROR_SHARING_VIOLATION: u32 = 32;\npub const ERROR_HANDLE_EOF: DWORD = 38;\npub const ERROR_FILE_EXISTS: DWORD = 80;\npub const ERROR_INVALID_PARAMETER: DWORD = 87;\npub const ERROR_BROKEN_PIPE: DWORD = 109;\npub const ERROR_CALL_NOT_IMPLEMENTED: DWORD = 120;\npub const ERROR_SEM_TIMEOUT: DWORD = 121;\npub const ERROR_INSUFFICIENT_BUFFER: DWORD = 122;\npub const ERROR_ALREADY_EXISTS: DWORD = 183;\npub const ERROR_ENVVAR_NOT_FOUND: DWORD = 203;\npub const ERROR_NO_DATA: DWORD = 232;\npub const ERROR_DRIVER_CANCEL_TIMEOUT: DWORD = 594;\npub const ERROR_OPERATION_ABORTED: DWORD = 995;\npub const ERROR_IO_PENDING: DWORD = 997;\npub const ERROR_SERVICE_REQUEST_TIMEOUT: DWORD = 1053;\npub const ERROR_COUNTER_TIMEOUT: DWORD = 1121;\npub const ERROR_TIMEOUT: DWORD = 1460;\npub const ERROR_RESOURCE_CALL_TIMED_OUT: DWORD = 5910;\npub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT: DWORD = 7012;\npub const ERROR_CTX_CLIENT_QUERY_TIMEOUT: DWORD = 7040;\npub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT: DWORD = 8014;\npub const ERROR_DS_TIMELIMIT_EXCEEDED: DWORD = 8226;\npub const DNS_ERROR_RECORD_TIMED_OUT: DWORD = 9705;\npub const ERROR_IPSEC_IKE_TIMED_OUT: DWORD = 13805;\npub const ERROR_RUNLEVEL_SWITCH_TIMEOUT: DWORD = 15402;\npub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT: DWORD = 15403;\n\npub const E_NOTIMPL: HRESULT = 0x80004001u32 as HRESULT;\n\npub const INVALID_HANDLE_VALUE: HANDLE = !0 as HANDLE;\n\npub const FACILITY_NT_BIT: DWORD = 0x1000_0000;\n\npub const FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;\npub const FORMAT_MESSAGE_FROM_HMODULE: DWORD = 0x00000800;\npub const FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;\n\npub const TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n\npub const DLL_THREAD_DETACH: DWORD = 3;\npub const DLL_PROCESS_DETACH: DWORD = 0;\n\npub const INFINITE: DWORD = !0;\n\npub const DUPLICATE_SAME_ACCESS: DWORD = 0x00000002;\n\npub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE { ptr: ptr::null_mut() };\npub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: ptr::null_mut() };\n\npub const DETACHED_PROCESS: DWORD = 0x00000008;\npub const CREATE_NEW_PROCESS_GROUP: DWORD = 0x00000200;\npub const CREATE_UNICODE_ENVIRONMENT: DWORD = 0x00000400;\npub const STARTF_USESTDHANDLES: DWORD = 0x00000100;\n\npub const AF_INET: c_int = 2;\npub const AF_INET6: c_int = 23;\npub const SD_BOTH: c_int = 2;\npub const SD_RECEIVE: c_int = 0;\npub const SD_SEND: c_int = 1;\npub const SOCK_DGRAM: c_int = 2;\npub const SOCK_STREAM: c_int = 1;\npub const SOCKET_ERROR: c_int = -1;\npub const SOL_SOCKET: c_int = 0xffff;\npub const SO_RCVTIMEO: c_int = 0x1006;\npub const SO_SNDTIMEO: c_int = 0x1005;\npub const IPPROTO_IP: c_int = 0;\npub const IPPROTO_TCP: c_int = 6;\npub const IPPROTO_IPV6: c_int = 41;\npub const TCP_NODELAY: c_int = 0x0001;\npub const IP_TTL: c_int = 4;\npub const IPV6_V6ONLY: c_int = 27;\npub const SO_ERROR: c_int = 0x1007;\npub const SO_BROADCAST: c_int = 0x0020;\npub const IP_MULTICAST_LOOP: c_int = 11;\npub const IPV6_MULTICAST_LOOP: c_int = 11;\npub const IP_MULTICAST_TTL: c_int = 10;\npub const IP_ADD_MEMBERSHIP: c_int = 12;\npub const IP_DROP_MEMBERSHIP: c_int = 13;\npub const IPV6_ADD_MEMBERSHIP: c_int = 12;\npub const IPV6_DROP_MEMBERSHIP: c_int = 13;\npub const MSG_PEEK: c_int = 0x2;\n\n#[repr(C)]\npub struct ip_mreq {\n    pub imr_multiaddr: in_addr,\n    pub imr_interface: in_addr,\n}\n\n#[repr(C)]\npub struct ipv6_mreq {\n    pub ipv6mr_multiaddr: in6_addr,\n    pub ipv6mr_interface: c_uint,\n}\n\npub const VOLUME_NAME_DOS: DWORD = 0x0;\npub const MOVEFILE_REPLACE_EXISTING: DWORD = 1;\n\npub const FILE_BEGIN: DWORD = 0;\npub const FILE_CURRENT: DWORD = 1;\npub const FILE_END: DWORD = 2;\n\npub const WAIT_OBJECT_0: DWORD = 0x00000000;\npub const WAIT_TIMEOUT: DWORD = 258;\npub const WAIT_FAILED: DWORD = 0xFFFFFFFF;\n\npub const PIPE_ACCESS_INBOUND: DWORD = 0x00000001;\npub const PIPE_ACCESS_OUTBOUND: DWORD = 0x00000002;\npub const FILE_FLAG_FIRST_PIPE_INSTANCE: DWORD = 0x00080000;\npub const FILE_FLAG_OVERLAPPED: DWORD = 0x40000000;\npub const PIPE_WAIT: DWORD = 0x00000000;\npub const PIPE_TYPE_BYTE: DWORD = 0x00000000;\npub const PIPE_REJECT_REMOTE_CLIENTS: DWORD = 0x00000008;\npub const PIPE_READMODE_BYTE: DWORD = 0x00000000;\n\npub const FD_SETSIZE: usize = 64;\n\npub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n\npub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n\n#[repr(C)]\n#[cfg(not(target_pointer_width = \"64\"))]\npub struct WSADATA {\n    pub wVersion: WORD,\n    pub wHighVersion: WORD,\n    pub szDescription: [u8; WSADESCRIPTION_LEN + 1],\n    pub szSystemStatus: [u8; WSASYS_STATUS_LEN + 1],\n    pub iMaxSockets: u16,\n    pub iMaxUdpDg: u16,\n    pub lpVendorInfo: *mut u8,\n}\n#[repr(C)]\n#[cfg(target_pointer_width = \"64\")]\npub struct WSADATA {\n    pub wVersion: WORD,\n    pub wHighVersion: WORD,\n    pub iMaxSockets: u16,\n    pub iMaxUdpDg: u16,\n    pub lpVendorInfo: *mut u8,\n    pub szDescription: [u8; WSADESCRIPTION_LEN + 1],\n    pub szSystemStatus: [u8; WSASYS_STATUS_LEN + 1],\n}\n\n#[derive(Copy, Clone)]\n#[repr(C)]\npub struct WSABUF {\n    pub len: ULONG,\n    pub buf: *mut CHAR,\n}\n\n#[repr(C)]\npub struct WSAPROTOCOL_INFO {\n    pub dwServiceFlags1: DWORD,\n    pub dwServiceFlags2: DWORD,\n    pub dwServiceFlags3: DWORD,\n    pub dwServiceFlags4: DWORD,\n    pub dwProviderFlags: DWORD,\n    pub ProviderId: GUID,\n    pub dwCatalogEntryId: DWORD,\n    pub ProtocolChain: WSAPROTOCOLCHAIN,\n    pub iVersion: c_int,\n    pub iAddressFamily: c_int,\n    pub iMaxSockAddr: c_int,\n    pub iMinSockAddr: c_int,\n    pub iSocketType: c_int,\n    pub iProtocol: c_int,\n    pub iProtocolMaxOffset: c_int,\n    pub iNetworkByteOrder: c_int,\n    pub iSecurityScheme: c_int,\n    pub dwMessageSize: DWORD,\n    pub dwProviderReserved: DWORD,\n    pub szProtocol: [u16; (WSAPROTOCOL_LEN as usize) + 1],\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct WIN32_FILE_ATTRIBUTE_DATA {\n    pub dwFileAttributes: DWORD,\n    pub ftCreationTime: FILETIME,\n    pub ftLastAccessTime: FILETIME,\n    pub ftLastWriteTime: FILETIME,\n    pub nFileSizeHigh: DWORD,\n    pub nFileSizeLow: DWORD,\n}\n\n#[repr(C)]\n#[allow(dead_code)] // we only use some variants\npub enum FILE_INFO_BY_HANDLE_CLASS {\n    FileBasicInfo = 0,\n    FileStandardInfo = 1,\n    FileNameInfo = 2,\n    FileRenameInfo = 3,\n    FileDispositionInfo = 4,\n    FileAllocationInfo = 5,\n    FileEndOfFileInfo = 6,\n    FileStreamInfo = 7,\n    FileCompressionInfo = 8,\n    FileAttributeTagInfo = 9,\n    FileIdBothDirectoryInfo = 10,        // 0xA\n    FileIdBothDirectoryRestartInfo = 11, // 0xB\n    FileIoPriorityHintInfo = 12,         // 0xC\n    FileRemoteProtocolInfo = 13,         // 0xD\n    FileFullDirectoryInfo = 14,          // 0xE\n    FileFullDirectoryRestartInfo = 15,   // 0xF\n    FileStorageInfo = 16,                // 0x10\n    FileAlignmentInfo = 17,              // 0x11\n    FileIdInfo = 18,                     // 0x12\n    FileIdExtdDirectoryInfo = 19,        // 0x13\n    FileIdExtdDirectoryRestartInfo = 20, // 0x14\n    MaximumFileInfoByHandlesClass,\n}\n\n#[repr(C)]\npub struct FILE_BASIC_INFO {\n    pub CreationTime: LARGE_INTEGER,\n    pub LastAccessTime: LARGE_INTEGER,\n    pub LastWriteTime: LARGE_INTEGER,\n    pub ChangeTime: LARGE_INTEGER,\n    pub FileAttributes: DWORD,\n}\n\n#[repr(C)]\npub struct FILE_END_OF_FILE_INFO {\n    pub EndOfFile: LARGE_INTEGER,\n}\n\n#[repr(C)]\npub struct REPARSE_DATA_BUFFER {\n    pub ReparseTag: c_uint,\n    pub ReparseDataLength: c_ushort,\n    pub Reserved: c_ushort,\n    pub rest: (),\n}\n\n#[repr(C)]\npub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n    pub SubstituteNameOffset: c_ushort,\n    pub SubstituteNameLength: c_ushort,\n    pub PrintNameOffset: c_ushort,\n    pub PrintNameLength: c_ushort,\n    pub Flags: c_ulong,\n    pub PathBuffer: WCHAR,\n}\n\n#[repr(C)]\npub struct MOUNT_POINT_REPARSE_BUFFER {\n    pub SubstituteNameOffset: c_ushort,\n    pub SubstituteNameLength: c_ushort,\n    pub PrintNameOffset: c_ushort,\n    pub PrintNameLength: c_ushort,\n    pub PathBuffer: WCHAR,\n}\n\npub type LPPROGRESS_ROUTINE = crate::option::Option<\n    unsafe extern \"system\" fn(\n        TotalFileSize: LARGE_INTEGER,\n        TotalBytesTransferred: LARGE_INTEGER,\n        StreamSize: LARGE_INTEGER,\n        StreamBytesTransferred: LARGE_INTEGER,\n        dwStreamNumber: DWORD,\n        dwCallbackReason: DWORD,\n        hSourceFile: HANDLE,\n        hDestinationFile: HANDLE,\n        lpData: LPVOID,\n    ) -> DWORD,\n>;\n\n#[repr(C)]\npub struct CONDITION_VARIABLE {\n    pub ptr: LPVOID,\n}\n#[repr(C)]\npub struct SRWLOCK {\n    pub ptr: LPVOID,\n}\n#[repr(C)]\npub struct CRITICAL_SECTION {\n    CriticalSectionDebug: LPVOID,\n    LockCount: LONG,\n    RecursionCount: LONG,\n    OwningThread: HANDLE,\n    LockSemaphore: HANDLE,\n    SpinCount: ULONG_PTR,\n}\n\n#[repr(C)]\npub struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n    pub ReparseTag: DWORD,\n    pub ReparseDataLength: DWORD,\n    pub Reserved: WORD,\n    pub ReparseTargetLength: WORD,\n    pub ReparseTargetMaximumLength: WORD,\n    pub Reserved1: WORD,\n    pub ReparseTarget: WCHAR,\n}\n\n#[repr(C)]\npub struct GUID {\n    pub Data1: DWORD,\n    pub Data2: WORD,\n    pub Data3: WORD,\n    pub Data4: [BYTE; 8],\n}\n\n#[repr(C)]\npub struct WSAPROTOCOLCHAIN {\n    pub ChainLen: c_int,\n    pub ChainEntries: [DWORD; MAX_PROTOCOL_CHAIN as usize],\n}\n\n#[repr(C)]\npub struct SECURITY_ATTRIBUTES {\n    pub nLength: DWORD,\n    pub lpSecurityDescriptor: LPVOID,\n    pub bInheritHandle: BOOL,\n}\n\n#[repr(C)]\npub struct PROCESS_INFORMATION {\n    pub hProcess: HANDLE,\n    pub hThread: HANDLE,\n    pub dwProcessId: DWORD,\n    pub dwThreadId: DWORD,\n}\n\n#[repr(C)]\npub struct STARTUPINFO {\n    pub cb: DWORD,\n    pub lpReserved: LPWSTR,\n    pub lpDesktop: LPWSTR,\n    pub lpTitle: LPWSTR,\n    pub dwX: DWORD,\n    pub dwY: DWORD,\n    pub dwXSize: DWORD,\n    pub dwYSize: DWORD,\n    pub dwXCountChars: DWORD,\n    pub dwYCountCharts: DWORD,\n    pub dwFillAttribute: DWORD,\n    pub dwFlags: DWORD,\n    pub wShowWindow: WORD,\n    pub cbReserved2: WORD,\n    pub lpReserved2: LPBYTE,\n    pub hStdInput: HANDLE,\n    pub hStdOutput: HANDLE,\n    pub hStdError: HANDLE,\n}\n\n#[repr(C)]\npub struct SOCKADDR {\n    pub sa_family: ADDRESS_FAMILY,\n    pub sa_data: [CHAR; 14],\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct FILETIME {\n    pub dwLowDateTime: DWORD,\n    pub dwHighDateTime: DWORD,\n}\n\n#[repr(C)]\npub struct OVERLAPPED {\n    pub Internal: *mut c_ulong,\n    pub InternalHigh: *mut c_ulong,\n    pub Offset: DWORD,\n    pub OffsetHigh: DWORD,\n    pub hEvent: HANDLE,\n}\n\n#[repr(C)]\n#[allow(dead_code)] // we only use some variants\npub enum ADDRESS_MODE {\n    AddrMode1616,\n    AddrMode1632,\n    AddrModeReal,\n    AddrModeFlat,\n}\n\n#[repr(C)]\npub struct SOCKADDR_STORAGE_LH {\n    pub ss_family: ADDRESS_FAMILY,\n    pub __ss_pad1: [CHAR; 6],\n    pub __ss_align: i64,\n    pub __ss_pad2: [CHAR; 112],\n}\n\n#[repr(C)]\npub struct ADDRINFOA {\n    pub ai_flags: c_int,\n    pub ai_family: c_int,\n    pub ai_socktype: c_int,\n    pub ai_protocol: c_int,\n    pub ai_addrlen: size_t,\n    pub ai_canonname: *mut c_char,\n    pub ai_addr: *mut SOCKADDR,\n    pub ai_next: *mut ADDRINFOA,\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct sockaddr_in {\n    pub sin_family: ADDRESS_FAMILY,\n    pub sin_port: USHORT,\n    pub sin_addr: in_addr,\n    pub sin_zero: [CHAR; 8],\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct sockaddr_in6 {\n    pub sin6_family: ADDRESS_FAMILY,\n    pub sin6_port: USHORT,\n    pub sin6_flowinfo: c_ulong,\n    pub sin6_addr: in6_addr,\n    pub sin6_scope_id: c_ulong,\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct in_addr {\n    pub s_addr: u32,\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct in6_addr {\n    pub s6_addr: [u8; 16],\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\n#[allow(dead_code)] // we only use some variants\npub enum EXCEPTION_DISPOSITION {\n    ExceptionContinueExecution,\n    ExceptionContinueSearch,\n    ExceptionNestedException,\n    ExceptionCollidedUnwind,\n}\n\n#[repr(C)]\n#[derive(Copy)]\npub struct fd_set {\n    pub fd_count: c_uint,\n    pub fd_array: [SOCKET; FD_SETSIZE],\n}\n\nimpl Clone for fd_set {\n    fn clone(&self) -> fd_set {\n        *self\n    }\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct timeval {\n    pub tv_sec: c_long,\n    pub tv_usec: c_long,\n}\n\n// Desktop specific functions & types\ncfg_if::cfg_if! {\nif #[cfg(not(target_vendor = \"uwp\"))] {\n    pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n    pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n    pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n\n    #[repr(C)]\n    pub struct EXCEPTION_RECORD {\n        pub ExceptionCode: DWORD,\n        pub ExceptionFlags: DWORD,\n        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n        pub ExceptionAddress: LPVOID,\n        pub NumberParameters: DWORD,\n        pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS],\n    }\n\n    pub enum CONTEXT {}\n\n    #[repr(C)]\n    pub struct EXCEPTION_POINTERS {\n        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n        pub ContextRecord: *mut CONTEXT,\n    }\n\n    pub type PVECTORED_EXCEPTION_HANDLER =\n        extern \"system\" fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n\n    #[repr(C)]\n    #[derive(Copy, Clone)]\n    pub struct CONSOLE_READCONSOLE_CONTROL {\n        pub nLength: ULONG,\n        pub nInitialChars: ULONG,\n        pub dwCtrlWakeupMask: ULONG,\n        pub dwControlKeyState: ULONG,\n    }\n\n    pub type PCONSOLE_READCONSOLE_CONTROL = *mut CONSOLE_READCONSOLE_CONTROL;\n\n    #[repr(C)]\n    pub struct BY_HANDLE_FILE_INFORMATION {\n        pub dwFileAttributes: DWORD,\n        pub ftCreationTime: FILETIME,\n        pub ftLastAccessTime: FILETIME,\n        pub ftLastWriteTime: FILETIME,\n        pub dwVolumeSerialNumber: DWORD,\n        pub nFileSizeHigh: DWORD,\n        pub nFileSizeLow: DWORD,\n        pub nNumberOfLinks: DWORD,\n        pub nFileIndexHigh: DWORD,\n        pub nFileIndexLow: DWORD,\n    }\n\n    pub type LPBY_HANDLE_FILE_INFORMATION = *mut BY_HANDLE_FILE_INFORMATION;\n    pub type LPCVOID = *const c_void;\n\n    pub const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;\n\n    pub const TOKEN_READ: DWORD = 0x20008;\n\n    #[link(name = \"advapi32\")]\n    extern \"system\" {\n        // Forbidden when targeting UWP\n        #[link_name = \"SystemFunction036\"]\n        pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n\n        // Allowed but unused by UWP\n        pub fn OpenProcessToken(\n            ProcessHandle: HANDLE,\n            DesiredAccess: DWORD,\n            TokenHandle: *mut HANDLE,\n        ) -> BOOL;\n    }\n\n    #[link(name = \"userenv\")]\n    extern \"system\" {\n        // Allowed but unused by UWP\n        pub fn GetUserProfileDirectoryW(\n            hToken: HANDLE,\n            lpProfileDir: LPWSTR,\n            lpcchSize: *mut DWORD,\n        ) -> BOOL;\n    }\n\n    #[link(name = \"kernel32\")]\n    extern \"system\" {\n        // Functions forbidden when targeting UWP\n        pub fn ReadConsoleW(\n            hConsoleInput: HANDLE,\n            lpBuffer: LPVOID,\n            nNumberOfCharsToRead: DWORD,\n            lpNumberOfCharsRead: LPDWORD,\n            pInputControl: PCONSOLE_READCONSOLE_CONTROL,\n        ) -> BOOL;\n\n        pub fn WriteConsoleW(\n            hConsoleOutput: HANDLE,\n            lpBuffer: LPCVOID,\n            nNumberOfCharsToWrite: DWORD,\n            lpNumberOfCharsWritten: LPDWORD,\n            lpReserved: LPVOID,\n        ) -> BOOL;\n\n        pub fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n        // Allowed but unused by UWP\n        pub fn GetFileInformationByHandle(\n            hFile: HANDLE,\n            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION,\n        ) -> BOOL;\n        pub fn SetHandleInformation(hObject: HANDLE, dwMask: DWORD, dwFlags: DWORD) -> BOOL;\n        pub fn AddVectoredExceptionHandler(\n            FirstHandler: ULONG,\n            VectoredHandler: PVECTORED_EXCEPTION_HANDLER,\n        ) -> LPVOID;\n        pub fn CreateHardLinkW(\n            lpSymlinkFileName: LPCWSTR,\n            lpTargetFileName: LPCWSTR,\n            lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n        ) -> BOOL;\n        pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;\n    }\n}\n}\n\n// UWP specific functions & types\ncfg_if::cfg_if! {\nif #[cfg(target_vendor = \"uwp\")] {\n    pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG: DWORD = 0x00000002;\n\n    #[repr(C)]\n    pub struct FILE_STANDARD_INFO {\n        pub AllocationSize: LARGE_INTEGER,\n        pub EndOfFile: LARGE_INTEGER,\n        pub NumberOfLinks: DWORD,\n        pub DeletePending: BOOLEAN,\n        pub Directory: BOOLEAN,\n    }\n\n    #[link(name = \"bcrypt\")]\n    extern \"system\" {\n        pub fn BCryptGenRandom(\n            hAlgorithm: LPVOID,\n            pBuffer: *mut u8,\n            cbBuffer: ULONG,\n            dwFlags: ULONG,\n        ) -> LONG;\n    }\n    #[link(name = \"kernel32\")]\n    extern \"system\" {\n        pub fn GetFileInformationByHandleEx(\n            hFile: HANDLE,\n            fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n            lpFileInformation: LPVOID,\n            dwBufferSize: DWORD,\n        ) -> BOOL;\n    }\n}\n}\n\n// Shared between Desktop & UWP\n\n#[link(name = \"kernel32\")]\nextern \"system\" {\n    pub fn GetCurrentProcessId() -> DWORD;\n    pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n    pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOL;\n    pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n    pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n\n    pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n    pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;\n    pub fn SetLastError(dwErrCode: DWORD);\n    pub fn GetCommandLineW() -> *mut LPCWSTR;\n    pub fn GetTempPathW(nBufferLength: DWORD, lpBuffer: LPCWSTR) -> DWORD;\n    pub fn GetCurrentProcess() -> HANDLE;\n    pub fn GetCurrentThread() -> HANDLE;\n    pub fn GetStdHandle(which: DWORD) -> HANDLE;\n    pub fn ExitProcess(uExitCode: c_uint) -> !;\n    pub fn DeviceIoControl(\n        hDevice: HANDLE,\n        dwIoControlCode: DWORD,\n        lpInBuffer: LPVOID,\n        nInBufferSize: DWORD,\n        lpOutBuffer: LPVOID,\n        nOutBufferSize: DWORD,\n        lpBytesReturned: LPDWORD,\n        lpOverlapped: LPOVERLAPPED,\n    ) -> BOOL;\n    pub fn CreateThread(\n        lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n        dwStackSize: SIZE_T,\n        lpStartAddress: extern \"system\" fn(*mut c_void) -> DWORD,\n        lpParameter: LPVOID,\n        dwCreationFlags: DWORD,\n        lpThreadId: LPDWORD,\n    ) -> HANDLE;\n    pub fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n    pub fn SwitchToThread() -> BOOL;\n    pub fn Sleep(dwMilliseconds: DWORD);\n    pub fn GetProcessId(handle: HANDLE) -> DWORD;\n    pub fn CopyFileExW(\n        lpExistingFileName: LPCWSTR,\n        lpNewFileName: LPCWSTR,\n        lpProgressRoutine: LPPROGRESS_ROUTINE,\n        lpData: LPVOID,\n        pbCancel: LPBOOL,\n        dwCopyFlags: DWORD,\n    ) -> BOOL;\n    pub fn FormatMessageW(\n        flags: DWORD,\n        lpSrc: LPVOID,\n        msgId: DWORD,\n        langId: DWORD,\n        buf: LPWSTR,\n        nsize: DWORD,\n        args: *const c_void,\n    ) -> DWORD;\n    pub fn TlsAlloc() -> DWORD;\n    pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n    pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n    pub fn GetLastError() -> DWORD;\n    pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;\n    pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER) -> BOOL;\n    pub fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;\n    pub fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) -> BOOL;\n    pub fn CreateProcessW(\n        lpApplicationName: LPCWSTR,\n        lpCommandLine: LPWSTR,\n        lpProcessAttributes: LPSECURITY_ATTRIBUTES,\n        lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n        bInheritHandles: BOOL,\n        dwCreationFlags: DWORD,\n        lpEnvironment: LPVOID,\n        lpCurrentDirectory: LPCWSTR,\n        lpStartupInfo: LPSTARTUPINFO,\n        lpProcessInformation: LPPROCESS_INFORMATION,\n    ) -> BOOL;\n    pub fn GetEnvironmentVariableW(n: LPCWSTR, v: LPWSTR, nsize: DWORD) -> DWORD;\n    pub fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;\n    pub fn GetEnvironmentStringsW() -> LPWCH;\n    pub fn FreeEnvironmentStringsW(env_ptr: LPWCH) -> BOOL;\n    pub fn GetModuleFileNameW(hModule: HMODULE, lpFilename: LPWSTR, nSize: DWORD) -> DWORD;\n    pub fn CreateDirectoryW(\n        lpPathName: LPCWSTR,\n        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n    ) -> BOOL;\n    pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n    pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;\n    pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n    pub fn DuplicateHandle(\n        hSourceProcessHandle: HANDLE,\n        hSourceHandle: HANDLE,\n        hTargetProcessHandle: HANDLE,\n        lpTargetHandle: LPHANDLE,\n        dwDesiredAccess: DWORD,\n        bInheritHandle: BOOL,\n        dwOptions: DWORD,\n    ) -> BOOL;\n    pub fn ReadFile(\n        hFile: HANDLE,\n        lpBuffer: LPVOID,\n        nNumberOfBytesToRead: DWORD,\n        lpNumberOfBytesRead: LPDWORD,\n        lpOverlapped: LPOVERLAPPED,\n    ) -> BOOL;\n    pub fn WriteFile(\n        hFile: HANDLE,\n        lpBuffer: LPVOID,\n        nNumberOfBytesToWrite: DWORD,\n        lpNumberOfBytesWritten: LPDWORD,\n        lpOverlapped: LPOVERLAPPED,\n    ) -> BOOL;\n    pub fn CloseHandle(hObject: HANDLE) -> BOOL;\n    pub fn MoveFileExW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD)\n    -> BOOL;\n    pub fn SetFilePointerEx(\n        hFile: HANDLE,\n        liDistanceToMove: LARGE_INTEGER,\n        lpNewFilePointer: PLARGE_INTEGER,\n        dwMoveMethod: DWORD,\n    ) -> BOOL;\n    pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;\n    pub fn CreateFileW(\n        lpFileName: LPCWSTR,\n        dwDesiredAccess: DWORD,\n        dwShareMode: DWORD,\n        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n        dwCreationDisposition: DWORD,\n        dwFlagsAndAttributes: DWORD,\n        hTemplateFile: HANDLE,\n    ) -> HANDLE;\n\n    pub fn FindFirstFileW(fileName: LPCWSTR, findFileData: LPWIN32_FIND_DATAW) -> HANDLE;\n    pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW) -> BOOL;\n    pub fn FindClose(findFile: HANDLE) -> BOOL;\n\n    pub fn GetProcAddress(handle: HMODULE, name: LPCSTR) -> *mut c_void;\n    pub fn GetModuleHandleA(lpModuleName: LPCSTR) -> HMODULE;\n    pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n\n    pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);\n\n    pub fn CreateEventW(\n        lpEventAttributes: LPSECURITY_ATTRIBUTES,\n        bManualReset: BOOL,\n        bInitialState: BOOL,\n        lpName: LPCWSTR,\n    ) -> HANDLE;\n    pub fn WaitForMultipleObjects(\n        nCount: DWORD,\n        lpHandles: *const HANDLE,\n        bWaitAll: BOOL,\n        dwMilliseconds: DWORD,\n    ) -> DWORD;\n    pub fn CreateNamedPipeW(\n        lpName: LPCWSTR,\n        dwOpenMode: DWORD,\n        dwPipeMode: DWORD,\n        nMaxInstances: DWORD,\n        nOutBufferSize: DWORD,\n        nInBufferSize: DWORD,\n        nDefaultTimeOut: DWORD,\n        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n    ) -> HANDLE;\n    pub fn CancelIo(handle: HANDLE) -> BOOL;\n    pub fn GetOverlappedResult(\n        hFile: HANDLE,\n        lpOverlapped: LPOVERLAPPED,\n        lpNumberOfBytesTransferred: LPDWORD,\n        bWait: BOOL,\n    ) -> BOOL;\n    pub fn CreateSymbolicLinkW(\n        lpSymlinkFileName: LPCWSTR,\n        lpTargetFileName: LPCWSTR,\n        dwFlags: DWORD,\n    ) -> BOOLEAN;\n    pub fn GetFinalPathNameByHandleW(\n        hFile: HANDLE,\n        lpszFilePath: LPCWSTR,\n        cchFilePath: DWORD,\n        dwFlags: DWORD,\n    ) -> DWORD;\n    pub fn SetFileInformationByHandle(\n        hFile: HANDLE,\n        FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n        lpFileInformation: LPVOID,\n        dwBufferSize: DWORD,\n    ) -> BOOL;\n    pub fn SleepConditionVariableSRW(\n        ConditionVariable: PCONDITION_VARIABLE,\n        SRWLock: PSRWLOCK,\n        dwMilliseconds: DWORD,\n        Flags: ULONG,\n    ) -> BOOL;\n\n    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n\n    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);\n    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);\n    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);\n    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);\n    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;\n    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n}\n\n#[link(name = \"ws2_32\")]\nextern \"system\" {\n    pub fn WSAStartup(wVersionRequested: WORD, lpWSAData: LPWSADATA) -> c_int;\n    pub fn WSACleanup() -> c_int;\n    pub fn WSAGetLastError() -> c_int;\n    pub fn WSADuplicateSocketW(\n        s: SOCKET,\n        dwProcessId: DWORD,\n        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n    ) -> c_int;\n    pub fn WSASend(\n        s: SOCKET,\n        lpBuffers: LPWSABUF,\n        dwBufferCount: DWORD,\n        lpNumberOfBytesSent: LPDWORD,\n        dwFlags: DWORD,\n        lpOverlapped: LPWSAOVERLAPPED,\n        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n    ) -> c_int;\n    pub fn WSARecv(\n        s: SOCKET,\n        lpBuffers: LPWSABUF,\n        dwBufferCount: DWORD,\n        lpNumberOfBytesRecvd: LPDWORD,\n        lpFlags: LPDWORD,\n        lpOverlapped: LPWSAOVERLAPPED,\n        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n    ) -> c_int;\n    pub fn WSASocketW(\n        af: c_int,\n        kind: c_int,\n        protocol: c_int,\n        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n        g: GROUP,\n        dwFlags: DWORD,\n    ) -> SOCKET;\n    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;\n    pub fn closesocket(socket: SOCKET) -> c_int;\n    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int, flags: c_int) -> c_int;\n    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int, flags: c_int) -> c_int;\n    pub fn recvfrom(\n        socket: SOCKET,\n        buf: *mut c_void,\n        len: c_int,\n        flags: c_int,\n        addr: *mut SOCKADDR,\n        addrlen: *mut c_int,\n    ) -> c_int;\n    pub fn sendto(\n        socket: SOCKET,\n        buf: *const c_void,\n        len: c_int,\n        flags: c_int,\n        addr: *const SOCKADDR,\n        addrlen: c_int,\n    ) -> c_int;\n    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;\n    pub fn accept(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> SOCKET;\n    pub fn getsockopt(\n        s: SOCKET,\n        level: c_int,\n        optname: c_int,\n        optval: *mut c_char,\n        optlen: *mut c_int,\n    ) -> c_int;\n    pub fn setsockopt(\n        s: SOCKET,\n        level: c_int,\n        optname: c_int,\n        optval: *const c_void,\n        optlen: c_int,\n    ) -> c_int;\n    pub fn getsockname(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n    pub fn getpeername(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n    pub fn bind(socket: SOCKET, address: *const SOCKADDR, address_len: socklen_t) -> c_int;\n    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int) -> c_int;\n    pub fn getaddrinfo(\n        node: *const c_char,\n        service: *const c_char,\n        hints: *const ADDRINFOA,\n        res: *mut *mut ADDRINFOA,\n    ) -> c_int;\n    pub fn freeaddrinfo(res: *mut ADDRINFOA);\n    pub fn select(\n        nfds: c_int,\n        readfds: *mut fd_set,\n        writefds: *mut fd_set,\n        exceptfds: *mut fd_set,\n        timeout: *const timeval,\n    ) -> c_int;\n}\n\n// Functions that aren't available on every version of Windows that we support,\n// but we still use them and just provide some form of a fallback implementation.\ncompat_fn! {\n    \"kernel32\":\n\n    // >= Win10 1607\n    // https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreaddescription\n    pub fn SetThreadDescription(hThread: HANDLE,\n                                lpThreadDescription: LPCWSTR) -> HRESULT {\n        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); E_NOTIMPL\n    }\n\n    // >= Win8 / Server 2012\n    // https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimepreciseasfiletime\n    pub fn GetSystemTimePreciseAsFileTime(lpSystemTimeAsFileTime: LPFILETIME)\n                                          -> () {\n        GetSystemTimeAsFileTime(lpSystemTimeAsFileTime)\n    }\n}\n\ncompat_fn! {\n    \"api-ms-win-core-synch-l1-2-0\":\n\n    // >= Windows 8 / Server 2012\n    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress\n    pub fn WaitOnAddress(\n        Address: LPVOID,\n        CompareAddress: LPVOID,\n        AddressSize: SIZE_T,\n        dwMilliseconds: DWORD\n    ) -> BOOL {\n        panic!(\"WaitOnAddress not available\")\n    }\n    pub fn WakeByAddressSingle(Address: LPVOID) -> () {\n        // If this api is unavailable, there cannot be anything waiting, because\n        // WaitOnAddress would've panicked. So it's fine to do nothing here.\n    }\n}\n\ncompat_fn! {\n    \"ntdll\":\n    pub fn NtCreateKeyedEvent(\n        KeyedEventHandle: LPHANDLE,\n        DesiredAccess: ACCESS_MASK,\n        ObjectAttributes: LPVOID,\n        Flags: ULONG\n    ) -> NTSTATUS {\n        panic!(\"keyed events not available\")\n    }\n    pub fn NtReleaseKeyedEvent(\n        EventHandle: HANDLE,\n        Key: LPVOID,\n        Alertable: BOOLEAN,\n        Timeout: PLARGE_INTEGER\n    ) -> NTSTATUS {\n        panic!(\"keyed events not available\")\n    }\n    pub fn NtWaitForKeyedEvent(\n        EventHandle: HANDLE,\n        Key: LPVOID,\n        Alertable: BOOLEAN,\n        Timeout: PLARGE_INTEGER\n    ) -> NTSTATUS {\n        panic!(\"keyed events not available\")\n    }\n}\n"],["2549","#![unstable(issue = \"none\", feature = \"windows_stdio\")]\n\nuse crate::char::decode_utf16;\nuse crate::cmp;\nuse crate::io;\nuse crate::ptr;\nuse crate::str;\nuse crate::sys::c;\nuse crate::sys::cvt;\nuse crate::sys::handle::Handle;\n\n// Don't cache handles but get them fresh for every read/write. This allows us to track changes to\n// the value over time (such as if a process calls `SetStdHandle` while it's running). See #40490.\npub struct Stdin {\n    surrogate: u16,\n}\npub struct Stdout;\npub struct Stderr;\n\n// Apparently Windows doesn't handle large reads on stdin or writes to stdout/stderr well (see\n// #13304 for details).\n//\n// From MSDN (2011): \"The storage for this buffer is allocated from a shared heap for the\n// process that is 64 KB in size. The maximum size of the buffer will depend on heap usage.\"\n//\n// We choose the cap at 8 KiB because libuv does the same, and it seems to be acceptable so far.\nconst MAX_BUFFER_SIZE: usize = 8192;\n\n// The standard buffer size of BufReader for Stdin should be able to hold 3x more bytes than there\n// are `u16`'s in MAX_BUFFER_SIZE. This ensures the read data can always be completely decoded from\n// UTF-16 to UTF-8.\npub const STDIN_BUF_SIZE: usize = MAX_BUFFER_SIZE / 2 * 3;\n\npub fn get_handle(handle_id: c::DWORD) -> io::Result<c::HANDLE> {\n    let handle = unsafe { c::GetStdHandle(handle_id) };\n    if handle == c::INVALID_HANDLE_VALUE {\n        Err(io::Error::last_os_error())\n    } else if handle.is_null() {\n        Err(io::Error::from_raw_os_error(c::ERROR_INVALID_HANDLE as i32))\n    } else {\n        Ok(handle)\n    }\n}\n\nfn is_console(handle: c::HANDLE) -> bool {\n    // `GetConsoleMode` will return false (0) if this is a pipe (we don't care about the reported\n    // mode). This will only detect Windows Console, not other terminals connected to a pipe like\n    // MSYS. Which is exactly what we need, as only Windows Console needs a conversion to UTF-16.\n    let mut mode = 0;\n    unsafe { c::GetConsoleMode(handle, &mut mode) != 0 }\n}\n\nfn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n    let handle = get_handle(handle_id)?;\n    if !is_console(handle) {\n        let handle = Handle::new(handle);\n        let ret = handle.write(data);\n        handle.into_raw(); // Don't close the handle\n        return ret;\n    }\n\n    // As the console is meant for presenting text, we assume bytes of `data` come from a string\n    // and are encoded as UTF-8, which needs to be encoded as UTF-16.\n    //\n    // If the data is not valid UTF-8 we write out as many bytes as are valid.\n    // Only when there are no valid bytes (which will happen on the next call), return an error.\n    let len = cmp::min(data.len(), MAX_BUFFER_SIZE / 2);\n    let utf8 = match str::from_utf8(&data[..len]) {\n        Ok(s) => s,\n        Err(ref e) if e.valid_up_to() == 0 => {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidData,\n                &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n            ));\n        }\n        Err(e) => str::from_utf8(&data[..e.valid_up_to()]).unwrap(),\n    };\n    let mut utf16 = [0u16; MAX_BUFFER_SIZE / 2];\n    let mut len_utf16 = 0;\n    for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n        *dest = chr;\n        len_utf16 += 1;\n    }\n    let utf16 = &utf16[..len_utf16];\n\n    let mut written = write_u16s(handle, &utf16)?;\n\n    // Figure out how many bytes of as UTF-8 were written away as UTF-16.\n    if written == utf16.len() {\n        Ok(utf8.len())\n    } else {\n        // Make sure we didn't end up writing only half of a surrogate pair (even though the chance\n        // is tiny). Because it is not possible for user code to re-slice `data` in such a way that\n        // a missing surrogate can be produced (and also because of the UTF-8 validation above),\n        // write the missing surrogate out now.\n        // Buffering it would mean we have to lie about the number of bytes written.\n        let first_char_remaining = utf16[written];\n        if first_char_remaining >= 0xDCEE && first_char_remaining <= 0xDFFF {\n            // low surrogate\n            // We just hope this works, and give up otherwise\n            let _ = write_u16s(handle, &utf16[written..written + 1]);\n            written += 1;\n        }\n        // Calculate the number of bytes of `utf8` that were actually written.\n        let mut count = 0;\n        for ch in utf16[..written].iter() {\n            count += match ch {\n                0x0000..=0x007F => 1,\n                0x0080..=0x07FF => 2,\n                0xDCEE..=0xDFFF => 1, // Low surrogate. We already counted 3 bytes for the other.\n                _ => 3,\n            };\n        }\n        debug_assert!(String::from_utf16(&utf16[..written]).unwrap() == utf8[..count]);\n        Ok(count)\n    }\n}\n\nfn write_u16s(handle: c::HANDLE, data: &[u16]) -> io::Result<usize> {\n    let mut written = 0;\n    cvt(unsafe {\n        c::WriteConsoleW(\n            handle,\n            data.as_ptr() as c::LPCVOID,\n            data.len() as u32,\n            &mut written,\n            ptr::null_mut(),\n        )\n    })?;\n    Ok(written as usize)\n}\n\nimpl Stdin {\n    pub const fn new() -> Stdin {\n        Stdin { surrogate: 0 }\n    }\n}\n\nimpl io::Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let handle = get_handle(c::STD_INPUT_HANDLE)?;\n        if !is_console(handle) {\n            let handle = Handle::new(handle);\n            let ret = handle.read(buf);\n            handle.into_raw(); // Don't close the handle\n            return ret;\n        }\n\n        if buf.len() == 0 {\n            return Ok(0);\n        } else if buf.len() < 4 {\n            return Err(io::Error::new_const(\n                io::ErrorKind::InvalidInput,\n                &\"Windows stdin in console mode does not support a buffer too small to \\\n                 guarantee holding one arbitrary UTF-8 character (4 bytes)\",\n            ));\n        }\n\n        let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n        // In the worst case, an UTF-8 string can take 3 bytes for every `u16` of an UTF-16. So\n        // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n        // lost.\n        let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n        let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n\n        utf16_to_utf8(&utf16_buf[..read], buf)\n    }\n}\n\n// We assume that if the last `u16` is an unpaired surrogate they got sliced apart by our\n// buffer size, and keep it around for the next read hoping to put them together.\n// This is a best effort, and may not work if we are not the only reader on Stdin.\nfn read_u16s_fixup_surrogates(\n    handle: c::HANDLE,\n    buf: &mut [u16],\n    mut amount: usize,\n    surrogate: &mut u16,\n) -> io::Result<usize> {\n    // Insert possibly remaining unpaired surrogate from last read.\n    let mut start = 0;\n    if *surrogate != 0 {\n        buf[0] = *surrogate;\n        *surrogate = 0;\n        start = 1;\n        if amount == 1 {\n            // Special case: `Stdin::read` guarantees we can always read at least one new `u16`\n            // and combine it with an unpaired surrogate, because the UTF-8 buffer is at least\n            // 4 bytes.\n            amount = 2;\n        }\n    }\n    let mut amount = read_u16s(handle, &mut buf[start..amount])? + start;\n\n    if amount > 0 {\n        let last_char = buf[amount - 1];\n        if last_char >= 0xD800 && last_char <= 0xDBFF {\n            // high surrogate\n            *surrogate = last_char;\n            amount -= 1;\n        }\n    }\n    Ok(amount)\n}\n\nfn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n    // Configure the `pInputControl` parameter to not only return on `\\r\\n` but also Ctrl-Z, the\n    // traditional DOS method to indicate end of character stream / user input (SUB).\n    // See #38274 and https://stackoverflow.com/questions/43836040/win-api-readconsole.\n    const CTRL_Z: u16 = 0x1A;\n    const CTRL_Z_MASK: c::ULONG = 1 << CTRL_Z;\n    let mut input_control = c::CONSOLE_READCONSOLE_CONTROL {\n        nLength: crate::mem::size_of::<c::CONSOLE_READCONSOLE_CONTROL>() as c::ULONG,\n        nInitialChars: 0,\n        dwCtrlWakeupMask: CTRL_Z_MASK,\n        dwControlKeyState: 0,\n    };\n\n    let mut amount = 0;\n    cvt(unsafe {\n        c::ReadConsoleW(\n            handle,\n            buf.as_mut_ptr() as c::LPVOID,\n            buf.len() as u32,\n            &mut amount,\n            &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL,\n        )\n    })?;\n\n    if amount > 0 && buf[amount as usize - 1] == CTRL_Z {\n        amount -= 1;\n    }\n    Ok(amount as usize)\n}\n\n#[allow(unused)]\nfn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n    let mut written = 0;\n    for chr in decode_utf16(utf16.iter().cloned()) {\n        match chr {\n            Ok(chr) => {\n                chr.encode_utf8(&mut utf8[written..]);\n                written += chr.len_utf8();\n            }\n            Err(_) => {\n                // We can't really do any better than forget all data and return an error.\n                return Err(io::Error::new_const(\n                    io::ErrorKind::InvalidData,\n                    &\"Windows stdin in console mode does not support non-UTF-16 input; \\\n                     encountered unpaired surrogate\",\n                ));\n            }\n        }\n    }\n    Ok(written)\n}\n\nimpl Stdout {\n    pub const fn new() -> Stdout {\n        Stdout\n    }\n}\n\nimpl io::Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        write(c::STD_OUTPUT_HANDLE, buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl Stderr {\n    pub const fn new() -> Stderr {\n        Stderr\n    }\n}\n\nimpl io::Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        write(c::STD_ERROR_HANDLE, buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\npub fn is_ebadf(err: &io::Error) -> bool {\n    err.raw_os_error() == Some(c::ERROR_INVALID_HANDLE as i32)\n}\n\npub fn panic_output() -> Option<impl io::Write> {\n    Some(Stderr::new())\n}\n"],["2550","//! Platform-dependent platform abstraction.\n//!\n//! The `std::sys` module is the abstracted interface through which\n//! `std` talks to the underlying operating system. It has different\n//! implementations for different operating system families, today\n//! just Unix and Windows, and initial support for Redox.\n//!\n//! The centralization of platform-specific code in this module is\n//! enforced by the \"platform abstraction layer\" tidy script in\n//! `tools/tidy/src/pal.rs`.\n//!\n//! This module is closely related to the platform-independent system\n//! integration code in `std::sys_common`. See that module's\n//! documentation for details.\n//!\n//! In the future it would be desirable for the independent\n//! implementations of this module to be extracted to their own crates\n//! that `std` can link to, thus enabling their implementation\n//! out-of-tree via crate replacement. Though due to the complex\n//! inter-dependencies within `std` that will be a challenging goal to\n//! achieve.\n\n#![allow(missing_debug_implementations)]\n\nmod common;\n\ncfg_if::cfg_if! {\n    if #[cfg(unix)] {\n        mod unix;\n        pub use self::unix::*;\n    } else if #[cfg(windows)] {\n        mod windows;\n        pub use self::windows::*;\n    } else if #[cfg(target_os = \"hermit\")] {\n        mod hermit;\n        pub use self::hermit::*;\n    } else if #[cfg(target_os = \"wasi\")] {\n        mod wasi;\n        pub use self::wasi::*;\n    } else if #[cfg(target_arch = \"wasm32\")] {\n        mod wasm;\n        pub use self::wasm::*;\n    } else if #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] {\n        mod sgx;\n        pub use self::sgx::*;\n    } else {\n        mod unsupported;\n        pub use self::unsupported::*;\n    }\n}\n\n// Import essential modules from platforms used in `std::os` when documenting.\n//\n// Note that on some platforms those modules don't compile\n// (missing things in `libc` which is empty), so they are not included in `std::os` and can be\n// omitted here as well.\n\n#[cfg(doc)]\n#[cfg(not(any(\n    all(target_arch = \"wasm32\", not(target_os = \"wasi\")),\n    all(target_vendor = \"fortanix\", target_env = \"sgx\")\n)))]\ncfg_if::cfg_if! {\n    if #[cfg(not(windows))] {\n        // On non-Windows platforms (aka linux/osx/etc) pull in a \"minimal\"\n        // amount of windows goop which ends up compiling\n\n        #[macro_use]\n        #[path = \"windows/compat.rs\"]\n        pub mod compat;\n\n        #[path = \"windows/c.rs\"]\n        pub mod c;\n    }\n}\n"],["2551","//! Traits for working with Errors.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// A note about crates and the facade:\n//\n// Originally, the `Error` trait was defined in libcore, and the impls\n// were scattered about. However, coherence objected to this\n// arrangement, because to create the blanket impls for `Box` required\n// knowing that `&str: !Error`, and we have no means to deal with that\n// sort of conflict just now. Therefore, for the time being, we have\n// moved the `Error` trait into libstd. As we evolve a sol'n to the\n// coherence challenge (e.g., specialization, neg impls, etc) we can\n// reconsider what crate these items belong in.\n\n#[cfg(test)]\nmod tests;\n\nuse core::array;\nuse core::convert::Infallible;\n\nuse crate::alloc::{AllocError, LayoutError};\nuse crate::any::TypeId;\nuse crate::backtrace::Backtrace;\nuse crate::borrow::Cow;\nuse crate::cell;\nuse crate::char;\nuse crate::fmt::{self, Debug, Display};\nuse crate::mem::transmute;\nuse crate::num;\nuse crate::str;\nuse crate::string;\nuse crate::sync::Arc;\n\n/// `Error` is a trait representing the basic expectations for error values,\n/// i.e., values of type `E` in [`Result<T, E>`].\n///\n/// Errors must describe themselves through the [`Display`] and [`Debug`]\n/// traits. Error messages are typically concise lowercase sentences without\n/// trailing punctuation:\n///\n/// ```\n/// let err = \"NaN\".parse::<u32>().unwrap_err();\n/// assert_eq!(err.to_string(), \"invalid digit found in string\");\n/// ```\n///\n/// Errors may provide cause chain information. [`Error::source()`] is generally\n/// used when errors cross \"abstraction boundaries\". If one module must report\n/// an error that is caused by an error from a lower-level module, it can allow\n/// accessing that error via [`Error::source()`]. This makes it possible for the\n/// high-level module to provide its own errors while also revealing some of the\n/// implementation for debugging via `source` chains.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Error: Debug + Display {\n    /// The lower-level source of this error, if any.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    ///\n    /// #[derive(Debug)]\n    /// struct SuperError {\n    ///     side: SuperErrorSideKick,\n    /// }\n    ///\n    /// impl fmt::Display for SuperError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"SuperError is here!\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for SuperError {\n    ///     fn source(&self) -> Option<&(dyn Error + 'static)> {\n    ///         Some(&self.side)\n    ///     }\n    /// }\n    ///\n    /// #[derive(Debug)]\n    /// struct SuperErrorSideKick;\n    ///\n    /// impl fmt::Display for SuperErrorSideKick {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"SuperErrorSideKick is here!\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for SuperErrorSideKick {}\n    ///\n    /// fn get_super_error() -> Result<(), SuperError> {\n    ///     Err(SuperError { side: SuperErrorSideKick })\n    /// }\n    ///\n    /// fn main() {\n    ///     match get_super_error() {\n    ///         Err(e) => {\n    ///             println!(\"Error: {}\", e);\n    ///             println!(\"Caused by: {}\", e.source().unwrap());\n    ///         }\n    ///         _ => println!(\"No error\"),\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"error_source\", since = \"1.30.0\")]\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\n        None\n    }\n\n    /// Gets the `TypeId` of `self`.\n    #[doc(hidden)]\n    #[unstable(\n        feature = \"error_type_id\",\n        reason = \"this is memory-unsafe to override in user code\",\n        issue = \"60784\"\n    )]\n    fn type_id(&self, _: private::Internal) -> TypeId\n    where\n        Self: 'static,\n    {\n        TypeId::of::<Self>()\n    }\n\n    /// Returns a stack backtrace, if available, of where this error occurred.\n    ///\n    /// This function allows inspecting the location, in code, of where an error\n    /// happened. The returned `Backtrace` contains information about the stack\n    /// trace of the OS thread of execution of where the error originated from.\n    ///\n    /// Note that not all errors contain a `Backtrace`. Also note that a\n    /// `Backtrace` may actually be empty. For more information consult the\n    /// `Backtrace` type itself.\n    #[unstable(feature = \"backtrace\", issue = \"53487\")]\n    fn backtrace(&self) -> Option<&Backtrace> {\n        None\n    }\n\n    /// ```\n    /// if let Err(e) = \"xc\".parse::<u32>() {\n    ///     // Print `e` itself, no need for description().\n    ///     eprintln!(\"Error: {}\", e);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.42.0\", reason = \"use the Display impl or to_string()\")]\n    fn description(&self) -> &str {\n        \"description() is deprecated; use Display\"\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.33.0\",\n        reason = \"replaced by Error::source, which can support downcasting\"\n    )]\n    #[allow(missing_docs)]\n    fn cause(&self) -> Option<&dyn Error> {\n        self.source()\n    }\n}\n\nmod private {\n    // This is a hack to prevent `type_id` from being overridden by `Error`\n    // implementations, since that can enable unsound downcasting.\n    #[unstable(feature = \"error_type_id\", issue = \"60784\")]\n    #[derive(Debug)]\n    pub struct Internal;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, E: Error + 'a> From<E> for Box<dyn Error + 'a> {\n    /// Converts a type of [`Error`] into a box of dyn [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    /// use std::mem;\n    ///\n    /// #[derive(Debug)]\n    /// struct AnError;\n    ///\n    /// impl fmt::Display for AnError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f , \"An error\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for AnError {}\n    ///\n    /// let an_error = AnError;\n    /// assert!(0 == mem::size_of_val(&an_error));\n    /// let a_boxed_error = Box::<dyn Error>::from(an_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: E) -> Box<dyn Error + 'a> {\n        Box::new(err)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a type of [`Error`] + [`Send`] + [`Sync`] into a box of\n    /// dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    /// use std::mem;\n    ///\n    /// #[derive(Debug)]\n    /// struct AnError;\n    ///\n    /// impl fmt::Display for AnError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f , \"An error\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for AnError {}\n    ///\n    /// unsafe impl Send for AnError {}\n    ///\n    /// unsafe impl Sync for AnError {}\n    ///\n    /// let an_error = AnError;\n    /// assert!(0 == mem::size_of_val(&an_error));\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(an_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: E) -> Box<dyn Error + Send + Sync + 'a> {\n        Box::new(err)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<String> for Box<dyn Error + Send + Sync> {\n    /// Converts a [`String`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_string_error = \"a string error\".to_string();\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_string_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    #[inline]\n    fn from(err: String) -> Box<dyn Error + Send + Sync> {\n        struct StringError(String);\n\n        impl Error for StringError {\n            #[allow(deprecated)]\n            fn description(&self) -> &str {\n                &self.0\n            }\n        }\n\n        impl Display for StringError {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                Display::fmt(&self.0, f)\n            }\n        }\n\n        // Purposefully skip printing \"StringError(..)\"\n        impl Debug for StringError {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                Debug::fmt(&self.0, f)\n            }\n        }\n\n        Box::new(StringError(err))\n    }\n}\n\n#[stable(feature = \"string_box_error\", since = \"1.6.0\")]\nimpl From<String> for Box<dyn Error> {\n    /// Converts a [`String`] into a box of dyn [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_string_error = \"a string error\".to_string();\n    /// let a_boxed_error = Box::<dyn Error>::from(a_string_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(str_err: String) -> Box<dyn Error> {\n        let err1: Box<dyn Error + Send + Sync> = From::from(str_err);\n        let err2: Box<dyn Error> = err1;\n        err2\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// [`str`]: prim@str\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_str_error = \"a str error\";\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_str_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    #[inline]\n    fn from(err: &str) -> Box<dyn Error + Send + Sync + 'a> {\n        From::from(String::from(err))\n    }\n}\n\n#[stable(feature = \"string_box_error\", since = \"1.6.0\")]\nimpl From<&str> for Box<dyn Error> {\n    /// Converts a [`str`] into a box of dyn [`Error`].\n    ///\n    /// [`str`]: prim@str\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_str_error = \"a str error\";\n    /// let a_boxed_error = Box::<dyn Error>::from(a_str_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: &str) -> Box<dyn Error> {\n        From::from(String::from(err))\n    }\n}\n\n#[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\nimpl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a [`Cow`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    /// use std::borrow::Cow;\n    ///\n    /// let a_cow_str_error = Cow::from(\"a str error\");\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_cow_str_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: Cow<'b, str>) -> Box<dyn Error + Send + Sync + 'a> {\n        From::from(String::from(err))\n    }\n}\n\n#[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\nimpl<'a> From<Cow<'a, str>> for Box<dyn Error> {\n    /// Converts a [`Cow`] into a box of dyn [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    /// use std::borrow::Cow;\n    ///\n    /// let a_cow_str_error = Cow::from(\"a str error\");\n    /// let a_boxed_error = Box::<dyn Error>::from(a_cow_str_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: Cow<'a, str>) -> Box<dyn Error> {\n        From::from(String::from(err))\n    }\n}\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Error for ! {}\n\n#[unstable(\n    feature = \"allocator_api\",\n    reason = \"the precise API and guarantees it provides may be tweaked.\",\n    issue = \"32838\"\n)]\nimpl Error for AllocError {}\n\n#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\nimpl Error for LayoutError {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for str::ParseBoolError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"failed to parse bool\"\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for str::Utf8Error {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"invalid utf-8: corrupt contents\"\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for num::ParseIntError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        self.__description()\n    }\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl Error for num::TryFromIntError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        self.__description()\n    }\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl Error for array::TryFromSliceError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        self.__description()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for num::ParseFloatError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        self.__description()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for string::FromUtf8Error {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"invalid utf-8\"\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for string::FromUtf16Error {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"invalid utf-16\"\n    }\n}\n\n#[stable(feature = \"str_parse_error2\", since = \"1.8.0\")]\nimpl Error for Infallible {\n    fn description(&self) -> &str {\n        match *self {}\n    }\n}\n\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\nimpl Error for char::DecodeUtf16Error {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"unpaired surrogate found\"\n    }\n}\n\n#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\nimpl<'a, K: Debug + Ord, V: Debug> Error\n    for crate::collections::btree_map::OccupiedError<'a, K, V>\n{\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"key already exists\"\n    }\n}\n\n#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\nimpl<'a, K: Debug, V: Debug> Error for crate::collections::hash_map::OccupiedError<'a, K, V> {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"key already exists\"\n    }\n}\n\n#[stable(feature = \"box_error\", since = \"1.8.0\")]\nimpl<T: Error> Error for Box<T> {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        Error::description(&**self)\n    }\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn Error> {\n        Error::cause(&**self)\n    }\n\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\n        Error::source(&**self)\n    }\n}\n\n#[stable(feature = \"error_by_ref\", since = \"1.51.0\")]\nimpl<'a, T: Error + ?Sized> Error for &'a T {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        Error::description(&**self)\n    }\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn Error> {\n        Error::cause(&**self)\n    }\n\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\n        Error::source(&**self)\n    }\n\n    fn backtrace(&self) -> Option<&Backtrace> {\n        Error::backtrace(&**self)\n    }\n}\n\n#[stable(feature = \"arc_error\", since = \"1.52.0\")]\nimpl<T: Error + ?Sized> Error for Arc<T> {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        Error::description(&**self)\n    }\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn Error> {\n        Error::cause(&**self)\n    }\n\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\n        Error::source(&**self)\n    }\n\n    fn backtrace(&self) -> Option<&Backtrace> {\n        Error::backtrace(&**self)\n    }\n}\n\n#[stable(feature = \"fmt_error\", since = \"1.11.0\")]\nimpl Error for fmt::Error {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"an error occurred when formatting an argument\"\n    }\n}\n\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\nimpl Error for cell::BorrowError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"already mutably borrowed\"\n    }\n}\n\n#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\nimpl Error for cell::BorrowMutError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"already borrowed\"\n    }\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl Error for char::CharTryFromError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"converted integer out of range for `char`\"\n    }\n}\n\n#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\nimpl Error for char::ParseCharError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        self.__description()\n    }\n}\n\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\nimpl Error for alloc::collections::TryReserveError {}\n\n#[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\nimpl Error for core::time::FromSecsError {}\n\n// Copied from `any.rs`.\nimpl dyn Error + 'static {\n    /// Returns `true` if the boxed type is the same as `T`\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn is<T: Error + 'static>(&self) -> bool {\n        // Get `TypeId` of the type this function is instantiated with.\n        let t = TypeId::of::<T>();\n\n        // Get `TypeId` of the type in the trait object.\n        let boxed = self.type_id(private::Internal);\n\n        // Compare both `TypeId`s on equality.\n        t == boxed\n    }\n\n    /// Returns some reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n        if self.is::<T>() {\n            unsafe { Some(&*(self as *const dyn Error as *const T)) }\n        } else {\n            None\n        }\n    }\n\n    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n        if self.is::<T>() {\n            unsafe { Some(&mut *(self as *mut dyn Error as *mut T)) }\n        } else {\n            None\n        }\n    }\n}\n\nimpl dyn Error + 'static + Send {\n    /// Forwards to the method defined on the type `dyn Error`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn is<T: Error + 'static>(&self) -> bool {\n        <dyn Error + 'static>::is::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `dyn Error`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n        <dyn Error + 'static>::downcast_ref::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `dyn Error`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n        <dyn Error + 'static>::downcast_mut::<T>(self)\n    }\n}\n\nimpl dyn Error + 'static + Send + Sync {\n    /// Forwards to the method defined on the type `dyn Error`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn is<T: Error + 'static>(&self) -> bool {\n        <dyn Error + 'static>::is::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `dyn Error`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n        <dyn Error + 'static>::downcast_ref::<T>(self)\n    }\n\n    /// Forwards to the method defined on the type `dyn Error`.\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n        <dyn Error + 'static>::downcast_mut::<T>(self)\n    }\n}\n\nimpl dyn Error {\n    #[inline]\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    /// Attempts to downcast the box to a concrete type.\n    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n        if self.is::<T>() {\n            unsafe {\n                let raw: *mut dyn Error = Box::into_raw(self);\n                Ok(Box::from_raw(raw as *mut T))\n            }\n        } else {\n            Err(self)\n        }\n    }\n\n    /// Returns an iterator starting with the current error and continuing with\n    /// recursively calling [`Error::source`].\n    ///\n    /// If you want to omit the current error and only use its sources,\n    /// use `skip(1)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(error_iter)]\n    /// use std::error::Error;\n    /// use std::fmt;\n    ///\n    /// #[derive(Debug)]\n    /// struct A;\n    ///\n    /// #[derive(Debug)]\n    /// struct B(Option<Box<dyn Error + 'static>>);\n    ///\n    /// impl fmt::Display for A {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"A\")\n    ///     }\n    /// }\n    ///\n    /// impl fmt::Display for B {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"B\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for A {}\n    ///\n    /// impl Error for B {\n    ///     fn source(&self) -> Option<&(dyn Error + 'static)> {\n    ///         self.0.as_ref().map(|e| e.as_ref())\n    ///     }\n    /// }\n    ///\n    /// let b = B(Some(Box::new(A)));\n    ///\n    /// // let err : Box<Error> = b.into(); // or\n    /// let err = &b as &(dyn Error);\n    ///\n    /// let mut iter = err.chain();\n    ///\n    /// assert_eq!(\"B\".to_string(), iter.next().unwrap().to_string());\n    /// assert_eq!(\"A\".to_string(), iter.next().unwrap().to_string());\n    /// assert!(iter.next().is_none());\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[unstable(feature = \"error_iter\", issue = \"58520\")]\n    #[inline]\n    pub fn chain(&self) -> Chain<'_> {\n        Chain { current: Some(self) }\n    }\n}\n\n/// An iterator over an [`Error`] and its sources.\n///\n/// If you want to omit the initial error and only process\n/// its sources, use `skip(1)`.\n#[unstable(feature = \"error_iter\", issue = \"58520\")]\n#[derive(Clone, Debug)]\npub struct Chain<'a> {\n    current: Option<&'a (dyn Error + 'static)>,\n}\n\n#[unstable(feature = \"error_iter\", issue = \"58520\")]\nimpl<'a> Iterator for Chain<'a> {\n    type Item = &'a (dyn Error + 'static);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let current = self.current;\n        self.current = self.current.and_then(Error::source);\n        current\n    }\n}\n\nimpl dyn Error + Send {\n    #[inline]\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    /// Attempts to downcast the box to a concrete type.\n    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {\n        let err: Box<dyn Error> = self;\n        <dyn Error>::downcast(err).map_err(|s| unsafe {\n            // Reapply the `Send` marker.\n            transmute::<Box<dyn Error>, Box<dyn Error + Send>>(s)\n        })\n    }\n}\n\nimpl dyn Error + Send + Sync {\n    #[inline]\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    /// Attempts to downcast the box to a concrete type.\n    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Self>> {\n        let err: Box<dyn Error> = self;\n        <dyn Error>::downcast(err).map_err(|s| unsafe {\n            // Reapply the `Send + Sync` marker.\n            transmute::<Box<dyn Error>, Box<dyn Error + Send + Sync>>(s)\n        })\n    }\n}\n"],["2552","use crate::{\n    lazy::{Lazy, SyncLazy, SyncOnceCell},\n    panic,\n    sync::{\n        atomic::{AtomicUsize, Ordering::SeqCst},\n        mpsc::channel,\n        Mutex,\n    },\n    thread,\n};\n\n#[test]\nfn lazy_default() {\n    static CALLED: AtomicUsize = AtomicUsize::new(0);\n\n    struct Foo(u8);\n    impl Default for Foo {\n        fn default() -> Self {\n            CALLED.fetch_add(1, SeqCst);\n            Foo(42)\n        }\n    }\n\n    let lazy: Lazy<Mutex<Foo>> = <_>::default();\n\n    assert_eq!(CALLED.load(SeqCst), 0);\n\n    assert_eq!(lazy.lock().unwrap().0, 42);\n    assert_eq!(CALLED.load(SeqCst), 1);\n\n    lazy.lock().unwrap().0 = 21;\n\n    assert_eq!(lazy.lock().unwrap().0, 21);\n    assert_eq!(CALLED.load(SeqCst), 1);\n}\n\n#[test]\nfn lazy_poisoning() {\n    let x: Lazy<String> = Lazy::new(|| panic!(\"kaboom\"));\n    for _ in 0..2 {\n        let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n        assert!(res.is_err());\n    }\n}\n\nfn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n    thread::spawn(f).join().unwrap()\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn sync_once_cell() {\n    static ONCE_CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n\n    assert!(ONCE_CELL.get().is_none());\n\n    spawn_and_wait(|| {\n        ONCE_CELL.get_or_init(|| 92);\n        assert_eq!(ONCE_CELL.get(), Some(&92));\n    });\n\n    ONCE_CELL.get_or_init(|| panic!(\"Kabom!\"));\n    assert_eq!(ONCE_CELL.get(), Some(&92));\n}\n\n#[test]\nfn sync_once_cell_get_mut() {\n    let mut c = SyncOnceCell::new();\n    assert!(c.get_mut().is_none());\n    c.set(90).unwrap();\n    *c.get_mut().unwrap() += 2;\n    assert_eq!(c.get_mut(), Some(&mut 92));\n}\n\n#[test]\nfn sync_once_cell_get_unchecked() {\n    let c = SyncOnceCell::new();\n    c.set(92).unwrap();\n    unsafe {\n        assert_eq!(c.get_unchecked(), &92);\n    }\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn sync_once_cell_drop() {\n    static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n    struct Dropper;\n    impl Drop for Dropper {\n        fn drop(&mut self) {\n            DROP_CNT.fetch_add(1, SeqCst);\n        }\n    }\n\n    let x = SyncOnceCell::new();\n    spawn_and_wait(move || {\n        x.get_or_init(|| Dropper);\n        assert_eq!(DROP_CNT.load(SeqCst), 0);\n        drop(x);\n    });\n\n    assert_eq!(DROP_CNT.load(SeqCst), 1);\n}\n\n#[test]\nfn sync_once_cell_drop_empty() {\n    let x = SyncOnceCell::<String>::new();\n    drop(x);\n}\n\n#[test]\nfn clone() {\n    let s = SyncOnceCell::new();\n    let c = s.clone();\n    assert!(c.get().is_none());\n\n    s.set(\"hello\".to_string()).unwrap();\n    let c = s.clone();\n    assert_eq!(c.get().map(String::as_str), Some(\"hello\"));\n}\n\n#[test]\nfn get_or_try_init() {\n    let cell: SyncOnceCell<String> = SyncOnceCell::new();\n    assert!(cell.get().is_none());\n\n    let res = panic::catch_unwind(|| cell.get_or_try_init(|| -> Result<_, ()> { panic!() }));\n    assert!(res.is_err());\n    assert!(!cell.is_initialized());\n    assert!(cell.get().is_none());\n\n    assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n\n    assert_eq!(cell.get_or_try_init(|| Ok::<_, ()>(\"hello\".to_string())), Ok(&\"hello\".to_string()));\n    assert_eq!(cell.get(), Some(&\"hello\".to_string()));\n}\n\n#[test]\nfn from_impl() {\n    assert_eq!(SyncOnceCell::from(\"value\").get(), Some(&\"value\"));\n    assert_ne!(SyncOnceCell::from(\"foo\").get(), Some(&\"bar\"));\n}\n\n#[test]\nfn partialeq_impl() {\n    assert!(SyncOnceCell::from(\"value\") == SyncOnceCell::from(\"value\"));\n    assert!(SyncOnceCell::from(\"foo\") != SyncOnceCell::from(\"bar\"));\n\n    assert!(SyncOnceCell::<String>::new() == SyncOnceCell::new());\n    assert!(SyncOnceCell::<String>::new() != SyncOnceCell::from(\"value\".to_owned()));\n}\n\n#[test]\nfn into_inner() {\n    let cell: SyncOnceCell<String> = SyncOnceCell::new();\n    assert_eq!(cell.into_inner(), None);\n    let cell = SyncOnceCell::new();\n    cell.set(\"hello\".to_string()).unwrap();\n    assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn sync_lazy_new() {\n    static CALLED: AtomicUsize = AtomicUsize::new(0);\n    static SYNC_LAZY: SyncLazy<i32> = SyncLazy::new(|| {\n        CALLED.fetch_add(1, SeqCst);\n        92\n    });\n\n    assert_eq!(CALLED.load(SeqCst), 0);\n\n    spawn_and_wait(|| {\n        let y = *SYNC_LAZY - 30;\n        assert_eq!(y, 62);\n        assert_eq!(CALLED.load(SeqCst), 1);\n    });\n\n    let y = *SYNC_LAZY - 30;\n    assert_eq!(y, 62);\n    assert_eq!(CALLED.load(SeqCst), 1);\n}\n\n#[test]\nfn sync_lazy_default() {\n    static CALLED: AtomicUsize = AtomicUsize::new(0);\n\n    struct Foo(u8);\n    impl Default for Foo {\n        fn default() -> Self {\n            CALLED.fetch_add(1, SeqCst);\n            Foo(42)\n        }\n    }\n\n    let lazy: SyncLazy<Mutex<Foo>> = <_>::default();\n\n    assert_eq!(CALLED.load(SeqCst), 0);\n\n    assert_eq!(lazy.lock().unwrap().0, 42);\n    assert_eq!(CALLED.load(SeqCst), 1);\n\n    lazy.lock().unwrap().0 = 21;\n\n    assert_eq!(lazy.lock().unwrap().0, 21);\n    assert_eq!(CALLED.load(SeqCst), 1);\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn static_sync_lazy() {\n    static XS: SyncLazy<Vec<i32>> = SyncLazy::new(|| {\n        let mut xs = Vec::new();\n        xs.push(1);\n        xs.push(2);\n        xs.push(3);\n        xs\n    });\n\n    spawn_and_wait(|| {\n        assert_eq!(&*XS, &vec![1, 2, 3]);\n    });\n\n    assert_eq!(&*XS, &vec![1, 2, 3]);\n}\n\n#[test]\nfn static_sync_lazy_via_fn() {\n    fn xs() -> &'static Vec<i32> {\n        static XS: SyncOnceCell<Vec<i32>> = SyncOnceCell::new();\n        XS.get_or_init(|| {\n            let mut xs = Vec::new();\n            xs.push(1);\n            xs.push(2);\n            xs.push(3);\n            xs\n        })\n    }\n    assert_eq!(xs(), &vec![1, 2, 3]);\n}\n\n#[test]\nfn sync_lazy_poisoning() {\n    let x: SyncLazy<String> = SyncLazy::new(|| panic!(\"kaboom\"));\n    for _ in 0..2 {\n        let res = panic::catch_unwind(|| x.len());\n        assert!(res.is_err());\n    }\n}\n\n#[test]\nfn is_sync_send() {\n    fn assert_traits<T: Send + Sync>() {}\n    assert_traits::<SyncOnceCell<String>>();\n    assert_traits::<SyncLazy<String>>();\n}\n\n#[test]\nfn eval_once_macro() {\n    macro_rules! eval_once {\n        (|| -> $ty:ty {\n            $($body:tt)*\n        }) => {{\n            static ONCE_CELL: SyncOnceCell<$ty> = SyncOnceCell::new();\n            fn init() -> $ty {\n                $($body)*\n            }\n            ONCE_CELL.get_or_init(init)\n        }};\n    }\n\n    let fib: &'static Vec<i32> = eval_once! {\n        || -> Vec<i32> {\n            let mut res = vec![1, 1];\n            for i in 0..10 {\n                let next = res[i] + res[i + 1];\n                res.push(next);\n            }\n            res\n        }\n    };\n    assert_eq!(fib[5], 8)\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n    static ONCE_CELL: SyncOnceCell<String> = SyncOnceCell::new();\n\n    let n_readers = 10;\n    let n_writers = 3;\n    const MSG: &str = \"Hello, World\";\n\n    let (tx, rx) = channel();\n\n    for _ in 0..n_readers {\n        let tx = tx.clone();\n        thread::spawn(move || {\n            loop {\n                if let Some(msg) = ONCE_CELL.get() {\n                    tx.send(msg).unwrap();\n                    break;\n                }\n                #[cfg(target_env = \"sgx\")]\n                crate::thread::yield_now();\n            }\n        });\n    }\n    for _ in 0..n_writers {\n        thread::spawn(move || {\n            let _ = ONCE_CELL.set(MSG.to_owned());\n        });\n    }\n\n    for _ in 0..n_readers {\n        let msg = rx.recv().unwrap();\n        assert_eq!(msg, MSG);\n    }\n}\n\n#[test]\nfn dropck() {\n    let cell = SyncOnceCell::new();\n    {\n        let s = String::new();\n        cell.set(&s).unwrap();\n    }\n}\n"],["2553","//! Standard library macros\n//!\n//! This module contains a set of macros which are exported from the standard\n//! library. Each macro is available for use when linking against the standard\n//! library.\n\n#[doc = include_str!(\"../../core/src/macros/panic.md\")]\n#[macro_export]\n#[rustc_builtin_macro = \"std_panic\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(edition_panic)]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"std_panic_macro\")]\nmacro_rules! panic {\n    // Expands to either `$crate::panic::panic_2015` or `$crate::panic::panic_2021`\n    // depending on the edition of the caller.\n    ($($arg:tt)*) => {\n        /* compiler built-in */\n    };\n}\n\n/// Prints to the standard output.\n///\n/// Equivalent to the [`println!`] macro except that a newline is not printed at\n/// the end of the message.\n///\n/// Note that stdout is frequently line-buffered by default so it may be\n/// necessary to use [`io::stdout().flush()`][flush] to ensure the output is emitted\n/// immediately.\n///\n/// Use `print!` only for the primary output of your program. Use\n/// [`eprint!`] instead to print error and progress messages.\n///\n/// [flush]: crate::io::Write::flush\n///\n/// # Panics\n///\n/// Panics if writing to `io::stdout()` fails.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{self, Write};\n///\n/// print!(\"this \");\n/// print!(\"will \");\n/// print!(\"be \");\n/// print!(\"on \");\n/// print!(\"the \");\n/// print!(\"same \");\n/// print!(\"line \");\n///\n/// io::stdout().flush().unwrap();\n///\n/// print!(\"this string has a newline, why not choose println! instead?\\n\");\n///\n/// io::stdout().flush().unwrap();\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! print {\n    ($($arg:tt)*) => ($crate::io::_print($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard output, with a newline.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`)).\n///\n/// Use the [`format!`] syntax to write data to the standard output.\n/// See [`std::fmt`] for more information.\n///\n/// Use `println!` only for the primary output of your program. Use\n/// [`eprintln!`] instead to print error and progress messages.\n///\n/// [`std::fmt`]: crate::fmt\n///\n/// # Panics\n///\n/// Panics if writing to [`io::stdout`] fails.\n///\n/// [`io::stdout`]: crate::io::stdout\n///\n/// # Examples\n///\n/// ```\n/// println!(); // prints just a newline\n/// println!(\"hello there!\");\n/// println!(\"format {} arguments\", \"some\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints to the standard error.\n///\n/// Equivalent to the [`print!`] macro, except that output goes to\n/// [`io::stderr`] instead of [`io::stdout`]. See [`print!`] for\n/// example usage.\n///\n/// Use `eprint!` only for error and progress messages. Use `print!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: crate::io::stderr\n/// [`io::stdout`]: crate::io::stdout\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprint!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! eprint {\n    ($($arg:tt)*) => ($crate::io::_eprint($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard error, with a newline.\n///\n/// Equivalent to the [`println!`] macro, except that output goes to\n/// [`io::stderr`] instead of [`io::stdout`]. See [`println!`] for\n/// example usage.\n///\n/// Use `eprintln!` only for error and progress messages. Use `println!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: crate::io::stderr\n/// [`io::stdout`]: crate::io::stdout\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprintln!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! eprintln {\n    () => ($crate::eprint!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_eprint($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints and returns the value of a given expression for quick and dirty\n/// debugging.\n///\n/// An example:\n///\n/// ```rust\n/// let a = 2;\n/// let b = dbg!(a * 2) + 1;\n/// //      ^-- prints: [src/main.rs:2] a * 2 = 4\n/// assert_eq!(b, 5);\n/// ```\n///\n/// The macro works by using the `Debug` implementation of the type of\n/// the given expression to print the value to [stderr] along with the\n/// source location of the macro invocation as well as the source code\n/// of the expression.\n///\n/// Invoking the macro on an expression moves and takes ownership of it\n/// before returning the evaluated expression unchanged. If the type\n/// of the expression does not implement `Copy` and you don't want\n/// to give up ownership, you can instead borrow with `dbg!(&expr)`\n/// for some expression `expr`.\n///\n/// The `dbg!` macro works exactly the same in release builds.\n/// This is useful when debugging issues that only occur in release\n/// builds or when debugging in release mode is significantly faster.\n///\n/// Note that the macro is intended as a debugging tool and therefore you\n/// should avoid having uses of it in version control for long periods\n/// (other than in tests and similar).\n/// Debug output from production code is better done with other facilities\n/// such as the [`debug!`] macro from the [`log`] crate.\n///\n/// # Stability\n///\n/// The exact output printed by this macro should not be relied upon\n/// and is subject to future changes.\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Further examples\n///\n/// With a method call:\n///\n/// ```rust\n/// fn foo(n: usize) {\n///     if let Some(_) = dbg!(n.checked_sub(4)) {\n///         // ...\n///     }\n/// }\n///\n/// foo(3)\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:4] n.checked_sub(4) = None\n/// ```\n///\n/// Naive factorial implementation:\n///\n/// ```rust\n/// fn factorial(n: u32) -> u32 {\n///     if dbg!(n <= 1) {\n///         dbg!(1)\n///     } else {\n///         dbg!(n * factorial(n - 1))\n///     }\n/// }\n///\n/// dbg!(factorial(4));\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = true\n/// [src/main.rs:4] 1 = 1\n/// [src/main.rs:5] n * factorial(n - 1) = 2\n/// [src/main.rs:5] n * factorial(n - 1) = 6\n/// [src/main.rs:5] n * factorial(n - 1) = 24\n/// [src/main.rs:11] factorial(4) = 24\n/// ```\n///\n/// The `dbg!(..)` macro moves the input:\n///\n/// ```compile_fail\n/// /// A wrapper around `usize` which importantly is not Copyable.\n/// #[derive(Debug)]\n/// struct NoCopy(usize);\n///\n/// let a = NoCopy(42);\n/// let _ = dbg!(a); // <-- `a` is moved here.\n/// let _ = dbg!(a); // <-- `a` is moved again; error!\n/// ```\n///\n/// You can also use `dbg!()` without a value to just print the\n/// file and line whenever it's reached.\n///\n/// Finally, if you want to `dbg!(..)` multiple values, it will treat them as\n/// a tuple (and return it, too):\n///\n/// ```\n/// assert_eq!(dbg!(1usize, 2u32), (1, 2));\n/// ```\n///\n/// However, a single argument with a trailing comma will still not be treated\n/// as a tuple, following the convention of ignoring trailing commas in macro\n/// invocations. You can use a 1-tuple directly if you need one:\n///\n/// ```\n/// assert_eq!(1, dbg!(1u32,)); // trailing comma ignored\n/// assert_eq!((1,), dbg!((1u32,))); // 1-tuple\n/// ```\n///\n/// [stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\n/// [`debug!`]: https://docs.rs/log/*/log/macro.debug.html\n/// [`log`]: https://crates.io/crates/log\n#[macro_export]\n#[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\nmacro_rules! dbg {\n    // NOTE: We cannot use `concat!` to make a static string as a format argument\n    // of `eprintln!` because `file!` could contain a `{` or\n    // `$val` expression could be a block (`{ .. }`), in which case the `eprintln!`\n    // will be malformed.\n    () => {\n        $crate::eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n    };\n    ($val:expr $(,)?) => {\n        // Use of `match` here is intentional because it affects the lifetimes\n        // of temporaries - https://stackoverflow.com/a/48732525/1063961\n        match $val {\n            tmp => {\n                $crate::eprintln!(\"[{}:{}] {} = {:#?}\",\n                    $crate::file!(), $crate::line!(), $crate::stringify!($val), &tmp);\n                tmp\n            }\n        }\n    };\n    ($($val:expr),+ $(,)?) => {\n        ($($crate::dbg!($val)),+,)\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_approx_eq {\n    ($a:expr, $b:expr) => {{\n        let (a, b) = (&$a, &$b);\n        assert!((*a - *b).abs() < 1.0e-6, \"{} is not approximately equal to {}\", *a, *b);\n    }};\n}\n"],["2554","use super::Entry::{Occupied, Vacant};\nuse super::HashMap;\nuse super::RandomState;\nuse crate::cell::RefCell;\nuse rand::{thread_rng, Rng};\nuse realstd::collections::TryReserveError::*;\n\n// https://github.com/rust-lang/rust/issues/62301\nfn _assert_hashmap_is_unwind_safe() {\n    fn assert_unwind_safe<T: crate::panic::UnwindSafe>() {}\n    assert_unwind_safe::<HashMap<(), crate::cell::UnsafeCell<()>>>();\n}\n\n#[test]\nfn test_zero_capacities() {\n    type HM = HashMap<i32, i32>;\n\n    let m = HM::new();\n    assert_eq!(m.capacity(), 0);\n\n    let m = HM::default();\n    assert_eq!(m.capacity(), 0);\n\n    let m = HM::with_hasher(RandomState::new());\n    assert_eq!(m.capacity(), 0);\n\n    let m = HM::with_capacity(0);\n    assert_eq!(m.capacity(), 0);\n\n    let m = HM::with_capacity_and_hasher(0, RandomState::new());\n    assert_eq!(m.capacity(), 0);\n\n    let mut m = HM::new();\n    m.insert(1, 1);\n    m.insert(2, 2);\n    m.remove(&1);\n    m.remove(&2);\n    m.shrink_to_fit();\n    assert_eq!(m.capacity(), 0);\n\n    let mut m = HM::new();\n    m.reserve(0);\n    assert_eq!(m.capacity(), 0);\n}\n\n#[test]\nfn test_create_capacity_zero() {\n    let mut m = HashMap::with_capacity(0);\n\n    assert!(m.insert(1, 1).is_none());\n\n    assert!(m.contains_key(&1));\n    assert!(!m.contains_key(&0));\n}\n\n#[test]\nfn test_insert() {\n    let mut m = HashMap::new();\n    assert_eq!(m.len(), 0);\n    assert!(m.insert(1, 2).is_none());\n    assert_eq!(m.len(), 1);\n    assert!(m.insert(2, 4).is_none());\n    assert_eq!(m.len(), 2);\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert_eq!(*m.get(&2).unwrap(), 4);\n}\n\n#[test]\nfn test_clone() {\n    let mut m = HashMap::new();\n    assert_eq!(m.len(), 0);\n    assert!(m.insert(1, 2).is_none());\n    assert_eq!(m.len(), 1);\n    assert!(m.insert(2, 4).is_none());\n    assert_eq!(m.len(), 2);\n    let m2 = m.clone();\n    assert_eq!(*m2.get(&1).unwrap(), 2);\n    assert_eq!(*m2.get(&2).unwrap(), 4);\n    assert_eq!(m2.len(), 2);\n}\n\nthread_local! { static DROP_VECTOR: RefCell<Vec<i32>> = RefCell::new(Vec::new()) }\n\n#[derive(Hash, PartialEq, Eq)]\nstruct Droppable {\n    k: usize,\n}\n\nimpl Droppable {\n    fn new(k: usize) -> Droppable {\n        DROP_VECTOR.with(|slot| {\n            slot.borrow_mut()[k] += 1;\n        });\n\n        Droppable { k }\n    }\n}\n\nimpl Drop for Droppable {\n    fn drop(&mut self) {\n        DROP_VECTOR.with(|slot| {\n            slot.borrow_mut()[self.k] -= 1;\n        });\n    }\n}\n\nimpl Clone for Droppable {\n    fn clone(&self) -> Droppable {\n        Droppable::new(self.k)\n    }\n}\n\n#[test]\nfn test_drops() {\n    DROP_VECTOR.with(|slot| {\n        *slot.borrow_mut() = vec![0; 200];\n    });\n\n    {\n        let mut m = HashMap::new();\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 0);\n            }\n        });\n\n        for i in 0..100 {\n            let d1 = Droppable::new(i);\n            let d2 = Droppable::new(i + 100);\n            m.insert(d1, d2);\n        }\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 1);\n            }\n        });\n\n        for i in 0..50 {\n            let k = Droppable::new(i);\n            let v = m.remove(&k);\n\n            assert!(v.is_some());\n\n            DROP_VECTOR.with(|v| {\n                assert_eq!(v.borrow()[i], 1);\n                assert_eq!(v.borrow()[i + 100], 1);\n            });\n        }\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..50 {\n                assert_eq!(v.borrow()[i], 0);\n                assert_eq!(v.borrow()[i + 100], 0);\n            }\n\n            for i in 50..100 {\n                assert_eq!(v.borrow()[i], 1);\n                assert_eq!(v.borrow()[i + 100], 1);\n            }\n        });\n    }\n\n    DROP_VECTOR.with(|v| {\n        for i in 0..200 {\n            assert_eq!(v.borrow()[i], 0);\n        }\n    });\n}\n\n#[test]\nfn test_into_iter_drops() {\n    DROP_VECTOR.with(|v| {\n        *v.borrow_mut() = vec![0; 200];\n    });\n\n    let hm = {\n        let mut hm = HashMap::new();\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 0);\n            }\n        });\n\n        for i in 0..100 {\n            let d1 = Droppable::new(i);\n            let d2 = Droppable::new(i + 100);\n            hm.insert(d1, d2);\n        }\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 1);\n            }\n        });\n\n        hm\n    };\n\n    // By the way, ensure that cloning doesn't screw up the dropping.\n    drop(hm.clone());\n\n    {\n        let mut half = hm.into_iter().take(50);\n\n        DROP_VECTOR.with(|v| {\n            for i in 0..200 {\n                assert_eq!(v.borrow()[i], 1);\n            }\n        });\n\n        for _ in half.by_ref() {}\n\n        DROP_VECTOR.with(|v| {\n            let nk = (0..100).filter(|&i| v.borrow()[i] == 1).count();\n\n            let nv = (0..100).filter(|&i| v.borrow()[i + 100] == 1).count();\n\n            assert_eq!(nk, 50);\n            assert_eq!(nv, 50);\n        });\n    };\n\n    DROP_VECTOR.with(|v| {\n        for i in 0..200 {\n            assert_eq!(v.borrow()[i], 0);\n        }\n    });\n}\n\n#[test]\nfn test_empty_remove() {\n    let mut m: HashMap<i32, bool> = HashMap::new();\n    assert_eq!(m.remove(&0), None);\n}\n\n#[test]\nfn test_empty_entry() {\n    let mut m: HashMap<i32, bool> = HashMap::new();\n    match m.entry(0) {\n        Occupied(_) => panic!(),\n        Vacant(_) => {}\n    }\n    assert!(*m.entry(0).or_insert(true));\n    assert_eq!(m.len(), 1);\n}\n\n#[test]\nfn test_empty_iter() {\n    let mut m: HashMap<i32, bool> = HashMap::new();\n    assert_eq!(m.drain().next(), None);\n    assert_eq!(m.keys().next(), None);\n    assert_eq!(m.values().next(), None);\n    assert_eq!(m.values_mut().next(), None);\n    assert_eq!(m.iter().next(), None);\n    assert_eq!(m.iter_mut().next(), None);\n    assert_eq!(m.len(), 0);\n    assert!(m.is_empty());\n    assert_eq!(m.into_iter().next(), None);\n}\n\n#[test]\nfn test_lots_of_insertions() {\n    let mut m = HashMap::new();\n\n    // Try this a few times to make sure we never screw up the hashmap's\n    // internal state.\n    for _ in 0..10 {\n        assert!(m.is_empty());\n\n        for i in 1..1001 {\n            assert!(m.insert(i, i).is_none());\n\n            for j in 1..=i {\n                let r = m.get(&j);\n                assert_eq!(r, Some(&j));\n            }\n\n            for j in i + 1..1001 {\n                let r = m.get(&j);\n                assert_eq!(r, None);\n            }\n        }\n\n        for i in 1001..2001 {\n            assert!(!m.contains_key(&i));\n        }\n\n        // remove forwards\n        for i in 1..1001 {\n            assert!(m.remove(&i).is_some());\n\n            for j in 1..=i {\n                assert!(!m.contains_key(&j));\n            }\n\n            for j in i + 1..1001 {\n                assert!(m.contains_key(&j));\n            }\n        }\n\n        for i in 1..1001 {\n            assert!(!m.contains_key(&i));\n        }\n\n        for i in 1..1001 {\n            assert!(m.insert(i, i).is_none());\n        }\n\n        // remove backwards\n        for i in (1..1001).rev() {\n            assert!(m.remove(&i).is_some());\n\n            for j in i..1001 {\n                assert!(!m.contains_key(&j));\n            }\n\n            for j in 1..i {\n                assert!(m.contains_key(&j));\n            }\n        }\n    }\n}\n\n#[test]\nfn test_find_mut() {\n    let mut m = HashMap::new();\n    assert!(m.insert(1, 12).is_none());\n    assert!(m.insert(2, 8).is_none());\n    assert!(m.insert(5, 14).is_none());\n    let new = 100;\n    match m.get_mut(&5) {\n        None => panic!(),\n        Some(x) => *x = new,\n    }\n    assert_eq!(m.get(&5), Some(&new));\n}\n\n#[test]\nfn test_insert_overwrite() {\n    let mut m = HashMap::new();\n    assert!(m.insert(1, 2).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert!(!m.insert(1, 3).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 3);\n}\n\n#[test]\nfn test_insert_conflicts() {\n    let mut m = HashMap::with_capacity(4);\n    assert!(m.insert(1, 2).is_none());\n    assert!(m.insert(5, 3).is_none());\n    assert!(m.insert(9, 4).is_none());\n    assert_eq!(*m.get(&9).unwrap(), 4);\n    assert_eq!(*m.get(&5).unwrap(), 3);\n    assert_eq!(*m.get(&1).unwrap(), 2);\n}\n\n#[test]\nfn test_conflict_remove() {\n    let mut m = HashMap::with_capacity(4);\n    assert!(m.insert(1, 2).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert!(m.insert(5, 3).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert_eq!(*m.get(&5).unwrap(), 3);\n    assert!(m.insert(9, 4).is_none());\n    assert_eq!(*m.get(&1).unwrap(), 2);\n    assert_eq!(*m.get(&5).unwrap(), 3);\n    assert_eq!(*m.get(&9).unwrap(), 4);\n    assert!(m.remove(&1).is_some());\n    assert_eq!(*m.get(&9).unwrap(), 4);\n    assert_eq!(*m.get(&5).unwrap(), 3);\n}\n\n#[test]\nfn test_is_empty() {\n    let mut m = HashMap::with_capacity(4);\n    assert!(m.insert(1, 2).is_none());\n    assert!(!m.is_empty());\n    assert!(m.remove(&1).is_some());\n    assert!(m.is_empty());\n}\n\n#[test]\nfn test_remove() {\n    let mut m = HashMap::new();\n    m.insert(1, 2);\n    assert_eq!(m.remove(&1), Some(2));\n    assert_eq!(m.remove(&1), None);\n}\n\n#[test]\nfn test_remove_entry() {\n    let mut m = HashMap::new();\n    m.insert(1, 2);\n    assert_eq!(m.remove_entry(&1), Some((1, 2)));\n    assert_eq!(m.remove(&1), None);\n}\n\n#[test]\nfn test_iterate() {\n    let mut m = HashMap::with_capacity(4);\n    for i in 0..32 {\n        assert!(m.insert(i, i * 2).is_none());\n    }\n    assert_eq!(m.len(), 32);\n\n    let mut observed: u32 = 0;\n\n    for (k, v) in &m {\n        assert_eq!(*v, *k * 2);\n        observed |= 1 << *k;\n    }\n    assert_eq!(observed, 0xFFFF_FFFF);\n}\n\n#[test]\nfn test_keys() {\n    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n    let map: HashMap<_, _> = vec.into_iter().collect();\n    let keys: Vec<_> = map.keys().cloned().collect();\n    assert_eq!(keys.len(), 3);\n    assert!(keys.contains(&1));\n    assert!(keys.contains(&2));\n    assert!(keys.contains(&3));\n}\n\n#[test]\nfn test_values() {\n    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n    let map: HashMap<_, _> = vec.into_iter().collect();\n    let values: Vec<_> = map.values().cloned().collect();\n    assert_eq!(values.len(), 3);\n    assert!(values.contains(&'a'));\n    assert!(values.contains(&'b'));\n    assert!(values.contains(&'c'));\n}\n\n#[test]\nfn test_values_mut() {\n    let vec = vec![(1, 1), (2, 2), (3, 3)];\n    let mut map: HashMap<_, _> = vec.into_iter().collect();\n    for value in map.values_mut() {\n        *value = (*value) * 2\n    }\n    let values: Vec<_> = map.values().cloned().collect();\n    assert_eq!(values.len(), 3);\n    assert!(values.contains(&2));\n    assert!(values.contains(&4));\n    assert!(values.contains(&6));\n}\n\n#[test]\nfn test_into_keys() {\n    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n    let map: HashMap<_, _> = vec.into_iter().collect();\n    let keys: Vec<_> = map.into_keys().collect();\n\n    assert_eq!(keys.len(), 3);\n    assert!(keys.contains(&1));\n    assert!(keys.contains(&2));\n    assert!(keys.contains(&3));\n}\n\n#[test]\nfn test_into_values() {\n    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n    let map: HashMap<_, _> = vec.into_iter().collect();\n    let values: Vec<_> = map.into_values().collect();\n\n    assert_eq!(values.len(), 3);\n    assert!(values.contains(&'a'));\n    assert!(values.contains(&'b'));\n    assert!(values.contains(&'c'));\n}\n\n#[test]\nfn test_find() {\n    let mut m = HashMap::new();\n    assert!(m.get(&1).is_none());\n    m.insert(1, 2);\n    match m.get(&1) {\n        None => panic!(),\n        Some(v) => assert_eq!(*v, 2),\n    }\n}\n\n#[test]\nfn test_eq() {\n    let mut m1 = HashMap::new();\n    m1.insert(1, 2);\n    m1.insert(2, 3);\n    m1.insert(3, 4);\n\n    let mut m2 = HashMap::new();\n    m2.insert(1, 2);\n    m2.insert(2, 3);\n\n    assert!(m1 != m2);\n\n    m2.insert(3, 4);\n\n    assert_eq!(m1, m2);\n}\n\n#[test]\nfn test_show() {\n    let mut map = HashMap::new();\n    let empty: HashMap<i32, i32> = HashMap::new();\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n\n    let map_str = format!(\"{:?}\", map);\n\n    assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n    assert_eq!(format!(\"{:?}\", empty), \"{}\");\n}\n\n#[test]\nfn test_reserve_shrink_to_fit() {\n    let mut m = HashMap::new();\n    m.insert(0, 0);\n    m.remove(&0);\n    assert!(m.capacity() >= m.len());\n    for i in 0..128 {\n        m.insert(i, i);\n    }\n    m.reserve(256);\n\n    let usable_cap = m.capacity();\n    for i in 128..(128 + 256) {\n        m.insert(i, i);\n        assert_eq!(m.capacity(), usable_cap);\n    }\n\n    for i in 100..(128 + 256) {\n        assert_eq!(m.remove(&i), Some(i));\n    }\n    m.shrink_to_fit();\n\n    assert_eq!(m.len(), 100);\n    assert!(!m.is_empty());\n    assert!(m.capacity() >= m.len());\n\n    for i in 0..100 {\n        assert_eq!(m.remove(&i), Some(i));\n    }\n    m.shrink_to_fit();\n    m.insert(0, 0);\n\n    assert_eq!(m.len(), 1);\n    assert!(m.capacity() >= m.len());\n    assert_eq!(m.remove(&0), Some(0));\n}\n\n#[test]\nfn test_from_iter() {\n    let xs = [(1, 1), (2, 2), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    for &(k, v) in &xs {\n        assert_eq!(map.get(&k), Some(&v));\n    }\n\n    assert_eq!(map.iter().len(), xs.len() - 1);\n}\n\n#[test]\nfn test_size_hint() {\n    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let mut iter = map.iter();\n\n    for _ in iter.by_ref().take(3) {}\n\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n}\n\n#[test]\nfn test_iter_len() {\n    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let mut iter = map.iter();\n\n    for _ in iter.by_ref().take(3) {}\n\n    assert_eq!(iter.len(), 3);\n}\n\n#[test]\nfn test_mut_size_hint() {\n    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let mut iter = map.iter_mut();\n\n    for _ in iter.by_ref().take(3) {}\n\n    assert_eq!(iter.size_hint(), (3, Some(3)));\n}\n\n#[test]\nfn test_iter_mut_len() {\n    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n\n    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let mut iter = map.iter_mut();\n\n    for _ in iter.by_ref().take(3) {}\n\n    assert_eq!(iter.len(), 3);\n}\n\n#[test]\nfn test_index() {\n    let mut map = HashMap::new();\n\n    map.insert(1, 2);\n    map.insert(2, 1);\n    map.insert(3, 4);\n\n    assert_eq!(map[&2], 1);\n}\n\n#[test]\n#[should_panic]\nfn test_index_nonexistent() {\n    let mut map = HashMap::new();\n\n    map.insert(1, 2);\n    map.insert(2, 1);\n    map.insert(3, 4);\n\n    map[&4];\n}\n\n#[test]\nfn test_entry() {\n    let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n\n    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    // Existing key (insert)\n    match map.entry(1) {\n        Vacant(_) => unreachable!(),\n        Occupied(mut view) => {\n            assert_eq!(view.get(), &10);\n            assert_eq!(view.insert(100), 10);\n        }\n    }\n    assert_eq!(map.get(&1).unwrap(), &100);\n    assert_eq!(map.len(), 6);\n\n    // Existing key (update)\n    match map.entry(2) {\n        Vacant(_) => unreachable!(),\n        Occupied(mut view) => {\n            let v = view.get_mut();\n            let new_v = (*v) * 10;\n            *v = new_v;\n        }\n    }\n    assert_eq!(map.get(&2).unwrap(), &200);\n    assert_eq!(map.len(), 6);\n\n    // Existing key (take)\n    match map.entry(3) {\n        Vacant(_) => unreachable!(),\n        Occupied(view) => {\n            assert_eq!(view.remove(), 30);\n        }\n    }\n    assert_eq!(map.get(&3), None);\n    assert_eq!(map.len(), 5);\n\n    // Inexistent key (insert)\n    match map.entry(10) {\n        Occupied(_) => unreachable!(),\n        Vacant(view) => {\n            assert_eq!(*view.insert(1000), 1000);\n        }\n    }\n    assert_eq!(map.get(&10).unwrap(), &1000);\n    assert_eq!(map.len(), 6);\n}\n\n#[test]\nfn test_entry_take_doesnt_corrupt() {\n    #![allow(deprecated)] //rand\n    // Test for #19292\n    fn check(m: &HashMap<i32, ()>) {\n        for k in m.keys() {\n            assert!(m.contains_key(k), \"{} is in keys() but not in the map?\", k);\n        }\n    }\n\n    let mut m = HashMap::new();\n    let mut rng = thread_rng();\n\n    // Populate the map with some items.\n    for _ in 0..50 {\n        let x = rng.gen_range(-10, 10);\n        m.insert(x, ());\n    }\n\n    for _ in 0..1000 {\n        let x = rng.gen_range(-10, 10);\n        match m.entry(x) {\n            Vacant(_) => {}\n            Occupied(e) => {\n                e.remove();\n            }\n        }\n\n        check(&m);\n    }\n}\n\n#[test]\nfn test_extend_ref() {\n    let mut a = HashMap::new();\n    a.insert(1, \"one\");\n    let mut b = HashMap::new();\n    b.insert(2, \"two\");\n    b.insert(3, \"three\");\n\n    a.extend(&b);\n\n    assert_eq!(a.len(), 3);\n    assert_eq!(a[&1], \"one\");\n    assert_eq!(a[&2], \"two\");\n    assert_eq!(a[&3], \"three\");\n}\n\n#[test]\nfn test_capacity_not_less_than_len() {\n    let mut a = HashMap::new();\n    let mut item = 0;\n\n    for _ in 0..116 {\n        a.insert(item, 0);\n        item += 1;\n    }\n\n    assert!(a.capacity() > a.len());\n\n    let free = a.capacity() - a.len();\n    for _ in 0..free {\n        a.insert(item, 0);\n        item += 1;\n    }\n\n    assert_eq!(a.len(), a.capacity());\n\n    // Insert at capacity should cause allocation.\n    a.insert(item, 0);\n    assert!(a.capacity() > a.len());\n}\n\n#[test]\nfn test_occupied_entry_key() {\n    let mut a = HashMap::new();\n    let key = \"hello there\";\n    let value = \"value goes here\";\n    assert!(a.is_empty());\n    a.insert(key, value);\n    assert_eq!(a.len(), 1);\n    assert_eq!(a[key], value);\n\n    match a.entry(key) {\n        Vacant(_) => panic!(),\n        Occupied(e) => assert_eq!(key, *e.key()),\n    }\n    assert_eq!(a.len(), 1);\n    assert_eq!(a[key], value);\n}\n\n#[test]\nfn test_vacant_entry_key() {\n    let mut a = HashMap::new();\n    let key = \"hello there\";\n    let value = \"value goes here\";\n\n    assert!(a.is_empty());\n    match a.entry(key) {\n        Occupied(_) => panic!(),\n        Vacant(e) => {\n            assert_eq!(key, *e.key());\n            e.insert(value);\n        }\n    }\n    assert_eq!(a.len(), 1);\n    assert_eq!(a[key], value);\n}\n\n#[test]\nfn test_retain() {\n    let mut map: HashMap<i32, i32> = (0..100).map(|x| (x, x * 10)).collect();\n\n    map.retain(|&k, _| k % 2 == 0);\n    assert_eq!(map.len(), 50);\n    assert_eq!(map[&2], 20);\n    assert_eq!(map[&4], 40);\n    assert_eq!(map[&6], 60);\n}\n\n#[test]\nfn test_try_reserve() {\n    let mut empty_bytes: HashMap<u8, u8> = HashMap::new();\n\n    const MAX_USIZE: usize = usize::MAX;\n\n    if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n    } else {\n        panic!(\"usize::MAX should trigger an overflow!\");\n    }\n\n    if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n    } else {\n        panic!(\"usize::MAX / 8 should trigger an OOM!\")\n    }\n}\n\n#[test]\nfn test_raw_entry() {\n    use super::RawEntryMut::{Occupied, Vacant};\n\n    let xs = [(1i32, 10i32), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n\n    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n\n    let compute_hash = |map: &HashMap<i32, i32>, k: i32| -> u64 {\n        use core::hash::{BuildHasher, Hash, Hasher};\n\n        let mut hasher = map.hasher().build_hasher();\n        k.hash(&mut hasher);\n        hasher.finish()\n    };\n\n    // Existing key (insert)\n    match map.raw_entry_mut().from_key(&1) {\n        Vacant(_) => unreachable!(),\n        Occupied(mut view) => {\n            assert_eq!(view.get(), &10);\n            assert_eq!(view.insert(100), 10);\n        }\n    }\n    let hash1 = compute_hash(&map, 1);\n    assert_eq!(map.raw_entry().from_key(&1).unwrap(), (&1, &100));\n    assert_eq!(map.raw_entry().from_hash(hash1, |k| *k == 1).unwrap(), (&1, &100));\n    assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash1, &1).unwrap(), (&1, &100));\n    assert_eq!(map.len(), 6);\n\n    // Existing key (update)\n    match map.raw_entry_mut().from_key(&2) {\n        Vacant(_) => unreachable!(),\n        Occupied(mut view) => {\n            let v = view.get_mut();\n            let new_v = (*v) * 10;\n            *v = new_v;\n        }\n    }\n    let hash2 = compute_hash(&map, 2);\n    assert_eq!(map.raw_entry().from_key(&2).unwrap(), (&2, &200));\n    assert_eq!(map.raw_entry().from_hash(hash2, |k| *k == 2).unwrap(), (&2, &200));\n    assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash2, &2).unwrap(), (&2, &200));\n    assert_eq!(map.len(), 6);\n\n    // Existing key (take)\n    let hash3 = compute_hash(&map, 3);\n    match map.raw_entry_mut().from_key_hashed_nocheck(hash3, &3) {\n        Vacant(_) => unreachable!(),\n        Occupied(view) => {\n            assert_eq!(view.remove_entry(), (3, 30));\n        }\n    }\n    assert_eq!(map.raw_entry().from_key(&3), None);\n    assert_eq!(map.raw_entry().from_hash(hash3, |k| *k == 3), None);\n    assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash3, &3), None);\n    assert_eq!(map.len(), 5);\n\n    // Nonexistent key (insert)\n    match map.raw_entry_mut().from_key(&10) {\n        Occupied(_) => unreachable!(),\n        Vacant(view) => {\n            assert_eq!(view.insert(10, 1000), (&mut 10, &mut 1000));\n        }\n    }\n    assert_eq!(map.raw_entry().from_key(&10).unwrap(), (&10, &1000));\n    assert_eq!(map.len(), 6);\n\n    // Ensure all lookup methods produce equivalent results.\n    for k in 0..12 {\n        let hash = compute_hash(&map, k);\n        let v = map.get(&k).cloned();\n        let kv = v.as_ref().map(|v| (&k, v));\n\n        assert_eq!(map.raw_entry().from_key(&k), kv);\n        assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n\n        match map.raw_entry_mut().from_key(&k) {\n            Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n            Vacant(_) => assert_eq!(v, None),\n        }\n        match map.raw_entry_mut().from_key_hashed_nocheck(hash, &k) {\n            Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n            Vacant(_) => assert_eq!(v, None),\n        }\n        match map.raw_entry_mut().from_hash(hash, |q| *q == k) {\n            Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n            Vacant(_) => assert_eq!(v, None),\n        }\n    }\n}\n\nmod test_drain_filter {\n    use super::*;\n\n    use crate::panic::{catch_unwind, AssertUnwindSafe};\n    use crate::sync::atomic::{AtomicUsize, Ordering};\n\n    trait EqSorted: Iterator {\n        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool;\n    }\n\n    impl<T: Iterator> EqSorted for T\n    where\n        T::Item: Eq + Ord,\n    {\n        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool {\n            let mut v: Vec<_> = self.collect();\n            v.sort_unstable();\n            v.into_iter().eq(other)\n        }\n    }\n\n    #[test]\n    fn empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn consuming_nothing() {\n        let pairs = (0..3).map(|i| (i, i));\n        let mut map: HashMap<_, _> = pairs.collect();\n        assert!(map.drain_filter(|_, _| false).eq_sorted(crate::iter::empty()));\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn consuming_all() {\n        let pairs = (0..3).map(|i| (i, i));\n        let mut map: HashMap<_, _> = pairs.clone().collect();\n        assert!(map.drain_filter(|_, _| true).eq_sorted(pairs));\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn mutating_and_keeping() {\n        let pairs = (0..3).map(|i| (i, i));\n        let mut map: HashMap<_, _> = pairs.collect();\n        assert!(\n            map.drain_filter(|_, v| {\n                *v += 6;\n                false\n            })\n            .eq_sorted(crate::iter::empty())\n        );\n        assert!(map.keys().copied().eq_sorted(0..3));\n        assert!(map.values().copied().eq_sorted(6..9));\n    }\n\n    #[test]\n    fn mutating_and_removing() {\n        let pairs = (0..3).map(|i| (i, i));\n        let mut map: HashMap<_, _> = pairs.collect();\n        assert!(\n            map.drain_filter(|_, v| {\n                *v += 6;\n                true\n            })\n            .eq_sorted((0..3).map(|i| (i, i + 6)))\n        );\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn drop_panic_leak() {\n        static PREDS: AtomicUsize = AtomicUsize::new(0);\n        static DROPS: AtomicUsize = AtomicUsize::new(0);\n\n        struct D;\n        impl Drop for D {\n            fn drop(&mut self) {\n                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n                    panic!(\"panic in `drop`\");\n                }\n            }\n        }\n\n        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n\n        catch_unwind(move || {\n            drop(map.drain_filter(|_, _| {\n                PREDS.fetch_add(1, Ordering::SeqCst);\n                true\n            }))\n        })\n        .unwrap_err();\n\n        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n    }\n\n    #[test]\n    fn pred_panic_leak() {\n        static PREDS: AtomicUsize = AtomicUsize::new(0);\n        static DROPS: AtomicUsize = AtomicUsize::new(0);\n\n        struct D;\n        impl Drop for D {\n            fn drop(&mut self) {\n                DROPS.fetch_add(1, Ordering::SeqCst);\n            }\n        }\n\n        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n\n        catch_unwind(AssertUnwindSafe(|| {\n            drop(map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n                0 => true,\n                _ => panic!(),\n            }))\n        }))\n        .unwrap_err();\n\n        assert_eq!(PREDS.load(Ordering::SeqCst), 2);\n        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n        assert_eq!(map.len(), 2);\n    }\n\n    // Same as above, but attempt to use the iterator again after the panic in the predicate\n    #[test]\n    fn pred_panic_reuse() {\n        static PREDS: AtomicUsize = AtomicUsize::new(0);\n        static DROPS: AtomicUsize = AtomicUsize::new(0);\n\n        struct D;\n        impl Drop for D {\n            fn drop(&mut self) {\n                DROPS.fetch_add(1, Ordering::SeqCst);\n            }\n        }\n\n        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n\n        {\n            let mut it = map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n                0 => true,\n                _ => panic!(),\n            });\n            catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n            // Iterator behaviour after a panic is explicitly unspecified,\n            // so this is just the current implementation:\n            let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n            assert!(result.is_err());\n        }\n\n        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n        assert_eq!(map.len(), 2);\n    }\n}\n"],["2555","#[cfg(test)]\nmod tests;\n\nuse hashbrown::hash_set as base;\n\nuse crate::borrow::Borrow;\nuse crate::collections::TryReserveError;\nuse crate::fmt;\nuse crate::hash::{BuildHasher, Hash};\nuse crate::iter::{Chain, FromIterator, FusedIterator};\nuse crate::ops::{BitAnd, BitOr, BitXor, Sub};\n\nuse super::map::{map_try_reserve_error, RandomState};\n\n// Future Optimization (FIXME!)\n// ============================\n//\n// Iteration over zero sized values is a noop. There is no need\n// for `bucket.val` in the case of HashSet. I suppose we would need HKT\n// to get rid of it properly.\n\n/// A [hash set] implemented as a `HashMap` where the value is `()`.\n///\n/// As with the [`HashMap`] type, a `HashSet` requires that the elements\n/// implement the [`Eq`] and [`Hash`] traits. This can frequently be achieved by\n/// using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself,\n/// it is important that the following property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must be equal.\n///\n///\n/// It is a logic error for an item to be modified in such a way that the\n/// item's hash, as determined by the [`Hash`] trait, or its equality, as\n/// determined by the [`Eq`] trait, changes while it is in the set. This is\n/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or\n/// unsafe code. The behavior resulting from such a logic error is not\n/// specified, but will not result in undefined behavior. This could include\n/// panics, incorrect results, aborts, memory leaks, and non-termination.\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `HashSet<String>` in this example).\n/// let mut books = HashSet::new();\n///\n/// // Add some books.\n/// books.insert(\"A Dance With Dragons\".to_string());\n/// books.insert(\"To Kill a Mockingbird\".to_string());\n/// books.insert(\"The Odyssey\".to_string());\n/// books.insert(\"The Great Gatsby\".to_string());\n///\n/// // Check for a specific one.\n/// if !books.contains(\"The Winds of Winter\") {\n///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n///              books.len());\n/// }\n///\n/// // Remove a book.\n/// books.remove(\"The Odyssey\");\n///\n/// // Iterate over everything.\n/// for book in &books {\n///     println!(\"{}\", book);\n/// }\n/// ```\n///\n/// The easiest way to use `HashSet` with a custom type is to derive\n/// [`Eq`] and [`Hash`]. We must also derive [`PartialEq`], this will in the\n/// future be implied by [`Eq`].\n///\n/// ```\n/// use std::collections::HashSet;\n/// #[derive(Hash, Eq, PartialEq, Debug)]\n/// struct Viking {\n///     name: String,\n///     power: usize,\n/// }\n///\n/// let mut vikings = HashSet::new();\n///\n/// vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\n/// vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\n/// vikings.insert(Viking { name: \"Olaf\".to_string(), power: 4 });\n/// vikings.insert(Viking { name: \"Harald\".to_string(), power: 8 });\n///\n/// // Use derived implementation to print the vikings.\n/// for x in &vikings {\n///     println!(\"{:?}\", x);\n/// }\n/// ```\n///\n/// A `HashSet` with fixed list of elements can be initialized from an array:\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let viking_names: HashSet<&'static str> =\n///     [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n/// // use the values stored in the set\n/// ```\n///\n/// [hash set]: crate::collections#use-the-set-variant-of-any-of-these-maps-when\n/// [`HashMap`]: crate::collections::HashMap\n/// [`RefCell`]: crate::cell::RefCell\n/// [`Cell`]: crate::cell::Cell\n#[cfg_attr(not(test), rustc_diagnostic_item = \"hashset_type\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct HashSet<T, S = RandomState> {\n    base: base::HashSet<T, S>,\n}\n\nimpl<T> HashSet<T, RandomState> {\n    /// Creates an empty `HashSet`.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let set: HashSet<i32> = HashSet::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> HashSet<T, RandomState> {\n        Default::default()\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, Default::default()) }\n    }\n}\n\nimpl<T, S> HashSet<T, S> {\n    /// Returns the number of elements the set can hold without reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n    /// assert!(set.capacity() >= 100);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n        self.base.capacity()\n    }\n\n    /// An iterator visiting all elements in arbitrary order.\n    /// The iterator element type is `&'a T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let mut set = HashSet::new();\n    /// set.insert(\"a\");\n    /// set.insert(\"b\");\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in set.iter() {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n        Iter { base: self.base.iter() }\n    }\n\n    /// Returns the number of elements in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert_eq!(v.len(), 0);\n    /// v.insert(1);\n    /// assert_eq!(v.len(), 1);\n    /// ```\n    #[doc(alias = \"length\")]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n        self.base.len()\n    }\n\n    /// Returns `true` if the set contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert!(v.is_empty());\n    /// v.insert(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.base.is_empty()\n    }\n\n    /// Clears the set, returning all elements in an iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert!(!set.is_empty());\n    ///\n    /// // print 1, 2, 3 in an arbitrary order\n    /// for i in set.drain() {\n    ///     println!(\"{}\", i);\n    /// }\n    ///\n    /// assert!(set.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain(&mut self) -> Drain<'_, T> {\n        Drain { base: self.base.drain() }\n    }\n\n    /// Creates an iterator which uses a closure to determine if a value should be removed.\n    ///\n    /// If the closure returns true, then the value is removed and yielded.\n    /// If the closure returns false, the value will remain in the list and will not be yielded\n    /// by the iterator.\n    ///\n    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n    /// values will still be subjected to the closure and removed and dropped if it returns true.\n    ///\n    /// It is unspecified how many more values will be subjected to the closure\n    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n    /// `DrainFilter` itself is leaked.\n    ///\n    /// # Examples\n    ///\n    /// Splitting a set into even and odd values, reusing the original set:\n    ///\n    /// ```\n    /// #![feature(hash_drain_filter)]\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<i32> = (0..8).collect();\n    /// let drained: HashSet<i32> = set.drain_filter(|v| v % 2 == 0).collect();\n    ///\n    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n    /// let mut odds = set.into_iter().collect::<Vec<_>>();\n    /// evens.sort();\n    /// odds.sort();\n    ///\n    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        DrainFilter { base: self.base.drain_filter(pred) }\n    }\n\n    /// Clears the set, removing all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// v.insert(1);\n    /// v.clear();\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n        self.base.clear()\n    }\n\n    /// Creates a new empty hash set which will use the given hasher to hash\n    /// keys.\n    ///\n    /// The hash set is also created with the default initial capacity.\n    ///\n    /// Warning: `hasher` is normally randomly generated, and\n    /// is designed to allow `HashSet`s to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashMap to be useful, see its documentation for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut set = HashSet::with_hasher(s);\n    /// set.insert(2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n        HashSet { base: base::HashSet::with_hasher(hasher) }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity, using\n    /// `hasher` to hash the keys.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// Warning: `hasher` is normally randomly generated, and\n    /// is designed to allow `HashSet`s to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashMap to be useful, see its documentation for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n    /// set.insert(1);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, hasher) }\n    }\n\n    /// Returns a reference to the set's [`BuildHasher`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let hasher = RandomState::new();\n    /// let set: HashSet<i32> = HashSet::with_hasher(hasher);\n    /// let hasher: &RandomState = set.hasher();\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n    pub fn hasher(&self) -> &S {\n        self.base.hasher()\n    }\n}\n\nimpl<T, S> HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashSet`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new allocation size overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.reserve(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.base.reserve(additional)\n    }\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashSet<K, V>`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::HashSet;\n    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.base.try_reserve(additional).map_err(map_try_reserve_error)\n    }\n\n    /// Shrinks the capacity of the set as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to_fit();\n    /// assert!(set.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        self.base.shrink_to_fit()\n    }\n\n    /// Shrinks the capacity of the set with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// If the current capacity is less than the lower limit, this is a no-op.\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to(10);\n    /// assert!(set.capacity() >= 10);\n    /// set.shrink_to(0);\n    /// assert!(set.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.base.shrink_to(min_capacity)\n    }\n\n    /// Visits the values representing the difference,\n    /// i.e., the values that are in `self` but not in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Can be seen as `a - b`.\n    /// for x in a.difference(&b) {\n    ///     println!(\"{}\", x); // Print 1\n    /// }\n    ///\n    /// let diff: HashSet<_> = a.difference(&b).collect();\n    /// assert_eq!(diff, [1].iter().collect());\n    ///\n    /// // Note that difference is not symmetric,\n    /// // and `b - a` means something else:\n    /// let diff: HashSet<_> = b.difference(&a).collect();\n    /// assert_eq!(diff, [4].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n        Difference { iter: self.iter(), other }\n    }\n\n    /// Visits the values representing the symmetric difference,\n    /// i.e., the values that are in `self` or in `other` but not in both.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Print 1, 4 in arbitrary order.\n    /// for x in a.symmetric_difference(&b) {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let diff1: HashSet<_> = a.symmetric_difference(&b).collect();\n    /// let diff2: HashSet<_> = b.symmetric_difference(&a).collect();\n    ///\n    /// assert_eq!(diff1, diff2);\n    /// assert_eq!(diff1, [1, 4].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn symmetric_difference<'a>(\n        &'a self,\n        other: &'a HashSet<T, S>,\n    ) -> SymmetricDifference<'a, T, S> {\n        SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n    }\n\n    /// Visits the values representing the intersection,\n    /// i.e., the values that are both in `self` and `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Print 2, 3 in arbitrary order.\n    /// for x in a.intersection(&b) {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let intersection: HashSet<_> = a.intersection(&b).collect();\n    /// assert_eq!(intersection, [2, 3].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n        if self.len() <= other.len() {\n            Intersection { iter: self.iter(), other }\n        } else {\n            Intersection { iter: other.iter(), other: self }\n        }\n    }\n\n    /// Visits the values representing the union,\n    /// i.e., all the values in `self` or `other`, without duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Print 1, 2, 3, 4 in arbitrary order.\n    /// for x in a.union(&b) {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let union: HashSet<_> = a.union(&b).collect();\n    /// assert_eq!(union, [1, 2, 3, 4].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n        if self.len() >= other.len() {\n            Union { iter: self.iter().chain(other.difference(self)) }\n        } else {\n            Union { iter: other.iter().chain(self.difference(other)) }\n        }\n    }\n\n    /// Returns `true` if the set contains a value.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.contains(&1), true);\n    /// assert_eq!(set.contains(&4), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.contains(value)\n    }\n\n    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.get(&2), Some(&2));\n    /// assert_eq!(set.get(&4), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.get(value)\n    }\n\n    /// Inserts the given `value` into the set if it is not present, then\n    /// returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_set_entry)]\n    ///\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.len(), 3);\n    /// assert_eq!(set.get_or_insert(2), &2);\n    /// assert_eq!(set.get_or_insert(100), &100);\n    /// assert_eq!(set.len(), 4); // 100 was inserted\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n    pub fn get_or_insert(&mut self, value: T) -> &T {\n        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n        self.base.get_or_insert(value)\n    }\n\n    /// Inserts an owned copy of the given `value` into the set if it is not\n    /// present, then returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_set_entry)]\n    ///\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n    ///     .iter().map(|&pet| pet.to_owned()).collect();\n    ///\n    /// assert_eq!(set.len(), 3);\n    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n    ///     let value = set.get_or_insert_owned(pet);\n    ///     assert_eq!(value, pet);\n    /// }\n    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n    pub fn get_or_insert_owned<Q: ?Sized>(&mut self, value: &Q) -> &T\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq + ToOwned<Owned = T>,\n    {\n        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n        self.base.get_or_insert_owned(value)\n    }\n\n    /// Inserts a value computed from `f` into the set if the given `value` is\n    /// not present, then returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_set_entry)]\n    ///\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n    ///     .iter().map(|&pet| pet.to_owned()).collect();\n    ///\n    /// assert_eq!(set.len(), 3);\n    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n    ///     let value = set.get_or_insert_with(pet, str::to_owned);\n    ///     assert_eq!(value, pet);\n    /// }\n    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n    pub fn get_or_insert_with<Q: ?Sized, F>(&mut self, value: &Q, f: F) -> &T\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n        F: FnOnce(&Q) -> T,\n    {\n        // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n        // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n        self.base.get_or_insert_with(value, f)\n    }\n\n    /// Returns `true` if `self` has no elements in common with `other`.\n    /// This is equivalent to checking for an empty intersection.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let mut b = HashSet::new();\n    ///\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(4);\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(1);\n    /// assert_eq!(a.is_disjoint(&b), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n        if self.len() <= other.len() {\n            self.iter().all(|v| !other.contains(v))\n        } else {\n            other.iter().all(|v| !self.contains(v))\n        }\n    }\n\n    /// Returns `true` if the set is a subset of another,\n    /// i.e., `other` contains at least all the values in `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(2);\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(4);\n    /// assert_eq!(set.is_subset(&sup), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n        if self.len() <= other.len() { self.iter().all(|v| other.contains(v)) } else { false }\n    }\n\n    /// Returns `true` if the set is a superset of another,\n    /// i.e., `self` contains at least all the values in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(0);\n    /// set.insert(1);\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.is_superset(&sub), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n        other.is_subset(self)\n    }\n\n    /// Adds a value to the set.\n    ///\n    /// If the set did not have this value present, `true` is returned.\n    ///\n    /// If the set did have this value present, `false` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.insert(2), true);\n    /// assert_eq!(set.insert(2), false);\n    /// assert_eq!(set.len(), 1);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, value: T) -> bool {\n        self.base.insert(value)\n    }\n\n    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n    /// one. Returns the replaced value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    /// set.insert(Vec::<i32>::new());\n    ///\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 0);\n    /// set.replace(Vec::with_capacity(10));\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn replace(&mut self, value: T) -> Option<T> {\n        self.base.replace(value)\n    }\n\n    /// Removes a value from the set. Returns whether the value was\n    /// present in the set.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.remove(&2), true);\n    /// assert_eq!(set.remove(&2), false);\n    /// ```\n    #[doc(alias = \"delete\")]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.remove(value)\n    }\n\n    /// Removes and returns the value in the set, if any, that is equal to the given one.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.take(&2), Some(2));\n    /// assert_eq!(set.take(&2), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.take(value)\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let xs = [1, 2, 3, 4, 5, 6];\n    /// let mut set: HashSet<i32> = xs.iter().cloned().collect();\n    /// set.retain(|&k| k % 2 == 0);\n    /// assert_eq!(set.len(), 3);\n    /// ```\n    #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n    pub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n        self.base.retain(f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for HashSet<T, S>\nwhere\n    T: Clone,\n    S: Clone,\n{\n    #[inline]\n    fn clone(&self) -> Self {\n        Self { base: self.base.clone() }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, other: &Self) {\n        self.base.clone_from(&other.base);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> PartialEq for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    fn eq(&self, other: &HashSet<T, S>) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter().all(|key| other.contains(key))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Eq for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> fmt::Debug for HashSet<T, S>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_set().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> FromIterator<T> for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher + Default,\n{\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> HashSet<T, S> {\n        let mut set = HashSet::with_hasher(Default::default());\n        set.extend(iter);\n        set\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Extend<T> for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        self.base.extend(iter);\n    }\n\n    #[inline]\n    fn extend_one(&mut self, item: T) {\n        self.base.insert(item);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        self.base.extend_reserve(additional);\n    }\n}\n\n#[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\nimpl<'a, T, S> Extend<&'a T> for HashSet<T, S>\nwhere\n    T: 'a + Eq + Hash + Copy,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n        self.extend(iter.into_iter().cloned());\n    }\n\n    #[inline]\n    fn extend_one(&mut self, &item: &'a T) {\n        self.base.insert(item);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<T>::extend_reserve(self, additional)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Default for HashSet<T, S>\nwhere\n    S: Default,\n{\n    /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n    #[inline]\n    fn default() -> HashSet<T, S> {\n        HashSet { base: Default::default() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> BitOr<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a | &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 3, 4, 5];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.union(rhs).cloned().collect()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> BitAnd<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n    ///\n    /// let set = &a & &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [2, 3];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.intersection(rhs).cloned().collect()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> BitXor<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a ^ &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 4, 5];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.symmetric_difference(rhs).cloned().collect()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Sub<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a - &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n        self.difference(rhs).cloned().collect()\n    }\n}\n\n/// An iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`iter`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`iter`]: HashSet::iter\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n///\n/// let mut iter = a.iter();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, K: 'a> {\n    base: base::Iter<'a, K>,\n}\n\n/// An owning iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashSet`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`into_iter`]: IntoIterator::into_iter\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n///\n/// let mut iter = a.into_iter();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<K> {\n    base: base::IntoIter<K>,\n}\n\n/// A draining iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`drain`]: HashSet::drain\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let mut a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n///\n/// let mut drain = a.drain();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Drain<'a, K: 'a> {\n    base: base::Drain<'a, K>,\n}\n\n/// A draining, filtering iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`drain_filter`] method on [`HashSet`].\n///\n/// [`drain_filter`]: HashSet::drain_filter\n///\n/// # Examples\n///\n/// ```\n/// #![feature(hash_drain_filter)]\n///\n/// use std::collections::HashSet;\n///\n/// let mut a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n///\n/// let mut drain_filtered = a.drain_filter(|v| v % 2 == 0);\n/// ```\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\npub struct DrainFilter<'a, K, F>\nwhere\n    F: FnMut(&K) -> bool,\n{\n    base: base::DrainFilter<'a, K, F>,\n}\n\n/// A lazy iterator producing elements in the intersection of `HashSet`s.\n///\n/// This `struct` is created by the [`intersection`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`intersection`]: HashSet::intersection\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n///\n/// let mut intersection = a.intersection(&b);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Intersection<'a, T: 'a, S: 'a> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S>,\n}\n\n/// A lazy iterator producing elements in the difference of `HashSet`s.\n///\n/// This `struct` is created by the [`difference`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`difference`]: HashSet::difference\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n///\n/// let mut difference = a.difference(&b);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Difference<'a, T: 'a, S: 'a> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S>,\n}\n\n/// A lazy iterator producing elements in the symmetric difference of `HashSet`s.\n///\n/// This `struct` is created by the [`symmetric_difference`] method on\n/// [`HashSet`]. See its documentation for more.\n///\n/// [`symmetric_difference`]: HashSet::symmetric_difference\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n///\n/// let mut intersection = a.symmetric_difference(&b);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>,\n}\n\n/// A lazy iterator producing elements in the union of `HashSet`s.\n///\n/// This `struct` is created by the [`union`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`union`]: HashSet::union\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let a: HashSet<u32> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n///\n/// let mut union_iter = a.union(&b);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Union<'a, T: 'a, S: 'a> {\n    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> IntoIterator for &'a HashSet<T, S> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    #[inline]\n    fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> IntoIterator for HashSet<T, S> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out\n    /// of the set in arbitrary order. The set cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let mut set = HashSet::new();\n    /// set.insert(\"a\".to_string());\n    /// set.insert(\"b\".to_string());\n    ///\n    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n    /// let v: Vec<String> = set.into_iter().collect();\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in &v {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter { base: self.base.into_iter() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> Clone for Iter<'_, K> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Iter { base: self.base.clone() }\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K> Iterator for Iter<'a, K> {\n    type Item = &'a K;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a K> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> ExactSizeIterator for Iter<'_, K> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K> FusedIterator for Iter<'_, K> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: fmt::Debug> fmt::Debug for Iter<'_, K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> Iterator for IntoIter<K> {\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> ExactSizeIterator for IntoIter<K> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K> FusedIterator for IntoIter<K> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: fmt::Debug> fmt::Debug for IntoIter<K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.base, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K> Iterator for Drain<'a, K> {\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> ExactSizeIterator for Drain<'_, K> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K> FusedIterator for Drain<'_, K> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.base, f)\n    }\n}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<K, F> Iterator for DrainFilter<'_, K, F>\nwhere\n    F: FnMut(&K) -> bool,\n{\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<K, F> FusedIterator for DrainFilter<'_, K, F> where F: FnMut(&K) -> bool {}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<'a, K, F> fmt::Debug for DrainFilter<'a, K, F>\nwhere\n    F: FnMut(&K) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"DrainFilter\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for Intersection<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Intersection { iter: self.iter.clone(), ..*self }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for Intersection<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n        loop {\n            let elt = self.iter.next()?;\n            if self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for Intersection<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for Intersection<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for Difference<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Difference { iter: self.iter.clone(), ..*self }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for Difference<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n        loop {\n            let elt = self.iter.next()?;\n            if !self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper)\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for Difference<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for Difference<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for SymmetricDifference<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n        SymmetricDifference { iter: self.iter.clone() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n        self.iter.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for SymmetricDifference<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for SymmetricDifference<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for Union<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Union { iter: self.iter.clone() }\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for Union<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for Union<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for Union<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n        self.iter.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[allow(dead_code)]\nfn assert_covariance() {\n    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> {\n        v\n    }\n    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> {\n        v\n    }\n    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> {\n        v\n    }\n    fn difference<'a, 'new>(\n        v: Difference<'a, &'static str, RandomState>,\n    ) -> Difference<'a, &'new str, RandomState> {\n        v\n    }\n    fn symmetric_difference<'a, 'new>(\n        v: SymmetricDifference<'a, &'static str, RandomState>,\n    ) -> SymmetricDifference<'a, &'new str, RandomState> {\n        v\n    }\n    fn intersection<'a, 'new>(\n        v: Intersection<'a, &'static str, RandomState>,\n    ) -> Intersection<'a, &'new str, RandomState> {\n        v\n    }\n    fn union<'a, 'new>(\n        v: Union<'a, &'static str, RandomState>,\n    ) -> Union<'a, &'new str, RandomState> {\n        v\n    }\n    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n        d\n    }\n}\n"],["2556","//! Unordered containers, implemented as hash-tables\n\npub mod map;\npub mod set;\n"],["2557","// ignore-tidy-filelength\n\n#[cfg(test)]\nmod tests;\n\nuse self::Entry::*;\n\nuse hashbrown::hash_map as base;\n\nuse crate::borrow::Borrow;\nuse crate::cell::Cell;\nuse crate::collections::TryReserveError;\nuse crate::fmt::{self, Debug};\n#[allow(deprecated)]\nuse crate::hash::{BuildHasher, Hash, Hasher, SipHasher13};\nuse crate::iter::{FromIterator, FusedIterator};\nuse crate::ops::Index;\nuse crate::sys;\n\n/// A [hash map] implemented with quadratic probing and SIMD lookup.\n///\n/// By default, `HashMap` uses a hashing algorithm selected to provide\n/// resistance against HashDoS attacks. The algorithm is randomly seeded, and a\n/// reasonable best-effort is made to generate this seed from a high quality,\n/// secure source of randomness provided by the host without blocking the\n/// program. Because of this, the randomness of the seed depends on the output\n/// quality of the system's random number generator when the seed is created.\n/// In particular, seeds generated when the system's entropy pool is abnormally\n/// low such as during system boot may be of a lower quality.\n///\n/// The default hashing algorithm is currently SipHash 1-3, though this is\n/// subject to change at any point in the future. While its performance is very\n/// competitive for medium sized keys, other hashing algorithms will outperform\n/// it for small keys such as integers as well as large keys such as long\n/// strings, though those algorithms will typically *not* protect against\n/// attacks such as HashDoS.\n///\n/// The hashing algorithm can be replaced on a per-`HashMap` basis using the\n/// [`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods.\n/// There are many alternative [hashing algorithms available on crates.io].\n///\n/// It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n/// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n/// If you implement these yourself, it is important that the following\n/// property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must be equal.\n///\n/// It is a logic error for a key to be modified in such a way that the key's\n/// hash, as determined by the [`Hash`] trait, or its equality, as determined by\n/// the [`Eq`] trait, changes while it is in the map. This is normally only\n/// possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n/// The behavior resulting from such a logic error is not specified, but will\n/// not result in undefined behavior. This could include panics, incorrect results,\n/// aborts, memory leaks, and non-termination.\n///\n/// The hash table implementation is a Rust port of Google's [SwissTable].\n/// The original C++ version of SwissTable can be found [here], and this\n/// [CppCon talk] gives an overview of how the algorithm works.\n///\n/// [hash map]: crate::collections#use-a-hashmap-when\n/// [hashing algorithms available on crates.io]: https://crates.io/keywords/hasher\n/// [SwissTable]: https://abseil.io/blog/20180927-swisstables\n/// [here]: https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h\n/// [CppCon talk]: https://www.youtube.com/watch?v=ncHmEUmJZf4\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `HashMap<String, String>` in this example).\n/// let mut book_reviews = HashMap::new();\n///\n/// // Review some books.\n/// book_reviews.insert(\n///     \"Adventures of Huckleberry Finn\".to_string(),\n///     \"My favorite book.\".to_string(),\n/// );\n/// book_reviews.insert(\n///     \"Grimms' Fairy Tales\".to_string(),\n///     \"Masterpiece.\".to_string(),\n/// );\n/// book_reviews.insert(\n///     \"Pride and Prejudice\".to_string(),\n///     \"Very enjoyable.\".to_string(),\n/// );\n/// book_reviews.insert(\n///     \"The Adventures of Sherlock Holmes\".to_string(),\n///     \"Eye lyked it alot.\".to_string(),\n/// );\n///\n/// // Check for a specific one.\n/// // When collections store owned values (String), they can still be\n/// // queried using references (&str).\n/// if !book_reviews.contains_key(\"Les Misrables\") {\n///     println!(\"We've got {} reviews, but Les Misrables ain't one.\",\n///              book_reviews.len());\n/// }\n///\n/// // oops, this review has a lot of spelling mistakes, let's delete it.\n/// book_reviews.remove(\"The Adventures of Sherlock Holmes\");\n///\n/// // Look up the values associated with some keys.\n/// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n/// for &book in &to_find {\n///     match book_reviews.get(book) {\n///         Some(review) => println!(\"{}: {}\", book, review),\n///         None => println!(\"{} is unreviewed.\", book)\n///     }\n/// }\n///\n/// // Look up the value for a key (will panic if the key is not found).\n/// println!(\"Review for Jane: {}\", book_reviews[\"Pride and Prejudice\"]);\n///\n/// // Iterate over everything.\n/// for (book, review) in &book_reviews {\n///     println!(\"{}: \\\"{}\\\"\", book, review);\n/// }\n/// ```\n///\n/// `HashMap` also implements an [`Entry API`](#method.entry), which allows\n/// for more complex methods of getting, setting, updating and removing keys and\n/// their values:\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// // type inference lets us omit an explicit type signature (which\n/// // would be `HashMap<&str, u8>` in this example).\n/// let mut player_stats = HashMap::new();\n///\n/// fn random_stat_buff() -> u8 {\n///     // could actually return some random value here - let's just return\n///     // some fixed value for now\n///     42\n/// }\n///\n/// // insert a key only if it doesn't already exist\n/// player_stats.entry(\"health\").or_insert(100);\n///\n/// // insert a key using a function that provides a new value only if it\n/// // doesn't already exist\n/// player_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n///\n/// // update a key, guarding against the key possibly not being set\n/// let stat = player_stats.entry(\"attack\").or_insert(100);\n/// *stat += random_stat_buff();\n/// ```\n///\n/// The easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].\n/// We must also derive [`PartialEq`].\n///\n/// [`RefCell`]: crate::cell::RefCell\n/// [`Cell`]: crate::cell::Cell\n/// [`default`]: Default::default\n/// [`with_hasher`]: Self::with_hasher\n/// [`with_capacity_and_hasher`]: Self::with_capacity_and_hasher\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// #[derive(Hash, Eq, PartialEq, Debug)]\n/// struct Viking {\n///     name: String,\n///     country: String,\n/// }\n///\n/// impl Viking {\n///     /// Creates a new Viking.\n///     fn new(name: &str, country: &str) -> Viking {\n///         Viking { name: name.to_string(), country: country.to_string() }\n///     }\n/// }\n///\n/// // Use a HashMap to store the vikings' health points.\n/// let mut vikings = HashMap::new();\n///\n/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n///\n/// // Use derived implementation to print the status of the vikings.\n/// for (viking, health) in &vikings {\n///     println!(\"{:?} has {} hp\", viking, health);\n/// }\n/// ```\n///\n/// A `HashMap` with fixed list of elements can be initialized from an array:\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let timber_resources: HashMap<&str, i32> = [(\"Norway\", 100), (\"Denmark\", 50), (\"Iceland\", 10)]\n///     .iter().cloned().collect();\n/// // use the values stored in map\n/// ```\n\n#[cfg_attr(not(test), rustc_diagnostic_item = \"hashmap_type\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct HashMap<K, V, S = RandomState> {\n    base: base::HashMap<K, V, S>,\n}\n\nimpl<K, V> HashMap<K, V, RandomState> {\n    /// Creates an empty `HashMap`.\n    ///\n    /// The hash map is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> HashMap<K, V, RandomState> {\n        Default::default()\n    }\n\n    /// Creates an empty `HashMap` with the specified capacity.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::with_capacity(10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {\n        HashMap::with_capacity_and_hasher(capacity, Default::default())\n    }\n}\n\nimpl<K, V, S> HashMap<K, V, S> {\n    /// Creates an empty `HashMap` which will use the given hash builder to hash\n    /// keys.\n    ///\n    /// The created map has the default initial capacity.\n    ///\n    /// Warning: `hash_builder` is normally randomly generated, and\n    /// is designed to allow HashMaps to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashMap to be useful, see its documentation for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut map = HashMap::with_hasher(s);\n    /// map.insert(1, 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n        HashMap { base: base::HashMap::with_hasher(hash_builder) }\n    }\n\n    /// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n    /// to hash the keys.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// Warning: `hash_builder` is normally randomly generated, and\n    /// is designed to allow HashMaps to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the HashMap to be useful, see its documentation for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n    /// map.insert(1, 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n        HashMap { base: base::HashMap::with_capacity_and_hasher(capacity, hash_builder) }\n    }\n\n    /// Returns the number of elements the map can hold without reallocating.\n    ///\n    /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n    /// more, but is guaranteed to be able to hold at least this many.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// assert!(map.capacity() >= 100);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n        self.base.capacity()\n    }\n\n    /// An iterator visiting all keys in arbitrary order.\n    /// The iterator element type is `&'a K`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for key in map.keys() {\n    ///     println!(\"{}\", key);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn keys(&self) -> Keys<'_, K, V> {\n        Keys { inner: self.iter() }\n    }\n\n    /// An iterator visiting all values in arbitrary order.\n    /// The iterator element type is `&'a V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for val in map.values() {\n    ///     println!(\"{}\", val);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn values(&self) -> Values<'_, K, V> {\n        Values { inner: self.iter() }\n    }\n\n    /// An iterator visiting all values mutably in arbitrary order.\n    /// The iterator element type is `&'a mut V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    ///\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for val in map.values_mut() {\n    ///     *val = *val + 10;\n    /// }\n    ///\n    /// for val in map.values() {\n    ///     println!(\"{}\", val);\n    /// }\n    /// ```\n    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {\n        ValuesMut { inner: self.iter_mut() }\n    }\n\n    /// An iterator visiting all key-value pairs in arbitrary order.\n    /// The iterator element type is `(&'a K, &'a V)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for (key, val) in map.iter() {\n    ///     println!(\"key: {} val: {}\", key, val);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, K, V> {\n        Iter { base: self.base.iter() }\n    }\n\n    /// An iterator visiting all key-value pairs in arbitrary order,\n    /// with mutable references to the values.\n    /// The iterator element type is `(&'a K, &'a mut V)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// // Update all values\n    /// for (_, val) in map.iter_mut() {\n    ///     *val *= 2;\n    /// }\n    ///\n    /// for (key, val) in &map {\n    ///     println!(\"key: {} val: {}\", key, val);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n        IterMut { base: self.base.iter_mut() }\n    }\n\n    /// Returns the number of elements in the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// assert_eq!(a.len(), 0);\n    /// a.insert(1, \"a\");\n    /// assert_eq!(a.len(), 1);\n    /// ```\n    #[doc(alias = \"length\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n        self.base.len()\n    }\n\n    /// Returns `true` if the map contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// assert!(a.is_empty());\n    /// a.insert(1, \"a\");\n    /// assert!(!a.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.base.is_empty()\n    }\n\n    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n    /// allocated memory for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// a.insert(1, \"a\");\n    /// a.insert(2, \"b\");\n    ///\n    /// for (k, v) in a.drain().take(1) {\n    ///     assert!(k == 1 || k == 2);\n    ///     assert!(v == \"a\" || v == \"b\");\n    /// }\n    ///\n    /// assert!(a.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain(&mut self) -> Drain<'_, K, V> {\n        Drain { base: self.base.drain() }\n    }\n\n    /// Creates an iterator which uses a closure to determine if an element should be removed.\n    ///\n    /// If the closure returns true, the element is removed from the map and yielded.\n    /// If the closure returns false, or panics, the element remains in the map and will not be\n    /// yielded.\n    ///\n    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n    /// whether you choose to keep or remove it.\n    ///\n    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n    ///\n    /// It is unspecified how many more elements will be subjected to the closure\n    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n    /// or if the `DrainFilter` value is leaked.\n    ///\n    /// # Examples\n    ///\n    /// Splitting a map into even and odd keys, reusing the original map:\n    ///\n    /// ```\n    /// #![feature(hash_drain_filter)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n    /// let drained: HashMap<i32, i32> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n    ///\n    /// let mut evens = drained.keys().copied().collect::<Vec<_>>();\n    /// let mut odds = map.keys().copied().collect::<Vec<_>>();\n    /// evens.sort();\n    /// odds.sort();\n    ///\n    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n    where\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        DrainFilter { base: self.base.drain_filter(pred) }\n    }\n\n    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n    /// for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// a.insert(1, \"a\");\n    /// a.clear();\n    /// assert!(a.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n        self.base.clear();\n    }\n\n    /// Returns a reference to the map's [`BuildHasher`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let hasher = RandomState::new();\n    /// let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n    /// let hasher: &RandomState = map.hasher();\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n    pub fn hasher(&self) -> &S {\n        self.base.hasher()\n    }\n}\n\nimpl<K, V, S> HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n{\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashMap`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new allocation size overflows [`usize`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    /// map.reserve(10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.base.reserve(additional)\n    }\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashMap<K, V>`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, isize> = HashMap::new();\n    /// map.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.base.try_reserve(additional).map_err(map_try_reserve_error)\n    }\n\n    /// Shrinks the capacity of the map as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// assert!(map.capacity() >= 100);\n    /// map.shrink_to_fit();\n    /// assert!(map.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        self.base.shrink_to_fit();\n    }\n\n    /// Shrinks the capacity of the map with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// If the current capacity is less than the lower limit, this is a no-op.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// assert!(map.capacity() >= 100);\n    /// map.shrink_to(10);\n    /// assert!(map.capacity() >= 10);\n    /// map.shrink_to(0);\n    /// assert!(map.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.base.shrink_to(min_capacity);\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut letters = HashMap::new();\n    ///\n    /// for ch in \"a short treatise on fungi\".chars() {\n    ///     let counter = letters.entry(ch).or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(letters[&'s'], 2);\n    /// assert_eq!(letters[&'t'], 3);\n    /// assert_eq!(letters[&'u'], 1);\n    /// assert_eq!(letters.get(&'y'), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n        map_entry(self.base.rustc_entry(key))\n    }\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.get(&1), Some(&\"a\"));\n    /// assert_eq!(map.get(&2), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.get(k)\n    }\n\n    /// Returns the key-value pair corresponding to the supplied key.\n    ///\n    /// The supplied key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n    /// assert_eq!(map.get_key_value(&2), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n    pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.get_key_value(k)\n    }\n\n    /// Returns `true` if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.contains_key(&1), true);\n    /// assert_eq!(map.contains_key(&2), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.contains_key(k)\n    }\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// if let Some(x) = map.get_mut(&1) {\n    ///     *x = \"b\";\n    /// }\n    /// assert_eq!(map[&1], \"b\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.get_mut(k)\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, [`None`] is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned. The key is not updated, though; this matters for\n    /// types that can be `==` without being identical. See the [module-level\n    /// documentation] for more.\n    ///\n    /// [module-level documentation]: crate::collections#insert-and-complex-keys\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// assert_eq!(map.insert(37, \"a\"), None);\n    /// assert_eq!(map.is_empty(), false);\n    ///\n    /// map.insert(37, \"b\");\n    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n    /// assert_eq!(map[&37], \"c\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n        self.base.insert(k, v)\n    }\n\n    /// Tries to insert a key-value pair into the map, and returns\n    /// a mutable reference to the value in the entry.\n    ///\n    /// If the map already had this key present, nothing is updated, and\n    /// an error containing the occupied entry and the value is returned.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(map_try_insert)]\n    ///\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// assert_eq!(map.try_insert(37, \"a\").unwrap(), &\"a\");\n    ///\n    /// let err = map.try_insert(37, \"b\").unwrap_err();\n    /// assert_eq!(err.entry.key(), &37);\n    /// assert_eq!(err.entry.get(), &\"a\");\n    /// assert_eq!(err.value, \"b\");\n    /// ```\n    #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n    pub fn try_insert(&mut self, key: K, value: V) -> Result<&mut V, OccupiedError<'_, K, V>> {\n        match self.entry(key) {\n            Occupied(entry) => Err(OccupiedError { entry, value }),\n            Vacant(entry) => Ok(entry.insert(value)),\n        }\n    }\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.remove(&1), Some(\"a\"));\n    /// assert_eq!(map.remove(&1), None);\n    /// ```\n    #[doc(alias = \"delete\")]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.remove(k)\n    }\n\n    /// Removes a key from the map, returning the stored key and value if the\n    /// key was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// # fn main() {\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n    /// assert_eq!(map.remove(&1), None);\n    /// # }\n    /// ```\n    #[inline]\n    #[stable(feature = \"hash_map_remove_entry\", since = \"1.27.0\")]\n    pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.remove_entry(k)\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)` returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x*10)).collect();\n    /// map.retain(|&k, _| k % 2 == 0);\n    /// assert_eq!(map.len(), 4);\n    /// ```\n    #[inline]\n    #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n    pub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        self.base.retain(f)\n    }\n\n    /// Creates a consuming iterator visiting all the keys in arbitrary order.\n    /// The map cannot be used after calling this.\n    /// The iterator element type is `K`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// let vec: Vec<&str> = map.into_keys().collect();\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n    pub fn into_keys(self) -> IntoKeys<K, V> {\n        IntoKeys { inner: self.into_iter() }\n    }\n\n    /// Creates a consuming iterator visiting all the values in arbitrary order.\n    /// The map cannot be used after calling this.\n    /// The iterator element type is `V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// let vec: Vec<i32> = map.into_values().collect();\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n    pub fn into_values(self) -> IntoValues<K, V> {\n        IntoValues { inner: self.into_iter() }\n    }\n}\n\nimpl<K, V, S> HashMap<K, V, S>\nwhere\n    S: BuildHasher,\n{\n    /// Creates a raw entry builder for the HashMap.\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched. After this, insertions into a vacant entry\n    /// still require an owned key to be provided.\n    ///\n    /// Raw entries are useful for such exotic situations as:\n    ///\n    /// * Hash memoization\n    /// * Deferring the creation of an owned key until it is known to be required\n    /// * Using a search key that doesn't work with the Borrow trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Because raw entries provide much more low-level control, it's much easier\n    /// to put the HashMap into an inconsistent state which, while memory-safe,\n    /// will cause the map to produce seemingly random results. Higher-level and\n    /// more foolproof APIs like `entry` should be preferred when possible.\n    ///\n    /// In particular, the hash used to initialized the raw entry must still be\n    /// consistent with the hash of the key that is ultimately stored in the entry.\n    /// This is because implementations of HashMap may need to recompute hashes\n    /// when resizing, at which point only the keys are available.\n    ///\n    /// Raw entries give mutable access to the keys. This must not be used\n    /// to modify how the key would compare or hash, as the map will not re-evaluate\n    /// where the key should go, meaning the keys may become \"lost\" if their\n    /// location does not reflect their state. For instance, if you change a key\n    /// so that the map now contains keys which compare equal, search may start\n    /// acting erratically, with two keys randomly masking each other. Implementations\n    /// are free to assume this doesn't happen (within the limits of memory-safety).\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<'_, K, V, S> {\n        RawEntryBuilderMut { map: self }\n    }\n\n    /// Creates a raw immutable entry builder for the HashMap.\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched.\n    ///\n    /// This is useful for\n    /// * Hash memoization\n    /// * Using a search key that doesn't work with the Borrow trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Unless you are in such a situation, higher-level and more foolproof APIs like\n    /// `get` should be preferred.\n    ///\n    /// Immutable raw entries have very limited use; you might instead want `raw_entry_mut`.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn raw_entry(&self) -> RawEntryBuilder<'_, K, V, S> {\n        RawEntryBuilder { map: self }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Clone for HashMap<K, V, S>\nwhere\n    K: Clone,\n    V: Clone,\n    S: Clone,\n{\n    #[inline]\n    fn clone(&self) -> Self {\n        Self { base: self.base.clone() }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, other: &Self) {\n        self.base.clone_from(&other.base);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> PartialEq for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    V: PartialEq,\n    S: BuildHasher,\n{\n    fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter().all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Eq for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Debug for HashMap<K, V, S>\nwhere\n    K: Debug,\n    V: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_map().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Default for HashMap<K, V, S>\nwhere\n    S: Default,\n{\n    /// Creates an empty `HashMap<K, V, S>`, with the `Default` value for the hasher.\n    #[inline]\n    fn default() -> HashMap<K, V, S> {\n        HashMap::with_hasher(Default::default())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, Q: ?Sized, V, S> Index<&Q> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash + Borrow<Q>,\n    Q: Eq + Hash,\n    S: BuildHasher,\n{\n    type Output = V;\n\n    /// Returns a reference to the value corresponding to the supplied key.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the key is not present in the `HashMap`.\n    #[inline]\n    fn index(&self, key: &Q) -> &V {\n        self.get(key).expect(\"no entry found for key\")\n    }\n}\n\n/// An iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`iter`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`iter`]: HashMap::iter\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.iter();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, K: 'a, V: 'a> {\n    base: base::Iter<'a, K, V>,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Iter<'_, K, V> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Iter { base: self.base.clone() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: Debug, V: Debug> fmt::Debug for Iter<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n/// A mutable iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`iter_mut`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`iter_mut`]: HashMap::iter_mut\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.iter_mut();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, K: 'a, V: 'a> {\n    base: base::IterMut<'a, K, V>,\n}\n\nimpl<'a, K, V> IterMut<'a, K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[inline]\n    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n        Iter { base: self.base.rustc_iter() }\n    }\n}\n\n/// An owning iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashMap`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`into_iter`]: IntoIterator::into_iter\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.into_iter();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<K, V> {\n    base: base::IntoIter<K, V>,\n}\n\nimpl<K, V> IntoIter<K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[inline]\n    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n        Iter { base: self.base.rustc_iter() }\n    }\n}\n\n/// An iterator over the keys of a `HashMap`.\n///\n/// This `struct` is created by the [`keys`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`keys`]: HashMap::keys\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_keys = map.keys();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Keys<'a, K: 'a, V: 'a> {\n    inner: Iter<'a, K, V>,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Keys<'_, K, V> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Keys { inner: self.inner.clone() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: Debug, V> fmt::Debug for Keys<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n/// An iterator over the values of a `HashMap`.\n///\n/// This `struct` is created by the [`values`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`values`]: HashMap::values\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_values = map.values();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Values<'a, K: 'a, V: 'a> {\n    inner: Iter<'a, K, V>,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Values<'_, K, V> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Values { inner: self.inner.clone() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V: Debug> fmt::Debug for Values<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}\n\n/// A draining iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`drain`]: HashMap::drain\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.drain();\n/// ```\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<'a, K: 'a, V: 'a> {\n    base: base::Drain<'a, K, V>,\n}\n\nimpl<'a, K, V> Drain<'a, K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[inline]\n    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n        Iter { base: self.base.rustc_iter() }\n    }\n}\n\n/// A draining, filtering iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`drain_filter`] method on [`HashMap`].\n///\n/// [`drain_filter`]: HashMap::drain_filter\n///\n/// # Example\n///\n/// ```\n/// #![feature(hash_drain_filter)]\n///\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter = map.drain_filter(|_k, v| *v % 2 == 0);\n/// ```\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\npub struct DrainFilter<'a, K, V, F>\nwhere\n    F: FnMut(&K, &mut V) -> bool,\n{\n    base: base::DrainFilter<'a, K, V, F>,\n}\n\n/// A mutable iterator over the values of a `HashMap`.\n///\n/// This `struct` is created by the [`values_mut`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`values_mut`]: HashMap::values_mut\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_values = map.values_mut();\n/// ```\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\npub struct ValuesMut<'a, K: 'a, V: 'a> {\n    inner: IterMut<'a, K, V>,\n}\n\n/// An owning iterator over the keys of a `HashMap`.\n///\n/// This `struct` is created by the [`into_keys`] method on [`HashMap`].\n/// See its documentation for more.\n///\n/// [`into_keys`]: HashMap::into_keys\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_keys = map.into_keys();\n/// ```\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\npub struct IntoKeys<K, V> {\n    inner: IntoIter<K, V>,\n}\n\n/// An owning iterator over the values of a `HashMap`.\n///\n/// This `struct` is created by the [`into_values`] method on [`HashMap`].\n/// See its documentation for more.\n///\n/// [`into_values`]: HashMap::into_values\n///\n/// # Example\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(\"a\", 1);\n/// let iter_keys = map.into_values();\n/// ```\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\npub struct IntoValues<K, V> {\n    inner: IntoIter<K, V>,\n}\n\n/// A builder for computing where in a HashMap a key-value pair would be stored.\n///\n/// See the [`HashMap::raw_entry_mut`] docs for usage examples.\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n    map: &'a mut HashMap<K, V, S>,\n}\n\n/// A view into a single entry in a map, which may either be vacant or occupied.\n///\n/// This is a lower-level version of [`Entry`].\n///\n/// This `enum` is constructed through the [`raw_entry_mut`] method on [`HashMap`],\n/// then calling one of the methods of that [`RawEntryBuilderMut`].\n///\n/// [`raw_entry_mut`]: HashMap::raw_entry_mut\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n    /// An occupied entry.\n    Occupied(RawOccupiedEntryMut<'a, K, V, S>),\n    /// A vacant entry.\n    Vacant(RawVacantEntryMut<'a, K, V, S>),\n}\n\n/// A view into an occupied entry in a `HashMap`.\n/// It is part of the [`RawEntryMut`] enum.\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n    base: base::RawOccupiedEntryMut<'a, K, V, S>,\n}\n\n/// A view into a vacant entry in a `HashMap`.\n/// It is part of the [`RawEntryMut`] enum.\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n    base: base::RawVacantEntryMut<'a, K, V, S>,\n}\n\n/// A builder for computing where in a HashMap a key-value pair would be stored.\n///\n/// See the [`HashMap::raw_entry`] docs for usage examples.\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n    map: &'a HashMap<K, V, S>,\n}\n\nimpl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\nwhere\n    S: BuildHasher,\n{\n    /// Creates a `RawEntryMut` from the given key.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        map_raw_entry(self.map.base.raw_entry_mut().from_key(k))\n    }\n\n    /// Creates a `RawEntryMut` from the given key and its hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        K: Borrow<Q>,\n        Q: Eq,\n    {\n        map_raw_entry(self.map.base.raw_entry_mut().from_key_hashed_nocheck(hash, k))\n    }\n\n    /// Creates a `RawEntryMut` from the given hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n    where\n        for<'b> F: FnMut(&'b K) -> bool,\n    {\n        map_raw_entry(self.map.base.raw_entry_mut().from_hash(hash, is_match))\n    }\n}\n\nimpl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\nwhere\n    S: BuildHasher,\n{\n    /// Access an entry by key.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.map.base.raw_entry().from_key(k)\n    }\n\n    /// Access an entry by a key and its hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> Option<(&'a K, &'a V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.map.base.raw_entry().from_key_hashed_nocheck(hash, k)\n    }\n\n    /// Access an entry by hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n    where\n        F: FnMut(&K) -> bool,\n    {\n        self.map.base.raw_entry().from_hash(hash, is_match)\n    }\n}\n\nimpl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// mutable references to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_raw_entry)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 3);\n    /// assert_eq!(map[\"poneyland\"], 3);\n    ///\n    /// *map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 10).1 *= 2;\n    /// assert_eq!(map[\"poneyland\"], 6);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n            RawEntryMut::Vacant(entry) => entry.insert(default_key, default_val),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns mutable references to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_raw_entry)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    ///\n    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert_with(|| {\n    ///     (\"poneyland\", \"hoho\".to_string())\n    /// });\n    ///\n    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n    where\n        F: FnOnce() -> (K, V),\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n            RawEntryMut::Vacant(entry) => {\n                let (k, v) = default();\n                entry.insert(k, v)\n            }\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_raw_entry)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.raw_entry_mut()\n    ///    .from_key(\"poneyland\")\n    ///    .and_modify(|_k, v| { *v += 1 })\n    ///    .or_insert(\"poneyland\", 42);\n    /// assert_eq!(map[\"poneyland\"], 42);\n    ///\n    /// map.raw_entry_mut()\n    ///    .from_key(\"poneyland\")\n    ///    .and_modify(|_k, v| { *v += 1 })\n    ///    .or_insert(\"poneyland\", 0);\n    /// assert_eq!(map[\"poneyland\"], 43);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut K, &mut V),\n    {\n        match self {\n            RawEntryMut::Occupied(mut entry) => {\n                {\n                    let (k, v) = entry.get_key_value_mut();\n                    f(k, v);\n                }\n                RawEntryMut::Occupied(entry)\n            }\n            RawEntryMut::Vacant(entry) => RawEntryMut::Vacant(entry),\n        }\n    }\n}\n\nimpl<'a, K, V, S> RawOccupiedEntryMut<'a, K, V, S> {\n    /// Gets a reference to the key in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn key(&self) -> &K {\n        self.base.key()\n    }\n\n    /// Gets a mutable reference to the key in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn key_mut(&mut self) -> &mut K {\n        self.base.key_mut()\n    }\n\n    /// Converts the entry into a mutable reference to the key in the entry\n    /// with a lifetime bound to the map itself.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn into_key(self) -> &'a mut K {\n        self.base.into_key()\n    }\n\n    /// Gets a reference to the value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get(&self) -> &V {\n        self.base.get()\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn into_mut(self) -> &'a mut V {\n        self.base.into_mut()\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get_mut(&mut self) -> &mut V {\n        self.base.get_mut()\n    }\n\n    /// Gets a reference to the key and value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get_key_value(&mut self) -> (&K, &V) {\n        self.base.get_key_value()\n    }\n\n    /// Gets a mutable reference to the key and value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n        self.base.get_key_value_mut()\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the key and value in the entry\n    /// with a lifetime bound to the map itself.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn into_key_value(self) -> (&'a mut K, &'a mut V) {\n        self.base.into_key_value()\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert(&mut self, value: V) -> V {\n        self.base.insert(value)\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert_key(&mut self, key: K) -> K {\n        self.base.insert_key(key)\n    }\n\n    /// Takes the value out of the entry, and returns it.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn remove(self) -> V {\n        self.base.remove()\n    }\n\n    /// Take the ownership of the key and value from the map.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn remove_entry(self) -> (K, V) {\n        self.base.remove_entry()\n    }\n}\n\nimpl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n    /// Sets the value of the entry with the `VacantEntry`'s key,\n    /// and returns a mutable reference to it.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        self.base.insert(key, value)\n    }\n\n    /// Sets the value of the entry with the VacantEntry's key,\n    /// and returns a mutable reference to it.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        self.base.insert_hashed_nocheck(hash, key, value)\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K, V, S> Debug for RawEntryBuilderMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawEntryBuilder\").finish_non_exhaustive()\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K: Debug, V: Debug, S> Debug for RawEntryMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            RawEntryMut::Vacant(ref v) => f.debug_tuple(\"RawEntry\").field(v).finish(),\n            RawEntryMut::Occupied(ref o) => f.debug_tuple(\"RawEntry\").field(o).finish(),\n        }\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K: Debug, V: Debug, S> Debug for RawOccupiedEntryMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawOccupiedEntryMut\")\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish_non_exhaustive()\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K, V, S> Debug for RawVacantEntryMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawVacantEntryMut\").finish_non_exhaustive()\n    }\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K, V, S> Debug for RawEntryBuilder<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawEntryBuilder\").finish_non_exhaustive()\n    }\n}\n\n/// A view into a single entry in a map, which may either be vacant or occupied.\n///\n/// This `enum` is constructed from the [`entry`] method on [`HashMap`].\n///\n/// [`entry`]: HashMap::entry\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Entry<'a, K: 'a, V: 'a> {\n    /// An occupied entry.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n\n    /// A vacant entry.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n}\n\n#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\nimpl<K: Debug, V: Debug> Debug for Entry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n        }\n    }\n}\n\n/// A view into an occupied entry in a `HashMap`.\n/// It is part of the [`Entry`] enum.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n    base: base::RustcOccupiedEntry<'a, K, V>,\n}\n\n#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\nimpl<K: Debug, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"OccupiedEntry\")\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish_non_exhaustive()\n    }\n}\n\n/// A view into a vacant entry in a `HashMap`.\n/// It is part of the [`Entry`] enum.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct VacantEntry<'a, K: 'a, V: 'a> {\n    base: base::RustcVacantEntry<'a, K, V>,\n}\n\n#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\nimpl<K: Debug, V> Debug for VacantEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n    }\n}\n\n/// The error returned by [`try_insert`](HashMap::try_insert) when the key already exists.\n///\n/// Contains the occupied entry, and the value that was not inserted.\n#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\npub struct OccupiedError<'a, K: 'a, V: 'a> {\n    /// The entry in the map that was already occupied.\n    pub entry: OccupiedEntry<'a, K, V>,\n    /// The value which was not inserted, because the entry was already occupied.\n    pub value: V,\n}\n\n#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\nimpl<K: Debug, V: Debug> Debug for OccupiedError<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"OccupiedError\")\n            .field(\"key\", self.entry.key())\n            .field(\"old_value\", self.entry.get())\n            .field(\"new_value\", &self.value)\n            .finish_non_exhaustive()\n    }\n}\n\n#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\nimpl<'a, K: Debug, V: Debug> fmt::Display for OccupiedError<'a, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"failed to insert {:?}, key {:?} already exists with value {:?}\",\n            self.value,\n            self.entry.key(),\n            self.entry.get(),\n        )\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S> {\n    type Item = (&'a K, &'a V);\n    type IntoIter = Iter<'a, K, V>;\n\n    #[inline]\n    fn into_iter(self) -> Iter<'a, K, V> {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S> {\n    type Item = (&'a K, &'a mut V);\n    type IntoIter = IterMut<'a, K, V>;\n\n    #[inline]\n    fn into_iter(self) -> IterMut<'a, K, V> {\n        self.iter_mut()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> IntoIterator for HashMap<K, V, S> {\n    type Item = (K, V);\n    type IntoIter = IntoIter<K, V>;\n\n    /// Creates a consuming iterator, that is, one that moves each key-value\n    /// pair out of the map in arbitrary order. The map cannot be used after\n    /// calling this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// // Not possible with .iter()\n    /// let vec: Vec<(&str, i32)> = map.into_iter().collect();\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<K, V> {\n        IntoIter { base: self.base.into_iter() }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Iter<'a, K, V> {\n    type Item = (&'a K, &'a V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Iter<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for IterMut<'a, K, V> {\n    type Item = (&'a K, &'a mut V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for IterMut<'_, K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V> fmt::Debug for IterMut<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Iterator for IntoIter<K, V> {\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for IntoIter<K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for IntoIter<K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: Debug, V: Debug> fmt::Debug for IntoIter<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Keys<'a, K, V> {\n    type Item = &'a K;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a K> {\n        self.inner.next().map(|(k, _)| k)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Keys<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Keys<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Values<'a, K, V> {\n    type Item = &'a V;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a V> {\n        self.inner.next().map(|(_, v)| v)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Values<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Values<'_, K, V> {}\n\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\nimpl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n    type Item = &'a mut V;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut V> {\n        self.inner.next().map(|(_, v)| v)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\nimpl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V: fmt::Debug> fmt::Debug for ValuesMut<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.inner.iter().map(|(_, val)| val)).finish()\n    }\n}\n\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> Iterator for IntoKeys<K, V> {\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n        self.inner.next().map(|(k, _)| k)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> ExactSizeIterator for IntoKeys<K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> FusedIterator for IntoKeys<K, V> {}\n\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K: Debug, V> fmt::Debug for IntoKeys<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.inner.iter().map(|(k, _)| k)).finish()\n    }\n}\n\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> Iterator for IntoValues<K, V> {\n    type Item = V;\n\n    #[inline]\n    fn next(&mut self) -> Option<V> {\n        self.inner.next().map(|(_, v)| v)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> ExactSizeIterator for IntoValues<K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V> FusedIterator for IntoValues<K, V> {}\n\n#[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\nimpl<K, V: Debug> fmt::Debug for IntoValues<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.inner.iter().map(|(_, v)| v)).finish()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, K, V> Iterator for Drain<'a, K, V> {\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<K, V> ExactSizeIterator for Drain<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.base.len()\n    }\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Drain<'_, K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V> fmt::Debug for Drain<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\nwhere\n    F: FnMut(&K, &mut V) -> bool,\n{\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n\n#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\nimpl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\nwhere\n    F: FnMut(&K, &mut V) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"DrainFilter\").finish_non_exhaustive()\n    }\n}\n\nimpl<'a, K, V> Entry<'a, K, V> {\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.entry(\"poneyland\").or_insert(3);\n    /// assert_eq!(map[\"poneyland\"], 3);\n    ///\n    /// *map.entry(\"poneyland\").or_insert(10) *= 2;\n    /// assert_eq!(map[\"poneyland\"], 6);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_insert(self, default: V) -> &'a mut V {\n        match self {\n            Occupied(entry) => entry.into_mut(),\n            Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    /// let s = \"hoho\".to_string();\n    ///\n    /// map.entry(\"poneyland\").or_insert_with(|| s);\n    ///\n    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n        match self {\n            Occupied(entry) => entry.into_mut(),\n            Vacant(entry) => entry.insert(default()),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting, if empty, the result of the default function.\n    /// This method allows for generating key-derived values for insertion by providing the default\n    /// function a reference to the key that was moved during the `.entry(key)` method call.\n    ///\n    /// The reference to the moved key is provided so that cloning or copying the key is\n    /// unnecessary, unlike with `.or_insert_with(|| ... )`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, usize> = HashMap::new();\n    ///\n    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n    ///\n    /// assert_eq!(map[\"poneyland\"], 9);\n    /// ```\n    #[inline]\n    #[stable(feature = \"or_insert_with_key\", since = \"1.50.0\")]\n    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n        match self {\n            Occupied(entry) => entry.into_mut(),\n            Vacant(entry) => {\n                let value = default(entry.key());\n                entry.insert(value)\n            }\n        }\n    }\n\n    /// Returns a reference to this entry's key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n        match *self {\n            Occupied(ref entry) => entry.key(),\n            Vacant(ref entry) => entry.key(),\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.entry(\"poneyland\")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map[\"poneyland\"], 42);\n    ///\n    /// map.entry(\"poneyland\")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map[\"poneyland\"], 43);\n    /// ```\n    #[inline]\n    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        match self {\n            Occupied(mut entry) => {\n                f(entry.get_mut());\n                Occupied(entry)\n            }\n            Vacant(entry) => Vacant(entry),\n        }\n    }\n\n    /// Sets the value of the entry, and returns an `OccupiedEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(entry_insert)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    /// let entry = map.entry(\"poneyland\").insert(\"hoho\".to_string());\n    ///\n    /// assert_eq!(entry.key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"entry_insert\", issue = \"65225\")]\n    pub fn insert(self, value: V) -> OccupiedEntry<'a, K, V> {\n        match self {\n            Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            Vacant(entry) => entry.insert_entry(value),\n        }\n    }\n}\n\nimpl<'a, K, V: Default> Entry<'a, K, V> {\n    /// Ensures a value is in the entry by inserting the default value if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n    /// map.entry(\"poneyland\").or_default();\n    ///\n    /// assert_eq!(map[\"poneyland\"], None);\n    /// # }\n    /// ```\n    #[inline]\n    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n    pub fn or_default(self) -> &'a mut V {\n        match self {\n            Occupied(entry) => entry.into_mut(),\n            Vacant(entry) => entry.insert(Default::default()),\n        }\n    }\n}\n\nimpl<'a, K, V> OccupiedEntry<'a, K, V> {\n    /// Gets a reference to the key in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n        self.base.key()\n    }\n\n    /// Take the ownership of the key and value from the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     // We delete the entry from the map.\n    ///     o.remove_entry();\n    /// }\n    ///\n    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n    pub fn remove_entry(self) -> (K, V) {\n        self.base.remove_entry()\n    }\n\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.get(), &12);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get(&self) -> &V {\n        self.base.get()\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// If you need a reference to the `OccupiedEntry` which may outlive the\n    /// destruction of the `Entry` value, see [`into_mut`].\n    ///\n    /// [`into_mut`]: Self::into_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// assert_eq!(map[\"poneyland\"], 12);\n    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n    ///     *o.get_mut() += 10;\n    ///     assert_eq!(*o.get(), 22);\n    ///\n    ///     // We can use the same Entry multiple times.\n    ///     *o.get_mut() += 2;\n    /// }\n    ///\n    /// assert_eq!(map[\"poneyland\"], 24);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut V {\n        self.base.get_mut()\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    ///\n    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n    ///\n    /// [`get_mut`]: Self::get_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// assert_eq!(map[\"poneyland\"], 12);\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     *o.into_mut() += 10;\n    /// }\n    ///\n    /// assert_eq!(map[\"poneyland\"], 22);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_mut(self) -> &'a mut V {\n        self.base.into_mut()\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.insert(15), 12);\n    /// }\n    ///\n    /// assert_eq!(map[\"poneyland\"], 15);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, value: V) -> V {\n        self.base.insert(value)\n    }\n\n    /// Takes the value out of the entry, and returns it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.remove(), 12);\n    /// }\n    ///\n    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(self) -> V {\n        self.base.remove()\n    }\n\n    /// Replaces the entry, returning the old key and value. The new key in the hash map will be\n    /// the key used to create this entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(map_entry_replace)]\n    /// use std::collections::hash_map::{Entry, HashMap};\n    /// use std::rc::Rc;\n    ///\n    /// let mut map: HashMap<Rc<String>, u32> = HashMap::new();\n    /// map.insert(Rc::new(\"Stringthing\".to_string()), 15);\n    ///\n    /// let my_key = Rc::new(\"Stringthing\".to_string());\n    ///\n    /// if let Entry::Occupied(entry) = map.entry(my_key) {\n    ///     // Also replace the key with a handle to our other key.\n    ///     let (old_key, old_value): (Rc<String>, u32) = entry.replace_entry(16);\n    /// }\n    ///\n    /// ```\n    #[inline]\n    #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n    pub fn replace_entry(self, value: V) -> (K, V) {\n        self.base.replace_entry(value)\n    }\n\n    /// Replaces the key in the hash map with the key used to create this entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(map_entry_replace)]\n    /// use std::collections::hash_map::{Entry, HashMap};\n    /// use std::rc::Rc;\n    ///\n    /// let mut map: HashMap<Rc<String>, u32> = HashMap::new();\n    /// let known_strings: Vec<Rc<String>> = Vec::new();\n    ///\n    /// // Initialise known strings, run program, etc.\n    ///\n    /// reclaim_memory(&mut map, &known_strings);\n    ///\n    /// fn reclaim_memory(map: &mut HashMap<Rc<String>, u32>, known_strings: &[Rc<String>] ) {\n    ///     for s in known_strings {\n    ///         if let Entry::Occupied(entry) = map.entry(Rc::clone(s)) {\n    ///             // Replaces the entry's key with our version of it in `known_strings`.\n    ///             entry.replace_key();\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n    pub fn replace_key(self) -> K {\n        self.base.replace_key()\n    }\n}\n\nimpl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the `VacantEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n        self.base.key()\n    }\n\n    /// Take ownership of the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n    ///     v.into_key();\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n    pub fn into_key(self) -> K {\n        self.base.into_key()\n    }\n\n    /// Sets the value of the entry with the `VacantEntry`'s key,\n    /// and returns a mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n    ///     o.insert(37);\n    /// }\n    /// assert_eq!(map[\"poneyland\"], 37);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(self, value: V) -> &'a mut V {\n        self.base.insert(value)\n    }\n\n    /// Sets the value of the entry with the `VacantEntry`'s key,\n    /// and returns an `OccupiedEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n    ///     o.insert(37);\n    /// }\n    /// assert_eq!(map[\"poneyland\"], 37);\n    /// ```\n    #[inline]\n    fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {\n        let base = self.base.insert_entry(value);\n        OccupiedEntry { base }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher + Default,\n{\n    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> HashMap<K, V, S> {\n        let mut map = HashMap::with_hasher(Default::default());\n        map.extend(iter);\n        map\n    }\n}\n\n/// Inserts all new key-values from the iterator and replaces values with existing\n/// keys with new values returned from the iterator.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n        self.base.extend(iter)\n    }\n\n    #[inline]\n    fn extend_one(&mut self, (k, v): (K, V)) {\n        self.base.insert(k, v);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        // self.base.extend_reserve(additional);\n        // FIXME: hashbrown should implement this method.\n        // But until then, use the same reservation logic:\n\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let reserve = if self.is_empty() { additional } else { (additional + 1) / 2 };\n        self.base.reserve(reserve);\n    }\n}\n\n#[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\nimpl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash + Copy,\n    V: Copy,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n        self.base.extend(iter)\n    }\n\n    #[inline]\n    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n        self.base.insert(k, v);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<(K, V)>::extend_reserve(self, additional)\n    }\n}\n\n/// `RandomState` is the default state for [`HashMap`] types.\n///\n/// A particular instance `RandomState` will create the same instances of\n/// [`Hasher`], but the hashers created by two different `RandomState`\n/// instances are unlikely to produce the same result for the same values.\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashMap;\n/// use std::collections::hash_map::RandomState;\n///\n/// let s = RandomState::new();\n/// let mut map = HashMap::with_hasher(s);\n/// map.insert(1, 2);\n/// ```\n#[derive(Clone)]\n#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\npub struct RandomState {\n    k0: u64,\n    k1: u64,\n}\n\nimpl RandomState {\n    /// Constructs a new `RandomState` that is initialized with random keys.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// ```\n    #[inline]\n    #[allow(deprecated)]\n    // rand\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn new() -> RandomState {\n        // Historically this function did not cache keys from the OS and instead\n        // simply always called `rand::thread_rng().gen()` twice. In #31356 it\n        // was discovered, however, that because we re-seed the thread-local RNG\n        // from the OS periodically that this can cause excessive slowdown when\n        // many hash maps are created on a thread. To solve this performance\n        // trap we cache the first set of randomly generated keys per-thread.\n        //\n        // Later in #36481 it was discovered that exposing a deterministic\n        // iteration order allows a form of DOS attack. To counter that we\n        // increment one of the seeds on every RandomState creation, giving\n        // every corresponding HashMap a different iteration order.\n        thread_local!(static KEYS: Cell<(u64, u64)> = {\n            Cell::new(sys::hashmap_random_keys())\n        });\n\n        KEYS.with(|keys| {\n            let (k0, k1) = keys.get();\n            keys.set((k0.wrapping_add(1), k1));\n            RandomState { k0, k1 }\n        })\n    }\n}\n\n#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\nimpl BuildHasher for RandomState {\n    type Hasher = DefaultHasher;\n    #[inline]\n    #[allow(deprecated)]\n    fn build_hasher(&self) -> DefaultHasher {\n        DefaultHasher(SipHasher13::new_with_keys(self.k0, self.k1))\n    }\n}\n\n/// The default [`Hasher`] used by [`RandomState`].\n///\n/// The internal algorithm is not specified, and so it and its hashes should\n/// not be relied upon over releases.\n#[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n#[allow(deprecated)]\n#[derive(Clone, Debug)]\npub struct DefaultHasher(SipHasher13);\n\nimpl DefaultHasher {\n    /// Creates a new `DefaultHasher`.\n    ///\n    /// This hasher is not guaranteed to be the same as all other\n    /// `DefaultHasher` instances, but is the same as all other `DefaultHasher`\n    /// instances created through `new` or `default`.\n    #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n    #[allow(deprecated)]\n    pub fn new() -> DefaultHasher {\n        DefaultHasher(SipHasher13::new_with_keys(0, 0))\n    }\n}\n\n#[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\nimpl Default for DefaultHasher {\n    /// Creates a new `DefaultHasher` using [`new`].\n    /// See its documentation for more.\n    ///\n    /// [`new`]: DefaultHasher::new\n    fn default() -> DefaultHasher {\n        DefaultHasher::new()\n    }\n}\n\n#[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\nimpl Hasher for DefaultHasher {\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n        self.0.write(msg)\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        self.0.finish()\n    }\n}\n\n#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\nimpl Default for RandomState {\n    /// Constructs a new `RandomState`.\n    #[inline]\n    fn default() -> RandomState {\n        RandomState::new()\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for RandomState {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RandomState\").finish_non_exhaustive()\n    }\n}\n\n#[inline]\nfn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K, V> {\n    match raw {\n        base::RustcEntry::Occupied(base) => Entry::Occupied(OccupiedEntry { base }),\n        base::RustcEntry::Vacant(base) => Entry::Vacant(VacantEntry { base }),\n    }\n}\n\n#[inline]\npub(super) fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n    match err {\n        hashbrown::TryReserveError::CapacityOverflow => TryReserveError::CapacityOverflow,\n        hashbrown::TryReserveError::AllocError { layout } => {\n            TryReserveError::AllocError { layout, non_exhaustive: () }\n        }\n    }\n}\n\n#[inline]\nfn map_raw_entry<'a, K: 'a, V: 'a, S: 'a>(\n    raw: base::RawEntryMut<'a, K, V, S>,\n) -> RawEntryMut<'a, K, V, S> {\n    match raw {\n        base::RawEntryMut::Occupied(base) => RawEntryMut::Occupied(RawOccupiedEntryMut { base }),\n        base::RawEntryMut::Vacant(base) => RawEntryMut::Vacant(RawVacantEntryMut { base }),\n    }\n}\n\n#[allow(dead_code)]\nfn assert_covariance() {\n    fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> {\n        v\n    }\n    fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str> {\n        v\n    }\n    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8> {\n        v\n    }\n    fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str> {\n        v\n    }\n    fn into_iter_key<'new>(v: IntoIter<&'static str, u8>) -> IntoIter<&'new str, u8> {\n        v\n    }\n    fn into_iter_val<'new>(v: IntoIter<u8, &'static str>) -> IntoIter<u8, &'new str> {\n        v\n    }\n    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8> {\n        v\n    }\n    fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str> {\n        v\n    }\n    fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8> {\n        v\n    }\n    fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> {\n        v\n    }\n    fn drain<'new>(\n        d: Drain<'static, &'static str, &'static str>,\n    ) -> Drain<'new, &'new str, &'new str> {\n        d\n    }\n}\n"],["2558","use super::super::map::RandomState;\nuse super::HashSet;\n\nuse crate::panic::{catch_unwind, AssertUnwindSafe};\nuse crate::sync::atomic::{AtomicU32, Ordering};\n\n#[test]\nfn test_zero_capacities() {\n    type HS = HashSet<i32>;\n\n    let s = HS::new();\n    assert_eq!(s.capacity(), 0);\n\n    let s = HS::default();\n    assert_eq!(s.capacity(), 0);\n\n    let s = HS::with_hasher(RandomState::new());\n    assert_eq!(s.capacity(), 0);\n\n    let s = HS::with_capacity(0);\n    assert_eq!(s.capacity(), 0);\n\n    let s = HS::with_capacity_and_hasher(0, RandomState::new());\n    assert_eq!(s.capacity(), 0);\n\n    let mut s = HS::new();\n    s.insert(1);\n    s.insert(2);\n    s.remove(&1);\n    s.remove(&2);\n    s.shrink_to_fit();\n    assert_eq!(s.capacity(), 0);\n\n    let mut s = HS::new();\n    s.reserve(0);\n    assert_eq!(s.capacity(), 0);\n}\n\n#[test]\nfn test_disjoint() {\n    let mut xs = HashSet::new();\n    let mut ys = HashSet::new();\n    assert!(xs.is_disjoint(&ys));\n    assert!(ys.is_disjoint(&xs));\n    assert!(xs.insert(5));\n    assert!(ys.insert(11));\n    assert!(xs.is_disjoint(&ys));\n    assert!(ys.is_disjoint(&xs));\n    assert!(xs.insert(7));\n    assert!(xs.insert(19));\n    assert!(xs.insert(4));\n    assert!(ys.insert(2));\n    assert!(ys.insert(-11));\n    assert!(xs.is_disjoint(&ys));\n    assert!(ys.is_disjoint(&xs));\n    assert!(ys.insert(7));\n    assert!(!xs.is_disjoint(&ys));\n    assert!(!ys.is_disjoint(&xs));\n}\n\n#[test]\nfn test_subset_and_superset() {\n    let mut a = HashSet::new();\n    assert!(a.insert(0));\n    assert!(a.insert(5));\n    assert!(a.insert(11));\n    assert!(a.insert(7));\n\n    let mut b = HashSet::new();\n    assert!(b.insert(0));\n    assert!(b.insert(7));\n    assert!(b.insert(19));\n    assert!(b.insert(250));\n    assert!(b.insert(11));\n    assert!(b.insert(200));\n\n    assert!(!a.is_subset(&b));\n    assert!(!a.is_superset(&b));\n    assert!(!b.is_subset(&a));\n    assert!(!b.is_superset(&a));\n\n    assert!(b.insert(5));\n\n    assert!(a.is_subset(&b));\n    assert!(!a.is_superset(&b));\n    assert!(!b.is_subset(&a));\n    assert!(b.is_superset(&a));\n}\n\n#[test]\nfn test_iterate() {\n    let mut a = HashSet::new();\n    for i in 0..32 {\n        assert!(a.insert(i));\n    }\n    let mut observed: u32 = 0;\n    for k in &a {\n        observed |= 1 << *k;\n    }\n    assert_eq!(observed, 0xFFFF_FFFF);\n}\n\n#[test]\nfn test_intersection() {\n    let mut a = HashSet::new();\n    let mut b = HashSet::new();\n    assert!(a.intersection(&b).next().is_none());\n\n    assert!(a.insert(11));\n    assert!(a.insert(1));\n    assert!(a.insert(3));\n    assert!(a.insert(77));\n    assert!(a.insert(103));\n    assert!(a.insert(5));\n    assert!(a.insert(-5));\n\n    assert!(b.insert(2));\n    assert!(b.insert(11));\n    assert!(b.insert(77));\n    assert!(b.insert(-9));\n    assert!(b.insert(-42));\n    assert!(b.insert(5));\n    assert!(b.insert(3));\n\n    let mut i = 0;\n    let expected = [3, 5, 11, 77];\n    for x in a.intersection(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n\n    assert!(a.insert(9)); // make a bigger than b\n\n    i = 0;\n    for x in a.intersection(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n\n    i = 0;\n    for x in b.intersection(&a) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n}\n\n#[test]\nfn test_difference() {\n    let mut a = HashSet::new();\n    let mut b = HashSet::new();\n\n    assert!(a.insert(1));\n    assert!(a.insert(3));\n    assert!(a.insert(5));\n    assert!(a.insert(9));\n    assert!(a.insert(11));\n\n    assert!(b.insert(3));\n    assert!(b.insert(9));\n\n    let mut i = 0;\n    let expected = [1, 5, 11];\n    for x in a.difference(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n}\n\n#[test]\nfn test_symmetric_difference() {\n    let mut a = HashSet::new();\n    let mut b = HashSet::new();\n\n    assert!(a.insert(1));\n    assert!(a.insert(3));\n    assert!(a.insert(5));\n    assert!(a.insert(9));\n    assert!(a.insert(11));\n\n    assert!(b.insert(-2));\n    assert!(b.insert(3));\n    assert!(b.insert(9));\n    assert!(b.insert(14));\n    assert!(b.insert(22));\n\n    let mut i = 0;\n    let expected = [-2, 1, 5, 11, 14, 22];\n    for x in a.symmetric_difference(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n}\n\n#[test]\nfn test_union() {\n    let mut a = HashSet::new();\n    let mut b = HashSet::new();\n    assert!(a.union(&b).next().is_none());\n    assert!(b.union(&a).next().is_none());\n\n    assert!(a.insert(1));\n    assert!(a.insert(3));\n    assert!(a.insert(11));\n    assert!(a.insert(16));\n    assert!(a.insert(19));\n    assert!(a.insert(24));\n\n    assert!(b.insert(-2));\n    assert!(b.insert(1));\n    assert!(b.insert(5));\n    assert!(b.insert(9));\n    assert!(b.insert(13));\n    assert!(b.insert(19));\n\n    let mut i = 0;\n    let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n    for x in a.union(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n\n    assert!(a.insert(9)); // make a bigger than b\n    assert!(a.insert(5));\n\n    i = 0;\n    for x in a.union(&b) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n\n    i = 0;\n    for x in b.union(&a) {\n        assert!(expected.contains(x));\n        i += 1\n    }\n    assert_eq!(i, expected.len());\n}\n\n#[test]\nfn test_from_iter() {\n    let xs = [1, 2, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    let set: HashSet<_> = xs.iter().cloned().collect();\n\n    for x in &xs {\n        assert!(set.contains(x));\n    }\n\n    assert_eq!(set.iter().len(), xs.len() - 1);\n}\n\n#[test]\nfn test_move_iter() {\n    let hs = {\n        let mut hs = HashSet::new();\n\n        hs.insert('a');\n        hs.insert('b');\n\n        hs\n    };\n\n    let v = hs.into_iter().collect::<Vec<char>>();\n    assert!(v == ['a', 'b'] || v == ['b', 'a']);\n}\n\n#[test]\nfn test_eq() {\n    // These constants once happened to expose a bug in insert().\n    // I'm keeping them around to prevent a regression.\n    let mut s1 = HashSet::new();\n\n    s1.insert(1);\n    s1.insert(2);\n    s1.insert(3);\n\n    let mut s2 = HashSet::new();\n\n    s2.insert(1);\n    s2.insert(2);\n\n    assert!(s1 != s2);\n\n    s2.insert(3);\n\n    assert_eq!(s1, s2);\n}\n\n#[test]\nfn test_show() {\n    let mut set = HashSet::new();\n    let empty = HashSet::<i32>::new();\n\n    set.insert(1);\n    set.insert(2);\n\n    let set_str = format!(\"{:?}\", set);\n\n    assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n    assert_eq!(format!(\"{:?}\", empty), \"{}\");\n}\n\n#[test]\nfn test_trivial_drain() {\n    let mut s = HashSet::<i32>::new();\n    for _ in s.drain() {}\n    assert!(s.is_empty());\n    drop(s);\n\n    let mut s = HashSet::<i32>::new();\n    drop(s.drain());\n    assert!(s.is_empty());\n}\n\n#[test]\nfn test_drain() {\n    let mut s: HashSet<_> = (1..100).collect();\n\n    // try this a bunch of times to make sure we don't screw up internal state.\n    for _ in 0..20 {\n        assert_eq!(s.len(), 99);\n\n        {\n            let mut last_i = 0;\n            let mut d = s.drain();\n            for (i, x) in d.by_ref().take(50).enumerate() {\n                last_i = i;\n                assert!(x != 0);\n            }\n            assert_eq!(last_i, 49);\n        }\n\n        for _ in &s {\n            panic!(\"s should be empty!\");\n        }\n\n        // reset to try again.\n        s.extend(1..100);\n    }\n}\n\n#[test]\nfn test_replace() {\n    use crate::hash;\n\n    #[derive(Debug)]\n    struct Foo(&'static str, i32);\n\n    impl PartialEq for Foo {\n        fn eq(&self, other: &Self) -> bool {\n            self.0 == other.0\n        }\n    }\n\n    impl Eq for Foo {}\n\n    impl hash::Hash for Foo {\n        fn hash<H: hash::Hasher>(&self, h: &mut H) {\n            self.0.hash(h);\n        }\n    }\n\n    let mut s = HashSet::new();\n    assert_eq!(s.replace(Foo(\"a\", 1)), None);\n    assert_eq!(s.len(), 1);\n    assert_eq!(s.replace(Foo(\"a\", 2)), Some(Foo(\"a\", 1)));\n    assert_eq!(s.len(), 1);\n\n    let mut it = s.iter();\n    assert_eq!(it.next(), Some(&Foo(\"a\", 2)));\n    assert_eq!(it.next(), None);\n}\n\n#[test]\nfn test_extend_ref() {\n    let mut a = HashSet::new();\n    a.insert(1);\n\n    a.extend(&[2, 3, 4]);\n\n    assert_eq!(a.len(), 4);\n    assert!(a.contains(&1));\n    assert!(a.contains(&2));\n    assert!(a.contains(&3));\n    assert!(a.contains(&4));\n\n    let mut b = HashSet::new();\n    b.insert(5);\n    b.insert(6);\n\n    a.extend(&b);\n\n    assert_eq!(a.len(), 6);\n    assert!(a.contains(&1));\n    assert!(a.contains(&2));\n    assert!(a.contains(&3));\n    assert!(a.contains(&4));\n    assert!(a.contains(&5));\n    assert!(a.contains(&6));\n}\n\n#[test]\nfn test_retain() {\n    let xs = [1, 2, 3, 4, 5, 6];\n    let mut set: HashSet<i32> = xs.iter().cloned().collect();\n    set.retain(|&k| k % 2 == 0);\n    assert_eq!(set.len(), 3);\n    assert!(set.contains(&2));\n    assert!(set.contains(&4));\n    assert!(set.contains(&6));\n}\n\n#[test]\nfn test_drain_filter() {\n    let mut x: HashSet<_> = [1].iter().copied().collect();\n    let mut y: HashSet<_> = [1].iter().copied().collect();\n\n    x.drain_filter(|_| true);\n    y.drain_filter(|_| false);\n    assert_eq!(x.len(), 0);\n    assert_eq!(y.len(), 1);\n}\n\n#[test]\nfn test_drain_filter_drop_panic_leak() {\n    static PREDS: AtomicU32 = AtomicU32::new(0);\n    static DROPS: AtomicU32 = AtomicU32::new(0);\n\n    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n    struct D(i32);\n    impl Drop for D {\n        fn drop(&mut self) {\n            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n                panic!(\"panic in `drop`\");\n            }\n        }\n    }\n\n    let mut set = (0..3).map(|i| D(i)).collect::<HashSet<_>>();\n\n    catch_unwind(move || {\n        drop(set.drain_filter(|_| {\n            PREDS.fetch_add(1, Ordering::SeqCst);\n            true\n        }))\n    })\n    .ok();\n\n    assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n}\n\n#[test]\nfn test_drain_filter_pred_panic_leak() {\n    static PREDS: AtomicU32 = AtomicU32::new(0);\n    static DROPS: AtomicU32 = AtomicU32::new(0);\n\n    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n    struct D;\n    impl Drop for D {\n        fn drop(&mut self) {\n            DROPS.fetch_add(1, Ordering::SeqCst);\n        }\n    }\n\n    let mut set: HashSet<_> = (0..3).map(|_| D).collect();\n\n    catch_unwind(AssertUnwindSafe(|| {\n        drop(set.drain_filter(|_| match PREDS.fetch_add(1, Ordering::SeqCst) {\n            0 => true,\n            _ => panic!(),\n        }))\n    }))\n    .ok();\n\n    assert_eq!(PREDS.load(Ordering::SeqCst), 1);\n    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n    assert_eq!(set.len(), 0);\n}\n"],["2559","//! Collection types.\n//!\n//! Rust's standard collection library provides efficient implementations of the\n//! most common general purpose programming data structures. By using the\n//! standard implementations, it should be possible for two libraries to\n//! communicate without significant data conversion.\n//!\n//! To get this out of the way: you should probably just use [`Vec`] or [`HashMap`].\n//! These two collections cover most use cases for generic data storage and\n//! processing. They are exceptionally good at doing what they do. All the other\n//! collections in the standard library have specific use cases where they are\n//! the optimal choice, but these cases are borderline *niche* in comparison.\n//! Even when `Vec` and `HashMap` are technically suboptimal, they're probably a\n//! good enough choice to get started.\n//!\n//! Rust's collections can be grouped into four major categories:\n//!\n//! * Sequences: [`Vec`], [`VecDeque`], [`LinkedList`]\n//! * Maps: [`HashMap`], [`BTreeMap`]\n//! * Sets: [`HashSet`], [`BTreeSet`]\n//! * Misc: [`BinaryHeap`]\n//!\n//! # When Should You Use Which Collection?\n//!\n//! These are fairly high-level and quick break-downs of when each collection\n//! should be considered. Detailed discussions of strengths and weaknesses of\n//! individual collections can be found on their own documentation pages.\n//!\n//! ### Use a `Vec` when:\n//! * You want to collect items up to be processed or sent elsewhere later, and\n//!   don't care about any properties of the actual values being stored.\n//! * You want a sequence of elements in a particular order, and will only be\n//!   appending to (or near) the end.\n//! * You want a stack.\n//! * You want a resizable array.\n//! * You want a heap-allocated array.\n//!\n//! ### Use a `VecDeque` when:\n//! * You want a [`Vec`] that supports efficient insertion at both ends of the\n//!   sequence.\n//! * You want a queue.\n//! * You want a double-ended queue (deque).\n//!\n//! ### Use a `LinkedList` when:\n//! * You want a [`Vec`] or [`VecDeque`] of unknown size, and can't tolerate\n//!   amortization.\n//! * You want to efficiently split and append lists.\n//! * You are *absolutely* certain you *really*, *truly*, want a doubly linked\n//!   list.\n//!\n//! ### Use a `HashMap` when:\n//! * You want to associate arbitrary keys with an arbitrary value.\n//! * You want a cache.\n//! * You want a map, with no extra functionality.\n//!\n//! ### Use a `BTreeMap` when:\n//! * You want a map sorted by its keys.\n//! * You want to be able to get a range of entries on-demand.\n//! * You're interested in what the smallest or largest key-value pair is.\n//! * You want to find the largest or smallest key that is smaller or larger\n//!   than something.\n//!\n//! ### Use the `Set` variant of any of these `Map`s when:\n//! * You just want to remember which keys you've seen.\n//! * There is no meaningful value to associate with your keys.\n//! * You just want a set.\n//!\n//! ### Use a `BinaryHeap` when:\n//!\n//! * You want to store a bunch of elements, but only ever want to process the\n//!   \"biggest\" or \"most important\" one at any given time.\n//! * You want a priority queue.\n//!\n//! # Performance\n//!\n//! Choosing the right collection for the job requires an understanding of what\n//! each collection is good at. Here we briefly summarize the performance of\n//! different collections for certain important operations. For further details,\n//! see each type's documentation, and note that the names of actual methods may\n//! differ from the tables below on certain collections.\n//!\n//! Throughout the documentation, we will follow a few conventions. For all\n//! operations, the collection's size is denoted by n. If another collection is\n//! involved in the operation, it contains m elements. Operations which have an\n//! *amortized* cost are suffixed with a `*`. Operations with an *expected*\n//! cost are suffixed with a `~`.\n//!\n//! All amortized costs are for the potential need to resize when capacity is\n//! exhausted. If a resize occurs it will take *O*(*n*) time. Our collections never\n//! automatically shrink, so removal operations aren't amortized. Over a\n//! sufficiently large series of operations, the average cost per operation will\n//! deterministically equal the given cost.\n//!\n//! Only [`HashMap`] has expected costs, due to the probabilistic nature of hashing.\n//! It is theoretically possible, though very unlikely, for [`HashMap`] to\n//! experience worse performance.\n//!\n//! ## Sequences\n//!\n//! |                | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n//! |----------------|----------------|-----------------|----------------|--------|----------------|\n//! | [`Vec`]        | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n//! | [`VecDeque`]   | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n//! | [`LinkedList`] | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n//!\n//! Note that where ties occur, [`Vec`] is generally going to be faster than [`VecDeque`], and\n//! [`VecDeque`] is generally going to be faster than [`LinkedList`].\n//!\n//! ## Maps\n//!\n//! For Sets, all operations have the cost of the equivalent Map operation.\n//!\n//! |              | get       | insert    | remove    | range     | append |\n//! |--------------|-----------|-----------|-----------|-----------|--------|\n//! | [`HashMap`]  | O(1)~     | O(1)~*    | O(1)~     | N/A       | N/A    |\n//! | [`BTreeMap`] | O(log(n)) | O(log(n)) | O(log(n)) | O(log(n)) | O(n+m) |\n//!\n//! # Correct and Efficient Usage of Collections\n//!\n//! Of course, knowing which collection is the right one for the job doesn't\n//! instantly permit you to use it correctly. Here are some quick tips for\n//! efficient and correct usage of the standard collections in general. If\n//! you're interested in how to use a specific collection in particular, consult\n//! its documentation for detailed discussion and code examples.\n//!\n//! ## Capacity Management\n//!\n//! Many collections provide several constructors and methods that refer to\n//! \"capacity\". These collections are generally built on top of an array.\n//! Optimally, this array would be exactly the right size to fit only the\n//! elements stored in the collection, but for the collection to do this would\n//! be very inefficient. If the backing array was exactly the right size at all\n//! times, then every time an element is inserted, the collection would have to\n//! grow the array to fit it. Due to the way memory is allocated and managed on\n//! most computers, this would almost surely require allocating an entirely new\n//! array and copying every single element from the old one into the new one.\n//! Hopefully you can see that this wouldn't be very efficient to do on every\n//! operation.\n//!\n//! Most collections therefore use an *amortized* allocation strategy. They\n//! generally let themselves have a fair amount of unoccupied space so that they\n//! only have to grow on occasion. When they do grow, they allocate a\n//! substantially larger array to move the elements into so that it will take a\n//! while for another grow to be required. While this strategy is great in\n//! general, it would be even better if the collection *never* had to resize its\n//! backing array. Unfortunately, the collection itself doesn't have enough\n//! information to do this itself. Therefore, it is up to us programmers to give\n//! it hints.\n//!\n//! Any `with_capacity` constructor will instruct the collection to allocate\n//! enough space for the specified number of elements. Ideally this will be for\n//! exactly that many elements, but some implementation details may prevent\n//! this. See collection-specific documentation for details. In general, use\n//! `with_capacity` when you know exactly how many elements will be inserted, or\n//! at least have a reasonable upper-bound on that number.\n//!\n//! When anticipating a large influx of elements, the `reserve` family of\n//! methods can be used to hint to the collection how much room it should make\n//! for the coming items. As with `with_capacity`, the precise behavior of\n//! these methods will be specific to the collection of interest.\n//!\n//! For optimal performance, collections will generally avoid shrinking\n//! themselves. If you believe that a collection will not soon contain any more\n//! elements, or just really need the memory, the `shrink_to_fit` method prompts\n//! the collection to shrink the backing array to the minimum size capable of\n//! holding its elements.\n//!\n//! Finally, if ever you're interested in what the actual capacity of the\n//! collection is, most collections provide a `capacity` method to query this\n//! information on demand. This can be useful for debugging purposes, or for\n//! use with the `reserve` methods.\n//!\n//! ## Iterators\n//!\n//! Iterators are a powerful and robust mechanism used throughout Rust's\n//! standard libraries. Iterators provide a sequence of values in a generic,\n//! safe, efficient and convenient way. The contents of an iterator are usually\n//! *lazily* evaluated, so that only the values that are actually needed are\n//! ever actually produced, and no allocation need be done to temporarily store\n//! them. Iterators are primarily consumed using a `for` loop, although many\n//! functions also take iterators where a collection or sequence of values is\n//! desired.\n//!\n//! All of the standard collections provide several iterators for performing\n//! bulk manipulation of their contents. The three primary iterators almost\n//! every collection should provide are `iter`, `iter_mut`, and `into_iter`.\n//! Some of these are not provided on collections where it would be unsound or\n//! unreasonable to provide them.\n//!\n//! `iter` provides an iterator of immutable references to all the contents of a\n//! collection in the most \"natural\" order. For sequence collections like [`Vec`],\n//! this means the items will be yielded in increasing order of index starting\n//! at 0. For ordered collections like [`BTreeMap`], this means that the items\n//! will be yielded in sorted order. For unordered collections like [`HashMap`],\n//! the items will be yielded in whatever order the internal representation made\n//! most convenient. This is great for reading through all the contents of the\n//! collection.\n//!\n//! ```\n//! let vec = vec![1, 2, 3, 4];\n//! for x in vec.iter() {\n//!    println!(\"vec contained {}\", x);\n//! }\n//! ```\n//!\n//! `iter_mut` provides an iterator of *mutable* references in the same order as\n//! `iter`. This is great for mutating all the contents of the collection.\n//!\n//! ```\n//! let mut vec = vec![1, 2, 3, 4];\n//! for x in vec.iter_mut() {\n//!    *x += 1;\n//! }\n//! ```\n//!\n//! `into_iter` transforms the actual collection into an iterator over its\n//! contents by-value. This is great when the collection itself is no longer\n//! needed, and the values are needed elsewhere. Using `extend` with `into_iter`\n//! is the main way that contents of one collection are moved into another.\n//! `extend` automatically calls `into_iter`, and takes any `T: `[`IntoIterator`].\n//! Calling `collect` on an iterator itself is also a great way to convert one\n//! collection into another. Both of these methods should internally use the\n//! capacity management tools discussed in the previous section to do this as\n//! efficiently as possible.\n//!\n//! ```\n//! let mut vec1 = vec![1, 2, 3, 4];\n//! let vec2 = vec![10, 20, 30, 40];\n//! vec1.extend(vec2);\n//! ```\n//!\n//! ```\n//! use std::collections::VecDeque;\n//!\n//! let vec = vec![1, 2, 3, 4];\n//! let buf: VecDeque<_> = vec.into_iter().collect();\n//! ```\n//!\n//! Iterators also provide a series of *adapter* methods for performing common\n//! threads to sequences. Among the adapters are functional favorites like `map`,\n//! `fold`, `skip` and `take`. Of particular interest to collections is the\n//! `rev` adapter, that reverses any iterator that supports this operation. Most\n//! collections provide reversible iterators as the way to iterate over them in\n//! reverse order.\n//!\n//! ```\n//! let vec = vec![1, 2, 3, 4];\n//! for x in vec.iter().rev() {\n//!    println!(\"vec contained {}\", x);\n//! }\n//! ```\n//!\n//! Several other collection methods also return iterators to yield a sequence\n//! of results but avoid allocating an entire collection to store the result in.\n//! This provides maximum flexibility as `collect` or `extend` can be called to\n//! \"pipe\" the sequence into any collection if desired. Otherwise, the sequence\n//! can be looped over with a `for` loop. The iterator can also be discarded\n//! after partial use, preventing the computation of the unused items.\n//!\n//! ## Entries\n//!\n//! The `entry` API is intended to provide an efficient mechanism for\n//! manipulating the contents of a map conditionally on the presence of a key or\n//! not. The primary motivating use case for this is to provide efficient\n//! accumulator maps. For instance, if one wishes to maintain a count of the\n//! number of times each key has been seen, they will have to perform some\n//! conditional logic on whether this is the first time the key has been seen or\n//! not. Normally, this would require a `find` followed by an `insert`,\n//! effectively duplicating the search effort on each insertion.\n//!\n//! When a user calls `map.entry(&key)`, the map will search for the key and\n//! then yield a variant of the `Entry` enum.\n//!\n//! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case\n//! the only valid operation is to `insert` a value into the entry. When this is\n//! done, the vacant entry is consumed and converted into a mutable reference to\n//! the value that was inserted. This allows for further manipulation of the\n//! value beyond the lifetime of the search itself. This is useful if complex\n//! logic needs to be performed on the value regardless of whether the value was\n//! just inserted.\n//!\n//! If an `Occupied(entry)` is yielded, then the key *was* found. In this case,\n//! the user has several options: they can `get`, `insert` or `remove` the\n//! value of the occupied entry. Additionally, they can convert the occupied\n//! entry into a mutable reference to its value, providing symmetry to the\n//! vacant `insert` case.\n//!\n//! ### Examples\n//!\n//! Here are the two primary ways in which `entry` is used. First, a simple\n//! example where the logic performed on the values is trivial.\n//!\n//! #### Counting the number of times each character in a string occurs\n//!\n//! ```\n//! use std::collections::btree_map::BTreeMap;\n//!\n//! let mut count = BTreeMap::new();\n//! let message = \"she sells sea shells by the sea shore\";\n//!\n//! for c in message.chars() {\n//!     *count.entry(c).or_insert(0) += 1;\n//! }\n//!\n//! assert_eq!(count.get(&'s'), Some(&8));\n//!\n//! println!(\"Number of occurrences of each character\");\n//! for (char, count) in &count {\n//!     println!(\"{}: {}\", char, count);\n//! }\n//! ```\n//!\n//! When the logic to be performed on the value is more complex, we may simply\n//! use the `entry` API to ensure that the value is initialized and perform the\n//! logic afterwards.\n//!\n//! #### Tracking the inebriation of customers at a bar\n//!\n//! ```\n//! use std::collections::btree_map::BTreeMap;\n//!\n//! // A client of the bar. They have a blood alcohol level.\n//! struct Person { blood_alcohol: f32 }\n//!\n//! // All the orders made to the bar, by client ID.\n//! let orders = vec![1, 2, 1, 2, 3, 4, 1, 2, 2, 3, 4, 1, 1, 1];\n//!\n//! // Our clients.\n//! let mut blood_alcohol = BTreeMap::new();\n//!\n//! for id in orders {\n//!     // If this is the first time we've seen this customer, initialize them\n//!     // with no blood alcohol. Otherwise, just retrieve them.\n//!     let person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: 0.0 });\n//!\n//!     // Reduce their blood alcohol level. It takes time to order and drink a beer!\n//!     person.blood_alcohol *= 0.9;\n//!\n//!     // Check if they're sober enough to have another beer.\n//!     if person.blood_alcohol > 0.3 {\n//!         // Too drunk... for now.\n//!         println!(\"Sorry {}, I have to cut you off\", id);\n//!     } else {\n//!         // Have another!\n//!         person.blood_alcohol += 0.1;\n//!     }\n//! }\n//! ```\n//!\n//! # Insert and complex keys\n//!\n//! If we have a more complex key, calls to `insert` will\n//! not update the value of the key. For example:\n//!\n//! ```\n//! use std::cmp::Ordering;\n//! use std::collections::BTreeMap;\n//! use std::hash::{Hash, Hasher};\n//!\n//! #[derive(Debug)]\n//! struct Foo {\n//!     a: u32,\n//!     b: &'static str,\n//! }\n//!\n//! // we will compare `Foo`s by their `a` value only.\n//! impl PartialEq for Foo {\n//!     fn eq(&self, other: &Self) -> bool { self.a == other.a }\n//! }\n//!\n//! impl Eq for Foo {}\n//!\n//! // we will hash `Foo`s by their `a` value only.\n//! impl Hash for Foo {\n//!     fn hash<H: Hasher>(&self, h: &mut H) { self.a.hash(h); }\n//! }\n//!\n//! impl PartialOrd for Foo {\n//!     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { self.a.partial_cmp(&other.a) }\n//! }\n//!\n//! impl Ord for Foo {\n//!     fn cmp(&self, other: &Self) -> Ordering { self.a.cmp(&other.a) }\n//! }\n//!\n//! let mut map = BTreeMap::new();\n//! map.insert(Foo { a: 1, b: \"baz\" }, 99);\n//!\n//! // We already have a Foo with an a of 1, so this will be updating the value.\n//! map.insert(Foo { a: 1, b: \"xyz\" }, 100);\n//!\n//! // The value has been updated...\n//! assert_eq!(map.values().next().unwrap(), &100);\n//!\n//! // ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\n//! assert_eq!(map.keys().next().unwrap().b, \"baz\");\n//! ```\n//!\n//! [`IntoIterator`]: crate::iter::IntoIterator\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME(#82080) The deprecation here is only theoretical, and does not actually produce a warning.\n#[rustc_deprecated(reason = \"moved to `std::ops::Bound`\", since = \"1.26.0\")]\n#[doc(hidden)]\npub use crate::ops::Bound;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{binary_heap, btree_map, btree_set};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{linked_list, vec_deque};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{BTreeMap, BTreeSet, BinaryHeap};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{LinkedList, VecDeque};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::hash_map::HashMap;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::hash_set::HashSet;\n\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\npub use alloc_crate::collections::TryReserveError;\n\nmod hash;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod hash_map {\n    //! A hash map implemented with quadratic probing and SIMD lookup.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::hash::map::*;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod hash_set {\n    //! A hash set implemented as a `HashMap` where the value is `()`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::hash::set::*;\n}\n"],["2560","//! Filesystem manipulation operations.\n//!\n//! This module contains basic methods to manipulate the contents of the local\n//! filesystem. All methods in this module represent cross-platform filesystem\n//! operations. Extra platform-specific functionality can be found in the\n//! extension traits of `std::os::$platform`.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![deny(unsafe_op_in_unsafe_fn)]\n\n#[cfg(all(test, not(any(target_os = \"emscripten\", target_env = \"sgx\"))))]\nmod tests;\n\nuse crate::ffi::OsString;\nuse crate::fmt;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\nuse crate::path::{Path, PathBuf};\nuse crate::sys::fs as fs_imp;\nuse crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\nuse crate::time::SystemTime;\n\n/// A reference to an open file on the filesystem.\n///\n/// An instance of a `File` can be read and/or written depending on what options\n/// it was opened with. Files also implement [`Seek`] to alter the logical cursor\n/// that the file contains internally.\n///\n/// Files are automatically closed when they go out of scope.  Errors detected\n/// on closing are ignored by the implementation of `Drop`.  Use the method\n/// [`sync_all`] if these errors must be manually handled.\n///\n/// # Examples\n///\n/// Creates a new file and write bytes to it (you can also use [`write()`]):\n///\n/// ```no_run\n/// use std::fs::File;\n/// use std::io::prelude::*;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut file = File::create(\"foo.txt\")?;\n///     file.write_all(b\"Hello, world!\")?;\n///     Ok(())\n/// }\n/// ```\n///\n/// Read the contents of a file into a [`String`] (you can also use [`read`]):\n///\n/// ```no_run\n/// use std::fs::File;\n/// use std::io::prelude::*;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut file = File::open(\"foo.txt\")?;\n///     let mut contents = String::new();\n///     file.read_to_string(&mut contents)?;\n///     assert_eq!(contents, \"Hello, world!\");\n///     Ok(())\n/// }\n/// ```\n///\n/// It can be more efficient to read the contents of a file with a buffered\n/// [`Read`]er. This can be accomplished with [`BufReader<R>`]:\n///\n/// ```no_run\n/// use std::fs::File;\n/// use std::io::BufReader;\n/// use std::io::prelude::*;\n///\n/// fn main() -> std::io::Result<()> {\n///     let file = File::open(\"foo.txt\")?;\n///     let mut buf_reader = BufReader::new(file);\n///     let mut contents = String::new();\n///     buf_reader.read_to_string(&mut contents)?;\n///     assert_eq!(contents, \"Hello, world!\");\n///     Ok(())\n/// }\n/// ```\n///\n/// Note that, although read and write methods require a `&mut File`, because\n/// of the interfaces for [`Read`] and [`Write`], the holder of a `&File` can\n/// still modify the file, either through methods that take `&File` or by\n/// retrieving the underlying OS object and modifying the file that way.\n/// Additionally, many operating systems allow concurrent modification of files\n/// by different processes. Avoid assuming that holding a `&File` means that the\n/// file will not change.\n///\n/// [`BufReader<R>`]: io::BufReader\n/// [`sync_all`]: File::sync_all\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct File {\n    inner: fs_imp::File,\n}\n\n/// Metadata information about a file.\n///\n/// This structure is returned from the [`metadata`] or\n/// [`symlink_metadata`] function or method and represents known\n/// metadata about a file such as its permissions, size, modification\n/// times, etc.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct Metadata(fs_imp::FileAttr);\n\n/// Iterator over the entries in a directory.\n///\n/// This iterator is returned from the [`read_dir`] function of this module and\n/// will yield instances of [`io::Result`]`<`[`DirEntry`]`>`. Through a [`DirEntry`]\n/// information like the entry's path and possibly other metadata can be\n/// learned.\n///\n/// The order in which this iterator returns entries is platform and filesystem\n/// dependent.\n///\n/// # Errors\n///\n/// This [`io::Result`] will be an [`Err`] if there's some sort of intermittent\n/// IO error during iteration.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct ReadDir(fs_imp::ReadDir);\n\n/// Entries returned by the [`ReadDir`] iterator.\n///\n/// An instance of `DirEntry` represents an entry inside of a directory on the\n/// filesystem. Each entry can be inspected via methods to learn about the full\n/// path or possibly other metadata through per-platform extension traits.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct DirEntry(fs_imp::DirEntry);\n\n/// Options and flags which can be used to configure how a file is opened.\n///\n/// This builder exposes the ability to configure how a [`File`] is opened and\n/// what operations are permitted on the open file. The [`File::open`] and\n/// [`File::create`] methods are aliases for commonly used options using this\n/// builder.\n///\n/// Generally speaking, when using `OpenOptions`, you'll first call\n/// [`OpenOptions::new`], then chain calls to methods to set each option, then\n/// call [`OpenOptions::open`], passing the path of the file you're trying to\n/// open. This will give you a [`io::Result`] with a [`File`] inside that you\n/// can further operate on.\n///\n/// # Examples\n///\n/// Opening a file to read:\n///\n/// ```no_run\n/// use std::fs::OpenOptions;\n///\n/// let file = OpenOptions::new().read(true).open(\"foo.txt\");\n/// ```\n///\n/// Opening a file for both reading and writing, as well as creating it if it\n/// doesn't exist:\n///\n/// ```no_run\n/// use std::fs::OpenOptions;\n///\n/// let file = OpenOptions::new()\n///             .read(true)\n///             .write(true)\n///             .create(true)\n///             .open(\"foo.txt\");\n/// ```\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OpenOptions(fs_imp::OpenOptions);\n\n/// Representation of the various permissions on a file.\n///\n/// This module only currently provides one bit of information,\n/// [`Permissions::readonly`], which is exposed on all currently supported\n/// platforms. Unix-specific functionality, such as mode bits, is available\n/// through the [`PermissionsExt`] trait.\n///\n/// [`PermissionsExt`]: crate::os::unix::fs::PermissionsExt\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Permissions(fs_imp::FilePermissions);\n\n/// A structure representing a type of file with accessors for each file type.\n/// It is returned by [`Metadata::file_type`] method.\n#[stable(feature = \"file_type\", since = \"1.1.0\")]\n#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\npub struct FileType(fs_imp::FileType);\n\n/// A builder used to create directories in various manners.\n///\n/// This builder also supports platform-specific options.\n#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n#[derive(Debug)]\npub struct DirBuilder {\n    inner: fs_imp::DirBuilder,\n    recursive: bool,\n}\n\n/// Indicates how large a buffer to pre-allocate before reading the entire file.\nfn initial_buffer_size(file: &File) -> usize {\n    // Allocate one extra byte so the buffer doesn't need to grow before the\n    // final `read` call at the end of the file.  Don't worry about `usize`\n    // overflow because reading will fail regardless in that case.\n    file.metadata().map(|m| m.len() as usize + 1).unwrap_or(0)\n}\n\n/// Read the entire contents of a file into a bytes vector.\n///\n/// This is a convenience function for using [`File::open`] and [`read_to_end`]\n/// with fewer imports and without an intermediate variable. It pre-allocates a\n/// buffer based on the file size when available, so it is generally faster than\n/// reading into a vector created with [`Vec::new()`].\n///\n/// [`read_to_end`]: Read::read_to_end\n///\n/// # Errors\n///\n/// This function will return an error if `path` does not already exist.\n/// Other errors may also be returned according to [`OpenOptions::open`].\n///\n/// It will also return an error if it encounters while reading an error\n/// of a kind other than [`io::ErrorKind::Interrupted`].\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n/// use std::net::SocketAddr;\n///\n/// fn main() -> Result<(), Box<dyn std::error::Error + 'static>> {\n///     let foo: SocketAddr = String::from_utf8_lossy(&fs::read(\"address.txt\")?).parse()?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"fs_read_write_bytes\", since = \"1.26.0\")]\npub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n    fn inner(path: &Path) -> io::Result<Vec<u8>> {\n        let mut file = File::open(path)?;\n        let mut bytes = Vec::with_capacity(initial_buffer_size(&file));\n        file.read_to_end(&mut bytes)?;\n        Ok(bytes)\n    }\n    inner(path.as_ref())\n}\n\n/// Read the entire contents of a file into a string.\n///\n/// This is a convenience function for using [`File::open`] and [`read_to_string`]\n/// with fewer imports and without an intermediate variable. It pre-allocates a\n/// buffer based on the file size when available, so it is generally faster than\n/// reading into a string created with [`String::new()`].\n///\n/// [`read_to_string`]: Read::read_to_string\n///\n/// # Errors\n///\n/// This function will return an error if `path` does not already exist.\n/// Other errors may also be returned according to [`OpenOptions::open`].\n///\n/// It will also return an error if it encounters while reading an error\n/// of a kind other than [`io::ErrorKind::Interrupted`],\n/// or if the contents of the file are not valid UTF-8.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n/// use std::net::SocketAddr;\n/// use std::error::Error;\n///\n/// fn main() -> Result<(), Box<dyn Error>> {\n///     let foo: SocketAddr = fs::read_to_string(\"address.txt\")?.parse()?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"fs_read_write\", since = \"1.26.0\")]\npub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String> {\n    fn inner(path: &Path) -> io::Result<String> {\n        let mut file = File::open(path)?;\n        let mut string = String::with_capacity(initial_buffer_size(&file));\n        file.read_to_string(&mut string)?;\n        Ok(string)\n    }\n    inner(path.as_ref())\n}\n\n/// Write a slice as the entire contents of a file.\n///\n/// This function will create a file if it does not exist,\n/// and will entirely replace its contents if it does.\n///\n/// This is a convenience function for using [`File::create`] and [`write_all`]\n/// with fewer imports.\n///\n/// [`write_all`]: Write::write_all\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::write(\"foo.txt\", b\"Lorem ipsum\")?;\n///     fs::write(\"bar.txt\", \"dolor sit\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"fs_read_write_bytes\", since = \"1.26.0\")]\npub fn write<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> io::Result<()> {\n    fn inner(path: &Path, contents: &[u8]) -> io::Result<()> {\n        File::create(path)?.write_all(contents)\n    }\n    inner(path.as_ref(), contents.as_ref())\n}\n\nimpl File {\n    /// Attempts to open a file in read-only mode.\n    ///\n    /// See the [`OpenOptions::open`] method for more details.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if `path` does not already exist.\n    /// Other errors may also be returned according to [`OpenOptions::open`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn open<P: AsRef<Path>>(path: P) -> io::Result<File> {\n        OpenOptions::new().read(true).open(path.as_ref())\n    }\n\n    /// Opens a file in write-only mode.\n    ///\n    /// This function will create a file if it does not exist,\n    /// and will truncate it if it does.\n    ///\n    /// See the [`OpenOptions::open`] function for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn create<P: AsRef<Path>>(path: P) -> io::Result<File> {\n        OpenOptions::new().write(true).create(true).truncate(true).open(path.as_ref())\n    }\n\n    /// Returns a new OpenOptions object.\n    ///\n    /// This function returns a new OpenOptions object that you can use to\n    /// open or create a file with specific options if `open()` or `create()`\n    /// are not appropriate.\n    ///\n    /// It is equivalent to `OpenOptions::new()` but allows you to write more\n    /// readable code. Instead of `OpenOptions::new().read(true).open(\"foo.txt\")`\n    /// you can write `File::with_options().read(true).open(\"foo.txt\")`. This\n    /// also avoids the need to import `OpenOptions`.\n    ///\n    /// See the [`OpenOptions::new`] function for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// #![feature(with_options)]\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::with_options().read(true).open(\"foo.txt\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[unstable(feature = \"with_options\", issue = \"65439\")]\n    pub fn with_options() -> OpenOptions {\n        OpenOptions::new()\n    }\n\n    /// Attempts to sync all OS-internal metadata to disk.\n    ///\n    /// This function will attempt to ensure that all in-memory data reaches the\n    /// filesystem before returning.\n    ///\n    /// This can be used to handle errors that would otherwise only be caught\n    /// when the `File` is closed.  Dropping a file will ignore errors in\n    /// synchronizing this in-memory data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::prelude::*;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     f.write_all(b\"Hello, world!\")?;\n    ///\n    ///     f.sync_all()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn sync_all(&self) -> io::Result<()> {\n        self.inner.fsync()\n    }\n\n    /// This function is similar to [`sync_all`], except that it may not\n    /// synchronize file metadata to the filesystem.\n    ///\n    /// This is intended for use cases that must synchronize content, but don't\n    /// need the metadata on disk. The goal of this method is to reduce disk\n    /// operations.\n    ///\n    /// Note that some platforms may simply implement this in terms of\n    /// [`sync_all`].\n    ///\n    /// [`sync_all`]: File::sync_all\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::prelude::*;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     f.write_all(b\"Hello, world!\")?;\n    ///\n    ///     f.sync_data()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn sync_data(&self) -> io::Result<()> {\n        self.inner.datasync()\n    }\n\n    /// Truncates or extends the underlying file, updating the size of\n    /// this file to become `size`.\n    ///\n    /// If the `size` is less than the current file's size, then the file will\n    /// be shrunk. If it is greater than the current file's size, then the file\n    /// will be extended to `size` and have all of the intermediate data filled\n    /// in with 0s.\n    ///\n    /// The file's cursor isn't changed. In particular, if the cursor was at the\n    /// end and the file is shrunk using this operation, the cursor will now be\n    /// past the end.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the file is not opened for writing.\n    /// Also, std::io::ErrorKind::InvalidInput will be returned if the desired\n    /// length would cause an overflow due to the implementation specifics.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     f.set_len(10)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Note that this method alters the content of the underlying file, even\n    /// though it takes `&self` rather than `&mut self`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_len(&self, size: u64) -> io::Result<()> {\n        self.inner.truncate(size)\n    }\n\n    /// Queries metadata about the underlying file.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let metadata = f.metadata()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn metadata(&self) -> io::Result<Metadata> {\n        self.inner.file_attr().map(Metadata)\n    }\n\n    /// Creates a new `File` instance that shares the same underlying file handle\n    /// as the existing `File` instance. Reads, writes, and seeks will affect\n    /// both `File` instances simultaneously.\n    ///\n    /// # Examples\n    ///\n    /// Creates two handles for a file named `foo.txt`:\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///     let file_copy = file.try_clone()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Assuming theres a file named `foo.txt` with contents `abcdef\\n`, create\n    /// two handles, seek one of them, and read the remaining bytes from the\n    /// other handle:\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::SeekFrom;\n    /// use std::io::prelude::*;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///     let mut file_copy = file.try_clone()?;\n    ///\n    ///     file.seek(SeekFrom::Start(3))?;\n    ///\n    ///     let mut contents = vec![];\n    ///     file_copy.read_to_end(&mut contents)?;\n    ///     assert_eq!(contents, b\"def\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_try_clone\", since = \"1.9.0\")]\n    pub fn try_clone(&self) -> io::Result<File> {\n        Ok(File { inner: self.inner.duplicate()? })\n    }\n\n    /// Changes the permissions on the underlying file.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// This function currently corresponds to the `fchmod` function on Unix and\n    /// the `SetFileInformationByHandle` function on Windows. Note that, this\n    /// [may change in the future][changes].\n    ///\n    /// [changes]: io#platform-specific-behavior\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the user lacks permission change\n    /// attributes on the underlying file. It may also return an error in other\n    /// os-specific unspecified cases.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs::File;\n    ///\n    ///     let file = File::open(\"foo.txt\")?;\n    ///     let mut perms = file.metadata()?.permissions();\n    ///     perms.set_readonly(true);\n    ///     file.set_permissions(perms)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Note that this method alters the permissions of the underlying file,\n    /// even though it takes `&self` rather than `&mut self`.\n    #[stable(feature = \"set_permissions_atomic\", since = \"1.16.0\")]\n    pub fn set_permissions(&self, perm: Permissions) -> io::Result<()> {\n        self.inner.set_permissions(perm.0)\n    }\n}\n\nimpl AsInner<fs_imp::File> for File {\n    fn as_inner(&self) -> &fs_imp::File {\n        &self.inner\n    }\n}\nimpl FromInner<fs_imp::File> for File {\n    fn from_inner(f: fs_imp::File) -> File {\n        File { inner: f }\n    }\n}\nimpl IntoInner<fs_imp::File> for File {\n    fn into_inner(self) -> fs_imp::File {\n        self.inner\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for File {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.inner.fmt(f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for File {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        // SAFETY: Read is guaranteed to work on uninitialized memory\n        unsafe { Initializer::nop() }\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for File {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.inner.is_write_vectored()\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Seek for File {\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        self.inner.seek(pos)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for &File {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        // SAFETY: Read is guaranteed to work on uninitialized memory\n        unsafe { Initializer::nop() }\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for &File {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.inner.is_write_vectored()\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Seek for &File {\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        self.inner.seek(pos)\n    }\n}\n\nimpl OpenOptions {\n    /// Creates a blank new set of options ready for configuration.\n    ///\n    /// All options are initially set to `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let mut options = OpenOptions::new();\n    /// let file = options.read(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> Self {\n        OpenOptions(fs_imp::OpenOptions::new())\n    }\n\n    /// Sets the option for read access.\n    ///\n    /// This option, when true, will indicate that the file should be\n    /// `read`-able if opened.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().read(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn read(&mut self, read: bool) -> &mut Self {\n        self.0.read(read);\n        self\n    }\n\n    /// Sets the option for write access.\n    ///\n    /// This option, when true, will indicate that the file should be\n    /// `write`-able if opened.\n    ///\n    /// If the file already exists, any write calls on it will overwrite its\n    /// contents, without truncating it.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().write(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write(&mut self, write: bool) -> &mut Self {\n        self.0.write(write);\n        self\n    }\n\n    /// Sets the option for the append mode.\n    ///\n    /// This option, when true, means that writes will append to a file instead\n    /// of overwriting previous contents.\n    /// Note that setting `.write(true).append(true)` has the same effect as\n    /// setting only `.append(true)`.\n    ///\n    /// For most filesystems, the operating system guarantees that all writes are\n    /// atomic: no writes get mangled because another process writes at the same\n    /// time.\n    ///\n    /// One maybe obvious note when using append-mode: make sure that all data\n    /// that belongs together is written to the file in one operation. This\n    /// can be done by concatenating strings before passing them to [`write()`],\n    /// or using a buffered writer (with a buffer of adequate size),\n    /// and calling [`flush()`] when the message is complete.\n    ///\n    /// If a file is opened with both read and append access, beware that after\n    /// opening, and after every write, the position for reading may be set at the\n    /// end of the file. So, before writing, save the current position (using\n    /// [`seek`]`(`[`SeekFrom`]`::`[`Current`]`(0))`), and restore it before the next read.\n    ///\n    /// ## Note\n    ///\n    /// This function doesn't create the file if it doesn't exist. Use the\n    /// [`OpenOptions::create`] method to do so.\n    ///\n    /// [`write()`]: Write::write\n    /// [`flush()`]: Write::flush\n    /// [`seek`]: Seek::seek\n    /// [`Current`]: SeekFrom::Current\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().append(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn append(&mut self, append: bool) -> &mut Self {\n        self.0.append(append);\n        self\n    }\n\n    /// Sets the option for truncating a previous file.\n    ///\n    /// If a file is successfully opened with this option set it will truncate\n    /// the file to 0 length if it already exists.\n    ///\n    /// The file must be opened with write access for truncate to work.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().write(true).truncate(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn truncate(&mut self, truncate: bool) -> &mut Self {\n        self.0.truncate(truncate);\n        self\n    }\n\n    /// Sets the option to create a new file, or open it if it already exists.\n    ///\n    /// In order for the file to be created, [`OpenOptions::write`] or\n    /// [`OpenOptions::append`] access must be used.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().write(true).create(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn create(&mut self, create: bool) -> &mut Self {\n        self.0.create(create);\n        self\n    }\n\n    /// Sets the option to create a new file, failing if it already exists.\n    ///\n    /// No file is allowed to exist at the target location, also no (dangling) symlink. In this\n    /// way, if the call succeeds, the file returned is guaranteed to be new.\n    ///\n    /// This option is useful because it is atomic. Otherwise between checking\n    /// whether a file exists and creating a new one, the file may have been\n    /// created by another process (a TOCTOU race condition / attack).\n    ///\n    /// If `.create_new(true)` is set, [`.create()`] and [`.truncate()`] are\n    /// ignored.\n    ///\n    /// The file must be opened with write or append access in order to create\n    /// a new file.\n    ///\n    /// [`.create()`]: OpenOptions::create\n    /// [`.truncate()`]: OpenOptions::truncate\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().write(true)\n    ///                              .create_new(true)\n    ///                              .open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"expand_open_options2\", since = \"1.9.0\")]\n    pub fn create_new(&mut self, create_new: bool) -> &mut Self {\n        self.0.create_new(create_new);\n        self\n    }\n\n    /// Opens a file at `path` with the options specified by `self`.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error under a number of different\n    /// circumstances. Some of these error conditions are listed here, together\n    /// with their [`io::ErrorKind`]. The mapping to [`io::ErrorKind`]s is not\n    /// part of the compatibility contract of the function, especially the\n    /// [`Other`] kind might change to more specific kinds in the future.\n    ///\n    /// * [`NotFound`]: The specified file does not exist and neither `create`\n    ///   or `create_new` is set.\n    /// * [`NotFound`]: One of the directory components of the file path does\n    ///   not exist.\n    /// * [`PermissionDenied`]: The user lacks permission to get the specified\n    ///   access rights for the file.\n    /// * [`PermissionDenied`]: The user lacks permission to open one of the\n    ///   directory components of the specified path.\n    /// * [`AlreadyExists`]: `create_new` was specified and the file already\n    ///   exists.\n    /// * [`InvalidInput`]: Invalid combinations of open options (truncate\n    ///   without write access, no access mode set, etc.).\n    /// * [`Other`]: One of the directory components of the specified file path\n    ///   was not, in fact, a directory.\n    /// * [`Other`]: Filesystem-level errors: full disk, write permission\n    ///   requested on a read-only file system, exceeded disk quota, too many\n    ///   open files, too long filename, too many symbolic links in the\n    ///   specified path (Unix-like systems only), etc.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().read(true).open(\"foo.txt\");\n    /// ```\n    ///\n    /// [`AlreadyExists`]: io::ErrorKind::AlreadyExists\n    /// [`InvalidInput`]: io::ErrorKind::InvalidInput\n    /// [`NotFound`]: io::ErrorKind::NotFound\n    /// [`Other`]: io::ErrorKind::Other\n    /// [`PermissionDenied`]: io::ErrorKind::PermissionDenied\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> {\n        self._open(path.as_ref())\n    }\n\n    fn _open(&self, path: &Path) -> io::Result<File> {\n        fs_imp::File::open(path, &self.0).map(|inner| File { inner })\n    }\n}\n\nimpl AsInner<fs_imp::OpenOptions> for OpenOptions {\n    fn as_inner(&self) -> &fs_imp::OpenOptions {\n        &self.0\n    }\n}\n\nimpl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions {\n        &mut self.0\n    }\n}\n\nimpl Metadata {\n    /// Returns the file type for this metadata.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs;\n    ///\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     println!(\"{:?}\", metadata.file_type());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_type\", since = \"1.1.0\")]\n    pub fn file_type(&self) -> FileType {\n        FileType(self.0.file_type())\n    }\n\n    /// Returns `true` if this metadata is for a directory. The\n    /// result is mutually exclusive to the result of\n    /// [`Metadata::is_file`], and will be false for symlink metadata\n    /// obtained from [`symlink_metadata`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs;\n    ///\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     assert!(!metadata.is_dir());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_dir(&self) -> bool {\n        self.file_type().is_dir()\n    }\n\n    /// Returns `true` if this metadata is for a regular file. The\n    /// result is mutually exclusive to the result of\n    /// [`Metadata::is_dir`], and will be false for symlink metadata\n    /// obtained from [`symlink_metadata`].\n    ///\n    /// When the goal is simply to read from (or write to) the source, the most\n    /// reliable way to test the source can be read (or written to) is to open\n    /// it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n    /// a Unix-like system for example. See [`File::open`] or\n    /// [`OpenOptions::open`] for more information.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     assert!(metadata.is_file());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_file(&self) -> bool {\n        self.file_type().is_file()\n    }\n\n    /// Returns the size of the file, in bytes, this metadata is for.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     assert_eq!(0, metadata.len());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> u64 {\n        self.0.size()\n    }\n\n    /// Returns the permissions of the file this metadata is for.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     assert!(!metadata.permissions().readonly());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn permissions(&self) -> Permissions {\n        Permissions(self.0.perm())\n    }\n\n    /// Returns the last modification time listed in this metadata.\n    ///\n    /// The returned value corresponds to the `mtime` field of `stat` on Unix\n    /// platforms and the `ftLastWriteTime` field on Windows platforms.\n    ///\n    /// # Errors\n    ///\n    /// This field may not be available on all platforms, and will return an\n    /// `Err` on platforms where it is not available.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     if let Ok(time) = metadata.modified() {\n    ///         println!(\"{:?}\", time);\n    ///     } else {\n    ///         println!(\"Not supported on this platform\");\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n    pub fn modified(&self) -> io::Result<SystemTime> {\n        self.0.modified().map(FromInner::from_inner)\n    }\n\n    /// Returns the last access time of this metadata.\n    ///\n    /// The returned value corresponds to the `atime` field of `stat` on Unix\n    /// platforms and the `ftLastAccessTime` field on Windows platforms.\n    ///\n    /// Note that not all platforms will keep this field update in a file's\n    /// metadata, for example Windows has an option to disable updating this\n    /// time when files are accessed and Linux similarly has `noatime`.\n    ///\n    /// # Errors\n    ///\n    /// This field may not be available on all platforms, and will return an\n    /// `Err` on platforms where it is not available.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     if let Ok(time) = metadata.accessed() {\n    ///         println!(\"{:?}\", time);\n    ///     } else {\n    ///         println!(\"Not supported on this platform\");\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n        self.0.accessed().map(FromInner::from_inner)\n    }\n\n    /// Returns the creation time listed in this metadata.\n    ///\n    /// The returned value corresponds to the `btime` field of `statx` on\n    /// Linux kernel starting from to 4.11, the `birthtime` field of `stat` on other\n    /// Unix platforms, and the `ftCreationTime` field on Windows platforms.\n    ///\n    /// # Errors\n    ///\n    /// This field may not be available on all platforms, and will return an\n    /// `Err` on platforms or filesystems where it is not available.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     if let Ok(time) = metadata.created() {\n    ///         println!(\"{:?}\", time);\n    ///     } else {\n    ///         println!(\"Not supported on this platform or filesystem\");\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n    pub fn created(&self) -> io::Result<SystemTime> {\n        self.0.created().map(FromInner::from_inner)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Metadata {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Metadata\")\n            .field(\"file_type\", &self.file_type())\n            .field(\"is_dir\", &self.is_dir())\n            .field(\"is_file\", &self.is_file())\n            .field(\"permissions\", &self.permissions())\n            .field(\"modified\", &self.modified())\n            .field(\"accessed\", &self.accessed())\n            .field(\"created\", &self.created())\n            .finish_non_exhaustive()\n    }\n}\n\nimpl AsInner<fs_imp::FileAttr> for Metadata {\n    fn as_inner(&self) -> &fs_imp::FileAttr {\n        &self.0\n    }\n}\n\nimpl FromInner<fs_imp::FileAttr> for Metadata {\n    fn from_inner(attr: fs_imp::FileAttr) -> Metadata {\n        Metadata(attr)\n    }\n}\n\nimpl Permissions {\n    /// Returns `true` if these permissions describe a readonly (unwritable) file.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     let metadata = f.metadata()?;\n    ///\n    ///     assert_eq!(false, metadata.permissions().readonly());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn readonly(&self) -> bool {\n        self.0.readonly()\n    }\n\n    /// Modifies the readonly flag for this set of permissions. If the\n    /// `readonly` argument is `true`, using the resulting `Permission` will\n    /// update file permissions to forbid writing. Conversely, if it's `false`,\n    /// using the resulting `Permission` will update file permissions to allow\n    /// writing.\n    ///\n    /// This operation does **not** modify the filesystem. To modify the\n    /// filesystem use the [`set_permissions`] function.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::create(\"foo.txt\")?;\n    ///     let metadata = f.metadata()?;\n    ///     let mut permissions = metadata.permissions();\n    ///\n    ///     permissions.set_readonly(true);\n    ///\n    ///     // filesystem doesn't change\n    ///     assert_eq!(false, metadata.permissions().readonly());\n    ///\n    ///     // just this particular `permissions`.\n    ///     assert_eq!(true, permissions.readonly());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_readonly(&mut self, readonly: bool) {\n        self.0.set_readonly(readonly)\n    }\n}\n\nimpl FileType {\n    /// Tests whether this file type represents a directory. The\n    /// result is mutually exclusive to the results of\n    /// [`is_file`] and [`is_symlink`]; only zero or one of these\n    /// tests may pass.\n    ///\n    /// [`is_file`]: FileType::is_file\n    /// [`is_symlink`]: FileType::is_symlink\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs;\n    ///\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///     let file_type = metadata.file_type();\n    ///\n    ///     assert_eq!(file_type.is_dir(), false);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_type\", since = \"1.1.0\")]\n    pub fn is_dir(&self) -> bool {\n        self.0.is_dir()\n    }\n\n    /// Tests whether this file type represents a regular file.\n    /// The result is  mutually exclusive to the results of\n    /// [`is_dir`] and [`is_symlink`]; only zero or one of these\n    /// tests may pass.\n    ///\n    /// When the goal is simply to read from (or write to) the source, the most\n    /// reliable way to test the source can be read (or written to) is to open\n    /// it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n    /// a Unix-like system for example. See [`File::open`] or\n    /// [`OpenOptions::open`] for more information.\n    ///\n    /// [`is_dir`]: FileType::is_dir\n    /// [`is_symlink`]: FileType::is_symlink\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs;\n    ///\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///     let file_type = metadata.file_type();\n    ///\n    ///     assert_eq!(file_type.is_file(), true);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_type\", since = \"1.1.0\")]\n    pub fn is_file(&self) -> bool {\n        self.0.is_file()\n    }\n\n    /// Tests whether this file type represents a symbolic link.\n    /// The result is mutually exclusive to the results of\n    /// [`is_dir`] and [`is_file`]; only zero or one of these\n    /// tests may pass.\n    ///\n    /// The underlying [`Metadata`] struct needs to be retrieved\n    /// with the [`fs::symlink_metadata`] function and not the\n    /// [`fs::metadata`] function. The [`fs::metadata`] function\n    /// follows symbolic links, so [`is_symlink`] would always\n    /// return `false` for the target file.\n    ///\n    /// [`fs::metadata`]: metadata\n    /// [`fs::symlink_metadata`]: symlink_metadata\n    /// [`is_dir`]: FileType::is_dir\n    /// [`is_file`]: FileType::is_file\n    /// [`is_symlink`]: FileType::is_symlink\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::symlink_metadata(\"foo.txt\")?;\n    ///     let file_type = metadata.file_type();\n    ///\n    ///     assert_eq!(file_type.is_symlink(), false);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_type\", since = \"1.1.0\")]\n    pub fn is_symlink(&self) -> bool {\n        self.0.is_symlink()\n    }\n}\n\nimpl AsInner<fs_imp::FileType> for FileType {\n    fn as_inner(&self) -> &fs_imp::FileType {\n        &self.0\n    }\n}\n\nimpl FromInner<fs_imp::FilePermissions> for Permissions {\n    fn from_inner(f: fs_imp::FilePermissions) -> Permissions {\n        Permissions(f)\n    }\n}\n\nimpl AsInner<fs_imp::FilePermissions> for Permissions {\n    fn as_inner(&self) -> &fs_imp::FilePermissions {\n        &self.0\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for ReadDir {\n    type Item = io::Result<DirEntry>;\n\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        self.0.next().map(|entry| entry.map(DirEntry))\n    }\n}\n\nimpl DirEntry {\n    /// Returns the full path to the file that this entry represents.\n    ///\n    /// The full path is created by joining the original path to `read_dir`\n    /// with the filename of this entry.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     for entry in fs::read_dir(\".\")? {\n    ///         let dir = entry?;\n    ///         println!(\"{:?}\", dir.path());\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// This prints output like:\n    ///\n    /// ```text\n    /// \"./whatever.txt\"\n    /// \"./foo.html\"\n    /// \"./hello_world.rs\"\n    /// ```\n    ///\n    /// The exact text, of course, depends on what files you have in `.`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn path(&self) -> PathBuf {\n        self.0.path()\n    }\n\n    /// Returns the metadata for the file that this entry points at.\n    ///\n    /// This function will not traverse symlinks if this entry points at a\n    /// symlink. To traverse symlinks use [`fs::metadata`] or [`fs::File::metadata`].\n    ///\n    /// [`fs::metadata`]: metadata\n    /// [`fs::File::metadata`]: File::metadata\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// On Windows this function is cheap to call (no extra system calls\n    /// needed), but on Unix platforms this function is the equivalent of\n    /// calling `symlink_metadata` on the path.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs;\n    ///\n    /// if let Ok(entries) = fs::read_dir(\".\") {\n    ///     for entry in entries {\n    ///         if let Ok(entry) = entry {\n    ///             // Here, `entry` is a `DirEntry`.\n    ///             if let Ok(metadata) = entry.metadata() {\n    ///                 // Now let's show our entry's permissions!\n    ///                 println!(\"{:?}: {:?}\", entry.path(), metadata.permissions());\n    ///             } else {\n    ///                 println!(\"Couldn't get metadata for {:?}\", entry.path());\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n    pub fn metadata(&self) -> io::Result<Metadata> {\n        self.0.metadata().map(Metadata)\n    }\n\n    /// Returns the file type for the file that this entry points at.\n    ///\n    /// This function will not traverse symlinks if this entry points at a\n    /// symlink.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// On Windows and most Unix platforms this function is free (no extra\n    /// system calls needed), but some Unix platforms may require the equivalent\n    /// call to `symlink_metadata` to learn about the target file type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs;\n    ///\n    /// if let Ok(entries) = fs::read_dir(\".\") {\n    ///     for entry in entries {\n    ///         if let Ok(entry) = entry {\n    ///             // Here, `entry` is a `DirEntry`.\n    ///             if let Ok(file_type) = entry.file_type() {\n    ///                 // Now let's show our entry's file type!\n    ///                 println!(\"{:?}: {:?}\", entry.path(), file_type);\n    ///             } else {\n    ///                 println!(\"Couldn't get file type for {:?}\", entry.path());\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n    pub fn file_type(&self) -> io::Result<FileType> {\n        self.0.file_type().map(FileType)\n    }\n\n    /// Returns the bare file name of this directory entry without any other\n    /// leading path component.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs;\n    ///\n    /// if let Ok(entries) = fs::read_dir(\".\") {\n    ///     for entry in entries {\n    ///         if let Ok(entry) = entry {\n    ///             // Here, `entry` is a `DirEntry`.\n    ///             println!(\"{:?}\", entry.file_name());\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n    pub fn file_name(&self) -> OsString {\n        self.0.file_name()\n    }\n}\n\n#[stable(feature = \"dir_entry_debug\", since = \"1.13.0\")]\nimpl fmt::Debug for DirEntry {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"DirEntry\").field(&self.path()).finish()\n    }\n}\n\nimpl AsInner<fs_imp::DirEntry> for DirEntry {\n    fn as_inner(&self) -> &fs_imp::DirEntry {\n        &self.0\n    }\n}\n\n/// Removes a file from the filesystem.\n///\n/// Note that there is no\n/// guarantee that the file is immediately deleted (e.g., depending on\n/// platform, other open file descriptors may prevent immediate removal).\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `unlink` function on Unix\n/// and the `DeleteFile` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `path` points to a directory.\n/// * The file doesn't exist.\n/// * The user lacks permissions to remove the file.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::remove_file(\"a.txt\")?;\n///     Ok(())\n/// }\n/// ```\n#[doc(alias = \"delete\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n    fs_imp::unlink(path.as_ref())\n}\n\n/// Given a path, query the file system to get information about a file,\n/// directory, etc.\n///\n/// This function will traverse symbolic links to query information about the\n/// destination file.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `stat` function on Unix\n/// and the `GetFileAttributesEx` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The user lacks permissions to perform `metadata` call on `path`.\n/// * `path` does not exist.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let attr = fs::metadata(\"/some/file/path.txt\")?;\n///     // inspect attr ...\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n    fs_imp::stat(path.as_ref()).map(Metadata)\n}\n\n/// Query the metadata about a file without following symlinks.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `lstat` function on Unix\n/// and the `GetFileAttributesEx` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The user lacks permissions to perform `metadata` call on `path`.\n/// * `path` does not exist.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let attr = fs::symlink_metadata(\"/some/file/path.txt\")?;\n///     // inspect attr ...\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"symlink_metadata\", since = \"1.1.0\")]\npub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n    fs_imp::lstat(path.as_ref()).map(Metadata)\n}\n\n/// Rename a file or directory to a new name, replacing the original file if\n/// `to` already exists.\n///\n/// This will not work if the new name is on a different mount point.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `rename` function on Unix\n/// and the `MoveFileEx` function with the `MOVEFILE_REPLACE_EXISTING` flag on Windows.\n///\n/// Because of this, the behavior when both `from` and `to` exist differs. On\n/// Unix, if `from` is a directory, `to` must also be an (empty) directory. If\n/// `from` is not a directory, `to` must also be not a directory. In contrast,\n/// on Windows, `from` can be anything, but `to` must *not* be a directory.\n///\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `from` does not exist.\n/// * The user lacks permissions to view contents.\n/// * `from` and `to` are on separate filesystems.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::rename(\"a.txt\", \"b.txt\")?; // Rename a.txt to b.txt\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()> {\n    fs_imp::rename(from.as_ref(), to.as_ref())\n}\n\n/// Copies the contents of one file to another. This function will also\n/// copy the permission bits of the original file to the destination file.\n///\n/// This function will **overwrite** the contents of `to`.\n///\n/// Note that if `from` and `to` both point to the same file, then the file\n/// will likely get truncated by this operation.\n///\n/// On success, the total number of bytes copied is returned and it is equal to\n/// the length of the `to` file as reported by `metadata`.\n///\n/// If youre wanting to copy the contents of one file to another and youre\n/// working with [`File`]s, see the [`io::copy()`] function.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `open` function in Unix\n/// with `O_RDONLY` for `from` and `O_WRONLY`, `O_CREAT`, and `O_TRUNC` for `to`.\n/// `O_CLOEXEC` is set for returned file descriptors.\n/// On Windows, this function currently corresponds to `CopyFileEx`. Alternate\n/// NTFS streams are copied but only the size of the main stream is returned by\n/// this function. On MacOS, this function corresponds to `fclonefileat` and\n/// `fcopyfile`.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `from` is neither a regular file nor a symlink to a regular file.\n/// * `from` does not exist.\n/// * The current process does not have the permission rights to read\n///   `from` or write `to`.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::copy(\"foo.txt\", \"bar.txt\")?;  // Copy foo.txt to bar.txt\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n    fs_imp::copy(from.as_ref(), to.as_ref())\n}\n\n/// Creates a new hard link on the filesystem.\n///\n/// The `link` path will be a link pointing to the `original` path. Note that\n/// systems often require these two paths to both be located on the same\n/// filesystem.\n///\n/// If `original` names a symbolic link, it is platform-specific whether the\n/// symbolic link is followed. On platforms where it's possible to not follow\n/// it, it is not followed, and the created hard link points to the symbolic\n/// link itself.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `linkat` function with no flags\n/// on Unix and the `CreateHardLink` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The `original` path is not a file or doesn't exist.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::hard_link(\"a.txt\", \"b.txt\")?; // Hard link a.txt to b.txt\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {\n    fs_imp::link(original.as_ref(), link.as_ref())\n}\n\n/// Creates a new symbolic link on the filesystem.\n///\n/// The `link` path will be a symbolic link pointing to the `original` path.\n/// On Windows, this will be a file symlink, not a directory symlink;\n/// for this reason, the platform-specific [`std::os::unix::fs::symlink`]\n/// and [`std::os::windows::fs::symlink_file`] or [`symlink_dir`] should be\n/// used instead to make the intent explicit.\n///\n/// [`std::os::unix::fs::symlink`]: crate::os::unix::fs::symlink\n/// [`std::os::windows::fs::symlink_file`]: crate::os::windows::fs::symlink_file\n/// [`symlink_dir`]: crate::os::windows::fs::symlink_dir\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::soft_link(\"a.txt\", \"b.txt\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"1.1.0\",\n    reason = \"replaced with std::os::unix::fs::symlink and \\\n              std::os::windows::fs::{symlink_file, symlink_dir}\"\n)]\npub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {\n    fs_imp::symlink(original.as_ref(), link.as_ref())\n}\n\n/// Reads a symbolic link, returning the file that the link points to.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `readlink` function on Unix\n/// and the `CreateFile` function with `FILE_FLAG_OPEN_REPARSE_POINT` and\n/// `FILE_FLAG_BACKUP_SEMANTICS` flags on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `path` is not a symbolic link.\n/// * `path` does not exist.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let path = fs::read_link(\"a.txt\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n    fs_imp::readlink(path.as_ref())\n}\n\n/// Returns the canonical, absolute form of a path with all intermediate\n/// components normalized and symbolic links resolved.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `realpath` function on Unix\n/// and the `CreateFile` and `GetFinalPathNameByHandle` functions on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// On Windows, this converts the path to use [extended length path][path]\n/// syntax, which allows your program to use longer path names, but means you\n/// can only join backslash-delimited paths to it, and it may be incompatible\n/// with other applications (if passed to the application on the command-line,\n/// or written to a file another application may read).\n///\n/// [changes]: io#platform-specific-behavior\n/// [path]: https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `path` does not exist.\n/// * A non-final component in path is not a directory.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let path = fs::canonicalize(\"../a/../foo.txt\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"fs_canonicalize\", since = \"1.5.0\")]\npub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n    fs_imp::canonicalize(path.as_ref())\n}\n\n/// Creates a new, empty directory at the provided path\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `mkdir` function on Unix\n/// and the `CreateDirectory` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// **NOTE**: If a parent of the given path doesn't exist, this function will\n/// return an error. To create a directory and all its missing parents at the\n/// same time, use the [`create_dir_all`] function.\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * User lacks permissions to create directory at `path`.\n/// * A parent of the given path doesn't exist. (To create a directory and all\n///   its missing parents at the same time, use the [`create_dir_all`]\n///   function.)\n/// * `path` already exists.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::create_dir(\"/some/dir\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n    DirBuilder::new().create(path.as_ref())\n}\n\n/// Recursively create a directory and all of its parent components if they\n/// are missing.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `mkdir` function on Unix\n/// and the `CreateDirectory` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * If any directory in the path specified by `path`\n/// does not already exist and it could not be created otherwise. The specific\n/// error conditions for when a directory is being created (after it is\n/// determined to not exist) are outlined by [`fs::create_dir`].\n///\n/// Notable exception is made for situations where any of the directories\n/// specified in the `path` could not be created as it was being created concurrently.\n/// Such cases are considered to be successful. That is, calling `create_dir_all`\n/// concurrently from multiple threads or processes is guaranteed not to fail\n/// due to a race condition with itself.\n///\n/// [`fs::create_dir`]: create_dir\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::create_dir_all(\"/some/dir\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n    DirBuilder::new().recursive(true).create(path.as_ref())\n}\n\n/// Removes an empty directory.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `rmdir` function on Unix\n/// and the `RemoveDirectory` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `path` doesn't exist.\n/// * `path` isn't a directory.\n/// * The user lacks permissions to remove the directory at the provided `path`.\n/// * The directory isn't empty.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::remove_dir(\"/some/dir\")?;\n///     Ok(())\n/// }\n/// ```\n#[doc(alias = \"delete\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n    fs_imp::rmdir(path.as_ref())\n}\n\n/// Removes a directory at this path, after removing all its contents. Use\n/// carefully!\n///\n/// This function does **not** follow symbolic links and it will simply remove the\n/// symbolic link itself.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to `opendir`, `lstat`, `rm` and `rmdir` functions on Unix\n/// and the `FindFirstFile`, `GetFileAttributesEx`, `DeleteFile`, and `RemoveDirectory` functions\n/// on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// See [`fs::remove_file`] and [`fs::remove_dir`].\n///\n/// [`fs::remove_file`]: remove_file\n/// [`fs::remove_dir`]: remove_dir\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::remove_dir_all(\"/some/dir\")?;\n///     Ok(())\n/// }\n/// ```\n#[doc(alias = \"delete\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n    fs_imp::remove_dir_all(path.as_ref())\n}\n\n/// Returns an iterator over the entries within a directory.\n///\n/// The iterator will yield instances of [`io::Result`]`<`[`DirEntry`]`>`.\n/// New errors may be encountered after an iterator is initially constructed.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `opendir` function on Unix\n/// and the `FindFirstFile` function on Windows. Advancing the iterator\n/// currently corresponds to `readdir` on Unix and `FindNextFile` on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// The order in which this iterator returns entries is platform and filesystem\n/// dependent.\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The provided `path` doesn't exist.\n/// * The process lacks permissions to view the contents.\n/// * The `path` points at a non-directory file.\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n/// use std::fs::{self, DirEntry};\n/// use std::path::Path;\n///\n/// // one possible implementation of walking a directory only visiting files\n/// fn visit_dirs(dir: &Path, cb: &dyn Fn(&DirEntry)) -> io::Result<()> {\n///     if dir.is_dir() {\n///         for entry in fs::read_dir(dir)? {\n///             let entry = entry?;\n///             let path = entry.path();\n///             if path.is_dir() {\n///                 visit_dirs(&path, cb)?;\n///             } else {\n///                 cb(&entry);\n///             }\n///         }\n///     }\n///     Ok(())\n/// }\n/// ```\n///\n/// ```rust,no_run\n/// use std::{fs, io};\n///\n/// fn main() -> io::Result<()> {\n///     let mut entries = fs::read_dir(\".\")?\n///         .map(|res| res.map(|e| e.path()))\n///         .collect::<Result<Vec<_>, io::Error>>()?;\n///\n///     // The order in which `read_dir` returns entries is not guaranteed. If reproducible\n///     // ordering is required the entries should be explicitly sorted.\n///\n///     entries.sort();\n///\n///     // The entries have now been sorted by their path.\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n    fs_imp::readdir(path.as_ref()).map(ReadDir)\n}\n\n/// Changes the permissions found on a file or a directory.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `chmod` function on Unix\n/// and the `SetFileAttributes` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: io#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `path` does not exist.\n/// * The user lacks the permission to change attributes of the file.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut perms = fs::metadata(\"foo.txt\")?.permissions();\n///     perms.set_readonly(true);\n///     fs::set_permissions(\"foo.txt\", perms)?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"set_permissions\", since = \"1.1.0\")]\npub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions) -> io::Result<()> {\n    fs_imp::set_perm(path.as_ref(), perm.0)\n}\n\nimpl DirBuilder {\n    /// Creates a new set of options with default mode/security settings for all\n    /// platforms and also non-recursive.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs::DirBuilder;\n    ///\n    /// let builder = DirBuilder::new();\n    /// ```\n    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n    pub fn new() -> DirBuilder {\n        DirBuilder { inner: fs_imp::DirBuilder::new(), recursive: false }\n    }\n\n    /// Indicates that directories should be created recursively, creating all\n    /// parent directories. Parents that do not exist are created with the same\n    /// security and permissions settings.\n    ///\n    /// This option defaults to `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs::DirBuilder;\n    ///\n    /// let mut builder = DirBuilder::new();\n    /// builder.recursive(true);\n    /// ```\n    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n    pub fn recursive(&mut self, recursive: bool) -> &mut Self {\n        self.recursive = recursive;\n        self\n    }\n\n    /// Creates the specified directory with the options configured in this\n    /// builder.\n    ///\n    /// It is considered an error if the directory already exists unless\n    /// recursive mode is enabled.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::{self, DirBuilder};\n    ///\n    /// let path = \"/tmp/foo/bar/baz\";\n    /// DirBuilder::new()\n    ///     .recursive(true)\n    ///     .create(path).unwrap();\n    ///\n    /// assert!(fs::metadata(path).unwrap().is_dir());\n    /// ```\n    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n    pub fn create<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n        self._create(path.as_ref())\n    }\n\n    fn _create(&self, path: &Path) -> io::Result<()> {\n        if self.recursive { self.create_dir_all(path) } else { self.inner.mkdir(path) }\n    }\n\n    fn create_dir_all(&self, path: &Path) -> io::Result<()> {\n        if path == Path::new(\"\") {\n            return Ok(());\n        }\n\n        match self.inner.mkdir(path) {\n            Ok(()) => return Ok(()),\n            Err(ref e) if e.kind() == io::ErrorKind::NotFound => {}\n            Err(_) if path.is_dir() => return Ok(()),\n            Err(e) => return Err(e),\n        }\n        match path.parent() {\n            Some(p) => self.create_dir_all(p)?,\n            None => {\n                return Err(io::Error::new_const(\n                    io::ErrorKind::Other,\n                    &\"failed to create whole tree\",\n                ));\n            }\n        }\n        match self.inner.mkdir(path) {\n            Ok(()) => Ok(()),\n            Err(_) if path.is_dir() => Ok(()),\n            Err(e) => Err(e),\n        }\n    }\n}\n\nimpl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n    fn as_inner_mut(&mut self) -> &mut fs_imp::DirBuilder {\n        &mut self.inner\n    }\n}\n\n/// Returns `Ok(true)` if the path points at an existing entity.\n///\n/// This function will traverse symbolic links to query information about the\n/// destination file. In case of broken symbolic links this will return `Ok(false)`.\n///\n/// As opposed to the `exists()` method, this one doesn't silently ignore errors\n/// unrelated to the path not existing. (E.g. it will return `Err(_)` in case of permission\n/// denied on some of the parent directories.)\n///\n/// # Examples\n///\n/// ```no_run\n/// #![feature(path_try_exists)]\n/// use std::fs;\n///\n/// assert!(!fs::try_exists(\"does_not_exist.txt\").expect(\"Can't check existence of file does_not_exist.txt\"));\n/// assert!(fs::try_exists(\"/root/secret_file.txt\").is_err());\n/// ```\n// FIXME: stabilization should modify documentation of `exists()` to recommend this method\n// instead.\n#[unstable(feature = \"path_try_exists\", issue = \"83186\")]\n#[inline]\npub fn try_exists<P: AsRef<Path>>(path: P) -> io::Result<bool> {\n    fs_imp::try_exists(path.as_ref())\n}\n"],["2561","use crate::cell::RefCell;\nuse crate::collections::HashMap;\nuse crate::thread_local;\n\n#[test]\nfn smoke() {\n    fn square(i: i32) -> i32 {\n        i * i\n    }\n    thread_local!(static FOO: i32 = square(3));\n\n    FOO.with(|f| {\n        assert_eq!(*f, 9);\n    });\n}\n\n#[test]\nfn hashmap() {\n    fn map() -> RefCell<HashMap<i32, i32>> {\n        let mut m = HashMap::new();\n        m.insert(1, 2);\n        RefCell::new(m)\n    }\n    thread_local!(static FOO: RefCell<HashMap<i32, i32>> = map());\n\n    FOO.with(|map| {\n        assert_eq!(map.borrow()[&1], 2);\n    });\n}\n\n#[test]\nfn refcell_vec() {\n    thread_local!(static FOO: RefCell<Vec<u32>> = RefCell::new(vec![1, 2, 3]));\n\n    FOO.with(|vec| {\n        assert_eq!(vec.borrow().len(), 3);\n        vec.borrow_mut().push(4);\n        assert_eq!(vec.borrow()[3], 4);\n    });\n}\n"],["2562","use crate::cell::{Cell, UnsafeCell};\nuse crate::sync::atomic::{AtomicU8, Ordering};\nuse crate::sync::mpsc::{channel, Sender};\nuse crate::thread::{self, LocalKey};\nuse crate::thread_local;\n\nstruct Foo(Sender<()>);\n\nimpl Drop for Foo {\n    fn drop(&mut self) {\n        let Foo(ref s) = *self;\n        s.send(()).unwrap();\n    }\n}\n\n#[test]\nfn smoke_no_dtor() {\n    thread_local!(static FOO: Cell<i32> = Cell::new(1));\n    run(&FOO);\n    thread_local!(static FOO2: Cell<i32> = const { Cell::new(1) });\n    run(&FOO2);\n\n    fn run(key: &'static LocalKey<Cell<i32>>) {\n        key.with(|f| {\n            assert_eq!(f.get(), 1);\n            f.set(2);\n        });\n        let t = thread::spawn(move || {\n            key.with(|f| {\n                assert_eq!(f.get(), 1);\n            });\n        });\n        t.join().unwrap();\n\n        key.with(|f| {\n            assert_eq!(f.get(), 2);\n        });\n    }\n}\n\n#[test]\nfn states() {\n    struct Foo(&'static LocalKey<Foo>);\n    impl Drop for Foo {\n        fn drop(&mut self) {\n            assert!(self.0.try_with(|_| ()).is_err());\n        }\n    }\n\n    thread_local!(static FOO: Foo = Foo(&FOO));\n    run(&FOO);\n    thread_local!(static FOO2: Foo = const { Foo(&FOO2) });\n    run(&FOO2);\n\n    fn run(foo: &'static LocalKey<Foo>) {\n        thread::spawn(move || {\n            assert!(foo.try_with(|_| ()).is_ok());\n        })\n        .join()\n        .unwrap();\n    }\n}\n\n#[test]\nfn smoke_dtor() {\n    thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n    run(&FOO);\n    thread_local!(static FOO2: UnsafeCell<Option<Foo>> = const { UnsafeCell::new(None) });\n    run(&FOO2);\n\n    fn run(key: &'static LocalKey<UnsafeCell<Option<Foo>>>) {\n        let (tx, rx) = channel();\n        let t = thread::spawn(move || unsafe {\n            let mut tx = Some(tx);\n            key.with(|f| {\n                *f.get() = Some(Foo(tx.take().unwrap()));\n            });\n        });\n        rx.recv().unwrap();\n        t.join().unwrap();\n    }\n}\n\n#[test]\nfn circular() {\n    struct S1(&'static LocalKey<UnsafeCell<Option<S1>>>, &'static LocalKey<UnsafeCell<Option<S2>>>);\n    struct S2(&'static LocalKey<UnsafeCell<Option<S1>>>, &'static LocalKey<UnsafeCell<Option<S2>>>);\n    thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n    thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell::new(None));\n    thread_local!(static K3: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n    thread_local!(static K4: UnsafeCell<Option<S2>> = const { UnsafeCell::new(None) });\n    static mut HITS: usize = 0;\n\n    impl Drop for S1 {\n        fn drop(&mut self) {\n            unsafe {\n                HITS += 1;\n                if self.1.try_with(|_| ()).is_err() {\n                    assert_eq!(HITS, 3);\n                } else {\n                    if HITS == 1 {\n                        self.1.with(|s| *s.get() = Some(S2(self.0, self.1)));\n                    } else {\n                        assert_eq!(HITS, 3);\n                    }\n                }\n            }\n        }\n    }\n    impl Drop for S2 {\n        fn drop(&mut self) {\n            unsafe {\n                HITS += 1;\n                assert!(self.0.try_with(|_| ()).is_ok());\n                assert_eq!(HITS, 2);\n                self.0.with(|s| *s.get() = Some(S1(self.0, self.1)));\n            }\n        }\n    }\n\n    thread::spawn(move || {\n        drop(S1(&K1, &K2));\n    })\n    .join()\n    .unwrap();\n\n    unsafe {\n        HITS = 0;\n    }\n\n    thread::spawn(move || {\n        drop(S1(&K3, &K4));\n    })\n    .join()\n    .unwrap();\n}\n\n#[test]\nfn self_referential() {\n    struct S1(&'static LocalKey<UnsafeCell<Option<S1>>>);\n\n    thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n    thread_local!(static K2: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n\n    impl Drop for S1 {\n        fn drop(&mut self) {\n            assert!(self.0.try_with(|_| ()).is_err());\n        }\n    }\n\n    thread::spawn(move || unsafe {\n        K1.with(|s| *s.get() = Some(S1(&K1)));\n    })\n    .join()\n    .unwrap();\n\n    thread::spawn(move || unsafe {\n        K2.with(|s| *s.get() = Some(S1(&K2)));\n    })\n    .join()\n    .unwrap();\n}\n\n// Note that this test will deadlock if TLS destructors aren't run (this\n// requires the destructor to be run to pass the test).\n#[test]\nfn dtors_in_dtors_in_dtors() {\n    struct S1(Sender<()>);\n    thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n    thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n\n    impl Drop for S1 {\n        fn drop(&mut self) {\n            let S1(ref tx) = *self;\n            unsafe {\n                let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n            }\n        }\n    }\n\n    let (tx, rx) = channel();\n    let _t = thread::spawn(move || unsafe {\n        let mut tx = Some(tx);\n        K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n    });\n    rx.recv().unwrap();\n}\n\n#[test]\nfn dtors_in_dtors_in_dtors_const_init() {\n    struct S1(Sender<()>);\n    thread_local!(static K1: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n    thread_local!(static K2: UnsafeCell<Option<Foo>> = const { UnsafeCell::new(None) });\n\n    impl Drop for S1 {\n        fn drop(&mut self) {\n            let S1(ref tx) = *self;\n            unsafe {\n                let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n            }\n        }\n    }\n\n    let (tx, rx) = channel();\n    let _t = thread::spawn(move || unsafe {\n        let mut tx = Some(tx);\n        K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n    });\n    rx.recv().unwrap();\n}\n\n// This test tests that TLS destructors have run before the thread joins. The\n// test has no false positives (meaning: if the test fails, there's actually\n// an ordering problem). It may have false negatives, where the test passes but\n// join is not guaranteed to be after the TLS destructors. However, false\n// negatives should be exceedingly rare due to judicious use of\n// thread::yield_now and running the test several times.\n#[test]\nfn join_orders_after_tls_destructors() {\n    // We emulate a synchronous MPSC rendezvous channel using only atomics and\n    // thread::yield_now. We can't use std::mpsc as the implementation itself\n    // may rely on thread locals.\n    //\n    // The basic state machine for an SPSC rendezvous channel is:\n    //           FRESH -> THREAD1_WAITING -> MAIN_THREAD_RENDEZVOUS\n    // where the first transition is done by the receiving thread and the 2nd\n    // transition is done by the sending thread.\n    //\n    // We add an additional state `THREAD2_LAUNCHED` between `FRESH` and\n    // `THREAD1_WAITING` to block until all threads are actually running.\n    //\n    // A thread that joins on the receiving thread completion should never\n    // observe the channel in the `THREAD1_WAITING` state. If this does occur,\n    // we switch to the poison state `THREAD2_JOINED` and panic all around.\n    // (This is equivalent to sending from an alternate producer thread.)\n    const FRESH: u8 = 0;\n    const THREAD2_LAUNCHED: u8 = 1;\n    const THREAD1_WAITING: u8 = 2;\n    const MAIN_THREAD_RENDEZVOUS: u8 = 3;\n    const THREAD2_JOINED: u8 = 4;\n    static SYNC_STATE: AtomicU8 = AtomicU8::new(FRESH);\n\n    for _ in 0..10 {\n        SYNC_STATE.store(FRESH, Ordering::SeqCst);\n\n        let jh = thread::Builder::new()\n            .name(\"thread1\".into())\n            .spawn(move || {\n                struct TlDrop;\n\n                impl Drop for TlDrop {\n                    fn drop(&mut self) {\n                        let mut sync_state = SYNC_STATE.swap(THREAD1_WAITING, Ordering::SeqCst);\n                        loop {\n                            match sync_state {\n                                THREAD2_LAUNCHED | THREAD1_WAITING => thread::yield_now(),\n                                MAIN_THREAD_RENDEZVOUS => break,\n                                THREAD2_JOINED => panic!(\n                                    \"Thread 1 still running after thread 2 joined on thread 1\"\n                                ),\n                                v => unreachable!(\"sync state: {}\", v),\n                            }\n                            sync_state = SYNC_STATE.load(Ordering::SeqCst);\n                        }\n                    }\n                }\n\n                thread_local! {\n                    static TL_DROP: TlDrop = TlDrop;\n                }\n\n                TL_DROP.with(|_| {});\n\n                loop {\n                    match SYNC_STATE.load(Ordering::SeqCst) {\n                        FRESH => thread::yield_now(),\n                        THREAD2_LAUNCHED => break,\n                        v => unreachable!(\"sync state: {}\", v),\n                    }\n                }\n            })\n            .unwrap();\n\n        let jh2 = thread::Builder::new()\n            .name(\"thread2\".into())\n            .spawn(move || {\n                assert_eq!(SYNC_STATE.swap(THREAD2_LAUNCHED, Ordering::SeqCst), FRESH);\n                jh.join().unwrap();\n                match SYNC_STATE.swap(THREAD2_JOINED, Ordering::SeqCst) {\n                    MAIN_THREAD_RENDEZVOUS => return,\n                    THREAD2_LAUNCHED | THREAD1_WAITING => {\n                        panic!(\"Thread 2 running after thread 1 join before main thread rendezvous\")\n                    }\n                    v => unreachable!(\"sync state: {:?}\", v),\n                }\n            })\n            .unwrap();\n\n        loop {\n            match SYNC_STATE.compare_exchange_weak(\n                THREAD1_WAITING,\n                MAIN_THREAD_RENDEZVOUS,\n                Ordering::SeqCst,\n                Ordering::SeqCst,\n            ) {\n                Ok(_) => break,\n                Err(FRESH) => thread::yield_now(),\n                Err(THREAD2_LAUNCHED) => thread::yield_now(),\n                Err(THREAD2_JOINED) => {\n                    panic!(\"Main thread rendezvous after thread 2 joined thread 1\")\n                }\n                v => unreachable!(\"sync state: {:?}\", v),\n            }\n        }\n        jh2.join().unwrap();\n    }\n}\n"],["2563","//! Native threads.\n//!\n//! ## The threading model\n//!\n//! An executing Rust program consists of a collection of native OS threads,\n//! each with their own stack and local state. Threads can be named, and\n//! provide some built-in support for low-level synchronization.\n//!\n//! Communication between threads can be done through\n//! [channels], Rust's message-passing types, along with [other forms of thread\n//! synchronization](../../std/sync/index.html) and shared-memory data\n//! structures. In particular, types that are guaranteed to be\n//! threadsafe are easily shared between threads using the\n//! atomically-reference-counted container, [`Arc`].\n//!\n//! Fatal logic errors in Rust cause *thread panic*, during which\n//! a thread will unwind the stack, running destructors and freeing\n//! owned resources. While not meant as a 'try/catch' mechanism, panics\n//! in Rust can nonetheless be caught (unless compiling with `panic=abort`) with\n//! [`catch_unwind`](../../std/panic/fn.catch_unwind.html) and recovered\n//! from, or alternatively be resumed with\n//! [`resume_unwind`](../../std/panic/fn.resume_unwind.html). If the panic\n//! is not caught the thread will exit, but the panic may optionally be\n//! detected from a different thread with [`join`]. If the main thread panics\n//! without the panic being caught, the application will exit with a\n//! non-zero exit code.\n//!\n//! When the main thread of a Rust program terminates, the entire program shuts\n//! down, even if other threads are still running. However, this module provides\n//! convenient facilities for automatically waiting for the termination of a\n//! child thread (i.e., join).\n//!\n//! ## Spawning a thread\n//!\n//! A new thread can be spawned using the [`thread::spawn`][`spawn`] function:\n//!\n//! ```rust\n//! use std::thread;\n//!\n//! thread::spawn(move || {\n//!     // some work here\n//! });\n//! ```\n//!\n//! In this example, the spawned thread is \"detached\" from the current\n//! thread. This means that it can outlive its parent (the thread that spawned\n//! it), unless this parent is the main thread.\n//!\n//! The parent thread can also wait on the completion of the child\n//! thread; a call to [`spawn`] produces a [`JoinHandle`], which provides\n//! a `join` method for waiting:\n//!\n//! ```rust\n//! use std::thread;\n//!\n//! let child = thread::spawn(move || {\n//!     // some work here\n//! });\n//! // some work here\n//! let res = child.join();\n//! ```\n//!\n//! The [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final\n//! value produced by the child thread, or [`Err`] of the value given to\n//! a call to [`panic!`] if the child panicked.\n//!\n//! ## Configuring threads\n//!\n//! A new thread can be configured before it is spawned via the [`Builder`] type,\n//! which currently allows you to set the name and stack size for the child thread:\n//!\n//! ```rust\n//! # #![allow(unused_must_use)]\n//! use std::thread;\n//!\n//! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n//!     println!(\"Hello, world!\");\n//! });\n//! ```\n//!\n//! ## The `Thread` type\n//!\n//! Threads are represented via the [`Thread`] type, which you can get in one of\n//! two ways:\n//!\n//! * By spawning a new thread, e.g., using the [`thread::spawn`][`spawn`]\n//!   function, and calling [`thread`][`JoinHandle::thread`] on the [`JoinHandle`].\n//! * By requesting the current thread, using the [`thread::current`] function.\n//!\n//! The [`thread::current`] function is available even for threads not spawned\n//! by the APIs of this module.\n//!\n//! ## Thread-local storage\n//!\n//! This module also provides an implementation of thread-local storage for Rust\n//! programs. Thread-local storage is a method of storing data into a global\n//! variable that each thread in the program will have its own copy of.\n//! Threads do not share this data, so accesses do not need to be synchronized.\n//!\n//! A thread-local key owns the value it contains and will destroy the value when the\n//! thread exits. It is created with the [`thread_local!`] macro and can contain any\n//! value that is `'static` (no borrowed pointers). It provides an accessor function,\n//! [`with`], that yields a shared reference to the value to the specified\n//! closure. Thread-local keys allow only shared access to values, as there would be no\n//! way to guarantee uniqueness if mutable borrows were allowed. Most values\n//! will want to make use of some form of **interior mutability** through the\n//! [`Cell`] or [`RefCell`] types.\n//!\n//! ## Naming threads\n//!\n//! Threads are able to have associated names for identification purposes. By default, spawned\n//! threads are unnamed. To specify a name for a thread, build the thread with [`Builder`] and pass\n//! the desired thread name to [`Builder::name`]. To retrieve the thread name from within the\n//! thread, use [`Thread::name`]. A couple examples of where the name of a thread gets used:\n//!\n//! * If a panic occurs in a named thread, the thread name will be printed in the panic message.\n//! * The thread name is provided to the OS where applicable (e.g., `pthread_setname_np` in\n//!   unix-like platforms).\n//!\n//! ## Stack size\n//!\n//! The default stack size for spawned threads is 2 MiB, though this particular stack size is\n//! subject to change in the future. There are two ways to manually specify the stack size for\n//! spawned threads:\n//!\n//! * Build the thread with [`Builder`] and pass the desired stack size to [`Builder::stack_size`].\n//! * Set the `RUST_MIN_STACK` environment variable to an integer representing the desired stack\n//!   size (in bytes). Note that setting [`Builder::stack_size`] will override this.\n//!\n//! Note that the stack size of the main thread is *not* determined by Rust.\n//!\n//! [channels]: crate::sync::mpsc\n//! [`join`]: JoinHandle::join\n//! [`Result`]: crate::result::Result\n//! [`Ok`]: crate::result::Result::Ok\n//! [`Err`]: crate::result::Result::Err\n//! [`thread::current`]: current\n//! [`thread::Result`]: Result\n//! [`unpark`]: Thread::unpark\n//! [`thread::park_timeout`]: park_timeout\n//! [`Cell`]: crate::cell::Cell\n//! [`RefCell`]: crate::cell::RefCell\n//! [`with`]: LocalKey::with\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![deny(unsafe_op_in_unsafe_fn)]\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\nuse crate::any::Any;\nuse crate::cell::UnsafeCell;\nuse crate::ffi::{CStr, CString};\nuse crate::fmt;\nuse crate::io;\nuse crate::mem;\nuse crate::num::NonZeroU64;\nuse crate::panic;\nuse crate::panicking;\nuse crate::str;\nuse crate::sync::Arc;\nuse crate::sys::thread as imp;\nuse crate::sys_common::mutex;\nuse crate::sys_common::thread;\nuse crate::sys_common::thread_info;\nuse crate::sys_common::thread_parker::Parker;\nuse crate::sys_common::{AsInner, IntoInner};\nuse crate::time::Duration;\n\n////////////////////////////////////////////////////////////////////////////////\n// Thread-local storage\n////////////////////////////////////////////////////////////////////////////////\n\n#[macro_use]\nmod local;\n\n#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\nmod available_concurrency;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::local::{AccessError, LocalKey};\n\n#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\npub use available_concurrency::available_concurrency;\n\n// The types used by the thread_local! macro to access TLS keys. Note that there\n// are two types, the \"OS\" type and the \"fast\" type. The OS thread local key\n// type is accessed via platform-specific API calls and is slow, while the fast\n// key type is accessed via code generated via LLVM, where TLS keys are set up\n// by the elf linker. Note that the OS TLS type is always available: on macOS\n// the standard library is compiled with support for older platform versions\n// where fast TLS was not available; end-user code is compiled with fast TLS\n// where available, but both are needed.\n\n#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n#[cfg(target_thread_local)]\n#[doc(hidden)]\npub use self::local::fast::Key as __FastLocalKeyInner;\n#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n#[doc(hidden)]\npub use self::local::os::Key as __OsLocalKeyInner;\n#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n#[doc(hidden)]\npub use self::local::statik::Key as __StaticLocalKeyInner;\n\n// This is only used to make thread locals with `const { .. }` initialization\n// expressions unstable. If and/or when that syntax is stabilized with thread\n// locals this will simply be removed.\n#[doc(hidden)]\n#[unstable(feature = \"thread_local_const_init\", issue = \"84223\")]\npub const fn require_unstable_const_init_thread_local() {}\n\n////////////////////////////////////////////////////////////////////////////////\n// Builder\n////////////////////////////////////////////////////////////////////////////////\n\n/// Thread factory, which can be used in order to configure the properties of\n/// a new thread.\n///\n/// Methods can be chained on it in order to configure it.\n///\n/// The two configurations available are:\n///\n/// - [`name`]: specifies an [associated name for the thread][naming-threads]\n/// - [`stack_size`]: specifies the [desired stack size for the thread][stack-size]\n///\n/// The [`spawn`] method will take ownership of the builder and create an\n/// [`io::Result`] to the thread handle with the given configuration.\n///\n/// The [`thread::spawn`] free function uses a `Builder` with default\n/// configuration and [`unwrap`]s its return value.\n///\n/// You may want to use [`spawn`] instead of [`thread::spawn`], when you want\n/// to recover from a failure to launch a thread, indeed the free function will\n/// panic where the `Builder` method will return a [`io::Result`].\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// let builder = thread::Builder::new();\n///\n/// let handler = builder.spawn(|| {\n///     // thread code\n/// }).unwrap();\n///\n/// handler.join().unwrap();\n/// ```\n///\n/// [`stack_size`]: Builder::stack_size\n/// [`name`]: Builder::name\n/// [`spawn`]: Builder::spawn\n/// [`thread::spawn`]: spawn\n/// [`io::Result`]: crate::io::Result\n/// [`unwrap`]: crate::result::Result::unwrap\n/// [naming-threads]: ./index.html#naming-threads\n/// [stack-size]: ./index.html#stack-size\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Builder {\n    // A name for the thread-to-be, for identification in panic messages\n    name: Option<String>,\n    // The size of the stack for the spawned thread in bytes\n    stack_size: Option<usize>,\n}\n\nimpl Builder {\n    /// Generates the base configuration for spawning a thread, from which\n    /// configuration methods can be chained.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///                               .name(\"foo\".into())\n    ///                               .stack_size(32 * 1024);\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     // thread code\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> Builder {\n        Builder { name: None, stack_size: None }\n    }\n\n    /// Names the thread-to-be. Currently the name is used for identification\n    /// only in panic messages.\n    ///\n    /// The name must not contain null bytes (`\\0`).\n    ///\n    /// For more information about named threads, see\n    /// [this module-level documentation][naming-threads].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///     .name(\"foo\".into());\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert_eq!(thread::current().name(), Some(\"foo\"))\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// [naming-threads]: ./index.html#naming-threads\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn name(mut self, name: String) -> Builder {\n        self.name = Some(name);\n        self\n    }\n\n    /// Sets the size of the stack (in bytes) for the new thread.\n    ///\n    /// The actual stack size may be greater than this value if\n    /// the platform specifies a minimal stack size.\n    ///\n    /// For more information about the stack size for threads, see\n    /// [this module-level documentation][stack-size].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new().stack_size(32 * 1024);\n    /// ```\n    ///\n    /// [stack-size]: ./index.html#stack-size\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn stack_size(mut self, size: usize) -> Builder {\n        self.stack_size = Some(size);\n        self\n    }\n\n    /// Spawns a new thread by taking ownership of the `Builder`, and returns an\n    /// [`io::Result`] to its [`JoinHandle`].\n    ///\n    /// The spawned thread may outlive the caller (unless the caller thread\n    /// is the main thread; the whole process is terminated when the main\n    /// thread finishes). The join handle can be used to block on\n    /// termination of the child thread, including recovering its panics.\n    ///\n    /// For a more complete documentation see [`thread::spawn`][`spawn`].\n    ///\n    /// # Errors\n    ///\n    /// Unlike the [`spawn`] free function, this method yields an\n    /// [`io::Result`] to capture any failure to create the thread at\n    /// the OS level.\n    ///\n    /// [`io::Result`]: crate::io::Result\n    ///\n    /// # Panics\n    ///\n    /// Panics if a thread name was set and it contained null bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     // thread code\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send + 'static,\n    {\n        unsafe { self.spawn_unchecked(f) }\n    }\n\n    /// Spawns a new thread without any lifetime restrictions by taking ownership\n    /// of the `Builder`, and returns an [`io::Result`] to its [`JoinHandle`].\n    ///\n    /// The spawned thread may outlive the caller (unless the caller thread\n    /// is the main thread; the whole process is terminated when the main\n    /// thread finishes). The join handle can be used to block on\n    /// termination of the child thread, including recovering its panics.\n    ///\n    /// This method is identical to [`thread::Builder::spawn`][`Builder::spawn`],\n    /// except for the relaxed lifetime bounds, which render it unsafe.\n    /// For a more complete documentation see [`thread::spawn`][`spawn`].\n    ///\n    /// # Errors\n    ///\n    /// Unlike the [`spawn`] free function, this method yields an\n    /// [`io::Result`] to capture any failure to create the thread at\n    /// the OS level.\n    ///\n    /// # Panics\n    ///\n    /// Panics if a thread name was set and it contained null bytes.\n    ///\n    /// # Safety\n    ///\n    /// The caller has to ensure that no references in the supplied thread closure\n    /// or its return type can outlive the spawned thread's lifetime. This can be\n    /// guaranteed in two ways:\n    ///\n    /// - ensure that [`join`][`JoinHandle::join`] is called before any referenced\n    /// data is dropped\n    /// - use only types with `'static` lifetime bounds, i.e., those with no or only\n    /// `'static` references (both [`thread::Builder::spawn`][`Builder::spawn`]\n    /// and [`thread::spawn`][`spawn`] enforce this property statically)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(thread_spawn_unchecked)]\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let x = 1;\n    /// let thread_x = &x;\n    ///\n    /// let handler = unsafe {\n    ///     builder.spawn_unchecked(move || {\n    ///         println!(\"x = {}\", *thread_x);\n    ///     }).unwrap()\n    /// };\n    ///\n    /// // caller has to ensure `join()` is called, otherwise\n    /// // it is possible to access freed memory if `x` gets\n    /// // dropped before the thread closure is executed!\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// [`io::Result`]: crate::io::Result\n    #[unstable(feature = \"thread_spawn_unchecked\", issue = \"55132\")]\n    pub unsafe fn spawn_unchecked<'a, F, T>(self, f: F) -> io::Result<JoinHandle<T>>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'a,\n        T: Send + 'a,\n    {\n        let Builder { name, stack_size } = self;\n\n        let stack_size = stack_size.unwrap_or_else(thread::min_stack);\n\n        let my_thread = Thread::new(name);\n        let their_thread = my_thread.clone();\n\n        let my_packet: Arc<UnsafeCell<Option<Result<T>>>> = Arc::new(UnsafeCell::new(None));\n        let their_packet = my_packet.clone();\n\n        let output_capture = crate::io::set_output_capture(None);\n        crate::io::set_output_capture(output_capture.clone());\n\n        let main = move || {\n            if let Some(name) = their_thread.cname() {\n                imp::Thread::set_name(name);\n            }\n\n            crate::io::set_output_capture(output_capture);\n\n            // SAFETY: the stack guard passed is the one for the current thread.\n            // This means the current thread's stack and the new thread's stack\n            // are properly set and protected from each other.\n            thread_info::set(unsafe { imp::guard::current() }, their_thread);\n            let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n                crate::sys_common::backtrace::__rust_begin_short_backtrace(f)\n            }));\n            // SAFETY: `their_packet` as been built just above and moved by the\n            // closure (it is an Arc<...>) and `my_packet` will be stored in the\n            // same `JoinInner` as this closure meaning the mutation will be\n            // safe (not modify it and affect a value far away).\n            unsafe { *their_packet.get() = Some(try_result) };\n        };\n\n        Ok(JoinHandle(JoinInner {\n            // SAFETY:\n            //\n            // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n            // through FFI or otherwise used with low-level threading primitives that have no\n            // notion of or way to enforce lifetimes.\n            //\n            // As mentioned in the `Safety` section of this function's documentation, the caller of\n            // this function needs to guarantee that the passed-in lifetime is sufficiently long\n            // for the lifetime of the thread.\n            //\n            // Similarly, the `sys` implementation must guarantee that no references to the closure\n            // exist after the thread has terminated, which is signaled by `Thread::join`\n            // returning.\n            native: unsafe {\n                Some(imp::Thread::new(\n                    stack_size,\n                    mem::transmute::<Box<dyn FnOnce() + 'a>, Box<dyn FnOnce() + 'static>>(\n                        Box::new(main),\n                    ),\n                )?)\n            },\n            thread: my_thread,\n            packet: Packet(my_packet),\n        }))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Free functions\n////////////////////////////////////////////////////////////////////////////////\n\n/// Spawns a new thread, returning a [`JoinHandle`] for it.\n///\n/// The join handle will implicitly *detach* the child thread upon being\n/// dropped. In this case, the child thread may outlive the parent (unless\n/// the parent thread is the main thread; the whole process is terminated when\n/// the main thread finishes). Additionally, the join handle provides a [`join`]\n/// method that can be used to join the child thread. If the child thread\n/// panics, [`join`] will return an [`Err`] containing the argument given to\n/// [`panic!`].\n///\n/// This will create a thread using default parameters of [`Builder`], if you\n/// want to specify the stack size or the name of the thread, use this API\n/// instead.\n///\n/// As you can see in the signature of `spawn` there are two constraints on\n/// both the closure given to `spawn` and its return value, let's explain them:\n///\n/// - The `'static` constraint means that the closure and its return value\n///   must have a lifetime of the whole program execution. The reason for this\n///   is that threads can `detach` and outlive the lifetime they have been\n///   created in.\n///   Indeed if the thread, and by extension its return value, can outlive their\n///   caller, we need to make sure that they will be valid afterwards, and since\n///   we *can't* know when it will return we need to have them valid as long as\n///   possible, that is until the end of the program, hence the `'static`\n///   lifetime.\n/// - The [`Send`] constraint is because the closure will need to be passed\n///   *by value* from the thread where it is spawned to the new thread. Its\n///   return value will need to be passed from the new thread to the thread\n///   where it is `join`ed.\n///   As a reminder, the [`Send`] marker trait expresses that it is safe to be\n///   passed from thread to thread. [`Sync`] expresses that it is safe to have a\n///   reference be passed from thread to thread.\n///\n/// # Panics\n///\n/// Panics if the OS fails to create a thread; use [`Builder::spawn`]\n/// to recover from such errors.\n///\n/// # Examples\n///\n/// Creating a thread.\n///\n/// ```\n/// use std::thread;\n///\n/// let handler = thread::spawn(|| {\n///     // thread code\n/// });\n///\n/// handler.join().unwrap();\n/// ```\n///\n/// As mentioned in the module documentation, threads are usually made to\n/// communicate using [`channels`], here is how it usually looks.\n///\n/// This example also shows how to use `move`, in order to give ownership\n/// of values to a thread.\n///\n/// ```\n/// use std::thread;\n/// use std::sync::mpsc::channel;\n///\n/// let (tx, rx) = channel();\n///\n/// let sender = thread::spawn(move || {\n///     tx.send(\"Hello, thread\".to_owned())\n///         .expect(\"Unable to send on channel\");\n/// });\n///\n/// let receiver = thread::spawn(move || {\n///     let value = rx.recv().expect(\"Unable to receive from channel\");\n///     println!(\"{}\", value);\n/// });\n///\n/// sender.join().expect(\"The sender thread has panicked\");\n/// receiver.join().expect(\"The receiver thread has panicked\");\n/// ```\n///\n/// A thread can also return a value through its [`JoinHandle`], you can use\n/// this to make asynchronous computations (futures might be more appropriate\n/// though).\n///\n/// ```\n/// use std::thread;\n///\n/// let computation = thread::spawn(|| {\n///     // Some expensive computation.\n///     42\n/// });\n///\n/// let result = computation.join().unwrap();\n/// println!(\"{}\", result);\n/// ```\n///\n/// [`channels`]: crate::sync::mpsc\n/// [`join`]: JoinHandle::join\n/// [`Err`]: crate::result::Result::Err\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn spawn<F, T>(f: F) -> JoinHandle<T>\nwhere\n    F: FnOnce() -> T,\n    F: Send + 'static,\n    T: Send + 'static,\n{\n    Builder::new().spawn(f).expect(\"failed to spawn thread\")\n}\n\n/// Gets a handle to the thread that invokes it.\n///\n/// # Examples\n///\n/// Getting a handle to the current thread with `thread::current()`:\n///\n/// ```\n/// use std::thread;\n///\n/// let handler = thread::Builder::new()\n///     .name(\"named thread\".into())\n///     .spawn(|| {\n///         let handle = thread::current();\n///         assert_eq!(handle.name(), Some(\"named thread\"));\n///     })\n///     .unwrap();\n///\n/// handler.join().unwrap();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn current() -> Thread {\n    thread_info::current_thread().expect(\n        \"use of std::thread::current() is not possible \\\n         after the thread's local data has been destroyed\",\n    )\n}\n\n/// Cooperatively gives up a timeslice to the OS scheduler.\n///\n/// This is used when the programmer knows that the thread will have nothing\n/// to do for some time, and thus avoid wasting computing time.\n///\n/// For example when polling on a resource, it is common to check that it is\n/// available, and if not to yield in order to avoid busy waiting.\n///\n/// Thus the pattern of `yield`ing after a failed poll is rather common when\n/// implementing low-level shared resources or synchronization primitives.\n///\n/// However programmers will usually prefer to use [`channel`]s, [`Condvar`]s,\n/// [`Mutex`]es or [`join`] for their synchronization routines, as they avoid\n/// thinking about thread scheduling.\n///\n/// Note that [`channel`]s for example are implemented using this primitive.\n/// Indeed when you call `send` or `recv`, which are blocking, they will yield\n/// if the channel is not available.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// thread::yield_now();\n/// ```\n///\n/// [`channel`]: crate::sync::mpsc\n/// [`join`]: JoinHandle::join\n/// [`Condvar`]: crate::sync::Condvar\n/// [`Mutex`]: crate::sync::Mutex\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn yield_now() {\n    imp::Thread::yield_now()\n}\n\n/// Determines whether the current thread is unwinding because of panic.\n///\n/// A common use of this feature is to poison shared resources when writing\n/// unsafe code, by checking `panicking` when the `drop` is called.\n///\n/// This is usually not needed when writing safe code, as [`Mutex`es][Mutex]\n/// already poison themselves when a thread panics while holding the lock.\n///\n/// This can also be used in multithreaded applications, in order to send a\n/// message to other threads warning that a thread has panicked (e.g., for\n/// monitoring purposes).\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::thread;\n///\n/// struct SomeStruct;\n///\n/// impl Drop for SomeStruct {\n///     fn drop(&mut self) {\n///         if thread::panicking() {\n///             println!(\"dropped while unwinding\");\n///         } else {\n///             println!(\"dropped while not unwinding\");\n///         }\n///     }\n/// }\n///\n/// {\n///     print!(\"a: \");\n///     let a = SomeStruct;\n/// }\n///\n/// {\n///     print!(\"b: \");\n///     let b = SomeStruct;\n///     panic!()\n/// }\n/// ```\n///\n/// [Mutex]: crate::sync::Mutex\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn panicking() -> bool {\n    panicking::panicking()\n}\n\n/// Puts the current thread to sleep for at least the specified amount of time.\n///\n/// The thread may sleep longer than the duration specified due to scheduling\n/// specifics or platform-dependent functionality. It will never sleep less.\n///\n/// This function is blocking, and should not be used in `async` functions.\n///\n/// # Platform-specific behavior\n///\n/// On Unix platforms, the underlying syscall may be interrupted by a\n/// spurious wakeup or signal handler. To ensure the sleep occurs for at least\n/// the specified duration, this function may invoke that system call multiple\n/// times.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::thread;\n///\n/// // Let's sleep for 2 seconds:\n/// thread::sleep_ms(2000);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::sleep`\")]\npub fn sleep_ms(ms: u32) {\n    sleep(Duration::from_millis(ms as u64))\n}\n\n/// Puts the current thread to sleep for at least the specified amount of time.\n///\n/// The thread may sleep longer than the duration specified due to scheduling\n/// specifics or platform-dependent functionality. It will never sleep less.\n///\n/// This function is blocking, and should not be used in `async` functions.\n///\n/// # Platform-specific behavior\n///\n/// On Unix platforms, the underlying syscall may be interrupted by a\n/// spurious wakeup or signal handler. To ensure the sleep occurs for at least\n/// the specified duration, this function may invoke that system call multiple\n/// times.\n/// Platforms which do not support nanosecond precision for sleeping will\n/// have `dur` rounded up to the nearest granularity of time they can sleep for.\n///\n/// Currently, specifying a zero duration on Unix platforms returns immediately\n/// without invoking the underlying [`nanosleep`] syscall, whereas on Windows\n/// platforms the underlying [`Sleep`] syscall is always invoked.\n/// If the intention is to yield the current time-slice you may want to use\n/// [`yield_now`] instead.\n///\n/// [`nanosleep`]: https://linux.die.net/man/2/nanosleep\n/// [`Sleep`]: https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::{thread, time};\n///\n/// let ten_millis = time::Duration::from_millis(10);\n/// let now = time::Instant::now();\n///\n/// thread::sleep(ten_millis);\n///\n/// assert!(now.elapsed() >= ten_millis);\n/// ```\n#[stable(feature = \"thread_sleep\", since = \"1.4.0\")]\npub fn sleep(dur: Duration) {\n    imp::Thread::sleep(dur)\n}\n\n/// Blocks unless or until the current thread's token is made available.\n///\n/// A call to `park` does not guarantee that the thread will remain parked\n/// forever, and callers should be prepared for this possibility.\n///\n/// # park and unpark\n///\n/// Every thread is equipped with some basic low-level blocking support, via the\n/// [`thread::park`][`park`] function and [`thread::Thread::unpark`][`unpark`]\n/// method. [`park`] blocks the current thread, which can then be resumed from\n/// another thread by calling the [`unpark`] method on the blocked thread's\n/// handle.\n///\n/// Conceptually, each [`Thread`] handle has an associated token, which is\n/// initially not present:\n///\n/// * The [`thread::park`][`park`] function blocks the current thread unless or\n///   until the token is available for its thread handle, at which point it\n///   atomically consumes the token. It may also return *spuriously*, without\n///   consuming the token. [`thread::park_timeout`] does the same, but allows\n///   specifying a maximum time to block the thread for.\n///\n/// * The [`unpark`] method on a [`Thread`] atomically makes the token available\n///   if it wasn't already. Because the token is initially absent, [`unpark`]\n///   followed by [`park`] will result in the second call returning immediately.\n///\n/// In other words, each [`Thread`] acts a bit like a spinlock that can be\n/// locked and unlocked using `park` and `unpark`.\n///\n/// Notice that being unblocked does not imply any synchronization with someone\n/// that unparked this thread, it could also be spurious.\n/// For example, it would be a valid, but inefficient, implementation to make both [`park`] and\n/// [`unpark`] return immediately without doing anything.\n///\n/// The API is typically used by acquiring a handle to the current thread,\n/// placing that handle in a shared data structure so that other threads can\n/// find it, and then `park`ing in a loop. When some desired condition is met, another\n/// thread calls [`unpark`] on the handle.\n///\n/// The motivation for this design is twofold:\n///\n/// * It avoids the need to allocate mutexes and condvars when building new\n///   synchronization primitives; the threads already provide basic\n///   blocking/signaling.\n///\n/// * It can be implemented very efficiently on many platforms.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::sync::{Arc, atomic::{Ordering, AtomicBool}};\n/// use std::time::Duration;\n///\n/// let flag = Arc::new(AtomicBool::new(false));\n/// let flag2 = Arc::clone(&flag);\n///\n/// let parked_thread = thread::spawn(move || {\n///     // We want to wait until the flag is set. We *could* just spin, but using\n///     // park/unpark is more efficient.\n///     while !flag2.load(Ordering::Acquire) {\n///         println!(\"Parking thread\");\n///         thread::park();\n///         // We *could* get here spuriously, i.e., way before the 10ms below are over!\n///         // But that is no problem, we are in a loop until the flag is set anyway.\n///         println!(\"Thread unparked\");\n///     }\n///     println!(\"Flag received\");\n/// });\n///\n/// // Let some time pass for the thread to be spawned.\n/// thread::sleep(Duration::from_millis(10));\n///\n/// // Set the flag, and let the thread wake up.\n/// // There is no race condition here, if `unpark`\n/// // happens first, `park` will return immediately.\n/// // Hence there is no risk of a deadlock.\n/// flag.store(true, Ordering::Release);\n/// println!(\"Unpark the thread\");\n/// parked_thread.thread().unpark();\n///\n/// parked_thread.join().unwrap();\n/// ```\n///\n/// [`unpark`]: Thread::unpark\n/// [`thread::park_timeout`]: park_timeout\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn park() {\n    // SAFETY: park_timeout is called on the parker owned by this thread.\n    unsafe {\n        current().inner.parker.park();\n    }\n}\n\n/// Use [`park_timeout`].\n///\n/// Blocks unless or until the current thread's token is made available or\n/// the specified duration has been reached (may wake spuriously).\n///\n/// The semantics of this function are equivalent to [`park`] except\n/// that the thread will be blocked for roughly no longer than `dur`. This\n/// method should not be used for precise timing due to anomalies such as\n/// preemption or platform differences that may not cause the maximum\n/// amount of time waited to be precisely `ms` long.\n///\n/// See the [park documentation][`park`] for more detail.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::park_timeout`\")]\npub fn park_timeout_ms(ms: u32) {\n    park_timeout(Duration::from_millis(ms as u64))\n}\n\n/// Blocks unless or until the current thread's token is made available or\n/// the specified duration has been reached (may wake spuriously).\n///\n/// The semantics of this function are equivalent to [`park`][park] except\n/// that the thread will be blocked for roughly no longer than `dur`. This\n/// method should not be used for precise timing due to anomalies such as\n/// preemption or platform differences that may not cause the maximum\n/// amount of time waited to be precisely `dur` long.\n///\n/// See the [park documentation][park] for more details.\n///\n/// # Platform-specific behavior\n///\n/// Platforms which do not support nanosecond precision for sleeping will have\n/// `dur` rounded up to the nearest granularity of time they can sleep for.\n///\n/// # Examples\n///\n/// Waiting for the complete expiration of the timeout:\n///\n/// ```rust,no_run\n/// use std::thread::park_timeout;\n/// use std::time::{Instant, Duration};\n///\n/// let timeout = Duration::from_secs(2);\n/// let beginning_park = Instant::now();\n///\n/// let mut timeout_remaining = timeout;\n/// loop {\n///     park_timeout(timeout_remaining);\n///     let elapsed = beginning_park.elapsed();\n///     if elapsed >= timeout {\n///         break;\n///     }\n///     println!(\"restarting park_timeout after {:?}\", elapsed);\n///     timeout_remaining = timeout - elapsed;\n/// }\n/// ```\n#[stable(feature = \"park_timeout\", since = \"1.4.0\")]\npub fn park_timeout(dur: Duration) {\n    // SAFETY: park_timeout is called on the parker owned by this thread.\n    unsafe {\n        current().inner.parker.park_timeout(dur);\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ThreadId\n////////////////////////////////////////////////////////////////////////////////\n\n/// A unique identifier for a running thread.\n///\n/// A `ThreadId` is an opaque object that has a unique value for each thread\n/// that creates one. `ThreadId`s are not guaranteed to correspond to a thread's\n/// system-designated identifier. A `ThreadId` can be retrieved from the [`id`]\n/// method on a [`Thread`].\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// let other_thread = thread::spawn(|| {\n///     thread::current().id()\n/// });\n///\n/// let other_thread_id = other_thread.join().unwrap();\n/// assert!(thread::current().id() != other_thread_id);\n/// ```\n///\n/// [`id`]: Thread::id\n#[stable(feature = \"thread_id\", since = \"1.19.0\")]\n#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\npub struct ThreadId(NonZeroU64);\n\nimpl ThreadId {\n    // Generate a new unique thread ID.\n    fn new() -> ThreadId {\n        // It is UB to attempt to acquire this mutex reentrantly!\n        static GUARD: mutex::StaticMutex = mutex::StaticMutex::new();\n        static mut COUNTER: u64 = 1;\n\n        unsafe {\n            let _guard = GUARD.lock();\n\n            // If we somehow use up all our bits, panic so that we're not\n            // covering up subtle bugs of IDs being reused.\n            if COUNTER == u64::MAX {\n                panic!(\"failed to generate unique thread ID: bitspace exhausted\");\n            }\n\n            let id = COUNTER;\n            COUNTER += 1;\n\n            ThreadId(NonZeroU64::new(id).unwrap())\n        }\n    }\n\n    /// This returns a numeric identifier for the thread identified by this\n    /// `ThreadId`.\n    ///\n    /// As noted in the documentation for the type itself, it is essentially an\n    /// opaque ID, but is guaranteed to be unique for each thread. The returned\n    /// value is entirely opaque -- only equality testing is stable. Note that\n    /// it is not guaranteed which values new threads will return, and this may\n    /// change across Rust versions.\n    #[unstable(feature = \"thread_id_value\", issue = \"67939\")]\n    pub fn as_u64(&self) -> NonZeroU64 {\n        self.0\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Thread\n////////////////////////////////////////////////////////////////////////////////\n\n/// The internal representation of a `Thread` handle\nstruct Inner {\n    name: Option<CString>, // Guaranteed to be UTF-8\n    id: ThreadId,\n    parker: Parker,\n}\n\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n/// A handle to a thread.\n///\n/// Threads are represented via the `Thread` type, which you can get in one of\n/// two ways:\n///\n/// * By spawning a new thread, e.g., using the [`thread::spawn`][`spawn`]\n///   function, and calling [`thread`][`JoinHandle::thread`] on the\n///   [`JoinHandle`].\n/// * By requesting the current thread, using the [`thread::current`] function.\n///\n/// The [`thread::current`] function is available even for threads not spawned\n/// by the APIs of this module.\n///\n/// There is usually no need to create a `Thread` struct yourself, one\n/// should instead use a function like `spawn` to create new threads, see the\n/// docs of [`Builder`] and [`spawn`] for more details.\n///\n/// [`thread::current`]: current\npub struct Thread {\n    inner: Arc<Inner>,\n}\n\nimpl Thread {\n    // Used only internally to construct a thread object without spawning\n    // Panics if the name contains nuls.\n    pub(crate) fn new(name: Option<String>) -> Thread {\n        let cname =\n            name.map(|n| CString::new(n).expect(\"thread name may not contain interior null bytes\"));\n        Thread {\n            inner: Arc::new(Inner { name: cname, id: ThreadId::new(), parker: Parker::new() }),\n        }\n    }\n\n    /// Atomically makes the handle's token available if it is not already.\n    ///\n    /// Every thread is equipped with some basic low-level blocking support, via\n    /// the [`park`][park] function and the `unpark()` method. These can be\n    /// used as a more CPU-efficient implementation of a spinlock.\n    ///\n    /// See the [park documentation][park] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let parked_thread = thread::Builder::new()\n    ///     .spawn(|| {\n    ///         println!(\"Parking thread\");\n    ///         thread::park();\n    ///         println!(\"Thread unparked\");\n    ///     })\n    ///     .unwrap();\n    ///\n    /// // Let some time pass for the thread to be spawned.\n    /// thread::sleep(Duration::from_millis(10));\n    ///\n    /// println!(\"Unpark the thread\");\n    /// parked_thread.thread().unpark();\n    ///\n    /// parked_thread.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn unpark(&self) {\n        self.inner.parker.unpark();\n    }\n\n    /// Gets the thread's unique identifier.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let other_thread = thread::spawn(|| {\n    ///     thread::current().id()\n    /// });\n    ///\n    /// let other_thread_id = other_thread.join().unwrap();\n    /// assert!(thread::current().id() != other_thread_id);\n    /// ```\n    #[stable(feature = \"thread_id\", since = \"1.19.0\")]\n    pub fn id(&self) -> ThreadId {\n        self.inner.id\n    }\n\n    /// Gets the thread's name.\n    ///\n    /// For more information about named threads, see\n    /// [this module-level documentation][naming-threads].\n    ///\n    /// # Examples\n    ///\n    /// Threads by default have no name specified:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert!(thread::current().name().is_none());\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// Thread with a specified name:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///     .name(\"foo\".into());\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert_eq!(thread::current().name(), Some(\"foo\"))\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// [naming-threads]: ./index.html#naming-threads\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn name(&self) -> Option<&str> {\n        self.cname().map(|s| unsafe { str::from_utf8_unchecked(s.to_bytes()) })\n    }\n\n    fn cname(&self) -> Option<&CStr> {\n        self.inner.name.as_deref()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Thread {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Thread\")\n            .field(\"id\", &self.id())\n            .field(\"name\", &self.name())\n            .finish_non_exhaustive()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// JoinHandle\n////////////////////////////////////////////////////////////////////////////////\n\n/// A specialized [`Result`] type for threads.\n///\n/// Indicates the manner in which a thread exited.\n///\n/// The value contained in the `Result::Err` variant\n/// is the value the thread panicked with;\n/// that is, the argument the `panic!` macro was called with.\n/// Unlike with normal errors, this value doesn't implement\n/// the [`Error`](crate::error::Error) trait.\n///\n/// Thus, a sensible way to handle a thread panic is to either:\n///\n/// 1. propagate the panic with [`std::panic::resume_unwind`]\n/// 2. or in case the thread is intended to be a subsystem boundary\n/// that is supposed to isolate system-level failures,\n/// match on the `Err` variant and handle the panic in an appropriate way\n///\n/// A thread that completes without panicking is considered to exit successfully.\n///\n/// # Examples\n///\n/// Matching on the result of a joined thread:\n///\n/// ```no_run\n/// use std::{fs, thread, panic};\n///\n/// fn copy_in_thread() -> thread::Result<()> {\n///     thread::spawn(|| {\n///         fs::copy(\"foo.txt\", \"bar.txt\").unwrap();\n///     }).join()\n/// }\n///\n/// fn main() {\n///     match copy_in_thread() {\n///         Ok(_) => println!(\"copy succeeded\"),\n///         Err(e) => panic::resume_unwind(e),\n///     }\n/// }\n/// ```\n///\n/// [`Result`]: crate::result::Result\n/// [`std::panic::resume_unwind`]: crate::panic::resume_unwind\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result<T> = crate::result::Result<T, Box<dyn Any + Send + 'static>>;\n\n// This packet is used to communicate the return value between the child thread\n// and the parent thread. Memory is shared through the `Arc` within and there's\n// no need for a mutex here because synchronization happens with `join()` (the\n// parent thread never reads this packet until the child has exited).\n//\n// This packet itself is then stored into a `JoinInner` which in turns is placed\n// in `JoinHandle` and `JoinGuard`. Due to the usage of `UnsafeCell` we need to\n// manually worry about impls like Send and Sync. The type `T` should\n// already always be Send (otherwise the thread could not have been created) and\n// this type is inherently Sync because no methods take &self. Regardless,\n// however, we add inheriting impls for Send/Sync to this type to ensure it's\n// Send/Sync and that future modifications will still appropriately classify it.\nstruct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n\nunsafe impl<T: Send> Send for Packet<T> {}\nunsafe impl<T: Sync> Sync for Packet<T> {}\n\n/// Inner representation for JoinHandle\nstruct JoinInner<T> {\n    native: Option<imp::Thread>,\n    thread: Thread,\n    packet: Packet<T>,\n}\n\nimpl<T> JoinInner<T> {\n    fn join(&mut self) -> Result<T> {\n        self.native.take().unwrap().join();\n        unsafe { (*self.packet.0.get()).take().unwrap() }\n    }\n}\n\n/// An owned permission to join on a thread (block on its termination).\n///\n/// A `JoinHandle` *detaches* the associated thread when it is dropped, which\n/// means that there is no longer any handle to thread and no way to `join`\n/// on it.\n///\n/// Due to platform restrictions, it is not possible to [`Clone`] this\n/// handle: the ability to join a thread is a uniquely-owned permission.\n///\n/// This `struct` is created by the [`thread::spawn`] function and the\n/// [`thread::Builder::spawn`] method.\n///\n/// # Examples\n///\n/// Creation from [`thread::spawn`]:\n///\n/// ```\n/// use std::thread;\n///\n/// let join_handle: thread::JoinHandle<_> = thread::spawn(|| {\n///     // some work here\n/// });\n/// ```\n///\n/// Creation from [`thread::Builder::spawn`]:\n///\n/// ```\n/// use std::thread;\n///\n/// let builder = thread::Builder::new();\n///\n/// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n///     // some work here\n/// }).unwrap();\n/// ```\n///\n/// Child being detached and outliving its parent:\n///\n/// ```no_run\n/// use std::thread;\n/// use std::time::Duration;\n///\n/// let original_thread = thread::spawn(|| {\n///     let _detached_thread = thread::spawn(|| {\n///         // Here we sleep to make sure that the first thread returns before.\n///         thread::sleep(Duration::from_millis(10));\n///         // This will be called, even though the JoinHandle is dropped.\n///         println!(\" Still alive \");\n///     });\n/// });\n///\n/// original_thread.join().expect(\"The thread being joined has panicked\");\n/// println!(\"Original thread is joined.\");\n///\n/// // We make sure that the new thread has time to run, before the main\n/// // thread returns.\n///\n/// thread::sleep(Duration::from_millis(1000));\n/// ```\n///\n/// [`thread::Builder::spawn`]: Builder::spawn\n/// [`thread::spawn`]: spawn\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct JoinHandle<T>(JoinInner<T>);\n\n#[stable(feature = \"joinhandle_impl_send_sync\", since = \"1.29.0\")]\nunsafe impl<T> Send for JoinHandle<T> {}\n#[stable(feature = \"joinhandle_impl_send_sync\", since = \"1.29.0\")]\nunsafe impl<T> Sync for JoinHandle<T> {}\n\nimpl<T> JoinHandle<T> {\n    /// Extracts a handle to the underlying thread.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n    ///     // some work here\n    /// }).unwrap();\n    ///\n    /// let thread = join_handle.thread();\n    /// println!(\"thread id: {:?}\", thread.id());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn thread(&self) -> &Thread {\n        &self.0.thread\n    }\n\n    /// Waits for the associated thread to finish.\n    ///\n    /// In terms of [atomic memory orderings],  the completion of the associated\n    /// thread synchronizes with this function returning. In other words, all\n    /// operations performed by that thread are ordered before all\n    /// operations that happen after `join` returns.\n    ///\n    /// If the child thread panics, [`Err`] is returned with the parameter given\n    /// to [`panic!`].\n    ///\n    /// [`Err`]: crate::result::Result::Err\n    /// [atomic memory orderings]: crate::sync::atomic\n    ///\n    /// # Panics\n    ///\n    /// This function may panic on some platforms if a thread attempts to join\n    /// itself or otherwise may create a deadlock with joining threads.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n    ///     // some work here\n    /// }).unwrap();\n    /// join_handle.join().expect(\"Couldn't join on the associated thread\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn join(mut self) -> Result<T> {\n        self.0.join()\n    }\n}\n\nimpl<T> AsInner<imp::Thread> for JoinHandle<T> {\n    fn as_inner(&self) -> &imp::Thread {\n        self.0.native.as_ref().unwrap()\n    }\n}\n\nimpl<T> IntoInner<imp::Thread> for JoinHandle<T> {\n    fn into_inner(self) -> imp::Thread {\n        self.0.native.unwrap()\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T> fmt::Debug for JoinHandle<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"JoinHandle\").finish_non_exhaustive()\n    }\n}\n\nfn _assert_sync_and_send() {\n    fn _assert_both<T: Send + Sync>() {}\n    _assert_both::<JoinHandle<()>>();\n    _assert_both::<Thread>();\n}\n"],["2564","use super::Builder;\nuse crate::any::Any;\nuse crate::mem;\nuse crate::result;\nuse crate::sync::mpsc::{channel, Sender};\nuse crate::thread::{self, ThreadId};\nuse crate::time::Duration;\n\n// !!! These tests are dangerous. If something is buggy, they will hang, !!!\n// !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n\n#[test]\nfn test_unnamed_thread() {\n    thread::spawn(move || {\n        assert!(thread::current().name().is_none());\n    })\n    .join()\n    .ok()\n    .expect(\"thread panicked\");\n}\n\n#[test]\nfn test_named_thread() {\n    Builder::new()\n        .name(\"ada lovelace\".to_string())\n        .spawn(move || {\n            assert!(thread::current().name().unwrap() == \"ada lovelace\".to_string());\n        })\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\n#[test]\n#[should_panic]\nfn test_invalid_named_thread() {\n    let _ = Builder::new().name(\"ada l\\0velace\".to_string()).spawn(|| {});\n}\n\n#[test]\nfn test_run_basic() {\n    let (tx, rx) = channel();\n    thread::spawn(move || {\n        tx.send(()).unwrap();\n    });\n    rx.recv().unwrap();\n}\n\n#[test]\nfn test_join_panic() {\n    match thread::spawn(move || panic!()).join() {\n        result::Result::Err(_) => (),\n        result::Result::Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_spawn_sched() {\n    let (tx, rx) = channel();\n\n    fn f(i: i32, tx: Sender<()>) {\n        let tx = tx.clone();\n        thread::spawn(move || {\n            if i == 0 {\n                tx.send(()).unwrap();\n            } else {\n                f(i - 1, tx);\n            }\n        });\n    }\n    f(10, tx);\n    rx.recv().unwrap();\n}\n\n#[test]\nfn test_spawn_sched_childs_on_default_sched() {\n    let (tx, rx) = channel();\n\n    thread::spawn(move || {\n        thread::spawn(move || {\n            tx.send(()).unwrap();\n        });\n    });\n\n    rx.recv().unwrap();\n}\n\nfn avoid_copying_the_body<F>(spawnfn: F)\nwhere\n    F: FnOnce(Box<dyn Fn() + Send>),\n{\n    let (tx, rx) = channel();\n\n    let x: Box<_> = box 1;\n    let x_in_parent = (&*x) as *const i32 as usize;\n\n    spawnfn(Box::new(move || {\n        let x_in_child = (&*x) as *const i32 as usize;\n        tx.send(x_in_child).unwrap();\n    }));\n\n    let x_in_child = rx.recv().unwrap();\n    assert_eq!(x_in_parent, x_in_child);\n}\n\n#[test]\nfn test_avoid_copying_the_body_spawn() {\n    avoid_copying_the_body(|v| {\n        thread::spawn(move || v());\n    });\n}\n\n#[test]\nfn test_avoid_copying_the_body_thread_spawn() {\n    avoid_copying_the_body(|f| {\n        thread::spawn(move || {\n            f();\n        });\n    })\n}\n\n#[test]\nfn test_avoid_copying_the_body_join() {\n    avoid_copying_the_body(|f| {\n        let _ = thread::spawn(move || f()).join();\n    })\n}\n\n#[test]\nfn test_child_doesnt_ref_parent() {\n    // If the child refcounts the parent thread, this will stack overflow when\n    // climbing the thread tree to dereference each ancestor. (See #1789)\n    // (well, it would if the constant were 8000+ - I lowered it to be more\n    // valgrind-friendly. try this at home, instead..!)\n    const GENERATIONS: u32 = 16;\n    fn child_no(x: u32) -> Box<dyn Fn() + Send> {\n        return Box::new(move || {\n            if x < GENERATIONS {\n                thread::spawn(move || child_no(x + 1)());\n            }\n        });\n    }\n    thread::spawn(|| child_no(0)());\n}\n\n#[test]\nfn test_simple_newsched_spawn() {\n    thread::spawn(move || {});\n}\n\n#[test]\nfn test_try_panic_message_static_str() {\n    match thread::spawn(move || {\n        panic!(\"static string\");\n    })\n    .join()\n    {\n        Err(e) => {\n            type T = &'static str;\n            assert!(e.is::<T>());\n            assert_eq!(*e.downcast::<T>().unwrap(), \"static string\");\n        }\n        Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_try_panic_message_owned_str() {\n    match thread::spawn(move || {\n        panic!(\"owned string\".to_string());\n    })\n    .join()\n    {\n        Err(e) => {\n            type T = String;\n            assert!(e.is::<T>());\n            assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\".to_string());\n        }\n        Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_try_panic_message_any() {\n    match thread::spawn(move || {\n        panic!(box 413u16 as Box<dyn Any + Send>);\n    })\n    .join()\n    {\n        Err(e) => {\n            type T = Box<dyn Any + Send>;\n            assert!(e.is::<T>());\n            let any = e.downcast::<T>().unwrap();\n            assert!(any.is::<u16>());\n            assert_eq!(*any.downcast::<u16>().unwrap(), 413);\n        }\n        Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_try_panic_message_unit_struct() {\n    struct Juju;\n\n    match thread::spawn(move || panic!(Juju)).join() {\n        Err(ref e) if e.is::<Juju>() => {}\n        Err(_) | Ok(()) => panic!(),\n    }\n}\n\n#[test]\nfn test_park_timeout_unpark_before() {\n    for _ in 0..10 {\n        thread::current().unpark();\n        thread::park_timeout(Duration::from_millis(u32::MAX as u64));\n    }\n}\n\n#[test]\nfn test_park_timeout_unpark_not_called() {\n    for _ in 0..10 {\n        thread::park_timeout(Duration::from_millis(10));\n    }\n}\n\n#[test]\nfn test_park_timeout_unpark_called_other_thread() {\n    for _ in 0..10 {\n        let th = thread::current();\n\n        let _guard = thread::spawn(move || {\n            super::sleep(Duration::from_millis(50));\n            th.unpark();\n        });\n\n        thread::park_timeout(Duration::from_millis(u32::MAX as u64));\n    }\n}\n\n#[test]\nfn sleep_ms_smoke() {\n    thread::sleep(Duration::from_millis(2));\n}\n\n#[test]\nfn test_size_of_option_thread_id() {\n    assert_eq!(mem::size_of::<Option<ThreadId>>(), mem::size_of::<ThreadId>());\n}\n\n#[test]\nfn test_thread_id_equal() {\n    assert!(thread::current().id() == thread::current().id());\n}\n\n#[test]\nfn test_thread_id_not_equal() {\n    let spawned_id = thread::spawn(|| thread::current().id()).join().unwrap();\n    assert!(thread::current().id() != spawned_id);\n}\n\n// NOTE: the corresponding test for stderr is in ui/thread-stderr, due\n// to the test harness apparently interfering with stderr configuration.\n"],["2565","use crate::io;\nuse crate::num::NonZeroUsize;\n\n/// Returns the number of hardware threads available to the program.\n///\n/// This value should be considered only a hint.\n///\n/// # Platform-specific behavior\n///\n/// If interpreted as the number of actual hardware threads, it may undercount on\n/// Windows systems with more than 64 hardware threads. If interpreted as the\n/// available concurrency for that process, it may overcount on Windows systems\n/// when limited by a process wide affinity mask or job object limitations, and\n/// it may overcount on Linux systems when limited by a process wide affinity\n/// mask or affected by cgroups limits.\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// - If the number of hardware threads is not known for the target platform.\n/// - The process lacks permissions to view the number of hardware threads\n///   available.\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(dead_code)]\n/// #![feature(available_concurrency)]\n/// use std::thread;\n///\n/// let count = thread::available_concurrency().map(|n| n.get()).unwrap_or(1);\n/// ```\n#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\npub fn available_concurrency() -> io::Result<NonZeroUsize> {\n    available_concurrency_internal()\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(windows)] {\n        #[allow(nonstandard_style)]\n        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n            #[repr(C)]\n            struct SYSTEM_INFO {\n                wProcessorArchitecture: u16,\n                wReserved: u16,\n                dwPageSize: u32,\n                lpMinimumApplicationAddress: *mut u8,\n                lpMaximumApplicationAddress: *mut u8,\n                dwActiveProcessorMask: *mut u8,\n                dwNumberOfProcessors: u32,\n                dwProcessorType: u32,\n                dwAllocationGranularity: u32,\n                wProcessorLevel: u16,\n                wProcessorRevision: u16,\n            }\n            extern \"system\" {\n                fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n            }\n            let res = unsafe {\n                let mut sysinfo = crate::mem::zeroed();\n                GetSystemInfo(&mut sysinfo);\n                sysinfo.dwNumberOfProcessors as usize\n            };\n            match res {\n                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus) }),\n            }\n        }\n    } else if #[cfg(any(\n        target_os = \"android\",\n        target_os = \"emscripten\",\n        target_os = \"fuchsia\",\n        target_os = \"ios\",\n        target_os = \"linux\",\n        target_os = \"macos\",\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n    ))] {\n        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n            match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n                -1 => Err(io::Error::last_os_error()),\n                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) }),\n            }\n        }\n    } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n            use crate::ptr;\n\n            let mut cpus: libc::c_uint = 0;\n            let mut cpus_size = crate::mem::size_of_val(&cpus);\n\n            unsafe {\n                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n            }\n\n            // Fallback approach in case of errors or no hardware threads.\n            if cpus < 1 {\n                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n                let res = unsafe {\n                    libc::sysctl(\n                        mib.as_mut_ptr(),\n                        2,\n                        &mut cpus as *mut _ as *mut _,\n                        &mut cpus_size as *mut _ as *mut _,\n                        ptr::null_mut(),\n                        0,\n                    )\n                };\n\n                // Handle errors if any.\n                if res == -1 {\n                    return Err(io::Error::last_os_error());\n                } else if cpus == 0 {\n                    return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n                }\n            }\n            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n        }\n    } else if #[cfg(target_os = \"openbsd\")] {\n        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n            use crate::ptr;\n\n            let mut cpus: libc::c_uint = 0;\n            let mut cpus_size = crate::mem::size_of_val(&cpus);\n            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n\n            let res = unsafe {\n                libc::sysctl(\n                    mib.as_mut_ptr(),\n                    2,\n                    &mut cpus as *mut _ as *mut _,\n                    &mut cpus_size as *mut _ as *mut _,\n                    ptr::null_mut(),\n                    0,\n                )\n            };\n\n            // Handle errors if any.\n            if res == -1 {\n                return Err(io::Error::last_os_error());\n            } else if cpus == 0 {\n                return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n            }\n\n            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n        }\n    } else {\n        // FIXME: implement on vxWorks, Redox, HermitCore, Haiku, l4re\n        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n            Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"))\n        }\n    }\n}\n"],["2566","//! Thread local storage\n\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests;\n\n#[cfg(test)]\nmod dynamic_tests;\n\nuse crate::error::Error;\nuse crate::fmt;\n\n/// A thread local storage key which owns its contents.\n///\n/// This key uses the fastest possible implementation available to it for the\n/// target platform. It is instantiated with the [`thread_local!`] macro and the\n/// primary method is the [`with`] method.\n///\n/// The [`with`] method yields a reference to the contained value which cannot be\n/// sent across threads or escape the given closure.\n///\n/// # Initialization and Destruction\n///\n/// Initialization is dynamically performed on the first call to [`with`]\n/// within a thread, and values that implement [`Drop`] get destructed when a\n/// thread exits. Some caveats apply, which are explained below.\n///\n/// A `LocalKey`'s initializer cannot recursively depend on itself, and using\n/// a `LocalKey` in this way will cause the initializer to infinitely recurse\n/// on the first call to `with`.\n///\n/// # Examples\n///\n/// ```\n/// use std::cell::RefCell;\n/// use std::thread;\n///\n/// thread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n///\n/// FOO.with(|f| {\n///     assert_eq!(*f.borrow(), 1);\n///     *f.borrow_mut() = 2;\n/// });\n///\n/// // each thread starts out with the initial value of 1\n/// let t = thread::spawn(move|| {\n///     FOO.with(|f| {\n///         assert_eq!(*f.borrow(), 1);\n///         *f.borrow_mut() = 3;\n///     });\n/// });\n///\n/// // wait for the thread to complete and bail out on panic\n/// t.join().unwrap();\n///\n/// // we retain our original value of 2 despite the child thread\n/// FOO.with(|f| {\n///     assert_eq!(*f.borrow(), 2);\n/// });\n/// ```\n///\n/// # Platform-specific behavior\n///\n/// Note that a \"best effort\" is made to ensure that destructors for types\n/// stored in thread local storage are run, but not all platforms can guarantee\n/// that destructors will be run for all types in thread local storage. For\n/// example, there are a number of known caveats where destructors are not run:\n///\n/// 1. On Unix systems when pthread-based TLS is being used, destructors will\n///    not be run for TLS values on the main thread when it exits. Note that the\n///    application will exit immediately after the main thread exits as well.\n/// 2. On all platforms it's possible for TLS to re-initialize other TLS slots\n///    during destruction. Some platforms ensure that this cannot happen\n///    infinitely by preventing re-initialization of any slot that has been\n///    destroyed, but not all platforms have this guard. Those platforms that do\n///    not guard typically have a synthetic limit after which point no more\n///    destructors are run.\n///\n/// [`with`]: LocalKey::with\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LocalKey<T: 'static> {\n    // This outer `LocalKey<T>` type is what's going to be stored in statics,\n    // but actual data inside will sometimes be tagged with #[thread_local].\n    // It's not valid for a true static to reference a #[thread_local] static,\n    // so we get around that by exposing an accessor through a layer of function\n    // indirection (this thunk).\n    //\n    // Note that the thunk is itself unsafe because the returned lifetime of the\n    // slot where data lives, `'static`, is not actually valid. The lifetime\n    // here is actually slightly shorter than the currently running thread!\n    //\n    // Although this is an extra layer of indirection, it should in theory be\n    // trivially devirtualizable by LLVM because the value of `inner` never\n    // changes and the constant should be readonly within a crate. This mainly\n    // only runs into problems when TLS statics are exported across crates.\n    inner: unsafe fn() -> Option<&'static T>,\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: 'static> fmt::Debug for LocalKey<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"LocalKey\").finish_non_exhaustive()\n    }\n}\n\n/// Declare a new thread local storage key of type [`std::thread::LocalKey`].\n///\n/// # Syntax\n///\n/// The macro wraps any number of static declarations and makes them thread local.\n/// Publicity and attributes for each static are allowed. Example:\n///\n/// ```\n/// use std::cell::RefCell;\n/// thread_local! {\n///     pub static FOO: RefCell<u32> = RefCell::new(1);\n///\n///     #[allow(unused)]\n///     static BAR: RefCell<f32> = RefCell::new(1.0);\n/// }\n/// # fn main() {}\n/// ```\n///\n/// See [`LocalKey` documentation][`std::thread::LocalKey`] for more\n/// information.\n///\n/// [`std::thread::LocalKey`]: crate::thread::LocalKey\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(thread_local_internals)]\nmacro_rules! thread_local {\n    // empty (base case for the recursion)\n    () => {};\n\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }; $($rest:tt)*) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n        $crate::thread_local!($($rest)*);\n    );\n\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = const { $init:expr }) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, const $init);\n    );\n\n    // process multiple declarations\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n        $crate::thread_local!($($rest)*);\n    );\n\n    // handle a single declaration\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n    );\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n#[macro_export]\n#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n#[allow_internal_unsafe]\nmacro_rules! __thread_local_inner {\n    // used to generate the `LocalKey` value for const-initialized thread locals\n    (@key $t:ty, const $init:expr) => {{\n        #[cfg_attr(not(windows), inline)] // see comments below\n        unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n            const _REQUIRE_UNSTABLE: () = $crate::thread::require_unstable_const_init_thread_local();\n\n            // wasm without atomics maps directly to `static mut`, and dtors\n            // aren't implemented because thread dtors aren't really a thing\n            // on wasm right now\n            //\n            // FIXME(#84224) this should come after the `target_thread_local`\n            // block.\n            #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n            {\n                static mut VAL: $t = $init;\n                Some(&VAL)\n            }\n\n            // If the platform has support for `#[thread_local]`, use it.\n            #[cfg(all(\n                target_thread_local,\n                not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n            ))]\n            {\n                // If a dtor isn't needed we can do something \"very raw\" and\n                // just get going.\n                if !$crate::mem::needs_drop::<$t>() {\n                    #[thread_local]\n                    static mut VAL: $t = $init;\n                    unsafe {\n                        return Some(&VAL)\n                    }\n                }\n\n                #[thread_local]\n                static mut VAL: $t = $init;\n                // 0 == dtor not registered\n                // 1 == dtor registered, dtor not run\n                // 2 == dtor registered and is running or has run\n                #[thread_local]\n                static mut STATE: u8 = 0;\n\n                unsafe extern \"C\" fn destroy(ptr: *mut u8) {\n                    let ptr = ptr as *mut $t;\n\n                    unsafe {\n                        debug_assert_eq!(STATE, 1);\n                        STATE = 2;\n                        $crate::ptr::drop_in_place(ptr);\n                    }\n                }\n\n                unsafe {\n                    match STATE {\n                        // 0 == we haven't registered a destructor, so do\n                        //   so now.\n                        0 => {\n                            $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n                                $crate::ptr::addr_of_mut!(VAL) as *mut u8,\n                                destroy,\n                            );\n                            STATE = 1;\n                            Some(&VAL)\n                        }\n                        // 1 == the destructor is registered and the value\n                        //   is valid, so return the pointer.\n                        1 => Some(&VAL),\n                        // otherwise the destructor has already run, so we\n                        // can't give access.\n                        _ => None,\n                    }\n                }\n            }\n\n            // On platforms without `#[thread_local]` we fall back to the\n            // same implementation as below for os thread locals.\n            #[cfg(all(\n                not(target_thread_local),\n                not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n            ))]\n            {\n                #[inline]\n                const fn __init() -> $t { $init }\n                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                    $crate::thread::__OsLocalKeyInner::new();\n                #[allow(unused_unsafe)]\n                unsafe { __KEY.get(__init) }\n            }\n        }\n\n        unsafe {\n            $crate::thread::LocalKey::new(__getit)\n        }\n    }};\n\n    // used to generate the `LocalKey` value for `thread_local!`\n    (@key $t:ty, $init:expr) => {\n        {\n            #[inline]\n            fn __init() -> $t { $init }\n\n            // When reading this function you might ask \"why is this inlined\n            // everywhere other than Windows?\", and that's a very reasonable\n            // question to ask. The short story is that it segfaults rustc if\n            // this function is inlined. The longer story is that Windows looks\n            // to not support `extern` references to thread locals across DLL\n            // boundaries. This appears to at least not be supported in the ABI\n            // that LLVM implements.\n            //\n            // Because of this we never inline on Windows, but we do inline on\n            // other platforms (where external references to thread locals\n            // across DLLs are supported). A better fix for this would be to\n            // inline this function on Windows, but only for \"statically linked\"\n            // components. For example if two separately compiled rlibs end up\n            // getting linked into a DLL then it's fine to inline this function\n            // across that boundary. It's only not fine to inline this function\n            // across a DLL boundary. Unfortunately rustc doesn't currently\n            // have this sort of logic available in an attribute, and it's not\n            // clear that rustc is even equipped to answer this (it's more of a\n            // Cargo question kinda). This means that, unfortunately, Windows\n            // gets the pessimistic path for now where it's never inlined.\n            //\n            // The issue of \"should enable on Windows sometimes\" is #84933\n            #[cfg_attr(not(windows), inline)]\n            unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n                #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                    $crate::thread::__StaticLocalKeyInner::new();\n\n                #[thread_local]\n                #[cfg(all(\n                    target_thread_local,\n                    not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                    $crate::thread::__FastLocalKeyInner::new();\n\n                #[cfg(all(\n                    not(target_thread_local),\n                    not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                    $crate::thread::__OsLocalKeyInner::new();\n\n                // FIXME: remove the #[allow(...)] marker when macros don't\n                // raise warning for missing/extraneous unsafe blocks anymore.\n                // See https://github.com/rust-lang/rust/issues/74838.\n                #[allow(unused_unsafe)]\n                unsafe { __KEY.get(__init) }\n            }\n\n            unsafe {\n                $crate::thread::LocalKey::new(__getit)\n            }\n        }\n    };\n    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n            $crate::__thread_local_inner!(@key $t, $($init)*);\n    }\n}\n\n/// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n#[derive(Clone, Copy, Eq, PartialEq)]\npub struct AccessError {\n    _private: (),\n}\n\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\nimpl fmt::Debug for AccessError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"AccessError\").finish()\n    }\n}\n\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\nimpl fmt::Display for AccessError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(\"already destroyed\", f)\n    }\n}\n\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\nimpl Error for AccessError {}\n\nimpl<T: 'static> LocalKey<T> {\n    #[doc(hidden)]\n    #[unstable(\n        feature = \"thread_local_internals\",\n        reason = \"recently added to create a key\",\n        issue = \"none\"\n    )]\n    #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static T>) -> LocalKey<T> {\n        LocalKey { inner }\n    }\n\n    /// Acquires a reference to the value in this TLS key.\n    ///\n    /// This will lazily initialize the value if this thread has not referenced\n    /// this key yet.\n    ///\n    /// # Panics\n    ///\n    /// This function will `panic!()` if the key currently has its\n    /// destructor running, and it **may** panic if the destructor has\n    /// previously been run for this thread.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with<F, R>(&'static self, f: F) -> R\n    where\n        F: FnOnce(&T) -> R,\n    {\n        self.try_with(f).expect(\n            \"cannot access a Thread Local Storage value \\\n             during or after destruction\",\n        )\n    }\n\n    /// Acquires a reference to the value in this TLS key.\n    ///\n    /// This will lazily initialize the value if this thread has not referenced\n    /// this key yet. If the key has been destroyed (which may happen if this is called\n    /// in a destructor), this function will return an [`AccessError`].\n    ///\n    /// # Panics\n    ///\n    /// This function will still `panic!()` if the key is uninitialized and the\n    /// key's initializer panics.\n    #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n    #[inline]\n    pub fn try_with<F, R>(&'static self, f: F) -> Result<R, AccessError>\n    where\n        F: FnOnce(&T) -> R,\n    {\n        unsafe {\n            let thread_local = (self.inner)().ok_or(AccessError { _private: () })?;\n            Ok(f(thread_local))\n        }\n    }\n}\n\nmod lazy {\n    use crate::cell::UnsafeCell;\n    use crate::hint;\n    use crate::mem;\n\n    pub struct LazyKeyInner<T> {\n        inner: UnsafeCell<Option<T>>,\n    }\n\n    impl<T> LazyKeyInner<T> {\n        pub const fn new() -> LazyKeyInner<T> {\n            LazyKeyInner { inner: UnsafeCell::new(None) }\n        }\n\n        pub unsafe fn get(&self) -> Option<&'static T> {\n            // SAFETY: The caller must ensure no reference is ever handed out to\n            // the inner cell nor mutable reference to the Option<T> inside said\n            // cell. This make it safe to hand a reference, though the lifetime\n            // of 'static is itself unsafe, making the get method unsafe.\n            unsafe { (*self.inner.get()).as_ref() }\n        }\n\n        /// The caller must ensure that no reference is active: this method\n        /// needs unique access.\n        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n            // Execute the initialization up front, *then* move it into our slot,\n            // just in case initialization fails.\n            let value = init();\n            let ptr = self.inner.get();\n\n            // SAFETY:\n            //\n            // note that this can in theory just be `*ptr = Some(value)`, but due to\n            // the compiler will currently codegen that pattern with something like:\n            //\n            //      ptr::drop_in_place(ptr)\n            //      ptr::write(ptr, Some(value))\n            //\n            // Due to this pattern it's possible for the destructor of the value in\n            // `ptr` (e.g., if this is being recursively initialized) to re-access\n            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n            // value (an aliasing violation). To avoid setting the \"I'm running a\n            // destructor\" flag we just use `mem::replace` which should sequence the\n            // operations a little differently and make this safe to call.\n            //\n            // The precondition also ensures that we are the only one accessing\n            // `self` at the moment so replacing is fine.\n            unsafe {\n                let _ = mem::replace(&mut *ptr, Some(value));\n            }\n\n            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n            // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n            // will never be reached.\n            unsafe {\n                // After storing `Some` we want to get a reference to the contents of\n                // what we just stored. While we could use `unwrap` here and it should\n                // always work it empirically doesn't seem to always get optimized away,\n                // which means that using something like `try_with` can pull in\n                // panicking code and cause a large size bloat.\n                match *ptr {\n                    Some(ref x) => x,\n                    None => hint::unreachable_unchecked(),\n                }\n            }\n        }\n\n        /// The other methods hand out references while taking &self.\n        /// As such, callers of this method must ensure no `&` and `&mut` are\n        /// available and used at the same time.\n        #[allow(unused)]\n        pub unsafe fn take(&mut self) -> Option<T> {\n            // SAFETY: See doc comment for this method.\n            unsafe { (*self.inner.get()).take() }\n        }\n    }\n}\n\n/// On some platforms like wasm32 there's no threads, so no need to generate\n/// thread locals and we can instead just use plain statics!\n#[doc(hidden)]\n#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\npub mod statik {\n    use super::lazy::LazyKeyInner;\n    use crate::fmt;\n\n    pub struct Key<T> {\n        inner: LazyKeyInner<T>,\n    }\n\n    unsafe impl<T> Sync for Key<T> {}\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"Key\").finish_non_exhaustive()\n        }\n    }\n\n    impl<T> Key<T> {\n        pub const fn new() -> Key<T> {\n            Key { inner: LazyKeyInner::new() }\n        }\n\n        pub unsafe fn get(&self, init: fn() -> T) -> Option<&'static T> {\n            // SAFETY: The caller must ensure no reference is ever handed out to\n            // the inner cell nor mutable reference to the Option<T> inside said\n            // cell. This make it safe to hand a reference, though the lifetime\n            // of 'static is itself unsafe, making the get method unsafe.\n            let value = unsafe {\n                match self.inner.get() {\n                    Some(ref value) => value,\n                    None => self.inner.initialize(init),\n                }\n            };\n\n            Some(value)\n        }\n    }\n}\n\n#[doc(hidden)]\n#[cfg(target_thread_local)]\npub mod fast {\n    use super::lazy::LazyKeyInner;\n    use crate::cell::Cell;\n    use crate::fmt;\n    use crate::mem;\n    use crate::sys::thread_local_dtor::register_dtor;\n\n    #[derive(Copy, Clone)]\n    enum DtorState {\n        Unregistered,\n        Registered,\n        RunningOrHasRun,\n    }\n\n    // This data structure has been carefully constructed so that the fast path\n    // only contains one branch on x86. That optimization is necessary to avoid\n    // duplicated tls lookups on OSX.\n    //\n    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n    pub struct Key<T> {\n        // If `LazyKeyInner::get` returns `None`, that indicates either:\n        //   * The value has never been initialized\n        //   * The value is being recursively initialized\n        //   * The value has already been destroyed or is being destroyed\n        // To determine which kind of `None`, check `dtor_state`.\n        //\n        // This is very optimizer friendly for the fast path - initialized but\n        // not yet dropped.\n        inner: LazyKeyInner<T>,\n\n        // Metadata to keep track of the state of the destructor. Remember that\n        // this variable is thread-local, not global.\n        dtor_state: Cell<DtorState>,\n    }\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"Key\").finish_non_exhaustive()\n        }\n    }\n\n    impl<T> Key<T> {\n        pub const fn new() -> Key<T> {\n            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n        }\n\n        // note that this is just a publically-callable function only for the\n        // const-initialized form of thread locals, basically a way to call the\n        // free `register_dtor` function defined elsewhere in libstd.\n        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n            unsafe {\n                register_dtor(a, dtor);\n            }\n        }\n\n        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n            // SAFETY: See the definitions of `LazyKeyInner::get` and\n            // `try_initialize` for more informations.\n            //\n            // The caller must ensure no mutable references are ever active to\n            // the inner cell or the inner T when this is called.\n            // The `try_initialize` is dependant on the passed `init` function\n            // for this.\n            unsafe {\n                match self.inner.get() {\n                    Some(val) => Some(val),\n                    None => self.try_initialize(init),\n                }\n            }\n        }\n\n        // `try_initialize` is only called once per fast thread local variable,\n        // except in corner cases where thread_local dtors reference other\n        // thread_local's, or it is being recursively initialized.\n        //\n        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n        // be performed for every call to `Key::get`.\n        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n        #[inline(never)]\n        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n            // SAFETY: See comment above (this function doc).\n            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n                // SAFETY: See comment above (his function doc).\n                Some(unsafe { self.inner.initialize(init) })\n            } else {\n                None\n            }\n        }\n\n        // `try_register_dtor` is only called once per fast thread local\n        // variable, except in corner cases where thread_local dtors reference\n        // other thread_local's, or it is being recursively initialized.\n        unsafe fn try_register_dtor(&self) -> bool {\n            match self.dtor_state.get() {\n                DtorState::Unregistered => {\n                    // SAFETY: dtor registration happens before initialization.\n                    // Passing `self` as a pointer while using `destroy_value<T>`\n                    // is safe because the function will build a pointer to a\n                    // Key<T>, which is the type of self and so find the correct\n                    // size.\n                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n                    self.dtor_state.set(DtorState::Registered);\n                    true\n                }\n                DtorState::Registered => {\n                    // recursively initialized\n                    true\n                }\n                DtorState::RunningOrHasRun => false,\n            }\n        }\n    }\n\n    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n        let ptr = ptr as *mut Key<T>;\n\n        // SAFETY:\n        //\n        // The pointer `ptr` has been built just above and comes from\n        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n        // making it non-NUL and of the correct type.\n        //\n        // Right before we run the user destructor be sure to set the\n        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n        // causes future calls to `get` to run `try_initialize_drop` again,\n        // which will now fail, and return `None`.\n        unsafe {\n            let value = (*ptr).inner.take();\n            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n            drop(value);\n        }\n    }\n}\n\n#[doc(hidden)]\npub mod os {\n    use super::lazy::LazyKeyInner;\n    use crate::cell::Cell;\n    use crate::fmt;\n    use crate::marker;\n    use crate::ptr;\n    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n\n    pub struct Key<T> {\n        // OS-TLS key that we'll use to key off.\n        os: OsStaticKey,\n        marker: marker::PhantomData<Cell<T>>,\n    }\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.debug_struct(\"Key\").finish_non_exhaustive()\n        }\n    }\n\n    unsafe impl<T> Sync for Key<T> {}\n\n    struct Value<T: 'static> {\n        inner: LazyKeyInner<T>,\n        key: &'static Key<T>,\n    }\n\n    impl<T: 'static> Key<T> {\n        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n        pub const fn new() -> Key<T> {\n            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n        }\n\n        /// It is a requirement for the caller to ensure that no mutable\n        /// reference is active when this method is called.\n        pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n            // SAFETY: See the documentation for this method.\n            let ptr = unsafe { self.os.get() as *mut Value<T> };\n            if ptr as usize > 1 {\n                // SAFETY: the check ensured the pointer is safe (its destructor\n                // is not running) + it is coming from a trusted source (self).\n                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n                    return Some(value);\n                }\n            }\n            // SAFETY: At this point we are sure we have no value and so\n            // initializing (or trying to) is safe.\n            unsafe { self.try_initialize(init) }\n        }\n\n        // `try_initialize` is only called once per os thread local variable,\n        // except in corner cases where thread_local dtors reference other\n        // thread_local's, or it is being recursively initialized.\n        unsafe fn try_initialize(&'static self, init: fn() -> T) -> Option<&'static T> {\n            // SAFETY: No mutable references are ever handed out meaning getting\n            // the value is ok.\n            let ptr = unsafe { self.os.get() as *mut Value<T> };\n            if ptr as usize == 1 {\n                // destructor is running\n                return None;\n            }\n\n            let ptr = if ptr.is_null() {\n                // If the lookup returned null, we haven't initialized our own\n                // local copy, so do that now.\n                let ptr: Box<Value<T>> = box Value { inner: LazyKeyInner::new(), key: self };\n                let ptr = Box::into_raw(ptr);\n                // SAFETY: At this point we are sure there is no value inside\n                // ptr so setting it will not affect anyone else.\n                unsafe {\n                    self.os.set(ptr as *mut u8);\n                }\n                ptr\n            } else {\n                // recursive initialization\n                ptr\n            };\n\n            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n            // dereferenced safely.\n            unsafe { Some((*ptr).inner.initialize(init)) }\n        }\n    }\n\n    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n        // SAFETY:\n        //\n        // The OS TLS ensures that this key contains a null value when this\n        // destructor starts to run. We set it back to a sentinel value of 1 to\n        // ensure that any future calls to `get` for this thread will return\n        // `None`.\n        //\n        // Note that to prevent an infinite loop we reset it back to null right\n        // before we return from the destructor ourselves.\n        unsafe {\n            let ptr = Box::from_raw(ptr as *mut Value<T>);\n            let key = ptr.key;\n            key.os.set(1 as *mut u8);\n            drop(ptr);\n            key.os.set(ptr::null_mut());\n        }\n    }\n}\n"],["2567","//! Memory allocation APIs.\n//!\n//! In a given program, the standard library has one global memory allocator\n//! that is used for example by `Box<T>` and `Vec<T>`.\n//!\n//! Currently the default global allocator is unspecified. Libraries, however,\n//! like `cdylib`s and `staticlib`s are guaranteed to use the [`System`] by\n//! default.\n//!\n//! # The `#[global_allocator]` attribute\n//!\n//! This attribute allows configuring the choice of global allocator.\n//! You can use this to implement a completely custom global allocator\n//! to route all default allocation requests to a custom object.\n//!\n//! ```rust\n//! use std::alloc::{GlobalAlloc, System, Layout};\n//!\n//! struct MyAllocator;\n//!\n//! unsafe impl GlobalAlloc for MyAllocator {\n//!     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n//!         System.alloc(layout)\n//!     }\n//!\n//!     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n//!         System.dealloc(ptr, layout)\n//!     }\n//! }\n//!\n//! #[global_allocator]\n//! static GLOBAL: MyAllocator = MyAllocator;\n//!\n//! fn main() {\n//!     // This `Vec` will allocate memory through `GLOBAL` above\n//!     let mut v = Vec::new();\n//!     v.push(1);\n//! }\n//! ```\n//!\n//! The attribute is used on a `static` item whose type implements the\n//! [`GlobalAlloc`] trait. This type can be provided by an external library:\n//!\n//! ```rust,ignore (demonstrates crates.io usage)\n//! extern crate jemallocator;\n//!\n//! use jemallocator::Jemalloc;\n//!\n//! #[global_allocator]\n//! static GLOBAL: Jemalloc = Jemalloc;\n//!\n//! fn main() {}\n//! ```\n//!\n//! The `#[global_allocator]` can only be used once in a crate\n//! or its recursive dependencies.\n\n#![deny(unsafe_op_in_unsafe_fn)]\n#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n\nuse core::intrinsics;\nuse core::ptr::NonNull;\nuse core::sync::atomic::{AtomicPtr, Ordering};\nuse core::{mem, ptr};\n\n#[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n#[doc(inline)]\npub use alloc_crate::alloc::*;\n\n/// The default memory allocator provided by the operating system.\n///\n/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n/// plus related functions.\n///\n/// This type implements the `GlobalAlloc` trait and Rust programs by default\n/// work as if they had this definition:\n///\n/// ```rust\n/// use std::alloc::System;\n///\n/// #[global_allocator]\n/// static A: System = System;\n///\n/// fn main() {\n///     let a = Box::new(4); // Allocates from the system allocator.\n///     println!(\"{}\", a);\n/// }\n/// ```\n///\n/// You can also define your own wrapper around `System` if you'd like, such as\n/// keeping track of the number of all bytes allocated:\n///\n/// ```rust\n/// use std::alloc::{System, GlobalAlloc, Layout};\n/// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n///\n/// struct Counter;\n///\n/// static ALLOCATED: AtomicUsize = AtomicUsize::new(0);\n///\n/// unsafe impl GlobalAlloc for Counter {\n///     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n///         let ret = System.alloc(layout);\n///         if !ret.is_null() {\n///             ALLOCATED.fetch_add(layout.size(), SeqCst);\n///         }\n///         return ret\n///     }\n///\n///     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n///         System.dealloc(ptr, layout);\n///         ALLOCATED.fetch_sub(layout.size(), SeqCst);\n///     }\n/// }\n///\n/// #[global_allocator]\n/// static A: Counter = Counter;\n///\n/// fn main() {\n///     println!(\"allocated bytes before main: {}\", ALLOCATED.load(SeqCst));\n/// }\n/// ```\n///\n/// It can also be used directly to allocate memory independently of whatever\n/// global allocator has been selected for a Rust program. For example if a Rust\n/// program opts in to using jemalloc as the global allocator, `System` will\n/// still allocate memory using `malloc` and `HeapAlloc`.\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n#[derive(Debug, Default, Copy, Clone)]\npub struct System;\n\nimpl System {\n    #[inline]\n    fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {\n        match layout.size() {\n            0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n            // SAFETY: `layout` is non-zero in size,\n            size => unsafe {\n                let raw_ptr = if zeroed {\n                    GlobalAlloc::alloc_zeroed(self, layout)\n                } else {\n                    GlobalAlloc::alloc(self, layout)\n                };\n                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                Ok(NonNull::slice_from_raw_parts(ptr, size))\n            },\n        }\n    }\n\n    // SAFETY: Same as `Allocator::grow`\n    #[inline]\n    unsafe fn grow_impl(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n        zeroed: bool,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        debug_assert!(\n            new_layout.size() >= old_layout.size(),\n            \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n        );\n\n        match old_layout.size() {\n            0 => self.alloc_impl(new_layout, zeroed),\n\n            // SAFETY: `new_size` is non-zero as `new_size` is greater than or equal to `old_size`\n            // as required by safety conditions and the `old_size == 0` case was handled in the\n            // previous match arm. Other conditions must be upheld by the caller\n            old_size if old_layout.align() == new_layout.align() => unsafe {\n                let new_size = new_layout.size();\n\n                // `realloc` probably checks for `new_size >= old_layout.size()` or something similar.\n                intrinsics::assume(new_size >= old_layout.size());\n\n                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);\n                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                if zeroed {\n                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n                }\n                Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n            },\n\n            // SAFETY: because `new_layout.size()` must be greater than or equal to `old_size`,\n            // both the old and new memory allocation are valid for reads and writes for `old_size`\n            // bytes. Also, because the old allocation wasn't yet deallocated, it cannot overlap\n            // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n            // for `dealloc` must be upheld by the caller.\n            old_size => unsafe {\n                let new_ptr = self.alloc_impl(new_layout, zeroed)?;\n                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_size);\n                Allocator::deallocate(&self, ptr, old_layout);\n                Ok(new_ptr)\n            },\n        }\n    }\n}\n\n// The Allocator impl checks the layout size to be non-zero and forwards to the GlobalAlloc impl,\n// which is in `std::sys::*::alloc`.\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\nunsafe impl Allocator for System {\n    #[inline]\n    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n        self.alloc_impl(layout, false)\n    }\n\n    #[inline]\n    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n        self.alloc_impl(layout, true)\n    }\n\n    #[inline]\n    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n        if layout.size() != 0 {\n            // SAFETY: `layout` is non-zero in size,\n            // other conditions must be upheld by the caller\n            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }\n        }\n    }\n\n    #[inline]\n    unsafe fn grow(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        // SAFETY: all conditions must be upheld by the caller\n        unsafe { self.grow_impl(ptr, old_layout, new_layout, false) }\n    }\n\n    #[inline]\n    unsafe fn grow_zeroed(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        // SAFETY: all conditions must be upheld by the caller\n        unsafe { self.grow_impl(ptr, old_layout, new_layout, true) }\n    }\n\n    #[inline]\n    unsafe fn shrink(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        debug_assert!(\n            new_layout.size() <= old_layout.size(),\n            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n        );\n\n        match new_layout.size() {\n            // SAFETY: conditions must be upheld by the caller\n            0 => unsafe {\n                Allocator::deallocate(&self, ptr, old_layout);\n                Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))\n            },\n\n            // SAFETY: `new_size` is non-zero. Other conditions must be upheld by the caller\n            new_size if old_layout.align() == new_layout.align() => unsafe {\n                // `realloc` probably checks for `new_size <= old_layout.size()` or something similar.\n                intrinsics::assume(new_size <= old_layout.size());\n\n                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);\n                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n            },\n\n            // SAFETY: because `new_size` must be smaller than or equal to `old_layout.size()`,\n            // both the old and new memory allocation are valid for reads and writes for `new_size`\n            // bytes. Also, because the old allocation wasn't yet deallocated, it cannot overlap\n            // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n            // for `dealloc` must be upheld by the caller.\n            new_size => unsafe {\n                let new_ptr = Allocator::allocate(&self, new_layout)?;\n                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);\n                Allocator::deallocate(&self, ptr, old_layout);\n                Ok(new_ptr)\n            },\n        }\n    }\n}\n\nstatic HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n\n/// Registers a custom allocation error hook, replacing any that was previously registered.\n///\n/// The allocation error hook is invoked when an infallible memory allocation fails, before\n/// the runtime aborts. The default hook prints a message to standard error,\n/// but this behavior can be customized with the [`set_alloc_error_hook`] and\n/// [`take_alloc_error_hook`] functions.\n///\n/// The hook is provided with a `Layout` struct which contains information\n/// about the allocation that failed.\n///\n/// The allocation error hook is a global resource.\n#[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\npub fn set_alloc_error_hook(hook: fn(Layout)) {\n    HOOK.store(hook as *mut (), Ordering::SeqCst);\n}\n\n/// Unregisters the current allocation error hook, returning it.\n///\n/// *See also the function [`set_alloc_error_hook`].*\n///\n/// If no custom hook is registered, the default hook will be returned.\n#[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\npub fn take_alloc_error_hook() -> fn(Layout) {\n    let hook = HOOK.swap(ptr::null_mut(), Ordering::SeqCst);\n    if hook.is_null() { default_alloc_error_hook } else { unsafe { mem::transmute(hook) } }\n}\n\nfn default_alloc_error_hook(layout: Layout) {\n    rtprintpanic!(\"memory allocation of {} bytes failed\\n\", layout.size());\n}\n\n#[cfg(not(test))]\n#[doc(hidden)]\n#[alloc_error_handler]\n#[unstable(feature = \"alloc_internals\", issue = \"none\")]\npub fn rust_oom(layout: Layout) -> ! {\n    let hook = HOOK.load(Ordering::SeqCst);\n    let hook: fn(Layout) =\n        if hook.is_null() { default_alloc_error_hook } else { unsafe { mem::transmute(hook) } };\n    hook(layout);\n    crate::process::abort()\n}\n\n#[cfg(not(test))]\n#[doc(hidden)]\n#[allow(unused_attributes)]\n#[unstable(feature = \"alloc_internals\", issue = \"none\")]\npub mod __default_lib_allocator {\n    use super::{GlobalAlloc, Layout, System};\n    // These magic symbol names are used as a fallback for implementing the\n    // `__rust_alloc` etc symbols (see `src/liballoc/alloc.rs`) when there is\n    // no `#[global_allocator]` attribute.\n\n    // for symbol names src/librustc_ast/expand/allocator.rs\n    // for signatures src/librustc_allocator/lib.rs\n\n    // linkage directives are provided as part of the current compiler allocator\n    // ABI\n\n    #[rustc_std_internal_symbol]\n    pub unsafe extern \"C\" fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {\n        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n        // `GlobalAlloc::alloc`.\n        unsafe {\n            let layout = Layout::from_size_align_unchecked(size, align);\n            System.alloc(layout)\n        }\n    }\n\n    #[rustc_std_internal_symbol]\n    pub unsafe extern \"C\" fn __rdl_dealloc(ptr: *mut u8, size: usize, align: usize) {\n        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n        // `GlobalAlloc::dealloc`.\n        unsafe { System.dealloc(ptr, Layout::from_size_align_unchecked(size, align)) }\n    }\n\n    #[rustc_std_internal_symbol]\n    pub unsafe extern \"C\" fn __rdl_realloc(\n        ptr: *mut u8,\n        old_size: usize,\n        align: usize,\n        new_size: usize,\n    ) -> *mut u8 {\n        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n        // `GlobalAlloc::realloc`.\n        unsafe {\n            let old_layout = Layout::from_size_align_unchecked(old_size, align);\n            System.realloc(ptr, old_layout, new_size)\n        }\n    }\n\n    #[rustc_std_internal_symbol]\n    pub unsafe extern \"C\" fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n        // `GlobalAlloc::alloc_zeroed`.\n        unsafe {\n            let layout = Layout::from_size_align_unchecked(size, align);\n            System.alloc_zeroed(layout)\n        }\n    }\n}\n"],["2568","#[cfg(test)]\nmod tests;\n\nuse crate::io::prelude::*;\n\nuse crate::cmp;\nuse crate::io::{self, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, SeekFrom};\n\nuse core::convert::TryInto;\n\n/// A `Cursor` wraps an in-memory buffer and provides it with a\n/// [`Seek`] implementation.\n///\n/// `Cursor`s are used with in-memory buffers, anything implementing\n/// [`AsRef`]`<[u8]>`, to allow them to implement [`Read`] and/or [`Write`],\n/// allowing these buffers to be used anywhere you might use a reader or writer\n/// that does actual I/O.\n///\n/// The standard library implements some I/O traits on various types which\n/// are commonly used as a buffer, like `Cursor<`[`Vec`]`<u8>>` and\n/// `Cursor<`[`&[u8]`][bytes]`>`.\n///\n/// # Examples\n///\n/// We may want to write bytes to a [`File`] in our production\n/// code, but use an in-memory buffer in our tests. We can do this with\n/// `Cursor`:\n///\n/// [bytes]: crate::slice\n/// [`File`]: crate::fs::File\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::{self, SeekFrom};\n/// use std::fs::File;\n///\n/// // a library function we've written\n/// fn write_ten_bytes_at_end<W: Write + Seek>(writer: &mut W) -> io::Result<()> {\n///     writer.seek(SeekFrom::End(-10))?;\n///\n///     for i in 0..10 {\n///         writer.write(&[i])?;\n///     }\n///\n///     // all went well\n///     Ok(())\n/// }\n///\n/// # fn foo() -> io::Result<()> {\n/// // Here's some code that uses this library function.\n/// //\n/// // We might want to use a BufReader here for efficiency, but let's\n/// // keep this example focused.\n/// let mut file = File::create(\"foo.txt\")?;\n///\n/// write_ten_bytes_at_end(&mut file)?;\n/// # Ok(())\n/// # }\n///\n/// // now let's write a test\n/// #[test]\n/// fn test_writes_bytes() {\n///     // setting up a real File is much slower than an in-memory buffer,\n///     // let's use a cursor instead\n///     use std::io::Cursor;\n///     let mut buff = Cursor::new(vec![0; 15]);\n///\n///     write_ten_bytes_at_end(&mut buff).unwrap();\n///\n///     assert_eq!(&buff.get_ref()[5..15], &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug, Default, Eq, PartialEq)]\npub struct Cursor<T> {\n    inner: T,\n    pos: u64,\n}\n\nimpl<T> Cursor<T> {\n    /// Creates a new cursor wrapping the provided underlying in-memory buffer.\n    ///\n    /// Cursor initial position is `0` even if underlying buffer (e.g., [`Vec`])\n    /// is not empty. So writing to cursor starts with overwriting [`Vec`]\n    /// content, not with appending to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\n    pub const fn new(inner: T) -> Cursor<T> {\n        Cursor { pos: 0, inner }\n    }\n\n    /// Consumes this cursor, returning the underlying value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    ///\n    /// let vec = buff.into_inner();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> T {\n        self.inner\n    }\n\n    /// Gets a reference to the underlying value in this cursor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    ///\n    /// let reference = buff.get_ref();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\n    pub const fn get_ref(&self) -> &T {\n        &self.inner\n    }\n\n    /// Gets a mutable reference to the underlying value in this cursor.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying value as it may corrupt this cursor's position.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let mut buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    ///\n    /// let reference = buff.get_mut();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.inner\n    }\n\n    /// Returns the current position of this cursor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    /// use std::io::prelude::*;\n    /// use std::io::SeekFrom;\n    ///\n    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n    ///\n    /// assert_eq!(buff.position(), 0);\n    ///\n    /// buff.seek(SeekFrom::Current(2)).unwrap();\n    /// assert_eq!(buff.position(), 2);\n    ///\n    /// buff.seek(SeekFrom::Current(-1)).unwrap();\n    /// assert_eq!(buff.position(), 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\n    pub const fn position(&self) -> u64 {\n        self.pos\n    }\n\n    /// Sets the position of this cursor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n    ///\n    /// assert_eq!(buff.position(), 0);\n    ///\n    /// buff.set_position(2);\n    /// assert_eq!(buff.position(), 2);\n    ///\n    /// buff.set_position(4);\n    /// assert_eq!(buff.position(), 4);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_position(&mut self, pos: u64) {\n        self.pos = pos;\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Cursor<T>\nwhere\n    T: Clone,\n{\n    #[inline]\n    fn clone(&self) -> Self {\n        Cursor { inner: self.inner.clone(), pos: self.pos }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, other: &Self) {\n        self.inner.clone_from(&other.inner);\n        self.pos = other.pos;\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> io::Seek for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn seek(&mut self, style: SeekFrom) -> io::Result<u64> {\n        let (base_pos, offset) = match style {\n            SeekFrom::Start(n) => {\n                self.pos = n;\n                return Ok(n);\n            }\n            SeekFrom::End(n) => (self.inner.as_ref().len() as u64, n),\n            SeekFrom::Current(n) => (self.pos, n),\n        };\n        let new_pos = if offset >= 0 {\n            base_pos.checked_add(offset as u64)\n        } else {\n            base_pos.checked_sub((offset.wrapping_neg()) as u64)\n        };\n        match new_pos {\n            Some(n) => {\n                self.pos = n;\n                Ok(self.pos)\n            }\n            None => Err(Error::new_const(\n                ErrorKind::InvalidInput,\n                &\"invalid seek to a negative or overflowing position\",\n            )),\n        }\n    }\n\n    fn stream_len(&mut self) -> io::Result<u64> {\n        Ok(self.inner.as_ref().len() as u64)\n    }\n\n    fn stream_position(&mut self) -> io::Result<u64> {\n        Ok(self.pos)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Read for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let n = Read::read(&mut self.fill_buf()?, buf)?;\n        self.pos += n as u64;\n        Ok(n)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nread = 0;\n        for buf in bufs {\n            let n = self.read(buf)?;\n            nread += n;\n            if n < buf.len() {\n                break;\n            }\n        }\n        Ok(nread)\n    }\n\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        let n = buf.len();\n        Read::read_exact(&mut self.fill_buf()?, buf)?;\n        self.pos += n as u64;\n        Ok(())\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> BufRead for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        let amt = cmp::min(self.pos, self.inner.as_ref().len() as u64);\n        Ok(&self.inner.as_ref()[(amt as usize)..])\n    }\n    fn consume(&mut self, amt: usize) {\n        self.pos += amt as u64;\n    }\n}\n\n// Non-resizing write implementation\n#[inline]\nfn slice_write(pos_mut: &mut u64, slice: &mut [u8], buf: &[u8]) -> io::Result<usize> {\n    let pos = cmp::min(*pos_mut, slice.len() as u64);\n    let amt = (&mut slice[(pos as usize)..]).write(buf)?;\n    *pos_mut += amt as u64;\n    Ok(amt)\n}\n\n#[inline]\nfn slice_write_vectored(\n    pos_mut: &mut u64,\n    slice: &mut [u8],\n    bufs: &[IoSlice<'_>],\n) -> io::Result<usize> {\n    let mut nwritten = 0;\n    for buf in bufs {\n        let n = slice_write(pos_mut, slice, buf)?;\n        nwritten += n;\n        if n < buf.len() {\n            break;\n        }\n    }\n    Ok(nwritten)\n}\n\n// Resizing write implementation\nfn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n    let pos: usize = (*pos_mut).try_into().map_err(|_| {\n        Error::new_const(\n            ErrorKind::InvalidInput,\n            &\"cursor position exceeds maximum possible vector length\",\n        )\n    })?;\n    // Make sure the internal buffer is as least as big as where we\n    // currently are\n    let len = vec.len();\n    if len < pos {\n        // use `resize` so that the zero filling is as efficient as possible\n        vec.resize(pos, 0);\n    }\n    // Figure out what bytes will be used to overwrite what's currently\n    // there (left), and what will be appended on the end (right)\n    {\n        let space = vec.len() - pos;\n        let (left, right) = buf.split_at(cmp::min(space, buf.len()));\n        vec[pos..pos + left.len()].copy_from_slice(left);\n        vec.extend_from_slice(right);\n    }\n\n    // Bump us forward\n    *pos_mut = (pos + buf.len()) as u64;\n    Ok(buf.len())\n}\n\nfn vec_write_vectored(\n    pos_mut: &mut u64,\n    vec: &mut Vec<u8>,\n    bufs: &[IoSlice<'_>],\n) -> io::Result<usize> {\n    let mut nwritten = 0;\n    for buf in bufs {\n        nwritten += vec_write(pos_mut, vec, buf)?;\n    }\n    Ok(nwritten)\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Cursor<&mut [u8]> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        slice_write(&mut self.pos, self.inner, buf)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        slice_write_vectored(&mut self.pos, self.inner, bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"cursor_mut_vec\", since = \"1.25.0\")]\nimpl Write for Cursor<&mut Vec<u8>> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        vec_write(&mut self.pos, self.inner, buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        vec_write_vectored(&mut self.pos, self.inner, bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Cursor<Vec<u8>> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        vec_write(&mut self.pos, &mut self.inner, buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        vec_write_vectored(&mut self.pos, &mut self.inner, bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"cursor_box_slice\", since = \"1.5.0\")]\nimpl Write for Cursor<Box<[u8]>> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        slice_write(&mut self.pos, &mut self.inner, buf)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        slice_write_vectored(&mut self.pos, &mut self.inner, bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n"],["2569","#[cfg(test)]\nmod tests;\n\nuse crate::convert::From;\nuse crate::error;\nuse crate::fmt;\nuse crate::result;\nuse crate::sys;\n\n/// A specialized [`Result`] type for I/O operations.\n///\n/// This type is broadly used across [`std::io`] for any operation which may\n/// produce an error.\n///\n/// This typedef is generally used to avoid writing out [`io::Error`] directly and\n/// is otherwise a direct mapping to [`Result`].\n///\n/// While usual Rust style is to import types directly, aliases of [`Result`]\n/// often are not, to make it easier to distinguish between them. [`Result`] is\n/// generally assumed to be [`std::result::Result`][`Result`], and so users of this alias\n/// will generally use `io::Result` instead of shadowing the [prelude]'s import\n/// of [`std::result::Result`][`Result`].\n///\n/// [`std::io`]: crate::io\n/// [`io::Error`]: Error\n/// [`Result`]: crate::result::Result\n/// [prelude]: crate::prelude\n///\n/// # Examples\n///\n/// A convenience function that bubbles an `io::Result` to its caller:\n///\n/// ```\n/// use std::io;\n///\n/// fn get_string() -> io::Result<String> {\n///     let mut buffer = String::new();\n///\n///     io::stdin().read_line(&mut buffer)?;\n///\n///     Ok(buffer)\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result<T> = result::Result<T, Error>;\n\n/// The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and\n/// associated traits.\n///\n/// Errors mostly originate from the underlying OS, but custom instances of\n/// `Error` can be created with crafted error messages and a particular value of\n/// [`ErrorKind`].\n///\n/// [`Read`]: crate::io::Read\n/// [`Write`]: crate::io::Write\n/// [`Seek`]: crate::io::Seek\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Error {\n    repr: Repr,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.repr, f)\n    }\n}\n\nenum Repr {\n    Os(i32),\n    Simple(ErrorKind),\n    // &str is a fat pointer, but &&str is a thin pointer.\n    SimpleMessage(ErrorKind, &'static &'static str),\n    Custom(Box<Custom>),\n}\n\n#[derive(Debug)]\nstruct Custom {\n    kind: ErrorKind,\n    error: Box<dyn error::Error + Send + Sync>,\n}\n\n/// A list specifying general categories of I/O error.\n///\n/// This list is intended to grow over time and it is not recommended to\n/// exhaustively match against it.\n///\n/// It is used with the [`io::Error`] type.\n///\n/// [`io::Error`]: Error\n#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\n#[non_exhaustive]\npub enum ErrorKind {\n    /// An entity was not found, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotFound,\n    /// The operation lacked the necessary privileges to complete.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    PermissionDenied,\n    /// The connection was refused by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionRefused,\n    /// The connection was reset by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionReset,\n    /// The connection was aborted (terminated) by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionAborted,\n    /// The network operation failed because it was not connected yet.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotConnected,\n    /// A socket address could not be bound because the address is already in\n    /// use elsewhere.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrInUse,\n    /// A nonexistent interface was requested or the requested address was not\n    /// local.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrNotAvailable,\n    /// The operation failed because a pipe was closed.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    BrokenPipe,\n    /// An entity already exists, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AlreadyExists,\n    /// The operation needs to block to complete, but the blocking operation was\n    /// requested to not occur.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WouldBlock,\n    /// A parameter was incorrect.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    InvalidInput,\n    /// Data not valid for the operation were encountered.\n    ///\n    /// Unlike [`InvalidInput`], this typically means that the operation\n    /// parameters were valid, however the error was caused by malformed\n    /// input data.\n    ///\n    /// For example, a function that reads a file into a string will error with\n    /// `InvalidData` if the file's contents are not valid UTF-8.\n    ///\n    /// [`InvalidInput`]: ErrorKind::InvalidInput\n    #[stable(feature = \"io_invalid_data\", since = \"1.2.0\")]\n    InvalidData,\n    /// The I/O operation's timeout expired, causing it to be canceled.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    TimedOut,\n    /// An error returned when an operation could not be completed because a\n    /// call to [`write`] returned [`Ok(0)`].\n    ///\n    /// This typically means that an operation could only succeed if it wrote a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// written.\n    ///\n    /// [`write`]: crate::io::Write::write\n    /// [`Ok(0)`]: Ok\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WriteZero,\n    /// This operation was interrupted.\n    ///\n    /// Interrupted operations can typically be retried.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Interrupted,\n    /// Any I/O error not part of this list.\n    ///\n    /// Errors that are `Other` now may move to a different or a new\n    /// [`ErrorKind`] variant in the future. It is not recommended to match\n    /// an error against `Other` and to expect any additional characteristics,\n    /// e.g., a specific [`Error::raw_os_error`] return value.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Other,\n\n    /// An error returned when an operation could not be completed because an\n    /// \"end of file\" was reached prematurely.\n    ///\n    /// This typically means that an operation could only succeed if it read a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// read.\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    UnexpectedEof,\n\n    /// This operation is unsupported on this platform.\n    ///\n    /// This means that the operation can never succeed.\n    #[stable(feature = \"unsupported_error\", since = \"1.53.0\")]\n    Unsupported,\n\n    /// An operation could not be completed, because it failed\n    /// to allocate enough memory.\n    #[stable(feature = \"out_of_memory_error\", since = \"1.54.0\")]\n    OutOfMemory,\n}\n\nimpl ErrorKind {\n    pub(crate) fn as_str(&self) -> &'static str {\n        match *self {\n            ErrorKind::NotFound => \"entity not found\",\n            ErrorKind::PermissionDenied => \"permission denied\",\n            ErrorKind::ConnectionRefused => \"connection refused\",\n            ErrorKind::ConnectionReset => \"connection reset\",\n            ErrorKind::ConnectionAborted => \"connection aborted\",\n            ErrorKind::NotConnected => \"not connected\",\n            ErrorKind::AddrInUse => \"address in use\",\n            ErrorKind::AddrNotAvailable => \"address not available\",\n            ErrorKind::BrokenPipe => \"broken pipe\",\n            ErrorKind::AlreadyExists => \"entity already exists\",\n            ErrorKind::WouldBlock => \"operation would block\",\n            ErrorKind::InvalidInput => \"invalid input parameter\",\n            ErrorKind::InvalidData => \"invalid data\",\n            ErrorKind::TimedOut => \"timed out\",\n            ErrorKind::WriteZero => \"write zero\",\n            ErrorKind::Interrupted => \"operation interrupted\",\n            ErrorKind::Other => \"other os error\",\n            ErrorKind::UnexpectedEof => \"unexpected end of file\",\n            ErrorKind::Unsupported => \"unsupported\",\n            ErrorKind::OutOfMemory => \"out of memory\",\n        }\n    }\n}\n\n/// Intended for use for errors not exposed to the user, where allocating onto\n/// the heap (for normal construction via Error::new) is too costly.\n#[stable(feature = \"io_error_from_errorkind\", since = \"1.14.0\")]\nimpl From<ErrorKind> for Error {\n    /// Converts an [`ErrorKind`] into an [`Error`].\n    ///\n    /// This conversion allocates a new error with a simple representation of error kind.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// let not_found = ErrorKind::NotFound;\n    /// let error = Error::from(not_found);\n    /// assert_eq!(\"entity not found\", format!(\"{}\", error));\n    /// ```\n    #[inline]\n    fn from(kind: ErrorKind) -> Error {\n        Error { repr: Repr::Simple(kind) }\n    }\n}\n\nimpl Error {\n    /// Creates a new I/O error from a known kind of error as well as an\n    /// arbitrary error payload.\n    ///\n    /// This function is used to generically create I/O errors which do not\n    /// originate from the OS itself. The `error` argument is an arbitrary\n    /// payload which will be contained in this [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// // errors can be created from strings\n    /// let custom_error = Error::new(ErrorKind::Other, \"oh no!\");\n    ///\n    /// // errors can also be created from other errors\n    /// let custom_error2 = Error::new(ErrorKind::Interrupted, custom_error);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<E>(kind: ErrorKind, error: E) -> Error\n    where\n        E: Into<Box<dyn error::Error + Send + Sync>>,\n    {\n        Self::_new(kind, error.into())\n    }\n\n    fn _new(kind: ErrorKind, error: Box<dyn error::Error + Send + Sync>) -> Error {\n        Error { repr: Repr::Custom(Box::new(Custom { kind, error })) }\n    }\n\n    /// Creates a new I/O error from a known kind of error as well as a\n    /// constant message.\n    ///\n    /// This function does not allocate.\n    ///\n    /// This function should maybe change to\n    /// `new_const<const MSG: &'static str>(kind: ErrorKind)`\n    /// in the future, when const generics allow that.\n    #[inline]\n    pub(crate) const fn new_const(kind: ErrorKind, message: &'static &'static str) -> Error {\n        Self { repr: Repr::SimpleMessage(kind, message) }\n    }\n\n    /// Returns an error representing the last OS error which occurred.\n    ///\n    /// This function reads the value of `errno` for the target platform (e.g.\n    /// `GetLastError` on Windows) and will return a corresponding instance of\n    /// [`Error`] for the error code.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Error;\n    ///\n    /// println!(\"last OS error: {:?}\", Error::last_os_error());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn last_os_error() -> Error {\n        Error::from_raw_os_error(sys::os::errno() as i32)\n    }\n\n    /// Creates a new instance of an [`Error`] from a particular OS error code.\n    ///\n    /// # Examples\n    ///\n    /// On Linux:\n    ///\n    /// ```\n    /// # if cfg!(target_os = \"linux\") {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(22);\n    /// assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n    /// # }\n    /// ```\n    ///\n    /// On Windows:\n    ///\n    /// ```\n    /// # if cfg!(windows) {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(10022);\n    /// assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn from_raw_os_error(code: i32) -> Error {\n        Error { repr: Repr::Os(code) }\n    }\n\n    /// Returns the OS error that this error represents (if any).\n    ///\n    /// If this [`Error`] was constructed via [`last_os_error`] or\n    /// [`from_raw_os_error`], then this function will return [`Some`], otherwise\n    /// it will return [`None`].\n    ///\n    /// [`last_os_error`]: Error::last_os_error\n    /// [`from_raw_os_error`]: Error::from_raw_os_error\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_os_error(err: &Error) {\n    ///     if let Some(raw_os_err) = err.raw_os_error() {\n    ///         println!(\"raw OS error: {:?}\", raw_os_err);\n    ///     } else {\n    ///         println!(\"Not an OS error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"raw OS error: ...\".\n    ///     print_os_error(&Error::last_os_error());\n    ///     // Will print \"Not an OS error\".\n    ///     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn raw_os_error(&self) -> Option<i32> {\n        match self.repr {\n            Repr::Os(i) => Some(i),\n            Repr::Custom(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n        }\n    }\n\n    /// Returns a reference to the inner error wrapped by this error (if any).\n    ///\n    /// If this [`Error`] was constructed via [`new`] then this function will\n    /// return [`Some`], otherwise it will return [`None`].\n    ///\n    /// [`new`]: Error::new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {:?}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    #[inline]\n    pub fn get_ref(&self) -> Option<&(dyn error::Error + Send + Sync + 'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(ref c) => Some(&*c.error),\n        }\n    }\n\n    /// Returns a mutable reference to the inner error wrapped by this error\n    /// (if any).\n    ///\n    /// If this [`Error`] was constructed via [`new`] then this function will\n    /// return [`Some`], otherwise it will return [`None`].\n    ///\n    /// [`new`]: Error::new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    /// use std::{error, fmt};\n    /// use std::fmt::Display;\n    ///\n    /// #[derive(Debug)]\n    /// struct MyError {\n    ///     v: String,\n    /// }\n    ///\n    /// impl MyError {\n    ///     fn new() -> MyError {\n    ///         MyError {\n    ///             v: \"oh no!\".to_string()\n    ///         }\n    ///     }\n    ///\n    ///     fn change_message(&mut self, new_message: &str) {\n    ///         self.v = new_message.to_string();\n    ///     }\n    /// }\n    ///\n    /// impl error::Error for MyError {}\n    ///\n    /// impl Display for MyError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"MyError: {}\", &self.v)\n    ///     }\n    /// }\n    ///\n    /// fn change_error(mut err: Error) -> Error {\n    ///     if let Some(inner_err) = err.get_mut() {\n    ///         inner_err.downcast_mut::<MyError>().unwrap().change_message(\"I've been changed!\");\n    ///     }\n    ///     err\n    /// }\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&change_error(Error::last_os_error()));\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&change_error(Error::new(ErrorKind::Other, MyError::new())));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    #[inline]\n    pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(ref mut c) => Some(&mut *c.error),\n        }\n    }\n\n    /// Consumes the `Error`, returning its inner error (if any).\n    ///\n    /// If this [`Error`] was constructed via [`new`] then this function will\n    /// return [`Some`], otherwise it will return [`None`].\n    ///\n    /// [`new`]: Error::new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     if let Some(inner_err) = err.into_inner() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    #[inline]\n    pub fn into_inner(self) -> Option<Box<dyn error::Error + Send + Sync>> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(c) => Some(c.error),\n        }\n    }\n\n    /// Returns the corresponding [`ErrorKind`] for this error.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     println!(\"{:?}\", err.kind());\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"Other\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"AddrInUse\".\n    ///     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn kind(&self) -> ErrorKind {\n        match self.repr {\n            Repr::Os(code) => sys::decode_error_kind(code),\n            Repr::Custom(ref c) => c.kind,\n            Repr::Simple(kind) => kind,\n            Repr::SimpleMessage(kind, _) => kind,\n        }\n    }\n}\n\nimpl fmt::Debug for Repr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Repr::Os(code) => fmt\n                .debug_struct(\"Os\")\n                .field(\"code\", &code)\n                .field(\"kind\", &sys::decode_error_kind(code))\n                .field(\"message\", &sys::os::error_string(code))\n                .finish(),\n            Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),\n            Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n            Repr::SimpleMessage(kind, &message) => {\n                fmt.debug_struct(\"Error\").field(\"kind\", &kind).field(\"message\", &message).finish()\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Error {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.repr {\n            Repr::Os(code) => {\n                let detail = sys::os::error_string(code);\n                write!(fmt, \"{} (os error {})\", detail, code)\n            }\n            Repr::Custom(ref c) => c.error.fmt(fmt),\n            Repr::Simple(kind) => write!(fmt, \"{}\", kind.as_str()),\n            Repr::SimpleMessage(_, &msg) => msg.fmt(fmt),\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl error::Error for Error {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        match self.repr {\n            Repr::Os(..) | Repr::Simple(..) => self.kind().as_str(),\n            Repr::SimpleMessage(_, &msg) => msg,\n            Repr::Custom(ref c) => c.error.description(),\n        }\n    }\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn error::Error> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(ref c) => c.error.cause(),\n        }\n    }\n\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        match self.repr {\n            Repr::Os(..) => None,\n            Repr::Simple(..) => None,\n            Repr::SimpleMessage(..) => None,\n            Repr::Custom(ref c) => c.error.source(),\n        }\n    }\n}\n\nfn _assert_error_is_sync_send() {\n    fn _is_sync_send<T: Sync + Send>() {}\n    _is_sync_send::<Error>();\n}\n"],["2570","#![cfg_attr(test, allow(unused))]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::io::prelude::*;\n\nuse crate::cell::{Cell, RefCell};\nuse crate::fmt;\nuse crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\nuse crate::lazy::SyncOnceCell;\nuse crate::pin::Pin;\nuse crate::sync::atomic::{AtomicBool, Ordering};\nuse crate::sync::{Arc, Mutex, MutexGuard};\nuse crate::sys::stdio;\nuse crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n\ntype LocalStream = Arc<Mutex<Vec<u8>>>;\n\nthread_local! {\n    /// Used by the test crate to capture the output of the print macros and panics.\n    static OUTPUT_CAPTURE: Cell<Option<LocalStream>> = {\n        Cell::new(None)\n    }\n}\n\n/// Flag to indicate OUTPUT_CAPTURE is used.\n///\n/// If it is None and was never set on any thread, this flag is set to false,\n/// and OUTPUT_CAPTURE can be safely ignored on all threads, saving some time\n/// and memory registering an unused thread local.\n///\n/// Note about memory ordering: This contains information about whether a\n/// thread local variable might be in use. Although this is a global flag, the\n/// memory ordering between threads does not matter: we only want this flag to\n/// have a consistent order between set_output_capture and print_to *within\n/// the same thread*. Within the same thread, things always have a perfectly\n/// consistent order. So Ordering::Relaxed is fine.\nstatic OUTPUT_CAPTURE_USED: AtomicBool = AtomicBool::new(false);\n\n/// A handle to a raw instance of the standard input stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stdin_raw` function.\nstruct StdinRaw(stdio::Stdin);\n\n/// A handle to a raw instance of the standard output stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stdout_raw` function.\nstruct StdoutRaw(stdio::Stdout);\n\n/// A handle to a raw instance of the standard output stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stderr_raw` function.\nstruct StderrRaw(stdio::Stderr);\n\n/// Constructs a new raw handle to the standard input of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stdin`. Data buffered by the `std::io::stdin`\n/// handles is **not** available to raw handles returned from this function.\n///\n/// The returned handle has no external synchronization or buffering.\n#[unstable(feature = \"libstd_sys_internals\", issue = \"none\")]\nconst fn stdin_raw() -> StdinRaw {\n    StdinRaw(stdio::Stdin::new())\n}\n\n/// Constructs a new raw handle to the standard output stream of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stdout`. Note that data is buffered by the\n/// `std::io::stdout` handles so writes which happen via this raw handle may\n/// appear before previous writes.\n///\n/// The returned handle has no external synchronization or buffering layered on\n/// top.\n#[unstable(feature = \"libstd_sys_internals\", issue = \"none\")]\nconst fn stdout_raw() -> StdoutRaw {\n    StdoutRaw(stdio::Stdout::new())\n}\n\n/// Constructs a new raw handle to the standard error stream of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stderr`.\n///\n/// The returned handle has no external synchronization or buffering layered on\n/// top.\n#[unstable(feature = \"libstd_sys_internals\", issue = \"none\")]\nconst fn stderr_raw() -> StderrRaw {\n    StderrRaw(stdio::Stderr::new())\n}\n\nimpl Read for StdinRaw {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        handle_ebadf(self.0.read(buf), 0)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        handle_ebadf(self.0.read_vectored(bufs), 0)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.0.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        handle_ebadf(self.0.read_to_end(buf), 0)\n    }\n\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        handle_ebadf(self.0.read_to_string(buf), 0)\n    }\n}\n\nimpl Write for StdoutRaw {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        handle_ebadf(self.0.write(buf), buf.len())\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let total = bufs.iter().map(|b| b.len()).sum();\n        handle_ebadf(self.0.write_vectored(bufs), total)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        handle_ebadf(self.0.flush(), ())\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        handle_ebadf(self.0.write_all(buf), ())\n    }\n\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        handle_ebadf(self.0.write_all_vectored(bufs), ())\n    }\n\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        handle_ebadf(self.0.write_fmt(fmt), ())\n    }\n}\n\nimpl Write for StderrRaw {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        handle_ebadf(self.0.write(buf), buf.len())\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let total = bufs.iter().map(|b| b.len()).sum();\n        handle_ebadf(self.0.write_vectored(bufs), total)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.0.is_write_vectored()\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        handle_ebadf(self.0.flush(), ())\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        handle_ebadf(self.0.write_all(buf), ())\n    }\n\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        handle_ebadf(self.0.write_all_vectored(bufs), ())\n    }\n\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        handle_ebadf(self.0.write_fmt(fmt), ())\n    }\n}\n\nfn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n    match r {\n        Err(ref e) if stdio::is_ebadf(e) => Ok(default),\n        r => r,\n    }\n}\n\n/// A handle to the standard input stream of a process.\n///\n/// Each handle is a shared reference to a global buffer of input data to this\n/// process. A handle can be `lock`'d to gain full access to [`BufRead`] methods\n/// (e.g., `.lines()`). Reads to this handle are otherwise locked with respect\n/// to other reads.\n///\n/// This handle implements the `Read` trait, but beware that concurrent reads\n/// of `Stdin` must be executed with care.\n///\n/// Created by the [`io::stdin`] method.\n///\n/// [`io::stdin`]: stdin\n///\n/// ### Note: Windows Portability Consideration\n///\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     let mut stdin = io::stdin(); // We get `Stdin` here.\n///     stdin.read_to_string(&mut buffer)?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stdin {\n    inner: &'static Mutex<BufReader<StdinRaw>>,\n}\n\n/// A locked reference to the [`Stdin`] handle.\n///\n/// This handle implements both the [`Read`] and [`BufRead`] traits, and\n/// is constructed via the [`Stdin::lock`] method.\n///\n/// ### Note: Windows Portability Consideration\n///\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     let stdin = io::stdin(); // We get `Stdin` here.\n///     {\n///         let mut handle = stdin.lock(); // We get `StdinLock` here.\n///         handle.read_to_string(&mut buffer)?;\n///     } // `StdinLock` is dropped here.\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StdinLock<'a> {\n    inner: MutexGuard<'a, BufReader<StdinRaw>>,\n}\n\n/// Constructs a new handle to the standard input of the current process.\n///\n/// Each handle returned is a reference to a shared global buffer whose access\n/// is synchronized via a mutex. If you need more explicit control over\n/// locking, see the [`Stdin::lock`] method.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     io::stdin().read_to_string(&mut buffer)?;\n///     Ok(())\n/// }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     let stdin = io::stdin();\n///     let mut handle = stdin.lock();\n///\n///     handle.read_to_string(&mut buffer)?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stdin() -> Stdin {\n    static INSTANCE: SyncOnceCell<Mutex<BufReader<StdinRaw>>> = SyncOnceCell::new();\n    Stdin {\n        inner: INSTANCE.get_or_init(|| {\n            Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin_raw()))\n        }),\n    }\n}\n\nimpl Stdin {\n    /// Locks this handle to the standard input stream, returning a readable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the [`Read`] and [`BufRead`] traits for\n    /// accessing the underlying data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{self, Read};\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut buffer = String::new();\n    ///     let stdin = io::stdin();\n    ///     let mut handle = stdin.lock();\n    ///\n    ///     handle.read_to_string(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StdinLock<'_> {\n        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n    }\n\n    /// Locks this handle and reads a line of input, appending it to the specified buffer.\n    ///\n    /// For detailed semantics of this method, see the documentation on\n    /// [`BufRead::read_line`].\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    ///\n    /// let mut input = String::new();\n    /// match io::stdin().read_line(&mut input) {\n    ///     Ok(n) => {\n    ///         println!(\"{} bytes read\", n);\n    ///         println!(\"{}\", input);\n    ///     }\n    ///     Err(error) => println!(\"error: {}\", error),\n    /// }\n    /// ```\n    ///\n    /// You can run the example one of two ways:\n    ///\n    /// - Pipe some text to it, e.g., `printf foo | path/to/executable`\n    /// - Give it text interactively by running the executable directly,\n    ///   in which case it will wait for the Enter key to be pressed before\n    ///   continuing\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn read_line(&self, buf: &mut String) -> io::Result<usize> {\n        self.lock().read_line(buf)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdin {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Stdin\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.lock().read(buf)\n    }\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.lock().read_vectored(bufs)\n    }\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.lock().is_read_vectored()\n    }\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        self.lock().read_to_end(buf)\n    }\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        self.lock().read_to_string(buf)\n    }\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        self.lock().read_exact(buf)\n    }\n}\n\n// only used by platform-dependent io::copy specializations, i.e. unused on some platforms\n#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\nimpl StdinLock<'_> {\n    pub(crate) fn as_mut_buf(&mut self) -> &mut BufReader<impl Read> {\n        &mut self.inner\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for StdinLock<'_> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        self.inner.read_to_end(buf)\n    }\n\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        self.inner.read_to_string(buf)\n    }\n\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        self.inner.read_exact(buf)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl BufRead for StdinLock<'_> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        self.inner.fill_buf()\n    }\n\n    fn consume(&mut self, n: usize) {\n        self.inner.consume(n)\n    }\n\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        self.inner.read_until(byte, buf)\n    }\n\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        self.inner.read_line(buf)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for StdinLock<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"StdinLock\").finish_non_exhaustive()\n    }\n}\n\n/// A handle to the global standard output stream of the current process.\n///\n/// Each handle shares a global buffer of data to be written to the standard\n/// output stream. Access is also synchronized via a lock and explicit control\n/// over locking is available via the [`lock`] method.\n///\n/// Created by the [`io::stdout`] method.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// [`lock`]: Stdout::lock\n/// [`io::stdout`]: stdout\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stdout {\n    // FIXME: this should be LineWriter or BufWriter depending on the state of\n    //        stdout (tty or not). Note that if this is not line buffered it\n    //        should also flush-on-panic or some form of flush-on-abort.\n    inner: Pin<&'static ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>,\n}\n\n/// A locked reference to the [`Stdout`] handle.\n///\n/// This handle implements the [`Write`] trait, and is constructed via\n/// the [`Stdout::lock`] method. See its documentation for more.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StdoutLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n}\n\nstatic STDOUT: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = SyncOnceCell::new();\n\n/// Constructs a new handle to the standard output of the current process.\n///\n/// Each handle returned is a reference to a shared global buffer whose access\n/// is synchronized via a mutex. If you need more explicit control over\n/// locking, see the [`Stdout::lock`] method.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     io::stdout().write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     let stdout = io::stdout();\n///     let mut handle = stdout.lock();\n///\n///     handle.write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stdout() -> Stdout {\n    Stdout {\n        inner: Pin::static_ref(&STDOUT).get_or_init_pin(\n            || unsafe { ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))) },\n            |mutex| unsafe { mutex.init() },\n        ),\n    }\n}\n\npub fn cleanup() {\n    if let Some(instance) = STDOUT.get() {\n        // Flush the data and disable buffering during shutdown\n        // by replacing the line writer by one with zero\n        // buffering capacity.\n        // We use try_lock() instead of lock(), because someone\n        // might have leaked a StdoutLock, which would\n        // otherwise cause a deadlock here.\n        if let Some(lock) = Pin::static_ref(instance).try_lock() {\n            *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n        }\n    }\n}\n\nimpl Stdout {\n    /// Locks this handle to the standard output stream, returning a writable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the `Write` trait for writing data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{self, Write};\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let stdout = io::stdout();\n    ///     let mut handle = stdout.lock();\n    ///\n    ///     handle.write_all(b\"hello world\")?;\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StdoutLock<'_> {\n        StdoutLock { inner: self.inner.lock() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdout {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Stdout\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        (&*self).write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        (&*self).write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        io::Write::is_write_vectored(&&*self)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        (&*self).flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (&*self).write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        (&*self).write_all_vectored(bufs)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n        (&*self).write_fmt(args)\n    }\n}\n\n#[stable(feature = \"write_mt\", since = \"1.48.0\")]\nimpl Write for &Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.lock().write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.lock().write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.lock().is_write_vectored()\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.lock().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.lock().write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        self.lock().write_all_vectored(bufs)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n        self.lock().write_fmt(args)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for StdoutLock<'_> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.borrow_mut().write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.borrow_mut().write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.inner.borrow_mut().is_write_vectored()\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.borrow_mut().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.inner.borrow_mut().write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        self.inner.borrow_mut().write_all_vectored(bufs)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for StdoutLock<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"StdoutLock\").finish_non_exhaustive()\n    }\n}\n\n/// A handle to the standard error stream of a process.\n///\n/// For more information, see the [`io::stderr`] method.\n///\n/// [`io::stderr`]: stderr\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stderr {\n    inner: Pin<&'static ReentrantMutex<RefCell<StderrRaw>>>,\n}\n\n/// A locked reference to the [`Stderr`] handle.\n///\n/// This handle implements the [`Write`] trait and is constructed via\n/// the [`Stderr::lock`] method. See its documentation for more.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StderrLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<StderrRaw>>,\n}\n\n/// Constructs a new handle to the standard error of the current process.\n///\n/// This handle is not buffered.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     io::stderr().write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     let stderr = io::stderr();\n///     let mut handle = stderr.lock();\n///\n///     handle.write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stderr() -> Stderr {\n    // Note that unlike `stdout()` we don't use `at_exit` here to register a\n    // destructor. Stderr is not buffered , so there's no need to run a\n    // destructor for flushing the buffer\n    static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<StderrRaw>>> = SyncOnceCell::new();\n\n    Stderr {\n        inner: Pin::static_ref(&INSTANCE).get_or_init_pin(\n            || unsafe { ReentrantMutex::new(RefCell::new(stderr_raw())) },\n            |mutex| unsafe { mutex.init() },\n        ),\n    }\n}\n\nimpl Stderr {\n    /// Locks this handle to the standard error stream, returning a writable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the [`Write`] trait for writing data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Write};\n    ///\n    /// fn foo() -> io::Result<()> {\n    ///     let stderr = io::stderr();\n    ///     let mut handle = stderr.lock();\n    ///\n    ///     handle.write_all(b\"hello world\")?;\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StderrLock<'_> {\n        StderrLock { inner: self.inner.lock() }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stderr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Stderr\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        (&*self).write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        (&*self).write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        io::Write::is_write_vectored(&&*self)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        (&*self).flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (&*self).write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        (&*self).write_all_vectored(bufs)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n        (&*self).write_fmt(args)\n    }\n}\n\n#[stable(feature = \"write_mt\", since = \"1.48.0\")]\nimpl Write for &Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.lock().write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.lock().write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.lock().is_write_vectored()\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.lock().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.lock().write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        self.lock().write_all_vectored(bufs)\n    }\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n        self.lock().write_fmt(args)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for StderrLock<'_> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.borrow_mut().write(buf)\n    }\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.borrow_mut().write_vectored(bufs)\n    }\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        self.inner.borrow_mut().is_write_vectored()\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.borrow_mut().flush()\n    }\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.inner.borrow_mut().write_all(buf)\n    }\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        self.inner.borrow_mut().write_all_vectored(bufs)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for StderrLock<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"StderrLock\").finish_non_exhaustive()\n    }\n}\n\n/// Sets the thread-local output capture buffer and returns the old one.\n#[unstable(\n    feature = \"internal_output_capture\",\n    reason = \"this function is meant for use in the test crate \\\n        and may disappear in the future\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\npub fn set_output_capture(sink: Option<LocalStream>) -> Option<LocalStream> {\n    if sink.is_none() && !OUTPUT_CAPTURE_USED.load(Ordering::Relaxed) {\n        // OUTPUT_CAPTURE is definitely None since OUTPUT_CAPTURE_USED is false.\n        return None;\n    }\n    OUTPUT_CAPTURE_USED.store(true, Ordering::Relaxed);\n    OUTPUT_CAPTURE.with(move |slot| slot.replace(sink))\n}\n\n/// Write `args` to the capture buffer if enabled and possible, or `global_s`\n/// otherwise. `label` identifies the stream in a panic message.\n///\n/// This function is used to print error messages, so it takes extra\n/// care to avoid causing a panic when `local_s` is unusable.\n/// For instance, if the TLS key for the local stream is\n/// already destroyed, or if the local stream is locked by another\n/// thread, it will just fall back to the global stream.\n///\n/// However, if the actual I/O causes an error, this function does panic.\nfn print_to<T>(args: fmt::Arguments<'_>, global_s: fn() -> T, label: &str)\nwhere\n    T: Write,\n{\n    if OUTPUT_CAPTURE_USED.load(Ordering::Relaxed)\n        && OUTPUT_CAPTURE.try_with(|s| {\n            // Note that we completely remove a local sink to write to in case\n            // our printing recursively panics/prints, so the recursive\n            // panic/print goes to the global sink instead of our local sink.\n            s.take().map(|w| {\n                let _ = w.lock().unwrap_or_else(|e| e.into_inner()).write_fmt(args);\n                s.set(Some(w));\n            })\n        }) == Ok(Some(()))\n    {\n        // Succesfully wrote to capture buffer.\n        return;\n    }\n\n    if let Err(e) = global_s().write_fmt(args) {\n        panic!(\"failed printing to {}: {}\", label, e);\n    }\n}\n\n#[unstable(\n    feature = \"print_internals\",\n    reason = \"implementation detail which may disappear or be replaced at any time\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\n#[cfg(not(test))]\npub fn _print(args: fmt::Arguments<'_>) {\n    print_to(args, stdout, \"stdout\");\n}\n\n#[unstable(\n    feature = \"print_internals\",\n    reason = \"implementation detail which may disappear or be replaced at any time\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\n#[cfg(not(test))]\npub fn _eprint(args: fmt::Arguments<'_>) {\n    print_to(args, stderr, \"stderr\");\n}\n\n#[cfg(test)]\npub use realstd::io::{_eprint, _print};\n"],["2571","#[cfg(test)]\nmod tests;\n\nuse crate::alloc::Allocator;\nuse crate::cmp;\nuse crate::fmt;\nuse crate::io::{\n    self, BufRead, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n};\nuse crate::mem;\n\n// =============================================================================\n// Forwarding implementations\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read + ?Sized> Read for &mut R {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        (**self).read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        (**self).is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        (**self).initializer()\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_to_end(buf)\n    }\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_to_string(buf)\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        (**self).read_exact(buf)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + ?Sized> Write for &mut W {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        (**self).write(buf)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        (**self).write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        (**self).is_write_vectored()\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        (**self).flush()\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (**self).write_all(buf)\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        (**self).write_fmt(fmt)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<S: Seek + ?Sized> Seek for &mut S {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        (**self).seek(pos)\n    }\n\n    #[inline]\n    fn stream_position(&mut self) -> io::Result<u64> {\n        (**self).stream_position()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead + ?Sized> BufRead for &mut B {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        (**self).fill_buf()\n    }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) {\n        (**self).consume(amt)\n    }\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_until(byte, buf)\n    }\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_line(buf)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read + ?Sized> Read for Box<R> {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        (**self).read(buf)\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        (**self).read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        (**self).is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        (**self).initializer()\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_to_end(buf)\n    }\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_to_string(buf)\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        (**self).read_exact(buf)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + ?Sized> Write for Box<W> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        (**self).write(buf)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        (**self).write_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        (**self).is_write_vectored()\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        (**self).flush()\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        (**self).write_all(buf)\n    }\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        (**self).write_fmt(fmt)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<S: Seek + ?Sized> Seek for Box<S> {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        (**self).seek(pos)\n    }\n\n    #[inline]\n    fn stream_position(&mut self) -> io::Result<u64> {\n        (**self).stream_position()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead + ?Sized> BufRead for Box<B> {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        (**self).fill_buf()\n    }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) {\n        (**self).consume(amt)\n    }\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (**self).read_until(byte, buf)\n    }\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n        (**self).read_line(buf)\n    }\n}\n\n// =============================================================================\n// In-memory buffer implementations\n\n/// Read is implemented for `&[u8]` by copying from the slice.\n///\n/// Note that reading updates the slice to point to the yet unread part.\n/// The slice will be empty when EOF is reached.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for &[u8] {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let amt = cmp::min(buf.len(), self.len());\n        let (a, b) = self.split_at(amt);\n\n        // First check if the amount of bytes we want to read is small:\n        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n        // for a single byte the overhead is significant.\n        if amt == 1 {\n            buf[0] = a[0];\n        } else {\n            buf[..amt].copy_from_slice(a);\n        }\n\n        *self = b;\n        Ok(amt)\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nread = 0;\n        for buf in bufs {\n            nread += self.read(buf)?;\n            if self.is_empty() {\n                break;\n            }\n        }\n\n        Ok(nread)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        if buf.len() > self.len() {\n            return Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"));\n        }\n        let (a, b) = self.split_at(buf.len());\n\n        // First check if the amount of bytes we want to read is small:\n        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n        // for a single byte the overhead is significant.\n        if buf.len() == 1 {\n            buf[0] = a[0];\n        } else {\n            buf.copy_from_slice(a);\n        }\n\n        *self = b;\n        Ok(())\n    }\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        buf.extend_from_slice(*self);\n        let len = self.len();\n        *self = &self[len..];\n        Ok(len)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl BufRead for &[u8] {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        Ok(*self)\n    }\n\n    #[inline]\n    fn consume(&mut self, amt: usize) {\n        *self = &self[amt..];\n    }\n}\n\n/// Write is implemented for `&mut [u8]` by copying into the slice, overwriting\n/// its data.\n///\n/// Note that writing updates the slice to point to the yet unwritten part.\n/// The slice will be empty when it has been completely overwritten.\n///\n/// If the number of bytes to be written exceeds the size of the slice, write operations will\n/// return short writes: ultimately, `Ok(0)`; in this situation, `write_all` returns an error of\n/// kind `ErrorKind::WriteZero`.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for &mut [u8] {\n    #[inline]\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        let amt = cmp::min(data.len(), self.len());\n        let (a, b) = mem::replace(self, &mut []).split_at_mut(amt);\n        a.copy_from_slice(&data[..amt]);\n        *self = b;\n        Ok(amt)\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let mut nwritten = 0;\n        for buf in bufs {\n            nwritten += self.write(buf)?;\n            if self.is_empty() {\n                break;\n            }\n        }\n\n        Ok(nwritten)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn write_all(&mut self, data: &[u8]) -> io::Result<()> {\n        if self.write(data)? == data.len() {\n            Ok(())\n        } else {\n            Err(Error::new_const(ErrorKind::WriteZero, &\"failed to write whole buffer\"))\n        }\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n/// Write is implemented for `Vec<u8>` by appending to the vector.\n/// The vector will grow as needed.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Allocator> Write for Vec<u8, A> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.extend_from_slice(buf);\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let len = bufs.iter().map(|b| b.len()).sum();\n        self.reserve(len);\n        for buf in bufs {\n            self.extend_from_slice(buf);\n        }\n        Ok(len)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.extend_from_slice(buf);\n        Ok(())\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n"],["2572","use super::*;\nuse crate::panic::{RefUnwindSafe, UnwindSafe};\nuse crate::thread;\n\n#[test]\nfn stdout_unwind_safe() {\n    assert_unwind_safe::<Stdout>();\n}\n#[test]\nfn stdoutlock_unwind_safe() {\n    assert_unwind_safe::<StdoutLock<'_>>();\n    assert_unwind_safe::<StdoutLock<'static>>();\n}\n#[test]\nfn stderr_unwind_safe() {\n    assert_unwind_safe::<Stderr>();\n}\n#[test]\nfn stderrlock_unwind_safe() {\n    assert_unwind_safe::<StderrLock<'_>>();\n    assert_unwind_safe::<StderrLock<'static>>();\n}\n\nfn assert_unwind_safe<T: UnwindSafe + RefUnwindSafe>() {}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn panic_doesnt_poison() {\n    thread::spawn(|| {\n        let _a = stdin();\n        let _a = _a.lock();\n        let _a = stdout();\n        let _a = _a.lock();\n        let _a = stderr();\n        let _a = _a.lock();\n        panic!();\n    })\n    .join()\n    .unwrap_err();\n\n    let _a = stdin();\n    let _a = _a.lock();\n    let _a = stdout();\n    let _a = _a.lock();\n    let _a = stderr();\n    let _a = _a.lock();\n}\n"],["2573","//! Buffering wrappers for I/O traits\n\nmod bufreader;\nmod bufwriter;\nmod linewriter;\nmod linewritershim;\n\n#[cfg(test)]\nmod tests;\n\nuse crate::error;\nuse crate::fmt;\nuse crate::io::Error;\n\npub use bufreader::BufReader;\npub use bufwriter::BufWriter;\npub use linewriter::LineWriter;\nuse linewritershim::LineWriterShim;\n\n/// An error returned by [`BufWriter::into_inner`] which combines an error that\n/// happened while writing out the buffer, and the buffered writer object\n/// which may be used to recover from the condition.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::BufWriter;\n/// use std::net::TcpStream;\n///\n/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n///\n/// // do stuff with the stream\n///\n/// // we want to get our `TcpStream` back, so let's try:\n///\n/// let stream = match stream.into_inner() {\n///     Ok(s) => s,\n///     Err(e) => {\n///         // Here, e is an IntoInnerError\n///         panic!(\"An error occurred\");\n///     }\n/// };\n/// ```\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoInnerError<W>(W, Error);\n\nimpl<W> IntoInnerError<W> {\n    /// Construct a new IntoInnerError\n    fn new(writer: W, error: Error) -> Self {\n        Self(writer, error)\n    }\n\n    /// Helper to construct a new IntoInnerError; intended to help with\n    /// adapters that wrap other adapters\n    fn new_wrapped<W2>(self, f: impl FnOnce(W) -> W2) -> IntoInnerError<W2> {\n        let Self(writer, error) = self;\n        IntoInnerError::new(f(writer), error)\n    }\n\n    /// Returns the error which caused the call to [`BufWriter::into_inner()`]\n    /// to fail.\n    ///\n    /// This error was returned when attempting to write the internal buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // do stuff with the stream\n    ///\n    /// // we want to get our `TcpStream` back, so let's try:\n    ///\n    /// let stream = match stream.into_inner() {\n    ///     Ok(s) => s,\n    ///     Err(e) => {\n    ///         // Here, e is an IntoInnerError, let's log the inner error.\n    ///         //\n    ///         // We'll just 'log' to stdout for this example.\n    ///         println!(\"{}\", e.error());\n    ///\n    ///         panic!(\"An unexpected error occurred.\");\n    ///     }\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn error(&self) -> &Error {\n        &self.1\n    }\n\n    /// Returns the buffered writer instance which generated the error.\n    ///\n    /// The returned object can be used for error recovery, such as\n    /// re-inspecting the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // do stuff with the stream\n    ///\n    /// // we want to get our `TcpStream` back, so let's try:\n    ///\n    /// let stream = match stream.into_inner() {\n    ///     Ok(s) => s,\n    ///     Err(e) => {\n    ///         // Here, e is an IntoInnerError, let's re-examine the buffer:\n    ///         let buffer = e.into_inner();\n    ///\n    ///         // do stuff to try to recover\n    ///\n    ///         // afterwards, let's just return the stream\n    ///         buffer.into_inner().unwrap()\n    ///     }\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> W {\n        self.0\n    }\n\n    /// Consumes the [`IntoInnerError`] and returns the error which caused the call to\n    /// [`BufWriter::into_inner()`] to fail.  Unlike `error`, this can be used to\n    /// obtain ownership of the underlying error.\n    ///\n    /// # Example\n    /// ```\n    /// #![feature(io_into_inner_error_parts)]\n    /// use std::io::{BufWriter, ErrorKind, Write};\n    ///\n    /// let mut not_enough_space = [0u8; 10];\n    /// let mut stream = BufWriter::new(not_enough_space.as_mut());\n    /// write!(stream, \"this cannot be actually written\").unwrap();\n    /// let into_inner_err = stream.into_inner().expect_err(\"now we discover it's too small\");\n    /// let err = into_inner_err.into_error();\n    /// assert_eq!(err.kind(), ErrorKind::WriteZero);\n    /// ```\n    #[unstable(feature = \"io_into_inner_error_parts\", issue = \"79704\")]\n    pub fn into_error(self) -> Error {\n        self.1\n    }\n\n    /// Consumes the [`IntoInnerError`] and returns the error which caused the call to\n    /// [`BufWriter::into_inner()`] to fail, and the underlying writer.\n    ///\n    /// This can be used to simply obtain ownership of the underlying error; it can also be used for\n    /// advanced error recovery.\n    ///\n    /// # Example\n    /// ```\n    /// #![feature(io_into_inner_error_parts)]\n    /// use std::io::{BufWriter, ErrorKind, Write};\n    ///\n    /// let mut not_enough_space = [0u8; 10];\n    /// let mut stream = BufWriter::new(not_enough_space.as_mut());\n    /// write!(stream, \"this cannot be actually written\").unwrap();\n    /// let into_inner_err = stream.into_inner().expect_err(\"now we discover it's too small\");\n    /// let (err, recovered_writer) = into_inner_err.into_parts();\n    /// assert_eq!(err.kind(), ErrorKind::WriteZero);\n    /// assert_eq!(recovered_writer.buffer(), b\"t be actually written\");\n    /// ```\n    #[unstable(feature = \"io_into_inner_error_parts\", issue = \"79704\")]\n    pub fn into_parts(self) -> (Error, W) {\n        (self.1, self.0)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W> From<IntoInnerError<W>> for Error {\n    fn from(iie: IntoInnerError<W>) -> Error {\n        iie.1\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        error::Error::description(self.error())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W> fmt::Display for IntoInnerError<W> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.error().fmt(f)\n    }\n}\n"],["2574","use crate::io::{self, BufWriter, IoSlice, Write};\nuse crate::sys_common::memchr;\n\n/// Private helper struct for implementing the line-buffered writing logic.\n/// This shim temporarily wraps a BufWriter, and uses its internals to\n/// implement a line-buffered writer (specifically by using the internal\n/// methods like write_to_buf and flush_buf). In this way, a more\n/// efficient abstraction can be created than one that only had access to\n/// `write` and `flush`, without needlessly duplicating a lot of the\n/// implementation details of BufWriter. This also allows existing\n/// `BufWriters` to be temporarily given line-buffering logic; this is what\n/// enables Stdout to be alternately in line-buffered or block-buffered mode.\n#[derive(Debug)]\npub struct LineWriterShim<'a, W: Write> {\n    buffer: &'a mut BufWriter<W>,\n}\n\nimpl<'a, W: Write> LineWriterShim<'a, W> {\n    pub fn new(buffer: &'a mut BufWriter<W>) -> Self {\n        Self { buffer }\n    }\n\n    /// Get a reference to the inner writer (that is, the writer\n    /// wrapped by the BufWriter).\n    fn inner(&self) -> &W {\n        self.buffer.get_ref()\n    }\n\n    /// Get a mutable reference to the inner writer (that is, the writer\n    /// wrapped by the BufWriter). Be careful with this writer, as writes to\n    /// it will bypass the buffer.\n    fn inner_mut(&mut self) -> &mut W {\n        self.buffer.get_mut()\n    }\n\n    /// Get the content currently buffered in self.buffer\n    fn buffered(&self) -> &[u8] {\n        self.buffer.buffer()\n    }\n\n    /// Flush the buffer iff the last byte is a newline (indicating that an\n    /// earlier write only succeeded partially, and we want to retry flushing\n    /// the buffered line before continuing with a subsequent write)\n    fn flush_if_completed_line(&mut self) -> io::Result<()> {\n        match self.buffered().last().copied() {\n            Some(b'\\n') => self.buffer.flush_buf(),\n            _ => Ok(()),\n        }\n    }\n}\n\nimpl<'a, W: Write> Write for LineWriterShim<'a, W> {\n    /// Write some data into this BufReader with line buffering. This means\n    /// that, if any newlines are present in the data, the data up to the last\n    /// newline is sent directly to the underlying writer, and data after it\n    /// is buffered. Returns the number of bytes written.\n    ///\n    /// This function operates on a \"best effort basis\"; in keeping with the\n    /// convention of `Write::write`, it makes at most one attempt to write\n    /// new data to the underlying writer. If that write only reports a partial\n    /// success, the remaining data will be buffered.\n    ///\n    /// Because this function attempts to send completed lines to the underlying\n    /// writer, it will also flush the existing buffer if it ends with a\n    /// newline, even if the incoming data does not contain any newlines.\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n            // If there are no new newlines (that is, if this write is less than\n            // one line), just do a regular buffered write (which may flush if\n            // we exceed the inner buffer's size)\n            None => {\n                self.flush_if_completed_line()?;\n                return self.buffer.write(buf);\n            }\n            // Otherwise, arrange for the lines to be written directly to the\n            // inner writer.\n            Some(newline_idx) => newline_idx + 1,\n        };\n\n        // Flush existing content to prepare for our write. We have to do this\n        // before attempting to write `buf` in order to maintain consistency;\n        // if we add `buf` to the buffer then try to flush it all at once,\n        // we're obligated to return Ok(), which would mean suppressing any\n        // errors that occur during flush.\n        self.buffer.flush_buf()?;\n\n        // This is what we're going to try to write directly to the inner\n        // writer. The rest will be buffered, if nothing goes wrong.\n        let lines = &buf[..newline_idx];\n\n        // Write `lines` directly to the inner writer. In keeping with the\n        // `write` convention, make at most one attempt to add new (unbuffered)\n        // data. Because this write doesn't touch the BufWriter state directly,\n        // and the buffer is known to be empty, we don't need to worry about\n        // self.buffer.panicked here.\n        let flushed = self.inner_mut().write(lines)?;\n\n        // If buffer returns Ok(0), propagate that to the caller without\n        // doing additional buffering; otherwise we're just guaranteeing\n        // an \"ErrorKind::WriteZero\" later.\n        if flushed == 0 {\n            return Ok(0);\n        }\n\n        // Now that the write has succeeded, buffer the rest (or as much of\n        // the rest as possible). If there were any unwritten newlines, we\n        // only buffer out to the last unwritten newline that fits in the\n        // buffer; this helps prevent flushing partial lines on subsequent\n        // calls to LineWriterShim::write.\n\n        // Handle the cases in order of most-common to least-common, under\n        // the presumption that most writes succeed in totality, and that most\n        // writes are smaller than the buffer.\n        // - Is this a partial line (ie, no newlines left in the unwritten tail)\n        // - If not, does the data out to the last unwritten newline fit in\n        //   the buffer?\n        // - If not, scan for the last newline that *does* fit in the buffer\n        let tail = if flushed >= newline_idx {\n            &buf[flushed..]\n        } else if newline_idx - flushed <= self.buffer.capacity() {\n            &buf[flushed..newline_idx]\n        } else {\n            let scan_area = &buf[flushed..];\n            let scan_area = &scan_area[..self.buffer.capacity()];\n            match memchr::memrchr(b'\\n', scan_area) {\n                Some(newline_idx) => &scan_area[..newline_idx + 1],\n                None => scan_area,\n            }\n        };\n\n        let buffered = self.buffer.write_to_buf(tail);\n        Ok(flushed + buffered)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.buffer.flush()\n    }\n\n    /// Write some vectored data into this BufReader with line buffering. This\n    /// means that, if any newlines are present in the data, the data up to\n    /// and including the buffer containing the last newline is sent directly\n    /// to the inner writer, and the data after it is buffered. Returns the\n    /// number of bytes written.\n    ///\n    /// This function operates on a \"best effort basis\"; in keeping with the\n    /// convention of `Write::write`, it makes at most one attempt to write\n    /// new data to the underlying writer.\n    ///\n    /// Because this function attempts to send completed lines to the underlying\n    /// writer, it will also flush the existing buffer if it contains any\n    /// newlines.\n    ///\n    /// Because sorting through an array of `IoSlice` can be a bit convoluted,\n    /// This method differs from write in the following ways:\n    ///\n    /// - It attempts to write the full content of all the buffers up to and\n    ///   including the one containing the last newline. This means that it\n    ///   may attempt to write a partial line, that buffer has data past the\n    ///   newline.\n    /// - If the write only reports partial success, it does not attempt to\n    ///   find the precise location of the written bytes and buffer the rest.\n    ///\n    /// If the underlying vector doesn't support vectored writing, we instead\n    /// simply write the first non-empty buffer with `write`. This way, we\n    /// get the benefits of more granular partial-line handling without losing\n    /// anything in efficiency\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        // If there's no specialized behavior for write_vectored, just use\n        // write. This has the benefit of more granular partial-line handling.\n        if !self.is_write_vectored() {\n            return match bufs.iter().find(|buf| !buf.is_empty()) {\n                Some(buf) => self.write(buf),\n                None => Ok(0),\n            };\n        }\n\n        // Find the buffer containing the last newline\n        let last_newline_buf_idx = bufs\n            .iter()\n            .enumerate()\n            .rev()\n            .find_map(|(i, buf)| memchr::memchr(b'\\n', buf).map(|_| i));\n\n        // If there are no new newlines (that is, if this write is less than\n        // one line), just do a regular buffered write\n        let last_newline_buf_idx = match last_newline_buf_idx {\n            // No newlines; just do a normal buffered write\n            None => {\n                self.flush_if_completed_line()?;\n                return self.buffer.write_vectored(bufs);\n            }\n            Some(i) => i,\n        };\n\n        // Flush existing content to prepare for our write\n        self.buffer.flush_buf()?;\n\n        // This is what we're going to try to write directly to the inner\n        // writer. The rest will be buffered, if nothing goes wrong.\n        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);\n\n        // Write `lines` directly to the inner writer. In keeping with the\n        // `write` convention, make at most one attempt to add new (unbuffered)\n        // data. Because this write doesn't touch the BufWriter state directly,\n        // and the buffer is known to be empty, we don't need to worry about\n        // self.panicked here.\n        let flushed = self.inner_mut().write_vectored(lines)?;\n\n        // If inner returns Ok(0), propagate that to the caller without\n        // doing additional buffering; otherwise we're just guaranteeing\n        // an \"ErrorKind::WriteZero\" later.\n        if flushed == 0 {\n            return Ok(0);\n        }\n\n        // Don't try to reconstruct the exact amount written; just bail\n        // in the event of a partial write\n        let lines_len = lines.iter().map(|buf| buf.len()).sum();\n        if flushed < lines_len {\n            return Ok(flushed);\n        }\n\n        // Now that the write has succeeded, buffer the rest (or as much of the\n        // rest as possible)\n        let buffered: usize = tail\n            .iter()\n            .filter(|buf| !buf.is_empty())\n            .map(|buf| self.buffer.write_to_buf(buf))\n            .take_while(|&n| n > 0)\n            .sum();\n\n        Ok(flushed + buffered)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        self.inner().is_write_vectored()\n    }\n\n    /// Write some data into this BufReader with line buffering. This means\n    /// that, if any newlines are present in the data, the data up to the last\n    /// newline is sent directly to the underlying writer, and data after it\n    /// is buffered.\n    ///\n    /// Because this function attempts to send completed lines to the underlying\n    /// writer, it will also flush the existing buffer if it contains any\n    /// newlines, even if the incoming data does not contain any newlines.\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        match memchr::memrchr(b'\\n', buf) {\n            // If there are no new newlines (that is, if this write is less than\n            // one line), just do a regular buffered write (which may flush if\n            // we exceed the inner buffer's size)\n            None => {\n                self.flush_if_completed_line()?;\n                self.buffer.write_all(buf)\n            }\n            Some(newline_idx) => {\n                let (lines, tail) = buf.split_at(newline_idx + 1);\n\n                if self.buffered().is_empty() {\n                    self.inner_mut().write_all(lines)?;\n                } else {\n                    // If there is any buffered data, we add the incoming lines\n                    // to that buffer before flushing, which saves us at least\n                    // one write call. We can't really do this with `write`,\n                    // since we can't do this *and* not suppress errors *and*\n                    // report a consistent state to the caller in a return\n                    // value, but here in write_all it's fine.\n                    self.buffer.write_all(lines)?;\n                    self.buffer.flush_buf()?;\n                }\n\n                self.buffer.write_all(tail)\n            }\n        }\n    }\n}\n"],["2575","use crate::error;\nuse crate::fmt;\nuse crate::io::{\n    self, Error, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n};\nuse crate::mem;\nuse crate::ptr;\n\n/// Wraps a writer and buffers its output.\n///\n/// It can be excessively inefficient to work directly with something that\n/// implements [`Write`]. For example, every call to\n/// [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call. A\n/// `BufWriter<W>` keeps an in-memory buffer of data and writes it to an underlying\n/// writer in large, infrequent batches.\n///\n/// `BufWriter<W>` can improve the speed of programs that make *small* and\n/// *repeated* write calls to the same file or network socket. It does not\n/// help when writing very large amounts at once, or writing just one or a few\n/// times. It also provides no advantage when writing to a destination that is\n/// in memory, like a [`Vec`]`<u8>`.\n///\n/// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n/// dropping will attempt to flush the contents of the buffer, any errors\n/// that happen in the process of dropping will be ignored. Calling [`flush`]\n/// ensures that the buffer is empty and thus dropping will not even attempt\n/// file operations.\n///\n/// # Examples\n///\n/// Let's write the numbers one through ten to a [`TcpStream`]:\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::net::TcpStream;\n///\n/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n///\n/// for i in 0..10 {\n///     stream.write(&[i+1]).unwrap();\n/// }\n/// ```\n///\n/// Because we're not buffering, we write each one in turn, incurring the\n/// overhead of a system call per byte written. We can fix this with a\n/// `BufWriter<W>`:\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::BufWriter;\n/// use std::net::TcpStream;\n///\n/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n///\n/// for i in 0..10 {\n///     stream.write(&[i+1]).unwrap();\n/// }\n/// stream.flush().unwrap();\n/// ```\n///\n/// By wrapping the stream with a `BufWriter<W>`, these ten writes are all grouped\n/// together by the buffer and will all be written out in one system call when\n/// the `stream` is flushed.\n///\n// HACK(#78696): can't use `crate` for associated items\n/// [`TcpStream::write`]: super::super::super::net::TcpStream::write\n/// [`TcpStream`]: crate::net::TcpStream\n/// [`flush`]: BufWriter::flush\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BufWriter<W: Write> {\n    inner: Option<W>,\n    // The buffer. Avoid using this like a normal `Vec` in common code paths.\n    // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other\n    // methods that require bounds checking or the like. This makes an enormous\n    // difference to performance (we may want to stop using a `Vec` entirely).\n    buf: Vec<u8>,\n    // #30888: If the inner writer panics in a call to write, we don't want to\n    // write the buffered data a second time in BufWriter's destructor. This\n    // flag tells the Drop impl if it should skip the flush.\n    panicked: bool,\n}\n\nimpl<W: Write> BufWriter<W> {\n    /// Creates a new `BufWriter<W>` with a default buffer capacity. The default is currently 8 KB,\n    /// but may change in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: W) -> BufWriter<W> {\n        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n    }\n\n    /// Creates a new `BufWriter<W>` with the specified buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// Creating a buffer with a buffer of a hundred bytes.\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n    /// let mut buffer = BufWriter::with_capacity(100, stream);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {\n        BufWriter { inner: Some(inner), buf: Vec::with_capacity(capacity), panicked: false }\n    }\n\n    /// Send data in our local buffer into the inner writer, looping as\n    /// necessary until either it's all been sent or an error occurs.\n    ///\n    /// Because all the data in the buffer has been reported to our owner as\n    /// \"successfully written\" (by returning nonzero success values from\n    /// `write`), any 0-length writes from `inner` must be reported as i/o\n    /// errors from this method.\n    pub(in crate::io) fn flush_buf(&mut self) -> io::Result<()> {\n        /// Helper struct to ensure the buffer is updated after all the writes\n        /// are complete. It tracks the number of written bytes and drains them\n        /// all from the front of the buffer when dropped.\n        struct BufGuard<'a> {\n            buffer: &'a mut Vec<u8>,\n            written: usize,\n        }\n\n        impl<'a> BufGuard<'a> {\n            fn new(buffer: &'a mut Vec<u8>) -> Self {\n                Self { buffer, written: 0 }\n            }\n\n            /// The unwritten part of the buffer\n            fn remaining(&self) -> &[u8] {\n                &self.buffer[self.written..]\n            }\n\n            /// Flag some bytes as removed from the front of the buffer\n            fn consume(&mut self, amt: usize) {\n                self.written += amt;\n            }\n\n            /// true if all of the bytes have been written\n            fn done(&self) -> bool {\n                self.written >= self.buffer.len()\n            }\n        }\n\n        impl Drop for BufGuard<'_> {\n            fn drop(&mut self) {\n                if self.written > 0 {\n                    self.buffer.drain(..self.written);\n                }\n            }\n        }\n\n        let mut guard = BufGuard::new(&mut self.buf);\n        let inner = self.inner.as_mut().unwrap();\n        while !guard.done() {\n            self.panicked = true;\n            let r = inner.write(guard.remaining());\n            self.panicked = false;\n\n            match r {\n                Ok(0) => {\n                    return Err(Error::new_const(\n                        ErrorKind::WriteZero,\n                        &\"failed to write the buffered data\",\n                    ));\n                }\n                Ok(n) => guard.consume(n),\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Buffer some data without flushing it, regardless of the size of the\n    /// data. Writes as much as possible without exceeding capacity. Returns\n    /// the number of bytes written.\n    pub(super) fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n        let available = self.spare_capacity();\n        let amt_to_buffer = available.min(buf.len());\n\n        // SAFETY: `amt_to_buffer` is <= buffer's spare capacity by construction.\n        unsafe {\n            self.write_to_buffer_unchecked(&buf[..amt_to_buffer]);\n        }\n\n        amt_to_buffer\n    }\n\n    /// Gets a reference to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // we can use reference just like buffer\n    /// let reference = buffer.get_ref();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &W {\n        self.inner.as_ref().unwrap()\n    }\n\n    /// Gets a mutable reference to the underlying writer.\n    ///\n    /// It is inadvisable to directly write to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // we can use reference just like buffer\n    /// let reference = buffer.get_mut();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.as_mut().unwrap()\n    }\n\n    /// Returns a reference to the internally buffered data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // See how many bytes are currently buffered\n    /// let bytes_buffered = buf_writer.buffer().len();\n    /// ```\n    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n    pub fn buffer(&self) -> &[u8] {\n        &self.buf\n    }\n\n    /// Returns a mutable reference to the internal buffer.\n    ///\n    /// This can be used to write data directly into the buffer without triggering writers\n    /// to the underlying writer.\n    ///\n    /// That the buffer is a `Vec` is an implementation detail.\n    /// Callers should not modify the capacity as there currently is no public API to do so\n    /// and thus any capacity changes would be unexpected by the user.\n    pub(in crate::io) fn buffer_mut(&mut self) -> &mut Vec<u8> {\n        &mut self.buf\n    }\n\n    /// Returns the number of bytes the internal buffer can hold without flushing.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // Check the capacity of the inner buffer\n    /// let capacity = buf_writer.capacity();\n    /// // Calculate how many bytes can be written without flushing\n    /// let without_flush = capacity - buf_writer.buffer().len();\n    /// ```\n    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n    pub fn capacity(&self) -> usize {\n        self.buf.capacity()\n    }\n\n    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n    ///\n    /// The buffer is written out before returning the writer.\n    ///\n    /// # Errors\n    ///\n    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // unwrap the TcpStream and flush the buffer\n    /// let stream = buffer.into_inner().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n        match self.flush_buf() {\n            Err(e) => Err(IntoInnerError::new(self, e)),\n            Ok(()) => Ok(self.inner.take().unwrap()),\n        }\n    }\n\n    /// Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n    /// unwritten data.\n    ///\n    /// If the underlying writer panicked, it is not known what portion of the data was written.\n    /// In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n    /// contents can still be recovered).\n    ///\n    /// `into_raw_parts` makes no attempt to flush data and cannot fail.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(bufwriter_into_raw_parts)]\n    /// use std::io::{BufWriter, Write};\n    ///\n    /// let mut buffer = [0u8; 10];\n    /// let mut stream = BufWriter::new(buffer.as_mut());\n    /// write!(stream, \"too much data\").unwrap();\n    /// stream.flush().expect_err(\"it doesn't fit\");\n    /// let (recovered_writer, buffered_data) = stream.into_raw_parts();\n    /// assert_eq!(recovered_writer.len(), 0);\n    /// assert_eq!(&buffered_data.unwrap(), b\"ata\");\n    /// ```\n    #[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n    pub fn into_raw_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n        let buf = mem::take(&mut self.buf);\n        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n        (self.inner.take().unwrap(), buf)\n    }\n\n    // Ensure this function does not get inlined into `write`, so that it\n    // remains inlineable and its common path remains as short as possible.\n    // If this function ends up being called frequently relative to `write`,\n    // it's likely a sign that the client is using an improperly sized buffer\n    // or their write patterns are somewhat pathological.\n    #[cold]\n    #[inline(never)]\n    fn write_cold(&mut self, buf: &[u8]) -> io::Result<usize> {\n        if buf.len() > self.spare_capacity() {\n            self.flush_buf()?;\n        }\n\n        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n        if buf.len() >= self.buf.capacity() {\n            self.panicked = true;\n            let r = self.get_mut().write(buf);\n            self.panicked = false;\n            r\n        } else {\n            // Write to the buffer. In this case, we write to the buffer even if it fills it\n            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n            // input to the inner writer, which in many cases would be a worse strategy.\n\n            // SAFETY: There was either enough spare capacity already, or there wasn't and we\n            // flushed the buffer to ensure that there is. In the latter case, we know that there\n            // is because flushing ensured that our entire buffer is spare capacity, and we entered\n            // this block because the input buffer length is less than that capacity. In either\n            // case, it's safe to write the input buffer to our buffer.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(buf.len())\n        }\n    }\n\n    // Ensure this function does not get inlined into `write_all`, so that it\n    // remains inlineable and its common path remains as short as possible.\n    // If this function ends up being called frequently relative to `write_all`,\n    // it's likely a sign that the client is using an improperly sized buffer\n    // or their write patterns are somewhat pathological.\n    #[cold]\n    #[inline(never)]\n    fn write_all_cold(&mut self, buf: &[u8]) -> io::Result<()> {\n        // Normally, `write_all` just calls `write` in a loop. We can do better\n        // by calling `self.get_mut().write_all()` directly, which avoids\n        // round trips through the buffer in the event of a series of partial\n        // writes in some circumstances.\n\n        if buf.len() > self.spare_capacity() {\n            self.flush_buf()?;\n        }\n\n        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n        if buf.len() >= self.buf.capacity() {\n            self.panicked = true;\n            let r = self.get_mut().write_all(buf);\n            self.panicked = false;\n            r\n        } else {\n            // Write to the buffer. In this case, we write to the buffer even if it fills it\n            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n            // input to the inner writer, which in many cases would be a worse strategy.\n\n            // SAFETY: There was either enough spare capacity already, or there wasn't and we\n            // flushed the buffer to ensure that there is. In the latter case, we know that there\n            // is because flushing ensured that our entire buffer is spare capacity, and we entered\n            // this block because the input buffer length is less than that capacity. In either\n            // case, it's safe to write the input buffer to our buffer.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(())\n        }\n    }\n\n    // SAFETY: Requires `buf.len() <= self.buf.capacity() - self.buf.len()`,\n    // i.e., that input buffer length is less than or equal to spare capacity.\n    #[inline]\n    unsafe fn write_to_buffer_unchecked(&mut self, buf: &[u8]) {\n        debug_assert!(buf.len() <= self.spare_capacity());\n        let old_len = self.buf.len();\n        let buf_len = buf.len();\n        let src = buf.as_ptr();\n        let dst = self.buf.as_mut_ptr().add(old_len);\n        ptr::copy_nonoverlapping(src, dst, buf_len);\n        self.buf.set_len(old_len + buf_len);\n    }\n\n    #[inline]\n    fn spare_capacity(&self) -> usize {\n        self.buf.capacity() - self.buf.len()\n    }\n}\n\n#[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n/// Error returned for the buffered data from `BufWriter::into_raw_parts`, when the underlying\n/// writer has previously panicked.  Contains the (possibly partly written) buffered data.\n///\n/// # Example\n///\n/// ```\n/// #![feature(bufwriter_into_raw_parts)]\n/// use std::io::{self, BufWriter, Write};\n/// use std::panic::{catch_unwind, AssertUnwindSafe};\n///\n/// struct PanickingWriter;\n/// impl Write for PanickingWriter {\n///   fn write(&mut self, buf: &[u8]) -> io::Result<usize> { panic!() }\n///   fn flush(&mut self) -> io::Result<()> { panic!() }\n/// }\n///\n/// let mut stream = BufWriter::new(PanickingWriter);\n/// write!(stream, \"some data\").unwrap();\n/// let result = catch_unwind(AssertUnwindSafe(|| {\n///     stream.flush().unwrap()\n/// }));\n/// assert!(result.is_err());\n/// let (recovered_writer, buffered_data) = stream.into_raw_parts();\n/// assert!(matches!(recovered_writer, PanickingWriter));\n/// assert_eq!(buffered_data.unwrap_err().into_inner(), b\"some data\");\n/// ```\npub struct WriterPanicked {\n    buf: Vec<u8>,\n}\n\nimpl WriterPanicked {\n    /// Returns the perhaps-unwritten data.  Some of this data may have been written by the\n    /// panicking call(s) to the underlying writer, so simply writing it again is not a good idea.\n    #[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n    pub fn into_inner(self) -> Vec<u8> {\n        self.buf\n    }\n\n    const DESCRIPTION: &'static str =\n        \"BufWriter inner writer panicked, what data remains unwritten is not known\";\n}\n\n#[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\nimpl error::Error for WriterPanicked {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        Self::DESCRIPTION\n    }\n}\n\n#[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\nimpl fmt::Display for WriterPanicked {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", Self::DESCRIPTION)\n    }\n}\n\n#[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\nimpl fmt::Debug for WriterPanicked {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"WriterPanicked\")\n            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Write for BufWriter<W> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n        // See `write_cold` for details.\n        if buf.len() < self.spare_capacity() {\n            // SAFETY: safe by above conditional.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(buf.len())\n        } else {\n            self.write_cold(buf)\n        }\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n        // See `write_all_cold` for details.\n        if buf.len() < self.spare_capacity() {\n            // SAFETY: safe by above conditional.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(())\n        } else {\n            self.write_all_cold(buf)\n        }\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        // FIXME: Consider applying `#[inline]` / `#[inline(never)]` optimizations already applied\n        // to `write` and `write_all`. The performance benefits can be significant. See #79930.\n        if self.get_ref().is_write_vectored() {\n            // We have to handle the possibility that the total length of the buffers overflows\n            // `usize` (even though this can only happen if multiple `IoSlice`s reference the\n            // same underlying buffer, as otherwise the buffers wouldn't fit in memory). If the\n            // computation overflows, then surely the input cannot fit in our buffer, so we forward\n            // to the inner writer's `write_vectored` method to let it handle it appropriately.\n            let saturated_total_len =\n                bufs.iter().fold(0usize, |acc, b| acc.saturating_add(b.len()));\n\n            if saturated_total_len > self.spare_capacity() {\n                // Flush if the total length of the input exceeds our buffer's spare capacity.\n                // If we would have overflowed, this condition also holds, and we need to flush.\n                self.flush_buf()?;\n            }\n\n            if saturated_total_len >= self.buf.capacity() {\n                // Forward to our inner writer if the total length of the input is greater than or\n                // equal to our buffer capacity. If we would have overflowed, this condition also\n                // holds, and we punt to the inner writer.\n                self.panicked = true;\n                let r = self.get_mut().write_vectored(bufs);\n                self.panicked = false;\n                r\n            } else {\n                // `saturated_total_len < self.buf.capacity()` implies that we did not saturate.\n\n                // SAFETY: We checked whether or not the spare capacity was large enough above. If\n                // it was, then we're safe already. If it wasn't, we flushed, making sufficient\n                // room for any input <= the buffer size, which includes this input.\n                unsafe {\n                    bufs.iter().for_each(|b| self.write_to_buffer_unchecked(b));\n                };\n\n                Ok(saturated_total_len)\n            }\n        } else {\n            let mut iter = bufs.iter();\n            let mut total_written = if let Some(buf) = iter.by_ref().find(|&buf| !buf.is_empty()) {\n                // This is the first non-empty slice to write, so if it does\n                // not fit in the buffer, we still get to flush and proceed.\n                if buf.len() > self.spare_capacity() {\n                    self.flush_buf()?;\n                }\n                if buf.len() >= self.buf.capacity() {\n                    // The slice is at least as large as the buffering capacity,\n                    // so it's better to write it directly, bypassing the buffer.\n                    self.panicked = true;\n                    let r = self.get_mut().write(buf);\n                    self.panicked = false;\n                    return r;\n                } else {\n                    // SAFETY: We checked whether or not the spare capacity was large enough above.\n                    // If it was, then we're safe already. If it wasn't, we flushed, making\n                    // sufficient room for any input <= the buffer size, which includes this input.\n                    unsafe {\n                        self.write_to_buffer_unchecked(buf);\n                    }\n\n                    buf.len()\n                }\n            } else {\n                return Ok(0);\n            };\n            debug_assert!(total_written != 0);\n            for buf in iter {\n                if buf.len() <= self.spare_capacity() {\n                    // SAFETY: safe by above conditional.\n                    unsafe {\n                        self.write_to_buffer_unchecked(buf);\n                    }\n\n                    // This cannot overflow `usize`. If we are here, we've written all of the bytes\n                    // so far to our buffer, and we've ensured that we never exceed the buffer's\n                    // capacity. Therefore, `total_written` <= `self.buf.capacity()` <= `usize::MAX`.\n                    total_written += buf.len();\n                } else {\n                    break;\n                }\n            }\n            Ok(total_written)\n        }\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.flush_buf().and_then(|()| self.get_mut().flush())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> fmt::Debug for BufWriter<W>\nwhere\n    W: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"BufWriter\")\n            .field(\"writer\", &self.inner.as_ref().unwrap())\n            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + Seek> Seek for BufWriter<W> {\n    /// Seek to the offset, in bytes, in the underlying writer.\n    ///\n    /// Seeking always writes out the internal buffer before seeking.\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        self.flush_buf()?;\n        self.get_mut().seek(pos)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Drop for BufWriter<W> {\n    fn drop(&mut self) {\n        if self.inner.is_some() && !self.panicked {\n            // dtors should not panic, so we ignore a failed flush\n            let _r = self.flush_buf();\n        }\n    }\n}\n"],["2576","use crate::io::prelude::*;\nuse crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, SeekFrom};\nuse crate::panic;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::thread;\n\n/// A dummy reader intended at testing short-reads propagation.\npub struct ShortReader {\n    lengths: Vec<usize>,\n}\n\n// FIXME: rustfmt and tidy disagree about the correct formatting of this\n// function. This leads to issues for users with editors configured to\n// rustfmt-on-save.\nimpl Read for ShortReader {\n    fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n        if self.lengths.is_empty() { Ok(0) } else { Ok(self.lengths.remove(0)) }\n    }\n}\n\n#[test]\nfn test_buffered_reader() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(2, inner);\n\n    let mut buf = [0, 0, 0];\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 3);\n    assert_eq!(buf, [5, 6, 7]);\n    assert_eq!(reader.buffer(), []);\n\n    let mut buf = [0, 0];\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 2);\n    assert_eq!(buf, [0, 1]);\n    assert_eq!(reader.buffer(), []);\n\n    let mut buf = [0];\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 1);\n    assert_eq!(buf, [2]);\n    assert_eq!(reader.buffer(), [3]);\n\n    let mut buf = [0, 0, 0];\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 1);\n    assert_eq!(buf, [3, 0, 0]);\n    assert_eq!(reader.buffer(), []);\n\n    let nread = reader.read(&mut buf);\n    assert_eq!(nread.unwrap(), 1);\n    assert_eq!(buf, [4, 0, 0]);\n    assert_eq!(reader.buffer(), []);\n\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_buffered_reader_seek() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n\n    assert_eq!(reader.seek(SeekFrom::Start(3)).ok(), Some(3));\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(3));\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert_eq!(reader.seek(SeekFrom::Current(1)).ok(), Some(4));\n    assert_eq!(reader.fill_buf().ok(), Some(&[1, 2][..]));\n    reader.consume(1);\n    assert_eq!(reader.seek(SeekFrom::Current(-2)).ok(), Some(3));\n}\n\n#[test]\nfn test_buffered_reader_seek_relative() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n\n    assert!(reader.seek_relative(3).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert!(reader.seek_relative(0).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert!(reader.seek_relative(1).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[1][..]));\n    assert!(reader.seek_relative(-1).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert!(reader.seek_relative(2).is_ok());\n    assert_eq!(reader.fill_buf().ok(), Some(&[2, 3][..]));\n}\n\n#[test]\nfn test_buffered_reader_stream_position() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n\n    assert_eq!(reader.stream_position().ok(), Some(0));\n    assert_eq!(reader.seek(SeekFrom::Start(3)).ok(), Some(3));\n    assert_eq!(reader.stream_position().ok(), Some(3));\n    // relative seeking within the buffer and reading position should keep the buffer\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n    assert!(reader.seek_relative(0).is_ok());\n    assert_eq!(reader.stream_position().ok(), Some(3));\n    assert_eq!(reader.buffer(), &[0, 1][..]);\n    assert!(reader.seek_relative(1).is_ok());\n    assert_eq!(reader.stream_position().ok(), Some(4));\n    assert_eq!(reader.buffer(), &[1][..]);\n    assert!(reader.seek_relative(-1).is_ok());\n    assert_eq!(reader.stream_position().ok(), Some(3));\n    assert_eq!(reader.buffer(), &[0, 1][..]);\n    // relative seeking outside the buffer will discard it\n    assert!(reader.seek_relative(2).is_ok());\n    assert_eq!(reader.stream_position().ok(), Some(5));\n    assert_eq!(reader.buffer(), &[][..]);\n}\n\n#[test]\nfn test_buffered_reader_stream_position_panic() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(4, io::Cursor::new(inner));\n\n    // cause internal buffer to be filled but read only partially\n    let mut buffer = [0, 0];\n    assert!(reader.read_exact(&mut buffer).is_ok());\n    // rewinding the internal reader will cause buffer to loose sync\n    let inner = reader.get_mut();\n    assert!(inner.seek(SeekFrom::Start(0)).is_ok());\n    // overflow when subtracting the remaining buffer size from current position\n    let result = panic::catch_unwind(panic::AssertUnwindSafe(|| reader.stream_position().ok()));\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_buffered_reader_invalidated_after_read() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n\n    assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n    reader.consume(3);\n\n    let mut buffer = [0, 0, 0, 0, 0];\n    assert_eq!(reader.read(&mut buffer).ok(), Some(5));\n    assert_eq!(buffer, [0, 1, 2, 3, 4]);\n\n    assert!(reader.seek_relative(-2).is_ok());\n    let mut buffer = [0, 0];\n    assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n    assert_eq!(buffer, [3, 4]);\n}\n\n#[test]\nfn test_buffered_reader_invalidated_after_seek() {\n    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n    let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n\n    assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n    reader.consume(3);\n\n    assert!(reader.seek(SeekFrom::Current(5)).is_ok());\n\n    assert!(reader.seek_relative(-2).is_ok());\n    let mut buffer = [0, 0];\n    assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n    assert_eq!(buffer, [3, 4]);\n}\n\n#[test]\nfn test_buffered_reader_seek_underflow() {\n    // gimmick reader that yields its position modulo 256 for each byte\n    struct PositionReader {\n        pos: u64,\n    }\n    impl Read for PositionReader {\n        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n            let len = buf.len();\n            for x in buf {\n                *x = self.pos as u8;\n                self.pos = self.pos.wrapping_add(1);\n            }\n            Ok(len)\n        }\n    }\n    impl Seek for PositionReader {\n        fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n            match pos {\n                SeekFrom::Start(n) => {\n                    self.pos = n;\n                }\n                SeekFrom::Current(n) => {\n                    self.pos = self.pos.wrapping_add(n as u64);\n                }\n                SeekFrom::End(n) => {\n                    self.pos = u64::MAX.wrapping_add(n as u64);\n                }\n            }\n            Ok(self.pos)\n        }\n    }\n\n    let mut reader = BufReader::with_capacity(5, PositionReader { pos: 0 });\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2, 3, 4][..]));\n    assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::MAX - 5));\n    assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n    // the following seek will require two underlying seeks\n    let expected = 9223372036854775802;\n    assert_eq!(reader.seek(SeekFrom::Current(i64::MIN)).ok(), Some(expected));\n    assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n    // seeking to 0 should empty the buffer.\n    assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(expected));\n    assert_eq!(reader.get_ref().pos, expected);\n}\n\n#[test]\nfn test_buffered_reader_seek_underflow_discard_buffer_between_seeks() {\n    // gimmick reader that returns Err after first seek\n    struct ErrAfterFirstSeekReader {\n        first_seek: bool,\n    }\n    impl Read for ErrAfterFirstSeekReader {\n        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n            for x in &mut *buf {\n                *x = 0;\n            }\n            Ok(buf.len())\n        }\n    }\n    impl Seek for ErrAfterFirstSeekReader {\n        fn seek(&mut self, _: SeekFrom) -> io::Result<u64> {\n            if self.first_seek {\n                self.first_seek = false;\n                Ok(0)\n            } else {\n                Err(io::Error::new(io::ErrorKind::Other, \"oh no!\"))\n            }\n        }\n    }\n\n    let mut reader = BufReader::with_capacity(5, ErrAfterFirstSeekReader { first_seek: true });\n    assert_eq!(reader.fill_buf().ok(), Some(&[0, 0, 0, 0, 0][..]));\n\n    // The following seek will require two underlying seeks.  The first will\n    // succeed but the second will fail.  This should still invalidate the\n    // buffer.\n    assert!(reader.seek(SeekFrom::Current(i64::MIN)).is_err());\n    assert_eq!(reader.buffer().len(), 0);\n}\n\n#[test]\nfn test_buffered_writer() {\n    let inner = Vec::new();\n    let mut writer = BufWriter::with_capacity(2, inner);\n\n    writer.write(&[0, 1]).unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1]);\n\n    writer.write(&[2]).unwrap();\n    assert_eq!(writer.buffer(), [2]);\n    assert_eq!(*writer.get_ref(), [0, 1]);\n\n    writer.write(&[3]).unwrap();\n    assert_eq!(writer.buffer(), [2, 3]);\n    assert_eq!(*writer.get_ref(), [0, 1]);\n\n    writer.flush().unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n\n    writer.write(&[4]).unwrap();\n    writer.write(&[5]).unwrap();\n    assert_eq!(writer.buffer(), [4, 5]);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n\n    writer.write(&[6]).unwrap();\n    assert_eq!(writer.buffer(), [6]);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5]);\n\n    writer.write(&[7, 8]).unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8]);\n\n    writer.write(&[9, 10, 11]).unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n\n    writer.flush().unwrap();\n    assert_eq!(writer.buffer(), []);\n    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n}\n\n#[test]\nfn test_buffered_writer_inner_flushes() {\n    let mut w = BufWriter::with_capacity(3, Vec::new());\n    w.write(&[0, 1]).unwrap();\n    assert_eq!(*w.get_ref(), []);\n    let w = w.into_inner().unwrap();\n    assert_eq!(w, [0, 1]);\n}\n\n#[test]\nfn test_buffered_writer_seek() {\n    let mut w = BufWriter::with_capacity(3, io::Cursor::new(Vec::new()));\n    w.write_all(&[0, 1, 2, 3, 4, 5]).unwrap();\n    w.write_all(&[6, 7]).unwrap();\n    assert_eq!(w.seek(SeekFrom::Current(0)).ok(), Some(8));\n    assert_eq!(&w.get_ref().get_ref()[..], &[0, 1, 2, 3, 4, 5, 6, 7][..]);\n    assert_eq!(w.seek(SeekFrom::Start(2)).ok(), Some(2));\n    w.write_all(&[8, 9]).unwrap();\n    assert_eq!(&w.into_inner().unwrap().into_inner()[..], &[0, 1, 8, 9, 4, 5, 6, 7]);\n}\n\n#[test]\nfn test_read_until() {\n    let inner: &[u8] = &[0, 1, 2, 1, 0];\n    let mut reader = BufReader::with_capacity(2, inner);\n    let mut v = Vec::new();\n    reader.read_until(0, &mut v).unwrap();\n    assert_eq!(v, [0]);\n    v.truncate(0);\n    reader.read_until(2, &mut v).unwrap();\n    assert_eq!(v, [1, 2]);\n    v.truncate(0);\n    reader.read_until(1, &mut v).unwrap();\n    assert_eq!(v, [1]);\n    v.truncate(0);\n    reader.read_until(8, &mut v).unwrap();\n    assert_eq!(v, [0]);\n    v.truncate(0);\n    reader.read_until(9, &mut v).unwrap();\n    assert_eq!(v, []);\n}\n\n#[test]\nfn test_line_buffer() {\n    let mut writer = LineWriter::new(Vec::new());\n    writer.write(&[0]).unwrap();\n    assert_eq!(*writer.get_ref(), []);\n    writer.write(&[1]).unwrap();\n    assert_eq!(*writer.get_ref(), []);\n    writer.flush().unwrap();\n    assert_eq!(*writer.get_ref(), [0, 1]);\n    writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n    assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n']);\n    writer.flush().unwrap();\n    assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2]);\n    writer.write(&[3, b'\\n']).unwrap();\n    assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n}\n\n#[test]\nfn test_read_line() {\n    let in_buf: &[u8] = b\"a\\nb\\nc\";\n    let mut reader = BufReader::with_capacity(2, in_buf);\n    let mut s = String::new();\n    reader.read_line(&mut s).unwrap();\n    assert_eq!(s, \"a\\n\");\n    s.truncate(0);\n    reader.read_line(&mut s).unwrap();\n    assert_eq!(s, \"b\\n\");\n    s.truncate(0);\n    reader.read_line(&mut s).unwrap();\n    assert_eq!(s, \"c\");\n    s.truncate(0);\n    reader.read_line(&mut s).unwrap();\n    assert_eq!(s, \"\");\n}\n\n#[test]\nfn test_lines() {\n    let in_buf: &[u8] = b\"a\\nb\\nc\";\n    let reader = BufReader::with_capacity(2, in_buf);\n    let mut it = reader.lines();\n    assert_eq!(it.next().unwrap().unwrap(), \"a\".to_string());\n    assert_eq!(it.next().unwrap().unwrap(), \"b\".to_string());\n    assert_eq!(it.next().unwrap().unwrap(), \"c\".to_string());\n    assert!(it.next().is_none());\n}\n\n#[test]\nfn test_short_reads() {\n    let inner = ShortReader { lengths: vec![0, 1, 2, 0, 1, 0] };\n    let mut reader = BufReader::new(inner);\n    let mut buf = [0, 0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.read(&mut buf).unwrap(), 2);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\n#[should_panic]\nfn dont_panic_in_drop_on_panicked_flush() {\n    struct FailFlushWriter;\n\n    impl Write for FailFlushWriter {\n        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n            Ok(buf.len())\n        }\n        fn flush(&mut self) -> io::Result<()> {\n            Err(io::Error::last_os_error())\n        }\n    }\n\n    let writer = FailFlushWriter;\n    let _writer = BufWriter::new(writer);\n\n    // If writer panics *again* due to the flush error then the process will\n    // abort.\n    panic!();\n}\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn panic_in_write_doesnt_flush_in_drop() {\n    static WRITES: AtomicUsize = AtomicUsize::new(0);\n\n    struct PanicWriter;\n\n    impl Write for PanicWriter {\n        fn write(&mut self, _: &[u8]) -> io::Result<usize> {\n            WRITES.fetch_add(1, Ordering::SeqCst);\n            panic!();\n        }\n        fn flush(&mut self) -> io::Result<()> {\n            Ok(())\n        }\n    }\n\n    thread::spawn(|| {\n        let mut writer = BufWriter::new(PanicWriter);\n        let _ = writer.write(b\"hello world\");\n        let _ = writer.flush();\n    })\n    .join()\n    .unwrap_err();\n\n    assert_eq!(WRITES.load(Ordering::SeqCst), 1);\n}\n\n#[bench]\nfn bench_buffered_reader(b: &mut test::Bencher) {\n    b.iter(|| BufReader::new(io::empty()));\n}\n\n#[bench]\nfn bench_buffered_reader_small_reads(b: &mut test::Bencher) {\n    let data = (0..u8::MAX).cycle().take(1024 * 4).collect::<Vec<_>>();\n    b.iter(|| {\n        let mut reader = BufReader::new(&data[..]);\n        let mut buf = [0u8; 4];\n        for _ in 0..1024 {\n            reader.read_exact(&mut buf).unwrap();\n        }\n    });\n}\n\n#[bench]\nfn bench_buffered_writer(b: &mut test::Bencher) {\n    b.iter(|| BufWriter::new(io::sink()));\n}\n\n/// A simple `Write` target, designed to be wrapped by `LineWriter` /\n/// `BufWriter` / etc, that can have its `write` & `flush` behavior\n/// configured\n#[derive(Default, Clone)]\nstruct ProgrammableSink {\n    // Writes append to this slice\n    pub buffer: Vec<u8>,\n\n    // Flush sets this flag\n    pub flushed: bool,\n\n    // If true, writes will always be an error\n    pub always_write_error: bool,\n\n    // If true, flushes will always be an error\n    pub always_flush_error: bool,\n\n    // If set, only up to this number of bytes will be written in a single\n    // call to `write`\n    pub accept_prefix: Option<usize>,\n\n    // If set, counts down with each write, and writes return an error\n    // when it hits 0\n    pub max_writes: Option<usize>,\n\n    // If set, attempting to write when max_writes == Some(0) will be an\n    // error; otherwise, it will return Ok(0).\n    pub error_after_max_writes: bool,\n}\n\nimpl Write for ProgrammableSink {\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n        if self.always_write_error {\n            return Err(io::Error::new(io::ErrorKind::Other, \"test - always_write_error\"));\n        }\n\n        match self.max_writes {\n            Some(0) if self.error_after_max_writes => {\n                return Err(io::Error::new(io::ErrorKind::Other, \"test - max_writes\"));\n            }\n            Some(0) => return Ok(0),\n            Some(ref mut count) => *count -= 1,\n            None => {}\n        }\n\n        let len = match self.accept_prefix {\n            None => data.len(),\n            Some(prefix) => data.len().min(prefix),\n        };\n\n        let data = &data[..len];\n        self.buffer.extend_from_slice(data);\n\n        Ok(len)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        if self.always_flush_error {\n            Err(io::Error::new(io::ErrorKind::Other, \"test - always_flush_error\"))\n        } else {\n            self.flushed = true;\n            Ok(())\n        }\n    }\n}\n\n/// Previously the `LineWriter` could successfully write some bytes but\n/// then fail to report that it has done so. Additionally, an erroneous\n/// flush after a successful write was permanently ignored.\n///\n/// Test that a line writer correctly reports the number of written bytes,\n/// and that it attempts to flush buffered lines from previous writes\n/// before processing new data\n///\n/// Regression test for #37807\n#[test]\nfn erroneous_flush_retried() {\n    let writer = ProgrammableSink {\n        // Only write up to 4 bytes at a time\n        accept_prefix: Some(4),\n\n        // Accept the first two writes, then error the others\n        max_writes: Some(2),\n        error_after_max_writes: true,\n\n        ..Default::default()\n    };\n\n    // This should write the first 4 bytes. The rest will be buffered, out\n    // to the last newline.\n    let mut writer = LineWriter::new(writer);\n    assert_eq!(writer.write(b\"a\\nb\\nc\\nd\\ne\").unwrap(), 8);\n\n    // This write should attempt to flush \"c\\nd\\n\", then buffer \"e\". No\n    // errors should happen here because no further writes should be\n    // attempted against `writer`.\n    assert_eq!(writer.write(b\"e\").unwrap(), 1);\n    assert_eq!(&writer.get_ref().buffer, b\"a\\nb\\nc\\nd\\n\");\n}\n\n#[test]\nfn line_vectored() {\n    let mut a = LineWriter::new(Vec::new());\n    assert_eq!(\n        a.write_vectored(&[\n            IoSlice::new(&[]),\n            IoSlice::new(b\"\\n\"),\n            IoSlice::new(&[]),\n            IoSlice::new(b\"a\"),\n        ])\n        .unwrap(),\n        2,\n    );\n    assert_eq!(a.get_ref(), b\"\\n\");\n\n    assert_eq!(\n        a.write_vectored(&[\n            IoSlice::new(&[]),\n            IoSlice::new(b\"b\"),\n            IoSlice::new(&[]),\n            IoSlice::new(b\"a\"),\n            IoSlice::new(&[]),\n            IoSlice::new(b\"c\"),\n        ])\n        .unwrap(),\n        3,\n    );\n    assert_eq!(a.get_ref(), b\"\\n\");\n    a.flush().unwrap();\n    assert_eq!(a.get_ref(), b\"\\nabac\");\n    assert_eq!(a.write_vectored(&[]).unwrap(), 0);\n    assert_eq!(\n        a.write_vectored(&[\n            IoSlice::new(&[]),\n            IoSlice::new(&[]),\n            IoSlice::new(&[]),\n            IoSlice::new(&[]),\n        ])\n        .unwrap(),\n        0,\n    );\n    assert_eq!(a.write_vectored(&[IoSlice::new(b\"a\\nb\"),]).unwrap(), 3);\n    assert_eq!(a.get_ref(), b\"\\nabaca\\nb\");\n}\n\n#[test]\nfn line_vectored_partial_and_errors() {\n    use crate::collections::VecDeque;\n\n    enum Call {\n        Write { inputs: Vec<&'static [u8]>, output: io::Result<usize> },\n        Flush { output: io::Result<()> },\n    }\n\n    #[derive(Default)]\n    struct Writer {\n        calls: VecDeque<Call>,\n    }\n\n    impl Write for Writer {\n        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n            self.write_vectored(&[IoSlice::new(buf)])\n        }\n\n        fn write_vectored(&mut self, buf: &[IoSlice<'_>]) -> io::Result<usize> {\n            match self.calls.pop_front().expect(\"unexpected call to write\") {\n                Call::Write { inputs, output } => {\n                    assert_eq!(inputs, buf.iter().map(|b| &**b).collect::<Vec<_>>());\n                    output\n                }\n                Call::Flush { .. } => panic!(\"unexpected call to write; expected a flush\"),\n            }\n        }\n\n        fn is_write_vectored(&self) -> bool {\n            true\n        }\n\n        fn flush(&mut self) -> io::Result<()> {\n            match self.calls.pop_front().expect(\"Unexpected call to flush\") {\n                Call::Flush { output } => output,\n                Call::Write { .. } => panic!(\"unexpected call to flush; expected a write\"),\n            }\n        }\n    }\n\n    impl Drop for Writer {\n        fn drop(&mut self) {\n            if !thread::panicking() {\n                assert_eq!(self.calls.len(), 0);\n            }\n        }\n    }\n\n    // partial writes keep going\n    let mut a = LineWriter::new(Writer::default());\n    a.write_vectored(&[IoSlice::new(&[]), IoSlice::new(b\"abc\")]).unwrap();\n\n    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"abc\"], output: Ok(1) });\n    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"bc\"], output: Ok(2) });\n    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\n\"], output: Ok(2) });\n\n    a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\n\")]).unwrap();\n\n    a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n    a.flush().unwrap();\n\n    // erroneous writes stop and don't write more\n    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\na\"], output: Err(err()) });\n    a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n    assert!(a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\na\")]).is_err());\n    a.flush().unwrap();\n\n    fn err() -> io::Error {\n        io::Error::new(io::ErrorKind::Other, \"x\")\n    }\n}\n\n/// Test that, in cases where vectored writing is not enabled, the\n/// LineWriter uses the normal `write` call, which more-correctly handles\n/// partial lines\n#[test]\nfn line_vectored_ignored() {\n    let writer = ProgrammableSink::default();\n    let mut writer = LineWriter::new(writer);\n\n    let content = [\n        IoSlice::new(&[]),\n        IoSlice::new(b\"Line 1\\nLine\"),\n        IoSlice::new(b\" 2\\nLine 3\\nL\"),\n        IoSlice::new(&[]),\n        IoSlice::new(&[]),\n        IoSlice::new(b\"ine 4\"),\n        IoSlice::new(b\"\\nLine 5\\n\"),\n    ];\n\n    let count = writer.write_vectored(&content).unwrap();\n    assert_eq!(count, 11);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n\n    let count = writer.write_vectored(&content[2..]).unwrap();\n    assert_eq!(count, 11);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n\n    let count = writer.write_vectored(&content[5..]).unwrap();\n    assert_eq!(count, 5);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n\n    let count = writer.write_vectored(&content[6..]).unwrap();\n    assert_eq!(count, 8);\n    assert_eq!(\n        writer.get_ref().buffer.as_slice(),\n        b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\n\".as_ref()\n    );\n}\n\n/// Test that, given this input:\n///\n/// Line 1\\n\n/// Line 2\\n\n/// Line 3\\n\n/// Line 4\n///\n/// And given a result that only writes to midway through Line 2\n///\n/// That only up to the end of Line 3 is buffered\n///\n/// This behavior is desirable because it prevents flushing partial lines\n#[test]\nfn partial_write_buffers_line() {\n    let writer = ProgrammableSink { accept_prefix: Some(13), ..Default::default() };\n    let mut writer = LineWriter::new(writer);\n\n    assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\\nLine4\").unwrap(), 21);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\");\n\n    assert_eq!(writer.write(b\"Line 4\").unwrap(), 6);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n}\n\n/// Test that, given this input:\n///\n/// Line 1\\n\n/// Line 2\\n\n/// Line 3\n///\n/// And given that the full write of lines 1 and 2 was successful\n/// That data up to Line 3 is buffered\n#[test]\nfn partial_line_buffered_after_line_write() {\n    let writer = ProgrammableSink::default();\n    let mut writer = LineWriter::new(writer);\n\n    assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\").unwrap(), 20);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\n\");\n\n    assert!(writer.flush().is_ok());\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\");\n}\n\n/// Test that, given a partial line that exceeds the length of\n/// LineBuffer's buffer (that is, without a trailing newline), that that\n/// line is written to the inner writer\n#[test]\nfn long_line_flushed() {\n    let writer = ProgrammableSink::default();\n    let mut writer = LineWriter::with_capacity(5, writer);\n\n    assert_eq!(writer.write(b\"0123456789\").unwrap(), 10);\n    assert_eq!(&writer.get_ref().buffer, b\"0123456789\");\n}\n\n/// Test that, given a very long partial line *after* successfully\n/// flushing a complete line, that that line is buffered unconditionally,\n/// and no additional writes take place. This assures the property that\n/// `write` should make at-most-one attempt to write new data.\n#[test]\nfn line_long_tail_not_flushed() {\n    let writer = ProgrammableSink::default();\n    let mut writer = LineWriter::with_capacity(5, writer);\n\n    // Assert that Line 1\\n is flushed, and 01234 is buffered\n    assert_eq!(writer.write(b\"Line 1\\n0123456789\").unwrap(), 12);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n\n    // Because the buffer is full, this subsequent write will flush it\n    assert_eq!(writer.write(b\"5\").unwrap(), 1);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n01234\");\n}\n\n/// Test that, if an attempt to pre-flush buffered data returns Ok(0),\n/// this is propagated as an error.\n#[test]\nfn line_buffer_write0_error() {\n    let writer = ProgrammableSink {\n        // Accept one write, then return Ok(0) on subsequent ones\n        max_writes: Some(1),\n\n        ..Default::default()\n    };\n    let mut writer = LineWriter::new(writer);\n\n    // This should write \"Line 1\\n\" and buffer \"Partial\"\n    assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n\n    // This will attempt to flush \"partial\", which will return Ok(0), which\n    // needs to be an error, because we've already informed the client\n    // that we accepted the write.\n    let err = writer.write(b\" Line End\\n\").unwrap_err();\n    assert_eq!(err.kind(), ErrorKind::WriteZero);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n}\n\n/// Test that, if a write returns Ok(0) after a successful pre-flush, this\n/// is propagated as Ok(0)\n#[test]\nfn line_buffer_write0_normal() {\n    let writer = ProgrammableSink {\n        // Accept two writes, then return Ok(0) on subsequent ones\n        max_writes: Some(2),\n\n        ..Default::default()\n    };\n    let mut writer = LineWriter::new(writer);\n\n    // This should write \"Line 1\\n\" and buffer \"Partial\"\n    assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n\n    // This will flush partial, which will succeed, but then return Ok(0)\n    // when flushing \" Line End\\n\"\n    assert_eq!(writer.write(b\" Line End\\n\").unwrap(), 0);\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nPartial\");\n}\n\n/// LineWriter has a custom `write_all`; make sure it works correctly\n#[test]\nfn line_write_all() {\n    let writer = ProgrammableSink {\n        // Only write 5 bytes at a time\n        accept_prefix: Some(5),\n        ..Default::default()\n    };\n    let mut writer = LineWriter::new(writer);\n\n    writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\").unwrap();\n    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\n\");\n    writer.write_all(b\" Line 5\\n\").unwrap();\n    assert_eq!(\n        writer.get_ref().buffer.as_slice(),\n        b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial Line 5\\n\".as_ref(),\n    );\n}\n\n#[test]\nfn line_write_all_error() {\n    let writer = ProgrammableSink {\n        // Only accept up to 3 writes of up to 5 bytes each\n        accept_prefix: Some(5),\n        max_writes: Some(3),\n        ..Default::default()\n    };\n\n    let mut writer = LineWriter::new(writer);\n    let res = writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\");\n    assert!(res.is_err());\n    // An error from write_all leaves everything in an indeterminate state,\n    // so there's nothing else to test here\n}\n\n/// Under certain circumstances, the old implementation of LineWriter\n/// would try to buffer \"to the last newline\" but be forced to buffer\n/// less than that, leading to inappropriate partial line writes.\n/// Regression test for that issue.\n#[test]\nfn partial_multiline_buffering() {\n    let writer = ProgrammableSink {\n        // Write only up to 5 bytes at a time\n        accept_prefix: Some(5),\n        ..Default::default()\n    };\n\n    let mut writer = LineWriter::with_capacity(10, writer);\n\n    let content = b\"AAAAABBBBB\\nCCCCDDDDDD\\nEEE\";\n\n    // When content is written, LineWriter will try to write blocks A, B,\n    // C, and D. Only block A will succeed. Under the old behavior, LineWriter\n    // would then try to buffer B, C and D, but because its capacity is 10,\n    // it will only be able to buffer B and C. We don't want to buffer\n    // partial lines concurrent with whole lines, so the correct behavior\n    // is to buffer only block B (out to the newline)\n    assert_eq!(writer.write(content).unwrap(), 11);\n    assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n\n    writer.flush().unwrap();\n    assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\\n\");\n}\n\n/// Same as test_partial_multiline_buffering, but in the event NO full lines\n/// fit in the buffer, just buffer as much as possible\n#[test]\nfn partial_multiline_buffering_without_full_line() {\n    let writer = ProgrammableSink {\n        // Write only up to 5 bytes at a time\n        accept_prefix: Some(5),\n        ..Default::default()\n    };\n\n    let mut writer = LineWriter::with_capacity(5, writer);\n\n    let content = b\"AAAAABBBBBBBBBB\\nCCCCC\\nDDDDD\";\n\n    // When content is written, LineWriter will try to write blocks A, B,\n    // and C. Only block A will succeed. Under the old behavior, LineWriter\n    // would then try to buffer B and C, but because its capacity is 5,\n    // it will only be able to buffer part of B. Because it's not possible\n    // for it to buffer any complete lines, it should buffer as much of B as\n    // possible\n    assert_eq!(writer.write(content).unwrap(), 10);\n    assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n\n    writer.flush().unwrap();\n    assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\");\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum RecordedEvent {\n    Write(String),\n    Flush,\n}\n\n#[derive(Debug, Clone, Default)]\nstruct WriteRecorder {\n    pub events: Vec<RecordedEvent>,\n}\n\nimpl Write for WriteRecorder {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        use crate::str::from_utf8;\n\n        self.events.push(RecordedEvent::Write(from_utf8(buf).unwrap().to_string()));\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.events.push(RecordedEvent::Flush);\n        Ok(())\n    }\n}\n\n/// Test that a normal, formatted writeln only results in a single write\n/// call to the underlying writer. A naive implementation of\n/// LineWriter::write_all results in two writes: one of the buffered data,\n/// and another of the final substring in the formatted set\n#[test]\nfn single_formatted_write() {\n    let writer = WriteRecorder::default();\n    let mut writer = LineWriter::new(writer);\n\n    // Under a naive implementation of LineWriter, this will result in two\n    // writes: \"hello, world\" and \"!\\n\", because write() has to flush the\n    // buffer before attempting to write the last \"!\\n\". write_all shouldn't\n    // have this limitation.\n    writeln!(&mut writer, \"{}, {}!\", \"hello\", \"world\").unwrap();\n    assert_eq!(writer.get_ref().events, [RecordedEvent::Write(\"hello, world!\\n\".to_string())]);\n}\n"],["2577","use crate::cmp;\nuse crate::fmt;\nuse crate::io::{\n    self, BufRead, Initializer, IoSliceMut, Read, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n};\n\n/// The `BufReader<R>` struct adds buffering to any reader.\n///\n/// It can be excessively inefficient to work directly with a [`Read`] instance.\n/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n/// results in a system call. A `BufReader<R>` performs large, infrequent reads on\n/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n///\n/// `BufReader<R>` can improve the speed of programs that make *small* and\n/// *repeated* read calls to the same file or network socket. It does not\n/// help when reading very large amounts at once, or reading just one or a few\n/// times. It also provides no advantage when reading from a source that is\n/// already in memory, like a [`Vec`]`<u8>`.\n///\n/// When the `BufReader<R>` is dropped, the contents of its buffer will be\n/// discarded. Creating multiple instances of a `BufReader<R>` on the same\n/// stream can cause data loss. Reading from the underlying reader after\n/// unwrapping the `BufReader<R>` with [`BufReader::into_inner`] can also cause\n/// data loss.\n///\n// HACK(#78696): can't use `crate` for associated items\n/// [`TcpStream::read`]: super::super::super::net::TcpStream::read\n/// [`TcpStream`]: crate::net::TcpStream\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::BufReader;\n/// use std::fs::File;\n///\n/// fn main() -> std::io::Result<()> {\n///     let f = File::open(\"log.txt\")?;\n///     let mut reader = BufReader::new(f);\n///\n///     let mut line = String::new();\n///     let len = reader.read_line(&mut line)?;\n///     println!(\"First line is {} bytes long\", len);\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BufReader<R> {\n    inner: R,\n    buf: Box<[u8]>,\n    pos: usize,\n    cap: usize,\n}\n\nimpl<R: Read> BufReader<R> {\n    /// Creates a new `BufReader<R>` with a default buffer capacity. The default is currently 8 KB,\n    /// but may change in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::new(f);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: R) -> BufReader<R> {\n        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n    }\n\n    /// Creates a new `BufReader<R>` with the specified buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// Creating a buffer with ten bytes of capacity:\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::with_capacity(10, f);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n        unsafe {\n            let mut buf = Box::new_uninit_slice(capacity).assume_init();\n            inner.initializer().initialize(&mut buf);\n            BufReader { inner, buf, pos: 0, cap: 0 }\n        }\n    }\n}\n\nimpl<R> BufReader<R> {\n    /// Gets a reference to the underlying reader.\n    ///\n    /// It is inadvisable to directly read from the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f1 = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::new(f1);\n    ///\n    ///     let f2 = reader.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &R {\n        &self.inner\n    }\n\n    /// Gets a mutable reference to the underlying reader.\n    ///\n    /// It is inadvisable to directly read from the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f1 = File::open(\"log.txt\")?;\n    ///     let mut reader = BufReader::new(f1);\n    ///\n    ///     let f2 = reader.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut R {\n        &mut self.inner\n    }\n\n    /// Returns a reference to the internally buffered data.\n    ///\n    /// Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.\n    ///\n    /// [`fill_buf`]: BufRead::fill_buf\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{BufReader, BufRead};\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let mut reader = BufReader::new(f);\n    ///     assert!(reader.buffer().is_empty());\n    ///\n    ///     if reader.fill_buf()?.len() > 0 {\n    ///         assert!(!reader.buffer().is_empty());\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n    pub fn buffer(&self) -> &[u8] {\n        &self.buf[self.pos..self.cap]\n    }\n\n    /// Returns the number of bytes the internal buffer can hold at once.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{BufReader, BufRead};\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let mut reader = BufReader::new(f);\n    ///\n    ///     let capacity = reader.capacity();\n    ///     let buffer = reader.fill_buf()?;\n    ///     assert!(buffer.len() <= capacity);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n    pub fn capacity(&self) -> usize {\n        self.buf.len()\n    }\n\n    /// Unwraps this `BufReader<R>`, returning the underlying reader.\n    ///\n    /// Note that any leftover data in the internal buffer is lost. Therefore,\n    /// a following read from the underlying reader may lead to data loss.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f1 = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::new(f1);\n    ///\n    ///     let f2 = reader.into_inner();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> R {\n        self.inner\n    }\n\n    /// Invalidates all data in the internal buffer.\n    #[inline]\n    fn discard_buffer(&mut self) {\n        self.pos = 0;\n        self.cap = 0;\n    }\n}\n\nimpl<R: Seek> BufReader<R> {\n    /// Seeks relative to the current position. If the new position lies within the buffer,\n    /// the buffer will not be flushed, allowing for more efficient seeks.\n    /// This method does not return the location of the underlying reader, so the caller\n    /// must track this information themselves if it is required.\n    #[stable(feature = \"bufreader_seek_relative\", since = \"1.53.0\")]\n    pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n        let pos = self.pos as u64;\n        if offset < 0 {\n            if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n                self.pos = new_pos as usize;\n                return Ok(());\n            }\n        } else {\n            if let Some(new_pos) = pos.checked_add(offset as u64) {\n                if new_pos <= self.cap as u64 {\n                    self.pos = new_pos as usize;\n                    return Ok(());\n                }\n            }\n        }\n        self.seek(SeekFrom::Current(offset)).map(drop)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> Read for BufReader<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.pos == self.cap && buf.len() >= self.buf.len() {\n            self.discard_buffer();\n            return self.inner.read(buf);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read(buf)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }\n\n    // Small read_exacts from a BufReader are extremely common when used with a deserializer.\n    // The default implementation calls read in a loop, which results in surprisingly poor code\n    // generation for the common path where the buffer has enough bytes to fill the passed-in\n    // buffer.\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        if self.buffer().len() >= buf.len() {\n            buf.copy_from_slice(&self.buffer()[..buf.len()]);\n            self.consume(buf.len());\n            return Ok(());\n        }\n\n        crate::io::default_read_exact(self, buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n        if self.pos == self.cap && total_len >= self.buf.len() {\n            self.discard_buffer();\n            return self.inner.read_vectored(bufs);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read_vectored(bufs)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }\n\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    // we can't skip unconditionally because of the large buffer case in read.\n    unsafe fn initializer(&self) -> Initializer {\n        self.inner.initializer()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> BufRead for BufReader<R> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        // If we've reached the end of our internal buffer then we need to fetch\n        // some more data from the underlying reader.\n        // Branch using `>=` instead of the more correct `==`\n        // to tell the compiler that the pos..cap slice is always valid.\n        if self.pos >= self.cap {\n            debug_assert!(self.pos == self.cap);\n            self.cap = self.inner.read(&mut self.buf)?;\n            self.pos = 0;\n        }\n        Ok(&self.buf[self.pos..self.cap])\n    }\n\n    fn consume(&mut self, amt: usize) {\n        self.pos = cmp::min(self.pos + amt, self.cap);\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R> fmt::Debug for BufReader<R>\nwhere\n    R: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"BufReader\")\n            .field(\"reader\", &self.inner)\n            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n            .finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Seek> Seek for BufReader<R> {\n    /// Seek to an offset, in bytes, in the underlying reader.\n    ///\n    /// The position used for seeking with [`SeekFrom::Current`]`(_)` is the\n    /// position the underlying reader would be at if the `BufReader<R>` had no\n    /// internal buffer.\n    ///\n    /// Seeking always discards the internal buffer, even if the seek position\n    /// would otherwise fall within it. This guarantees that calling\n    /// [`BufReader::into_inner()`] immediately after a seek yields the underlying reader\n    /// at the same position.\n    ///\n    /// To seek without discarding the internal buffer, use [`BufReader::seek_relative`].\n    ///\n    /// See [`std::io::Seek`] for more details.\n    ///\n    /// Note: In the edge case where you're seeking with [`SeekFrom::Current`]`(n)`\n    /// where `n` minus the internal buffer length overflows an `i64`, two\n    /// seeks will be performed instead of one. If the second seek returns\n    /// [`Err`], the underlying reader will be left at the same position it would\n    /// have if you called `seek` with [`SeekFrom::Current`]`(0)`.\n    ///\n    /// [`std::io::Seek`]: Seek\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        let result: u64;\n        if let SeekFrom::Current(n) = pos {\n            let remainder = (self.cap - self.pos) as i64;\n            // it should be safe to assume that remainder fits within an i64 as the alternative\n            // means we managed to allocate 8 exbibytes and that's absurd.\n            // But it's not out of the realm of possibility for some weird underlying reader to\n            // support seeking by i64::MIN so we need to handle underflow when subtracting\n            // remainder.\n            if let Some(offset) = n.checked_sub(remainder) {\n                result = self.inner.seek(SeekFrom::Current(offset))?;\n            } else {\n                // seek backwards by our remainder, and then by the offset\n                self.inner.seek(SeekFrom::Current(-remainder))?;\n                self.discard_buffer();\n                result = self.inner.seek(SeekFrom::Current(n))?;\n            }\n        } else {\n            // Seeking with Start/End doesn't care about our buffer length.\n            result = self.inner.seek(pos)?;\n        }\n        self.discard_buffer();\n        Ok(result)\n    }\n\n    /// Returns the current seek position from the start of the stream.\n    ///\n    /// The value returned is equivalent to `self.seek(SeekFrom::Current(0))`\n    /// but does not flush the internal buffer. Due to this optimization the\n    /// function does not guarantee that calling `.into_inner()` immediately\n    /// afterwards will yield the underlying reader at the same position. Use\n    /// [`BufReader::seek`] instead if you require that guarantee.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the position of the inner reader is smaller\n    /// than the amount of buffered data. That can happen if the inner reader\n    /// has an incorrect implementation of [`Seek::stream_position`], or if the\n    /// position has gone out of sync due to calling [`Seek::seek`] directly on\n    /// the underlying reader.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use std::{\n    ///     io::{self, BufRead, BufReader, Seek},\n    ///     fs::File,\n    /// };\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n    ///\n    ///     let before = f.stream_position()?;\n    ///     f.read_line(&mut String::new())?;\n    ///     let after = f.stream_position()?;\n    ///\n    ///     println!(\"The first line was {} bytes long\", after - before);\n    ///     Ok(())\n    /// }\n    /// ```\n    fn stream_position(&mut self) -> io::Result<u64> {\n        let remainder = (self.cap - self.pos) as u64;\n        self.inner.stream_position().map(|pos| {\n            pos.checked_sub(remainder).expect(\n                \"overflow when subtracting remaining buffer size from inner stream position\",\n            )\n        })\n    }\n}\n\nimpl<T> SizeHint for BufReader<T> {\n    fn lower_bound(&self) -> usize {\n        self.buffer().len()\n    }\n}\n"],["2578","use crate::fmt;\nuse crate::io::{self, buffered::LineWriterShim, BufWriter, IntoInnerError, IoSlice, Write};\n\n/// Wraps a writer and buffers output to it, flushing whenever a newline\n/// (`0x0a`, `'\\n'`) is detected.\n///\n/// The [`BufWriter`] struct wraps a writer and buffers its output.\n/// But it only does this batched write when it goes out of scope, or when the\n/// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n/// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n/// does exactly that.\n///\n/// Like [`BufWriter`], a `LineWriter`s buffer will also be flushed when the\n/// `LineWriter` goes out of scope or when its internal buffer is full.\n///\n/// If there's still a partial line in the buffer when the `LineWriter` is\n/// dropped, it will flush those contents.\n///\n/// # Examples\n///\n/// We can use `LineWriter` to write one line at a time, significantly\n/// reducing the number of actual writes to the file.\n///\n/// ```no_run\n/// use std::fs::{self, File};\n/// use std::io::prelude::*;\n/// use std::io::LineWriter;\n///\n/// fn main() -> std::io::Result<()> {\n///     let road_not_taken = b\"I shall be telling this with a sigh\n/// Somewhere ages and ages hence:\n/// Two roads diverged in a wood, and I -\n/// I took the one less traveled by,\n/// And that has made all the difference.\";\n///\n///     let file = File::create(\"poem.txt\")?;\n///     let mut file = LineWriter::new(file);\n///\n///     file.write_all(b\"I shall be telling this with a sigh\")?;\n///\n///     // No bytes are written until a newline is encountered (or\n///     // the internal buffer is filled).\n///     assert_eq!(fs::read_to_string(\"poem.txt\")?, \"\");\n///     file.write_all(b\"\\n\")?;\n///     assert_eq!(\n///         fs::read_to_string(\"poem.txt\")?,\n///         \"I shall be telling this with a sigh\\n\",\n///     );\n///\n///     // Write the rest of the poem.\n///     file.write_all(b\"Somewhere ages and ages hence:\n/// Two roads diverged in a wood, and I -\n/// I took the one less traveled by,\n/// And that has made all the difference.\")?;\n///\n///     // The last line of the poem doesn't end in a newline, so\n///     // we have to flush or drop the `LineWriter` to finish\n///     // writing.\n///     file.flush()?;\n///\n///     // Confirm the whole poem was written.\n///     assert_eq!(fs::read(\"poem.txt\")?, &road_not_taken[..]);\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LineWriter<W: Write> {\n    inner: BufWriter<W>,\n}\n\nimpl<W: Write> LineWriter<W> {\n    /// Creates a new `LineWriter`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let file = LineWriter::new(file);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: W) -> LineWriter<W> {\n        // Lines typically aren't that long, don't use a giant buffer\n        LineWriter::with_capacity(1024, inner)\n    }\n\n    /// Creates a new `LineWriter` with a specified capacity for the internal\n    /// buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let file = LineWriter::with_capacity(100, file);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n        LineWriter { inner: BufWriter::with_capacity(capacity, inner) }\n    }\n\n    /// Gets a reference to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let file = LineWriter::new(file);\n    ///\n    ///     let reference = file.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &W {\n        self.inner.get_ref()\n    }\n\n    /// Gets a mutable reference to the underlying writer.\n    ///\n    /// Caution must be taken when calling methods on the mutable reference\n    /// returned as extra writes could corrupt the output stream.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let mut file = LineWriter::new(file);\n    ///\n    ///     // we can use reference just like file\n    ///     let reference = file.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut W {\n        self.inner.get_mut()\n    }\n\n    /// Unwraps this `LineWriter`, returning the underlying writer.\n    ///\n    /// The internal buffer is written out before returning the writer.\n    ///\n    /// # Errors\n    ///\n    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///\n    ///     let writer: LineWriter<File> = LineWriter::new(file);\n    ///\n    ///     let file: File = writer.into_inner()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n        self.inner.into_inner().map_err(|err| err.new_wrapped(|inner| LineWriter { inner }))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Write for LineWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        LineWriterShim::new(&mut self.inner).write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        LineWriterShim::new(&mut self.inner).write_vectored(bufs)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        self.inner.is_write_vectored()\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_all(buf)\n    }\n\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_all_vectored(bufs)\n    }\n\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_fmt(fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> fmt::Debug for LineWriter<W>\nwhere\n    W: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"LineWriter\")\n            .field(\"writer\", &self.get_ref())\n            .field(\n                \"buffer\",\n                &format_args!(\"{}/{}\", self.inner.buffer().len(), self.inner.capacity()),\n            )\n            .finish_non_exhaustive()\n    }\n}\n"],["2579","//! Traits, helpers, and type definitions for core I/O functionality.\n//!\n//! The `std::io` module contains a number of common things you'll need\n//! when doing input and output. The most core part of this module is\n//! the [`Read`] and [`Write`] traits, which provide the\n//! most general interface for reading and writing input and output.\n//!\n//! # Read and Write\n//!\n//! Because they are traits, [`Read`] and [`Write`] are implemented by a number\n//! of other types, and you can implement them for your types too. As such,\n//! you'll see a few different types of I/O throughout the documentation in\n//! this module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s. For\n//! example, [`Read`] adds a [`read`][`Read::read`] method, which we can use on\n//! [`File`]s:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let mut f = File::open(\"foo.txt\")?;\n//!     let mut buffer = [0; 10];\n//!\n//!     // read up to 10 bytes\n//!     let n = f.read(&mut buffer)?;\n//!\n//!     println!(\"The bytes: {:?}\", &buffer[..n]);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [`Read`] and [`Write`] are so important, implementors of the two traits have a\n//! nickname: readers and writers. So you'll sometimes see 'a reader' instead\n//! of 'a type that implements the [`Read`] trait'. Much easier!\n//!\n//! ## Seek and BufRead\n//!\n//! Beyond that, there are two important traits that are provided: [`Seek`]\n//! and [`BufRead`]. Both of these build on top of a reader to control\n//! how the reading happens. [`Seek`] lets you control where the next byte is\n//! coming from:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::SeekFrom;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let mut f = File::open(\"foo.txt\")?;\n//!     let mut buffer = [0; 10];\n//!\n//!     // skip to the last 10 bytes of the file\n//!     f.seek(SeekFrom::End(-10))?;\n//!\n//!     // read up to 10 bytes\n//!     let n = f.read(&mut buffer)?;\n//!\n//!     println!(\"The bytes: {:?}\", &buffer[..n]);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [`BufRead`] uses an internal buffer to provide a number of other ways to read, but\n//! to show it off, we'll need to talk about buffers in general. Keep reading!\n//!\n//! ## BufReader and BufWriter\n//!\n//! Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be\n//! making near-constant calls to the operating system. To help with this,\n//! `std::io` comes with two structs, [`BufReader`] and [`BufWriter`], which wrap\n//! readers and writers. The wrapper uses a buffer, reducing the number of\n//! calls and providing nicer methods for accessing exactly what you want.\n//!\n//! For example, [`BufReader`] works with the [`BufRead`] trait to add extra\n//! methods to any reader:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let f = File::open(\"foo.txt\")?;\n//!     let mut reader = BufReader::new(f);\n//!     let mut buffer = String::new();\n//!\n//!     // read a line into buffer\n//!     reader.read_line(&mut buffer)?;\n//!\n//!     println!(\"{}\", buffer);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [`BufWriter`] doesn't add any new ways of writing; it just buffers every call\n//! to [`write`][`Write::write`]:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufWriter;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let f = File::create(\"foo.txt\")?;\n//!     {\n//!         let mut writer = BufWriter::new(f);\n//!\n//!         // write a byte to the buffer\n//!         writer.write(&[42])?;\n//!\n//!     } // the buffer is flushed once writer goes out of scope\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Standard input and output\n//!\n//! A very common source of input is standard input:\n//!\n//! ```no_run\n//! use std::io;\n//!\n//! fn main() -> io::Result<()> {\n//!     let mut input = String::new();\n//!\n//!     io::stdin().read_line(&mut input)?;\n//!\n//!     println!(\"You typed: {}\", input.trim());\n//!     Ok(())\n//! }\n//! ```\n//!\n//! Note that you cannot use the [`?` operator] in functions that do not return\n//! a [`Result<T, E>`][`Result`]. Instead, you can call [`.unwrap()`]\n//! or `match` on the return value to catch any possible errors:\n//!\n//! ```no_run\n//! use std::io;\n//!\n//! let mut input = String::new();\n//!\n//! io::stdin().read_line(&mut input).unwrap();\n//! ```\n//!\n//! And a very common source of output is standard output:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//!\n//! fn main() -> io::Result<()> {\n//!     io::stdout().write(&[42])?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! Of course, using [`io::stdout`] directly is less common than something like\n//! [`println!`].\n//!\n//! ## Iterator types\n//!\n//! A large number of the structures provided by `std::io` are for various\n//! ways of iterating over I/O. For example, [`Lines`] is used to split over\n//! lines:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let f = File::open(\"foo.txt\")?;\n//!     let reader = BufReader::new(f);\n//!\n//!     for line in reader.lines() {\n//!         println!(\"{}\", line?);\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Functions\n//!\n//! There are a number of [functions][functions-list] that offer access to various\n//! features. For example, we can use three of these functions to copy everything\n//! from standard input to standard output:\n//!\n//! ```no_run\n//! use std::io;\n//!\n//! fn main() -> io::Result<()> {\n//!     io::copy(&mut io::stdin(), &mut io::stdout())?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [functions-list]: #functions-1\n//!\n//! ## io::Result\n//!\n//! Last, but certainly not least, is [`io::Result`]. This type is used\n//! as the return type of many `std::io` functions that can cause an error, and\n//! can be returned from your own functions as well. Many of the examples in this\n//! module use the [`?` operator]:\n//!\n//! ```\n//! use std::io;\n//!\n//! fn read_input() -> io::Result<()> {\n//!     let mut input = String::new();\n//!\n//!     io::stdin().read_line(&mut input)?;\n//!\n//!     println!(\"You typed: {}\", input.trim());\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! The return type of `read_input()`, [`io::Result<()>`][`io::Result`], is a very\n//! common type for functions which don't have a 'real' return value, but do want to\n//! return errors if they happen. In this case, the only purpose of this function is\n//! to read the line and print it, so we use `()`.\n//!\n//! ## Platform-specific behavior\n//!\n//! Many I/O functions throughout the standard library are documented to indicate\n//! what various library or syscalls they are delegated to. This is done to help\n//! applications both understand what's happening under the hood as well as investigate\n//! any possibly unclear semantics. Note, however, that this is informative, not a binding\n//! contract. The implementation of many of these functions are subject to change over\n//! time and may call fewer or more syscalls/library functions.\n//!\n//! [`File`]: crate::fs::File\n//! [`TcpStream`]: crate::net::TcpStream\n//! [`io::stdout`]: stdout\n//! [`io::Result`]: self::Result\n//! [`?` operator]: ../../book/appendix-02-operators.html\n//! [`Result`]: crate::result::Result\n//! [`.unwrap()`]: crate::result::Result::unwrap\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::cmp;\nuse crate::fmt;\nuse crate::ops::{Deref, DerefMut};\nuse crate::ptr;\nuse crate::slice;\nuse crate::str;\nuse crate::sys;\nuse crate::sys_common::memchr;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::IntoInnerError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::{BufReader, BufWriter, LineWriter};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::copy::copy;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::cursor::Cursor;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::error::{Error, ErrorKind, Result};\n#[unstable(feature = \"internal_output_capture\", issue = \"none\")]\n#[doc(no_inline, hidden)]\npub use self::stdio::set_output_capture;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n#[unstable(feature = \"print_internals\", issue = \"none\")]\npub use self::stdio::{_eprint, _print};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::util::{empty, repeat, sink, Empty, Repeat, Sink};\n\nmod buffered;\npub(crate) mod copy;\nmod cursor;\nmod error;\nmod impls;\npub mod prelude;\nmod stdio;\nmod util;\n\nconst DEFAULT_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n\npub(crate) fn cleanup() {\n    stdio::cleanup()\n}\n\nstruct Guard<'a> {\n    buf: &'a mut Vec<u8>,\n    len: usize,\n}\n\nimpl Drop for Guard<'_> {\n    fn drop(&mut self) {\n        unsafe {\n            self.buf.set_len(self.len);\n        }\n    }\n}\n\n// A few methods below (read_to_string, read_line) will append data into a\n// `String` buffer, but we need to be pretty careful when doing this. The\n// implementation will just call `.as_mut_vec()` and then delegate to a\n// byte-oriented reading method, but we must ensure that when returning we never\n// leave `buf` in a state such that it contains invalid UTF-8 in its bounds.\n//\n// To this end, we use an RAII guard (to protect against panics) which updates\n// the length of the string when it is dropped. This guard initially truncates\n// the string to the prior length and only after we've validated that the\n// new contents are valid UTF-8 do we allow it to set a longer length.\n//\n// The unsafety in this function is twofold:\n//\n// 1. We're looking at the raw bytes of `buf`, so we take on the burden of UTF-8\n//    checks.\n// 2. We're passing a raw buffer to the function `f`, and it is expected that\n//    the function only *appends* bytes to the buffer. We'll get undefined\n//    behavior if existing bytes are overwritten to have non-UTF-8 data.\nfn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\nwhere\n    F: FnOnce(&mut Vec<u8>) -> Result<usize>,\n{\n    unsafe {\n        let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };\n        let ret = f(g.buf);\n        if str::from_utf8(&g.buf[g.len..]).is_err() {\n            ret.and_then(|_| {\n                Err(Error::new_const(ErrorKind::InvalidData, &\"stream did not contain valid UTF-8\"))\n            })\n        } else {\n            g.len = g.buf.len();\n            ret\n        }\n    }\n}\n\n// This uses an adaptive system to extend the vector when it fills. We want to\n// avoid paying to allocate and zero a huge chunk of memory if the reader only\n// has 4 bytes while still making large reads if the reader does have a ton\n// of data to return. Simply tacking on an extra DEFAULT_BUF_SIZE space every\n// time is 4,500 times (!) slower than a default reservation size of 32 if the\n// reader has a very small amount of data to return.\n//\n// Because we're extending the buffer with uninitialized data for trusted\n// readers, we need to make sure to truncate that if any of this panics.\nfn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n    read_to_end_with_reservation(r, buf, |_| 32)\n}\n\nfn read_to_end_with_reservation<R, F>(\n    r: &mut R,\n    buf: &mut Vec<u8>,\n    mut reservation_size: F,\n) -> Result<usize>\nwhere\n    R: Read + ?Sized,\n    F: FnMut(&R) -> usize,\n{\n    let start_len = buf.len();\n    let mut g = Guard { len: buf.len(), buf };\n    loop {\n        if g.len == g.buf.len() {\n            unsafe {\n                // FIXME(danielhenrymantilla): #42788\n                //\n                //   - This creates a (mut) reference to a slice of\n                //     _uninitialized_ integers, which is **undefined behavior**\n                //\n                //   - Only the standard library gets to soundly \"ignore\" this,\n                //     based on its privileged knowledge of unstable rustc\n                //     internals;\n                g.buf.reserve(reservation_size(r));\n                let capacity = g.buf.capacity();\n                g.buf.set_len(capacity);\n                r.initializer().initialize(&mut g.buf[g.len..]);\n            }\n        }\n\n        let buf = &mut g.buf[g.len..];\n        match r.read(buf) {\n            Ok(0) => return Ok(g.len - start_len),\n            Ok(n) => {\n                // We can't allow bogus values from read. If it is too large, the returned vec could have its length\n                // set past its capacity, or if it overflows the vec could be shortened which could create an invalid\n                // string if this is called via read_to_string.\n                assert!(n <= buf.len());\n                g.len += n;\n            }\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            Err(e) => return Err(e),\n        }\n    }\n}\n\npub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize>\nwhere\n    F: FnOnce(&mut [u8]) -> Result<usize>,\n{\n    let buf = bufs.iter_mut().find(|b| !b.is_empty()).map_or(&mut [][..], |b| &mut **b);\n    read(buf)\n}\n\npub(crate) fn default_write_vectored<F>(write: F, bufs: &[IoSlice<'_>]) -> Result<usize>\nwhere\n    F: FnOnce(&[u8]) -> Result<usize>,\n{\n    let buf = bufs.iter().find(|b| !b.is_empty()).map_or(&[][..], |b| &**b);\n    write(buf)\n}\n\npub(crate) fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [u8]) -> Result<()> {\n    while !buf.is_empty() {\n        match this.read(buf) {\n            Ok(0) => break,\n            Ok(n) => {\n                let tmp = buf;\n                buf = &mut tmp[n..];\n            }\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            Err(e) => return Err(e),\n        }\n    }\n    if !buf.is_empty() {\n        Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n    } else {\n        Ok(())\n    }\n}\n\n/// The `Read` trait allows for reading bytes from a source.\n///\n/// Implementors of the `Read` trait are called 'readers'.\n///\n/// Readers are defined by one required method, [`read()`]. Each call to [`read()`]\n/// will attempt to pull bytes from this source into a provided buffer. A\n/// number of other methods are implemented in terms of [`read()`], giving\n/// implementors a number of ways to read bytes while only needing to implement\n/// a single method.\n///\n/// Readers are intended to be composable with one another. Many implementors\n/// throughout [`std::io`] take and provide types which implement the `Read`\n/// trait.\n///\n/// Please note that each call to [`read()`] may involve a system call, and\n/// therefore, using something that implements [`BufRead`], such as\n/// [`BufReader`], will be more efficient.\n///\n/// # Examples\n///\n/// [`File`]s implement `Read`:\n///\n/// ```no_run\n/// use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// fn main() -> io::Result<()> {\n///     let mut f = File::open(\"foo.txt\")?;\n///     let mut buffer = [0; 10];\n///\n///     // read up to 10 bytes\n///     f.read(&mut buffer)?;\n///\n///     let mut buffer = Vec::new();\n///     // read the whole file\n///     f.read_to_end(&mut buffer)?;\n///\n///     // read into a String, so that you don't need to do the conversion.\n///     let mut buffer = String::new();\n///     f.read_to_string(&mut buffer)?;\n///\n///     // and more! See the other methods for more details.\n///     Ok(())\n/// }\n/// ```\n///\n/// Read from [`&str`] because [`&[u8]`][prim@slice] implements `Read`:\n///\n/// ```no_run\n/// # use std::io;\n/// use std::io::prelude::*;\n///\n/// fn main() -> io::Result<()> {\n///     let mut b = \"This string will be read\".as_bytes();\n///     let mut buffer = [0; 10];\n///\n///     // read up to 10 bytes\n///     b.read(&mut buffer)?;\n///\n///     // etc... it works exactly as a File does!\n///     Ok(())\n/// }\n/// ```\n///\n/// [`read()`]: Read::read\n/// [`&str`]: prim@str\n/// [`std::io`]: self\n/// [`File`]: crate::fs::File\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(notable_trait)]\npub trait Read {\n    /// Pull some bytes from this source into the specified buffer, returning\n    /// how many bytes were read.\n    ///\n    /// This function does not provide any guarantees about whether it blocks\n    /// waiting for data, but if an object needs to block for a read and cannot,\n    /// it will typically signal this via an [`Err`] return value.\n    ///\n    /// If the return value of this method is [`Ok(n)`], then implementations must\n    /// guarantee that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n    /// that the buffer `buf` has been filled in with `n` bytes of data from this\n    /// source. If `n` is `0`, then it can indicate one of two scenarios:\n    ///\n    /// 1. This reader has reached its \"end of file\" and will likely no longer\n    ///    be able to produce bytes. Note that this does not mean that the\n    ///    reader will *always* no longer be able to produce bytes. As an example,\n    ///    on Linux, this method will call the `recv` syscall for a [`TcpStream`],\n    ///    where returning zero indicates the connection was shut down correctly. While\n    ///    for [`File`], it is possible to reach the end of file and get zero as result,\n    ///    but if more data is appended to the file, future calls to `read` will return\n    ///    more data.\n    /// 2. The buffer specified was 0 bytes in length.\n    ///\n    /// It is not an error if the returned value `n` is smaller than the buffer size,\n    /// even when the reader is not at the end of the stream yet.\n    /// This may happen for example because fewer bytes are actually available right now\n    /// (e. g. being close to end-of-file) or because read() was interrupted by a signal.\n    ///\n    /// As this trait is safe to implement, callers cannot rely on `n <= buf.len()` for safety.\n    /// Extra care needs to be taken when `unsafe` functions are used to access the read bytes.\n    /// Callers have to ensure that no unchecked out-of-bounds accesses are possible even if\n    /// `n > buf.len()`.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that *implementations*\n    /// only write data to `buf` instead of reading its contents.\n    ///\n    /// Correspondingly, however, *callers* of this method may not assume any guarantees\n    /// about how the implementation uses `buf`. The trait is safe to implement,\n    /// so it is possible that the code that's supposed to write to the buffer might also read\n    /// from it. It is your responsibility to make sure that `buf` is initialized\n    /// before calling `read`. Calling `read` with an uninitialized `buf` (of the kind one\n    /// obtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.\n    ///\n    /// [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters any form of I/O or other error, an error\n    /// variant will be returned. If an error is returned then it must be\n    /// guaranteed that no bytes were read.\n    ///\n    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the read\n    /// operation should be retried if there is nothing else to do.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`Ok(n)`]: Ok\n    /// [`File`]: crate::fs::File\n    /// [`TcpStream`]: crate::net::TcpStream\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = [0; 10];\n    ///\n    ///     // read up to 10 bytes\n    ///     let n = f.read(&mut buffer[..])?;\n    ///\n    ///     println!(\"The bytes: {:?}\", &buffer[..n]);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n\n    /// Like `read`, except that it reads into a slice of buffers.\n    ///\n    /// Data is copied to fill each buffer in order, with the final buffer\n    /// written to possibly being only partially filled. This method must\n    /// behave equivalently to a single call to `read` with concatenated\n    /// buffers.\n    ///\n    /// The default implementation calls `read` with either the first nonempty\n    /// buffer provided, or an empty one if none exists.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> Result<usize> {\n        default_read_vectored(|b| self.read(b), bufs)\n    }\n\n    /// Determines if this `Read`er has an efficient `read_vectored`\n    /// implementation.\n    ///\n    /// If a `Read`er does not override the default `read_vectored`\n    /// implementation, code using it may want to avoid the method all together\n    /// and coalesce writes into a single buffer for higher performance.\n    ///\n    /// The default implementation returns `false`.\n    #[unstable(feature = \"can_vector\", issue = \"69941\")]\n    fn is_read_vectored(&self) -> bool {\n        false\n    }\n\n    /// Determines if this `Read`er can work with buffers of uninitialized\n    /// memory.\n    ///\n    /// The default implementation returns an initializer which will zero\n    /// buffers.\n    ///\n    /// If a `Read`er guarantees that it can work properly with uninitialized\n    /// memory, it should call [`Initializer::nop()`]. See the documentation for\n    /// [`Initializer`] for details.\n    ///\n    /// The behavior of this method must be independent of the state of the\n    /// `Read`er - the method only takes `&self` so that it can be used through\n    /// trait objects.\n    ///\n    /// # Safety\n    ///\n    /// This method is unsafe because a `Read`er could otherwise return a\n    /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n    /// block.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::zeroing()\n    }\n\n    /// Read all bytes until EOF in this source, placing them into `buf`.\n    ///\n    /// All bytes read from this source will be appended to the specified buffer\n    /// `buf`. This function will continuously call [`read()`] to append more data to\n    /// `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n    /// non-[`ErrorKind::Interrupted`] kind.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. Any bytes which have already been read will be appended to\n    /// `buf`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`read()`]: Read::read\n    /// [`Ok(0)`]: Ok\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = Vec::new();\n    ///\n    ///     // read the whole file\n    ///     f.read_to_end(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (See also the [`std::fs::read`] convenience function for reading from a\n    /// file.)\n    ///\n    /// [`std::fs::read`]: crate::fs::read\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n        read_to_end(self, buf)\n    }\n\n    /// Read all bytes until EOF in this source, appending them to `buf`.\n    ///\n    /// If successful, this function returns the number of bytes which were read\n    /// and appended to `buf`.\n    ///\n    /// # Errors\n    ///\n    /// If the data in this stream is *not* valid UTF-8 then an error is\n    /// returned and `buf` is unchanged.\n    ///\n    /// See [`read_to_end`] for other error semantics.\n    ///\n    /// [`read_to_end`]: Read::read_to_end\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = String::new();\n    ///\n    ///     f.read_to_string(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (See also the [`std::fs::read_to_string`] convenience function for\n    /// reading from a file.)\n    ///\n    /// [`std::fs::read_to_string`]: crate::fs::read_to_string\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n        // Note that we do *not* call `.read_to_end()` here. We are passing\n        // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n        // method to fill it up. An arbitrary implementation could overwrite the\n        // entire contents of the vector, not just append to it (which is what\n        // we are expecting).\n        //\n        // To prevent extraneously checking the UTF-8-ness of the entire buffer\n        // we pass it to our hardcoded `read_to_end` implementation which we\n        // know is guaranteed to only read data into the end of the buffer.\n        append_to_string(buf, |b| read_to_end(self, b))\n    }\n\n    /// Read the exact number of bytes required to fill `buf`.\n    ///\n    /// This function reads as many bytes as necessary to completely fill the\n    /// specified buffer `buf`.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that implementations\n    /// only write data to `buf` instead of reading its contents. The\n    /// documentation on [`read`] has a more detailed explanation on this\n    /// subject.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If this function encounters an \"end of file\" before completely filling\n    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n    /// The contents of `buf` are unspecified in this case.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. The contents of `buf` are unspecified in this case.\n    ///\n    /// If this function returns an error, it is unspecified how many bytes it\n    /// has read, but it will never read more than would be necessary to\n    /// completely fill the buffer.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`read`]: Read::read\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = [0; 10];\n    ///\n    ///     // read exactly 10 bytes\n    ///     f.read_exact(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    fn read_exact(&mut self, buf: &mut [u8]) -> Result<()> {\n        default_read_exact(self, buf)\n    }\n\n    /// Creates a \"by reference\" adaptor for this instance of `Read`.\n    ///\n    /// The returned adaptor also implements `Read` and will simply borrow this\n    /// current reader.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::Read;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = Vec::new();\n    ///     let mut other_buffer = Vec::new();\n    ///\n    ///     {\n    ///         let reference = f.by_ref();\n    ///\n    ///         // read at most 5 bytes\n    ///         reference.take(5).read_to_end(&mut buffer)?;\n    ///\n    ///     } // drop our &mut reference so we can use f again\n    ///\n    ///     // original file still usable, read the rest\n    ///     f.read_to_end(&mut other_buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self\n    where\n        Self: Sized,\n    {\n        self\n    }\n\n    /// Transforms this `Read` instance to an [`Iterator`] over its bytes.\n    ///\n    /// The returned type implements [`Iterator`] where the `Item` is\n    /// [`Result`]`<`[`u8`]`, `[`io::Error`]`>`.\n    /// The yielded item is [`Ok`] if a byte was successfully read and [`Err`]\n    /// otherwise. EOF is mapped to returning [`None`] from this iterator.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    /// [`Result`]: crate::result::Result\n    /// [`io::Error`]: self::Error\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///\n    ///     for byte in f.bytes() {\n    ///         println!(\"{}\", byte.unwrap());\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bytes(self) -> Bytes<Self>\n    where\n        Self: Sized,\n    {\n        Bytes { inner: self }\n    }\n\n    /// Creates an adaptor which will chain this stream with another.\n    ///\n    /// The returned `Read` instance will first read all bytes from this object\n    /// until EOF is encountered. Afterwards the output is equivalent to the\n    /// output of `next`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f1 = File::open(\"foo.txt\")?;\n    ///     let mut f2 = File::open(\"bar.txt\")?;\n    ///\n    ///     let mut handle = f1.chain(f2);\n    ///     let mut buffer = String::new();\n    ///\n    ///     // read the value into a String. We could use any Read method here,\n    ///     // this is just one example.\n    ///     handle.read_to_string(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn chain<R: Read>(self, next: R) -> Chain<Self, R>\n    where\n        Self: Sized,\n    {\n        Chain { first: self, second: next, done_first: false }\n    }\n\n    /// Creates an adaptor which will read at most `limit` bytes from it.\n    ///\n    /// This function returns a new instance of `Read` which will read at most\n    /// `limit` bytes, after which it will always return EOF ([`Ok(0)`]). Any\n    /// read errors will not count towards the number of bytes read and future\n    /// calls to [`read()`] may succeed.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: crate::fs::File\n    /// [`Ok(0)`]: Ok\n    /// [`read()`]: Read::read\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = [0; 5];\n    ///\n    ///     // read at most five bytes\n    ///     let mut handle = f.take(5);\n    ///\n    ///     handle.read(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn take(self, limit: u64) -> Take<Self>\n    where\n        Self: Sized,\n    {\n        Take { inner: self, limit }\n    }\n}\n\n/// Read all bytes from a [reader][Read] into a new [`String`].\n///\n/// This is a convenience function for [`Read::read_to_string`]. Using this\n/// function avoids having to create a variable first and provides more type\n/// safety since you can only get the buffer out if there were no errors. (If you\n/// use [`Read::read_to_string`] you have to remember to check whether the read\n/// succeeded because otherwise your buffer will be empty or only partially full.)\n///\n/// # Performance\n///\n/// The downside of this function's increased ease of use and type safety is\n/// that it gives you less control over performance. For example, you can't\n/// pre-allocate memory like you can using [`String::with_capacity`] and\n/// [`Read::read_to_string`]. Also, you can't re-use the buffer if an error\n/// occurs while reading.\n///\n/// In many cases, this function's performance will be adequate and the ease of use\n/// and type safety tradeoffs will be worth it. However, there are cases where you\n/// need more control over performance, and in those cases you should definitely use\n/// [`Read::read_to_string`] directly.\n///\n/// # Errors\n///\n/// This function forces you to handle errors because the output (the `String`)\n/// is wrapped in a [`Result`]. See [`Read::read_to_string`] for the errors\n/// that can occur. If any error occurs, you will get an [`Err`], so you\n/// don't have to worry about your buffer being empty or partially full.\n///\n/// # Examples\n///\n/// ```no_run\n/// #![feature(io_read_to_string)]\n///\n/// # use std::io;\n/// fn main() -> io::Result<()> {\n///     let stdin = io::read_to_string(&mut io::stdin())?;\n///     println!(\"Stdin was:\");\n///     println!(\"{}\", stdin);\n///     Ok(())\n/// }\n/// ```\n#[unstable(feature = \"io_read_to_string\", issue = \"80218\")]\npub fn read_to_string<R: Read>(reader: &mut R) -> Result<String> {\n    let mut buf = String::new();\n    reader.read_to_string(&mut buf)?;\n    Ok(buf)\n}\n\n/// A buffer type used with `Read::read_vectored`.\n///\n/// It is semantically a wrapper around an `&mut [u8]`, but is guaranteed to be\n/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n/// Windows.\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\n#[repr(transparent)]\npub struct IoSliceMut<'a>(sys::io::IoSliceMut<'a>);\n\n#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\nunsafe impl<'a> Send for IoSliceMut<'a> {}\n\n#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\nunsafe impl<'a> Sync for IoSliceMut<'a> {}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> fmt::Debug for IoSliceMut<'a> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.0.as_slice(), fmt)\n    }\n}\n\nimpl<'a> IoSliceMut<'a> {\n    /// Creates a new `IoSliceMut` wrapping a byte slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics on Windows if the slice is larger than 4GB.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    #[inline]\n    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n        IoSliceMut(sys::io::IoSliceMut::new(buf))\n    }\n\n    /// Advance the internal cursor of the slice.\n    ///\n    /// # Notes\n    ///\n    /// Elements in the slice may be modified if the cursor is not advanced to\n    /// the end of the slice. For example if we have a slice of buffers with 2\n    /// `IoSliceMut`s, both of length 8, and we advance the cursor by 10 bytes\n    /// the first `IoSliceMut` will be untouched however the second will be\n    /// modified to remove the first 2 bytes (10 - 8).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(io_slice_advance)]\n    ///\n    /// use std::io::IoSliceMut;\n    /// use std::ops::Deref;\n    ///\n    /// let mut buf1 = [1; 8];\n    /// let mut buf2 = [2; 16];\n    /// let mut buf3 = [3; 8];\n    /// let mut bufs = &mut [\n    ///     IoSliceMut::new(&mut buf1),\n    ///     IoSliceMut::new(&mut buf2),\n    ///     IoSliceMut::new(&mut buf3),\n    /// ][..];\n    ///\n    /// // Mark 10 bytes as read.\n    /// bufs = IoSliceMut::advance(bufs, 10);\n    /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n    /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n    /// ```\n    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n    #[inline]\n    pub fn advance<'b>(bufs: &'b mut [IoSliceMut<'a>], n: usize) -> &'b mut [IoSliceMut<'a>] {\n        // Number of buffers to remove.\n        let mut remove = 0;\n        // Total length of all the to be removed buffers.\n        let mut accumulated_len = 0;\n        for buf in bufs.iter() {\n            if accumulated_len + buf.len() > n {\n                break;\n            } else {\n                accumulated_len += buf.len();\n                remove += 1;\n            }\n        }\n\n        let bufs = &mut bufs[remove..];\n        if !bufs.is_empty() {\n            bufs[0].0.advance(n - accumulated_len)\n        }\n        bufs\n    }\n}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> Deref for IoSliceMut<'a> {\n    type Target = [u8];\n\n    #[inline]\n    fn deref(&self) -> &[u8] {\n        self.0.as_slice()\n    }\n}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> DerefMut for IoSliceMut<'a> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut [u8] {\n        self.0.as_mut_slice()\n    }\n}\n\n/// A buffer type used with `Write::write_vectored`.\n///\n/// It is semantically a wrapper around an `&[u8]`, but is guaranteed to be\n/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n/// Windows.\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\n#[derive(Copy, Clone)]\n#[repr(transparent)]\npub struct IoSlice<'a>(sys::io::IoSlice<'a>);\n\n#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\nunsafe impl<'a> Send for IoSlice<'a> {}\n\n#[stable(feature = \"iovec-send-sync\", since = \"1.44.0\")]\nunsafe impl<'a> Sync for IoSlice<'a> {}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> fmt::Debug for IoSlice<'a> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.0.as_slice(), fmt)\n    }\n}\n\nimpl<'a> IoSlice<'a> {\n    /// Creates a new `IoSlice` wrapping a byte slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics on Windows if the slice is larger than 4GB.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    #[inline]\n    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n        IoSlice(sys::io::IoSlice::new(buf))\n    }\n\n    /// Advance the internal cursor of the slice.\n    ///\n    /// # Notes\n    ///\n    /// Elements in the slice may be modified if the cursor is not advanced to\n    /// the end of the slice. For example if we have a slice of buffers with 2\n    /// `IoSlice`s, both of length 8, and we advance the cursor by 10 bytes the\n    /// first `IoSlice` will be untouched however the second will be modified to\n    /// remove the first 2 bytes (10 - 8).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(io_slice_advance)]\n    ///\n    /// use std::io::IoSlice;\n    /// use std::ops::Deref;\n    ///\n    /// let buf1 = [1; 8];\n    /// let buf2 = [2; 16];\n    /// let buf3 = [3; 8];\n    /// let mut bufs = &mut [\n    ///     IoSlice::new(&buf1),\n    ///     IoSlice::new(&buf2),\n    ///     IoSlice::new(&buf3),\n    /// ][..];\n    ///\n    /// // Mark 10 bytes as written.\n    /// bufs = IoSlice::advance(bufs, 10);\n    /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n    /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n    #[inline]\n    pub fn advance<'b>(bufs: &'b mut [IoSlice<'a>], n: usize) -> &'b mut [IoSlice<'a>] {\n        // Number of buffers to remove.\n        let mut remove = 0;\n        // Total length of all the to be removed buffers.\n        let mut accumulated_len = 0;\n        for buf in bufs.iter() {\n            if accumulated_len + buf.len() > n {\n                break;\n            } else {\n                accumulated_len += buf.len();\n                remove += 1;\n            }\n        }\n\n        let bufs = &mut bufs[remove..];\n        if !bufs.is_empty() {\n            bufs[0].0.advance(n - accumulated_len)\n        }\n        bufs\n    }\n}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> Deref for IoSlice<'a> {\n    type Target = [u8];\n\n    #[inline]\n    fn deref(&self) -> &[u8] {\n        self.0.as_slice()\n    }\n}\n\n/// A type used to conditionally initialize buffers passed to `Read` methods.\n#[unstable(feature = \"read_initializer\", issue = \"42788\")]\n#[derive(Debug)]\npub struct Initializer(bool);\n\nimpl Initializer {\n    /// Returns a new `Initializer` which will zero out buffers.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn zeroing() -> Initializer {\n        Initializer(true)\n    }\n\n    /// Returns a new `Initializer` which will not zero out buffers.\n    ///\n    /// # Safety\n    ///\n    /// This may only be called by `Read`ers which guarantee that they will not\n    /// read from buffers passed to `Read` methods, and that the return value of\n    /// the method accurately reflects the number of bytes that have been\n    /// written to the head of the buffer.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub unsafe fn nop() -> Initializer {\n        Initializer(false)\n    }\n\n    /// Indicates if a buffer should be initialized.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn should_initialize(&self) -> bool {\n        self.0\n    }\n\n    /// Initializes a buffer if necessary.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn initialize(&self, buf: &mut [u8]) {\n        if self.should_initialize() {\n            unsafe { ptr::write_bytes(buf.as_mut_ptr(), 0, buf.len()) }\n        }\n    }\n}\n\n/// A trait for objects which are byte-oriented sinks.\n///\n/// Implementors of the `Write` trait are sometimes called 'writers'.\n///\n/// Writers are defined by two required methods, [`write`] and [`flush`]:\n///\n/// * The [`write`] method will attempt to write some data into the object,\n///   returning how many bytes were successfully written.\n///\n/// * The [`flush`] method is useful for adaptors and explicit buffers\n///   themselves for ensuring that all buffered data has been pushed out to the\n///   'true sink'.\n///\n/// Writers are intended to be composable with one another. Many implementors\n/// throughout [`std::io`] take and provide types which implement the `Write`\n/// trait.\n///\n/// [`write`]: Write::write\n/// [`flush`]: Write::flush\n/// [`std::io`]: self\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// fn main() -> std::io::Result<()> {\n///     let data = b\"some bytes\";\n///\n///     let mut pos = 0;\n///     let mut buffer = File::create(\"foo.txt\")?;\n///\n///     while pos < data.len() {\n///         let bytes_written = buffer.write(&data[pos..])?;\n///         pos += bytes_written;\n///     }\n///     Ok(())\n/// }\n/// ```\n///\n/// The trait also provides convenience methods like [`write_all`], which calls\n/// `write` in a loop until its entire input has been written.\n///\n/// [`write_all`]: Write::write_all\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(notable_trait)]\npub trait Write {\n    /// Write a buffer into this writer, returning how many bytes were written.\n    ///\n    /// This function will attempt to write the entire contents of `buf`, but\n    /// the entire write may not succeed, or the write may also generate an\n    /// error. A call to `write` represents *at most one* attempt to write to\n    /// any wrapped object.\n    ///\n    /// Calls to `write` are not guaranteed to block waiting for data to be\n    /// written, and a write which would otherwise block can be indicated through\n    /// an [`Err`] variant.\n    ///\n    /// If the return value is [`Ok(n)`] then it must be guaranteed that\n    /// `n <= buf.len()`. A return value of `0` typically means that the\n    /// underlying object is no longer able to accept bytes and will likely not\n    /// be able to in the future as well, or that the buffer provided is empty.\n    ///\n    /// # Errors\n    ///\n    /// Each call to `write` may generate an I/O error indicating that the\n    /// operation could not be completed. If an error is returned then no bytes\n    /// in the buffer were written to this writer.\n    ///\n    /// It is **not** considered an error if the entire buffer could not be\n    /// written to this writer.\n    ///\n    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n    /// write operation should be retried if there is nothing else to do.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     // Writes some prefix of the byte string, not necessarily all of it.\n    ///     buffer.write(b\"some bytes\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// [`Ok(n)`]: Ok\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n\n    /// Like [`write`], except that it writes from a slice of buffers.\n    ///\n    /// Data is copied from each buffer in order, with the final buffer\n    /// read from possibly being only partially consumed. This method must\n    /// behave as a call to [`write`] with the buffers concatenated would.\n    ///\n    /// The default implementation calls [`write`] with either the first nonempty\n    /// buffer provided, or an empty one if none exists.\n    ///\n    /// [`write`]: Write::write\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> Result<usize> {\n        default_write_vectored(|b| self.write(b), bufs)\n    }\n\n    /// Determines if this `Write`r has an efficient [`write_vectored`]\n    /// implementation.\n    ///\n    /// If a `Write`r does not override the default [`write_vectored`]\n    /// implementation, code using it may want to avoid the method all together\n    /// and coalesce writes into a single buffer for higher performance.\n    ///\n    /// The default implementation returns `false`.\n    ///\n    /// [`write_vectored`]: Write::write_vectored\n    #[unstable(feature = \"can_vector\", issue = \"69941\")]\n    fn is_write_vectored(&self) -> bool {\n        false\n    }\n\n    /// Flush this output stream, ensuring that all intermediately buffered\n    /// contents reach their destination.\n    ///\n    /// # Errors\n    ///\n    /// It is considered an error if not all bytes could be written due to\n    /// I/O errors or EOF being reached.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::io::BufWriter;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = BufWriter::new(File::create(\"foo.txt\")?);\n    ///\n    ///     buffer.write_all(b\"some bytes\")?;\n    ///     buffer.flush()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn flush(&mut self) -> Result<()>;\n\n    /// Attempts to write an entire buffer into this writer.\n    ///\n    /// This method will continuously call [`write`] until there is no more data\n    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n    /// returned. This method will not return until the entire buffer has been\n    /// successfully written or such an error occurs. The first error that is\n    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n    /// returned.\n    ///\n    /// If the buffer contains no data, this will never call [`write`].\n    ///\n    /// # Errors\n    ///\n    /// This function will return the first error of\n    /// non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n    ///\n    /// [`write`]: Write::write\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     buffer.write_all(b\"some bytes\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n        while !buf.is_empty() {\n            match self.write(buf) {\n                Ok(0) => {\n                    return Err(Error::new_const(\n                        ErrorKind::WriteZero,\n                        &\"failed to write whole buffer\",\n                    ));\n                }\n                Ok(n) => buf = &buf[n..],\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Attempts to write multiple buffers into this writer.\n    ///\n    /// This method will continuously call [`write_vectored`] until there is no\n    /// more data to be written or an error of non-[`ErrorKind::Interrupted`]\n    /// kind is returned. This method will not return until all buffers have\n    /// been successfully written or such an error occurs. The first error that\n    /// is not of [`ErrorKind::Interrupted`] kind generated from this method\n    /// will be returned.\n    ///\n    /// If the buffer contains no data, this will never call [`write_vectored`].\n    ///\n    /// # Notes\n    ///\n    /// Unlike [`write_vectored`], this takes a *mutable* reference to\n    /// a slice of [`IoSlice`]s, not an immutable one. That's because we need to\n    /// modify the slice to keep track of the bytes already written.\n    ///\n    /// Once this function returns, the contents of `bufs` are unspecified, as\n    /// this depends on how many calls to [`write_vectored`] were necessary. It is\n    /// best to understand this function as taking ownership of `bufs` and to\n    /// not use `bufs` afterwards. The underlying buffers, to which the\n    /// [`IoSlice`]s point (but not the [`IoSlice`]s themselves), are unchanged and\n    /// can be reused.\n    ///\n    /// [`write_vectored`]: Write::write_vectored\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(write_all_vectored)]\n    /// # fn main() -> std::io::Result<()> {\n    ///\n    /// use std::io::{Write, IoSlice};\n    ///\n    /// let mut writer = Vec::new();\n    /// let bufs = &mut [\n    ///     IoSlice::new(&[1]),\n    ///     IoSlice::new(&[2, 3]),\n    ///     IoSlice::new(&[4, 5, 6]),\n    /// ];\n    ///\n    /// writer.write_all_vectored(bufs)?;\n    /// // Note: the contents of `bufs` is now undefined, see the Notes section.\n    ///\n    /// assert_eq!(writer, &[1, 2, 3, 4, 5, 6]);\n    /// # Ok(()) }\n    /// ```\n    #[unstable(feature = \"write_all_vectored\", issue = \"70436\")]\n    fn write_all_vectored(&mut self, mut bufs: &mut [IoSlice<'_>]) -> Result<()> {\n        // Guarantee that bufs is empty if it contains no data,\n        // to avoid calling write_vectored if there is no data to be written.\n        bufs = IoSlice::advance(bufs, 0);\n        while !bufs.is_empty() {\n            match self.write_vectored(bufs) {\n                Ok(0) => {\n                    return Err(Error::new_const(\n                        ErrorKind::WriteZero,\n                        &\"failed to write whole buffer\",\n                    ));\n                }\n                Ok(n) => bufs = IoSlice::advance(bufs, n),\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes a formatted string into this writer, returning any error\n    /// encountered.\n    ///\n    /// This method is primarily used to interface with the\n    /// [`format_args!()`] macro, but it is rare that this should\n    /// explicitly be called. The [`write!()`] macro should be favored to\n    /// invoke this method instead.\n    ///\n    /// This function internally uses the [`write_all`] method on\n    /// this trait and hence will continuously write data so long as no errors\n    /// are received. This also means that partial writes are not indicated in\n    /// this signature.\n    ///\n    /// [`write_all`]: Write::write_all\n    ///\n    /// # Errors\n    ///\n    /// This function will return any I/O error reported while formatting.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     // this call\n    ///     write!(buffer, \"{:.*}\", 2, 1.234567)?;\n    ///     // turns into this:\n    ///     buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> Result<()> {\n        // Create a shim which translates a Write to a fmt::Write and saves\n        // off I/O errors. instead of discarding them\n        struct Adaptor<'a, T: ?Sized + 'a> {\n            inner: &'a mut T,\n            error: Result<()>,\n        }\n\n        impl<T: Write + ?Sized> fmt::Write for Adaptor<'_, T> {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                match self.inner.write_all(s.as_bytes()) {\n                    Ok(()) => Ok(()),\n                    Err(e) => {\n                        self.error = Err(e);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }\n\n        let mut output = Adaptor { inner: self, error: Ok(()) };\n        match fmt::write(&mut output, fmt) {\n            Ok(()) => Ok(()),\n            Err(..) => {\n                // check if the error came from the underlying `Write` or not\n                if output.error.is_err() {\n                    output.error\n                } else {\n                    Err(Error::new_const(ErrorKind::Other, &\"formatter error\"))\n                }\n            }\n        }\n    }\n\n    /// Creates a \"by reference\" adaptor for this instance of `Write`.\n    ///\n    /// The returned adaptor also implements `Write` and will simply borrow this\n    /// current writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::Write;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     let reference = buffer.by_ref();\n    ///\n    ///     // we can use reference just like our original buffer\n    ///     reference.write_all(b\"some bytes\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self\n    where\n        Self: Sized,\n    {\n        self\n    }\n}\n\n/// The `Seek` trait provides a cursor which can be moved within a stream of\n/// bytes.\n///\n/// The stream typically has a fixed size, allowing seeking relative to either\n/// end or the current offset.\n///\n/// # Examples\n///\n/// [`File`]s implement `Seek`:\n///\n/// [`File`]: crate::fs::File\n///\n/// ```no_run\n/// use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n/// use std::io::SeekFrom;\n///\n/// fn main() -> io::Result<()> {\n///     let mut f = File::open(\"foo.txt\")?;\n///\n///     // move the cursor 42 bytes from the start of the file\n///     f.seek(SeekFrom::Start(42))?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Seek {\n    /// Seek to an offset, in bytes, in a stream.\n    ///\n    /// A seek beyond the end of a stream is allowed, but behavior is defined\n    /// by the implementation.\n    ///\n    /// If the seek operation completed successfully,\n    /// this method returns the new position from the start of the stream.\n    /// That position can be used later with [`SeekFrom::Start`].\n    ///\n    /// # Errors\n    ///\n    /// Seeking can fail, for example because it might involve flushing a buffer.\n    ///\n    /// Seeking to a negative offset is considered an error.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n\n    /// Rewind to the beginning of a stream.\n    ///\n    /// This is a convenience method, equivalent to `seek(SeekFrom::Start(0))`.\n    ///\n    /// # Errors\n    ///\n    /// Rewinding can fail, for example because it might involve flushing a buffer.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// #![feature(seek_rewind)]\n    /// use std::io::{Read, Seek, Write};\n    /// use std::fs::OpenOptions;\n    ///\n    /// let mut f = OpenOptions::new()\n    ///     .write(true)\n    ///     .read(true)\n    ///     .create(true)\n    ///     .open(\"foo.txt\").unwrap();\n    ///\n    /// let hello = \"Hello!\\n\";\n    /// write!(f, \"{}\", hello).unwrap();\n    /// f.rewind().unwrap();\n    ///\n    /// let mut buf = String::new();\n    /// f.read_to_string(&mut buf).unwrap();\n    /// assert_eq!(&buf, hello);\n    /// ```\n    #[unstable(feature = \"seek_rewind\", issue = \"85149\")]\n    fn rewind(&mut self) -> Result<()> {\n        self.seek(SeekFrom::Start(0))?;\n        Ok(())\n    }\n\n    /// Returns the length of this stream (in bytes).\n    ///\n    /// This method is implemented using up to three seek operations. If this\n    /// method returns successfully, the seek position is unchanged (i.e. the\n    /// position before calling this method is the same as afterwards).\n    /// However, if this method returns an error, the seek position is\n    /// unspecified.\n    ///\n    /// If you need to obtain the length of *many* streams and you don't care\n    /// about the seek position afterwards, you can reduce the number of seek\n    /// operations by simply calling `seek(SeekFrom::End(0))` and using its\n    /// return value (it is also the stream length).\n    ///\n    /// Note that length of a stream can change over time (for example, when\n    /// data is appended to a file). So calling this method multiple times does\n    /// not necessarily return the same length each time.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// #![feature(seek_stream_len)]\n    /// use std::{\n    ///     io::{self, Seek},\n    ///     fs::File,\n    /// };\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///\n    ///     let len = f.stream_len()?;\n    ///     println!(\"The file is currently {} bytes long\", len);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[unstable(feature = \"seek_stream_len\", issue = \"59359\")]\n    fn stream_len(&mut self) -> Result<u64> {\n        let old_pos = self.stream_position()?;\n        let len = self.seek(SeekFrom::End(0))?;\n\n        // Avoid seeking a third time when we were already at the end of the\n        // stream. The branch is usually way cheaper than a seek operation.\n        if old_pos != len {\n            self.seek(SeekFrom::Start(old_pos))?;\n        }\n\n        Ok(len)\n    }\n\n    /// Returns the current seek position from the start of the stream.\n    ///\n    /// This is equivalent to `self.seek(SeekFrom::Current(0))`.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use std::{\n    ///     io::{self, BufRead, BufReader, Seek},\n    ///     fs::File,\n    /// };\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n    ///\n    ///     let before = f.stream_position()?;\n    ///     f.read_line(&mut String::new())?;\n    ///     let after = f.stream_position()?;\n    ///\n    ///     println!(\"The first line was {} bytes long\", after - before);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"seek_convenience\", since = \"1.51.0\")]\n    fn stream_position(&mut self) -> Result<u64> {\n        self.seek(SeekFrom::Current(0))\n    }\n}\n\n/// Enumeration of possible methods to seek within an I/O object.\n///\n/// It is used by the [`Seek`] trait.\n#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum SeekFrom {\n    /// Sets the offset to the provided number of bytes.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Start(#[stable(feature = \"rust1\", since = \"1.0.0\")] u64),\n\n    /// Sets the offset to the size of this object plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    End(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n\n    /// Sets the offset to the current position plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Current(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n}\n\nfn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> Result<usize> {\n    let mut read = 0;\n    loop {\n        let (done, used) = {\n            let available = match r.fill_buf() {\n                Ok(n) => n,\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                Err(e) => return Err(e),\n            };\n            match memchr::memchr(delim, available) {\n                Some(i) => {\n                    buf.extend_from_slice(&available[..=i]);\n                    (true, i + 1)\n                }\n                None => {\n                    buf.extend_from_slice(available);\n                    (false, available.len())\n                }\n            }\n        };\n        r.consume(used);\n        read += used;\n        if done || used == 0 {\n            return Ok(read);\n        }\n    }\n}\n\n/// A `BufRead` is a type of `Read`er which has an internal buffer, allowing it\n/// to perform extra ways of reading.\n///\n/// For example, reading line-by-line is inefficient without using a buffer, so\n/// if you want to read by line, you'll need `BufRead`, which includes a\n/// [`read_line`] method as well as a [`lines`] iterator.\n///\n/// # Examples\n///\n/// A locked standard input implements `BufRead`:\n///\n/// ```no_run\n/// use std::io;\n/// use std::io::prelude::*;\n///\n/// let stdin = io::stdin();\n/// for line in stdin.lock().lines() {\n///     println!(\"{}\", line.unwrap());\n/// }\n/// ```\n///\n/// If you have something that implements [`Read`], you can use the [`BufReader`\n/// type][`BufReader`] to turn it into a `BufRead`.\n///\n/// For example, [`File`] implements [`Read`], but not `BufRead`.\n/// [`BufReader`] to the rescue!\n///\n/// [`File`]: crate::fs::File\n/// [`read_line`]: BufRead::read_line\n/// [`lines`]: BufRead::lines\n///\n/// ```no_run\n/// use std::io::{self, BufReader};\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// fn main() -> io::Result<()> {\n///     let f = File::open(\"foo.txt\")?;\n///     let f = BufReader::new(f);\n///\n///     for line in f.lines() {\n///         println!(\"{}\", line.unwrap());\n///     }\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait BufRead: Read {\n    /// Returns the contents of the internal buffer, filling it with more data\n    /// from the inner reader if it is empty.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`consume`] method to function properly. When calling this\n    /// method, none of the contents will be \"read\" in the sense that later\n    /// calling `read` may return the same contents. As such, [`consume`] must\n    /// be called with the number of bytes that are consumed from this buffer to\n    /// ensure that the bytes are never returned twice.\n    ///\n    /// [`consume`]: BufRead::consume\n    ///\n    /// An empty buffer returned indicates that the stream has reached EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an I/O error if the underlying reader was\n    /// read, but returned an error.\n    ///\n    /// # Examples\n    ///\n    /// A locked standard input implements `BufRead`:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    ///\n    /// let stdin = io::stdin();\n    /// let mut stdin = stdin.lock();\n    ///\n    /// let buffer = stdin.fill_buf().unwrap();\n    ///\n    /// // work with buffer\n    /// println!(\"{:?}\", buffer);\n    ///\n    /// // ensure the bytes we worked with aren't returned again later\n    /// let length = buffer.len();\n    /// stdin.consume(length);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fill_buf(&mut self) -> Result<&[u8]>;\n\n    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n    /// so they should no longer be returned in calls to `read`.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`fill_buf`] method to function properly. This function does\n    /// not perform any I/O, it simply informs this object that some amount of\n    /// its buffer, returned from [`fill_buf`], has been consumed and should\n    /// no longer be returned. As such, this function may do odd things if\n    /// [`fill_buf`] isn't called before calling it.\n    ///\n    /// The `amt` must be `<=` the number of bytes in the buffer returned by\n    /// [`fill_buf`].\n    ///\n    /// # Examples\n    ///\n    /// Since `consume()` is meant to be used with [`fill_buf`],\n    /// that method's example includes an example of `consume()`.\n    ///\n    /// [`fill_buf`]: BufRead::fill_buf\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn consume(&mut self, amt: usize);\n\n    /// Read all bytes into `buf` until the delimiter `byte` or EOF is reached.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// delimiter or EOF is found. Once found, all bytes up to, and including,\n    /// the delimiter (if found) will be appended to `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// This function is blocking and should be used carefully: it is possible for\n    /// an attacker to continuously send bytes without ever sending the delimiter\n    /// or EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function will ignore all instances of [`ErrorKind::Interrupted`] and\n    /// will otherwise return any errors returned by [`fill_buf`].\n    ///\n    /// If an I/O error is encountered then all bytes read so far will be\n    /// present in `buf` and its length will have been adjusted appropriately.\n    ///\n    /// [`fill_buf`]: BufRead::fill_buf\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the bytes in a byte slice\n    /// in hyphen delimited segments:\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"lorem-ipsum\");\n    /// let mut buf = vec![];\n    ///\n    /// // cursor is at 'l'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 6);\n    /// assert_eq!(buf, b\"lorem-\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'i'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 5);\n    /// assert_eq!(buf, b\"ipsum\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, b\"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n        read_until(self, byte, buf)\n    }\n\n    /// Read all bytes until a newline (the `0xA` byte) is reached, and append\n    /// them to the provided buffer.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// newline delimiter (the `0xA` byte) or EOF is found. Once found, all bytes\n    /// up to, and including, the delimiter (if found) will be appended to\n    /// `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// If this function returns [`Ok(0)`], the stream has reached EOF.\n    ///\n    /// This function is blocking and should be used carefully: it is possible for\n    /// an attacker to continuously send bytes without ever sending a newline\n    /// or EOF.\n    ///\n    /// [`Ok(0)`]: Ok\n    ///\n    /// # Errors\n    ///\n    /// This function has the same error semantics as [`read_until`] and will\n    /// also return an error if the read bytes are not valid UTF-8. If an I/O\n    /// error is encountered then `buf` may contain some bytes already read in\n    /// the event that all data read so far was valid UTF-8.\n    ///\n    /// [`read_until`]: BufRead::read_until\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the lines in a byte slice:\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"foo\\nbar\");\n    /// let mut buf = String::new();\n    ///\n    /// // cursor is at 'f'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 4);\n    /// assert_eq!(buf, \"foo\\n\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'b'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 3);\n    /// assert_eq!(buf, \"bar\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, \"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n        // Note that we are not calling the `.read_until` method here, but\n        // rather our hardcoded implementation. For more details as to why, see\n        // the comments in `read_to_end`.\n        append_to_string(buf, |b| read_until(self, b'\\n', b))\n    }\n\n    /// Returns an iterator over the contents of this reader split on the byte\n    /// `byte`.\n    ///\n    /// The iterator returned from this function will return instances of\n    /// [`io::Result`]`<`[`Vec<u8>`]`>`. Each vector returned will *not* have\n    /// the delimiter byte at the end.\n    ///\n    /// This function will yield errors whenever [`read_until`] would have\n    /// also yielded an error.\n    ///\n    /// [`io::Result`]: self::Result\n    /// [`read_until`]: BufRead::read_until\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all hyphen delimited\n    /// segments in a byte slice\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem-ipsum-dolor\");\n    ///\n    /// let mut split_iter = cursor.split(b'-').map(|l| l.unwrap());\n    /// assert_eq!(split_iter.next(), Some(b\"lorem\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"ipsum\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"dolor\".to_vec()));\n    /// assert_eq!(split_iter.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn split(self, byte: u8) -> Split<Self>\n    where\n        Self: Sized,\n    {\n        Split { buf: self, delim: byte }\n    }\n\n    /// Returns an iterator over the lines of this reader.\n    ///\n    /// The iterator returned from this function will yield instances of\n    /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n    /// byte (the `0xA` byte) or `CRLF` (`0xD`, `0xA` bytes) at the end.\n    ///\n    /// [`io::Result`]: self::Result\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all the lines in a byte\n    /// slice.\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n    ///\n    /// let mut lines_iter = cursor.lines().map(|l| l.unwrap());\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"lorem\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"ipsum\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"dolor\")));\n    /// assert_eq!(lines_iter.next(), None);\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// Each line of the iterator has the same error semantics as [`BufRead::read_line`].\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn lines(self) -> Lines<Self>\n    where\n        Self: Sized,\n    {\n        Lines { buf: self }\n    }\n}\n\n/// Adaptor to chain together two readers.\n///\n/// This struct is generally created by calling [`chain`] on a reader.\n/// Please see the documentation of [`chain`] for more details.\n///\n/// [`chain`]: Read::chain\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Chain<T, U> {\n    first: T,\n    second: U,\n    done_first: bool,\n}\n\nimpl<T, U> Chain<T, U> {\n    /// Consumes the `Chain`, returning the wrapped readers.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut foo_file = File::open(\"foo.txt\")?;\n    ///     let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    ///     let chain = foo_file.chain(bar_file);\n    ///     let (foo_file, bar_file) = chain.into_inner();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn into_inner(self) -> (T, U) {\n        (self.first, self.second)\n    }\n\n    /// Gets references to the underlying readers in this `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut foo_file = File::open(\"foo.txt\")?;\n    ///     let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    ///     let chain = foo_file.chain(bar_file);\n    ///     let (foo_file, bar_file) = chain.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> (&T, &U) {\n        (&self.first, &self.second)\n    }\n\n    /// Gets mutable references to the underlying readers in this `Chain`.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying readers as doing so may corrupt the internal state of this\n    /// `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut foo_file = File::open(\"foo.txt\")?;\n    ///     let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    ///     let mut chain = foo_file.chain(bar_file);\n    ///     let (foo_file, bar_file) = chain.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> (&mut T, &mut U) {\n        (&mut self.first, &mut self.second)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read, U: Read> Read for Chain<T, U> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        if !self.done_first {\n            match self.first.read(buf)? {\n                0 if !buf.is_empty() => self.done_first = true,\n                n => return Ok(n),\n            }\n        }\n        self.second.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> Result<usize> {\n        if !self.done_first {\n            match self.first.read_vectored(bufs)? {\n                0 if bufs.iter().any(|b| !b.is_empty()) => self.done_first = true,\n                n => return Ok(n),\n            }\n        }\n        self.second.read_vectored(bufs)\n    }\n\n    unsafe fn initializer(&self) -> Initializer {\n        let initializer = self.first.initializer();\n        if initializer.should_initialize() { initializer } else { self.second.initializer() }\n    }\n}\n\n#[stable(feature = \"chain_bufread\", since = \"1.9.0\")]\nimpl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n        if !self.done_first {\n            match self.first.fill_buf()? {\n                buf if buf.is_empty() => {\n                    self.done_first = true;\n                }\n                buf => return Ok(buf),\n            }\n        }\n        self.second.fill_buf()\n    }\n\n    fn consume(&mut self, amt: usize) {\n        if !self.done_first { self.first.consume(amt) } else { self.second.consume(amt) }\n    }\n}\n\nimpl<T, U> SizeHint for Chain<T, U> {\n    fn lower_bound(&self) -> usize {\n        SizeHint::lower_bound(&self.first) + SizeHint::lower_bound(&self.second)\n    }\n\n    fn upper_bound(&self) -> Option<usize> {\n        match (SizeHint::upper_bound(&self.first), SizeHint::upper_bound(&self.second)) {\n            (Some(first), Some(second)) => Some(first + second),\n            _ => None,\n        }\n    }\n}\n\n/// Reader adaptor which limits the bytes read from an underlying reader.\n///\n/// This struct is generally created by calling [`take`] on a reader.\n/// Please see the documentation of [`take`] for more details.\n///\n/// [`take`]: Read::take\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Take<T> {\n    inner: T,\n    limit: u64,\n}\n\nimpl<T> Take<T> {\n    /// Returns the number of bytes that can be read before this instance will\n    /// return EOF.\n    ///\n    /// # Note\n    ///\n    /// This instance may reach `EOF` after reading fewer bytes than indicated by\n    /// this method if the underlying [`Read`] instance reaches EOF.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let f = File::open(\"foo.txt\")?;\n    ///\n    ///     // read at most five bytes\n    ///     let handle = f.take(5);\n    ///\n    ///     println!(\"limit: {}\", handle.limit());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn limit(&self) -> u64 {\n        self.limit\n    }\n\n    /// Sets the number of bytes that can be read before this instance will\n    /// return EOF. This is the same as constructing a new `Take` instance, so\n    /// the amount of bytes read and the previous limit value don't matter when\n    /// calling this method.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let f = File::open(\"foo.txt\")?;\n    ///\n    ///     // read at most five bytes\n    ///     let mut handle = f.take(5);\n    ///     handle.set_limit(10);\n    ///\n    ///     assert_eq!(handle.limit(), 10);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"take_set_limit\", since = \"1.27.0\")]\n    pub fn set_limit(&mut self, limit: u64) {\n        self.limit = limit;\n    }\n\n    /// Consumes the `Take`, returning the wrapped reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///\n    ///     let mut buffer = [0; 5];\n    ///     let mut handle = file.take(5);\n    ///     handle.read(&mut buffer)?;\n    ///\n    ///     let file = handle.into_inner();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"io_take_into_inner\", since = \"1.15.0\")]\n    pub fn into_inner(self) -> T {\n        self.inner\n    }\n\n    /// Gets a reference to the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///\n    ///     let mut buffer = [0; 5];\n    ///     let mut handle = file.take(5);\n    ///     handle.read(&mut buffer)?;\n    ///\n    ///     let file = handle.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> &T {\n        &self.inner\n    }\n\n    /// Gets a mutable reference to the underlying reader.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying reader as doing so may corrupt the internal limit of this\n    /// `Take`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///\n    ///     let mut buffer = [0; 5];\n    ///     let mut handle = file.take(5);\n    ///     handle.read(&mut buffer)?;\n    ///\n    ///     let file = handle.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.inner\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read> Read for Take<T> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        // Don't call into inner reader at all at EOF because it may still block\n        if self.limit == 0 {\n            return Ok(0);\n        }\n\n        let max = cmp::min(buf.len() as u64, self.limit) as usize;\n        let n = self.inner.read(&mut buf[..max])?;\n        self.limit -= n as u64;\n        Ok(n)\n    }\n\n    unsafe fn initializer(&self) -> Initializer {\n        self.inner.initializer()\n    }\n\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n        // Pass in a reservation_size closure that respects the current value\n        // of limit for each read. If we hit the read limit, this prevents the\n        // final zero-byte read from allocating again.\n        read_to_end_with_reservation(self, buf, |self_| cmp::min(self_.limit, 32) as usize)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: BufRead> BufRead for Take<T> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n        // Don't call into inner reader at all at EOF because it may still block\n        if self.limit == 0 {\n            return Ok(&[]);\n        }\n\n        let buf = self.inner.fill_buf()?;\n        let cap = cmp::min(buf.len() as u64, self.limit) as usize;\n        Ok(&buf[..cap])\n    }\n\n    fn consume(&mut self, amt: usize) {\n        // Don't let callers reset the limit by passing an overlarge value\n        let amt = cmp::min(amt as u64, self.limit) as usize;\n        self.limit -= amt as u64;\n        self.inner.consume(amt);\n    }\n}\n\n/// An iterator over `u8` values of a reader.\n///\n/// This struct is generally created by calling [`bytes`] on a reader.\n/// Please see the documentation of [`bytes`] for more details.\n///\n/// [`bytes`]: Read::bytes\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Bytes<R> {\n    inner: R,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> Iterator for Bytes<R> {\n    type Item = Result<u8>;\n\n    fn next(&mut self) -> Option<Result<u8>> {\n        let mut byte = 0;\n        loop {\n            return match self.inner.read(slice::from_mut(&mut byte)) {\n                Ok(0) => None,\n                Ok(..) => Some(Ok(byte)),\n                Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                Err(e) => Some(Err(e)),\n            };\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        SizeHint::size_hint(&self.inner)\n    }\n}\n\ntrait SizeHint {\n    fn lower_bound(&self) -> usize;\n\n    fn upper_bound(&self) -> Option<usize>;\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.lower_bound(), self.upper_bound())\n    }\n}\n\nimpl<T> SizeHint for T {\n    default fn lower_bound(&self) -> usize {\n        0\n    }\n\n    default fn upper_bound(&self) -> Option<usize> {\n        None\n    }\n}\n\n/// An iterator over the contents of an instance of `BufRead` split on a\n/// particular byte.\n///\n/// This struct is generally created by calling [`split`] on a `BufRead`.\n/// Please see the documentation of [`split`] for more details.\n///\n/// [`split`]: BufRead::split\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Split<B> {\n    buf: B,\n    delim: u8,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Split<B> {\n    type Item = Result<Vec<u8>>;\n\n    fn next(&mut self) -> Option<Result<Vec<u8>>> {\n        let mut buf = Vec::new();\n        match self.buf.read_until(self.delim, &mut buf) {\n            Ok(0) => None,\n            Ok(_n) => {\n                if buf[buf.len() - 1] == self.delim {\n                    buf.pop();\n                }\n                Some(Ok(buf))\n            }\n            Err(e) => Some(Err(e)),\n        }\n    }\n}\n\n/// An iterator over the lines of an instance of `BufRead`.\n///\n/// This struct is generally created by calling [`lines`] on a `BufRead`.\n/// Please see the documentation of [`lines`] for more details.\n///\n/// [`lines`]: BufRead::lines\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Lines<B> {\n    buf: B,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Lines<B> {\n    type Item = Result<String>;\n\n    fn next(&mut self) -> Option<Result<String>> {\n        let mut buf = String::new();\n        match self.buf.read_line(&mut buf) {\n            Ok(0) => None,\n            Ok(_n) => {\n                if buf.ends_with('\\n') {\n                    buf.pop();\n                    if buf.ends_with('\\r') {\n                        buf.pop();\n                    }\n                }\n                Some(Ok(buf))\n            }\n            Err(e) => Some(Err(e)),\n        }\n    }\n}\n"],["2580","use super::{repeat, Cursor, SeekFrom};\nuse crate::cmp::{self, min};\nuse crate::io::{self, IoSlice, IoSliceMut};\nuse crate::io::{BufRead, BufReader, Read, Seek, Write};\nuse crate::ops::Deref;\n\n#[test]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn read_until() {\n    let mut buf = Cursor::new(&b\"12\"[..]);\n    let mut v = Vec::new();\n    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 2);\n    assert_eq!(v, b\"12\");\n\n    let mut buf = Cursor::new(&b\"1233\"[..]);\n    let mut v = Vec::new();\n    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 3);\n    assert_eq!(v, b\"123\");\n    v.truncate(0);\n    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 1);\n    assert_eq!(v, b\"3\");\n    v.truncate(0);\n    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 0);\n    assert_eq!(v, []);\n}\n\n#[test]\nfn split() {\n    let buf = Cursor::new(&b\"12\"[..]);\n    let mut s = buf.split(b'3');\n    assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n    assert!(s.next().is_none());\n\n    let buf = Cursor::new(&b\"1233\"[..]);\n    let mut s = buf.split(b'3');\n    assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n    assert_eq!(s.next().unwrap().unwrap(), vec![]);\n    assert!(s.next().is_none());\n}\n\n#[test]\nfn read_line() {\n    let mut buf = Cursor::new(&b\"12\"[..]);\n    let mut v = String::new();\n    assert_eq!(buf.read_line(&mut v).unwrap(), 2);\n    assert_eq!(v, \"12\");\n\n    let mut buf = Cursor::new(&b\"12\\n\\n\"[..]);\n    let mut v = String::new();\n    assert_eq!(buf.read_line(&mut v).unwrap(), 3);\n    assert_eq!(v, \"12\\n\");\n    v.truncate(0);\n    assert_eq!(buf.read_line(&mut v).unwrap(), 1);\n    assert_eq!(v, \"\\n\");\n    v.truncate(0);\n    assert_eq!(buf.read_line(&mut v).unwrap(), 0);\n    assert_eq!(v, \"\");\n}\n\n#[test]\nfn lines() {\n    let buf = Cursor::new(&b\"12\\r\"[..]);\n    let mut s = buf.lines();\n    assert_eq!(s.next().unwrap().unwrap(), \"12\\r\".to_string());\n    assert!(s.next().is_none());\n\n    let buf = Cursor::new(&b\"12\\r\\n\\n\"[..]);\n    let mut s = buf.lines();\n    assert_eq!(s.next().unwrap().unwrap(), \"12\".to_string());\n    assert_eq!(s.next().unwrap().unwrap(), \"\".to_string());\n    assert!(s.next().is_none());\n}\n\n#[test]\nfn read_to_end() {\n    let mut c = Cursor::new(&b\"\"[..]);\n    let mut v = Vec::new();\n    assert_eq!(c.read_to_end(&mut v).unwrap(), 0);\n    assert_eq!(v, []);\n\n    let mut c = Cursor::new(&b\"1\"[..]);\n    let mut v = Vec::new();\n    assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n    assert_eq!(v, b\"1\");\n\n    let cap = 1024 * 1024;\n    let data = (0..cap).map(|i| (i / 3) as u8).collect::<Vec<_>>();\n    let mut v = Vec::new();\n    let (a, b) = data.split_at(data.len() / 2);\n    assert_eq!(Cursor::new(a).read_to_end(&mut v).unwrap(), a.len());\n    assert_eq!(Cursor::new(b).read_to_end(&mut v).unwrap(), b.len());\n    assert_eq!(v, data);\n}\n\n#[test]\nfn read_to_string() {\n    let mut c = Cursor::new(&b\"\"[..]);\n    let mut v = String::new();\n    assert_eq!(c.read_to_string(&mut v).unwrap(), 0);\n    assert_eq!(v, \"\");\n\n    let mut c = Cursor::new(&b\"1\"[..]);\n    let mut v = String::new();\n    assert_eq!(c.read_to_string(&mut v).unwrap(), 1);\n    assert_eq!(v, \"1\");\n\n    let mut c = Cursor::new(&b\"\\xff\"[..]);\n    let mut v = String::new();\n    assert!(c.read_to_string(&mut v).is_err());\n}\n\n#[test]\nfn read_exact() {\n    let mut buf = [0; 4];\n\n    let mut c = Cursor::new(&b\"\"[..]);\n    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n\n    let mut c = Cursor::new(&b\"123\"[..]).chain(Cursor::new(&b\"456789\"[..]));\n    c.read_exact(&mut buf).unwrap();\n    assert_eq!(&buf, b\"1234\");\n    c.read_exact(&mut buf).unwrap();\n    assert_eq!(&buf, b\"5678\");\n    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n}\n\n#[test]\nfn read_exact_slice() {\n    let mut buf = [0; 4];\n\n    let mut c = &b\"\"[..];\n    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n\n    let mut c = &b\"123\"[..];\n    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n    // make sure the optimized (early returning) method is being used\n    assert_eq!(&buf, &[0; 4]);\n\n    let mut c = &b\"1234\"[..];\n    c.read_exact(&mut buf).unwrap();\n    assert_eq!(&buf, b\"1234\");\n\n    let mut c = &b\"56789\"[..];\n    c.read_exact(&mut buf).unwrap();\n    assert_eq!(&buf, b\"5678\");\n    assert_eq!(c, b\"9\");\n}\n\n#[test]\nfn take_eof() {\n    struct R;\n\n    impl Read for R {\n        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n        }\n    }\n    impl BufRead for R {\n        fn fill_buf(&mut self) -> io::Result<&[u8]> {\n            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n        }\n        fn consume(&mut self, _amt: usize) {}\n    }\n\n    let mut buf = [0; 1];\n    assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n    assert_eq!(b\"\", R.take(0).fill_buf().unwrap());\n}\n\nfn cmp_bufread<Br1: BufRead, Br2: BufRead>(mut br1: Br1, mut br2: Br2, exp: &[u8]) {\n    let mut cat = Vec::new();\n    loop {\n        let consume = {\n            let buf1 = br1.fill_buf().unwrap();\n            let buf2 = br2.fill_buf().unwrap();\n            let minlen = if buf1.len() < buf2.len() { buf1.len() } else { buf2.len() };\n            assert_eq!(buf1[..minlen], buf2[..minlen]);\n            cat.extend_from_slice(&buf1[..minlen]);\n            minlen\n        };\n        if consume == 0 {\n            break;\n        }\n        br1.consume(consume);\n        br2.consume(consume);\n    }\n    assert_eq!(br1.fill_buf().unwrap().len(), 0);\n    assert_eq!(br2.fill_buf().unwrap().len(), 0);\n    assert_eq!(&cat[..], &exp[..])\n}\n\n#[test]\nfn chain_bufread() {\n    let testdata = b\"ABCDEFGHIJKL\";\n    let chain1 =\n        (&testdata[..3]).chain(&testdata[3..6]).chain(&testdata[6..9]).chain(&testdata[9..]);\n    let chain2 = (&testdata[..4]).chain(&testdata[4..8]).chain(&testdata[8..]);\n    cmp_bufread(chain1, chain2, &testdata[..]);\n}\n\n#[test]\nfn bufreader_size_hint() {\n    let testdata = b\"ABCDEFGHIJKL\";\n    let mut buf_reader = BufReader::new(&testdata[..]);\n    assert_eq!(buf_reader.buffer().len(), 0);\n\n    let buffer_length = testdata.len();\n    buf_reader.fill_buf().unwrap();\n\n    // Check that size hint matches buffer contents\n    let mut buffered_bytes = buf_reader.bytes();\n    let (lower_bound, _upper_bound) = buffered_bytes.size_hint();\n    assert_eq!(lower_bound, buffer_length);\n\n    // Check that size hint matches buffer contents after advancing\n    buffered_bytes.next().unwrap().unwrap();\n    let (lower_bound, _upper_bound) = buffered_bytes.size_hint();\n    assert_eq!(lower_bound, buffer_length - 1);\n}\n\n#[test]\nfn empty_size_hint() {\n    let size_hint = io::empty().bytes().size_hint();\n    assert_eq!(size_hint, (0, Some(0)));\n}\n\n#[test]\nfn chain_empty_size_hint() {\n    let chain = io::empty().chain(io::empty());\n    let size_hint = chain.bytes().size_hint();\n    assert_eq!(size_hint, (0, Some(0)));\n}\n\n#[test]\nfn chain_size_hint() {\n    let testdata = b\"ABCDEFGHIJKL\";\n    let mut buf_reader_1 = BufReader::new(&testdata[..6]);\n    let mut buf_reader_2 = BufReader::new(&testdata[6..]);\n\n    buf_reader_1.fill_buf().unwrap();\n    buf_reader_2.fill_buf().unwrap();\n\n    let chain = buf_reader_1.chain(buf_reader_2);\n    let size_hint = chain.bytes().size_hint();\n    assert_eq!(size_hint, (testdata.len(), None));\n}\n\n#[test]\nfn chain_zero_length_read_is_not_eof() {\n    let a = b\"A\";\n    let b = b\"B\";\n    let mut s = String::new();\n    let mut chain = (&a[..]).chain(&b[..]);\n    chain.read(&mut []).unwrap();\n    chain.read_to_string(&mut s).unwrap();\n    assert_eq!(\"AB\", s);\n}\n\n#[bench]\n#[cfg_attr(target_os = \"emscripten\", ignore)]\nfn bench_read_to_end(b: &mut test::Bencher) {\n    b.iter(|| {\n        let mut lr = repeat(1).take(10000000);\n        let mut vec = Vec::with_capacity(1024);\n        super::read_to_end(&mut lr, &mut vec)\n    });\n}\n\n#[test]\nfn seek_len() -> io::Result<()> {\n    let mut c = Cursor::new(vec![0; 15]);\n    assert_eq!(c.stream_len()?, 15);\n\n    c.seek(SeekFrom::End(0))?;\n    let old_pos = c.stream_position()?;\n    assert_eq!(c.stream_len()?, 15);\n    assert_eq!(c.stream_position()?, old_pos);\n\n    c.seek(SeekFrom::Start(7))?;\n    c.seek(SeekFrom::Current(2))?;\n    let old_pos = c.stream_position()?;\n    assert_eq!(c.stream_len()?, 15);\n    assert_eq!(c.stream_position()?, old_pos);\n\n    Ok(())\n}\n\n#[test]\nfn seek_position() -> io::Result<()> {\n    // All `asserts` are duplicated here to make sure the method does not\n    // change anything about the seek state.\n    let mut c = Cursor::new(vec![0; 15]);\n    assert_eq!(c.stream_position()?, 0);\n    assert_eq!(c.stream_position()?, 0);\n\n    c.seek(SeekFrom::End(0))?;\n    assert_eq!(c.stream_position()?, 15);\n    assert_eq!(c.stream_position()?, 15);\n\n    c.seek(SeekFrom::Start(7))?;\n    c.seek(SeekFrom::Current(2))?;\n    assert_eq!(c.stream_position()?, 9);\n    assert_eq!(c.stream_position()?, 9);\n\n    c.seek(SeekFrom::End(-3))?;\n    c.seek(SeekFrom::Current(1))?;\n    c.seek(SeekFrom::Current(-5))?;\n    assert_eq!(c.stream_position()?, 8);\n    assert_eq!(c.stream_position()?, 8);\n\n    Ok(())\n}\n\n// A simple example reader which uses the default implementation of\n// read_to_end.\nstruct ExampleSliceReader<'a> {\n    slice: &'a [u8],\n}\n\nimpl<'a> Read for ExampleSliceReader<'a> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let len = cmp::min(self.slice.len(), buf.len());\n        buf[..len].copy_from_slice(&self.slice[..len]);\n        self.slice = &self.slice[len..];\n        Ok(len)\n    }\n}\n\n#[test]\nfn test_read_to_end_capacity() -> io::Result<()> {\n    let input = &b\"foo\"[..];\n\n    // read_to_end() generally needs to over-allocate, both for efficiency\n    // and so that it can distinguish EOF. Assert that this is the case\n    // with this simple ExampleSliceReader struct, which uses the default\n    // implementation of read_to_end. Even though vec1 is allocated with\n    // exactly enough capacity for the read, read_to_end will allocate more\n    // space here.\n    let mut vec1 = Vec::with_capacity(input.len());\n    ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n    assert_eq!(vec1.len(), input.len());\n    assert!(vec1.capacity() > input.len(), \"allocated more\");\n\n    // However, std::io::Take includes an implementation of read_to_end\n    // that will not allocate when the limit has already been reached. In\n    // this case, vec2 never grows.\n    let mut vec2 = Vec::with_capacity(input.len());\n    ExampleSliceReader { slice: input }.take(input.len() as u64).read_to_end(&mut vec2)?;\n    assert_eq!(vec2.len(), input.len());\n    assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n\n    Ok(())\n}\n\n#[test]\nfn io_slice_mut_advance() {\n    let mut buf1 = [1; 8];\n    let mut buf2 = [2; 16];\n    let mut buf3 = [3; 8];\n    let mut bufs = &mut [\n        IoSliceMut::new(&mut buf1),\n        IoSliceMut::new(&mut buf2),\n        IoSliceMut::new(&mut buf3),\n    ][..];\n\n    // Only in a single buffer..\n    bufs = IoSliceMut::advance(bufs, 1);\n    assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n    assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n    assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n\n    // Removing a buffer, leaving others as is.\n    bufs = IoSliceMut::advance(bufs, 7);\n    assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n    assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n\n    // Removing a buffer and removing from the next buffer.\n    bufs = IoSliceMut::advance(bufs, 18);\n    assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n}\n\n#[test]\nfn io_slice_mut_advance_empty_slice() {\n    let empty_bufs = &mut [][..];\n    // Shouldn't panic.\n    IoSliceMut::advance(empty_bufs, 1);\n}\n\n#[test]\nfn io_slice_mut_advance_beyond_total_length() {\n    let mut buf1 = [1; 8];\n    let mut bufs = &mut [IoSliceMut::new(&mut buf1)][..];\n\n    // Going beyond the total length should be ok.\n    bufs = IoSliceMut::advance(bufs, 9);\n    assert!(bufs.is_empty());\n}\n\n#[test]\nfn io_slice_advance() {\n    let buf1 = [1; 8];\n    let buf2 = [2; 16];\n    let buf3 = [3; 8];\n    let mut bufs = &mut [IoSlice::new(&buf1), IoSlice::new(&buf2), IoSlice::new(&buf3)][..];\n\n    // Only in a single buffer..\n    bufs = IoSlice::advance(bufs, 1);\n    assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n    assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n    assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n\n    // Removing a buffer, leaving others as is.\n    bufs = IoSlice::advance(bufs, 7);\n    assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n    assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n\n    // Removing a buffer and removing from the next buffer.\n    bufs = IoSlice::advance(bufs, 18);\n    assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n}\n\n#[test]\nfn io_slice_advance_empty_slice() {\n    let empty_bufs = &mut [][..];\n    // Shouldn't panic.\n    IoSlice::advance(empty_bufs, 1);\n}\n\n#[test]\nfn io_slice_advance_beyond_total_length() {\n    let buf1 = [1; 8];\n    let mut bufs = &mut [IoSlice::new(&buf1)][..];\n\n    // Going beyond the total length should be ok.\n    bufs = IoSlice::advance(bufs, 9);\n    assert!(bufs.is_empty());\n}\n\n/// Create a new writer that reads from at most `n_bufs` and reads\n/// `per_call` bytes (in total) per call to write.\nfn test_writer(n_bufs: usize, per_call: usize) -> TestWriter {\n    TestWriter { n_bufs, per_call, written: Vec::new() }\n}\n\nstruct TestWriter {\n    n_bufs: usize,\n    per_call: usize,\n    written: Vec<u8>,\n}\n\nimpl Write for TestWriter {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.write_vectored(&[IoSlice::new(buf)])\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let mut left = self.per_call;\n        let mut written = 0;\n        for buf in bufs.iter().take(self.n_bufs) {\n            let n = min(left, buf.len());\n            self.written.extend_from_slice(&buf[0..n]);\n            left -= n;\n            written += n;\n        }\n        Ok(written)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[test]\nfn test_writer_read_from_one_buf() {\n    let mut writer = test_writer(1, 2);\n\n    assert_eq!(writer.write(&[]).unwrap(), 0);\n    assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n\n    // Read at most 2 bytes.\n    assert_eq!(writer.write(&[1, 1, 1]).unwrap(), 2);\n    let bufs = &[IoSlice::new(&[2, 2, 2])];\n    assert_eq!(writer.write_vectored(bufs).unwrap(), 2);\n\n    // Only read from first buf.\n    let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4, 4])];\n    assert_eq!(writer.write_vectored(bufs).unwrap(), 1);\n\n    assert_eq!(writer.written, &[1, 1, 2, 2, 3]);\n}\n\n#[test]\nfn test_writer_read_from_multiple_bufs() {\n    let mut writer = test_writer(3, 3);\n\n    // Read at most 3 bytes from two buffers.\n    let bufs = &[IoSlice::new(&[1]), IoSlice::new(&[2, 2, 2])];\n    assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n\n    // Read at most 3 bytes from three buffers.\n    let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4]), IoSlice::new(&[5, 5])];\n    assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n\n    assert_eq!(writer.written, &[1, 2, 2, 3, 4, 5]);\n}\n\n#[test]\nfn test_write_all_vectored() {\n    #[rustfmt::skip] // Becomes unreadable otherwise.\n    let tests: Vec<(_, &'static [u8])> = vec![\n        (vec![], &[]),\n        (vec![IoSlice::new(&[]), IoSlice::new(&[])], &[]),\n        (vec![IoSlice::new(&[1])], &[1]),\n        (vec![IoSlice::new(&[1, 2])], &[1, 2]),\n        (vec![IoSlice::new(&[1, 2, 3])], &[1, 2, 3]),\n        (vec![IoSlice::new(&[1, 2, 3, 4])], &[1, 2, 3, 4]),\n        (vec![IoSlice::new(&[1, 2, 3, 4, 5])], &[1, 2, 3, 4, 5]),\n        (vec![IoSlice::new(&[1]), IoSlice::new(&[2])], &[1, 2]),\n        (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2])], &[1, 2, 2]),\n        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2])], &[1, 1, 2, 2]),\n        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n        (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 1, 2, 2, 2]),\n        (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 2, 2, 2, 2]),\n        (vec![IoSlice::new(&[1, 1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 1, 2, 2, 2, 2]),\n        (vec![IoSlice::new(&[1]), IoSlice::new(&[2]), IoSlice::new(&[3])], &[1, 2, 3]),\n        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3])], &[1, 1, 2, 2, 3, 3]),\n        (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 2, 2, 3, 3, 3]),\n        (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 1, 1, 2, 2, 2, 3, 3, 3]),\n    ];\n\n    let writer_configs = &[(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)];\n\n    for (n_bufs, per_call) in writer_configs.iter().copied() {\n        for (mut input, wanted) in tests.clone().into_iter() {\n            let mut writer = test_writer(n_bufs, per_call);\n            assert!(writer.write_all_vectored(&mut *input).is_ok());\n            assert_eq!(&*writer.written, &*wanted);\n        }\n    }\n}\n"],["2581","use crate::cmp::{max, min};\nuse crate::io::prelude::*;\nuse crate::io::{\n    copy, empty, repeat, sink, BufWriter, Empty, Repeat, Result, SeekFrom, Sink, DEFAULT_BUF_SIZE,\n};\n\n#[test]\nfn copy_copies() {\n    let mut r = repeat(0).take(4);\n    let mut w = sink();\n    assert_eq!(copy(&mut r, &mut w).unwrap(), 4);\n\n    let mut r = repeat(0).take(1 << 17);\n    assert_eq!(copy(&mut r as &mut dyn Read, &mut w as &mut dyn Write).unwrap(), 1 << 17);\n}\n\nstruct ShortReader {\n    cap: usize,\n    read_size: usize,\n    observed_buffer: usize,\n}\n\nimpl Read for ShortReader {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n        let bytes = min(self.cap, self.read_size);\n        self.cap -= bytes;\n        self.observed_buffer = max(self.observed_buffer, buf.len());\n        Ok(bytes)\n    }\n}\n\nstruct WriteObserver {\n    observed_buffer: usize,\n}\n\nimpl Write for WriteObserver {\n    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.observed_buffer = max(self.observed_buffer, buf.len());\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[test]\nfn copy_specializes_bufwriter() {\n    let cap = 117 * 1024;\n    let buf_sz = 16 * 1024;\n    let mut r = ShortReader { cap, observed_buffer: 0, read_size: 1337 };\n    let mut w = BufWriter::with_capacity(buf_sz, WriteObserver { observed_buffer: 0 });\n    assert_eq!(\n        copy(&mut r, &mut w).unwrap(),\n        cap as u64,\n        \"expected the whole capacity to be copied\"\n    );\n    assert_eq!(r.observed_buffer, buf_sz, \"expected a large buffer to be provided to the reader\");\n    assert!(w.get_mut().observed_buffer > DEFAULT_BUF_SIZE, \"expected coalesced writes\");\n}\n\n#[test]\nfn sink_sinks() {\n    let mut s = sink();\n    assert_eq!(s.write(&[]).unwrap(), 0);\n    assert_eq!(s.write(&[0]).unwrap(), 1);\n    assert_eq!(s.write(&[0; 1024]).unwrap(), 1024);\n    assert_eq!(s.by_ref().write(&[0; 1024]).unwrap(), 1024);\n}\n\n#[test]\nfn empty_reads() {\n    let mut e = empty();\n    assert_eq!(e.read(&mut []).unwrap(), 0);\n    assert_eq!(e.read(&mut [0]).unwrap(), 0);\n    assert_eq!(e.read(&mut [0; 1024]).unwrap(), 0);\n    assert_eq!(e.by_ref().read(&mut [0; 1024]).unwrap(), 0);\n}\n\n#[test]\nfn empty_seeks() {\n    let mut e = empty();\n    assert!(matches!(e.seek(SeekFrom::Start(0)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Start(1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Start(u64::MAX)), Ok(0)));\n\n    assert!(matches!(e.seek(SeekFrom::End(i64::MIN)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::End(-1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::End(0)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::End(1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::End(i64::MAX)), Ok(0)));\n\n    assert!(matches!(e.seek(SeekFrom::Current(i64::MIN)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Current(-1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Current(0)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Current(1)), Ok(0)));\n    assert!(matches!(e.seek(SeekFrom::Current(i64::MAX)), Ok(0)));\n}\n\n#[test]\nfn repeat_repeats() {\n    let mut r = repeat(4);\n    let mut b = [0; 1024];\n    assert_eq!(r.read(&mut b).unwrap(), 1024);\n    assert!(b.iter().all(|b| *b == 4));\n}\n\n#[test]\nfn take_some_bytes() {\n    assert_eq!(repeat(4).take(100).bytes().count(), 100);\n    assert_eq!(repeat(4).take(100).bytes().next().unwrap().unwrap(), 4);\n    assert_eq!(repeat(1).take(10).chain(repeat(2).take(10)).bytes().count(), 20);\n}\n\n#[allow(dead_code)]\nfn const_utils() {\n    const _: Empty = empty();\n    const _: Repeat = repeat(b'c');\n    const _: Sink = sink();\n}\n"],["2582","use crate::io::prelude::*;\n\n#[bench]\nfn bench_read_slice(b: &mut test::Bencher) {\n    let buf = [5; 1024];\n    let mut dst = [0; 128];\n\n    b.iter(|| {\n        let mut rd = &buf[..];\n        for _ in 0..8 {\n            let _ = rd.read(&mut dst);\n            test::black_box(&dst);\n        }\n    })\n}\n\n#[bench]\nfn bench_write_slice(b: &mut test::Bencher) {\n    let mut buf = [0; 1024];\n    let src = [5; 128];\n\n    b.iter(|| {\n        let mut wr = &mut buf[..];\n        for _ in 0..8 {\n            let _ = wr.write_all(&src);\n            test::black_box(&wr);\n        }\n    })\n}\n\n#[bench]\nfn bench_read_vec(b: &mut test::Bencher) {\n    let buf = vec![5; 1024];\n    let mut dst = [0; 128];\n\n    b.iter(|| {\n        let mut rd = &buf[..];\n        for _ in 0..8 {\n            let _ = rd.read(&mut dst);\n            test::black_box(&dst);\n        }\n    })\n}\n\n#[bench]\nfn bench_write_vec(b: &mut test::Bencher) {\n    let mut buf = Vec::with_capacity(1024);\n    let src = [5; 128];\n\n    b.iter(|| {\n        let mut wr = &mut buf[..];\n        for _ in 0..8 {\n            let _ = wr.write_all(&src);\n            test::black_box(&wr);\n        }\n    })\n}\n"],["2583","//! The I/O Prelude.\n//!\n//! The purpose of this module is to alleviate imports of many common I/O traits\n//! by adding a glob import to the top of I/O heavy modules:\n//!\n//! ```\n//! # #![allow(unused_imports)]\n//! use std::io::prelude::*;\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use super::{BufRead, Read, Seek, Write};\n"],["2584","use crate::io::prelude::*;\nuse crate::io::{Cursor, IoSlice, IoSliceMut, SeekFrom};\n\n#[test]\nfn test_vec_writer() {\n    let mut writer = Vec::new();\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(\n        writer\n            .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n            .unwrap(),\n        3\n    );\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(writer, b);\n}\n\n#[test]\nfn test_mem_writer() {\n    let mut writer = Cursor::new(Vec::new());\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(\n        writer\n            .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n            .unwrap(),\n        3\n    );\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(&writer.get_ref()[..], b);\n}\n\n#[test]\nfn test_mem_mut_writer() {\n    let mut vec = Vec::new();\n    let mut writer = Cursor::new(&mut vec);\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(\n        writer\n            .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n            .unwrap(),\n        3\n    );\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(&writer.get_ref()[..], b);\n}\n\n#[test]\nfn test_box_slice_writer() {\n    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n    assert_eq!(writer.position(), 0);\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.position(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(writer.position(), 8);\n    assert_eq!(writer.write(&[]).unwrap(), 0);\n    assert_eq!(writer.position(), 8);\n\n    assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n    assert_eq!(writer.write(&[10]).unwrap(), 0);\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n    assert_eq!(&**writer.get_ref(), b);\n}\n\n#[test]\nfn test_box_slice_writer_vectored() {\n    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n    assert_eq!(writer.position(), 0);\n    assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n    assert_eq!(writer.position(), 1);\n    assert_eq!(\n        writer.write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7]),]).unwrap(),\n        7,\n    );\n    assert_eq!(writer.position(), 8);\n    assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n    assert_eq!(writer.position(), 8);\n\n    assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n    assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n    assert_eq!(&**writer.get_ref(), b);\n}\n\n#[test]\nfn test_buf_writer() {\n    let mut buf = [0 as u8; 9];\n    {\n        let mut writer = Cursor::new(&mut buf[..]);\n        assert_eq!(writer.position(), 0);\n        assert_eq!(writer.write(&[0]).unwrap(), 1);\n        assert_eq!(writer.position(), 1);\n        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n        assert_eq!(writer.position(), 8);\n        assert_eq!(writer.write(&[]).unwrap(), 0);\n        assert_eq!(writer.position(), 8);\n\n        assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n        assert_eq!(writer.write(&[10]).unwrap(), 0);\n    }\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n    assert_eq!(buf, b);\n}\n\n#[test]\nfn test_buf_writer_vectored() {\n    let mut buf = [0 as u8; 9];\n    {\n        let mut writer = Cursor::new(&mut buf[..]);\n        assert_eq!(writer.position(), 0);\n        assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n        assert_eq!(writer.position(), 1);\n        assert_eq!(\n            writer\n                .write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7])],)\n                .unwrap(),\n            7,\n        );\n        assert_eq!(writer.position(), 8);\n        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n        assert_eq!(writer.position(), 8);\n\n        assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n        assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n    }\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n    assert_eq!(buf, b);\n}\n\n#[test]\nfn test_buf_writer_seek() {\n    let mut buf = [0 as u8; 8];\n    {\n        let mut writer = Cursor::new(&mut buf[..]);\n        assert_eq!(writer.position(), 0);\n        assert_eq!(writer.write(&[1]).unwrap(), 1);\n        assert_eq!(writer.position(), 1);\n\n        assert_eq!(writer.seek(SeekFrom::Start(2)).unwrap(), 2);\n        assert_eq!(writer.position(), 2);\n        assert_eq!(writer.write(&[2]).unwrap(), 1);\n        assert_eq!(writer.position(), 3);\n\n        assert_eq!(writer.seek(SeekFrom::Current(-2)).unwrap(), 1);\n        assert_eq!(writer.position(), 1);\n        assert_eq!(writer.write(&[3]).unwrap(), 1);\n        assert_eq!(writer.position(), 2);\n\n        assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n        assert_eq!(writer.position(), 7);\n        assert_eq!(writer.write(&[4]).unwrap(), 1);\n        assert_eq!(writer.position(), 8);\n    }\n    let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n    assert_eq!(buf, b);\n}\n\n#[test]\nfn test_buf_writer_error() {\n    let mut buf = [0 as u8; 2];\n    let mut writer = Cursor::new(&mut buf[..]);\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.write(&[0, 0]).unwrap(), 1);\n    assert_eq!(writer.write(&[0, 0]).unwrap(), 0);\n}\n\n#[test]\nfn test_mem_reader() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n    let mut buf = [];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf = [0; 4];\n    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n    assert_eq!(reader.position(), 5);\n    let b: &[_] = &[1, 2, 3, 4];\n    assert_eq!(buf, b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n    let b: &[_] = &[5, 6, 7];\n    assert_eq!(&buf[..3], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_mem_reader_vectored() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n    let mut buf = [];\n    assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(\n        reader.read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),]).unwrap(),\n        1,\n    );\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf1 = [0; 4];\n    let mut buf2 = [0; 4];\n    assert_eq!(\n        reader\n            .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2),])\n            .unwrap(),\n        7,\n    );\n    let b1: &[_] = &[1, 2, 3, 4];\n    let b2: &[_] = &[5, 6, 7];\n    assert_eq!(buf1, b1);\n    assert_eq!(&buf2[..3], b2);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_boxed_slice_reader() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n    let mut buf = [];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf = [0; 4];\n    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n    assert_eq!(reader.position(), 5);\n    let b: &[_] = &[1, 2, 3, 4];\n    assert_eq!(buf, b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n    let b: &[_] = &[5, 6, 7];\n    assert_eq!(&buf[..3], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_boxed_slice_reader_vectored() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n    let mut buf = [];\n    assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(\n        reader.read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),]).unwrap(),\n        1,\n    );\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf1 = [0; 4];\n    let mut buf2 = [0; 4];\n    assert_eq!(\n        reader\n            .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],)\n            .unwrap(),\n        7,\n    );\n    let b1: &[_] = &[1, 2, 3, 4];\n    let b2: &[_] = &[5, 6, 7];\n    assert_eq!(buf1, b1);\n    assert_eq!(&buf2[..3], b2);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn read_to_end() {\n    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n    let mut v = Vec::new();\n    reader.read_to_end(&mut v).unwrap();\n    assert_eq!(v, [0, 1, 2, 3, 4, 5, 6, 7]);\n}\n\n#[test]\nfn test_slice_reader() {\n    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n    let reader = &mut &in_buf[..];\n    let mut buf = [];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    let mut buf = [0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.len(), 7);\n    let b: &[_] = &[0];\n    assert_eq!(&buf[..], b);\n    let mut buf = [0; 4];\n    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n    assert_eq!(reader.len(), 3);\n    let b: &[_] = &[1, 2, 3, 4];\n    assert_eq!(&buf[..], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n    let b: &[_] = &[5, 6, 7];\n    assert_eq!(&buf[..3], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_slice_reader_vectored() {\n    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n    let reader = &mut &in_buf[..];\n    let mut buf = [];\n    assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n    let mut buf = [0];\n    assert_eq!(\n        reader.read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),]).unwrap(),\n        1,\n    );\n    assert_eq!(reader.len(), 7);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf1 = [0; 4];\n    let mut buf2 = [0; 4];\n    assert_eq!(\n        reader\n            .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],)\n            .unwrap(),\n        7,\n    );\n    let b1: &[_] = &[1, 2, 3, 4];\n    let b2: &[_] = &[5, 6, 7];\n    assert_eq!(buf1, b1);\n    assert_eq!(&buf2[..3], b2);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn test_read_exact() {\n    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n    let reader = &mut &in_buf[..];\n    let mut buf = [];\n    assert!(reader.read_exact(&mut buf).is_ok());\n    let mut buf = [8];\n    assert!(reader.read_exact(&mut buf).is_ok());\n    assert_eq!(buf[0], 0);\n    assert_eq!(reader.len(), 7);\n    let mut buf = [0, 0, 0, 0, 0, 0, 0];\n    assert!(reader.read_exact(&mut buf).is_ok());\n    assert_eq!(buf, [1, 2, 3, 4, 5, 6, 7]);\n    assert_eq!(reader.len(), 0);\n    let mut buf = [0];\n    assert!(reader.read_exact(&mut buf).is_err());\n}\n\n#[test]\nfn test_buf_reader() {\n    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n    let mut reader = Cursor::new(&in_buf[..]);\n    let mut buf = [];\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n    assert_eq!(reader.position(), 0);\n    let mut buf = [0];\n    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n    assert_eq!(reader.position(), 1);\n    let b: &[_] = &[0];\n    assert_eq!(buf, b);\n    let mut buf = [0; 4];\n    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n    assert_eq!(reader.position(), 5);\n    let b: &[_] = &[1, 2, 3, 4];\n    assert_eq!(buf, b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n    let b: &[_] = &[5, 6, 7];\n    assert_eq!(&buf[..3], b);\n    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n}\n\n#[test]\nfn seek_past_end() {\n    let buf = [0xff];\n    let mut r = Cursor::new(&buf[..]);\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.read(&mut [0]).unwrap(), 0);\n\n    let mut r = Cursor::new(vec![10]);\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.read(&mut [0]).unwrap(), 0);\n\n    let mut buf = [0];\n    let mut r = Cursor::new(&mut buf[..]);\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.write(&[3]).unwrap(), 0);\n\n    let mut r = Cursor::new(vec![10].into_boxed_slice());\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.write(&[3]).unwrap(), 0);\n}\n\n#[test]\nfn seek_past_i64() {\n    let buf = [0xff];\n    let mut r = Cursor::new(&buf[..]);\n    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n\n    let mut r = Cursor::new(vec![10]);\n    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n\n    let mut buf = [0];\n    let mut r = Cursor::new(&mut buf[..]);\n    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n\n    let mut r = Cursor::new(vec![10].into_boxed_slice());\n    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n}\n\n#[test]\nfn seek_before_0() {\n    let buf = [0xff];\n    let mut r = Cursor::new(&buf[..]);\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n\n    let mut r = Cursor::new(vec![10]);\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n\n    let mut buf = [0];\n    let mut r = Cursor::new(&mut buf[..]);\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n\n    let mut r = Cursor::new(vec![10].into_boxed_slice());\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n}\n\n#[test]\nfn test_seekable_mem_writer() {\n    let mut writer = Cursor::new(Vec::<u8>::new());\n    assert_eq!(writer.position(), 0);\n    assert_eq!(writer.write(&[0]).unwrap(), 1);\n    assert_eq!(writer.position(), 1);\n    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n    assert_eq!(writer.position(), 8);\n    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n    assert_eq!(&writer.get_ref()[..], b);\n\n    assert_eq!(writer.seek(SeekFrom::Start(0)).unwrap(), 0);\n    assert_eq!(writer.position(), 0);\n    assert_eq!(writer.write(&[3, 4]).unwrap(), 2);\n    let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n    assert_eq!(&writer.get_ref()[..], b);\n\n    assert_eq!(writer.seek(SeekFrom::Current(1)).unwrap(), 3);\n    assert_eq!(writer.write(&[0, 1]).unwrap(), 2);\n    let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n    assert_eq!(&writer.get_ref()[..], b);\n\n    assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n    assert_eq!(writer.write(&[1, 2]).unwrap(), 2);\n    let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n    assert_eq!(&writer.get_ref()[..], b);\n\n    assert_eq!(writer.seek(SeekFrom::End(1)).unwrap(), 10);\n    assert_eq!(writer.write(&[1]).unwrap(), 1);\n    let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n    assert_eq!(&writer.get_ref()[..], b);\n}\n\n#[test]\nfn vec_seek_past_end() {\n    let mut r = Cursor::new(Vec::new());\n    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n    assert_eq!(r.write(&[3]).unwrap(), 1);\n}\n\n#[test]\nfn vec_seek_before_0() {\n    let mut r = Cursor::new(Vec::new());\n    assert!(r.seek(SeekFrom::End(-2)).is_err());\n}\n\n#[test]\n#[cfg(target_pointer_width = \"32\")]\nfn vec_seek_and_write_past_usize_max() {\n    let mut c = Cursor::new(Vec::new());\n    c.set_position(usize::MAX as u64 + 1);\n    assert!(c.write_all(&[1, 2, 3]).is_err());\n}\n\n#[test]\nfn test_partial_eq() {\n    assert_eq!(Cursor::new(Vec::<u8>::new()), Cursor::new(Vec::<u8>::new()));\n}\n\n#[test]\nfn test_eq() {\n    struct AssertEq<T: Eq>(pub T);\n\n    let _: AssertEq<Cursor<Vec<u8>>> = AssertEq(Cursor::new(Vec::new()));\n}\n\n#[allow(dead_code)]\nfn const_cursor() {\n    const CURSOR: Cursor<&[u8]> = Cursor::new(&[0]);\n    const _: &&[u8] = CURSOR.get_ref();\n    const _: u64 = CURSOR.position();\n}\n"],["2585","use super::{Custom, Error, ErrorKind, Repr};\nuse crate::error;\nuse crate::fmt;\nuse crate::mem::size_of;\nuse crate::sys::decode_error_kind;\nuse crate::sys::os::error_string;\n\n#[test]\nfn test_size() {\n    assert!(size_of::<Error>() <= size_of::<[usize; 2]>());\n}\n\n#[test]\nfn test_debug_error() {\n    let code = 6;\n    let msg = error_string(code);\n    let kind = decode_error_kind(code);\n    let err = Error {\n        repr: Repr::Custom(box Custom {\n            kind: ErrorKind::InvalidInput,\n            error: box Error { repr: super::Repr::Os(code) },\n        }),\n    };\n    let expected = format!(\n        \"Custom {{ \\\n         kind: InvalidInput, \\\n         error: Os {{ \\\n         code: {:?}, \\\n         kind: {:?}, \\\n         message: {:?} \\\n         }} \\\n         }}\",\n        code, kind, msg\n    );\n    assert_eq!(format!(\"{:?}\", err), expected);\n}\n\n#[test]\nfn test_downcasting() {\n    #[derive(Debug)]\n    struct TestError;\n\n    impl fmt::Display for TestError {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.write_str(\"asdf\")\n        }\n    }\n\n    impl error::Error for TestError {}\n\n    // we have to call all of these UFCS style right now since method\n    // resolution won't implicitly drop the Send+Sync bounds\n    let mut err = Error::new(ErrorKind::Other, TestError);\n    assert!(err.get_ref().unwrap().is::<TestError>());\n    assert_eq!(\"asdf\", err.get_ref().unwrap().to_string());\n    assert!(err.get_mut().unwrap().is::<TestError>());\n    let extracted = err.into_inner().unwrap();\n    extracted.downcast::<TestError>().unwrap();\n}\n\n#[test]\nfn test_const() {\n    const E: Error = Error::new_const(ErrorKind::NotFound, &\"hello\");\n\n    assert_eq!(E.kind(), ErrorKind::NotFound);\n    assert_eq!(E.to_string(), \"hello\");\n    assert!(format!(\"{:?}\", E).contains(\"\\\"hello\\\"\"));\n    assert!(format!(\"{:?}\", E).contains(\"NotFound\"));\n}\n"],["2586","#![allow(missing_copy_implementations)]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::fmt;\nuse crate::io::{\n    self, BufRead, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, SizeHint, Write,\n};\n\n/// A reader which is always at EOF.\n///\n/// This struct is generally created by calling [`empty()`]. Please see\n/// the documentation of [`empty()`] for more details.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Empty {\n    _priv: (),\n}\n\n/// Constructs a new handle to an empty reader.\n///\n/// All reads from the returned reader will return [`Ok`]`(0)`.\n///\n/// # Examples\n///\n/// A slightly sad example of not reading anything into a buffer:\n///\n/// ```\n/// use std::io::{self, Read};\n///\n/// let mut buffer = String::new();\n/// io::empty().read_to_string(&mut buffer).unwrap();\n/// assert!(buffer.is_empty());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\npub const fn empty() -> Empty {\n    Empty { _priv: () }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Empty {\n    #[inline]\n    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n        Ok(0)\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl BufRead for Empty {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        Ok(&[])\n    }\n    #[inline]\n    fn consume(&mut self, _n: usize) {}\n}\n\n#[stable(feature = \"empty_seek\", since = \"1.51.0\")]\nimpl Seek for Empty {\n    fn seek(&mut self, _pos: SeekFrom) -> io::Result<u64> {\n        Ok(0)\n    }\n\n    fn stream_len(&mut self) -> io::Result<u64> {\n        Ok(0)\n    }\n\n    fn stream_position(&mut self) -> io::Result<u64> {\n        Ok(0)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Empty {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Empty\").finish_non_exhaustive()\n    }\n}\n\nimpl SizeHint for Empty {\n    fn upper_bound(&self) -> Option<usize> {\n        Some(0)\n    }\n}\n\n/// A reader which yields one byte over and over and over and over and over and...\n///\n/// This struct is generally created by calling [`repeat()`]. Please\n/// see the documentation of [`repeat()`] for more details.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Repeat {\n    byte: u8,\n}\n\n/// Creates an instance of a reader that infinitely repeats one byte.\n///\n/// All reads from this reader will succeed by filling the specified buffer with\n/// the given byte.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{self, Read};\n///\n/// let mut buffer = [0; 3];\n/// io::repeat(0b101).read_exact(&mut buffer).unwrap();\n/// assert_eq!(buffer, [0b101, 0b101, 0b101]);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\npub const fn repeat(byte: u8) -> Repeat {\n    Repeat { byte }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Repeat {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        for slot in &mut *buf {\n            *slot = self.byte;\n        }\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nwritten = 0;\n        for buf in bufs {\n            nwritten += self.read(buf)?;\n        }\n        Ok(nwritten)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        Initializer::nop()\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Repeat {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Repeat\").finish_non_exhaustive()\n    }\n}\n\n/// A writer which will move data into the void.\n///\n/// This struct is generally created by calling [`sink`]. Please\n/// see the documentation of [`sink()`] for more details.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Sink {\n    _priv: (),\n}\n\n/// Creates an instance of a writer which will successfully consume all data.\n///\n/// All calls to [`write`] on the returned instance will return `Ok(buf.len())`\n/// and the contents of the buffer will not be inspected.\n///\n/// [`write`]: Write::write\n///\n/// # Examples\n///\n/// ```rust\n/// use std::io::{self, Write};\n///\n/// let buffer = vec![1, 2, 3, 5, 8];\n/// let num_bytes = io::sink().write(&buffer).unwrap();\n/// assert_eq!(num_bytes, 5);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_const_unstable(feature = \"const_io_structs\", issue = \"78812\")]\npub const fn sink() -> Sink {\n    Sink { _priv: () }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Sink {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let total_len = bufs.iter().map(|b| b.len()).sum();\n        Ok(total_len)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"write_mt\", since = \"1.48.0\")]\nimpl Write for &Sink {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let total_len = bufs.iter().map(|b| b.len()).sum();\n        Ok(total_len)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Sink {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Sink\").finish_non_exhaustive()\n    }\n}\n"],["2587","use super::{BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\nuse crate::mem::MaybeUninit;\n\n/// Copies the entire contents of a reader into a writer.\n///\n/// This function will continuously read data from `reader` and then\n/// write it into `writer` in a streaming fashion until `reader`\n/// returns EOF.\n///\n/// On success, the total number of bytes that were copied from\n/// `reader` to `writer` is returned.\n///\n/// If youre wanting to copy the contents of one file to another and youre\n/// working with filesystem paths, see the [`fs::copy`] function.\n///\n/// [`fs::copy`]: crate::fs::copy\n///\n/// # Errors\n///\n/// This function will return an error immediately if any call to [`read`] or\n/// [`write`] returns an error. All instances of [`ErrorKind::Interrupted`] are\n/// handled by this function and the underlying operation is retried.\n///\n/// [`read`]: Read::read\n/// [`write`]: Write::write\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n///\n/// fn main() -> io::Result<()> {\n///     let mut reader: &[u8] = b\"hello\";\n///     let mut writer: Vec<u8> = vec![];\n///\n///     io::copy(&mut reader, &mut writer)?;\n///\n///     assert_eq!(&b\"hello\"[..], &writer[..]);\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\nwhere\n    R: Read,\n    W: Write,\n{\n    cfg_if::cfg_if! {\n        if #[cfg(any(target_os = \"linux\", target_os = \"android\"))] {\n            crate::sys::kernel_copy::copy_spec(reader, writer)\n        } else {\n            generic_copy(reader, writer)\n        }\n    }\n}\n\n/// The userspace read-write-loop implementation of `io::copy` that is used when\n/// OS-specific specializations for copy offloading are not available or not applicable.\npub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\nwhere\n    R: Read,\n    W: Write,\n{\n    BufferedCopySpec::copy_to(reader, writer)\n}\n\n/// Specialization of the read-write loop that either uses a stack buffer\n/// or reuses the internal buffer of a BufWriter\ntrait BufferedCopySpec: Write {\n    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64>;\n}\n\nimpl<W: Write + ?Sized> BufferedCopySpec for W {\n    default fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n        stack_buffer_copy(reader, writer)\n    }\n}\n\nimpl<I: Write> BufferedCopySpec for BufWriter<I> {\n    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n        if writer.capacity() < DEFAULT_BUF_SIZE {\n            return stack_buffer_copy(reader, writer);\n        }\n\n        // FIXME: #42788\n        //\n        //   - This creates a (mut) reference to a slice of\n        //     _uninitialized_ integers, which is **undefined behavior**\n        //\n        //   - Only the standard library gets to soundly \"ignore\" this,\n        //     based on its privileged knowledge of unstable rustc\n        //     internals;\n        unsafe {\n            let spare_cap = writer.buffer_mut().spare_capacity_mut();\n            reader.initializer().initialize(MaybeUninit::slice_assume_init_mut(spare_cap));\n        }\n\n        let mut len = 0;\n\n        loop {\n            let buf = writer.buffer_mut();\n            let spare_cap = buf.spare_capacity_mut();\n\n            if spare_cap.len() >= DEFAULT_BUF_SIZE {\n                match reader.read(unsafe { MaybeUninit::slice_assume_init_mut(spare_cap) }) {\n                    Ok(0) => return Ok(len), // EOF reached\n                    Ok(bytes_read) => {\n                        assert!(bytes_read <= spare_cap.len());\n                        // SAFETY: The initializer contract guarantees that either it or `read`\n                        // will have initialized these bytes. And we just checked that the number\n                        // of bytes is within the buffer capacity.\n                        unsafe { buf.set_len(buf.len() + bytes_read) };\n                        len += bytes_read as u64;\n                        // Read again if the buffer still has enough capacity, as BufWriter itself would do\n                        // This will occur if the reader returns short reads\n                        continue;\n                    }\n                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                    Err(e) => return Err(e),\n                }\n            }\n\n            writer.flush_buf()?;\n        }\n    }\n}\n\nfn stack_buffer_copy<R: Read + ?Sized, W: Write + ?Sized>(\n    reader: &mut R,\n    writer: &mut W,\n) -> Result<u64> {\n    let mut buf = MaybeUninit::<[u8; DEFAULT_BUF_SIZE]>::uninit();\n    // FIXME: #42788\n    //\n    //   - This creates a (mut) reference to a slice of\n    //     _uninitialized_ integers, which is **undefined behavior**\n    //\n    //   - Only the standard library gets to soundly \"ignore\" this,\n    //     based on its privileged knowledge of unstable rustc\n    //     internals;\n    unsafe {\n        reader.initializer().initialize(buf.assume_init_mut());\n    }\n\n    let mut written = 0;\n    loop {\n        let len = match reader.read(unsafe { buf.assume_init_mut() }) {\n            Ok(0) => return Ok(written),\n            Ok(len) => len,\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n            Err(e) => return Err(e),\n        };\n        writer.write_all(unsafe { &buf.assume_init_ref()[..len] })?;\n        written += len as u64;\n    }\n}\n"],["2588","//! Lazy values and one-time initialization of static data.\n\n#[cfg(test)]\nmod tests;\n\nuse crate::{\n    cell::{Cell, UnsafeCell},\n    fmt,\n    marker::PhantomData,\n    mem::MaybeUninit,\n    ops::{Deref, Drop},\n    panic::{RefUnwindSafe, UnwindSafe},\n    pin::Pin,\n    sync::Once,\n};\n\n#[doc(inline)]\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\npub use core::lazy::*;\n\n/// A synchronization primitive which can be written to only once.\n///\n/// This type is a thread-safe `OnceCell`.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(once_cell)]\n///\n/// use std::lazy::SyncOnceCell;\n///\n/// static CELL: SyncOnceCell<String> = SyncOnceCell::new();\n/// assert!(CELL.get().is_none());\n///\n/// std::thread::spawn(|| {\n///     let value: &String = CELL.get_or_init(|| {\n///         \"Hello, World!\".to_string()\n///     });\n///     assert_eq!(value, \"Hello, World!\");\n/// }).join().unwrap();\n///\n/// let value: Option<&String> = CELL.get();\n/// assert!(value.is_some());\n/// assert_eq!(value.unwrap().as_str(), \"Hello, World!\");\n/// ```\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\npub struct SyncOnceCell<T> {\n    once: Once,\n    // Whether or not the value is initialized is tracked by `state_and_queue`.\n    value: UnsafeCell<MaybeUninit<T>>,\n    /// `PhantomData` to make sure dropck understands we're dropping T in our Drop impl.\n    ///\n    /// ```compile_fail,E0597\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::SyncOnceCell;\n    ///\n    /// struct A<'a>(&'a str);\n    ///\n    /// impl<'a> Drop for A<'a> {\n    ///     fn drop(&mut self) {}\n    /// }\n    ///\n    /// let cell = SyncOnceCell::new();\n    /// {\n    ///     let s = String::new();\n    ///     let _ = cell.set(A(&s));\n    /// }\n    /// ```\n    _marker: PhantomData<T>,\n}\n\n// Why do we need `T: Send`?\n// Thread A creates a `SyncOnceCell` and shares it with\n// scoped thread B, which fills the cell, which is\n// then destroyed by A. That is, destructor observes\n// a sent value.\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nunsafe impl<T: Sync + Send> Sync for SyncOnceCell<T> {}\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nunsafe impl<T: Send> Send for SyncOnceCell<T> {}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for SyncOnceCell<T> {}\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: UnwindSafe> UnwindSafe for SyncOnceCell<T> {}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T> Default for SyncOnceCell<T> {\n    fn default() -> SyncOnceCell<T> {\n        SyncOnceCell::new()\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: fmt::Debug> fmt::Debug for SyncOnceCell<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.get() {\n            Some(v) => f.debug_tuple(\"Once\").field(v).finish(),\n            None => f.write_str(\"Once(Uninit)\"),\n        }\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: Clone> Clone for SyncOnceCell<T> {\n    fn clone(&self) -> SyncOnceCell<T> {\n        let cell = Self::new();\n        if let Some(value) = self.get() {\n            match cell.set(value.clone()) {\n                Ok(()) => (),\n                Err(_) => unreachable!(),\n            }\n        }\n        cell\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T> From<T> for SyncOnceCell<T> {\n    fn from(value: T) -> Self {\n        let cell = Self::new();\n        match cell.set(value) {\n            Ok(()) => cell,\n            Err(_) => unreachable!(),\n        }\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: PartialEq> PartialEq for SyncOnceCell<T> {\n    fn eq(&self, other: &SyncOnceCell<T>) -> bool {\n        self.get() == other.get()\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: Eq> Eq for SyncOnceCell<T> {}\n\nimpl<T> SyncOnceCell<T> {\n    /// Creates a new empty cell.\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub const fn new() -> SyncOnceCell<T> {\n        SyncOnceCell {\n            once: Once::new(),\n            value: UnsafeCell::new(MaybeUninit::uninit()),\n            _marker: PhantomData,\n        }\n    }\n\n    /// Gets the reference to the underlying value.\n    ///\n    /// Returns `None` if the cell is empty, or being initialized. This\n    /// method never blocks.\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn get(&self) -> Option<&T> {\n        if self.is_initialized() {\n            // Safe b/c checked is_initialized\n            Some(unsafe { self.get_unchecked() })\n        } else {\n            None\n        }\n    }\n\n    /// Gets the mutable reference to the underlying value.\n    ///\n    /// Returns `None` if the cell is empty. This method never blocks.\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn get_mut(&mut self) -> Option<&mut T> {\n        if self.is_initialized() {\n            // Safe b/c checked is_initialized and we have a unique access\n            Some(unsafe { self.get_unchecked_mut() })\n        } else {\n            None\n        }\n    }\n\n    /// Sets the contents of this cell to `value`.\n    ///\n    /// May block if another thread is currently attempting to initialize the cell. The cell is\n    /// guaranteed to contain a value when set returns, though not necessarily the one provided.\n    ///\n    /// Returns `Ok(())` if the cell's value was set by this call.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::SyncOnceCell;\n    ///\n    /// static CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n    ///\n    /// fn main() {\n    ///     assert!(CELL.get().is_none());\n    ///\n    ///     std::thread::spawn(|| {\n    ///         assert_eq!(CELL.set(92), Ok(()));\n    ///     }).join().unwrap();\n    ///\n    ///     assert_eq!(CELL.set(62), Err(62));\n    ///     assert_eq!(CELL.get(), Some(&92));\n    /// }\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn set(&self, value: T) -> Result<(), T> {\n        let mut value = Some(value);\n        self.get_or_init(|| value.take().unwrap());\n        match value {\n            None => Ok(()),\n            Some(value) => Err(value),\n        }\n    }\n\n    /// Gets the contents of the cell, initializing it with `f` if the cell\n    /// was empty.\n    ///\n    /// Many threads may call `get_or_init` concurrently with different\n    /// initializing functions, but it is guaranteed that only one function\n    /// will be executed.\n    ///\n    /// # Panics\n    ///\n    /// If `f` panics, the panic is propagated to the caller, and the cell\n    /// remains uninitialized.\n    ///\n    /// It is an error to reentrantly initialize the cell from `f`. The\n    /// exact outcome is unspecified. Current implementation deadlocks, but\n    /// this may be changed to a panic in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::SyncOnceCell;\n    ///\n    /// let cell = SyncOnceCell::new();\n    /// let value = cell.get_or_init(|| 92);\n    /// assert_eq!(value, &92);\n    /// let value = cell.get_or_init(|| unreachable!());\n    /// assert_eq!(value, &92);\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn get_or_init<F>(&self, f: F) -> &T\n    where\n        F: FnOnce() -> T,\n    {\n        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n            Ok(val) => val,\n        }\n    }\n\n    /// Gets the contents of the cell, initializing it with `f` if\n    /// the cell was empty. If the cell was empty and `f` failed, an\n    /// error is returned.\n    ///\n    /// # Panics\n    ///\n    /// If `f` panics, the panic is propagated to the caller, and\n    /// the cell remains uninitialized.\n    ///\n    /// It is an error to reentrantly initialize the cell from `f`.\n    /// The exact outcome is unspecified. Current implementation\n    /// deadlocks, but this may be changed to a panic in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::SyncOnceCell;\n    ///\n    /// let cell = SyncOnceCell::new();\n    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n    /// assert!(cell.get().is_none());\n    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n    ///     Ok(92)\n    /// });\n    /// assert_eq!(value, Ok(&92));\n    /// assert_eq!(cell.get(), Some(&92))\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n    where\n        F: FnOnce() -> Result<T, E>,\n    {\n        // Fast path check\n        // NOTE: We need to perform an acquire on the state in this method\n        // in order to correctly synchronize `SyncLazy::force`. This is\n        // currently done by calling `self.get()`, which in turn calls\n        // `self.is_initialized()`, which in turn performs the acquire.\n        if let Some(value) = self.get() {\n            return Ok(value);\n        }\n        self.initialize(f)?;\n\n        debug_assert!(self.is_initialized());\n\n        // SAFETY: The inner value has been initialized\n        Ok(unsafe { self.get_unchecked() })\n    }\n\n    /// Internal-only API that gets the contents of the cell, initializing it\n    /// in two steps with `f` and `g` if the cell was empty.\n    ///\n    /// `f` is called to construct the value, which is then moved into the cell\n    /// and given as a (pinned) mutable reference to `g` to finish\n    /// initialization.\n    ///\n    /// This allows `g` to inspect an manipulate the value after it has been\n    /// moved into its final place in the cell, but before the cell is\n    /// considered initialized.\n    ///\n    /// # Panics\n    ///\n    /// If `f` or `g` panics, the panic is propagated to the caller, and the\n    /// cell remains uninitialized.\n    ///\n    /// With the current implementation, if `g` panics, the value from `f` will\n    /// not be dropped. This should probably be fixed if this is ever used for\n    /// a type where this matters.\n    ///\n    /// It is an error to reentrantly initialize the cell from `f`. The exact\n    /// outcome is unspecified. Current implementation deadlocks, but this may\n    /// be changed to a panic in the future.\n    pub(crate) fn get_or_init_pin<F, G>(self: Pin<&Self>, f: F, g: G) -> Pin<&T>\n    where\n        F: FnOnce() -> T,\n        G: FnOnce(Pin<&mut T>),\n    {\n        if let Some(value) = self.get_ref().get() {\n            // SAFETY: The inner value was already initialized, and will not be\n            // moved anymore.\n            return unsafe { Pin::new_unchecked(value) };\n        }\n\n        let slot = &self.value;\n\n        // Ignore poisoning from other threads\n        // If another thread panics, then we'll be able to run our closure\n        self.once.call_once_force(|_| {\n            let value = f();\n            // SAFETY: We use the Once (self.once) to guarantee unique access\n            // to the UnsafeCell (slot).\n            let value: &mut T = unsafe { (&mut *slot.get()).write(value) };\n            // SAFETY: The value has been written to its final place in\n            // self.value. We do not to move it anymore, which we promise here\n            // with a Pin<&mut T>.\n            g(unsafe { Pin::new_unchecked(value) });\n        });\n\n        // SAFETY: The inner value has been initialized, and will not be moved\n        // anymore.\n        unsafe { Pin::new_unchecked(self.get_ref().get_unchecked()) }\n    }\n\n    /// Consumes the `SyncOnceCell`, returning the wrapped value. Returns\n    /// `None` if the cell was empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::SyncOnceCell;\n    ///\n    /// let cell: SyncOnceCell<String> = SyncOnceCell::new();\n    /// assert_eq!(cell.into_inner(), None);\n    ///\n    /// let cell = SyncOnceCell::new();\n    /// cell.set(\"hello\".to_string()).unwrap();\n    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn into_inner(mut self) -> Option<T> {\n        self.take()\n    }\n\n    /// Takes the value out of this `SyncOnceCell`, moving it back to an uninitialized state.\n    ///\n    /// Has no effect and returns `None` if the `SyncOnceCell` hasn't been initialized.\n    ///\n    /// Safety is guaranteed by requiring a mutable reference.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::SyncOnceCell;\n    ///\n    /// let mut cell: SyncOnceCell<String> = SyncOnceCell::new();\n    /// assert_eq!(cell.take(), None);\n    ///\n    /// let mut cell = SyncOnceCell::new();\n    /// cell.set(\"hello\".to_string()).unwrap();\n    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n    /// assert_eq!(cell.get(), None);\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn take(&mut self) -> Option<T> {\n        if self.is_initialized() {\n            self.once = Once::new();\n            // SAFETY: `self.value` is initialized and contains a valid `T`.\n            // `self.once` is reset, so `is_initialized()` will be false again\n            // which prevents the value from being read twice.\n            unsafe { Some((&mut *self.value.get()).assume_init_read()) }\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn is_initialized(&self) -> bool {\n        self.once.is_completed()\n    }\n\n    #[cold]\n    fn initialize<F, E>(&self, f: F) -> Result<(), E>\n    where\n        F: FnOnce() -> Result<T, E>,\n    {\n        let mut res: Result<(), E> = Ok(());\n        let slot = &self.value;\n\n        // Ignore poisoning from other threads\n        // If another thread panics, then we'll be able to run our closure\n        self.once.call_once_force(|p| {\n            match f() {\n                Ok(value) => {\n                    unsafe { (&mut *slot.get()).write(value) };\n                }\n                Err(e) => {\n                    res = Err(e);\n\n                    // Treat the underlying `Once` as poisoned since we\n                    // failed to initialize our value. Calls\n                    p.poison();\n                }\n            }\n        });\n        res\n    }\n\n    /// # Safety\n    ///\n    /// The value must be initialized\n    unsafe fn get_unchecked(&self) -> &T {\n        debug_assert!(self.is_initialized());\n        (&*self.value.get()).assume_init_ref()\n    }\n\n    /// # Safety\n    ///\n    /// The value must be initialized\n    unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n        debug_assert!(self.is_initialized());\n        (&mut *self.value.get()).assume_init_mut()\n    }\n}\n\nunsafe impl<#[may_dangle] T> Drop for SyncOnceCell<T> {\n    fn drop(&mut self) {\n        if self.is_initialized() {\n            // SAFETY: The cell is initialized and being dropped, so it can't\n            // be accessed again. We also don't touch the `T` other than\n            // dropping it, which validates our usage of #[may_dangle].\n            unsafe { (&mut *self.value.get()).assume_init_drop() };\n        }\n    }\n}\n\n/// A value which is initialized on the first access.\n///\n/// This type is a thread-safe `Lazy`, and can be used in statics.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(once_cell)]\n///\n/// use std::collections::HashMap;\n///\n/// use std::lazy::SyncLazy;\n///\n/// static HASHMAP: SyncLazy<HashMap<i32, String>> = SyncLazy::new(|| {\n///     println!(\"initializing\");\n///     let mut m = HashMap::new();\n///     m.insert(13, \"Spica\".to_string());\n///     m.insert(74, \"Hoyten\".to_string());\n///     m\n/// });\n///\n/// fn main() {\n///     println!(\"ready\");\n///     std::thread::spawn(|| {\n///         println!(\"{:?}\", HASHMAP.get(&13));\n///     }).join().unwrap();\n///     println!(\"{:?}\", HASHMAP.get(&74));\n///\n///     // Prints:\n///     //   ready\n///     //   initializing\n///     //   Some(\"Spica\")\n///     //   Some(\"Hoyten\")\n/// }\n/// ```\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\npub struct SyncLazy<T, F = fn() -> T> {\n    cell: SyncOnceCell<T>,\n    init: Cell<Option<F>>,\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: fmt::Debug, F> fmt::Debug for SyncLazy<T, F> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).finish_non_exhaustive()\n    }\n}\n\n// We never create a `&F` from a `&SyncLazy<T, F>` so it is fine\n// to not impl `Sync` for `F`\n// we do create a `&mut Option<F>` in `force`, but this is\n// properly synchronized, so it only happens once\n// so it also does not contribute to this impl.\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nunsafe impl<T, F: Send> Sync for SyncLazy<T, F> where SyncOnceCell<T>: Sync {}\n// auto-derived `Send` impl is OK.\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T, F: UnwindSafe> RefUnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: RefUnwindSafe {}\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T, F: UnwindSafe> UnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: UnwindSafe {}\n\nimpl<T, F> SyncLazy<T, F> {\n    /// Creates a new lazy value with the given initializing\n    /// function.\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub const fn new(f: F) -> SyncLazy<T, F> {\n        SyncLazy { cell: SyncOnceCell::new(), init: Cell::new(Some(f)) }\n    }\n}\n\nimpl<T, F: FnOnce() -> T> SyncLazy<T, F> {\n    /// Forces the evaluation of this lazy value and\n    /// returns a reference to result. This is equivalent\n    /// to the `Deref` impl, but is explicit.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_cell)]\n    ///\n    /// use std::lazy::SyncLazy;\n    ///\n    /// let lazy = SyncLazy::new(|| 92);\n    ///\n    /// assert_eq!(SyncLazy::force(&lazy), &92);\n    /// assert_eq!(&*lazy, &92);\n    /// ```\n    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n    pub fn force(this: &SyncLazy<T, F>) -> &T {\n        this.cell.get_or_init(|| match this.init.take() {\n            Some(f) => f(),\n            None => panic!(\"Lazy instance has previously been poisoned\"),\n        })\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T, F: FnOnce() -> T> Deref for SyncLazy<T, F> {\n    type Target = T;\n    fn deref(&self) -> &T {\n        SyncLazy::force(self)\n    }\n}\n\n#[unstable(feature = \"once_cell\", issue = \"74465\")]\nimpl<T: Default> Default for SyncLazy<T> {\n    /// Creates a new lazy value using `Default` as the initializing function.\n    fn default() -> SyncLazy<T> {\n        SyncLazy::new(T::default)\n    }\n}\n"],["2589","use super::*;\n\nuse crate::rc::Rc;\nuse crate::sync::Arc;\n\nmacro_rules! t(\n    ($path:expr, iter: $iter:expr) => (\n        {\n            let path = Path::new($path);\n\n            // Forward iteration\n            let comps = path.iter()\n                .map(|p| p.to_string_lossy().into_owned())\n                .collect::<Vec<String>>();\n            let exp: &[&str] = &$iter;\n            let exps = exp.iter().map(|s| s.to_string()).collect::<Vec<String>>();\n            assert!(comps == exps, \"iter: Expected {:?}, found {:?}\",\n                    exps, comps);\n\n            // Reverse iteration\n            let comps = Path::new($path).iter().rev()\n                .map(|p| p.to_string_lossy().into_owned())\n                .collect::<Vec<String>>();\n            let exps = exps.into_iter().rev().collect::<Vec<String>>();\n            assert!(comps == exps, \"iter().rev(): Expected {:?}, found {:?}\",\n                    exps, comps);\n        }\n    );\n\n    ($path:expr, has_root: $has_root:expr, is_absolute: $is_absolute:expr) => (\n        {\n            let path = Path::new($path);\n\n            let act_root = path.has_root();\n            assert!(act_root == $has_root, \"has_root: Expected {:?}, found {:?}\",\n                    $has_root, act_root);\n\n            let act_abs = path.is_absolute();\n            assert!(act_abs == $is_absolute, \"is_absolute: Expected {:?}, found {:?}\",\n                    $is_absolute, act_abs);\n        }\n    );\n\n    ($path:expr, parent: $parent:expr, file_name: $file:expr) => (\n        {\n            let path = Path::new($path);\n\n            let parent = path.parent().map(|p| p.to_str().unwrap());\n            let exp_parent: Option<&str> = $parent;\n            assert!(parent == exp_parent, \"parent: Expected {:?}, found {:?}\",\n                    exp_parent, parent);\n\n            let file = path.file_name().map(|p| p.to_str().unwrap());\n            let exp_file: Option<&str> = $file;\n            assert!(file == exp_file, \"file_name: Expected {:?}, found {:?}\",\n                    exp_file, file);\n        }\n    );\n\n    ($path:expr, file_stem: $file_stem:expr, extension: $extension:expr) => (\n        {\n            let path = Path::new($path);\n\n            let stem = path.file_stem().map(|p| p.to_str().unwrap());\n            let exp_stem: Option<&str> = $file_stem;\n            assert!(stem == exp_stem, \"file_stem: Expected {:?}, found {:?}\",\n                    exp_stem, stem);\n\n            let ext = path.extension().map(|p| p.to_str().unwrap());\n            let exp_ext: Option<&str> = $extension;\n            assert!(ext == exp_ext, \"extension: Expected {:?}, found {:?}\",\n                    exp_ext, ext);\n        }\n    );\n\n    ($path:expr, iter: $iter:expr,\n                 has_root: $has_root:expr, is_absolute: $is_absolute:expr,\n                 parent: $parent:expr, file_name: $file:expr,\n                 file_stem: $file_stem:expr, extension: $extension:expr) => (\n        {\n            t!($path, iter: $iter);\n            t!($path, has_root: $has_root, is_absolute: $is_absolute);\n            t!($path, parent: $parent, file_name: $file);\n            t!($path, file_stem: $file_stem, extension: $extension);\n        }\n    );\n);\n\n#[test]\nfn into() {\n    use crate::borrow::Cow;\n\n    let static_path = Path::new(\"/home/foo\");\n    let static_cow_path: Cow<'static, Path> = static_path.into();\n    let pathbuf = PathBuf::from(\"/home/foo\");\n\n    {\n        let path: &Path = &pathbuf;\n        let borrowed_cow_path: Cow<'_, Path> = path.into();\n\n        assert_eq!(static_cow_path, borrowed_cow_path);\n    }\n\n    let owned_cow_path: Cow<'static, Path> = pathbuf.into();\n\n    assert_eq!(static_cow_path, owned_cow_path);\n}\n\n#[test]\n#[cfg(unix)]\npub fn test_decompositions_unix() {\n    t!(\"\",\n    iter: [],\n    has_root: false,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"/\",\n    iter: [\"/\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"/foo\",\n    iter: [\"/\", \"foo\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"/foo/\",\n    iter: [\"/\", \"foo\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/bar\",\n    iter: [\"foo\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"/foo/bar\",\n    iter: [\"/\", \"foo\", \"bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"///foo///\",\n    iter: [\"/\", \"foo\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"///foo///bar\",\n    iter: [\"/\", \"foo\", \"bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"///foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"./.\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"/..\",\n    iter: [\"/\", \"..\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"/\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"../\",\n    iter: [\"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/.\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/..\",\n    iter: [\"foo\", \"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/./\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/./bar\",\n    iter: [\"foo\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"foo/../\",\n    iter: [\"foo\", \"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/../bar\",\n    iter: [\"foo\", \"..\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo/..\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"./a\",\n    iter: [\".\", \"a\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\".\"),\n    file_name: Some(\"a\"),\n    file_stem: Some(\"a\"),\n    extension: None\n    );\n\n    t!(\".\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"./\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"a/b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a//b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a/./b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a/b/c\",\n    iter: [\"a\", \"b\", \"c\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a/b\"),\n    file_name: Some(\"c\"),\n    file_stem: Some(\"c\"),\n    extension: None\n    );\n\n    t!(\".foo\",\n    iter: [\".foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\".foo\"),\n    file_stem: Some(\".foo\"),\n    extension: None\n    );\n}\n\n#[test]\n#[cfg(windows)]\npub fn test_decompositions_windows() {\n    t!(\"\",\n    iter: [],\n    has_root: false,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"/\",\n    iter: [\"\\\\\"],\n    has_root: true,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\",\n    iter: [\"\\\\\"],\n    has_root: true,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"c:\",\n    iter: [\"c:\"],\n    has_root: false,\n    is_absolute: false,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"c:\\\\\",\n    iter: [\"c:\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"c:/\",\n    iter: [\"c:\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"/foo\",\n    iter: [\"\\\\\", \"foo\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"/foo/\",\n    iter: [\"\\\\\", \"foo\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/bar\",\n    iter: [\"foo\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"/foo/bar\",\n    iter: [\"\\\\\", \"foo\", \"bar\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"///foo///\",\n    iter: [\"\\\\\", \"foo\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"///foo///bar\",\n    iter: [\"\\\\\", \"foo\", \"bar\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"///foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"./.\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"/..\",\n    iter: [\"\\\\\", \"..\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"/\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"../\",\n    iter: [\"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/.\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/..\",\n    iter: [\"foo\", \"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/./\",\n    iter: [\"foo\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: Some(\"foo\"),\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo/./bar\",\n    iter: [\"foo\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"foo/../\",\n    iter: [\"foo\", \"..\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"foo/../bar\",\n    iter: [\"foo\", \"..\", \"bar\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"foo/..\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"./a\",\n    iter: [\".\", \"a\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\".\"),\n    file_name: Some(\"a\"),\n    file_stem: Some(\"a\"),\n    extension: None\n    );\n\n    t!(\".\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"./\",\n    iter: [\".\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"\"),\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"a/b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a//b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a/./b\",\n    iter: [\"a\", \"b\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n\n    t!(\"a/b/c\",\n       iter: [\"a\", \"b\", \"c\"],\n       has_root: false,\n       is_absolute: false,\n       parent: Some(\"a/b\"),\n       file_name: Some(\"c\"),\n       file_stem: Some(\"c\"),\n       extension: None);\n\n    t!(\"a\\\\b\\\\c\",\n    iter: [\"a\", \"b\", \"c\"],\n    has_root: false,\n    is_absolute: false,\n    parent: Some(\"a\\\\b\"),\n    file_name: Some(\"c\"),\n    file_stem: Some(\"c\"),\n    extension: None\n    );\n\n    t!(\"\\\\a\",\n    iter: [\"\\\\\", \"a\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"\\\\\"),\n    file_name: Some(\"a\"),\n    file_stem: Some(\"a\"),\n    extension: None\n    );\n\n    t!(\"c:\\\\foo.txt\",\n    iter: [\"c:\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"c:\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\server\\\\share\\\\foo.txt\",\n    iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\server\\\\share\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\server\\\\share\",\n    iter: [\"\\\\\\\\server\\\\share\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\server\",\n    iter: [\"\\\\\", \"server\"],\n    has_root: true,\n    is_absolute: false,\n    parent: Some(\"\\\\\"),\n    file_name: Some(\"server\"),\n    file_stem: Some(\"server\"),\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\bar\\\\foo.txt\",\n    iter: [\"\\\\\\\\?\\\\bar\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\?\\\\bar\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\?\\\\bar\",\n    iter: [\"\\\\\\\\?\\\\bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\\",\n    iter: [\"\\\\\\\\?\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\",\n    iter: [\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\?\\\\UNC\\\\server\",\n    iter: [\"\\\\\\\\?\\\\UNC\\\\server\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\UNC\\\\\",\n    iter: [\"\\\\\\\\?\\\\UNC\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\C:\\\\foo.txt\",\n    iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"foo.txt\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\?\\\\C:\\\\\"),\n    file_name: Some(\"foo.txt\"),\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"\\\\\\\\?\\\\C:\\\\\",\n    iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\C:\",\n    iter: [\"\\\\\\\\?\\\\C:\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\foo/bar\",\n    iter: [\"\\\\\\\\?\\\\foo/bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\C:/foo\",\n    iter: [\"\\\\\\\\?\\\\C:/foo\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\foo\\\\bar\",\n    iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\.\\\\foo\\\\\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\foo\",\n    iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\foo/bar\",\n    iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\.\\\\foo/\"),\n    file_name: Some(\"bar\"),\n    file_stem: Some(\"bar\"),\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\foo\\\\bar/baz\",\n    iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\", \"baz\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\.\\\\foo\\\\bar\"),\n    file_name: Some(\"baz\"),\n    file_stem: Some(\"baz\"),\n    extension: None\n    );\n\n    t!(\"\\\\\\\\.\\\\\",\n    iter: [\"\\\\\\\\.\\\\\", \"\\\\\"],\n    has_root: true,\n    is_absolute: true,\n    parent: None,\n    file_name: None,\n    file_stem: None,\n    extension: None\n    );\n\n    t!(\"\\\\\\\\?\\\\a\\\\b\\\\\",\n    iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\"],\n    has_root: true,\n    is_absolute: true,\n    parent: Some(\"\\\\\\\\?\\\\a\\\\\"),\n    file_name: Some(\"b\"),\n    file_stem: Some(\"b\"),\n    extension: None\n    );\n}\n\n#[test]\npub fn test_stem_ext() {\n    t!(\"foo\",\n    file_stem: Some(\"foo\"),\n    extension: None\n    );\n\n    t!(\"foo.\",\n    file_stem: Some(\"foo\"),\n    extension: Some(\"\")\n    );\n\n    t!(\".foo\",\n    file_stem: Some(\".foo\"),\n    extension: None\n    );\n\n    t!(\"foo.txt\",\n    file_stem: Some(\"foo\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"foo.bar.txt\",\n    file_stem: Some(\"foo.bar\"),\n    extension: Some(\"txt\")\n    );\n\n    t!(\"foo.bar.\",\n    file_stem: Some(\"foo.bar\"),\n    extension: Some(\"\")\n    );\n\n    t!(\".\", file_stem: None, extension: None);\n\n    t!(\"..\", file_stem: None, extension: None);\n\n    t!(\"\", file_stem: None, extension: None);\n}\n\n#[test]\npub fn test_push() {\n    macro_rules! tp(\n        ($path:expr, $push:expr, $expected:expr) => ( {\n            let mut actual = PathBuf::from($path);\n            actual.push($push);\n            assert!(actual.to_str() == Some($expected),\n                    \"pushing {:?} onto {:?}: Expected {:?}, got {:?}\",\n                    $push, $path, $expected, actual.to_str().unwrap());\n        });\n    );\n\n    if cfg!(unix) || cfg!(all(target_env = \"sgx\", target_vendor = \"fortanix\")) {\n        tp!(\"\", \"foo\", \"foo\");\n        tp!(\"foo\", \"bar\", \"foo/bar\");\n        tp!(\"foo/\", \"bar\", \"foo/bar\");\n        tp!(\"foo//\", \"bar\", \"foo//bar\");\n        tp!(\"foo/.\", \"bar\", \"foo/./bar\");\n        tp!(\"foo./.\", \"bar\", \"foo././bar\");\n        tp!(\"foo\", \"\", \"foo/\");\n        tp!(\"foo\", \".\", \"foo/.\");\n        tp!(\"foo\", \"..\", \"foo/..\");\n        tp!(\"foo\", \"/\", \"/\");\n        tp!(\"/foo/bar\", \"/\", \"/\");\n        tp!(\"/foo/bar\", \"/baz\", \"/baz\");\n        tp!(\"/foo/bar\", \"./baz\", \"/foo/bar/./baz\");\n    } else {\n        tp!(\"\", \"foo\", \"foo\");\n        tp!(\"foo\", \"bar\", r\"foo\\bar\");\n        tp!(\"foo/\", \"bar\", r\"foo/bar\");\n        tp!(r\"foo\\\", \"bar\", r\"foo\\bar\");\n        tp!(\"foo//\", \"bar\", r\"foo//bar\");\n        tp!(r\"foo\\\\\", \"bar\", r\"foo\\\\bar\");\n        tp!(\"foo/.\", \"bar\", r\"foo/.\\bar\");\n        tp!(\"foo./.\", \"bar\", r\"foo./.\\bar\");\n        tp!(r\"foo\\.\", \"bar\", r\"foo\\.\\bar\");\n        tp!(r\"foo.\\.\", \"bar\", r\"foo.\\.\\bar\");\n        tp!(\"foo\", \"\", \"foo\\\\\");\n        tp!(\"foo\", \".\", r\"foo\\.\");\n        tp!(\"foo\", \"..\", r\"foo\\..\");\n        tp!(\"foo\", \"/\", \"/\");\n        tp!(\"foo\", r\"\\\", r\"\\\");\n        tp!(\"/foo/bar\", \"/\", \"/\");\n        tp!(r\"\\foo\\bar\", r\"\\\", r\"\\\");\n        tp!(\"/foo/bar\", \"/baz\", \"/baz\");\n        tp!(\"/foo/bar\", r\"\\baz\", r\"\\baz\");\n        tp!(\"/foo/bar\", \"./baz\", r\"/foo/bar\\./baz\");\n        tp!(\"/foo/bar\", r\".\\baz\", r\"/foo/bar\\.\\baz\");\n\n        tp!(\"c:\\\\\", \"windows\", \"c:\\\\windows\");\n        tp!(\"c:\", \"windows\", \"c:windows\");\n\n        tp!(\"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n        tp!(\"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n        tp!(\"a\\\\b\", \"c\\\\d\", \"a\\\\b\\\\c\\\\d\");\n        tp!(\"a\\\\b\", \"\\\\c\\\\d\", \"\\\\c\\\\d\");\n        tp!(\"a\\\\b\", \".\", \"a\\\\b\\\\.\");\n        tp!(\"a\\\\b\", \"..\\\\c\", \"a\\\\b\\\\..\\\\c\");\n        tp!(\"a\\\\b\", \"C:a.txt\", \"C:a.txt\");\n        tp!(\"a\\\\b\", \"C:\\\\a.txt\", \"C:\\\\a.txt\");\n        tp!(\"C:\\\\a\", \"C:\\\\b.txt\", \"C:\\\\b.txt\");\n        tp!(\"C:\\\\a\\\\b\\\\c\", \"C:d\", \"C:d\");\n        tp!(\"C:a\\\\b\\\\c\", \"C:d\", \"C:d\");\n        tp!(\"C:\", r\"a\\b\\c\", r\"C:a\\b\\c\");\n        tp!(\"C:\", r\"..\\a\", r\"C:..\\a\");\n        tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n        tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"C:baz\", \"C:baz\");\n        tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n        tp!(\"\\\\\\\\?\\\\C:a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n        tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", \"C:\\\\c\\\\d\");\n        tp!(\"\\\\\\\\?\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\");\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:\\\\a\", \"C:\\\\a\");\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:a\", \"C:a\");\n\n        // Note: modified from old path API\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\", \"foo\", \"\\\\\\\\?\\\\UNC\\\\server\\\\foo\");\n\n        tp!(\"C:\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n        tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\");\n        tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"C:a\", \"C:a\");\n        // again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim\n        tp!(\"\\\\\\\\.\\\\foo\", \"..\\\\bar\", \"\\\\\\\\.\\\\foo\\\\..\\\\bar\");\n\n        tp!(\"\\\\\\\\?\\\\C:\", \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\"); // this is a weird one\n    }\n}\n\n#[test]\npub fn test_pop() {\n    macro_rules! tp(\n        ($path:expr, $expected:expr, $output:expr) => ( {\n            let mut actual = PathBuf::from($path);\n            let output = actual.pop();\n            assert!(actual.to_str() == Some($expected) && output == $output,\n                    \"popping from {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n                    $path, $expected, $output,\n                    actual.to_str().unwrap(), output);\n        });\n    );\n\n    tp!(\"\", \"\", false);\n    tp!(\"/\", \"/\", false);\n    tp!(\"foo\", \"\", true);\n    tp!(\".\", \"\", true);\n    tp!(\"/foo\", \"/\", true);\n    tp!(\"/foo/bar\", \"/foo\", true);\n    tp!(\"foo/bar\", \"foo\", true);\n    tp!(\"foo/.\", \"\", true);\n    tp!(\"foo//bar\", \"foo\", true);\n\n    if cfg!(windows) {\n        tp!(\"a\\\\b\\\\c\", \"a\\\\b\", true);\n        tp!(\"\\\\a\", \"\\\\\", true);\n        tp!(\"\\\\\", \"\\\\\", false);\n\n        tp!(\"C:\\\\a\\\\b\", \"C:\\\\a\", true);\n        tp!(\"C:\\\\a\", \"C:\\\\\", true);\n        tp!(\"C:\\\\\", \"C:\\\\\", false);\n        tp!(\"C:a\\\\b\", \"C:a\", true);\n        tp!(\"C:a\", \"C:\", true);\n        tp!(\"C:\", \"C:\", false);\n        tp!(\"\\\\\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\server\\\\share\\\\a\", true);\n        tp!(\"\\\\\\\\server\\\\share\\\\a\", \"\\\\\\\\server\\\\share\\\\\", true);\n        tp!(\"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\", false);\n        tp!(\"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", true);\n        tp!(\"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\\", true);\n        tp!(\"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\a\", false);\n        tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", true);\n        tp!(\"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", true);\n        tp!(\"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", false);\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", true);\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\", true);\n        tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", false);\n        tp!(\"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", true);\n        tp!(\"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\\\\\", true);\n        tp!(\"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n\n        tp!(\"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\\\\\", true);\n    }\n}\n\n#[test]\npub fn test_set_file_name() {\n    macro_rules! tfn(\n            ($path:expr, $file:expr, $expected:expr) => ( {\n            let mut p = PathBuf::from($path);\n            p.set_file_name($file);\n            assert!(p.to_str() == Some($expected),\n                    \"setting file name of {:?} to {:?}: Expected {:?}, got {:?}\",\n                    $path, $file, $expected,\n                    p.to_str().unwrap());\n        });\n    );\n\n    tfn!(\"foo\", \"foo\", \"foo\");\n    tfn!(\"foo\", \"bar\", \"bar\");\n    tfn!(\"foo\", \"\", \"\");\n    tfn!(\"\", \"foo\", \"foo\");\n    if cfg!(unix) || cfg!(all(target_env = \"sgx\", target_vendor = \"fortanix\")) {\n        tfn!(\".\", \"foo\", \"./foo\");\n        tfn!(\"foo/\", \"bar\", \"bar\");\n        tfn!(\"foo/.\", \"bar\", \"bar\");\n        tfn!(\"..\", \"foo\", \"../foo\");\n        tfn!(\"foo/..\", \"bar\", \"foo/../bar\");\n        tfn!(\"/\", \"foo\", \"/foo\");\n    } else {\n        tfn!(\".\", \"foo\", r\".\\foo\");\n        tfn!(r\"foo\\\", \"bar\", r\"bar\");\n        tfn!(r\"foo\\.\", \"bar\", r\"bar\");\n        tfn!(\"..\", \"foo\", r\"..\\foo\");\n        tfn!(r\"foo\\..\", \"bar\", r\"foo\\..\\bar\");\n        tfn!(r\"\\\", \"foo\", r\"\\foo\");\n    }\n}\n\n#[test]\npub fn test_set_extension() {\n    macro_rules! tfe(\n            ($path:expr, $ext:expr, $expected:expr, $output:expr) => ( {\n            let mut p = PathBuf::from($path);\n            let output = p.set_extension($ext);\n            assert!(p.to_str() == Some($expected) && output == $output,\n                    \"setting extension of {:?} to {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n                    $path, $ext, $expected, $output,\n                    p.to_str().unwrap(), output);\n        });\n    );\n\n    tfe!(\"foo\", \"txt\", \"foo.txt\", true);\n    tfe!(\"foo.bar\", \"txt\", \"foo.txt\", true);\n    tfe!(\"foo.bar.baz\", \"txt\", \"foo.bar.txt\", true);\n    tfe!(\".test\", \"txt\", \".test.txt\", true);\n    tfe!(\"foo.txt\", \"\", \"foo\", true);\n    tfe!(\"foo\", \"\", \"foo\", true);\n    tfe!(\"\", \"foo\", \"\", false);\n    tfe!(\".\", \"foo\", \".\", false);\n    tfe!(\"foo/\", \"bar\", \"foo.bar\", true);\n    tfe!(\"foo/.\", \"bar\", \"foo.bar\", true);\n    tfe!(\"..\", \"foo\", \"..\", false);\n    tfe!(\"foo/..\", \"bar\", \"foo/..\", false);\n    tfe!(\"/\", \"foo\", \"/\", false);\n}\n\n#[test]\nfn test_eq_receivers() {\n    use crate::borrow::Cow;\n\n    let borrowed: &Path = Path::new(\"foo/bar\");\n    let mut owned: PathBuf = PathBuf::new();\n    owned.push(\"foo\");\n    owned.push(\"bar\");\n    let borrowed_cow: Cow<'_, Path> = borrowed.into();\n    let owned_cow: Cow<'_, Path> = owned.clone().into();\n\n    macro_rules! t {\n        ($($current:expr),+) => {\n            $(\n                assert_eq!($current, borrowed);\n                assert_eq!($current, owned);\n                assert_eq!($current, borrowed_cow);\n                assert_eq!($current, owned_cow);\n            )+\n        }\n    }\n\n    t!(borrowed, owned, borrowed_cow, owned_cow);\n}\n\n#[test]\npub fn test_compare() {\n    use crate::collections::hash_map::DefaultHasher;\n    use crate::hash::{Hash, Hasher};\n\n    fn hash<T: Hash>(t: T) -> u64 {\n        let mut s = DefaultHasher::new();\n        t.hash(&mut s);\n        s.finish()\n    }\n\n    macro_rules! tc(\n        ($path1:expr, $path2:expr, eq: $eq:expr,\n         starts_with: $starts_with:expr, ends_with: $ends_with:expr,\n         relative_from: $relative_from:expr) => ({\n             let path1 = Path::new($path1);\n             let path2 = Path::new($path2);\n\n             let eq = path1 == path2;\n             assert!(eq == $eq, \"{:?} == {:?}, expected {:?}, got {:?}\",\n                     $path1, $path2, $eq, eq);\n             assert!($eq == (hash(path1) == hash(path2)),\n                     \"{:?} == {:?}, expected {:?}, got {} and {}\",\n                     $path1, $path2, $eq, hash(path1), hash(path2));\n\n             let starts_with = path1.starts_with(path2);\n             assert!(starts_with == $starts_with,\n                     \"{:?}.starts_with({:?}), expected {:?}, got {:?}\", $path1, $path2,\n                     $starts_with, starts_with);\n\n             let ends_with = path1.ends_with(path2);\n             assert!(ends_with == $ends_with,\n                     \"{:?}.ends_with({:?}), expected {:?}, got {:?}\", $path1, $path2,\n                     $ends_with, ends_with);\n\n             let relative_from = path1.strip_prefix(path2)\n                                      .map(|p| p.to_str().unwrap())\n                                      .ok();\n             let exp: Option<&str> = $relative_from;\n             assert!(relative_from == exp,\n                     \"{:?}.strip_prefix({:?}), expected {:?}, got {:?}\",\n                     $path1, $path2, exp, relative_from);\n        });\n    );\n\n    tc!(\"\", \"\",\n    eq: true,\n    starts_with: true,\n    ends_with: true,\n    relative_from: Some(\"\")\n    );\n\n    tc!(\"foo\", \"\",\n    eq: false,\n    starts_with: true,\n    ends_with: true,\n    relative_from: Some(\"foo\")\n    );\n\n    tc!(\"\", \"foo\",\n    eq: false,\n    starts_with: false,\n    ends_with: false,\n    relative_from: None\n    );\n\n    tc!(\"foo\", \"foo\",\n    eq: true,\n    starts_with: true,\n    ends_with: true,\n    relative_from: Some(\"\")\n    );\n\n    tc!(\"foo/\", \"foo\",\n    eq: true,\n    starts_with: true,\n    ends_with: true,\n    relative_from: Some(\"\")\n    );\n\n    tc!(\"foo/bar\", \"foo\",\n    eq: false,\n    starts_with: true,\n    ends_with: false,\n    relative_from: Some(\"bar\")\n    );\n\n    tc!(\"foo/bar/baz\", \"foo/bar\",\n    eq: false,\n    starts_with: true,\n    ends_with: false,\n    relative_from: Some(\"baz\")\n    );\n\n    tc!(\"foo/bar\", \"foo/bar/baz\",\n    eq: false,\n    starts_with: false,\n    ends_with: false,\n    relative_from: None\n    );\n\n    tc!(\"./foo/bar/\", \".\",\n    eq: false,\n    starts_with: true,\n    ends_with: false,\n    relative_from: Some(\"foo/bar\")\n    );\n\n    if cfg!(windows) {\n        tc!(r\"C:\\src\\rust\\cargo-test\\test\\Cargo.toml\",\n        r\"c:\\src\\rust\\cargo-test\\test\",\n        eq: false,\n        starts_with: true,\n        ends_with: false,\n        relative_from: Some(\"Cargo.toml\")\n        );\n\n        tc!(r\"c:\\foo\", r\"C:\\foo\",\n        eq: true,\n        starts_with: true,\n        ends_with: true,\n        relative_from: Some(\"\")\n        );\n    }\n}\n\n#[test]\nfn test_components_debug() {\n    let path = Path::new(\"/tmp\");\n\n    let mut components = path.components();\n\n    let expected = \"Components([RootDir, Normal(\\\"tmp\\\")])\";\n    let actual = format!(\"{:?}\", components);\n    assert_eq!(expected, actual);\n\n    let _ = components.next().unwrap();\n    let expected = \"Components([Normal(\\\"tmp\\\")])\";\n    let actual = format!(\"{:?}\", components);\n    assert_eq!(expected, actual);\n\n    let _ = components.next().unwrap();\n    let expected = \"Components([])\";\n    let actual = format!(\"{:?}\", components);\n    assert_eq!(expected, actual);\n}\n\n#[cfg(unix)]\n#[test]\nfn test_iter_debug() {\n    let path = Path::new(\"/tmp\");\n\n    let mut iter = path.iter();\n\n    let expected = \"Iter([\\\"/\\\", \\\"tmp\\\"])\";\n    let actual = format!(\"{:?}\", iter);\n    assert_eq!(expected, actual);\n\n    let _ = iter.next().unwrap();\n    let expected = \"Iter([\\\"tmp\\\"])\";\n    let actual = format!(\"{:?}\", iter);\n    assert_eq!(expected, actual);\n\n    let _ = iter.next().unwrap();\n    let expected = \"Iter([])\";\n    let actual = format!(\"{:?}\", iter);\n    assert_eq!(expected, actual);\n}\n\n#[test]\nfn into_boxed() {\n    let orig: &str = \"some/sort/of/path\";\n    let path = Path::new(orig);\n    let boxed: Box<Path> = Box::from(path);\n    let path_buf = path.to_owned().into_boxed_path().into_path_buf();\n    assert_eq!(path, &*boxed);\n    assert_eq!(&*boxed, &*path_buf);\n    assert_eq!(&*path_buf, path);\n}\n\n#[test]\nfn test_clone_into() {\n    let mut path_buf = PathBuf::from(\"supercalifragilisticexpialidocious\");\n    let path = Path::new(\"short\");\n    path.clone_into(&mut path_buf);\n    assert_eq!(path, path_buf);\n    assert!(path_buf.into_os_string().capacity() >= 15);\n}\n\n#[test]\nfn display_format_flags() {\n    assert_eq!(format!(\"a{:#<5}b\", Path::new(\"\").display()), \"a#####b\");\n    assert_eq!(format!(\"a{:#<5}b\", Path::new(\"a\").display()), \"aa####b\");\n}\n\n#[test]\nfn into_rc() {\n    let orig = \"hello/world\";\n    let path = Path::new(orig);\n    let rc: Rc<Path> = Rc::from(path);\n    let arc: Arc<Path> = Arc::from(path);\n\n    assert_eq!(&*rc, path);\n    assert_eq!(&*arc, path);\n\n    let rc2: Rc<Path> = Rc::from(path.to_owned());\n    let arc2: Arc<Path> = Arc::from(path.to_owned());\n\n    assert_eq!(&*rc2, path);\n    assert_eq!(&*arc2, path);\n}\n"],["2590","//! Constants specific to the `f64` double-precision floating point type.\n//!\n//! *[See also the `f64` primitive type](primitive@f64).*\n//!\n//! Mathematically significant numbers are provided in the `consts` sub-module.\n//!\n//! For the constants defined directly in this module\n//! (as distinct from those defined in the `consts` sub-module),\n//! new code should instead use the associated constants\n//! defined directly on the `f64` type.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![allow(missing_docs)]\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(not(test))]\nuse crate::intrinsics;\n#[cfg(not(test))]\nuse crate::sys::cmath;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated, deprecated_in_future)]\npub use core::f64::{\n    consts, DIGITS, EPSILON, INFINITY, MANTISSA_DIGITS, MAX, MAX_10_EXP, MAX_EXP, MIN, MIN_10_EXP,\n    MIN_EXP, MIN_POSITIVE, NAN, NEG_INFINITY, RADIX,\n};\n\n#[cfg(not(test))]\n#[lang = \"f64_runtime\"]\nimpl f64 {\n    /// Returns the largest integer less than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.7_f64;\n    /// let g = 3.0_f64;\n    /// let h = -3.7_f64;\n    ///\n    /// assert_eq!(f.floor(), 3.0);\n    /// assert_eq!(g.floor(), 3.0);\n    /// assert_eq!(h.floor(), -4.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn floor(self) -> f64 {\n        unsafe { intrinsics::floorf64(self) }\n    }\n\n    /// Returns the smallest integer greater than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.01_f64;\n    /// let g = 4.0_f64;\n    ///\n    /// assert_eq!(f.ceil(), 4.0);\n    /// assert_eq!(g.ceil(), 4.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ceil(self) -> f64 {\n        unsafe { intrinsics::ceilf64(self) }\n    }\n\n    /// Returns the nearest integer to a number. Round half-way cases away from\n    /// `0.0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.3_f64;\n    /// let g = -3.3_f64;\n    ///\n    /// assert_eq!(f.round(), 3.0);\n    /// assert_eq!(g.round(), -3.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn round(self) -> f64 {\n        unsafe { intrinsics::roundf64(self) }\n    }\n\n    /// Returns the integer part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.7_f64;\n    /// let g = 3.0_f64;\n    /// let h = -3.7_f64;\n    ///\n    /// assert_eq!(f.trunc(), 3.0);\n    /// assert_eq!(g.trunc(), 3.0);\n    /// assert_eq!(h.trunc(), -3.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn trunc(self) -> f64 {\n        unsafe { intrinsics::truncf64(self) }\n    }\n\n    /// Returns the fractional part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 3.6_f64;\n    /// let y = -3.6_f64;\n    /// let abs_difference_x = (x.fract() - 0.6).abs();\n    /// let abs_difference_y = (y.fract() - (-0.6)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn fract(self) -> f64 {\n        self - self.trunc()\n    }\n\n    /// Computes the absolute value of `self`. Returns `NAN` if the\n    /// number is `NAN`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 3.5_f64;\n    /// let y = -3.5_f64;\n    ///\n    /// let abs_difference_x = (x.abs() - x).abs();\n    /// let abs_difference_y = (y.abs() - (-y)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    ///\n    /// assert!(f64::NAN.abs().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn abs(self) -> f64 {\n        unsafe { intrinsics::fabsf64(self) }\n    }\n\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n    /// - `NAN` if the number is `NAN`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.5_f64;\n    ///\n    /// assert_eq!(f.signum(), 1.0);\n    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n    ///\n    /// assert!(f64::NAN.signum().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn signum(self) -> f64 {\n        if self.is_nan() { Self::NAN } else { 1.0_f64.copysign(self) }\n    }\n\n    /// Returns a number composed of the magnitude of `self` and the sign of\n    /// `sign`.\n    ///\n    /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n    /// `sign` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.5_f64;\n    ///\n    /// assert_eq!(f.copysign(0.42), 3.5_f64);\n    /// assert_eq!(f.copysign(-0.42), -3.5_f64);\n    /// assert_eq!((-f).copysign(0.42), 3.5_f64);\n    /// assert_eq!((-f).copysign(-0.42), -3.5_f64);\n    ///\n    /// assert!(f64::NAN.copysign(1.0).is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"copysign\", since = \"1.35.0\")]\n    #[inline]\n    pub fn copysign(self, sign: f64) -> f64 {\n        unsafe { intrinsics::copysignf64(self, sign) }\n    }\n\n    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n    /// error, yielding a more accurate result than an unfused multiply-add.\n    ///\n    /// Using `mul_add` *may* be more performant than an unfused multiply-add if\n    /// the target architecture has a dedicated `fma` CPU instruction. However,\n    /// this is not always true, and will be heavily dependant on designing\n    /// algorithms with specific target hardware in mind.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let m = 10.0_f64;\n    /// let x = 4.0_f64;\n    /// let b = 60.0_f64;\n    ///\n    /// // 100.0\n    /// let abs_difference = (m.mul_add(x, b) - ((m * x) + b)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn mul_add(self, a: f64, b: f64) -> f64 {\n        unsafe { intrinsics::fmaf64(self, a, b) }\n    }\n\n    /// Calculates Euclidean division, the matching method for `rem_euclid`.\n    ///\n    /// This computes the integer `n` such that\n    /// `self = n * rhs + self.rem_euclid(rhs)`.\n    /// In other words, the result is `self / rhs` rounded to the integer `n`\n    /// such that `self >= n * rhs`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a: f64 = 7.0;\n    /// let b = 4.0;\n    /// assert_eq!(a.div_euclid(b), 1.0); // 7.0 > 4.0 * 1.0\n    /// assert_eq!((-a).div_euclid(b), -2.0); // -7.0 >= 4.0 * -2.0\n    /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n    /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[inline]\n    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n    pub fn div_euclid(self, rhs: f64) -> f64 {\n        let q = (self / rhs).trunc();\n        if self % rhs < 0.0 {\n            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 };\n        }\n        q\n    }\n\n    /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n    ///\n    /// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in\n    /// most cases. However, due to a floating point round-off error it can\n    /// result in `r == rhs.abs()`, violating the mathematical definition, if\n    /// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.\n    /// This result is not an element of the function's codomain, but it is the\n    /// closest floating point number in the real numbers and thus fulfills the\n    /// property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`\n    /// approximatively.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a: f64 = 7.0;\n    /// let b = 4.0;\n    /// assert_eq!(a.rem_euclid(b), 3.0);\n    /// assert_eq!((-a).rem_euclid(b), 1.0);\n    /// assert_eq!(a.rem_euclid(-b), 3.0);\n    /// assert_eq!((-a).rem_euclid(-b), 1.0);\n    /// // limitation due to round-off error\n    /// assert!((-f64::EPSILON).rem_euclid(3.0) != 0.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[inline]\n    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n    pub fn rem_euclid(self, rhs: f64) -> f64 {\n        let r = self % rhs;\n        if r < 0.0 { r + rhs.abs() } else { r }\n    }\n\n    /// Raises a number to an integer power.\n    ///\n    /// Using this function is generally faster than using `powf`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let abs_difference = (x.powi(2) - (x * x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn powi(self, n: i32) -> f64 {\n        unsafe { intrinsics::powif64(self, n) }\n    }\n\n    /// Raises a number to a floating point power.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let abs_difference = (x.powf(2.0) - (x * x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn powf(self, n: f64) -> f64 {\n        unsafe { intrinsics::powf64(self, n) }\n    }\n\n    /// Returns the square root of a number.\n    ///\n    /// Returns NaN if `self` is a negative number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let positive = 4.0_f64;\n    /// let negative = -4.0_f64;\n    ///\n    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// assert!(negative.sqrt().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sqrt(self) -> f64 {\n        unsafe { intrinsics::sqrtf64(self) }\n    }\n\n    /// Returns `e^(self)`, (the exponential function).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let one = 1.0_f64;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp(self) -> f64 {\n        unsafe { intrinsics::expf64(self) }\n    }\n\n    /// Returns `2^(self)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 2.0_f64;\n    ///\n    /// // 2^2 - 4 == 0\n    /// let abs_difference = (f.exp2() - 4.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp2(self) -> f64 {\n        unsafe { intrinsics::exp2f64(self) }\n    }\n\n    /// Returns the natural logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let one = 1.0_f64;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ln(self) -> f64 {\n        self.log_wrapper(|n| unsafe { intrinsics::logf64(n) })\n    }\n\n    /// Returns the logarithm of the number with respect to an arbitrary base.\n    ///\n    /// The result may not be correctly rounded owing to implementation details;\n    /// `self.log2()` can produce more accurate results for base 2, and\n    /// `self.log10()` can produce more accurate results for base 10.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let twenty_five = 25.0_f64;\n    ///\n    /// // log5(25) - 2 == 0\n    /// let abs_difference = (twenty_five.log(5.0) - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log(self, base: f64) -> f64 {\n        self.ln() / base.ln()\n    }\n\n    /// Returns the base 2 logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let four = 4.0_f64;\n    ///\n    /// // log2(4) - 2 == 0\n    /// let abs_difference = (four.log2() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log2(self) -> f64 {\n        self.log_wrapper(|n| {\n            #[cfg(target_os = \"android\")]\n            return crate::sys::android::log2f64(n);\n            #[cfg(not(target_os = \"android\"))]\n            return unsafe { intrinsics::log2f64(n) };\n        })\n    }\n\n    /// Returns the base 10 logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let hundred = 100.0_f64;\n    ///\n    /// // log10(100) - 2 == 0\n    /// let abs_difference = (hundred.log10() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log10(self) -> f64 {\n        self.log_wrapper(|n| unsafe { intrinsics::log10f64(n) })\n    }\n\n    /// The positive difference of two numbers.\n    ///\n    /// * If `self <= other`: `0:0`\n    /// * Else: `self - other`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 3.0_f64;\n    /// let y = -3.0_f64;\n    ///\n    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    #[rustc_deprecated(\n        since = \"1.10.0\",\n        reason = \"you probably meant `(self - other).abs()`: \\\n                  this operation is `(self - other).max(0.0)` \\\n                  except that `abs_sub` also propagates NaNs (also \\\n                  known as `fdim` in C). If you truly need the positive \\\n                  difference, consider using that expression or the C function \\\n                  `fdim`, depending on how you wish to handle NaN (please consider \\\n                  filing an issue describing your use-case too).\"\n    )]\n    pub fn abs_sub(self, other: f64) -> f64 {\n        unsafe { cmath::fdim(self, other) }\n    }\n\n    /// Returns the cube root of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 8.0_f64;\n    ///\n    /// // x^(1/3) - 2 == 0\n    /// let abs_difference = (x.cbrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cbrt(self) -> f64 {\n        unsafe { cmath::cbrt(self) }\n    }\n\n    /// Calculates the length of the hypotenuse of a right-angle triangle given\n    /// legs of length `x` and `y`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let y = 3.0_f64;\n    ///\n    /// // sqrt(x^2 + y^2)\n    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn hypot(self, other: f64) -> f64 {\n        unsafe { cmath::hypot(self, other) }\n    }\n\n    /// Computes the sine of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = std::f64::consts::FRAC_PI_2;\n    ///\n    /// let abs_difference = (x.sin() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sin(self) -> f64 {\n        unsafe { intrinsics::sinf64(self) }\n    }\n\n    /// Computes the cosine of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0 * std::f64::consts::PI;\n    ///\n    /// let abs_difference = (x.cos() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cos(self) -> f64 {\n        unsafe { intrinsics::cosf64(self) }\n    }\n\n    /// Computes the tangent of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = std::f64::consts::FRAC_PI_4;\n    /// let abs_difference = (x.tan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-14);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn tan(self) -> f64 {\n        unsafe { cmath::tan(self) }\n    }\n\n    /// Computes the arcsine of a number. Return value is in radians in\n    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = std::f64::consts::FRAC_PI_2;\n    ///\n    /// // asin(sin(pi/2))\n    /// let abs_difference = (f.sin().asin() - std::f64::consts::FRAC_PI_2).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn asin(self) -> f64 {\n        unsafe { cmath::asin(self) }\n    }\n\n    /// Computes the arccosine of a number. Return value is in radians in\n    /// the range [0, pi] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = std::f64::consts::FRAC_PI_4;\n    ///\n    /// // acos(cos(pi/4))\n    /// let abs_difference = (f.cos().acos() - std::f64::consts::FRAC_PI_4).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn acos(self) -> f64 {\n        unsafe { cmath::acos(self) }\n    }\n\n    /// Computes the arctangent of a number. Return value is in radians in the\n    /// range [-pi/2, pi/2];\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 1.0_f64;\n    ///\n    /// // atan(tan(1))\n    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atan(self) -> f64 {\n        unsafe { cmath::atan(self) }\n    }\n\n    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`) in radians.\n    ///\n    /// * `x = 0`, `y = 0`: `0`\n    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // Positive angles measured counter-clockwise\n    /// // from positive x axis\n    /// // -pi/4 radians (45 deg clockwise)\n    /// let x1 = 3.0_f64;\n    /// let y1 = -3.0_f64;\n    ///\n    /// // 3pi/4 radians (135 deg counter-clockwise)\n    /// let x2 = -3.0_f64;\n    /// let y2 = 3.0_f64;\n    ///\n    /// let abs_difference_1 = (y1.atan2(x1) - (-std::f64::consts::FRAC_PI_4)).abs();\n    /// let abs_difference_2 = (y2.atan2(x2) - (3.0 * std::f64::consts::FRAC_PI_4)).abs();\n    ///\n    /// assert!(abs_difference_1 < 1e-10);\n    /// assert!(abs_difference_2 < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atan2(self, other: f64) -> f64 {\n        unsafe { cmath::atan2(self, other) }\n    }\n\n    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n    /// `(sin(x), cos(x))`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = std::f64::consts::FRAC_PI_4;\n    /// let f = x.sin_cos();\n    ///\n    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n    ///\n    /// assert!(abs_difference_0 < 1e-10);\n    /// assert!(abs_difference_1 < 1e-10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sin_cos(self) -> (f64, f64) {\n        (self.sin(), self.cos())\n    }\n\n    /// Returns `e^(self) - 1` in a way that is accurate even if the\n    /// number is close to zero.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1e-16_f64;\n    ///\n    /// // for very small x, e^x is approximately 1 + x + x^2 / 2\n    /// let approx = x + x * x / 2.0;\n    /// let abs_difference = (x.exp_m1() - approx).abs();\n    ///\n    /// assert!(abs_difference < 1e-20);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp_m1(self) -> f64 {\n        unsafe { cmath::expm1(self) }\n    }\n\n    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n    /// the operations were performed separately.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1e-16_f64;\n    ///\n    /// // for very small x, ln(1 + x) is approximately x - x^2 / 2\n    /// let approx = x - x * x / 2.0;\n    /// let abs_difference = (x.ln_1p() - approx).abs();\n    ///\n    /// assert!(abs_difference < 1e-20);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ln_1p(self) -> f64 {\n        unsafe { cmath::log1p(self) }\n    }\n\n    /// Hyperbolic sine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let e = std::f64::consts::E;\n    /// let x = 1.0_f64;\n    ///\n    /// let f = x.sinh();\n    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n    /// let g = ((e * e) - 1.0) / (2.0 * e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sinh(self) -> f64 {\n        unsafe { cmath::sinh(self) }\n    }\n\n    /// Hyperbolic cosine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let e = std::f64::consts::E;\n    /// let x = 1.0_f64;\n    /// let f = x.cosh();\n    /// // Solving cosh() at 1 gives this result\n    /// let g = ((e * e) + 1.0) / (2.0 * e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// // Same result\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cosh(self) -> f64 {\n        unsafe { cmath::cosh(self) }\n    }\n\n    /// Hyperbolic tangent function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let e = std::f64::consts::E;\n    /// let x = 1.0_f64;\n    ///\n    /// let f = x.tanh();\n    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n    /// let g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn tanh(self) -> f64 {\n        unsafe { cmath::tanh(self) }\n    }\n\n    /// Inverse hyperbolic sine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let f = x.sinh().asinh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn asinh(self) -> f64 {\n        (self.abs() + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n    }\n\n    /// Inverse hyperbolic cosine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let f = x.cosh().acosh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn acosh(self) -> f64 {\n        if self < 1.0 { Self::NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n    }\n\n    /// Inverse hyperbolic tangent function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let e = std::f64::consts::E;\n    /// let f = e.tanh().atanh();\n    ///\n    /// let abs_difference = (f - e).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atanh(self) -> f64 {\n        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n    }\n\n    // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n    // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n    // of expected NaN).\n    fn log_wrapper<F: Fn(f64) -> f64>(self, log_fn: F) -> f64 {\n        if !cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n            log_fn(self)\n        } else if self.is_finite() {\n            if self > 0.0 {\n                log_fn(self)\n            } else if self == 0.0 {\n                Self::NEG_INFINITY // log(0) = -Inf\n            } else {\n                Self::NAN // log(-n) = NaN\n            }\n        } else if self.is_nan() {\n            self // log(NaN) = NaN\n        } else if self > 0.0 {\n            self // log(Inf) = Inf\n        } else {\n            Self::NAN // log(-Inf) = NaN\n        }\n    }\n}\n"],["2591","//! Runtime services\n//!\n//! The `rt` module provides a narrow set of runtime services,\n//! including the global heap (exported in `heap`) and unwinding and\n//! backtrace support. The APIs in this module are highly unstable,\n//! and should be considered as private implementation details for the\n//! time being.\n\n#![unstable(\n    feature = \"rt\",\n    reason = \"this public module should not exist and is highly likely \\\n              to disappear\",\n    issue = \"none\"\n)]\n#![doc(hidden)]\n\n// Re-export some of our utilities which are expected by other crates.\npub use crate::panicking::{begin_panic, begin_panic_fmt, panic_count};\n\n// To reduce the generated code of the new `lang_start`, this function is doing\n// the real work.\n#[cfg(not(test))]\nfn lang_start_internal(\n    main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindSafe),\n    argc: isize,\n    argv: *const *const u8,\n) -> isize {\n    use crate::panic;\n    use crate::sys_common;\n\n    // SAFETY: Only called once during runtime initialization.\n    unsafe { sys_common::rt::init(argc, argv) };\n\n    let exit_code = panic::catch_unwind(main);\n\n    sys_common::rt::cleanup();\n\n    exit_code.unwrap_or(101) as isize\n}\n\n#[cfg(not(test))]\n#[lang = \"start\"]\nfn lang_start<T: crate::process::Termination + 'static>(\n    main: fn() -> T,\n    argc: isize,\n    argv: *const *const u8,\n) -> isize {\n    lang_start_internal(\n        &move || crate::sys_common::backtrace::__rust_begin_short_backtrace(main).report(),\n        argc,\n        argv,\n    )\n}\n"],["2592","//! A module for working with processes.\n//!\n//! This module is mostly concerned with spawning and interacting with child\n//! processes, but it also provides [`abort`] and [`exit`] for terminating the\n//! current process.\n//!\n//! # Spawning a process\n//!\n//! The [`Command`] struct is used to configure and spawn processes:\n//!\n//! ```no_run\n//! use std::process::Command;\n//!\n//! let output = Command::new(\"echo\")\n//!                      .arg(\"Hello world\")\n//!                      .output()\n//!                      .expect(\"Failed to execute command\");\n//!\n//! assert_eq!(b\"Hello world\\n\", output.stdout.as_slice());\n//! ```\n//!\n//! Several methods on [`Command`], such as [`spawn`] or [`output`], can be used\n//! to spawn a process. In particular, [`output`] spawns the child process and\n//! waits until the process terminates, while [`spawn`] will return a [`Child`]\n//! that represents the spawned child process.\n//!\n//! # Handling I/O\n//!\n//! The [`stdout`], [`stdin`], and [`stderr`] of a child process can be\n//! configured by passing an [`Stdio`] to the corresponding method on\n//! [`Command`]. Once spawned, they can be accessed from the [`Child`]. For\n//! example, piping output from one command into another command can be done\n//! like so:\n//!\n//! ```no_run\n//! use std::process::{Command, Stdio};\n//!\n//! // stdout must be configured with `Stdio::piped` in order to use\n//! // `echo_child.stdout`\n//! let echo_child = Command::new(\"echo\")\n//!     .arg(\"Oh no, a tpyo!\")\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"Failed to start echo process\");\n//!\n//! // Note that `echo_child` is moved here, but we won't be needing\n//! // `echo_child` anymore\n//! let echo_out = echo_child.stdout.expect(\"Failed to open echo stdout\");\n//!\n//! let mut sed_child = Command::new(\"sed\")\n//!     .arg(\"s/tpyo/typo/\")\n//!     .stdin(Stdio::from(echo_out))\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"Failed to start sed process\");\n//!\n//! let output = sed_child.wait_with_output().expect(\"Failed to wait on sed\");\n//! assert_eq!(b\"Oh no, a typo!\\n\", output.stdout.as_slice());\n//! ```\n//!\n//! Note that [`ChildStderr`] and [`ChildStdout`] implement [`Read`] and\n//! [`ChildStdin`] implements [`Write`]:\n//!\n//! ```no_run\n//! use std::process::{Command, Stdio};\n//! use std::io::Write;\n//!\n//! let mut child = Command::new(\"/bin/cat\")\n//!     .stdin(Stdio::piped())\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"failed to execute child\");\n//!\n//! // If the child process fills its stdout buffer, it may end up\n//! // waiting until the parent reads the stdout, and not be able to\n//! // read stdin in the meantime, causing a deadlock.\n//! // Writing from another thread ensures that stdout is being read\n//! // at the same time, avoiding the problem.\n//! let mut stdin = child.stdin.take().expect(\"failed to get stdin\");\n//! std::thread::spawn(move || {\n//!     stdin.write_all(b\"test\").expect(\"failed to write to stdin\");\n//! });\n//!\n//! let output = child\n//!     .wait_with_output()\n//!     .expect(\"failed to wait on child\");\n//!\n//! assert_eq!(b\"test\", output.stdout.as_slice());\n//! ```\n//!\n//! [`spawn`]: Command::spawn\n//! [`output`]: Command::output\n//!\n//! [`stdout`]: Command::stdout\n//! [`stdin`]: Command::stdin\n//! [`stderr`]: Command::stderr\n//!\n//! [`Write`]: io::Write\n//! [`Read`]: io::Read\n\n#![stable(feature = \"process\", since = \"1.0.0\")]\n#![deny(unsafe_op_in_unsafe_fn)]\n\n#[cfg(all(test, not(any(target_os = \"emscripten\", target_env = \"sgx\"))))]\nmod tests;\n\nuse crate::io::prelude::*;\n\nuse crate::ffi::OsStr;\nuse crate::fmt;\nuse crate::fs;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut};\nuse crate::num::NonZeroI32;\nuse crate::path::Path;\nuse crate::str;\nuse crate::sys::pipe::{read2, AnonPipe};\nuse crate::sys::process as imp;\n#[unstable(feature = \"command_access\", issue = \"44434\")]\npub use crate::sys_common::process::CommandEnvs;\nuse crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n\n/// Representation of a running or exited child process.\n///\n/// This structure is used to represent and manage child processes. A child\n/// process is created via the [`Command`] struct, which configures the\n/// spawning process and can itself be constructed using a builder-style\n/// interface.\n///\n/// There is no implementation of [`Drop`] for child processes,\n/// so if you do not ensure the `Child` has exited then it will continue to\n/// run, even after the `Child` handle to the child process has gone out of\n/// scope.\n///\n/// Calling [`wait`] (or other functions that wrap around it) will make\n/// the parent process wait until the child has actually exited before\n/// continuing.\n///\n/// # Warning\n///\n/// On some systems, calling [`wait`] or similar is necessary for the OS to\n/// release resources. A process that terminated but has not been waited on is\n/// still around as a \"zombie\". Leaving too many zombies around may exhaust\n/// global resources (for example process IDs).\n///\n/// The standard library does *not* automatically wait on child processes (not\n/// even if the `Child` is dropped), it is up to the application developer to do\n/// so. As a consequence, dropping `Child` handles without waiting on them first\n/// is not recommended in long-running applications.\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::process::Command;\n///\n/// let mut child = Command::new(\"/bin/cat\")\n///                         .arg(\"file.txt\")\n///                         .spawn()\n///                         .expect(\"failed to execute child\");\n///\n/// let ecode = child.wait()\n///                  .expect(\"failed to wait on child\");\n///\n/// assert!(ecode.success());\n/// ```\n///\n/// [`wait`]: Child::wait\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Child {\n    handle: imp::Process,\n\n    /// The handle for writing to the child's standard input (stdin), if it has\n    /// been captured. To avoid partially moving\n    /// the `child` and thus blocking yourself from calling\n    /// functions on `child` while using `stdin`,\n    /// you might find it helpful:\n    ///\n    /// ```compile_fail,E0425\n    /// let stdin = child.stdin.take().unwrap();\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdin: Option<ChildStdin>,\n\n    /// The handle for reading from the child's standard output (stdout), if it\n    /// has been captured. You might find it helpful to do\n    ///\n    /// ```compile_fail,E0425\n    /// let stdout = child.stdout.take().unwrap();\n    /// ```\n    ///\n    /// to avoid partially moving the `child` and thus blocking yourself from calling\n    /// functions on `child` while using `stdout`.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdout: Option<ChildStdout>,\n\n    /// The handle for reading from the child's standard error (stderr), if it\n    /// has been captured. You might find it helpful to do\n    ///\n    /// ```compile_fail,E0425\n    /// let stderr = child.stderr.take().unwrap();\n    /// ```\n    ///\n    /// to avoid partially moving the `child` and thus blocking yourself from calling\n    /// functions on `child` while using `stderr`.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stderr: Option<ChildStderr>,\n}\n\nimpl AsInner<imp::Process> for Child {\n    fn as_inner(&self) -> &imp::Process {\n        &self.handle\n    }\n}\n\nimpl FromInner<(imp::Process, imp::StdioPipes)> for Child {\n    fn from_inner((handle, io): (imp::Process, imp::StdioPipes)) -> Child {\n        Child {\n            handle,\n            stdin: io.stdin.map(ChildStdin::from_inner),\n            stdout: io.stdout.map(ChildStdout::from_inner),\n            stderr: io.stderr.map(ChildStderr::from_inner),\n        }\n    }\n}\n\nimpl IntoInner<imp::Process> for Child {\n    fn into_inner(self) -> imp::Process {\n        self.handle\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Child {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Child\")\n            .field(\"stdin\", &self.stdin)\n            .field(\"stdout\", &self.stdout)\n            .field(\"stderr\", &self.stderr)\n            .finish_non_exhaustive()\n    }\n}\n\n/// A handle to a child process's standard input (stdin).\n///\n/// This struct is used in the [`stdin`] field on [`Child`].\n///\n/// When an instance of `ChildStdin` is [dropped], the `ChildStdin`'s underlying\n/// file handle will be closed. If the child process was blocked on input prior\n/// to being dropped, it will become unblocked after dropping.\n///\n/// [`stdin`]: Child::stdin\n/// [dropped]: Drop\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStdin {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Write for ChildStdin {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        (&*self).write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        (&*self).write_vectored(bufs)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        io::Write::is_write_vectored(&&*self)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        (&*self).flush()\n    }\n}\n\n#[stable(feature = \"write_mt\", since = \"1.48.0\")]\nimpl Write for &ChildStdin {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        self.inner.write_vectored(bufs)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        self.inner.is_write_vectored()\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\n\nimpl AsInner<AnonPipe> for ChildStdin {\n    fn as_inner(&self) -> &AnonPipe {\n        &self.inner\n    }\n}\n\nimpl IntoInner<AnonPipe> for ChildStdin {\n    fn into_inner(self) -> AnonPipe {\n        self.inner\n    }\n}\n\nimpl FromInner<AnonPipe> for ChildStdin {\n    fn from_inner(pipe: AnonPipe) -> ChildStdin {\n        ChildStdin { inner: pipe }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStdin {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"ChildStdin\").finish_non_exhaustive()\n    }\n}\n\n/// A handle to a child process's standard output (stdout).\n///\n/// This struct is used in the [`stdout`] field on [`Child`].\n///\n/// When an instance of `ChildStdout` is [dropped], the `ChildStdout`'s\n/// underlying file handle will be closed.\n///\n/// [`stdout`]: Child::stdout\n/// [dropped]: Drop\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStdout {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Read for ChildStdout {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        // SAFETY: Read is guaranteed to work on uninitialized memory\n        unsafe { Initializer::nop() }\n    }\n}\n\nimpl AsInner<AnonPipe> for ChildStdout {\n    fn as_inner(&self) -> &AnonPipe {\n        &self.inner\n    }\n}\n\nimpl IntoInner<AnonPipe> for ChildStdout {\n    fn into_inner(self) -> AnonPipe {\n        self.inner\n    }\n}\n\nimpl FromInner<AnonPipe> for ChildStdout {\n    fn from_inner(pipe: AnonPipe) -> ChildStdout {\n        ChildStdout { inner: pipe }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStdout {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"ChildStdout\").finish_non_exhaustive()\n    }\n}\n\n/// A handle to a child process's stderr.\n///\n/// This struct is used in the [`stderr`] field on [`Child`].\n///\n/// When an instance of `ChildStderr` is [dropped], the `ChildStderr`'s\n/// underlying file handle will be closed.\n///\n/// [`stderr`]: Child::stderr\n/// [dropped]: Drop\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStderr {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Read for ChildStderr {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n        // SAFETY: Read is guaranteed to work on uninitialized memory\n        unsafe { Initializer::nop() }\n    }\n}\n\nimpl AsInner<AnonPipe> for ChildStderr {\n    fn as_inner(&self) -> &AnonPipe {\n        &self.inner\n    }\n}\n\nimpl IntoInner<AnonPipe> for ChildStderr {\n    fn into_inner(self) -> AnonPipe {\n        self.inner\n    }\n}\n\nimpl FromInner<AnonPipe> for ChildStderr {\n    fn from_inner(pipe: AnonPipe) -> ChildStderr {\n        ChildStderr { inner: pipe }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStderr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"ChildStderr\").finish_non_exhaustive()\n    }\n}\n\n/// A process builder, providing fine-grained control\n/// over how a new process should be spawned.\n///\n/// A default configuration can be\n/// generated using `Command::new(program)`, where `program` gives a path to the\n/// program to be executed. Additional builder methods allow the configuration\n/// to be changed (for example, by adding arguments) prior to spawning:\n///\n/// ```\n/// use std::process::Command;\n///\n/// let output = if cfg!(target_os = \"windows\") {\n///     Command::new(\"cmd\")\n///             .args(&[\"/C\", \"echo hello\"])\n///             .output()\n///             .expect(\"failed to execute process\")\n/// } else {\n///     Command::new(\"sh\")\n///             .arg(\"-c\")\n///             .arg(\"echo hello\")\n///             .output()\n///             .expect(\"failed to execute process\")\n/// };\n///\n/// let hello = output.stdout;\n/// ```\n///\n/// `Command` can be reused to spawn multiple processes. The builder methods\n/// change the command without needing to immediately spawn the process.\n///\n/// ```no_run\n/// use std::process::Command;\n///\n/// let mut echo_hello = Command::new(\"sh\");\n/// echo_hello.arg(\"-c\")\n///           .arg(\"echo hello\");\n/// let hello_1 = echo_hello.output().expect(\"failed to execute process\");\n/// let hello_2 = echo_hello.output().expect(\"failed to execute process\");\n/// ```\n///\n/// Similarly, you can call builder methods after spawning a process and then\n/// spawn a new process with the modified settings.\n///\n/// ```no_run\n/// use std::process::Command;\n///\n/// let mut list_dir = Command::new(\"ls\");\n///\n/// // Execute `ls` in the current directory of the program.\n/// list_dir.status().expect(\"process failed to execute\");\n///\n/// println!();\n///\n/// // Change `ls` to execute in the root directory.\n/// list_dir.current_dir(\"/\");\n///\n/// // And then execute `ls` again but in the root directory.\n/// list_dir.status().expect(\"process failed to execute\");\n/// ```\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Command {\n    inner: imp::Command,\n}\n\n/// Allows extension traits within `std`.\n#[unstable(feature = \"sealed\", issue = \"none\")]\nimpl crate::sealed::Sealed for Command {}\n\nimpl Command {\n    /// Constructs a new `Command` for launching the program at\n    /// path `program`, with the following default configuration:\n    ///\n    /// * No arguments to the program\n    /// * Inherit the current process's environment\n    /// * Inherit the current process's working directory\n    /// * Inherit stdin/stdout/stderr for `spawn` or `status`, but create pipes for `output`\n    ///\n    /// Builder methods are provided to change these defaults and\n    /// otherwise configure the process.\n    ///\n    /// If `program` is not an absolute path, the `PATH` will be searched in\n    /// an OS-defined way.\n    ///\n    /// The search path to be used may be controlled by setting the\n    /// `PATH` environment variable on the Command,\n    /// but this has some implementation limitations on Windows\n    /// (see issue #37519).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"sh\")\n    ///         .spawn()\n    ///         .expect(\"sh command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n        Command { inner: imp::Command::new(program.as_ref()) }\n    }\n\n    /// Adds an argument to pass to the program.\n    ///\n    /// Only one argument can be passed per use. So instead of:\n    ///\n    /// ```no_run\n    /// # std::process::Command::new(\"sh\")\n    /// .arg(\"-C /path/to/repo\")\n    /// # ;\n    /// ```\n    ///\n    /// usage would be:\n    ///\n    /// ```no_run\n    /// # std::process::Command::new(\"sh\")\n    /// .arg(\"-C\")\n    /// .arg(\"/path/to/repo\")\n    /// # ;\n    /// ```\n    ///\n    /// To pass multiple arguments see [`args`].\n    ///\n    /// [`args`]: Command::args\n    ///\n    /// Note that the argument is not passed through a shell, but given\n    /// literally to the program. This means that shell syntax like quotes,\n    /// escaped characters, word splitting, glob patterns, substitution, etc.\n    /// have no effect.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .arg(\"-l\")\n    ///         .arg(\"-a\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {\n        self.inner.arg(arg.as_ref());\n        self\n    }\n\n    /// Adds multiple arguments to pass to the program.\n    ///\n    /// To pass a single argument see [`arg`].\n    ///\n    /// [`arg`]: Command::arg\n    ///\n    /// Note that the arguments are not passed through a shell, but given\n    /// literally to the program. This means that shell syntax like quotes,\n    /// escaped characters, word splitting, glob patterns, substitution, etc.\n    /// have no effect.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .args(&[\"-l\", \"-a\"])\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn args<I, S>(&mut self, args: I) -> &mut Command\n    where\n        I: IntoIterator<Item = S>,\n        S: AsRef<OsStr>,\n    {\n        for arg in args {\n            self.arg(arg.as_ref());\n        }\n        self\n    }\n\n    /// Inserts or updates an environment variable mapping.\n    ///\n    /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n    /// and case-sensitive on all other platforms.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env(\"PATH\", \"/bin\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n    where\n        K: AsRef<OsStr>,\n        V: AsRef<OsStr>,\n    {\n        self.inner.env_mut().set(key.as_ref(), val.as_ref());\n        self\n    }\n\n    /// Adds or updates multiple environment variable mappings.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    /// use std::env;\n    /// use std::collections::HashMap;\n    ///\n    /// let filtered_env : HashMap<String, String> =\n    ///     env::vars().filter(|&(ref k, _)|\n    ///         k == \"TERM\" || k == \"TZ\" || k == \"LANG\" || k == \"PATH\"\n    ///     ).collect();\n    ///\n    /// Command::new(\"printenv\")\n    ///         .stdin(Stdio::null())\n    ///         .stdout(Stdio::inherit())\n    ///         .env_clear()\n    ///         .envs(&filtered_env)\n    ///         .spawn()\n    ///         .expect(\"printenv failed to start\");\n    /// ```\n    #[stable(feature = \"command_envs\", since = \"1.19.0\")]\n    pub fn envs<I, K, V>(&mut self, vars: I) -> &mut Command\n    where\n        I: IntoIterator<Item = (K, V)>,\n        K: AsRef<OsStr>,\n        V: AsRef<OsStr>,\n    {\n        for (ref key, ref val) in vars {\n            self.inner.env_mut().set(key.as_ref(), val.as_ref());\n        }\n        self\n    }\n\n    /// Removes an environment variable mapping.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env_remove(\"PATH\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command {\n        self.inner.env_mut().remove(key.as_ref());\n        self\n    }\n\n    /// Clears the entire environment map for the child process.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env_clear()\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env_clear(&mut self) -> &mut Command {\n        self.inner.env_mut().clear();\n        self\n    }\n\n    /// Sets the working directory for the child process.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// If the program path is relative (e.g., `\"./script.sh\"`), it's ambiguous\n    /// whether it should be interpreted relative to the parent's working\n    /// directory or relative to `current_dir`. The behavior in this case is\n    /// platform specific and unstable, and it's recommended to use\n    /// [`canonicalize`] to get an absolute program path instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .current_dir(\"/bin\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    ///\n    /// [`canonicalize`]: crate::fs::canonicalize\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command {\n        self.inner.cwd(dir.as_ref().as_ref());\n        self\n    }\n\n    /// Configuration for the child process's standard input (stdin) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: Stdio::inherit\n    /// [`piped`]: Stdio::piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stdin(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stdin<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command {\n        self.inner.stdin(cfg.into().0);\n        self\n    }\n\n    /// Configuration for the child process's standard output (stdout) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: Stdio::inherit\n    /// [`piped`]: Stdio::piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stdout(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stdout<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command {\n        self.inner.stdout(cfg.into().0);\n        self\n    }\n\n    /// Configuration for the child process's standard error (stderr) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: Stdio::inherit\n    /// [`piped`]: Stdio::piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stderr(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stderr<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command {\n        self.inner.stderr(cfg.into().0);\n        self\n    }\n\n    /// Executes the command as a child process, returning a handle to it.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn spawn(&mut self) -> io::Result<Child> {\n        self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)\n    }\n\n    /// Executes the command as a child process, waiting for it to finish and\n    /// collecting all of its output.\n    ///\n    /// By default, stdout and stderr are captured (and used to provide the\n    /// resulting output). Stdin is not inherited from the parent and any\n    /// attempt by the child process to read from the stdin stream will result\n    /// in the stream immediately closing.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::Command;\n    /// use std::io::{self, Write};\n    /// let output = Command::new(\"/bin/cat\")\n    ///                      .arg(\"file.txt\")\n    ///                      .output()\n    ///                      .expect(\"failed to execute process\");\n    ///\n    /// println!(\"status: {}\", output.status);\n    /// io::stdout().write_all(&output.stdout).unwrap();\n    /// io::stderr().write_all(&output.stderr).unwrap();\n    ///\n    /// assert!(output.status.success());\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn output(&mut self) -> io::Result<Output> {\n        self.inner\n            .spawn(imp::Stdio::MakePipe, false)\n            .map(Child::from_inner)\n            .and_then(|p| p.wait_with_output())\n    }\n\n    /// Executes a command as a child process, waiting for it to finish and\n    /// collecting its status.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"/bin/cat\")\n    ///                      .arg(\"file.txt\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute process\");\n    ///\n    /// println!(\"process finished with: {}\", status);\n    ///\n    /// assert!(status.success());\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn status(&mut self) -> io::Result<ExitStatus> {\n        self.inner\n            .spawn(imp::Stdio::Inherit, true)\n            .map(Child::from_inner)\n            .and_then(|mut p| p.wait())\n    }\n\n    /// Returns the path to the program that was given to [`Command::new`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(command_access)]\n    /// use std::process::Command;\n    ///\n    /// let cmd = Command::new(\"echo\");\n    /// assert_eq!(cmd.get_program(), \"echo\");\n    /// ```\n    #[unstable(feature = \"command_access\", issue = \"44434\")]\n    pub fn get_program(&self) -> &OsStr {\n        self.inner.get_program()\n    }\n\n    /// Returns an iterator of the arguments that will be passed to the program.\n    ///\n    /// This does not include the path to the program as the first argument;\n    /// it only includes the arguments specified with [`Command::arg`] and\n    /// [`Command::args`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(command_access)]\n    /// use std::ffi::OsStr;\n    /// use std::process::Command;\n    ///\n    /// let mut cmd = Command::new(\"echo\");\n    /// cmd.arg(\"first\").arg(\"second\");\n    /// let args: Vec<&OsStr> = cmd.get_args().collect();\n    /// assert_eq!(args, &[\"first\", \"second\"]);\n    /// ```\n    #[unstable(feature = \"command_access\", issue = \"44434\")]\n    pub fn get_args(&self) -> CommandArgs<'_> {\n        CommandArgs { inner: self.inner.get_args() }\n    }\n\n    /// Returns an iterator of the environment variables that will be set when\n    /// the process is spawned.\n    ///\n    /// Each element is a tuple `(&OsStr, Option<&OsStr>)`, where the first\n    /// value is the key, and the second is the value, which is [`None`] if\n    /// the environment variable is to be explicitly removed.\n    ///\n    /// This only includes environment variables explicitly set with\n    /// [`Command::env`], [`Command::envs`], and [`Command::env_remove`]. It\n    /// does not include environment variables that will be inherited by the\n    /// child process.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(command_access)]\n    /// use std::ffi::OsStr;\n    /// use std::process::Command;\n    ///\n    /// let mut cmd = Command::new(\"ls\");\n    /// cmd.env(\"TERM\", \"dumb\").env_remove(\"TZ\");\n    /// let envs: Vec<(&OsStr, Option<&OsStr>)> = cmd.get_envs().collect();\n    /// assert_eq!(envs, &[\n    ///     (OsStr::new(\"TERM\"), Some(OsStr::new(\"dumb\"))),\n    ///     (OsStr::new(\"TZ\"), None)\n    /// ]);\n    /// ```\n    #[unstable(feature = \"command_access\", issue = \"44434\")]\n    pub fn get_envs(&self) -> CommandEnvs<'_> {\n        self.inner.get_envs()\n    }\n\n    /// Returns the working directory for the child process.\n    ///\n    /// This returns [`None`] if the working directory will not be changed.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(command_access)]\n    /// use std::path::Path;\n    /// use std::process::Command;\n    ///\n    /// let mut cmd = Command::new(\"ls\");\n    /// assert_eq!(cmd.get_current_dir(), None);\n    /// cmd.current_dir(\"/bin\");\n    /// assert_eq!(cmd.get_current_dir(), Some(Path::new(\"/bin\")));\n    /// ```\n    #[unstable(feature = \"command_access\", issue = \"44434\")]\n    pub fn get_current_dir(&self) -> Option<&Path> {\n        self.inner.get_current_dir()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Command {\n    /// Format the program and arguments of a Command for display. Any\n    /// non-utf8 data is lossily converted using the utf8 replacement\n    /// character.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.inner.fmt(f)\n    }\n}\n\nimpl AsInner<imp::Command> for Command {\n    fn as_inner(&self) -> &imp::Command {\n        &self.inner\n    }\n}\n\nimpl AsInnerMut<imp::Command> for Command {\n    fn as_inner_mut(&mut self) -> &mut imp::Command {\n        &mut self.inner\n    }\n}\n\n/// An iterator over the command arguments.\n///\n/// This struct is created by [`Command::get_args`]. See its documentation for\n/// more.\n#[unstable(feature = \"command_access\", issue = \"44434\")]\n#[derive(Debug)]\npub struct CommandArgs<'a> {\n    inner: imp::CommandArgs<'a>,\n}\n\n#[unstable(feature = \"command_access\", issue = \"44434\")]\nimpl<'a> Iterator for CommandArgs<'a> {\n    type Item = &'a OsStr;\n    fn next(&mut self) -> Option<&'a OsStr> {\n        self.inner.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}\n\n#[unstable(feature = \"command_access\", issue = \"44434\")]\nimpl<'a> ExactSizeIterator for CommandArgs<'a> {\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n    fn is_empty(&self) -> bool {\n        self.inner.is_empty()\n    }\n}\n\n/// The output of a finished process.\n///\n/// This is returned in a Result by either the [`output`] method of a\n/// [`Command`], or the [`wait_with_output`] method of a [`Child`]\n/// process.\n///\n/// [`output`]: Command::output\n/// [`wait_with_output`]: Child::wait_with_output\n#[derive(PartialEq, Eq, Clone)]\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Output {\n    /// The status (exit code) of the process.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub status: ExitStatus,\n    /// The data that the process wrote to stdout.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdout: Vec<u8>,\n    /// The data that the process wrote to stderr.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stderr: Vec<u8>,\n}\n\n// If either stderr or stdout are valid utf8 strings it prints the valid\n// strings, otherwise it prints the byte sequence instead\n#[stable(feature = \"process_output_debug\", since = \"1.7.0\")]\nimpl fmt::Debug for Output {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let stdout_utf8 = str::from_utf8(&self.stdout);\n        let stdout_debug: &dyn fmt::Debug = match stdout_utf8 {\n            Ok(ref str) => str,\n            Err(_) => &self.stdout,\n        };\n\n        let stderr_utf8 = str::from_utf8(&self.stderr);\n        let stderr_debug: &dyn fmt::Debug = match stderr_utf8 {\n            Ok(ref str) => str,\n            Err(_) => &self.stderr,\n        };\n\n        fmt.debug_struct(\"Output\")\n            .field(\"status\", &self.status)\n            .field(\"stdout\", stdout_debug)\n            .field(\"stderr\", stderr_debug)\n            .finish()\n    }\n}\n\n/// Describes what to do with a standard I/O stream for a child process when\n/// passed to the [`stdin`], [`stdout`], and [`stderr`] methods of [`Command`].\n///\n/// [`stdin`]: Command::stdin\n/// [`stdout`]: Command::stdout\n/// [`stderr`]: Command::stderr\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Stdio(imp::Stdio);\n\nimpl Stdio {\n    /// A new pipe should be arranged to connect the parent and child processes.\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"Hello, world!\\n\");\n    /// // Nothing echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::io::Write;\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let mut child = Command::new(\"rev\")\n    ///     .stdin(Stdio::piped())\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"Failed to spawn child process\");\n    ///\n    /// let mut stdin = child.stdin.take().expect(\"Failed to open stdin\");\n    /// std::thread::spawn(move || {\n    ///     stdin.write_all(\"Hello, world!\".as_bytes()).expect(\"Failed to write to stdin\");\n    /// });\n    ///\n    /// let output = child.wait_with_output().expect(\"Failed to read stdout\");\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\");\n    /// ```\n    ///\n    /// Writing more than a pipe buffer's worth of input to stdin without also reading\n    /// stdout and stderr at the same time may cause a deadlock.\n    /// This is an issue when running any program that doesn't guarantee that it reads\n    /// its entire stdin before writing more than a pipe buffer's worth of output.\n    /// The size of a pipe buffer varies on different targets.\n    ///\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn piped() -> Stdio {\n        Stdio(imp::Stdio::MakePipe)\n    }\n\n    /// The child inherits from the corresponding parent descriptor.\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::inherit())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n    /// // \"Hello, world!\" echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    /// use std::io::{self, Write};\n    ///\n    /// let output = Command::new(\"rev\")\n    ///     .stdin(Stdio::inherit())\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// print!(\"You piped in the reverse of: \");\n    /// io::stdout().write_all(&output.stdout).unwrap();\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn inherit() -> Stdio {\n        Stdio(imp::Stdio::Inherit)\n    }\n\n    /// This stream will be ignored. This is the equivalent of attaching the\n    /// stream to `/dev/null`.\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::null())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n    /// // Nothing echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"rev\")\n    ///     .stdin(Stdio::null())\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n    /// // Ignores any piped-in input\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn null() -> Stdio {\n        Stdio(imp::Stdio::Null)\n    }\n}\n\nimpl FromInner<imp::Stdio> for Stdio {\n    fn from_inner(inner: imp::Stdio) -> Stdio {\n        Stdio(inner)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdio {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Stdio\").finish_non_exhaustive()\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From<ChildStdin> for Stdio {\n    /// Converts a `ChildStdin` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `ChildStdin` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// let _echo = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(reverse.stdin.unwrap()) // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// // \"!dlrow ,olleH\" echoed to console\n    /// ```\n    fn from(child: ChildStdin) -> Stdio {\n        Stdio::from_inner(child.into_inner().into())\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From<ChildStdout> for Stdio {\n    /// Converts a `ChildStdout` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `ChildStdout` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let hello = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(hello.stdout.unwrap())  // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\\n\");\n    /// ```\n    fn from(child: ChildStdout) -> Stdio {\n        Stdio::from_inner(child.into_inner().into())\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From<ChildStderr> for Stdio {\n    /// Converts a `ChildStderr` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .arg(\"non_existing_file.txt\")\n    ///     .stderr(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// let cat = Command::new(\"cat\")\n    ///     .arg(\"-\")\n    ///     .stdin(reverse.stderr.unwrap()) // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// assert_eq!(\n    ///     String::from_utf8_lossy(&cat.stdout),\n    ///     \"rev: cannot open non_existing_file.txt: No such file or directory\\n\"\n    /// );\n    /// ```\n    fn from(child: ChildStderr) -> Stdio {\n        Stdio::from_inner(child.into_inner().into())\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From<fs::File> for Stdio {\n    /// Converts a `File` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `File` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::fs::File;\n    /// use std::process::Command;\n    ///\n    /// // With the `foo.txt` file containing `Hello, world!\"\n    /// let file = File::open(\"foo.txt\").unwrap();\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(file)  // Implicit File conversion into a Stdio\n    ///     .output()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\");\n    /// ```\n    fn from(file: fs::File) -> Stdio {\n        Stdio::from_inner(file.into_inner().into())\n    }\n}\n\n/// Describes the result of a process after it has terminated.\n///\n/// This `struct` is used to represent the exit status or other termination of a child process.\n/// Child processes are created via the [`Command`] struct and their exit\n/// status is exposed through the [`status`] method, or the [`wait`] method\n/// of a [`Child`] process.\n///\n/// An `ExitStatus` represents every possible disposition of a process.  On Unix this\n/// is the **wait status**.  It is *not* simply an *exit status* (a value passed to `exit`).\n///\n/// For proper error reporting of failed processes, print the value of `ExitStatus` or\n/// `ExitStatusError` using their implementations of [`Display`](crate::fmt::Display).\n///\n/// [`status`]: Command::status\n/// [`wait`]: Child::wait\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ExitStatus(imp::ExitStatus);\n\n/// Allows extension traits within `std`.\n#[unstable(feature = \"sealed\", issue = \"none\")]\nimpl crate::sealed::Sealed for ExitStatus {}\n\nimpl ExitStatus {\n    /// Was termination successful?  Returns a `Result`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(exit_status_error)]\n    /// # if cfg!(unix) {\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"ls\")\n    ///                      .arg(\"/dev/nonexistent\")\n    ///                      .status()\n    ///                      .expect(\"ls could not be executed\");\n    ///\n    /// println!(\"ls: {}\", status);\n    /// status.exit_ok().expect_err(\"/dev/nonexistent could be listed!\");\n    /// # } // cfg!(unix)\n    /// ```\n    #[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n        self.0.exit_ok().map_err(ExitStatusError)\n    }\n\n    /// Was termination successful? Signal termination is not considered a\n    /// success, and success is defined as a zero exit status.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"mkdir\")\n    ///                      .arg(\"projects\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute mkdir\");\n    ///\n    /// if status.success() {\n    ///     println!(\"'projects/' directory created\");\n    /// } else {\n    ///     println!(\"failed to create 'projects/' directory: {}\", status);\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn success(&self) -> bool {\n        self.0.exit_ok().is_ok()\n    }\n\n    /// Returns the exit code of the process, if any.\n    ///\n    /// In Unix terms the return value is the **exit status**: the value passed to `exit`, if the\n    /// process finished by calling `exit`.  Note that on Unix the exit status is truncated to 8\n    /// bits, and that values that didn't come from a program's call to `exit` may be invented the\n    /// runtime system (often, for example, 255, 254, 127 or 126).\n    ///\n    /// On Unix, this will return `None` if the process was terminated by a signal.\n    /// [`ExitStatusExt`](crate::os::unix::process::ExitStatusExt) is an\n    /// extension trait for extracting any such signal, and other details, from the `ExitStatus`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"mkdir\")\n    ///                      .arg(\"projects\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute mkdir\");\n    ///\n    /// match status.code() {\n    ///     Some(code) => println!(\"Exited with status code: {}\", code),\n    ///     None       => println!(\"Process terminated by signal\")\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn code(&self) -> Option<i32> {\n        self.0.code()\n    }\n}\n\nimpl AsInner<imp::ExitStatus> for ExitStatus {\n    fn as_inner(&self) -> &imp::ExitStatus {\n        &self.0\n    }\n}\n\nimpl FromInner<imp::ExitStatus> for ExitStatus {\n    fn from_inner(s: imp::ExitStatus) -> ExitStatus {\n        ExitStatus(s)\n    }\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n/// Allows extension traits within `std`.\n#[unstable(feature = \"sealed\", issue = \"none\")]\nimpl crate::sealed::Sealed for ExitStatusError {}\n\n/// Describes the result of a process after it has failed\n///\n/// Produced by the [`.exit_ok`](ExitStatus::exit_ok) method on [`ExitStatus`].\n///\n/// # Examples\n///\n/// ```\n/// #![feature(exit_status_error)]\n/// # if cfg!(unix) {\n/// use std::process::{Command, ExitStatusError};\n///\n/// fn run(cmd: &str) -> Result<(),ExitStatusError> {\n///     Command::new(cmd).status().unwrap().exit_ok()?;\n///     Ok(())\n/// }\n///\n/// run(\"true\").unwrap();\n/// run(\"false\").unwrap_err();\n/// # } // cfg!(unix)\n/// ```\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n// The definition of imp::ExitStatusError should ideally be such that\n// Result<(), imp::ExitStatusError> has an identical representation to imp::ExitStatus.\npub struct ExitStatusError(imp::ExitStatusError);\n\n#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\nimpl ExitStatusError {\n    /// Reports the exit code, if applicable, from an `ExitStatusError`.\n    ///\n    /// In Unix terms the return value is the **exit status**: the value passed to `exit`, if the\n    /// process finished by calling `exit`.  Note that on Unix the exit status is truncated to 8\n    /// bits, and that values that didn't come from a program's call to `exit` may be invented by the\n    /// runtime system (often, for example, 255, 254, 127 or 126).\n    ///\n    /// On Unix, this will return `None` if the process was terminated by a signal.  If you want to\n    /// handle such situations specially, consider using methods from\n    /// [`ExitStatusExt`](crate::os::unix::process::ExitStatusExt).\n    ///\n    /// If the process finished by calling `exit` with a nonzero value, this will return\n    /// that exit status.\n    ///\n    /// If the error was something else, it will return `None`.\n    ///\n    /// If the process exited successfully (ie, by calling `exit(0)`), there is no\n    /// `ExitStatusError`.  So the return value from `ExitStatusError::code()` is always nonzero.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(exit_status_error)]\n    /// # #[cfg(unix)] {\n    /// use std::process::Command;\n    ///\n    /// let bad = Command::new(\"false\").status().unwrap().exit_ok().unwrap_err();\n    /// assert_eq!(bad.code(), Some(1));\n    /// # } // #[cfg(unix)]\n    /// ```\n    pub fn code(&self) -> Option<i32> {\n        self.code_nonzero().map(Into::into)\n    }\n\n    /// Reports the exit code, if applicable, from an `ExitStatusError`, as a `NonZero`\n    ///\n    /// This is exaclty like [`code()`](Self::code), except that it returns a `NonZeroI32`.\n    ///\n    /// Plain `code`, returning a plain integer, is provided because is is often more convenient.\n    /// The returned value from `code()` is indeed also nonzero; use `code_nonzero()` when you want\n    /// a type-level guarantee of nonzeroness.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(exit_status_error)]\n    /// # if cfg!(unix) {\n    /// use std::convert::TryFrom;\n    /// use std::num::NonZeroI32;\n    /// use std::process::Command;\n    ///\n    /// let bad = Command::new(\"false\").status().unwrap().exit_ok().unwrap_err();\n    /// assert_eq!(bad.code_nonzero().unwrap(), NonZeroI32::try_from(1).unwrap());\n    /// # } // cfg!(unix)\n    /// ```\n    pub fn code_nonzero(&self) -> Option<NonZeroI32> {\n        self.0.code()\n    }\n\n    /// Converts an `ExitStatusError` (back) to an `ExitStatus`.\n    pub fn into_status(&self) -> ExitStatus {\n        ExitStatus(self.0.into())\n    }\n}\n\n#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\nimpl Into<ExitStatus> for ExitStatusError {\n    fn into(self) -> ExitStatus {\n        ExitStatus(self.0.into())\n    }\n}\n\n#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\nimpl fmt::Display for ExitStatusError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"process exited unsuccessfully: {}\", self.into_status())\n    }\n}\n\n#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\nimpl crate::error::Error for ExitStatusError {}\n\n/// This type represents the status code a process can return to its\n/// parent under normal termination.\n///\n/// Numeric values used in this type don't have portable meanings, and\n/// different platforms may mask different amounts of them.\n///\n/// For the platform's canonical successful and unsuccessful codes, see\n/// the [`SUCCESS`] and [`FAILURE`] associated items.\n///\n/// [`SUCCESS`]: ExitCode::SUCCESS\n/// [`FAILURE`]: ExitCode::FAILURE\n///\n/// **Warning**: While various forms of this were discussed in [RFC #1937],\n/// it was ultimately cut from that RFC, and thus this type is more subject\n/// to change even than the usual unstable item churn.\n///\n/// [RFC #1937]: https://github.com/rust-lang/rfcs/pull/1937\n#[derive(Clone, Copy, Debug)]\n#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\npub struct ExitCode(imp::ExitCode);\n\n#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\nimpl ExitCode {\n    /// The canonical ExitCode for successful termination on this platform.\n    ///\n    /// Note that a `()`-returning `main` implicitly results in a successful\n    /// termination, so there's no need to return this from `main` unless\n    /// you're also returning other possible codes.\n    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n    pub const SUCCESS: ExitCode = ExitCode(imp::ExitCode::SUCCESS);\n\n    /// The canonical ExitCode for unsuccessful termination on this platform.\n    ///\n    /// If you're only returning this and `SUCCESS` from `main`, consider\n    /// instead returning `Err(_)` and `Ok(())` respectively, which will\n    /// return the same codes (but will also `eprintln!` the error).\n    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n    pub const FAILURE: ExitCode = ExitCode(imp::ExitCode::FAILURE);\n}\n\nimpl Child {\n    /// Forces the child process to exit. If the child has already exited, an [`InvalidInput`]\n    /// error is returned.\n    ///\n    /// The mapping to [`ErrorKind`]s is not part of the compatibility contract of the function,\n    /// especially the [`Other`] kind might change to more specific kinds in the future.\n    ///\n    /// This is equivalent to sending a SIGKILL on Unix platforms.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"yes\");\n    /// if let Ok(mut child) = command.spawn() {\n    ///     child.kill().expect(\"command wasn't running\");\n    /// } else {\n    ///     println!(\"yes command didn't start\");\n    /// }\n    /// ```\n    ///\n    /// [`ErrorKind`]: io::ErrorKind\n    /// [`InvalidInput`]: io::ErrorKind::InvalidInput\n    /// [`Other`]: io::ErrorKind::Other\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn kill(&mut self) -> io::Result<()> {\n        self.handle.kill()\n    }\n\n    /// Returns the OS-assigned process identifier associated with this child.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"ls\");\n    /// if let Ok(child) = command.spawn() {\n    ///     println!(\"Child's ID is {}\", child.id());\n    /// } else {\n    ///     println!(\"ls command didn't start\");\n    /// }\n    /// ```\n    #[stable(feature = \"process_id\", since = \"1.3.0\")]\n    pub fn id(&self) -> u32 {\n        self.handle.id()\n    }\n\n    /// Waits for the child to exit completely, returning the status that it\n    /// exited with. This function will continue to have the same return value\n    /// after it has been called at least once.\n    ///\n    /// The stdin handle to the child process, if any, will be closed\n    /// before waiting. This helps avoid deadlock: it ensures that the\n    /// child does not block waiting for input from the parent, while\n    /// the parent waits for the child to exit.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"ls\");\n    /// if let Ok(mut child) = command.spawn() {\n    ///     child.wait().expect(\"command wasn't running\");\n    ///     println!(\"Child has finished its execution!\");\n    /// } else {\n    ///     println!(\"ls command didn't start\");\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        drop(self.stdin.take());\n        self.handle.wait().map(ExitStatus)\n    }\n\n    /// Attempts to collect the exit status of the child if it has already\n    /// exited.\n    ///\n    /// This function will not block the calling thread and will only\n    /// check to see if the child process has exited or not. If the child has\n    /// exited then on Unix the process ID is reaped. This function is\n    /// guaranteed to repeatedly return a successful exit status so long as the\n    /// child has already exited.\n    ///\n    /// If the child has exited, then `Ok(Some(status))` is returned. If the\n    /// exit status is not available at this time then `Ok(None)` is returned.\n    /// If an error occurs, then that error is returned.\n    ///\n    /// Note that unlike `wait`, this function will not attempt to drop stdin.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut child = Command::new(\"ls\").spawn().unwrap();\n    ///\n    /// match child.try_wait() {\n    ///     Ok(Some(status)) => println!(\"exited with: {}\", status),\n    ///     Ok(None) => {\n    ///         println!(\"status not ready yet, let's really wait\");\n    ///         let res = child.wait();\n    ///         println!(\"result: {:?}\", res);\n    ///     }\n    ///     Err(e) => println!(\"error attempting to wait: {}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"process_try_wait\", since = \"1.18.0\")]\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        Ok(self.handle.try_wait()?.map(ExitStatus))\n    }\n\n    /// Simultaneously waits for the child to exit and collect all remaining\n    /// output on the stdout/stderr handles, returning an `Output`\n    /// instance.\n    ///\n    /// The stdin handle to the child process, if any, will be closed\n    /// before waiting. This helps avoid deadlock: it ensures that the\n    /// child does not block waiting for input from the parent, while\n    /// the parent waits for the child to exit.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    /// In order to capture the output into this `Result<Output>` it is\n    /// necessary to create new pipes between parent and child. Use\n    /// `stdout(Stdio::piped())` or `stderr(Stdio::piped())`, respectively.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let child = Command::new(\"/bin/cat\")\n    ///     .arg(\"file.txt\")\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed to execute child\");\n    ///\n    /// let output = child\n    ///     .wait_with_output()\n    ///     .expect(\"failed to wait on child\");\n    ///\n    /// assert!(output.status.success());\n    /// ```\n    ///\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn wait_with_output(mut self) -> io::Result<Output> {\n        drop(self.stdin.take());\n\n        let (mut stdout, mut stderr) = (Vec::new(), Vec::new());\n        match (self.stdout.take(), self.stderr.take()) {\n            (None, None) => {}\n            (Some(mut out), None) => {\n                let res = out.read_to_end(&mut stdout);\n                res.unwrap();\n            }\n            (None, Some(mut err)) => {\n                let res = err.read_to_end(&mut stderr);\n                res.unwrap();\n            }\n            (Some(out), Some(err)) => {\n                let res = read2(out.inner, &mut stdout, err.inner, &mut stderr);\n                res.unwrap();\n            }\n        }\n\n        let status = self.wait()?;\n        Ok(Output { status, stdout, stderr })\n    }\n}\n\n/// Terminates the current process with the specified exit code.\n///\n/// This function will never return and will immediately terminate the current\n/// process. The exit code is passed through to the underlying OS and will be\n/// available for consumption by another process.\n///\n/// Note that because this function never returns, and that it terminates the\n/// process, no destructors on the current stack or any other thread's stack\n/// will be run. If a clean shutdown is needed it is recommended to only call\n/// this function at a known point where there are no more destructors left\n/// to run.\n///\n/// ## Platform-specific behavior\n///\n/// **Unix**: On Unix-like platforms, it is unlikely that all 32 bits of `exit`\n/// will be visible to a parent process inspecting the exit code. On most\n/// Unix-like platforms, only the eight least-significant bits are considered.\n///\n/// # Examples\n///\n/// Due to this functions behavior regarding destructors, a conventional way\n/// to use the function is to extract the actual computation to another\n/// function and compute the exit code from its return value:\n///\n/// ```\n/// fn run_app() -> Result<(), ()> {\n///     // Application logic here\n///     Ok(())\n/// }\n///\n/// fn main() {\n///     std::process::exit(match run_app() {\n///         Ok(_) => 0,\n///         Err(err) => {\n///             eprintln!(\"error: {:?}\", err);\n///             1\n///         }\n///     });\n/// }\n/// ```\n///\n/// Due to [platform-specific behavior], the exit code for this example will be\n/// `0` on Linux, but `256` on Windows:\n///\n/// ```no_run\n/// use std::process;\n///\n/// process::exit(0x0100);\n/// ```\n///\n/// [platform-specific behavior]: #platform-specific-behavior\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn exit(code: i32) -> ! {\n    crate::sys_common::rt::cleanup();\n    crate::sys::os::exit(code)\n}\n\n/// Terminates the process in an abnormal fashion.\n///\n/// The function will never return and will immediately terminate the current\n/// process in a platform specific \"abnormal\" manner.\n///\n/// Note that because this function never returns, and that it terminates the\n/// process, no destructors on the current stack or any other thread's stack\n/// will be run.\n///\n/// This is in contrast to the default behaviour of [`panic!`] which unwinds\n/// the current thread's stack and calls all destructors.\n/// When `panic=\"abort\"` is set, either as an argument to `rustc` or in a\n/// crate's Cargo.toml, [`panic!`] and `abort` are similar. However,\n/// [`panic!`] will still call the [panic hook] while `abort` will not.\n///\n/// If a clean shutdown is needed it is recommended to only call\n/// this function at a known point where there are no more destructors left\n/// to run.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::process;\n///\n/// fn main() {\n///     println!(\"aborting\");\n///\n///     process::abort();\n///\n///     // execution never gets here\n/// }\n/// ```\n///\n/// The `abort` function terminates the process, so the destructor will not\n/// get run on the example below:\n///\n/// ```no_run\n/// use std::process;\n///\n/// struct HasDrop;\n///\n/// impl Drop for HasDrop {\n///     fn drop(&mut self) {\n///         println!(\"This will never be printed!\");\n///     }\n/// }\n///\n/// fn main() {\n///     let _x = HasDrop;\n///     process::abort();\n///     // the destructor implemented for HasDrop will never get run\n/// }\n/// ```\n///\n/// [panic hook]: crate::panic::set_hook\n#[stable(feature = \"process_abort\", since = \"1.17.0\")]\n#[cold]\npub fn abort() -> ! {\n    crate::sys::abort_internal();\n}\n\n/// Returns the OS-assigned process identifier associated with this process.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```no_run\n/// use std::process;\n///\n/// println!(\"My pid is {}\", process::id());\n/// ```\n///\n///\n#[stable(feature = \"getpid\", since = \"1.26.0\")]\npub fn id() -> u32 {\n    crate::sys::os::getpid()\n}\n\n/// A trait for implementing arbitrary return types in the `main` function.\n///\n/// The C-main function only supports to return integers as return type.\n/// So, every type implementing the `Termination` trait has to be converted\n/// to an integer.\n///\n/// The default implementations are returning `libc::EXIT_SUCCESS` to indicate\n/// a successful execution. In case of a failure, `libc::EXIT_FAILURE` is returned.\n#[cfg_attr(not(test), lang = \"termination\")]\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n#[rustc_on_unimplemented(\n    message = \"`main` has invalid return type `{Self}`\",\n    label = \"`main` can only return types that implement `{Termination}`\"\n)]\npub trait Termination {\n    /// Is called to get the representation of the value as status code.\n    /// This status code is returned to the operating system.\n    fn report(self) -> i32;\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for () {\n    #[inline]\n    fn report(self) -> i32 {\n        ExitCode::SUCCESS.report()\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl<E: fmt::Debug> Termination for Result<(), E> {\n    fn report(self) -> i32 {\n        match self {\n            Ok(()) => ().report(),\n            Err(err) => Err::<!, _>(err).report(),\n        }\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for ! {\n    fn report(self) -> i32 {\n        self\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl<E: fmt::Debug> Termination for Result<!, E> {\n    fn report(self) -> i32 {\n        let Err(err) = self;\n        eprintln!(\"Error: {:?}\", err);\n        ExitCode::FAILURE.report()\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for ExitCode {\n    #[inline]\n    fn report(self) -> i32 {\n        self.0.as_i32()\n    }\n}\n"],["2593","use super::*;\nuse crate::sys_common::{AsInner, IntoInner};\n\nuse crate::rc::Rc;\nuse crate::sync::Arc;\n\n#[test]\nfn test_os_string_with_capacity() {\n    let os_string = OsString::with_capacity(0);\n    assert_eq!(0, os_string.inner.into_inner().capacity());\n\n    let os_string = OsString::with_capacity(10);\n    assert_eq!(10, os_string.inner.into_inner().capacity());\n\n    let mut os_string = OsString::with_capacity(0);\n    os_string.push(\"abc\");\n    assert!(os_string.inner.into_inner().capacity() >= 3);\n}\n\n#[test]\nfn test_os_string_clear() {\n    let mut os_string = OsString::from(\"abc\");\n    assert_eq!(3, os_string.inner.as_inner().len());\n\n    os_string.clear();\n    assert_eq!(&os_string, \"\");\n    assert_eq!(0, os_string.inner.as_inner().len());\n}\n\n#[test]\nfn test_os_string_capacity() {\n    let os_string = OsString::with_capacity(0);\n    assert_eq!(0, os_string.capacity());\n\n    let os_string = OsString::with_capacity(10);\n    assert_eq!(10, os_string.capacity());\n\n    let mut os_string = OsString::with_capacity(0);\n    os_string.push(\"abc\");\n    assert!(os_string.capacity() >= 3);\n}\n\n#[test]\nfn test_os_string_reserve() {\n    let mut os_string = OsString::new();\n    assert_eq!(os_string.capacity(), 0);\n\n    os_string.reserve(2);\n    assert!(os_string.capacity() >= 2);\n\n    for _ in 0..16 {\n        os_string.push(\"a\");\n    }\n\n    assert!(os_string.capacity() >= 16);\n    os_string.reserve(16);\n    assert!(os_string.capacity() >= 32);\n\n    os_string.push(\"a\");\n\n    os_string.reserve(16);\n    assert!(os_string.capacity() >= 33)\n}\n\n#[test]\nfn test_os_string_reserve_exact() {\n    let mut os_string = OsString::new();\n    assert_eq!(os_string.capacity(), 0);\n\n    os_string.reserve_exact(2);\n    assert!(os_string.capacity() >= 2);\n\n    for _ in 0..16 {\n        os_string.push(\"a\");\n    }\n\n    assert!(os_string.capacity() >= 16);\n    os_string.reserve_exact(16);\n    assert!(os_string.capacity() >= 32);\n\n    os_string.push(\"a\");\n\n    os_string.reserve_exact(16);\n    assert!(os_string.capacity() >= 33)\n}\n\n#[test]\nfn test_os_string_default() {\n    let os_string: OsString = Default::default();\n    assert_eq!(\"\", &os_string);\n}\n\n#[test]\nfn test_os_str_is_empty() {\n    let mut os_string = OsString::new();\n    assert!(os_string.is_empty());\n\n    os_string.push(\"abc\");\n    assert!(!os_string.is_empty());\n\n    os_string.clear();\n    assert!(os_string.is_empty());\n}\n\n#[test]\nfn test_os_str_len() {\n    let mut os_string = OsString::new();\n    assert_eq!(0, os_string.len());\n\n    os_string.push(\"abc\");\n    assert_eq!(3, os_string.len());\n\n    os_string.clear();\n    assert_eq!(0, os_string.len());\n}\n\n#[test]\nfn test_os_str_default() {\n    let os_str: &OsStr = Default::default();\n    assert_eq!(\"\", os_str);\n}\n\n#[test]\nfn into_boxed() {\n    let orig = \"Hello, world!\";\n    let os_str = OsStr::new(orig);\n    let boxed: Box<OsStr> = Box::from(os_str);\n    let os_string = os_str.to_owned().into_boxed_os_str().into_os_string();\n    assert_eq!(os_str, &*boxed);\n    assert_eq!(&*boxed, &*os_string);\n    assert_eq!(&*os_string, os_str);\n}\n\n#[test]\nfn boxed_default() {\n    let boxed = <Box<OsStr>>::default();\n    assert!(boxed.is_empty());\n}\n\n#[test]\nfn test_os_str_clone_into() {\n    let mut os_string = OsString::with_capacity(123);\n    os_string.push(\"hello\");\n    let os_str = OsStr::new(\"bonjour\");\n    os_str.clone_into(&mut os_string);\n    assert_eq!(os_str, os_string);\n    assert!(os_string.capacity() >= 123);\n}\n\n#[test]\nfn into_rc() {\n    let orig = \"Hello, world!\";\n    let os_str = OsStr::new(orig);\n    let rc: Rc<OsStr> = Rc::from(os_str);\n    let arc: Arc<OsStr> = Arc::from(os_str);\n\n    assert_eq!(&*rc, os_str);\n    assert_eq!(&*arc, os_str);\n\n    let rc2: Rc<OsStr> = Rc::from(os_str.to_owned());\n    let arc2: Arc<OsStr> = Arc::from(os_str.to_owned());\n\n    assert_eq!(&*rc2, os_str);\n    assert_eq!(&*arc2, os_str);\n}\n"],["2594","//! Utilities related to FFI bindings.\n//!\n//! This module provides utilities to handle data across non-Rust\n//! interfaces, like other programming languages and the underlying\n//! operating system. It is mainly of use for FFI (Foreign Function\n//! Interface) bindings and code that needs to exchange C-like strings\n//! with other languages.\n//!\n//! # Overview\n//!\n//! Rust represents owned strings with the [`String`] type, and\n//! borrowed slices of strings with the [`str`] primitive. Both are\n//! always in UTF-8 encoding, and may contain nul bytes in the middle,\n//! i.e., if you look at the bytes that make up the string, there may\n//! be a `\\0` among them. Both `String` and `str` store their length\n//! explicitly; there are no nul terminators at the end of strings\n//! like in C.\n//!\n//! C strings are different from Rust strings:\n//!\n//! * **Encodings** - Rust strings are UTF-8, but C strings may use\n//! other encodings. If you are using a string from C, you should\n//! check its encoding explicitly, rather than just assuming that it\n//! is UTF-8 like you can do in Rust.\n//!\n//! * **Character size** - C strings may use `char` or `wchar_t`-sized\n//! characters; please **note** that C's `char` is different from Rust's.\n//! The C standard leaves the actual sizes of those types open to\n//! interpretation, but defines different APIs for strings made up of\n//! each character type. Rust strings are always UTF-8, so different\n//! Unicode characters will be encoded in a variable number of bytes\n//! each. The Rust type [`char`] represents a '[Unicode scalar\n//! value]', which is similar to, but not the same as, a '[Unicode\n//! code point]'.\n//!\n//! * **Nul terminators and implicit string lengths** - Often, C\n//! strings are nul-terminated, i.e., they have a `\\0` character at the\n//! end. The length of a string buffer is not stored, but has to be\n//! calculated; to compute the length of a string, C code must\n//! manually call a function like `strlen()` for `char`-based strings,\n//! or `wcslen()` for `wchar_t`-based ones. Those functions return\n//! the number of characters in the string excluding the nul\n//! terminator, so the buffer length is really `len+1` characters.\n//! Rust strings don't have a nul terminator; their length is always\n//! stored and does not need to be calculated. While in Rust\n//! accessing a string's length is a `O(1)` operation (because the\n//! length is stored); in C it is an `O(length)` operation because the\n//! length needs to be computed by scanning the string for the nul\n//! terminator.\n//!\n//! * **Internal nul characters** - When C strings have a nul\n//! terminator character, this usually means that they cannot have nul\n//! characters in the middle  a nul character would essentially\n//! truncate the string. Rust strings *can* have nul characters in\n//! the middle, because nul does not have to mark the end of the\n//! string in Rust.\n//!\n//! # Representations of non-Rust strings\n//!\n//! [`CString`] and [`CStr`] are useful when you need to transfer\n//! UTF-8 strings to and from languages with a C ABI, like Python.\n//!\n//! * **From Rust to C:** [`CString`] represents an owned, C-friendly\n//! string: it is nul-terminated, and has no internal nul characters.\n//! Rust code can create a [`CString`] out of a normal string (provided\n//! that the string doesn't have nul characters in the middle), and\n//! then use a variety of methods to obtain a raw `*mut `[`u8`] that can\n//! then be passed as an argument to functions which use the C\n//! conventions for strings.\n//!\n//! * **From C to Rust:** [`CStr`] represents a borrowed C string; it\n//! is what you would use to wrap a raw `*const `[`u8`] that you got from\n//! a C function. A [`CStr`] is guaranteed to be a nul-terminated array\n//! of bytes. Once you have a [`CStr`], you can convert it to a Rust\n//! [`&str`][`str`] if it's valid UTF-8, or lossily convert it by adding\n//! replacement characters.\n//!\n//! [`OsString`] and [`OsStr`] are useful when you need to transfer\n//! strings to and from the operating system itself, or when capturing\n//! the output of external commands. Conversions between [`OsString`],\n//! [`OsStr`] and Rust strings work similarly to those for [`CString`]\n//! and [`CStr`].\n//!\n//! * [`OsString`] represents an owned string in whatever\n//! representation the operating system prefers. In the Rust standard\n//! library, various APIs that transfer strings to/from the operating\n//! system use [`OsString`] instead of plain strings. For example,\n//! [`env::var_os()`] is used to query environment variables; it\n//! returns an [`Option`]`<`[`OsString`]`>`. If the environment variable\n//! exists you will get a [`Some`]`(os_string)`, which you can *then* try to\n//! convert to a Rust string. This yields a [`Result`], so that\n//! your code can detect errors in case the environment variable did\n//! not in fact contain valid Unicode data.\n//!\n//! * [`OsStr`] represents a borrowed reference to a string in a\n//! format that can be passed to the operating system. It can be\n//! converted into an UTF-8 Rust string slice in a similar way to\n//! [`OsString`].\n//!\n//! # Conversions\n//!\n//! ## On Unix\n//!\n//! On Unix, [`OsStr`] implements the\n//! `std::os::unix::ffi::`[`OsStrExt`][unix.OsStrExt] trait, which\n//! augments it with two methods, [`from_bytes`] and [`as_bytes`].\n//! These do inexpensive conversions from and to UTF-8 byte slices.\n//!\n//! Additionally, on Unix [`OsString`] implements the\n//! `std::os::unix::ffi::`[`OsStringExt`][unix.OsStringExt] trait,\n//! which provides [`from_vec`] and [`into_vec`] methods that consume\n//! their arguments, and take or produce vectors of [`u8`].\n//!\n//! ## On Windows\n//!\n//! On Windows, [`OsStr`] implements the\n//! `std::os::windows::ffi::`[`OsStrExt`][windows.OsStrExt] trait,\n//! which provides an [`encode_wide`] method. This provides an\n//! iterator that can be [`collect`]ed into a vector of [`u16`].\n//!\n//! Additionally, on Windows [`OsString`] implements the\n//! `std::os::windows:ffi::`[`OsStringExt`][windows.OsStringExt]\n//! trait, which provides a [`from_wide`] method. The result of this\n//! method is an [`OsString`] which can be round-tripped to a Windows\n//! string losslessly.\n//!\n//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n//! [`env::set_var()`]: crate::env::set_var\n//! [`env::var_os()`]: crate::env::var_os\n//! [unix.OsStringExt]: crate::os::unix::ffi::OsStringExt\n//! [`from_vec`]: crate::os::unix::ffi::OsStringExt::from_vec\n//! [`into_vec`]: crate::os::unix::ffi::OsStringExt::into_vec\n//! [unix.OsStrExt]: crate::os::unix::ffi::OsStrExt\n//! [`from_bytes`]: crate::os::unix::ffi::OsStrExt::from_bytes\n//! [`as_bytes`]: crate::os::unix::ffi::OsStrExt::as_bytes\n//! [`OsStrExt`]: crate::os::unix::ffi::OsStrExt\n//! [windows.OsStrExt]: crate::os::windows::ffi::OsStrExt\n//! [`encode_wide`]: crate::os::windows::ffi::OsStrExt::encode_wide\n//! [`collect`]: crate::iter::Iterator::collect\n//! [windows.OsStringExt]: crate::os::windows::ffi::OsStringExt\n//! [`from_wide`]: crate::os::windows::ffi::OsStringExt::from_wide\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\npub use self::c_str::FromBytesWithNulError;\n#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\npub use self::c_str::FromVecWithNulError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::c_str::{CStr, CString, IntoStringError, NulError};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::os_str::{OsStr, OsString};\n\n#[stable(feature = \"core_c_void\", since = \"1.30.0\")]\npub use core::ffi::c_void;\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\npub use core::ffi::{VaList, VaListImpl};\n\nmod c_str;\nmod os_str;\n"],["2595","#[cfg(test)]\nmod tests;\n\nuse crate::borrow::{Borrow, Cow};\nuse crate::cmp;\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\nuse crate::iter::{Extend, FromIterator};\nuse crate::ops;\nuse crate::rc::Rc;\nuse crate::str::FromStr;\nuse crate::sync::Arc;\n\nuse crate::sys::os_str::{Buf, Slice};\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\n\n/// A type that can represent owned, mutable platform-native strings, but is\n/// cheaply inter-convertible with Rust strings.\n///\n/// The need for this type arises from the fact that:\n///\n/// * On Unix systems, strings are often arbitrary sequences of non-zero\n///   bytes, in many cases interpreted as UTF-8.\n///\n/// * On Windows, strings are often arbitrary sequences of non-zero 16-bit\n///   values, interpreted as UTF-16 when it is valid to do so.\n///\n/// * In Rust, strings are always valid UTF-8, which may contain zeros.\n///\n/// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust\n/// and platform-native string values, and in particular allowing a Rust string\n/// to be converted into an \"OS\" string with no cost if possible. A consequence\n/// of this is that `OsString` instances are *not* `NUL` terminated; in order\n/// to pass to e.g., Unix system call, you should create a [`CStr`].\n///\n/// `OsString` is to [`&OsStr`] as [`String`] is to [`&str`]: the former\n/// in each pair are owned strings; the latter are borrowed\n/// references.\n///\n/// Note, `OsString` and [`OsStr`] internally do not necessarily hold strings in\n/// the form native to the platform; While on Unix, strings are stored as a\n/// sequence of 8-bit values, on Windows, where strings are 16-bit value based\n/// as just discussed, strings are also actually stored as a sequence of 8-bit\n/// values, encoded in a less-strict variant of UTF-8. This is useful to\n/// understand when handling capacity and length values.\n///\n/// # Creating an `OsString`\n///\n/// **From a Rust string**: `OsString` implements\n/// [`From`]`<`[`String`]`>`, so you can use `my_string.from` to\n/// create an `OsString` from a normal Rust string.\n///\n/// **From slices:** Just like you can start with an empty Rust\n/// [`String`] and then [`String::push_str`] `&str`\n/// sub-string slices into it, you can create an empty `OsString` with\n/// the [`OsString::new`] method and then push string slices into it with the\n/// [`OsString::push`] method.\n///\n/// # Extracting a borrowed reference to the whole OS string\n///\n/// You can use the [`OsString::as_os_str`] method to get an `&`[`OsStr`] from\n/// an `OsString`; this is effectively a borrowed reference to the\n/// whole string.\n///\n/// # Conversions\n///\n/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n/// the traits which `OsString` implements for [conversions] from/to native representations.\n///\n/// [`&OsStr`]: OsStr\n/// [`&str`]: str\n/// [`CStr`]: crate::ffi::CStr\n/// [conversions]: super#conversions\n#[cfg_attr(not(test), rustc_diagnostic_item = \"OsString\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OsString {\n    inner: Buf,\n}\n\n/// Allows extension traits within `std`.\n#[unstable(feature = \"sealed\", issue = \"none\")]\nimpl crate::sealed::Sealed for OsString {}\n\n/// Borrowed reference to an OS string (see [`OsString`]).\n///\n/// This type represents a borrowed reference to a string in the operating system's preferred\n/// representation.\n///\n/// `&OsStr` is to [`OsString`] as [`&str`] is to [`String`]: the former in each pair are borrowed\n/// references; the latter are owned strings.\n///\n/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n/// the traits which `OsStr` implements for [conversions] from/to native representations.\n///\n/// [`&str`]: str\n/// [conversions]: super#conversions\n#[cfg_attr(not(test), rustc_diagnostic_item = \"OsStr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME:\n// `OsStr::from_inner` current implementation relies\n// on `OsStr` being layout-compatible with `Slice`.\n// When attribute privacy is implemented, `OsStr` should be annotated as `#[repr(transparent)]`.\n// Anyway, `OsStr` representation and layout are considered implementation details, are\n// not documented and must not be relied upon.\npub struct OsStr {\n    inner: Slice,\n}\n\n/// Allows extension traits within `std`.\n#[unstable(feature = \"sealed\", issue = \"none\")]\nimpl crate::sealed::Sealed for OsStr {}\n\nimpl OsString {\n    /// Constructs a new empty `OsString`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let os_string = OsString::new();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn new() -> OsString {\n        OsString { inner: Buf::from_string(String::new()) }\n    }\n\n    /// Converts to an [`OsStr`] slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{OsString, OsStr};\n    ///\n    /// let os_string = OsString::from(\"foo\");\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_string.as_os_str(), os_str);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_os_str(&self) -> &OsStr {\n        self\n    }\n\n    /// Converts the `OsString` into a [`String`] if it contains valid Unicode data.\n    ///\n    /// On failure, ownership of the original `OsString` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let os_string = OsString::from(\"foo\");\n    /// let string = os_string.into_string();\n    /// assert_eq!(string, Ok(String::from(\"foo\")));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn into_string(self) -> Result<String, OsString> {\n        self.inner.into_string().map_err(|buf| OsString { inner: buf })\n    }\n\n    /// Extends the string with the given [`&OsStr`] slice.\n    ///\n    /// [`&OsStr`]: OsStr\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::from(\"foo\");\n    /// os_string.push(\"bar\");\n    /// assert_eq!(&os_string, \"foobar\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n        self.inner.push_slice(&s.as_ref().inner)\n    }\n\n    /// Creates a new `OsString` with the given capacity.\n    ///\n    /// The string will be able to hold exactly `capacity` length units of other\n    /// OS strings without reallocating. If `capacity` is 0, the string will not\n    /// allocate.\n    ///\n    /// See main `OsString` documentation information about encoding.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::with_capacity(10);\n    /// let capacity = os_string.capacity();\n    ///\n    /// // This push is done without reallocating\n    /// os_string.push(\"foo\");\n    ///\n    /// assert_eq!(capacity, os_string.capacity());\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> OsString {\n        OsString { inner: Buf::with_capacity(capacity) }\n    }\n\n    /// Truncates the `OsString` to zero length.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::from(\"foo\");\n    /// assert_eq!(&os_string, \"foo\");\n    ///\n    /// os_string.clear();\n    /// assert_eq!(&os_string, \"\");\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    #[inline]\n    pub fn clear(&mut self) {\n        self.inner.clear()\n    }\n\n    /// Returns the capacity this `OsString` can hold without reallocating.\n    ///\n    /// See `OsString` introduction for information about encoding.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let os_string = OsString::with_capacity(10);\n    /// assert!(os_string.capacity() >= 10);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        self.inner.capacity()\n    }\n\n    /// Reserves capacity for at least `additional` more capacity to be inserted\n    /// in the given `OsString`.\n    ///\n    /// The collection may reserve more space to avoid frequent reallocations.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::new();\n    /// s.reserve(10);\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n        self.inner.reserve(additional)\n    }\n\n    /// Reserves the minimum capacity for exactly `additional` more capacity to\n    /// be inserted in the given `OsString`. Does nothing if the capacity is\n    /// already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore, capacity can not be relied upon to be precisely\n    /// minimal. Prefer reserve if future insertions are expected.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::new();\n    /// s.reserve_exact(10);\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    #[inline]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.inner.reserve_exact(additional)\n    }\n\n    /// Shrinks the capacity of the `OsString` to match its length.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::from(\"foo\");\n    ///\n    /// s.reserve(100);\n    /// assert!(s.capacity() >= 100);\n    ///\n    /// s.shrink_to_fit();\n    /// assert_eq!(3, s.capacity());\n    /// ```\n    #[stable(feature = \"osstring_shrink_to_fit\", since = \"1.19.0\")]\n    #[inline]\n    pub fn shrink_to_fit(&mut self) {\n        self.inner.shrink_to_fit()\n    }\n\n    /// Shrinks the capacity of the `OsString` with a lower bound.\n    ///\n    /// The capacity will remain at least as large as both the length\n    /// and the supplied value.\n    ///\n    /// If the current capacity is less than the lower limit, this is a no-op.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::from(\"foo\");\n    ///\n    /// s.reserve(100);\n    /// assert!(s.capacity() >= 100);\n    ///\n    /// s.shrink_to(10);\n    /// assert!(s.capacity() >= 10);\n    /// s.shrink_to(0);\n    /// assert!(s.capacity() >= 3);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.inner.shrink_to(min_capacity)\n    }\n\n    /// Converts this `OsString` into a boxed [`OsStr`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{OsString, OsStr};\n    ///\n    /// let s = OsString::from(\"hello\");\n    ///\n    /// let b: Box<OsStr> = s.into_boxed_os_str();\n    /// ```\n    #[stable(feature = \"into_boxed_os_str\", since = \"1.20.0\")]\n    pub fn into_boxed_os_str(self) -> Box<OsStr> {\n        let rw = Box::into_raw(self.inner.into_box()) as *mut OsStr;\n        unsafe { Box::from_raw(rw) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<String> for OsString {\n    /// Converts a [`String`] into a [`OsString`].\n    ///\n    /// This conversion does not allocate or copy memory.\n    #[inline]\n    fn from(s: String) -> OsString {\n        OsString { inner: Buf::from_string(s) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + AsRef<OsStr>> From<&T> for OsString {\n    fn from(s: &T) -> OsString {\n        s.as_ref().to_os_string()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeFull> for OsString {\n    type Output = OsStr;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &OsStr {\n        OsStr::from_inner(self.inner.as_slice())\n    }\n}\n\n#[stable(feature = \"mut_osstr\", since = \"1.44.0\")]\nimpl ops::IndexMut<ops::RangeFull> for OsString {\n    #[inline]\n    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut OsStr {\n        OsStr::from_inner_mut(self.inner.as_mut_slice())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for OsString {\n    type Target = OsStr;\n\n    #[inline]\n    fn deref(&self) -> &OsStr {\n        &self[..]\n    }\n}\n\n#[stable(feature = \"mut_osstr\", since = \"1.44.0\")]\nimpl ops::DerefMut for OsString {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut OsStr {\n        &mut self[..]\n    }\n}\n\n#[stable(feature = \"osstring_default\", since = \"1.9.0\")]\nimpl Default for OsString {\n    /// Constructs an empty `OsString`.\n    #[inline]\n    fn default() -> OsString {\n        OsString::new()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for OsString {\n    #[inline]\n    fn clone(&self) -> Self {\n        OsString { inner: self.inner.clone() }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, source: &Self) {\n        self.inner.clone_from(&source.inner)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for OsString {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&**self, formatter)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for OsString {\n    #[inline]\n    fn eq(&self, other: &OsString) -> bool {\n        &**self == &**other\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<str> for OsString {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        &**self == other\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<OsString> for str {\n    #[inline]\n    fn eq(&self, other: &OsString) -> bool {\n        &**other == self\n    }\n}\n\n#[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\nimpl PartialEq<&str> for OsString {\n    #[inline]\n    fn eq(&self, other: &&str) -> bool {\n        **self == **other\n    }\n}\n\n#[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\nimpl<'a> PartialEq<OsString> for &'a str {\n    #[inline]\n    fn eq(&self, other: &OsString) -> bool {\n        **other == **self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for OsString {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for OsString {\n    #[inline]\n    fn partial_cmp(&self, other: &OsString) -> Option<cmp::Ordering> {\n        (&**self).partial_cmp(&**other)\n    }\n    #[inline]\n    fn lt(&self, other: &OsString) -> bool {\n        &**self < &**other\n    }\n    #[inline]\n    fn le(&self, other: &OsString) -> bool {\n        &**self <= &**other\n    }\n    #[inline]\n    fn gt(&self, other: &OsString) -> bool {\n        &**self > &**other\n    }\n    #[inline]\n    fn ge(&self, other: &OsString) -> bool {\n        &**self >= &**other\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd<str> for OsString {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        (&**self).partial_cmp(other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for OsString {\n    #[inline]\n    fn cmp(&self, other: &OsString) -> cmp::Ordering {\n        (&**self).cmp(&**other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for OsString {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        (&**self).hash(state)\n    }\n}\n\nimpl OsStr {\n    /// Coerces into an `OsStr` slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &OsStr {\n        s.as_ref()\n    }\n\n    #[inline]\n    fn from_inner(inner: &Slice) -> &OsStr {\n        // SAFETY: OsStr is just a wrapper of Slice,\n        // therefore converting &Slice to &OsStr is safe.\n        unsafe { &*(inner as *const Slice as *const OsStr) }\n    }\n\n    #[inline]\n    fn from_inner_mut(inner: &mut Slice) -> &mut OsStr {\n        // SAFETY: OsStr is just a wrapper of Slice,\n        // therefore converting &mut Slice to &mut OsStr is safe.\n        // Any method that mutates OsStr must be careful not to\n        // break platform-specific encoding, in particular Wtf8 on Windows.\n        unsafe { &mut *(inner as *mut Slice as *mut OsStr) }\n    }\n\n    /// Yields a [`&str`] slice if the `OsStr` is valid Unicode.\n    ///\n    /// This conversion may entail doing a check for UTF-8 validity.\n    ///\n    /// [`&str`]: str\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_str.to_str(), Some(\"foo\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_str(&self) -> Option<&str> {\n        self.inner.to_str()\n    }\n\n    /// Converts an `OsStr` to a [`Cow`]`<`[`str`]`>`.\n    ///\n    /// Any non-Unicode sequences are replaced with\n    /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n    ///\n    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n    ///\n    /// # Examples\n    ///\n    /// Calling `to_string_lossy` on an `OsStr` with invalid unicode:\n    ///\n    /// ```\n    /// // Note, due to differences in how Unix and Windows represent strings,\n    /// // we are forced to complicate this example, setting up example `OsStr`s\n    /// // with different source data and via different platform extensions.\n    /// // Understand that in reality you could end up with such example invalid\n    /// // sequences simply through collecting user command line arguments, for\n    /// // example.\n    ///\n    /// #[cfg(unix)] {\n    ///     use std::ffi::OsStr;\n    ///     use std::os::unix::ffi::OsStrExt;\n    ///\n    ///     // Here, the values 0x66 and 0x6f correspond to 'f' and 'o'\n    ///     // respectively. The value 0x80 is a lone continuation byte, invalid\n    ///     // in a UTF-8 sequence.\n    ///     let source = [0x66, 0x6f, 0x80, 0x6f];\n    ///     let os_str = OsStr::from_bytes(&source[..]);\n    ///\n    ///     assert_eq!(os_str.to_string_lossy(), \"foo\");\n    /// }\n    /// #[cfg(windows)] {\n    ///     use std::ffi::OsString;\n    ///     use std::os::windows::prelude::*;\n    ///\n    ///     // Here the values 0x0066 and 0x006f correspond to 'f' and 'o'\n    ///     // respectively. The value 0xD800 is a lone surrogate half, invalid\n    ///     // in a UTF-16 sequence.\n    ///     let source = [0x0066, 0x006f, 0xD800, 0x006f];\n    ///     let os_string = OsString::from_wide(&source[..]);\n    ///     let os_str = os_string.as_os_str();\n    ///\n    ///     assert_eq!(os_str.to_string_lossy(), \"foo\");\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n        self.inner.to_string_lossy()\n    }\n\n    /// Copies the slice into an owned [`OsString`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{OsStr, OsString};\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// let os_string = os_str.to_os_string();\n    /// assert_eq!(os_string, OsString::from(\"foo\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_os_string(&self) -> OsString {\n        OsString { inner: self.inner.to_owned() }\n    }\n\n    /// Checks whether the `OsStr` is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"\");\n    /// assert!(os_str.is_empty());\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert!(!os_str.is_empty());\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.inner.inner.is_empty()\n    }\n\n    /// Returns the length of this `OsStr`.\n    ///\n    /// Note that this does **not** return the number of bytes in the string in\n    /// OS string form.\n    ///\n    /// The length returned is that of the underlying storage used by `OsStr`.\n    /// As discussed in the [`OsString`] introduction, [`OsString`] and `OsStr`\n    /// store strings in a form best suited for cheap inter-conversion between\n    /// native-platform and Rust string forms, which may differ significantly\n    /// from both of them, including in storage size and encoding.\n    ///\n    /// This number is simply useful for passing to other methods, like\n    /// [`OsString::with_capacity`] to avoid reallocations.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"\");\n    /// assert_eq!(os_str.len(), 0);\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_str.len(), 3);\n    /// ```\n    #[doc(alias = \"length\")]\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.inner.inner.len()\n    }\n\n    /// Converts a [`Box`]`<OsStr>` into an [`OsString`] without copying or allocating.\n    #[stable(feature = \"into_boxed_os_str\", since = \"1.20.0\")]\n    pub fn into_os_string(self: Box<OsStr>) -> OsString {\n        let boxed = unsafe { Box::from_raw(Box::into_raw(self) as *mut Slice) };\n        OsString { inner: Buf::from_box(boxed) }\n    }\n\n    /// Gets the underlying byte representation.\n    ///\n    /// Note: it is *crucial* that this API is not externally public, to avoid\n    /// revealing the internal, platform-specific encodings.\n    #[inline]\n    pub(crate) fn bytes(&self) -> &[u8] {\n        unsafe { &*(&self.inner as *const _ as *const [u8]) }\n    }\n\n    /// Converts this string to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`OsStr::to_ascii_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::from(\"GRE, JRGEN \");\n    ///\n    /// s.make_ascii_lowercase();\n    ///\n    /// assert_eq!(\"gre, jrgen \", s);\n    /// ```\n    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        self.inner.make_ascii_lowercase()\n    }\n\n    /// Converts this string to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`OsStr::to_ascii_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::from(\"Gre, Jrgen \");\n    ///\n    /// s.make_ascii_uppercase();\n    ///\n    /// assert_eq!(\"GRE, JRGEN \", s);\n    /// ```\n    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        self.inner.make_ascii_uppercase()\n    }\n\n    /// Returns a copy of this string where each character is mapped to its\n    /// ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`OsStr::make_ascii_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    /// let s = OsString::from(\"Gre, Jrgen \");\n    ///\n    /// assert_eq!(\"gre, jrgen \", s.to_ascii_lowercase());\n    /// ```\n    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n    pub fn to_ascii_lowercase(&self) -> OsString {\n        OsString::from_inner(self.inner.to_ascii_lowercase())\n    }\n\n    /// Returns a copy of this string where each character is mapped to its\n    /// ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`OsStr::make_ascii_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    /// let s = OsString::from(\"Gre, Jrgen \");\n    ///\n    /// assert_eq!(\"GRE, JRGEN \", s.to_ascii_uppercase());\n    /// ```\n    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n    pub fn to_ascii_uppercase(&self) -> OsString {\n        OsString::from_inner(self.inner.to_ascii_uppercase())\n    }\n\n    /// Checks if all characters in this string are within the ASCII range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let ascii = OsString::from(\"hello!\\n\");\n    /// let non_ascii = OsString::from(\"Gre, Jrgen \");\n    ///\n    /// assert!(ascii.is_ascii());\n    /// assert!(!non_ascii.is_ascii());\n    /// ```\n    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n        self.inner.is_ascii()\n    }\n\n    /// Checks that two strings are an ASCII case-insensitive match.\n    ///\n    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n    /// but without allocating and copying temporaries.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// assert!(OsString::from(\"Ferris\").eq_ignore_ascii_case(\"FERRIS\"));\n    /// assert!(OsString::from(\"Ferrs\").eq_ignore_ascii_case(\"FERRS\"));\n    /// assert!(!OsString::from(\"Ferrs\").eq_ignore_ascii_case(\"FERRS\"));\n    /// ```\n    #[stable(feature = \"osstring_ascii\", since = \"1.53.0\")]\n    pub fn eq_ignore_ascii_case<S: AsRef<OsStr>>(&self, other: S) -> bool {\n        self.inner.eq_ignore_ascii_case(&other.as_ref().inner)\n    }\n}\n\n#[stable(feature = \"box_from_os_str\", since = \"1.17.0\")]\nimpl From<&OsStr> for Box<OsStr> {\n    #[inline]\n    fn from(s: &OsStr) -> Box<OsStr> {\n        let rw = Box::into_raw(s.inner.into_box()) as *mut OsStr;\n        unsafe { Box::from_raw(rw) }\n    }\n}\n\n#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\nimpl From<Cow<'_, OsStr>> for Box<OsStr> {\n    #[inline]\n    fn from(cow: Cow<'_, OsStr>) -> Box<OsStr> {\n        match cow {\n            Cow::Borrowed(s) => Box::from(s),\n            Cow::Owned(s) => Box::from(s),\n        }\n    }\n}\n\n#[stable(feature = \"os_string_from_box\", since = \"1.18.0\")]\nimpl From<Box<OsStr>> for OsString {\n    /// Converts a [`Box`]`<`[`OsStr`]`>` into an [`OsString`] without copying or\n    /// allocating.\n    #[inline]\n    fn from(boxed: Box<OsStr>) -> OsString {\n        boxed.into_os_string()\n    }\n}\n\n#[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\nimpl From<OsString> for Box<OsStr> {\n    /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n    #[inline]\n    fn from(s: OsString) -> Box<OsStr> {\n        s.into_boxed_os_str()\n    }\n}\n\n#[stable(feature = \"more_box_slice_clone\", since = \"1.29.0\")]\nimpl Clone for Box<OsStr> {\n    #[inline]\n    fn clone(&self) -> Self {\n        self.to_os_string().into_boxed_os_str()\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<OsString> for Arc<OsStr> {\n    /// Converts a [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.\n    #[inline]\n    fn from(s: OsString) -> Arc<OsStr> {\n        let arc = s.inner.into_arc();\n        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const OsStr) }\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&OsStr> for Arc<OsStr> {\n    #[inline]\n    fn from(s: &OsStr) -> Arc<OsStr> {\n        let arc = s.inner.into_arc();\n        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const OsStr) }\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<OsString> for Rc<OsStr> {\n    /// Converts a [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n    #[inline]\n    fn from(s: OsString) -> Rc<OsStr> {\n        let rc = s.inner.into_rc();\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const OsStr) }\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&OsStr> for Rc<OsStr> {\n    #[inline]\n    fn from(s: &OsStr) -> Rc<OsStr> {\n        let rc = s.inner.into_rc();\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const OsStr) }\n    }\n}\n\n#[stable(feature = \"cow_from_osstr\", since = \"1.28.0\")]\nimpl<'a> From<OsString> for Cow<'a, OsStr> {\n    #[inline]\n    fn from(s: OsString) -> Cow<'a, OsStr> {\n        Cow::Owned(s)\n    }\n}\n\n#[stable(feature = \"cow_from_osstr\", since = \"1.28.0\")]\nimpl<'a> From<&'a OsStr> for Cow<'a, OsStr> {\n    #[inline]\n    fn from(s: &'a OsStr) -> Cow<'a, OsStr> {\n        Cow::Borrowed(s)\n    }\n}\n\n#[stable(feature = \"cow_from_osstr\", since = \"1.28.0\")]\nimpl<'a> From<&'a OsString> for Cow<'a, OsStr> {\n    #[inline]\n    fn from(s: &'a OsString) -> Cow<'a, OsStr> {\n        Cow::Borrowed(s.as_os_str())\n    }\n}\n\n#[stable(feature = \"osstring_from_cow_osstr\", since = \"1.28.0\")]\nimpl<'a> From<Cow<'a, OsStr>> for OsString {\n    #[inline]\n    fn from(s: Cow<'a, OsStr>) -> Self {\n        s.into_owned()\n    }\n}\n\n#[stable(feature = \"box_default_extra\", since = \"1.17.0\")]\nimpl Default for Box<OsStr> {\n    #[inline]\n    fn default() -> Box<OsStr> {\n        let rw = Box::into_raw(Slice::empty_box()) as *mut OsStr;\n        unsafe { Box::from_raw(rw) }\n    }\n}\n\n#[stable(feature = \"osstring_default\", since = \"1.9.0\")]\nimpl Default for &OsStr {\n    /// Creates an empty `OsStr`.\n    #[inline]\n    fn default() -> Self {\n        OsStr::new(\"\")\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for OsStr {\n    #[inline]\n    fn eq(&self, other: &OsStr) -> bool {\n        self.bytes().eq(other.bytes())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<str> for OsStr {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        *self == *OsStr::new(other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<OsStr> for str {\n    #[inline]\n    fn eq(&self, other: &OsStr) -> bool {\n        *other == *OsStr::new(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for OsStr {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for OsStr {\n    #[inline]\n    fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> {\n        self.bytes().partial_cmp(other.bytes())\n    }\n    #[inline]\n    fn lt(&self, other: &OsStr) -> bool {\n        self.bytes().lt(other.bytes())\n    }\n    #[inline]\n    fn le(&self, other: &OsStr) -> bool {\n        self.bytes().le(other.bytes())\n    }\n    #[inline]\n    fn gt(&self, other: &OsStr) -> bool {\n        self.bytes().gt(other.bytes())\n    }\n    #[inline]\n    fn ge(&self, other: &OsStr) -> bool {\n        self.bytes().ge(other.bytes())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd<str> for OsStr {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        self.partial_cmp(OsStr::new(other))\n    }\n}\n\n// FIXME (#19470): cannot provide PartialOrd<OsStr> for str until we\n// have more flexible coherence rules.\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for OsStr {\n    #[inline]\n    fn cmp(&self, other: &OsStr) -> cmp::Ordering {\n        self.bytes().cmp(other.bytes())\n    }\n}\n\nmacro_rules! impl_cmp {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool {\n                <OsStr as PartialEq>::eq(self, other)\n            }\n        }\n\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n                <OsStr as PartialEq>::eq(self, other)\n            }\n        }\n\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$rhs) -> Option<cmp::Ordering> {\n                <OsStr as PartialOrd>::partial_cmp(self, other)\n            }\n        }\n\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<cmp::Ordering> {\n                <OsStr as PartialOrd>::partial_cmp(self, other)\n            }\n        }\n    };\n}\n\nimpl_cmp!(OsString, OsStr);\nimpl_cmp!(OsString, &'a OsStr);\nimpl_cmp!(Cow<'a, OsStr>, OsStr);\nimpl_cmp!(Cow<'a, OsStr>, &'b OsStr);\nimpl_cmp!(Cow<'a, OsStr>, OsString);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for OsStr {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.bytes().hash(state)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for OsStr {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.inner, formatter)\n    }\n}\n\nimpl OsStr {\n    pub(crate) fn display(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(&self.inner, formatter)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Borrow<OsStr> for OsString {\n    #[inline]\n    fn borrow(&self) -> &OsStr {\n        &self[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToOwned for OsStr {\n    type Owned = OsString;\n    #[inline]\n    fn to_owned(&self) -> OsString {\n        self.to_os_string()\n    }\n    #[inline]\n    fn clone_into(&self, target: &mut OsString) {\n        self.inner.clone_into(&mut target.inner)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for OsStr {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for OsString {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for str {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n        OsStr::from_inner(Slice::from_str(self))\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for String {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n        (&**self).as_ref()\n    }\n}\n\nimpl FromInner<Buf> for OsString {\n    #[inline]\n    fn from_inner(buf: Buf) -> OsString {\n        OsString { inner: buf }\n    }\n}\n\nimpl IntoInner<Buf> for OsString {\n    #[inline]\n    fn into_inner(self) -> Buf {\n        self.inner\n    }\n}\n\nimpl AsInner<Slice> for OsStr {\n    #[inline]\n    fn as_inner(&self) -> &Slice {\n        &self.inner\n    }\n}\n\n#[stable(feature = \"osstring_from_str\", since = \"1.45.0\")]\nimpl FromStr for OsString {\n    type Err = core::convert::Infallible;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Ok(OsString::from(s))\n    }\n}\n\n#[stable(feature = \"osstring_extend\", since = \"1.52.0\")]\nimpl Extend<OsString> for OsString {\n    #[inline]\n    fn extend<T: IntoIterator<Item = OsString>>(&mut self, iter: T) {\n        for s in iter {\n            self.push(&s);\n        }\n    }\n}\n\n#[stable(feature = \"osstring_extend\", since = \"1.52.0\")]\nimpl<'a> Extend<&'a OsStr> for OsString {\n    #[inline]\n    fn extend<T: IntoIterator<Item = &'a OsStr>>(&mut self, iter: T) {\n        for s in iter {\n            self.push(s);\n        }\n    }\n}\n\n#[stable(feature = \"osstring_extend\", since = \"1.52.0\")]\nimpl<'a> Extend<Cow<'a, OsStr>> for OsString {\n    #[inline]\n    fn extend<T: IntoIterator<Item = Cow<'a, OsStr>>>(&mut self, iter: T) {\n        for s in iter {\n            self.push(&s);\n        }\n    }\n}\n\n#[stable(feature = \"osstring_extend\", since = \"1.52.0\")]\nimpl FromIterator<OsString> for OsString {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = OsString>>(iter: I) -> Self {\n        let mut iterator = iter.into_iter();\n\n        // Because we're iterating over `OsString`s, we can avoid at least\n        // one allocation by getting the first string from the iterator\n        // and appending to it all the subsequent strings.\n        match iterator.next() {\n            None => OsString::new(),\n            Some(mut buf) => {\n                buf.extend(iterator);\n                buf\n            }\n        }\n    }\n}\n\n#[stable(feature = \"osstring_extend\", since = \"1.52.0\")]\nimpl<'a> FromIterator<&'a OsStr> for OsString {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = &'a OsStr>>(iter: I) -> Self {\n        let mut buf = Self::new();\n        for s in iter {\n            buf.push(s);\n        }\n        buf\n    }\n}\n\n#[stable(feature = \"osstring_extend\", since = \"1.52.0\")]\nimpl<'a> FromIterator<Cow<'a, OsStr>> for OsString {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = Cow<'a, OsStr>>>(iter: I) -> Self {\n        let mut iterator = iter.into_iter();\n\n        // Because we're iterating over `OsString`s, we can avoid at least\n        // one allocation by getting the first owned string from the iterator\n        // and appending to it all the subsequent strings.\n        match iterator.next() {\n            None => OsString::new(),\n            Some(Cow::Owned(mut buf)) => {\n                buf.extend(iterator);\n                buf\n            }\n            Some(Cow::Borrowed(buf)) => {\n                let mut buf = OsString::from(buf);\n                buf.extend(iterator);\n                buf\n            }\n        }\n    }\n}\n"],["2596","use super::*;\nuse crate::borrow::Cow::{Borrowed, Owned};\nuse crate::collections::hash_map::DefaultHasher;\nuse crate::hash::{Hash, Hasher};\nuse crate::os::raw::c_char;\nuse crate::rc::Rc;\nuse crate::sync::Arc;\n\n#[test]\nfn c_to_rust() {\n    let data = b\"123\\0\";\n    let ptr = data.as_ptr() as *const c_char;\n    unsafe {\n        assert_eq!(CStr::from_ptr(ptr).to_bytes(), b\"123\");\n        assert_eq!(CStr::from_ptr(ptr).to_bytes_with_nul(), b\"123\\0\");\n    }\n}\n\n#[test]\nfn simple() {\n    let s = CString::new(\"1234\").unwrap();\n    assert_eq!(s.as_bytes(), b\"1234\");\n    assert_eq!(s.as_bytes_with_nul(), b\"1234\\0\");\n}\n\n#[test]\nfn build_with_zero1() {\n    assert!(CString::new(&b\"\\0\"[..]).is_err());\n}\n#[test]\nfn build_with_zero2() {\n    assert!(CString::new(vec![0]).is_err());\n}\n\n#[test]\nfn build_with_zero3() {\n    unsafe {\n        let s = CString::from_vec_unchecked(vec![0]);\n        assert_eq!(s.as_bytes(), b\"\\0\");\n    }\n}\n\n#[test]\nfn formatted() {\n    let s = CString::new(&b\"abc\\x01\\x02\\n\\xE2\\x80\\xA6\\xFF\"[..]).unwrap();\n    assert_eq!(format!(\"{:?}\", s), r#\"\"abc\\x01\\x02\\n\\xe2\\x80\\xa6\\xff\"\"#);\n}\n\n#[test]\nfn borrowed() {\n    unsafe {\n        let s = CStr::from_ptr(b\"12\\0\".as_ptr() as *const _);\n        assert_eq!(s.to_bytes(), b\"12\");\n        assert_eq!(s.to_bytes_with_nul(), b\"12\\0\");\n    }\n}\n\n#[test]\nfn to_str() {\n    let data = b\"123\\xE2\\x80\\xA6\\0\";\n    let ptr = data.as_ptr() as *const c_char;\n    unsafe {\n        assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\"));\n        assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\"));\n    }\n    let data = b\"123\\xE2\\0\";\n    let ptr = data.as_ptr() as *const c_char;\n    unsafe {\n        assert!(CStr::from_ptr(ptr).to_str().is_err());\n        assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n    }\n}\n\n#[test]\nfn to_owned() {\n    let data = b\"123\\0\";\n    let ptr = data.as_ptr() as *const c_char;\n\n    let owned = unsafe { CStr::from_ptr(ptr).to_owned() };\n    assert_eq!(owned.as_bytes_with_nul(), data);\n}\n\n#[test]\nfn equal_hash() {\n    let data = b\"123\\xE2\\xFA\\xA6\\0\";\n    let ptr = data.as_ptr() as *const c_char;\n    let cstr: &'static CStr = unsafe { CStr::from_ptr(ptr) };\n\n    let mut s = DefaultHasher::new();\n    cstr.hash(&mut s);\n    let cstr_hash = s.finish();\n    let mut s = DefaultHasher::new();\n    CString::new(&data[..data.len() - 1]).unwrap().hash(&mut s);\n    let cstring_hash = s.finish();\n\n    assert_eq!(cstr_hash, cstring_hash);\n}\n\n#[test]\nfn from_bytes_with_nul() {\n    let data = b\"123\\0\";\n    let cstr = CStr::from_bytes_with_nul(data);\n    assert_eq!(cstr.map(CStr::to_bytes), Ok(&b\"123\"[..]));\n    let cstr = CStr::from_bytes_with_nul(data);\n    assert_eq!(cstr.map(CStr::to_bytes_with_nul), Ok(&b\"123\\0\"[..]));\n\n    unsafe {\n        let cstr = CStr::from_bytes_with_nul(data);\n        let cstr_unchecked = CStr::from_bytes_with_nul_unchecked(data);\n        assert_eq!(cstr, Ok(cstr_unchecked));\n    }\n}\n\n#[test]\nfn from_bytes_with_nul_unterminated() {\n    let data = b\"123\";\n    let cstr = CStr::from_bytes_with_nul(data);\n    assert!(cstr.is_err());\n}\n\n#[test]\nfn from_bytes_with_nul_interior() {\n    let data = b\"1\\023\\0\";\n    let cstr = CStr::from_bytes_with_nul(data);\n    assert!(cstr.is_err());\n}\n\n#[test]\nfn into_boxed() {\n    let orig: &[u8] = b\"Hello, world!\\0\";\n    let cstr = CStr::from_bytes_with_nul(orig).unwrap();\n    let boxed: Box<CStr> = Box::from(cstr);\n    let cstring = cstr.to_owned().into_boxed_c_str().into_c_string();\n    assert_eq!(cstr, &*boxed);\n    assert_eq!(&*boxed, &*cstring);\n    assert_eq!(&*cstring, cstr);\n}\n\n#[test]\nfn boxed_default() {\n    let boxed = <Box<CStr>>::default();\n    assert_eq!(boxed.to_bytes_with_nul(), &[0]);\n}\n\n#[test]\nfn test_c_str_clone_into() {\n    let mut c_string = CString::new(\"lorem\").unwrap();\n    let c_ptr = c_string.as_ptr();\n    let c_str = CStr::from_bytes_with_nul(b\"ipsum\\0\").unwrap();\n    c_str.clone_into(&mut c_string);\n    assert_eq!(c_str, c_string.as_c_str());\n    // The exact same size shouldn't have needed to move its allocation\n    assert_eq!(c_ptr, c_string.as_ptr());\n}\n\n#[test]\nfn into_rc() {\n    let orig: &[u8] = b\"Hello, world!\\0\";\n    let cstr = CStr::from_bytes_with_nul(orig).unwrap();\n    let rc: Rc<CStr> = Rc::from(cstr);\n    let arc: Arc<CStr> = Arc::from(cstr);\n\n    assert_eq!(&*rc, cstr);\n    assert_eq!(&*arc, cstr);\n\n    let rc2: Rc<CStr> = Rc::from(cstr.to_owned());\n    let arc2: Arc<CStr> = Arc::from(cstr.to_owned());\n\n    assert_eq!(&*rc2, cstr);\n    assert_eq!(&*arc2, cstr);\n}\n\n#[test]\nfn cstr_const_constructor() {\n    const CSTR: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"Hello, world!\\0\") };\n\n    assert_eq!(CSTR.to_str().unwrap(), \"Hello, world!\");\n}\n\n#[test]\nfn cstr_index_from() {\n    let original = b\"Hello, world!\\0\";\n    let cstr = CStr::from_bytes_with_nul(original).unwrap();\n    let result = CStr::from_bytes_with_nul(&original[7..]).unwrap();\n\n    assert_eq!(&cstr[7..], result);\n}\n\n#[test]\n#[should_panic]\nfn cstr_index_from_empty() {\n    let original = b\"Hello, world!\\0\";\n    let cstr = CStr::from_bytes_with_nul(original).unwrap();\n    let _ = &cstr[original.len()..];\n}\n\n#[test]\nfn c_string_from_empty_string() {\n    let original = \"\";\n    let cstring = CString::new(original).unwrap();\n    assert_eq!(original.as_bytes(), cstring.as_bytes());\n    assert_eq!([b'\\0'], cstring.as_bytes_with_nul());\n}\n\n#[test]\nfn c_str_from_empty_string() {\n    let original = b\"\\0\";\n    let cstr = CStr::from_bytes_with_nul(original).unwrap();\n    assert_eq!([] as [u8; 0], cstr.to_bytes());\n    assert_eq!([b'\\0'], cstr.to_bytes_with_nul());\n}\n"],["2597","#![deny(unsafe_op_in_unsafe_fn)]\n\n#[cfg(test)]\nmod tests;\n\nuse crate::ascii;\nuse crate::borrow::{Borrow, Cow};\nuse crate::cmp::Ordering;\nuse crate::error::Error;\nuse crate::fmt::{self, Write};\nuse crate::io;\nuse crate::mem;\nuse crate::num::NonZeroU8;\nuse crate::ops;\nuse crate::os::raw::c_char;\nuse crate::ptr;\nuse crate::rc::Rc;\nuse crate::slice;\nuse crate::str::{self, Utf8Error};\nuse crate::sync::Arc;\nuse crate::sys;\nuse crate::sys_common::memchr;\n\n/// A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the\n/// middle.\n///\n/// This type serves the purpose of being able to safely generate a\n/// C-compatible string from a Rust byte slice or vector. An instance of this\n/// type is a static guarantee that the underlying bytes contain no interior 0\n/// bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n///\n/// `CString` is to [`&CStr`] as [`String`] is to [`&str`]: the former\n/// in each pair are owned strings; the latter are borrowed\n/// references.\n///\n/// # Creating a `CString`\n///\n/// A `CString` is created from either a byte slice or a byte vector,\n/// or anything that implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>` (for\n/// example, you can build a `CString` straight out of a [`String`] or\n/// a [`&str`], since both implement that trait).\n///\n/// The [`CString::new`] method will actually check that the provided `&[u8]`\n/// does not have 0 bytes in the middle, and return an error if it\n/// finds one.\n///\n/// # Extracting a raw pointer to the whole C string\n///\n/// `CString` implements a [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n/// trait. This method will give you a `*const c_char` which you can\n/// feed directly to extern functions that expect a nul-terminated\n/// string, like C's `strdup()`. Notice that [`as_ptr`][`CStr::as_ptr`] returns a\n/// read-only pointer; if the C code writes to it, that causes\n/// undefined behavior.\n///\n/// # Extracting a slice of the whole C string\n///\n/// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n/// `CString` with the [`CString::as_bytes`] method. Slices produced in this\n/// way do *not* contain the trailing nul terminator. This is useful\n/// when you will be calling an extern function that takes a `*const\n/// u8` argument which is not necessarily nul-terminated, plus another\n/// argument with the length of the string  like C's `strndup()`.\n/// You can of course get the slice's length with its\n/// [`len`][slice::len] method.\n///\n/// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n/// can use [`CString::as_bytes_with_nul`] instead.\n///\n/// Once you have the kind of slice you need (with or without a nul\n/// terminator), you can call the slice's own\n/// [`as_ptr`][slice::as_ptr] method to get a read-only raw pointer to pass to\n/// extern functions. See the documentation for that function for a\n/// discussion on ensuring the lifetime of the raw pointer.\n///\n/// [`&str`]: prim@str\n/// [`Deref`]: ops::Deref\n/// [`&CStr`]: CStr\n///\n/// # Examples\n///\n/// ```ignore (extern-declaration)\n/// # fn main() {\n/// use std::ffi::CString;\n/// use std::os::raw::c_char;\n///\n/// extern \"C\" {\n///     fn my_printer(s: *const c_char);\n/// }\n///\n/// // We are certain that our string doesn't have 0 bytes in the middle,\n/// // so we can .expect()\n/// let c_to_print = CString::new(\"Hello, world!\").expect(\"CString::new failed\");\n/// unsafe {\n///     my_printer(c_to_print.as_ptr());\n/// }\n/// # }\n/// ```\n///\n/// # Safety\n///\n/// `CString` is intended for working with traditional C-style strings\n/// (a sequence of non-nul bytes terminated by a single nul byte); the\n/// primary use case for these kinds of strings is interoperating with C-like\n/// code. Often you will need to transfer ownership to/from that external\n/// code. It is strongly recommended that you thoroughly read through the\n/// documentation of `CString` before use, as improper ownership management\n/// of `CString` instances can lead to invalid memory accesses, memory leaks,\n/// and other memory errors.\n#[derive(PartialEq, PartialOrd, Eq, Ord, Hash, Clone)]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"cstring_type\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct CString {\n    // Invariant 1: the slice ends with a zero byte and has a length of at least one.\n    // Invariant 2: the slice contains only one zero byte.\n    // Improper usage of unsafe function can break Invariant 2, but not Invariant 1.\n    inner: Box<[u8]>,\n}\n\n/// Representation of a borrowed C string.\n///\n/// This type represents a borrowed reference to a nul-terminated\n/// array of bytes. It can be constructed safely from a `&[`[`u8`]`]`\n/// slice, or unsafely from a raw `*const c_char`. It can then be\n/// converted to a Rust [`&str`] by performing UTF-8 validation, or\n/// into an owned [`CString`].\n///\n/// `&CStr` is to [`CString`] as [`&str`] is to [`String`]: the former\n/// in each pair are borrowed references; the latter are owned\n/// strings.\n///\n/// Note that this structure is **not** `repr(C)` and is not recommended to be\n/// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n/// functions may leverage the unsafe [`CStr::from_ptr`] constructor to provide\n/// a safe interface to other consumers.\n///\n/// # Examples\n///\n/// Inspecting a foreign C string:\n///\n/// ```ignore (extern-declaration)\n/// use std::ffi::CStr;\n/// use std::os::raw::c_char;\n///\n/// extern \"C\" { fn my_string() -> *const c_char; }\n///\n/// unsafe {\n///     let slice = CStr::from_ptr(my_string());\n///     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n/// }\n/// ```\n///\n/// Passing a Rust-originating C string:\n///\n/// ```ignore (extern-declaration)\n/// use std::ffi::{CString, CStr};\n/// use std::os::raw::c_char;\n///\n/// fn work(data: &CStr) {\n///     extern \"C\" { fn work_with(data: *const c_char); }\n///\n///     unsafe { work_with(data.as_ptr()) }\n/// }\n///\n/// let s = CString::new(\"data data data data\").expect(\"CString::new failed\");\n/// work(&s);\n/// ```\n///\n/// Converting a foreign C string into a Rust [`String`]:\n///\n/// ```ignore (extern-declaration)\n/// use std::ffi::CStr;\n/// use std::os::raw::c_char;\n///\n/// extern \"C\" { fn my_string() -> *const c_char; }\n///\n/// fn my_string_safe() -> String {\n///     unsafe {\n///         CStr::from_ptr(my_string()).to_string_lossy().into_owned()\n///     }\n/// }\n///\n/// println!(\"string: {}\", my_string_safe());\n/// ```\n///\n/// [`&str`]: prim@str\n#[derive(Hash)]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME:\n// `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n// on `CStr` being layout-compatible with `[u8]`.\n// When attribute privacy is implemented, `CStr` should be annotated as `#[repr(transparent)]`.\n// Anyway, `CStr` representation and layout are considered implementation detail, are\n// not documented and must not be relied upon.\npub struct CStr {\n    // FIXME: this should not be represented with a DST slice but rather with\n    //        just a raw `c_char` along with some form of marker to make\n    //        this an unsized type. Essentially `sizeof(&CStr)` should be the\n    //        same as `sizeof(&c_char)` but `CStr` should be an unsized type.\n    inner: [c_char],\n}\n\n/// An error indicating that an interior nul byte was found.\n///\n/// While Rust strings may contain nul bytes in the middle, C strings\n/// can't, as that byte would effectively truncate the string.\n///\n/// This error is created by the [`new`][`CString::new`] method on\n/// [`CString`]. See its documentation for more.\n///\n/// # Examples\n///\n/// ```\n/// use std::ffi::{CString, NulError};\n///\n/// let _: NulError = CString::new(b\"f\\0oo\".to_vec()).unwrap_err();\n/// ```\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct NulError(usize, Vec<u8>);\n\n/// An error indicating that a nul byte was not in the expected position.\n///\n/// The slice used to create a [`CStr`] must have one and only one nul byte,\n/// positioned at the end.\n///\n/// This error is created by the [`CStr::from_bytes_with_nul`] method.\n/// See its documentation for more.\n///\n/// # Examples\n///\n/// ```\n/// use std::ffi::{CStr, FromBytesWithNulError};\n///\n/// let _: FromBytesWithNulError = CStr::from_bytes_with_nul(b\"f\\0oo\").unwrap_err();\n/// ```\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\npub struct FromBytesWithNulError {\n    kind: FromBytesWithNulErrorKind,\n}\n\n/// An error indicating that a nul byte was not in the expected position.\n///\n/// The vector used to create a [`CString`] must have one and only one nul byte,\n/// positioned at the end.\n///\n/// This error is created by the [`CString::from_vec_with_nul`] method.\n/// See its documentation for more.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(cstring_from_vec_with_nul)]\n/// use std::ffi::{CString, FromVecWithNulError};\n///\n/// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"f\\0oo\".to_vec()).unwrap_err();\n/// ```\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\npub struct FromVecWithNulError {\n    error_kind: FromBytesWithNulErrorKind,\n    bytes: Vec<u8>,\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\nenum FromBytesWithNulErrorKind {\n    InteriorNul(usize),\n    NotNulTerminated,\n}\n\nimpl FromBytesWithNulError {\n    fn interior_nul(pos: usize) -> FromBytesWithNulError {\n        FromBytesWithNulError { kind: FromBytesWithNulErrorKind::InteriorNul(pos) }\n    }\n    fn not_nul_terminated() -> FromBytesWithNulError {\n        FromBytesWithNulError { kind: FromBytesWithNulErrorKind::NotNulTerminated }\n    }\n}\n\n#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\nimpl FromVecWithNulError {\n    /// Returns a slice of [`u8`]s bytes that were attempted to convert to a [`CString`].\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(cstring_from_vec_with_nul)]\n    /// use std::ffi::CString;\n    ///\n    /// // Some invalid bytes in a vector\n    /// let bytes = b\"f\\0oo\".to_vec();\n    ///\n    /// let value = CString::from_vec_with_nul(bytes.clone());\n    ///\n    /// assert_eq!(&bytes[..], value.unwrap_err().as_bytes());\n    /// ```\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.bytes[..]\n    }\n\n    /// Returns the bytes that were attempted to convert to a [`CString`].\n    ///\n    /// This method is carefully constructed to avoid allocation. It will\n    /// consume the error, moving out the bytes, so that a copy of the bytes\n    /// does not need to be made.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(cstring_from_vec_with_nul)]\n    /// use std::ffi::CString;\n    ///\n    /// // Some invalid bytes in a vector\n    /// let bytes = b\"f\\0oo\".to_vec();\n    ///\n    /// let value = CString::from_vec_with_nul(bytes.clone());\n    ///\n    /// assert_eq!(bytes, value.unwrap_err().into_bytes());\n    /// ```\n    pub fn into_bytes(self) -> Vec<u8> {\n        self.bytes\n    }\n}\n\n/// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n///\n/// `CString` is just a wrapper over a buffer of bytes with a nul terminator;\n/// [`CString::into_string`] performs UTF-8 validation on those bytes and may\n/// return this error.\n///\n/// This `struct` is created by [`CString::into_string()`]. See\n/// its documentation for more.\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\npub struct IntoStringError {\n    inner: CString,\n    error: Utf8Error,\n}\n\nimpl CString {\n    /// Creates a new C-compatible string from a container of bytes.\n    ///\n    /// This function will consume the provided data and use the\n    /// underlying bytes to construct a new string, ensuring that\n    /// there is a trailing 0 byte. This trailing 0 byte will be\n    /// appended by this function; the provided data should *not*\n    /// contain any 0 bytes in it.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore (extern-declaration)\n    /// use std::ffi::CString;\n    /// use std::os::raw::c_char;\n    ///\n    /// extern \"C\" { fn puts(s: *const c_char); }\n    ///\n    /// let to_print = CString::new(\"Hello!\").expect(\"CString::new failed\");\n    /// unsafe {\n    ///     puts(to_print.as_ptr());\n    /// }\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the supplied bytes contain an\n    /// internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n    /// the position of the nul byte.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n        trait SpecIntoVec {\n            fn into_vec(self) -> Vec<u8>;\n        }\n        impl<T: Into<Vec<u8>>> SpecIntoVec for T {\n            default fn into_vec(self) -> Vec<u8> {\n                self.into()\n            }\n        }\n        // Specialization for avoiding reallocation.\n        impl SpecIntoVec for &'_ [u8] {\n            fn into_vec(self) -> Vec<u8> {\n                let mut v = Vec::with_capacity(self.len() + 1);\n                v.extend(self);\n                v\n            }\n        }\n        impl SpecIntoVec for &'_ str {\n            fn into_vec(self) -> Vec<u8> {\n                let mut v = Vec::with_capacity(self.len() + 1);\n                v.extend(self.as_bytes());\n                v\n            }\n        }\n\n        Self::_new(SpecIntoVec::into_vec(t))\n    }\n\n    fn _new(bytes: Vec<u8>) -> Result<CString, NulError> {\n        match memchr::memchr(0, &bytes) {\n            Some(i) => Err(NulError(i, bytes)),\n            None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n        }\n    }\n\n    /// Creates a C-compatible string by consuming a byte vector,\n    /// without checking for interior 0 bytes.\n    ///\n    /// This method is equivalent to [`CString::new`] except that no runtime\n    /// assertion is made that `v` contains no 0 bytes, and it requires an\n    /// actual byte vector, not anything that can be converted to one with Into.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let raw = b\"foo\".to_vec();\n    /// unsafe {\n    ///     let c_string = CString::from_vec_unchecked(raw);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n        v.reserve_exact(1);\n        v.push(0);\n        CString { inner: v.into_boxed_slice() }\n    }\n\n    /// Retakes ownership of a `CString` that was transferred to C via\n    /// [`CString::into_raw`].\n    ///\n    /// Additionally, the length of the string will be recalculated from the pointer.\n    ///\n    /// # Safety\n    ///\n    /// This should only ever be called with a pointer that was earlier\n    /// obtained by calling [`CString::into_raw`]. Other usage (e.g., trying to take\n    /// ownership of a string that was allocated by foreign code) is likely to lead\n    /// to undefined behavior or allocator corruption.\n    ///\n    /// It should be noted that the length isn't just \"recomputed,\" but that\n    /// the recomputed length must match the original length from the\n    /// [`CString::into_raw`] call. This means the [`CString::into_raw`]/`from_raw`\n    /// methods should not be used when passing the string to C functions that can\n    /// modify the string's length.\n    ///\n    /// > **Note:** If you need to borrow a string that was allocated by\n    /// > foreign code, use [`CStr`]. If you need to take ownership of\n    /// > a string that was allocated by foreign code, you will need to\n    /// > make your own provisions for freeing it appropriately, likely\n    /// > with the foreign code's API to do that.\n    ///\n    /// # Examples\n    ///\n    /// Creates a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n    /// ownership with `from_raw`:\n    ///\n    /// ```ignore (extern-declaration)\n    /// use std::ffi::CString;\n    /// use std::os::raw::c_char;\n    ///\n    /// extern \"C\" {\n    ///     fn some_extern_function(s: *mut c_char);\n    /// }\n    ///\n    /// let c_string = CString::new(\"Hello!\").expect(\"CString::new failed\");\n    /// let raw = c_string.into_raw();\n    /// unsafe {\n    ///     some_extern_function(raw);\n    ///     let c_string = CString::from_raw(raw);\n    /// }\n    /// ```\n    #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n    pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n        // SAFETY: This is called with a pointer that was obtained from a call\n        // to `CString::into_raw` and the length has not been modified. As such,\n        // we know there is a NUL byte (and only one) at the end and that the\n        // information about the size of the allocation is correct on Rust's\n        // side.\n        unsafe {\n            let len = sys::strlen(ptr) + 1; // Including the NUL byte\n            let slice = slice::from_raw_parts_mut(ptr, len as usize);\n            CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }\n        }\n    }\n\n    /// Consumes the `CString` and transfers ownership of the string to a C caller.\n    ///\n    /// The pointer which this function returns must be returned to Rust and reconstituted using\n    /// [`CString::from_raw`] to be properly deallocated. Specifically, one\n    /// should *not* use the standard C `free()` function to deallocate\n    /// this string.\n    ///\n    /// Failure to call [`CString::from_raw`] will lead to a memory leak.\n    ///\n    /// The C side must **not** modify the length of the string (by writing a\n    /// `null` somewhere inside the string or removing the final one) before\n    /// it makes it back into Rust using [`CString::from_raw`]. See the safety section\n    /// in [`CString::from_raw`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    ///\n    /// let ptr = c_string.into_raw();\n    ///\n    /// unsafe {\n    ///     assert_eq!(b'f', *ptr as u8);\n    ///     assert_eq!(b'o', *ptr.offset(1) as u8);\n    ///     assert_eq!(b'o', *ptr.offset(2) as u8);\n    ///     assert_eq!(b'\\0', *ptr.offset(3) as u8);\n    ///\n    ///     // retake pointer to free memory\n    ///     let _ = CString::from_raw(ptr);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n    pub fn into_raw(self) -> *mut c_char {\n        Box::into_raw(self.into_inner()) as *mut c_char\n    }\n\n    /// Converts the `CString` into a [`String`] if it contains valid UTF-8 data.\n    ///\n    /// On failure, ownership of the original `CString` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let valid_utf8 = vec![b'f', b'o', b'o'];\n    /// let cstring = CString::new(valid_utf8).expect(\"CString::new failed\");\n    /// assert_eq!(cstring.into_string().expect(\"into_string() call failed\"), \"foo\");\n    ///\n    /// let invalid_utf8 = vec![b'f', 0xff, b'o', b'o'];\n    /// let cstring = CString::new(invalid_utf8).expect(\"CString::new failed\");\n    /// let err = cstring.into_string().err().expect(\"into_string().err() failed\");\n    /// assert_eq!(err.utf8_error().valid_up_to(), 1);\n    /// ```\n\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_string(self) -> Result<String, IntoStringError> {\n        String::from_utf8(self.into_bytes()).map_err(|e| IntoStringError {\n            error: e.utf8_error(),\n            inner: unsafe { CString::from_vec_unchecked(e.into_bytes()) },\n        })\n    }\n\n    /// Consumes the `CString` and returns the underlying byte buffer.\n    ///\n    /// The returned buffer does **not** contain the trailing nul\n    /// terminator, and it is guaranteed to not have any interior nul\n    /// bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    /// let bytes = c_string.into_bytes();\n    /// assert_eq!(bytes, vec![b'f', b'o', b'o']);\n    /// ```\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_bytes(self) -> Vec<u8> {\n        let mut vec = self.into_inner().into_vec();\n        let _nul = vec.pop();\n        debug_assert_eq!(_nul, Some(0u8));\n        vec\n    }\n\n    /// Equivalent to [`CString::into_bytes()`] except that the\n    /// returned vector includes the trailing nul terminator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    /// let bytes = c_string.into_bytes_with_nul();\n    /// assert_eq!(bytes, vec![b'f', b'o', b'o', b'\\0']);\n    /// ```\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_bytes_with_nul(self) -> Vec<u8> {\n        self.into_inner().into_vec()\n    }\n\n    /// Returns the contents of this `CString` as a slice of bytes.\n    ///\n    /// The returned slice does **not** contain the trailing nul\n    /// terminator, and it is guaranteed to not have any interior nul\n    /// bytes. If you need the nul terminator, use\n    /// [`CString::as_bytes_with_nul`] instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    /// let bytes = c_string.as_bytes();\n    /// assert_eq!(bytes, &[b'f', b'o', b'o']);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_bytes(&self) -> &[u8] {\n        // SAFETY: CString has a length at least 1\n        unsafe { self.inner.get_unchecked(..self.inner.len() - 1) }\n    }\n\n    /// Equivalent to [`CString::as_bytes()`] except that the\n    /// returned slice includes the trailing nul terminator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    /// let bytes = c_string.as_bytes_with_nul();\n    /// assert_eq!(bytes, &[b'f', b'o', b'o', b'\\0']);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_bytes_with_nul(&self) -> &[u8] {\n        &self.inner\n    }\n\n    /// Extracts a [`CStr`] slice containing the entire string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{CString, CStr};\n    ///\n    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n    /// let cstr = c_string.as_c_str();\n    /// assert_eq!(cstr,\n    ///            CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"as_c_str\", since = \"1.20.0\")]\n    pub fn as_c_str(&self) -> &CStr {\n        &*self\n    }\n\n    /// Converts this `CString` into a boxed [`CStr`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{CString, CStr};\n    ///\n    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n    /// let boxed = c_string.into_boxed_c_str();\n    /// assert_eq!(&*boxed,\n    ///            CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));\n    /// ```\n    #[stable(feature = \"into_boxed_c_str\", since = \"1.20.0\")]\n    pub fn into_boxed_c_str(self) -> Box<CStr> {\n        unsafe { Box::from_raw(Box::into_raw(self.into_inner()) as *mut CStr) }\n    }\n\n    /// Bypass \"move out of struct which implements [`Drop`] trait\" restriction.\n    #[inline]\n    fn into_inner(self) -> Box<[u8]> {\n        // Rationale: `mem::forget(self)` invalidates the previous call to `ptr::read(&self.inner)`\n        // so we use `ManuallyDrop` to ensure `self` is not dropped.\n        // Then we can return the box directly without invalidating it.\n        // See https://github.com/rust-lang/rust/issues/62553.\n        let this = mem::ManuallyDrop::new(self);\n        unsafe { ptr::read(&this.inner) }\n    }\n\n    /// Converts a [`Vec`]`<u8>` to a [`CString`] without checking the\n    /// invariants on the given [`Vec`].\n    ///\n    /// # Safety\n    ///\n    /// The given [`Vec`] **must** have one nul byte as its last element.\n    /// This means it cannot be empty nor have any other nul byte anywhere else.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// #![feature(cstring_from_vec_with_nul)]\n    /// use std::ffi::CString;\n    /// assert_eq!(\n    ///     unsafe { CString::from_vec_with_nul_unchecked(b\"abc\\0\".to_vec()) },\n    ///     unsafe { CString::from_vec_unchecked(b\"abc\".to_vec()) }\n    /// );\n    /// ```\n    #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n    pub unsafe fn from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n        Self { inner: v.into_boxed_slice() }\n    }\n\n    /// Attempts to converts a [`Vec`]`<u8>` to a [`CString`].\n    ///\n    /// Runtime checks are present to ensure there is only one nul byte in the\n    /// [`Vec`], its last element.\n    ///\n    /// # Errors\n    ///\n    /// If a nul byte is present and not the last element or no nul bytes\n    /// is present, an error will be returned.\n    ///\n    /// # Examples\n    ///\n    /// A successful conversion will produce the same result as [`CString::new`]\n    /// when called without the ending nul byte.\n    ///\n    /// ```\n    /// #![feature(cstring_from_vec_with_nul)]\n    /// use std::ffi::CString;\n    /// assert_eq!(\n    ///     CString::from_vec_with_nul(b\"abc\\0\".to_vec())\n    ///         .expect(\"CString::from_vec_with_nul failed\"),\n    ///     CString::new(b\"abc\".to_vec()).expect(\"CString::new failed\")\n    /// );\n    /// ```\n    ///\n    /// A incorrectly formatted [`Vec`] will produce an error.\n    ///\n    /// ```\n    /// #![feature(cstring_from_vec_with_nul)]\n    /// use std::ffi::{CString, FromVecWithNulError};\n    /// // Interior nul byte\n    /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"a\\0bc\".to_vec()).unwrap_err();\n    /// // No nul byte\n    /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"abc\".to_vec()).unwrap_err();\n    /// ```\n    #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n    pub fn from_vec_with_nul(v: Vec<u8>) -> Result<Self, FromVecWithNulError> {\n        let nul_pos = memchr::memchr(0, &v);\n        match nul_pos {\n            Some(nul_pos) if nul_pos + 1 == v.len() => {\n                // SAFETY: We know there is only one nul byte, at the end\n                // of the vec.\n                Ok(unsafe { Self::from_vec_with_nul_unchecked(v) })\n            }\n            Some(nul_pos) => Err(FromVecWithNulError {\n                error_kind: FromBytesWithNulErrorKind::InteriorNul(nul_pos),\n                bytes: v,\n            }),\n            None => Err(FromVecWithNulError {\n                error_kind: FromBytesWithNulErrorKind::NotNulTerminated,\n                bytes: v,\n            }),\n        }\n    }\n}\n\n// Turns this `CString` into an empty string to prevent\n// memory-unsafe code from working by accident. Inline\n// to prevent LLVM from optimizing it away in debug builds.\n#[stable(feature = \"cstring_drop\", since = \"1.13.0\")]\nimpl Drop for CString {\n    #[inline]\n    fn drop(&mut self) {\n        unsafe {\n            *self.inner.get_unchecked_mut(0) = 0;\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for CString {\n    type Target = CStr;\n\n    #[inline]\n    fn deref(&self) -> &CStr {\n        unsafe { CStr::from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for CString {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\nimpl From<CString> for Vec<u8> {\n    /// Converts a [`CString`] into a [`Vec`]`<u8>`.\n    ///\n    /// The conversion consumes the [`CString`], and removes the terminating NUL byte.\n    #[inline]\n    fn from(s: CString) -> Vec<u8> {\n        s.into_bytes()\n    }\n}\n\n#[stable(feature = \"cstr_debug\", since = \"1.3.0\")]\nimpl fmt::Debug for CStr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"\\\"\")?;\n        for byte in self.to_bytes().iter().flat_map(|&b| ascii::escape_default(b)) {\n            f.write_char(byte as char)?;\n        }\n        write!(f, \"\\\"\")\n    }\n}\n\n#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\nimpl Default for &CStr {\n    fn default() -> Self {\n        const SLICE: &[c_char] = &[0];\n        unsafe { CStr::from_ptr(SLICE.as_ptr()) }\n    }\n}\n\n#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\nimpl Default for CString {\n    /// Creates an empty `CString`.\n    fn default() -> CString {\n        let a: &CStr = Default::default();\n        a.to_owned()\n    }\n}\n\n#[stable(feature = \"cstr_borrow\", since = \"1.3.0\")]\nimpl Borrow<CStr> for CString {\n    #[inline]\n    fn borrow(&self) -> &CStr {\n        self\n    }\n}\n\n#[stable(feature = \"cstring_from_cow_cstr\", since = \"1.28.0\")]\nimpl<'a> From<Cow<'a, CStr>> for CString {\n    #[inline]\n    fn from(s: Cow<'a, CStr>) -> Self {\n        s.into_owned()\n    }\n}\n\n#[stable(feature = \"box_from_c_str\", since = \"1.17.0\")]\nimpl From<&CStr> for Box<CStr> {\n    fn from(s: &CStr) -> Box<CStr> {\n        let boxed: Box<[u8]> = Box::from(s.to_bytes_with_nul());\n        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut CStr) }\n    }\n}\n\n#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\nimpl From<Cow<'_, CStr>> for Box<CStr> {\n    #[inline]\n    fn from(cow: Cow<'_, CStr>) -> Box<CStr> {\n        match cow {\n            Cow::Borrowed(s) => Box::from(s),\n            Cow::Owned(s) => Box::from(s),\n        }\n    }\n}\n\n#[stable(feature = \"c_string_from_box\", since = \"1.18.0\")]\nimpl From<Box<CStr>> for CString {\n    /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n    #[inline]\n    fn from(s: Box<CStr>) -> CString {\n        s.into_c_string()\n    }\n}\n\n#[stable(feature = \"cstring_from_vec_of_nonzerou8\", since = \"1.43.0\")]\nimpl From<Vec<NonZeroU8>> for CString {\n    /// Converts a [`Vec`]`<`[`NonZeroU8`]`>` into a [`CString`] without\n    /// copying nor checking for inner null bytes.\n    #[inline]\n    fn from(v: Vec<NonZeroU8>) -> CString {\n        unsafe {\n            // Transmute `Vec<NonZeroU8>` to `Vec<u8>`.\n            let v: Vec<u8> = {\n                // SAFETY:\n                //   - transmuting between `NonZeroU8` and `u8` is sound;\n                //   - `alloc::Layout<NonZeroU8> == alloc::Layout<u8>`.\n                let (ptr, len, cap): (*mut NonZeroU8, _, _) = Vec::into_raw_parts(v);\n                Vec::from_raw_parts(ptr.cast::<u8>(), len, cap)\n            };\n            // SAFETY: `v` cannot contain null bytes, given the type-level\n            // invariant of `NonZeroU8`.\n            CString::from_vec_unchecked(v)\n        }\n    }\n}\n\n#[stable(feature = \"more_box_slice_clone\", since = \"1.29.0\")]\nimpl Clone for Box<CStr> {\n    #[inline]\n    fn clone(&self) -> Self {\n        (**self).into()\n    }\n}\n\n#[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\nimpl From<CString> for Box<CStr> {\n    /// Converts a [`CString`] into a [`Box`]`<CStr>` without copying or allocating.\n    #[inline]\n    fn from(s: CString) -> Box<CStr> {\n        s.into_boxed_c_str()\n    }\n}\n\n#[stable(feature = \"cow_from_cstr\", since = \"1.28.0\")]\nimpl<'a> From<CString> for Cow<'a, CStr> {\n    #[inline]\n    fn from(s: CString) -> Cow<'a, CStr> {\n        Cow::Owned(s)\n    }\n}\n\n#[stable(feature = \"cow_from_cstr\", since = \"1.28.0\")]\nimpl<'a> From<&'a CStr> for Cow<'a, CStr> {\n    #[inline]\n    fn from(s: &'a CStr) -> Cow<'a, CStr> {\n        Cow::Borrowed(s)\n    }\n}\n\n#[stable(feature = \"cow_from_cstr\", since = \"1.28.0\")]\nimpl<'a> From<&'a CString> for Cow<'a, CStr> {\n    #[inline]\n    fn from(s: &'a CString) -> Cow<'a, CStr> {\n        Cow::Borrowed(s.as_c_str())\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<CString> for Arc<CStr> {\n    /// Converts a [`CString`] into a [`Arc`]`<CStr>` without copying or allocating.\n    #[inline]\n    fn from(s: CString) -> Arc<CStr> {\n        let arc: Arc<[u8]> = Arc::from(s.into_inner());\n        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const CStr) }\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&CStr> for Arc<CStr> {\n    #[inline]\n    fn from(s: &CStr) -> Arc<CStr> {\n        let arc: Arc<[u8]> = Arc::from(s.to_bytes_with_nul());\n        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const CStr) }\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<CString> for Rc<CStr> {\n    /// Converts a [`CString`] into a [`Rc`]`<CStr>` without copying or allocating.\n    #[inline]\n    fn from(s: CString) -> Rc<CStr> {\n        let rc: Rc<[u8]> = Rc::from(s.into_inner());\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const CStr) }\n    }\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&CStr> for Rc<CStr> {\n    #[inline]\n    fn from(s: &CStr) -> Rc<CStr> {\n        let rc: Rc<[u8]> = Rc::from(s.to_bytes_with_nul());\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const CStr) }\n    }\n}\n\n#[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\nimpl Default for Box<CStr> {\n    fn default() -> Box<CStr> {\n        let boxed: Box<[u8]> = Box::from([0]);\n        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut CStr) }\n    }\n}\n\nimpl NulError {\n    /// Returns the position of the nul byte in the slice that caused\n    /// [`CString::new`] to fail.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let nul_error = CString::new(\"foo\\0bar\").unwrap_err();\n    /// assert_eq!(nul_error.nul_position(), 3);\n    ///\n    /// let nul_error = CString::new(\"foo bar\\0\").unwrap_err();\n    /// assert_eq!(nul_error.nul_position(), 7);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn nul_position(&self) -> usize {\n        self.0\n    }\n\n    /// Consumes this error, returning the underlying vector of bytes which\n    /// generated the error in the first place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let nul_error = CString::new(\"foo\\0bar\").unwrap_err();\n    /// assert_eq!(nul_error.into_vec(), b\"foo\\0bar\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_vec(self) -> Vec<u8> {\n        self.1\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for NulError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"nul byte found in data\"\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for NulError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"nul byte found in provided data at position: {}\", self.0)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<NulError> for io::Error {\n    /// Converts a [`NulError`] into a [`io::Error`].\n    fn from(_: NulError) -> io::Error {\n        io::Error::new_const(io::ErrorKind::InvalidInput, &\"data provided contains a nul byte\")\n    }\n}\n\n#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\nimpl Error for FromBytesWithNulError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        match self.kind {\n            FromBytesWithNulErrorKind::InteriorNul(..) => {\n                \"data provided contains an interior nul byte\"\n            }\n            FromBytesWithNulErrorKind::NotNulTerminated => \"data provided is not nul terminated\",\n        }\n    }\n}\n\n#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\nimpl fmt::Display for FromBytesWithNulError {\n    #[allow(deprecated, deprecated_in_future)]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.description())?;\n        if let FromBytesWithNulErrorKind::InteriorNul(pos) = self.kind {\n            write!(f, \" at byte pos {}\", pos)?;\n        }\n        Ok(())\n    }\n}\n\n#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\nimpl Error for FromVecWithNulError {}\n\n#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\nimpl fmt::Display for FromVecWithNulError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.error_kind {\n            FromBytesWithNulErrorKind::InteriorNul(pos) => {\n                write!(f, \"data provided contains an interior nul byte at pos {}\", pos)\n            }\n            FromBytesWithNulErrorKind::NotNulTerminated => {\n                write!(f, \"data provided is not nul terminated\")\n            }\n        }\n    }\n}\n\nimpl IntoStringError {\n    /// Consumes this error, returning original [`CString`] which generated the\n    /// error.\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_cstring(self) -> CString {\n        self.inner\n    }\n\n    /// Access the underlying UTF-8 error that was the cause of this error.\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn utf8_error(&self) -> Utf8Error {\n        self.error\n    }\n}\n\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\nimpl Error for IntoStringError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"C string contained non-utf8 bytes\"\n    }\n\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\n        Some(&self.error)\n    }\n}\n\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\nimpl fmt::Display for IntoStringError {\n    #[allow(deprecated, deprecated_in_future)]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.description().fmt(f)\n    }\n}\n\nimpl CStr {\n    /// Wraps a raw C string with a safe C string wrapper.\n    ///\n    /// This function will wrap the provided `ptr` with a `CStr` wrapper, which\n    /// allows inspection and interoperation of non-owned C strings. The total\n    /// size of the raw C string must be smaller than `isize::MAX` **bytes**\n    /// in memory due to calling the `slice::from_raw_parts` function.\n    /// This method is unsafe for a number of reasons:\n    ///\n    /// * There is no guarantee to the validity of `ptr`.\n    /// * The returned lifetime is not guaranteed to be the actual lifetime of\n    ///   `ptr`.\n    /// * There is no guarantee that the memory pointed to by `ptr` contains a\n    ///   valid nul terminator byte at the end of the string.\n    /// * It is not guaranteed that the memory pointed by `ptr` won't change\n    ///   before the `CStr` has been destroyed.\n    ///\n    /// > **Note**: This operation is intended to be a 0-cost cast but it is\n    /// > currently implemented with an up-front calculation of the length of\n    /// > the string. This is not guaranteed to always be the case.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore (extern-declaration)\n    /// # fn main() {\n    /// use std::ffi::CStr;\n    /// use std::os::raw::c_char;\n    ///\n    /// extern \"C\" {\n    ///     fn my_string() -> *const c_char;\n    /// }\n    ///\n    /// unsafe {\n    ///     let slice = CStr::from_ptr(my_string());\n    ///     println!(\"string returned: {}\", slice.to_str().unwrap());\n    /// }\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n        // SAFETY: The caller has provided a pointer that points to a valid C\n        // string with a NUL terminator of size less than `isize::MAX`, whose\n        // content remain valid and doesn't change for the lifetime of the\n        // returned `CStr`.\n        //\n        // Thus computing the length is fine (a NUL byte exists), the call to\n        // from_raw_parts is safe because we know the length is at most `isize::MAX`, meaning\n        // the call to `from_bytes_with_nul_unchecked` is correct.\n        //\n        // The cast from c_char to u8 is ok because a c_char is always one byte.\n        unsafe {\n            let len = sys::strlen(ptr);\n            let ptr = ptr as *const u8;\n            CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n        }\n    }\n\n    /// Creates a C string wrapper from a byte slice.\n    ///\n    /// This function will cast the provided `bytes` to a `CStr`\n    /// wrapper after ensuring that the byte slice is nul-terminated\n    /// and does not contain any interior nul bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"hello\\0\");\n    /// assert!(cstr.is_ok());\n    /// ```\n    ///\n    /// Creating a `CStr` without a trailing nul terminator is an error:\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"hello\");\n    /// assert!(cstr.is_err());\n    /// ```\n    ///\n    /// Creating a `CStr` with an interior nul byte is an error:\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n    /// assert!(cstr.is_err());\n    /// ```\n    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n    pub fn from_bytes_with_nul(bytes: &[u8]) -> Result<&CStr, FromBytesWithNulError> {\n        let nul_pos = memchr::memchr(0, bytes);\n        if let Some(nul_pos) = nul_pos {\n            if nul_pos + 1 != bytes.len() {\n                return Err(FromBytesWithNulError::interior_nul(nul_pos));\n            }\n            Ok(unsafe { CStr::from_bytes_with_nul_unchecked(bytes) })\n        } else {\n            Err(FromBytesWithNulError::not_nul_terminated())\n        }\n    }\n\n    /// Unsafely creates a C string wrapper from a byte slice.\n    ///\n    /// This function will cast the provided `bytes` to a `CStr` wrapper without\n    /// performing any sanity checks. The provided slice **must** be nul-terminated\n    /// and not contain any interior nul bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{CStr, CString};\n    ///\n    /// unsafe {\n    ///     let cstring = CString::new(\"hello\").expect(\"CString::new failed\");\n    ///     let cstr = CStr::from_bytes_with_nul_unchecked(cstring.to_bytes_with_nul());\n    ///     assert_eq!(cstr, &*cstring);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n    #[rustc_const_unstable(feature = \"const_cstr_unchecked\", issue = \"none\")]\n    pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n        // SAFETY: Casting to CStr is safe because its internal representation\n        // is a [u8] too (safe only inside std).\n        // Dereferencing the obtained pointer is safe because it comes from a\n        // reference. Making a reference is then safe because its lifetime\n        // is bound by the lifetime of the given `bytes`.\n        unsafe { &*(bytes as *const [u8] as *const CStr) }\n    }\n\n    /// Returns the inner pointer to this C string.\n    ///\n    /// The returned pointer will be valid for as long as `self` is, and points\n    /// to a contiguous region of memory terminated with a 0 byte to represent\n    /// the end of the string.\n    ///\n    /// **WARNING**\n    ///\n    /// The returned pointer is read-only; writing to it (including passing it\n    /// to C code that writes to it) causes undefined behavior.\n    ///\n    /// It is your responsibility to make sure that the underlying memory is not\n    /// freed too early. For example, the following code will cause undefined\n    /// behavior when `ptr` is used inside the `unsafe` block:\n    ///\n    /// ```no_run\n    /// # #![allow(unused_must_use)] #![allow(temporary_cstring_as_ptr)]\n    /// use std::ffi::CString;\n    ///\n    /// let ptr = CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr();\n    /// unsafe {\n    ///     // `ptr` is dangling\n    ///     *ptr;\n    /// }\n    /// ```\n    ///\n    /// This happens because the pointer returned by `as_ptr` does not carry any\n    /// lifetime information and the [`CString`] is deallocated immediately after\n    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()`\n    /// expression is evaluated.\n    /// To fix the problem, bind the `CString` to a local variable:\n    ///\n    /// ```no_run\n    /// # #![allow(unused_must_use)]\n    /// use std::ffi::CString;\n    ///\n    /// let hello = CString::new(\"Hello\").expect(\"CString::new failed\");\n    /// let ptr = hello.as_ptr();\n    /// unsafe {\n    ///     // `ptr` is valid because `hello` is in scope\n    ///     *ptr;\n    /// }\n    /// ```\n    ///\n    /// This way, the lifetime of the [`CString`] in `hello` encompasses\n    /// the lifetime of `ptr` and the `unsafe` block.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_str_as_ptr\", since = \"1.32.0\")]\n    pub const fn as_ptr(&self) -> *const c_char {\n        self.inner.as_ptr()\n    }\n\n    /// Converts this C string to a byte slice.\n    ///\n    /// The returned slice will **not** contain the trailing nul terminator that this C\n    /// string has.\n    ///\n    /// > **Note**: This method is currently implemented as a constant-time\n    /// > cast, but it is planned to alter its definition in the future to\n    /// > perform the length calculation whenever this method is called.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(cstr.to_bytes(), b\"foo\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_bytes(&self) -> &[u8] {\n        let bytes = self.to_bytes_with_nul();\n        // SAFETY: to_bytes_with_nul returns slice with length at least 1\n        unsafe { bytes.get_unchecked(..bytes.len() - 1) }\n    }\n\n    /// Converts this C string to a byte slice containing the trailing 0 byte.\n    ///\n    /// This function is the equivalent of [`CStr::to_bytes`] except that it\n    /// will retain the trailing nul terminator instead of chopping it off.\n    ///\n    /// > **Note**: This method is currently implemented as a 0-cost cast, but\n    /// > it is planned to alter its definition in the future to perform the\n    /// > length calculation whenever this method is called.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(cstr.to_bytes_with_nul(), b\"foo\\0\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_bytes_with_nul(&self) -> &[u8] {\n        unsafe { &*(&self.inner as *const [c_char] as *const [u8]) }\n    }\n\n    /// Yields a [`&str`] slice if the `CStr` contains valid UTF-8.\n    ///\n    /// If the contents of the `CStr` are valid UTF-8 data, this\n    /// function will return the corresponding [`&str`] slice. Otherwise,\n    /// it will return an error with details of where UTF-8 validation failed.\n    ///\n    /// [`&str`]: prim@str\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(cstr.to_str(), Ok(\"foo\"));\n    /// ```\n    #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n    pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n        // N.B., when `CStr` is changed to perform the length check in `.to_bytes()`\n        // instead of in `from_ptr()`, it may be worth considering if this should\n        // be rewritten to do the UTF-8 check inline with the length calculation\n        // instead of doing it afterwards.\n        str::from_utf8(self.to_bytes())\n    }\n\n    /// Converts a `CStr` into a [`Cow`]`<`[`str`]`>`.\n    ///\n    /// If the contents of the `CStr` are valid UTF-8 data, this\n    /// function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`\n    /// with the corresponding [`&str`] slice. Otherwise, it will\n    /// replace any invalid UTF-8 sequences with\n    /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n    /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.\n    ///\n    /// [`str`]: primitive@str\n    /// [`&str`]: primitive@str\n    /// [`Borrowed`]: Cow::Borrowed\n    /// [`Owned`]: Cow::Owned\n    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n    ///\n    /// # Examples\n    ///\n    /// Calling `to_string_lossy` on a `CStr` containing valid UTF-8:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"Hello World\\0\")\n    ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(cstr.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n    /// ```\n    ///\n    /// Calling `to_string_lossy` on a `CStr` containing invalid UTF-8:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\")\n    ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(\n    ///     cstr.to_string_lossy(),\n    ///     Cow::Owned(String::from(\"Hello World\")) as Cow<'_, str>\n    /// );\n    /// ```\n    #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n        String::from_utf8_lossy(self.to_bytes())\n    }\n\n    /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n    /// let boxed = c_string.into_boxed_c_str();\n    /// assert_eq!(boxed.into_c_string(), CString::new(\"foo\").expect(\"CString::new failed\"));\n    /// ```\n    #[stable(feature = \"into_boxed_c_str\", since = \"1.20.0\")]\n    pub fn into_c_string(self: Box<CStr>) -> CString {\n        let raw = Box::into_raw(self) as *mut [u8];\n        CString { inner: unsafe { Box::from_raw(raw) } }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for CStr {\n    fn eq(&self, other: &CStr) -> bool {\n        self.to_bytes().eq(other.to_bytes())\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for CStr {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for CStr {\n    fn partial_cmp(&self, other: &CStr) -> Option<Ordering> {\n        self.to_bytes().partial_cmp(&other.to_bytes())\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for CStr {\n    fn cmp(&self, other: &CStr) -> Ordering {\n        self.to_bytes().cmp(&other.to_bytes())\n    }\n}\n\n#[stable(feature = \"cstr_borrow\", since = \"1.3.0\")]\nimpl ToOwned for CStr {\n    type Owned = CString;\n\n    fn to_owned(&self) -> CString {\n        CString { inner: self.to_bytes_with_nul().into() }\n    }\n\n    fn clone_into(&self, target: &mut CString) {\n        let mut b = Vec::from(mem::take(&mut target.inner));\n        self.to_bytes_with_nul().clone_into(&mut b);\n        target.inner = b.into_boxed_slice();\n    }\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl From<&CStr> for CString {\n    fn from(s: &CStr) -> CString {\n        s.to_owned()\n    }\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl ops::Index<ops::RangeFull> for CString {\n    type Output = CStr;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &CStr {\n        self\n    }\n}\n\n#[stable(feature = \"cstr_range_from\", since = \"1.47.0\")]\nimpl ops::Index<ops::RangeFrom<usize>> for CStr {\n    type Output = CStr;\n\n    fn index(&self, index: ops::RangeFrom<usize>) -> &CStr {\n        let bytes = self.to_bytes_with_nul();\n        // we need to manually check the starting index to account for the null\n        // byte, since otherwise we could get an empty string that doesn't end\n        // in a null.\n        if index.start < bytes.len() {\n            unsafe { CStr::from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n        } else {\n            panic!(\n                \"index out of bounds: the len is {} but the index is {}\",\n                bytes.len(),\n                index.start\n            );\n        }\n    }\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl AsRef<CStr> for CStr {\n    #[inline]\n    fn as_ref(&self) -> &CStr {\n        self\n    }\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl AsRef<CStr> for CString {\n    #[inline]\n    fn as_ref(&self) -> &CStr {\n        self\n    }\n}\n"],["2598","//! Terminfo database interface.\n\nuse std::collections::HashMap;\nuse std::env;\nuse std::error;\nuse std::fmt;\nuse std::fs::File;\nuse std::io::{self, prelude::*, BufReader};\nuse std::path::Path;\n\nuse crate::color;\nuse crate::Attr;\nuse crate::Terminal;\n\nuse parm::{expand, Param, Variables};\nuse parser::compiled::{msys_terminfo, parse};\nuse searcher::get_dbpath_for_term;\n\n/// A parsed terminfo database entry.\n#[derive(Debug)]\npub struct TermInfo {\n    /// Names for the terminal\n    pub names: Vec<String>,\n    /// Map of capability name to boolean value\n    pub bools: HashMap<String, bool>,\n    /// Map of capability name to numeric value\n    pub numbers: HashMap<String, u32>,\n    /// Map of capability name to raw (unexpanded) string\n    pub strings: HashMap<String, Vec<u8>>,\n}\n\n/// A terminfo creation error.\n#[derive(Debug)]\npub enum Error {\n    /// TermUnset Indicates that the environment doesn't include enough information to find\n    /// the terminfo entry.\n    TermUnset,\n    /// MalformedTerminfo indicates that parsing the terminfo entry failed.\n    MalformedTerminfo(String),\n    /// io::Error forwards any io::Errors encountered when finding or reading the terminfo entry.\n    IoError(io::Error),\n}\n\nimpl error::Error for Error {\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        use Error::*;\n        match self {\n            IoError(e) => Some(e),\n            _ => None,\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use Error::*;\n        match *self {\n            TermUnset => Ok(()),\n            MalformedTerminfo(ref e) => e.fmt(f),\n            IoError(ref e) => e.fmt(f),\n        }\n    }\n}\n\nimpl TermInfo {\n    /// Creates a TermInfo based on current environment.\n    pub fn from_env() -> Result<TermInfo, Error> {\n        let term = match env::var(\"TERM\") {\n            Ok(name) => TermInfo::from_name(&name),\n            Err(..) => return Err(Error::TermUnset),\n        };\n\n        if term.is_err() && env::var(\"MSYSCON\").map_or(false, |s| \"mintty.exe\" == s) {\n            // msys terminal\n            Ok(msys_terminfo())\n        } else {\n            term\n        }\n    }\n\n    /// Creates a TermInfo for the named terminal.\n    pub fn from_name(name: &str) -> Result<TermInfo, Error> {\n        get_dbpath_for_term(name)\n            .ok_or_else(|| {\n                Error::IoError(io::Error::new(io::ErrorKind::NotFound, \"terminfo file not found\"))\n            })\n            .and_then(|p| TermInfo::from_path(&(*p)))\n    }\n\n    /// Parse the given TermInfo.\n    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<TermInfo, Error> {\n        Self::_from_path(path.as_ref())\n    }\n    // Keep the metadata small\n    fn _from_path(path: &Path) -> Result<TermInfo, Error> {\n        let file = File::open(path).map_err(Error::IoError)?;\n        let mut reader = BufReader::new(file);\n        parse(&mut reader, false).map_err(Error::MalformedTerminfo)\n    }\n}\n\npub mod searcher;\n\n/// TermInfo format parsing.\npub mod parser {\n    //! ncurses-compatible compiled terminfo format parsing (term(5))\n    pub mod compiled;\n}\npub mod parm;\n\nfn cap_for_attr(attr: Attr) -> &'static str {\n    match attr {\n        Attr::Bold => \"bold\",\n        Attr::Dim => \"dim\",\n        Attr::Italic(true) => \"sitm\",\n        Attr::Italic(false) => \"ritm\",\n        Attr::Underline(true) => \"smul\",\n        Attr::Underline(false) => \"rmul\",\n        Attr::Blink => \"blink\",\n        Attr::Standout(true) => \"smso\",\n        Attr::Standout(false) => \"rmso\",\n        Attr::Reverse => \"rev\",\n        Attr::Secure => \"invis\",\n        Attr::ForegroundColor(_) => \"setaf\",\n        Attr::BackgroundColor(_) => \"setab\",\n    }\n}\n\n/// A Terminal that knows how many colors it supports, with a reference to its\n/// parsed Terminfo database record.\npub struct TerminfoTerminal<T> {\n    num_colors: u32,\n    out: T,\n    ti: TermInfo,\n}\n\nimpl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n    type Output = T;\n    fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n        let color = self.dim_if_necessary(color);\n        if self.num_colors > color {\n            return self.apply_cap(\"setaf\", &[Param::Number(color as i32)]);\n        }\n        Ok(false)\n    }\n\n    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n        let color = self.dim_if_necessary(color);\n        if self.num_colors > color {\n            return self.apply_cap(\"setab\", &[Param::Number(color as i32)]);\n        }\n        Ok(false)\n    }\n\n    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n        match attr {\n            Attr::ForegroundColor(c) => self.fg(c),\n            Attr::BackgroundColor(c) => self.bg(c),\n            _ => self.apply_cap(cap_for_attr(attr), &[]),\n        }\n    }\n\n    fn supports_attr(&self, attr: Attr) -> bool {\n        match attr {\n            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => self.num_colors > 0,\n            _ => {\n                let cap = cap_for_attr(attr);\n                self.ti.strings.get(cap).is_some()\n            }\n        }\n    }\n\n    fn reset(&mut self) -> io::Result<bool> {\n        // are there any terminals that have color/attrs and not sgr0?\n        // Try falling back to sgr, then op\n        let cmd = match [\"sgr0\", \"sgr\", \"op\"].iter().find_map(|cap| self.ti.strings.get(*cap)) {\n            Some(op) => match expand(&op, &[], &mut Variables::new()) {\n                Ok(cmd) => cmd,\n                Err(e) => return Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n            },\n            None => return Ok(false),\n        };\n        self.out.write_all(&cmd).and(Ok(true))\n    }\n\n    fn get_ref(&self) -> &T {\n        &self.out\n    }\n\n    fn get_mut(&mut self) -> &mut T {\n        &mut self.out\n    }\n\n    fn into_inner(self) -> T\n    where\n        Self: Sized,\n    {\n        self.out\n    }\n}\n\nimpl<T: Write + Send> TerminfoTerminal<T> {\n    /// Creates a new TerminfoTerminal with the given TermInfo and Write.\n    pub fn new_with_terminfo(out: T, terminfo: TermInfo) -> TerminfoTerminal<T> {\n        let nc = if terminfo.strings.contains_key(\"setaf\") && terminfo.strings.contains_key(\"setab\")\n        {\n            terminfo.numbers.get(\"colors\").map_or(0, |&n| n)\n        } else {\n            0\n        };\n\n        TerminfoTerminal { out, ti: terminfo, num_colors: nc }\n    }\n\n    /// Creates a new TerminfoTerminal for the current environment with the given Write.\n    ///\n    /// Returns `None` when the terminfo cannot be found or parsed.\n    pub fn new(out: T) -> Option<TerminfoTerminal<T>> {\n        TermInfo::from_env().map(move |ti| TerminfoTerminal::new_with_terminfo(out, ti)).ok()\n    }\n\n    fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n        if color >= self.num_colors && color >= 8 && color < 16 { color - 8 } else { color }\n    }\n\n    fn apply_cap(&mut self, cmd: &str, params: &[Param]) -> io::Result<bool> {\n        match self.ti.strings.get(cmd) {\n            Some(cmd) => match expand(&cmd, params, &mut Variables::new()) {\n                Ok(s) => self.out.write_all(&s).and(Ok(true)),\n                Err(e) => Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n            },\n            None => Ok(false),\n        }\n    }\n}\n\nimpl<T: Write> Write for TerminfoTerminal<T> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.out.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.out.flush()\n    }\n}\n"],["2599","//! ncurses-compatible database discovery.\n//!\n//! Does not support hashed database, only filesystem!\n\nuse std::env;\nuse std::fs;\nuse std::path::PathBuf;\n\n#[cfg(test)]\nmod tests;\n\n/// Return path to database entry for `term`\n#[allow(deprecated)]\npub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n    let mut dirs_to_search = Vec::new();\n    let first_char = term.chars().next()?;\n\n    // Find search directory\n    if let Some(dir) = env::var_os(\"TERMINFO\") {\n        dirs_to_search.push(PathBuf::from(dir));\n    }\n\n    if let Ok(dirs) = env::var(\"TERMINFO_DIRS\") {\n        for i in dirs.split(':') {\n            if i == \"\" {\n                dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n            } else {\n                dirs_to_search.push(PathBuf::from(i));\n            }\n        }\n    } else {\n        // Found nothing in TERMINFO_DIRS, use the default paths:\n        // According to  /etc/terminfo/README, after looking at\n        // ~/.terminfo, ncurses will search /etc/terminfo, then\n        // /lib/terminfo, and eventually /usr/share/terminfo.\n        // On Haiku the database can be found at /boot/system/data/terminfo\n        if let Some(mut homedir) = env::home_dir() {\n            homedir.push(\".terminfo\");\n            dirs_to_search.push(homedir)\n        }\n\n        dirs_to_search.push(PathBuf::from(\"/etc/terminfo\"));\n        dirs_to_search.push(PathBuf::from(\"/lib/terminfo\"));\n        dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n        dirs_to_search.push(PathBuf::from(\"/boot/system/data/terminfo\"));\n    }\n\n    // Look for the terminal in all of the search directories\n    for mut p in dirs_to_search {\n        if fs::metadata(&p).is_ok() {\n            p.push(&first_char.to_string());\n            p.push(&term);\n            if fs::metadata(&p).is_ok() {\n                return Some(p);\n            }\n            p.pop();\n            p.pop();\n\n            // on some installations the dir is named after the hex of the char\n            // (e.g., macOS)\n            p.push(&format!(\"{:x}\", first_char as usize));\n            p.push(term);\n            if fs::metadata(&p).is_ok() {\n                return Some(p);\n            }\n        }\n    }\n    None\n}\n"],["2600","use super::*;\n\nuse std::result::Result::Ok;\n\n#[test]\nfn test_basic_setabf() {\n    let s = b\"\\\\E[48;5;%p1%dm\";\n    assert_eq!(\n        expand(s, &[Number(1)], &mut Variables::new()).unwrap(),\n        \"\\\\E[48;5;1m\".bytes().collect::<Vec<_>>()\n    );\n}\n\n#[test]\nfn test_multiple_int_constants() {\n    assert_eq!(\n        expand(b\"%{1}%{2}%d%d\", &[], &mut Variables::new()).unwrap(),\n        \"21\".bytes().collect::<Vec<_>>()\n    );\n}\n\n#[test]\nfn test_op_i() {\n    let mut vars = Variables::new();\n    assert_eq!(\n        expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\", &[Number(1), Number(2), Number(3)], &mut vars),\n        Ok(\"123233\".bytes().collect::<Vec<_>>())\n    );\n    assert_eq!(\n        expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n        Ok(\"0011\".bytes().collect::<Vec<_>>())\n    );\n}\n\n#[test]\nfn test_param_stack_failure_conditions() {\n    let mut varstruct = Variables::new();\n    let vars = &mut varstruct;\n    fn get_res(\n        fmt: &str,\n        cap: &str,\n        params: &[Param],\n        vars: &mut Variables,\n    ) -> Result<Vec<u8>, String> {\n        let mut u8v: Vec<_> = fmt.bytes().collect();\n        u8v.extend(cap.as_bytes().iter().map(|&b| b));\n        expand(&u8v, params, vars)\n    }\n\n    let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n    for &cap in caps.iter() {\n        let res = get_res(\"\", cap, &[], vars);\n        assert!(res.is_err(), \"Op {} succeeded incorrectly with 0 stack entries\", cap);\n        let p = if cap == \"%s\" || cap == \"%l\" { Words(\"foo\".to_string()) } else { Number(97) };\n        let res = get_res(\"%p1\", cap, &[p], vars);\n        assert!(res.is_ok(), \"Op {} failed with 1 stack entry: {}\", cap, res.unwrap_err());\n    }\n    let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n    for &cap in caps.iter() {\n        let res = expand(cap.as_bytes(), &[], vars);\n        assert!(res.is_err(), \"Binop {} succeeded incorrectly with 0 stack entries\", cap);\n        let res = get_res(\"%{1}\", cap, &[], vars);\n        assert!(res.is_err(), \"Binop {} succeeded incorrectly with 1 stack entry\", cap);\n        let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n        assert!(res.is_ok(), \"Binop {} failed with 2 stack entries: {}\", cap, res.unwrap_err());\n    }\n}\n\n#[test]\nfn test_push_bad_param() {\n    assert!(expand(b\"%pa\", &[], &mut Variables::new()).is_err());\n}\n\n#[test]\nfn test_comparison_ops() {\n    let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n    for &(op, bs) in v.iter() {\n        let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n        assert!(res.is_ok(), \"{}\", res.unwrap_err());\n        assert_eq!(res.unwrap(), vec![b'0' + bs[0]]);\n        let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n        assert!(res.is_ok(), \"{}\", res.unwrap_err());\n        assert_eq!(res.unwrap(), vec![b'0' + bs[1]]);\n        let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n        assert!(res.is_ok(), \"{}\", res.unwrap_err());\n        assert_eq!(res.unwrap(), vec![b'0' + bs[2]]);\n    }\n}\n\n#[test]\nfn test_conditionals() {\n    let mut vars = Variables::new();\n    let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n    let res = expand(s, &[Number(1)], &mut vars);\n    assert!(res.is_ok(), \"{}\", res.unwrap_err());\n    assert_eq!(res.unwrap(), \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n    let res = expand(s, &[Number(8)], &mut vars);\n    assert!(res.is_ok(), \"{}\", res.unwrap_err());\n    assert_eq!(res.unwrap(), \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n    let res = expand(s, &[Number(42)], &mut vars);\n    assert!(res.is_ok(), \"{}\", res.unwrap_err());\n    assert_eq!(res.unwrap(), \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n}\n\n#[test]\nfn test_format() {\n    let mut varstruct = Variables::new();\n    let vars = &mut varstruct;\n    assert_eq!(\n        expand(\n            b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n            &[\n                Words(\"foo\".to_string()),\n                Words(\"foo\".to_string()),\n                Words(\"f\".to_string()),\n                Words(\"foo\".to_string())\n            ],\n            vars\n        ),\n        Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>())\n    );\n    assert_eq!(\n        expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n        Ok(\"fo  \".bytes().collect::<Vec<_>>())\n    );\n\n    assert_eq!(\n        expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n        Ok(\"1001    1+1\".bytes().collect::<Vec<_>>())\n    );\n    assert_eq!(\n        expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\", &[Number(15), Number(27)], vars),\n        Ok(\"17017  001b0X001B\".bytes().collect::<Vec<_>>())\n    );\n}\n"],["2601","use super::*;\n\n#[test]\nfn test_veclens() {\n    assert_eq!(boolfnames.len(), boolnames.len());\n    assert_eq!(numfnames.len(), numnames.len());\n    assert_eq!(stringfnames.len(), stringnames.len());\n}\n"],["2602","#![allow(non_upper_case_globals, missing_docs)]\n\n//! ncurses-compatible compiled terminfo format parsing (term(5))\n\nuse super::super::TermInfo;\nuse std::collections::HashMap;\nuse std::io;\nuse std::io::prelude::*;\n\n#[cfg(test)]\nmod tests;\n\n// These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n\n#[rustfmt::skip]\npub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n    \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n    \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n    \"memory_below\", \"move_insert_mode\", \"move_standout_mode\", \"over_strike\", \"status_line_esc_ok\",\n    \"dest_tabs_magic_smso\", \"tilde_glitch\", \"transparent_underline\", \"xon_xoff\", \"needs_xon_xoff\",\n    \"prtr_silent\", \"hard_cursor\", \"non_rev_rmcup\", \"no_pad_char\", \"non_dest_scroll_region\",\n    \"can_change\", \"back_color_erase\", \"hue_lightness_saturation\", \"col_addr_glitch\",\n    \"cr_cancels_micro_mode\", \"has_print_wheel\", \"row_addr_glitch\", \"semi_auto_right_margin\",\n    \"cpi_changes_res\", \"lpi_changes_res\", \"backspaces_with_bs\", \"crt_no_scrolling\",\n    \"no_correctly_working_cr\", \"gnu_has_meta_key\", \"linefeed_is_newline\", \"has_hardware_tabs\",\n    \"return_does_clr_eol\"];\n\n#[rustfmt::skip]\npub static boolnames: &[&str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n    \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n    \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n    \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n\n#[rustfmt::skip]\npub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n    \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n    \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n    \"maximum_windows\", \"max_colors\", \"max_pairs\", \"no_color_video\", \"buffer_capacity\",\n    \"dot_vert_spacing\", \"dot_horz_spacing\", \"max_micro_address\", \"max_micro_jump\", \"micro_col_size\",\n    \"micro_line_size\", \"number_of_pins\", \"output_res_char\", \"output_res_line\",\n    \"output_res_horz_inch\", \"output_res_vert_inch\", \"print_rate\", \"wide_char_size\", \"buttons\",\n    \"bit_image_entwining\", \"bit_image_type\", \"magic_cookie_glitch_ul\", \"carriage_return_delay\",\n    \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n\n#[rustfmt::skip]\npub static numnames: &[&str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n    \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n    \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n    \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n\n#[rustfmt::skip]\npub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n    \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n    \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n    \"cursor_invisible\", \"cursor_left\", \"cursor_mem_address\", \"cursor_normal\", \"cursor_right\",\n    \"cursor_to_ll\", \"cursor_up\", \"cursor_visible\", \"delete_character\", \"delete_line\",\n    \"dis_status_line\", \"down_half_line\", \"enter_alt_charset_mode\", \"enter_blink_mode\",\n    \"enter_bold_mode\", \"enter_ca_mode\", \"enter_delete_mode\", \"enter_dim_mode\", \"enter_insert_mode\",\n    \"enter_secure_mode\", \"enter_protected_mode\", \"enter_reverse_mode\", \"enter_standout_mode\",\n    \"enter_underline_mode\", \"erase_chars\", \"exit_alt_charset_mode\", \"exit_attribute_mode\",\n    \"exit_ca_mode\", \"exit_delete_mode\", \"exit_insert_mode\", \"exit_standout_mode\",\n    \"exit_underline_mode\", \"flash_screen\", \"form_feed\", \"from_status_line\", \"init_1string\",\n    \"init_2string\", \"init_3string\", \"init_file\", \"insert_character\", \"insert_line\",\n    \"insert_padding\", \"key_backspace\", \"key_catab\", \"key_clear\", \"key_ctab\", \"key_dc\", \"key_dl\",\n    \"key_down\", \"key_eic\", \"key_eol\", \"key_eos\", \"key_f0\", \"key_f1\", \"key_f10\", \"key_f2\", \"key_f3\",\n    \"key_f4\", \"key_f5\", \"key_f6\", \"key_f7\", \"key_f8\", \"key_f9\", \"key_home\", \"key_ic\", \"key_il\",\n    \"key_left\", \"key_ll\", \"key_npage\", \"key_ppage\", \"key_right\", \"key_sf\", \"key_sr\", \"key_stab\",\n    \"key_up\", \"keypad_local\", \"keypad_xmit\", \"lab_f0\", \"lab_f1\", \"lab_f10\", \"lab_f2\", \"lab_f3\",\n    \"lab_f4\", \"lab_f5\", \"lab_f6\", \"lab_f7\", \"lab_f8\", \"lab_f9\", \"meta_off\", \"meta_on\", \"newline\",\n    \"pad_char\", \"parm_dch\", \"parm_delete_line\", \"parm_down_cursor\", \"parm_ich\", \"parm_index\",\n    \"parm_insert_line\", \"parm_left_cursor\", \"parm_right_cursor\", \"parm_rindex\", \"parm_up_cursor\",\n    \"pkey_key\", \"pkey_local\", \"pkey_xmit\", \"print_screen\", \"prtr_off\", \"prtr_on\", \"repeat_char\",\n    \"reset_1string\", \"reset_2string\", \"reset_3string\", \"reset_file\", \"restore_cursor\",\n    \"row_address\", \"save_cursor\", \"scroll_forward\", \"scroll_reverse\", \"set_attributes\", \"set_tab\",\n    \"set_window\", \"tab\", \"to_status_line\", \"underline_char\", \"up_half_line\", \"init_prog\", \"key_a1\",\n    \"key_a3\", \"key_b2\", \"key_c1\", \"key_c3\", \"prtr_non\", \"char_padding\", \"acs_chars\", \"plab_norm\",\n    \"key_btab\", \"enter_xon_mode\", \"exit_xon_mode\", \"enter_am_mode\", \"exit_am_mode\", \"xon_character\",\n    \"xoff_character\", \"ena_acs\", \"label_on\", \"label_off\", \"key_beg\", \"key_cancel\", \"key_close\",\n    \"key_command\", \"key_copy\", \"key_create\", \"key_end\", \"key_enter\", \"key_exit\", \"key_find\",\n    \"key_help\", \"key_mark\", \"key_message\", \"key_move\", \"key_next\", \"key_open\", \"key_options\",\n    \"key_previous\", \"key_print\", \"key_redo\", \"key_reference\", \"key_refresh\", \"key_replace\",\n    \"key_restart\", \"key_resume\", \"key_save\", \"key_suspend\", \"key_undo\", \"key_sbeg\", \"key_scancel\",\n    \"key_scommand\", \"key_scopy\", \"key_screate\", \"key_sdc\", \"key_sdl\", \"key_select\", \"key_send\",\n    \"key_seol\", \"key_sexit\", \"key_sfind\", \"key_shelp\", \"key_shome\", \"key_sic\", \"key_sleft\",\n    \"key_smessage\", \"key_smove\", \"key_snext\", \"key_soptions\", \"key_sprevious\", \"key_sprint\",\n    \"key_sredo\", \"key_sreplace\", \"key_sright\", \"key_srsume\", \"key_ssave\", \"key_ssuspend\",\n    \"key_sundo\", \"req_for_input\", \"key_f11\", \"key_f12\", \"key_f13\", \"key_f14\", \"key_f15\", \"key_f16\",\n    \"key_f17\", \"key_f18\", \"key_f19\", \"key_f20\", \"key_f21\", \"key_f22\", \"key_f23\", \"key_f24\",\n    \"key_f25\", \"key_f26\", \"key_f27\", \"key_f28\", \"key_f29\", \"key_f30\", \"key_f31\", \"key_f32\",\n    \"key_f33\", \"key_f34\", \"key_f35\", \"key_f36\", \"key_f37\", \"key_f38\", \"key_f39\", \"key_f40\",\n    \"key_f41\", \"key_f42\", \"key_f43\", \"key_f44\", \"key_f45\", \"key_f46\", \"key_f47\", \"key_f48\",\n    \"key_f49\", \"key_f50\", \"key_f51\", \"key_f52\", \"key_f53\", \"key_f54\", \"key_f55\", \"key_f56\",\n    \"key_f57\", \"key_f58\", \"key_f59\", \"key_f60\", \"key_f61\", \"key_f62\", \"key_f63\", \"clr_bol\",\n    \"clear_margins\", \"set_left_margin\", \"set_right_margin\", \"label_format\", \"set_clock\",\n    \"display_clock\", \"remove_clock\", \"create_window\", \"goto_window\", \"hangup\", \"dial_phone\",\n    \"quick_dial\", \"tone\", \"pulse\", \"flash_hook\", \"fixed_pause\", \"wait_tone\", \"user0\", \"user1\",\n    \"user2\", \"user3\", \"user4\", \"user5\", \"user6\", \"user7\", \"user8\", \"user9\", \"orig_pair\",\n    \"orig_colors\", \"initialize_color\", \"initialize_pair\", \"set_color_pair\", \"set_foreground\",\n    \"set_background\", \"change_char_pitch\", \"change_line_pitch\", \"change_res_horz\",\n    \"change_res_vert\", \"define_char\", \"enter_doublewide_mode\", \"enter_draft_quality\",\n    \"enter_italics_mode\", \"enter_leftward_mode\", \"enter_micro_mode\", \"enter_near_letter_quality\",\n    \"enter_normal_quality\", \"enter_shadow_mode\", \"enter_subscript_mode\", \"enter_superscript_mode\",\n    \"enter_upward_mode\", \"exit_doublewide_mode\", \"exit_italics_mode\", \"exit_leftward_mode\",\n    \"exit_micro_mode\", \"exit_shadow_mode\", \"exit_subscript_mode\", \"exit_superscript_mode\",\n    \"exit_upward_mode\", \"micro_column_address\", \"micro_down\", \"micro_left\", \"micro_right\",\n    \"micro_row_address\", \"micro_up\", \"order_of_pins\", \"parm_down_micro\", \"parm_left_micro\",\n    \"parm_right_micro\", \"parm_up_micro\", \"select_char_set\", \"set_bottom_margin\",\n    \"set_bottom_margin_parm\", \"set_left_margin_parm\", \"set_right_margin_parm\", \"set_top_margin\",\n    \"set_top_margin_parm\", \"start_bit_image\", \"start_char_set_def\", \"stop_bit_image\",\n    \"stop_char_set_def\", \"subscript_characters\", \"superscript_characters\", \"these_cause_cr\",\n    \"zero_motion\", \"char_set_names\", \"key_mouse\", \"mouse_info\", \"req_mouse_pos\", \"get_mouse\",\n    \"set_a_foreground\", \"set_a_background\", \"pkey_plab\", \"device_type\", \"code_set_init\",\n    \"set0_des_seq\", \"set1_des_seq\", \"set2_des_seq\", \"set3_des_seq\", \"set_lr_margin\",\n    \"set_tb_margin\", \"bit_image_repeat\", \"bit_image_newline\", \"bit_image_carriage_return\",\n    \"color_names\", \"define_bit_image_region\", \"end_bit_image_region\", \"set_color_band\",\n    \"set_page_length\", \"display_pc_char\", \"enter_pc_charset_mode\", \"exit_pc_charset_mode\",\n    \"enter_scancode_mode\", \"exit_scancode_mode\", \"pc_term_options\", \"scancode_escape\",\n    \"alt_scancode_esc\", \"enter_horizontal_hl_mode\", \"enter_left_hl_mode\", \"enter_low_hl_mode\",\n    \"enter_right_hl_mode\", \"enter_top_hl_mode\", \"enter_vertical_hl_mode\", \"set_a_attributes\",\n    \"set_pglen_inch\", \"termcap_init2\", \"termcap_reset\", \"linefeed_if_not_lf\", \"backspace_if_not_bs\",\n    \"other_non_function_keys\", \"arrow_key_map\", \"acs_ulcorner\", \"acs_llcorner\", \"acs_urcorner\",\n    \"acs_lrcorner\", \"acs_ltee\", \"acs_rtee\", \"acs_btee\", \"acs_ttee\", \"acs_hline\", \"acs_vline\",\n    \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n\n#[rustfmt::skip]\npub static stringnames: &[&str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n    \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n    \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\",\n    \"dim\", \"smir\", \"invis\", \"prot\", \"rev\", \"smso\", \"smul\", \"ech\", \"rmacs\", \"sgr0\", \"rmcup\", \"rmdc\",\n    \"rmir\", \"rmso\", \"rmul\", \"flash\", \"ff\", \"fsl\", \"is1\", \"is2\", \"is3\", \"if\", \"ich1\", \"il1\", \"ip\",\n    \"kbs\", \"ktbc\", \"kclr\", \"kctab\", \"_\", \"_\", \"kcud1\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"khome\", \"_\", \"_\", \"kcub1\", \"_\", \"knp\", \"kpp\", \"kcuf1\", \"_\", \"_\",\n    \"khts\", \"_\", \"rmkx\", \"smkx\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"rmm\", \"_\",\n    \"_\", \"pad\", \"dch\", \"dl\", \"cud\", \"ich\", \"indn\", \"il\", \"cub\", \"cuf\", \"rin\", \"cuu\", \"pfkey\",\n    \"pfloc\", \"pfx\", \"mc0\", \"mc4\", \"_\", \"rep\", \"rs1\", \"rs2\", \"rs3\", \"rf\", \"rc\", \"vpa\", \"sc\", \"ind\",\n    \"ri\", \"sgr\", \"_\", \"wind\", \"_\", \"tsl\", \"uc\", \"hu\", \"iprog\", \"_\", \"_\", \"_\", \"_\", \"_\", \"mc5p\",\n    \"rmp\", \"acsc\", \"pln\", \"kcbt\", \"smxon\", \"rmxon\", \"smam\", \"rmam\", \"xonc\", \"xoffc\", \"_\", \"smln\",\n    \"rmln\", \"_\", \"kcan\", \"kclo\", \"kcmd\", \"kcpy\", \"kcrt\", \"_\", \"kent\", \"kext\", \"kfnd\", \"khlp\",\n    \"kmrk\", \"kmsg\", \"kmov\", \"knxt\", \"kopn\", \"kopt\", \"kprv\", \"kprt\", \"krdo\", \"kref\", \"krfr\", \"krpl\",\n    \"krst\", \"kres\", \"ksav\", \"kspd\", \"kund\", \"kBEG\", \"kCAN\", \"kCMD\", \"kCPY\", \"kCRT\", \"_\", \"_\",\n    \"kslt\", \"kEND\", \"kEOL\", \"kEXT\", \"kFND\", \"kHLP\", \"kHOM\", \"_\", \"kLFT\", \"kMSG\", \"kMOV\", \"kNXT\",\n    \"kOPT\", \"kPRV\", \"kPRT\", \"kRDO\", \"kRPL\", \"kRIT\", \"kRES\", \"kSAV\", \"kSPD\", \"kUND\", \"rfi\", \"_\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n    \"dclk\", \"rmclk\", \"cwin\", \"wingo\", \"_\", \"dial\", \"qdial\", \"_\", \"_\", \"hook\", \"pause\", \"wait\", \"_\",\n    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"op\", \"oc\", \"initc\", \"initp\", \"scp\", \"setf\",\n    \"setb\", \"cpi\", \"lpi\", \"chr\", \"cvr\", \"defc\", \"swidm\", \"sdrfq\", \"sitm\", \"slm\", \"smicm\", \"snlq\",\n    \"snrmq\", \"sshm\", \"ssubm\", \"ssupm\", \"sum\", \"rwidm\", \"ritm\", \"rlm\", \"rmicm\", \"rshm\", \"rsubm\",\n    \"rsupm\", \"rum\", \"mhpa\", \"mcud1\", \"mcub1\", \"mcuf1\", \"mvpa\", \"mcuu1\", \"porder\", \"mcud\", \"mcub\",\n    \"mcuf\", \"mcuu\", \"scs\", \"smgb\", \"smgbp\", \"smglp\", \"smgrp\", \"smgt\", \"smgtp\", \"sbim\", \"scsd\",\n    \"rbim\", \"rcsd\", \"subcs\", \"supcs\", \"docr\", \"zerom\", \"csnm\", \"kmous\", \"minfo\", \"reqmp\", \"getm\",\n    \"setaf\", \"setab\", \"pfxl\", \"devt\", \"csin\", \"s0ds\", \"s1ds\", \"s2ds\", \"s3ds\", \"smglr\", \"smgtb\",\n    \"birep\", \"binel\", \"bicr\", \"colornm\", \"defbi\", \"endbi\", \"setcolor\", \"slines\", \"dispc\", \"smpch\",\n    \"rmpch\", \"smsc\", \"rmsc\", \"pctrm\", \"scesc\", \"scesa\", \"ehhlm\", \"elhlm\", \"elohlm\", \"erhlm\",\n    \"ethlm\", \"evhlm\", \"sgr1\", \"slength\", \"OTi2\", \"OTrs\", \"OTnl\", \"OTbs\", \"OTko\", \"OTma\", \"OTG2\",\n    \"OTG3\", \"OTG1\", \"OTG4\", \"OTGR\", \"OTGL\", \"OTGU\", \"OTGD\", \"OTGH\", \"OTGV\", \"OTGC\", \"meml\", \"memu\",\n    \"box1\"];\n\nfn read_le_u16(r: &mut dyn io::Read) -> io::Result<u16> {\n    let mut b = [0; 2];\n    r.read_exact(&mut b)?;\n    Ok((b[0] as u16) | ((b[1] as u16) << 8))\n}\n\nfn read_le_u32(r: &mut dyn io::Read) -> io::Result<u32> {\n    let mut b = [0; 4];\n    r.read_exact(&mut b)?;\n    Ok((b[0] as u32) | ((b[1] as u32) << 8) | ((b[2] as u32) << 16) | ((b[3] as u32) << 24))\n}\n\nfn read_byte(r: &mut dyn io::Read) -> io::Result<u8> {\n    match r.bytes().next() {\n        Some(s) => s,\n        None => Err(io::Error::new(io::ErrorKind::Other, \"end of file\")),\n    }\n}\n\n/// Parse a compiled terminfo entry, using long capability names if `longnames`\n/// is true\npub fn parse(file: &mut dyn io::Read, longnames: bool) -> Result<TermInfo, String> {\n    macro_rules! t( ($e:expr) => (\n        match $e {\n            Ok(e) => e,\n            Err(e) => return Err(e.to_string())\n        }\n    ) );\n\n    let (bnames, snames, nnames) = if longnames {\n        (boolfnames, stringfnames, numfnames)\n    } else {\n        (boolnames, stringnames, numnames)\n    };\n\n    // Check magic number\n    let magic = t!(read_le_u16(file));\n\n    let extended = match magic {\n        0o0432 => false,\n        0o01036 => true,\n        _ => return Err(format!(\"invalid magic number, found {:o}\", magic)),\n    };\n\n    // According to the spec, these fields must be >= -1 where -1 means that the feature is not\n    // supported. Using 0 instead of -1 works because we skip sections with length 0.\n    macro_rules! read_nonneg {\n        () => {{\n            match t!(read_le_u16(file)) as i16 {\n                n if n >= 0 => n as usize,\n                -1 => 0,\n                _ => return Err(\"incompatible file: length fields must be  >= -1\".to_string()),\n            }\n        }};\n    }\n\n    let names_bytes = read_nonneg!();\n    let bools_bytes = read_nonneg!();\n    let numbers_count = read_nonneg!();\n    let string_offsets_count = read_nonneg!();\n    let string_table_bytes = read_nonneg!();\n\n    if names_bytes == 0 {\n        return Err(\"incompatible file: names field must be at least 1 byte wide\".to_string());\n    }\n\n    if bools_bytes > boolnames.len() {\n        return Err(\"incompatible file: more booleans than expected\".to_string());\n    }\n\n    if numbers_count > numnames.len() {\n        return Err(\"incompatible file: more numbers than expected\".to_string());\n    }\n\n    if string_offsets_count > stringnames.len() {\n        return Err(\"incompatible file: more string offsets than expected\".to_string());\n    }\n\n    // don't read NUL\n    let mut bytes = Vec::new();\n    t!(file.take((names_bytes - 1) as u64).read_to_end(&mut bytes));\n    let names_str = match String::from_utf8(bytes) {\n        Ok(s) => s,\n        Err(_) => return Err(\"input not utf-8\".to_string()),\n    };\n\n    let term_names: Vec<String> = names_str.split('|').map(|s| s.to_string()).collect();\n    // consume NUL\n    if t!(read_byte(file)) != b'\\0' {\n        return Err(\"incompatible file: missing null terminator for names section\".to_string());\n    }\n\n    let bools_map: HashMap<String, bool> = t! {\n        (0..bools_bytes).filter_map(|i| match read_byte(file) {\n            Err(e) => Some(Err(e)),\n            Ok(1) => Some(Ok((bnames[i].to_string(), true))),\n            Ok(_) => None\n        }).collect()\n    };\n\n    if (bools_bytes + names_bytes) % 2 == 1 {\n        t!(read_byte(file)); // compensate for padding\n    }\n\n    let numbers_map: HashMap<String, u32> = t! {\n        (0..numbers_count).filter_map(|i| {\n            let number = if extended { read_le_u32(file) } else { read_le_u16(file).map(Into::into) };\n\n            match number {\n                Ok(0xFFFF) => None,\n                Ok(n) => Some(Ok((nnames[i].to_string(), n))),\n                Err(e) => Some(Err(e))\n            }\n        }).collect()\n    };\n\n    let string_map: HashMap<String, Vec<u8>> = if string_offsets_count > 0 {\n        let string_offsets: Vec<u16> =\n            t!((0..string_offsets_count).map(|_| read_le_u16(file)).collect());\n\n        let mut string_table = Vec::new();\n        t!(file.take(string_table_bytes as u64).read_to_end(&mut string_table));\n\n        t!(string_offsets\n            .into_iter()\n            .enumerate()\n            .filter(|&(_, offset)| {\n                // non-entry\n                offset != 0xFFFF\n            })\n            .map(|(i, offset)| {\n                let offset = offset as usize;\n\n                let name = if snames[i] == \"_\" { stringfnames[i] } else { snames[i] };\n\n                if offset == 0xFFFE {\n                    // undocumented: FFFE indicates cap@, which means the capability is not present\n                    // unsure if the handling for this is correct\n                    return Ok((name.to_string(), Vec::new()));\n                }\n\n                // Find the offset of the NUL we want to go to\n                let nulpos = string_table[offset..string_table_bytes].iter().position(|&b| b == 0);\n                match nulpos {\n                    Some(len) => {\n                        Ok((name.to_string(), string_table[offset..offset + len].to_vec()))\n                    }\n                    None => Err(\"invalid file: missing NUL in string_table\".to_string()),\n                }\n            })\n            .collect())\n    } else {\n        HashMap::new()\n    };\n\n    // And that's all there is to it\n    Ok(TermInfo { names: term_names, bools: bools_map, numbers: numbers_map, strings: string_map })\n}\n\n/// Creates a dummy TermInfo struct for msys terminals\npub fn msys_terminfo() -> TermInfo {\n    let mut strings = HashMap::new();\n    strings.insert(\"sgr0\".to_string(), b\"\\x1B[0m\".to_vec());\n    strings.insert(\"bold\".to_string(), b\"\\x1B[1m\".to_vec());\n    strings.insert(\"setaf\".to_string(), b\"\\x1B[3%p1%dm\".to_vec());\n    strings.insert(\"setab\".to_string(), b\"\\x1B[4%p1%dm\".to_vec());\n\n    let mut numbers = HashMap::new();\n    numbers.insert(\"colors\".to_string(), 8);\n\n    TermInfo {\n        names: vec![\"cygwin\".to_string()], // msys is a fork of an older cygwin version\n        bools: HashMap::new(),\n        numbers,\n        strings,\n    }\n}\n"],["2603","//! Parameterized string expansion\n\nuse self::Param::*;\nuse self::States::*;\n\nuse std::iter::repeat;\n\n#[cfg(test)]\nmod tests;\n\n#[derive(Clone, Copy, PartialEq)]\nenum States {\n    Nothing,\n    Percent,\n    SetVar,\n    GetVar,\n    PushParam,\n    CharConstant,\n    CharClose,\n    IntConstant(i32),\n    FormatPattern(Flags, FormatState),\n    SeekIfElse(usize),\n    SeekIfElsePercent(usize),\n    SeekIfEnd(usize),\n    SeekIfEndPercent(usize),\n}\n\n#[derive(Copy, PartialEq, Clone)]\nenum FormatState {\n    Flags,\n    Width,\n    Precision,\n}\n\n/// Types of parameters a capability can use\n#[allow(missing_docs)]\n#[derive(Clone)]\npub enum Param {\n    Words(String),\n    Number(i32),\n}\n\n/// Container for static and dynamic variable arrays\npub struct Variables {\n    /// Static variables A-Z\n    sta_va: [Param; 26],\n    /// Dynamic variables a-z\n    dyn_va: [Param; 26],\n}\n\nimpl Variables {\n    /// Returns a new zero-initialized Variables\n    pub fn new() -> Variables {\n        Variables {\n            sta_va: [\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n            ],\n            dyn_va: [\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n                Number(0),\n            ],\n        }\n    }\n}\n\n/// Expand a parameterized capability\n///\n/// # Arguments\n/// * `cap`    - string to expand\n/// * `params` - vector of params for %p1 etc\n/// * `vars`   - Variables struct for %Pa etc\n///\n/// To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n/// multiple capabilities for the same terminal.\npub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<u8>, String> {\n    let mut state = Nothing;\n\n    // expanded cap will only rarely be larger than the cap itself\n    let mut output = Vec::with_capacity(cap.len());\n\n    let mut stack: Vec<Param> = Vec::new();\n\n    // Copy parameters into a local vector for mutability\n    let mut mparams = [\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n        Number(0),\n    ];\n    for (dst, src) in mparams.iter_mut().zip(params.iter()) {\n        *dst = (*src).clone();\n    }\n\n    for &c in cap.iter() {\n        let cur = c as char;\n        let mut old_state = state;\n        match state {\n            Nothing => {\n                if cur == '%' {\n                    state = Percent;\n                } else {\n                    output.push(c);\n                }\n            }\n            Percent => {\n                match cur {\n                    '%' => {\n                        output.push(c);\n                        state = Nothing\n                    }\n                    'c' => {\n                        match stack.pop() {\n                            // if c is 0, use 0200 (128) for ncurses compatibility\n                            Some(Number(0)) => output.push(128u8),\n                            // Don't check bounds. ncurses just casts and truncates.\n                            Some(Number(c)) => output.push(c as u8),\n                            Some(_) => return Err(\"a non-char was used with %c\".to_string()),\n                            None => return Err(\"stack is empty\".to_string()),\n                        }\n                    }\n                    'p' => state = PushParam,\n                    'P' => state = SetVar,\n                    'g' => state = GetVar,\n                    '\\'' => state = CharConstant,\n                    '{' => state = IntConstant(0),\n                    'l' => match stack.pop() {\n                        Some(Words(s)) => stack.push(Number(s.len() as i32)),\n                        Some(_) => return Err(\"a non-str was used with %l\".to_string()),\n                        None => return Err(\"stack is empty\".to_string()),\n                    },\n                    '+' | '-' | '/' | '*' | '^' | '&' | '|' | 'm' => {\n                        match (stack.pop(), stack.pop()) {\n                            (Some(Number(y)), Some(Number(x))) => stack.push(Number(match cur {\n                                '+' => x + y,\n                                '-' => x - y,\n                                '*' => x * y,\n                                '/' => x / y,\n                                '|' => x | y,\n                                '&' => x & y,\n                                '^' => x ^ y,\n                                'm' => x % y,\n                                _ => unreachable!(\"All cases handled\"),\n                            })),\n                            (Some(_), Some(_)) => {\n                                return Err(format!(\"non-numbers on stack with {}\", cur));\n                            }\n                            _ => return Err(\"stack is empty\".to_string()),\n                        }\n                    }\n                    '=' | '>' | '<' | 'A' | 'O' => match (stack.pop(), stack.pop()) {\n                        (Some(Number(y)), Some(Number(x))) => stack.push(Number(\n                            if match cur {\n                                '=' => x == y,\n                                '<' => x < y,\n                                '>' => x > y,\n                                'A' => x > 0 && y > 0,\n                                'O' => x > 0 || y > 0,\n                                _ => unreachable!(),\n                            } {\n                                1\n                            } else {\n                                0\n                            },\n                        )),\n                        (Some(_), Some(_)) => {\n                            return Err(format!(\"non-numbers on stack with {}\", cur));\n                        }\n                        _ => return Err(\"stack is empty\".to_string()),\n                    },\n                    '!' | '~' => match stack.pop() {\n                        Some(Number(x)) => stack.push(Number(match cur {\n                            '!' if x > 0 => 0,\n                            '!' => 1,\n                            '~' => !x,\n                            _ => unreachable!(),\n                        })),\n                        Some(_) => return Err(format!(\"non-numbers on stack with {}\", cur)),\n                        None => return Err(\"stack is empty\".to_string()),\n                    },\n                    'i' => match (&mparams[0], &mparams[1]) {\n                        (&Number(x), &Number(y)) => {\n                            mparams[0] = Number(x + 1);\n                            mparams[1] = Number(y + 1);\n                        }\n                        _ => return Err(\"first two params not numbers with %i\".to_string()),\n                    },\n\n                    // printf-style support for %doxXs\n                    'd' | 'o' | 'x' | 'X' | 's' => {\n                        if let Some(arg) = stack.pop() {\n                            let flags = Flags::new();\n                            let res = format(arg, FormatOp::from_char(cur), flags)?;\n                            output.extend(res.iter().cloned());\n                        } else {\n                            return Err(\"stack is empty\".to_string());\n                        }\n                    }\n                    ':' | '#' | ' ' | '.' | '0'..='9' => {\n                        let mut flags = Flags::new();\n                        let mut fstate = FormatState::Flags;\n                        match cur {\n                            ':' => (),\n                            '#' => flags.alternate = true,\n                            ' ' => flags.space = true,\n                            '.' => fstate = FormatState::Precision,\n                            '0'..='9' => {\n                                flags.width = cur as usize - '0' as usize;\n                                fstate = FormatState::Width;\n                            }\n                            _ => unreachable!(),\n                        }\n                        state = FormatPattern(flags, fstate);\n                    }\n\n                    // conditionals\n                    '?' => (),\n                    't' => match stack.pop() {\n                        Some(Number(0)) => state = SeekIfElse(0),\n                        Some(Number(_)) => (),\n                        Some(_) => return Err(\"non-number on stack with conditional\".to_string()),\n                        None => return Err(\"stack is empty\".to_string()),\n                    },\n                    'e' => state = SeekIfEnd(0),\n                    ';' => (),\n                    _ => return Err(format!(\"unrecognized format option {}\", cur)),\n                }\n            }\n            PushParam => {\n                // params are 1-indexed\n                stack.push(\n                    mparams[match cur.to_digit(10) {\n                        Some(d) => d as usize - 1,\n                        None => return Err(\"bad param number\".to_string()),\n                    }]\n                    .clone(),\n                );\n            }\n            SetVar => {\n                if cur >= 'A' && cur <= 'Z' {\n                    if let Some(arg) = stack.pop() {\n                        let idx = (cur as u8) - b'A';\n                        vars.sta_va[idx as usize] = arg;\n                    } else {\n                        return Err(\"stack is empty\".to_string());\n                    }\n                } else if cur >= 'a' && cur <= 'z' {\n                    if let Some(arg) = stack.pop() {\n                        let idx = (cur as u8) - b'a';\n                        vars.dyn_va[idx as usize] = arg;\n                    } else {\n                        return Err(\"stack is empty\".to_string());\n                    }\n                } else {\n                    return Err(\"bad variable name in %P\".to_string());\n                }\n            }\n            GetVar => {\n                if cur >= 'A' && cur <= 'Z' {\n                    let idx = (cur as u8) - b'A';\n                    stack.push(vars.sta_va[idx as usize].clone());\n                } else if cur >= 'a' && cur <= 'z' {\n                    let idx = (cur as u8) - b'a';\n                    stack.push(vars.dyn_va[idx as usize].clone());\n                } else {\n                    return Err(\"bad variable name in %g\".to_string());\n                }\n            }\n            CharConstant => {\n                stack.push(Number(c as i32));\n                state = CharClose;\n            }\n            CharClose => {\n                if cur != '\\'' {\n                    return Err(\"malformed character constant\".to_string());\n                }\n            }\n            IntConstant(i) => {\n                if cur == '}' {\n                    stack.push(Number(i));\n                    state = Nothing;\n                } else if let Some(digit) = cur.to_digit(10) {\n                    match i.checked_mul(10).and_then(|i_ten| i_ten.checked_add(digit as i32)) {\n                        Some(i) => {\n                            state = IntConstant(i);\n                            old_state = Nothing;\n                        }\n                        None => return Err(\"int constant too large\".to_string()),\n                    }\n                } else {\n                    return Err(\"bad int constant\".to_string());\n                }\n            }\n            FormatPattern(ref mut flags, ref mut fstate) => {\n                old_state = Nothing;\n                match (*fstate, cur) {\n                    (_, 'd') | (_, 'o') | (_, 'x') | (_, 'X') | (_, 's') => {\n                        if let Some(arg) = stack.pop() {\n                            let res = format(arg, FormatOp::from_char(cur), *flags)?;\n                            output.extend(res.iter().cloned());\n                            // will cause state to go to Nothing\n                            old_state = FormatPattern(*flags, *fstate);\n                        } else {\n                            return Err(\"stack is empty\".to_string());\n                        }\n                    }\n                    (FormatState::Flags, '#') => {\n                        flags.alternate = true;\n                    }\n                    (FormatState::Flags, '-') => {\n                        flags.left = true;\n                    }\n                    (FormatState::Flags, '+') => {\n                        flags.sign = true;\n                    }\n                    (FormatState::Flags, ' ') => {\n                        flags.space = true;\n                    }\n                    (FormatState::Flags, '0'..='9') => {\n                        flags.width = cur as usize - '0' as usize;\n                        *fstate = FormatState::Width;\n                    }\n                    (FormatState::Flags, '.') => {\n                        *fstate = FormatState::Precision;\n                    }\n                    (FormatState::Width, '0'..='9') => {\n                        let old = flags.width;\n                        flags.width = flags.width * 10 + (cur as usize - '0' as usize);\n                        if flags.width < old {\n                            return Err(\"format width overflow\".to_string());\n                        }\n                    }\n                    (FormatState::Width, '.') => {\n                        *fstate = FormatState::Precision;\n                    }\n                    (FormatState::Precision, '0'..='9') => {\n                        let old = flags.precision;\n                        flags.precision = flags.precision * 10 + (cur as usize - '0' as usize);\n                        if flags.precision < old {\n                            return Err(\"format precision overflow\".to_string());\n                        }\n                    }\n                    _ => return Err(\"invalid format specifier\".to_string()),\n                }\n            }\n            SeekIfElse(level) => {\n                if cur == '%' {\n                    state = SeekIfElsePercent(level);\n                }\n                old_state = Nothing;\n            }\n            SeekIfElsePercent(level) => {\n                if cur == ';' {\n                    if level == 0 {\n                        state = Nothing;\n                    } else {\n                        state = SeekIfElse(level - 1);\n                    }\n                } else if cur == 'e' && level == 0 {\n                    state = Nothing;\n                } else if cur == '?' {\n                    state = SeekIfElse(level + 1);\n                } else {\n                    state = SeekIfElse(level);\n                }\n            }\n            SeekIfEnd(level) => {\n                if cur == '%' {\n                    state = SeekIfEndPercent(level);\n                }\n                old_state = Nothing;\n            }\n            SeekIfEndPercent(level) => {\n                if cur == ';' {\n                    if level == 0 {\n                        state = Nothing;\n                    } else {\n                        state = SeekIfEnd(level - 1);\n                    }\n                } else if cur == '?' {\n                    state = SeekIfEnd(level + 1);\n                } else {\n                    state = SeekIfEnd(level);\n                }\n            }\n        }\n        if state == old_state {\n            state = Nothing;\n        }\n    }\n    Ok(output)\n}\n\n#[derive(Copy, PartialEq, Clone)]\nstruct Flags {\n    width: usize,\n    precision: usize,\n    alternate: bool,\n    left: bool,\n    sign: bool,\n    space: bool,\n}\n\nimpl Flags {\n    fn new() -> Flags {\n        Flags { width: 0, precision: 0, alternate: false, left: false, sign: false, space: false }\n    }\n}\n\n#[derive(Copy, Clone)]\nenum FormatOp {\n    Digit,\n    Octal,\n    LowerHex,\n    UpperHex,\n    String,\n}\n\nimpl FormatOp {\n    fn from_char(c: char) -> FormatOp {\n        match c {\n            'd' => FormatOp::Digit,\n            'o' => FormatOp::Octal,\n            'x' => FormatOp::LowerHex,\n            'X' => FormatOp::UpperHex,\n            's' => FormatOp::String,\n            _ => panic!(\"bad FormatOp char\"),\n        }\n    }\n    fn to_char(self) -> char {\n        match self {\n            FormatOp::Digit => 'd',\n            FormatOp::Octal => 'o',\n            FormatOp::LowerHex => 'x',\n            FormatOp::UpperHex => 'X',\n            FormatOp::String => 's',\n        }\n    }\n}\n\nfn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n    let mut s = match val {\n        Number(d) => {\n            match op {\n                FormatOp::Digit => {\n                    if flags.sign {\n                        format!(\"{:+01$}\", d, flags.precision)\n                    } else if d < 0 {\n                        // C doesn't take sign into account in precision calculation.\n                        format!(\"{:01$}\", d, flags.precision + 1)\n                    } else if flags.space {\n                        format!(\" {:01$}\", d, flags.precision)\n                    } else {\n                        format!(\"{:01$}\", d, flags.precision)\n                    }\n                }\n                FormatOp::Octal => {\n                    if flags.alternate {\n                        // Leading octal zero counts against precision.\n                        format!(\"0{:01$o}\", d, flags.precision.saturating_sub(1))\n                    } else {\n                        format!(\"{:01$o}\", d, flags.precision)\n                    }\n                }\n                FormatOp::LowerHex => {\n                    if flags.alternate && d != 0 {\n                        format!(\"0x{:01$x}\", d, flags.precision)\n                    } else {\n                        format!(\"{:01$x}\", d, flags.precision)\n                    }\n                }\n                FormatOp::UpperHex => {\n                    if flags.alternate && d != 0 {\n                        format!(\"0X{:01$X}\", d, flags.precision)\n                    } else {\n                        format!(\"{:01$X}\", d, flags.precision)\n                    }\n                }\n                FormatOp::String => return Err(\"non-number on stack with %s\".to_string()),\n            }\n            .into_bytes()\n        }\n        Words(s) => match op {\n            FormatOp::String => {\n                let mut s = s.into_bytes();\n                if flags.precision > 0 && flags.precision < s.len() {\n                    s.truncate(flags.precision);\n                }\n                s\n            }\n            _ => return Err(format!(\"non-string on stack with %{}\", op.to_char())),\n        },\n    };\n    if flags.width > s.len() {\n        let n = flags.width - s.len();\n        if flags.left {\n            s.extend(repeat(b' ').take(n));\n        } else {\n            let mut s_ = Vec::with_capacity(flags.width);\n            s_.extend(repeat(b' ').take(n));\n            s_.extend(s.into_iter());\n            s = s_;\n        }\n    }\n    Ok(s)\n}\n"],["2604","use super::*;\n\n#[test]\n#[ignore = \"buildbots don't have ncurses installed and I can't mock everything I need\"]\nfn test_get_dbpath_for_term() {\n    // woefully inadequate test coverage\n    // note: current tests won't work with non-standard terminfo hierarchies (e.g., macOS's)\n    use std::env;\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    fn x(t: &str) -> String {\n        let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n        p.to_str().unwrap().to_string()\n    }\n    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n    assert!(get_dbpath_for_term(\"\") == None);\n    env::set_var(\"TERMINFO_DIRS\", \":\");\n    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n    env::remove_var(\"TERMINFO_DIRS\");\n}\n"],["2605","//! Windows console handling\n\n// FIXME (#13400): this is only a tiny fraction of the Windows console api\n\nuse std::io;\nuse std::io::prelude::*;\n\nuse crate::color;\nuse crate::Attr;\nuse crate::Terminal;\n\n/// A Terminal implementation that uses the Win32 Console API.\npub struct WinConsole<T> {\n    buf: T,\n    def_foreground: color::Color,\n    def_background: color::Color,\n    foreground: color::Color,\n    background: color::Color,\n}\n\ntype SHORT = i16;\ntype WORD = u16;\ntype DWORD = u32;\ntype BOOL = i32;\ntype HANDLE = *mut u8;\n\n#[allow(non_snake_case)]\n#[repr(C)]\nstruct SMALL_RECT {\n    Left: SHORT,\n    Top: SHORT,\n    Right: SHORT,\n    Bottom: SHORT,\n}\n\n#[allow(non_snake_case)]\n#[repr(C)]\nstruct COORD {\n    X: SHORT,\n    Y: SHORT,\n}\n\n#[allow(non_snake_case)]\n#[repr(C)]\nstruct CONSOLE_SCREEN_BUFFER_INFO {\n    dwSize: COORD,\n    dwCursorPosition: COORD,\n    wAttributes: WORD,\n    srWindow: SMALL_RECT,\n    dwMaximumWindowSize: COORD,\n}\n\n#[allow(non_snake_case)]\n#[link(name = \"kernel32\")]\nextern \"system\" {\n    fn SetConsoleTextAttribute(handle: HANDLE, attr: WORD) -> BOOL;\n    fn GetStdHandle(which: DWORD) -> HANDLE;\n    fn GetConsoleScreenBufferInfo(handle: HANDLE, info: *mut CONSOLE_SCREEN_BUFFER_INFO) -> BOOL;\n}\n\nfn color_to_bits(color: color::Color) -> u16 {\n    // magic numbers from mingw-w64's wincon.h\n\n    let bits = match color % 8 {\n        color::BLACK => 0,\n        color::BLUE => 0x1,\n        color::GREEN => 0x2,\n        color::RED => 0x4,\n        color::YELLOW => 0x2 | 0x4,\n        color::MAGENTA => 0x1 | 0x4,\n        color::CYAN => 0x1 | 0x2,\n        color::WHITE => 0x1 | 0x2 | 0x4,\n        _ => unreachable!(),\n    };\n\n    if color >= 8 { bits | 0x8 } else { bits }\n}\n\nfn bits_to_color(bits: u16) -> color::Color {\n    let color = match bits & 0x7 {\n        0 => color::BLACK,\n        0x1 => color::BLUE,\n        0x2 => color::GREEN,\n        0x4 => color::RED,\n        0x6 => color::YELLOW,\n        0x5 => color::MAGENTA,\n        0x3 => color::CYAN,\n        0x7 => color::WHITE,\n        _ => unreachable!(),\n    };\n\n    color | (u32::from(bits) & 0x8) // copy the hi-intensity bit\n}\n\nimpl<T: Write + Send + 'static> WinConsole<T> {\n    fn apply(&mut self) {\n        let _unused = self.buf.flush();\n        let mut accum: WORD = 0;\n        accum |= color_to_bits(self.foreground);\n        accum |= color_to_bits(self.background) << 4;\n\n        unsafe {\n            // Magic -11 means stdout, from\n            // https://docs.microsoft.com/en-us/windows/console/getstdhandle\n            //\n            // You may be wondering, \"but what about stderr?\", and the answer\n            // to that is that setting terminal attributes on the stdout\n            // handle also sets them for stderr, since they go to the same\n            // terminal! Admittedly, this is fragile, since stderr could be\n            // redirected to a different console. This is good enough for\n            // rustc though. See #13400.\n            let out = GetStdHandle(-11i32 as DWORD);\n            SetConsoleTextAttribute(out, accum);\n        }\n    }\n\n    /// Returns `None` whenever the terminal cannot be created for some reason.\n    pub fn new(out: T) -> io::Result<WinConsole<T>> {\n        use std::mem::MaybeUninit;\n\n        let fg;\n        let bg;\n        unsafe {\n            let mut buffer_info = MaybeUninit::<CONSOLE_SCREEN_BUFFER_INFO>::uninit();\n            if GetConsoleScreenBufferInfo(GetStdHandle(-11i32 as DWORD), buffer_info.as_mut_ptr())\n                != 0\n            {\n                let buffer_info = buffer_info.assume_init();\n                fg = bits_to_color(buffer_info.wAttributes);\n                bg = bits_to_color(buffer_info.wAttributes >> 4);\n            } else {\n                fg = color::WHITE;\n                bg = color::BLACK;\n            }\n        }\n        Ok(WinConsole {\n            buf: out,\n            def_foreground: fg,\n            def_background: bg,\n            foreground: fg,\n            background: bg,\n        })\n    }\n}\n\nimpl<T: Write> Write for WinConsole<T> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.buf.write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.buf.flush()\n    }\n}\n\nimpl<T: Write + Send + 'static> Terminal for WinConsole<T> {\n    type Output = T;\n\n    fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n        self.foreground = color;\n        self.apply();\n\n        Ok(true)\n    }\n\n    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n        self.background = color;\n        self.apply();\n\n        Ok(true)\n    }\n\n    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n        match attr {\n            Attr::ForegroundColor(f) => {\n                self.foreground = f;\n                self.apply();\n                Ok(true)\n            }\n            Attr::BackgroundColor(b) => {\n                self.background = b;\n                self.apply();\n                Ok(true)\n            }\n            _ => Ok(false),\n        }\n    }\n\n    fn supports_attr(&self, attr: Attr) -> bool {\n        // it claims support for underscore and reverse video, but I can't get\n        // it to do anything -cmr\n        match attr {\n            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => true,\n            _ => false,\n        }\n    }\n\n    fn reset(&mut self) -> io::Result<bool> {\n        self.foreground = self.def_foreground;\n        self.background = self.def_background;\n        self.apply();\n\n        Ok(true)\n    }\n\n    fn get_ref(&self) -> &T {\n        &self.buf\n    }\n\n    fn get_mut(&mut self) -> &mut T {\n        &mut self.buf\n    }\n\n    fn into_inner(self) -> T\n    where\n        Self: Sized,\n    {\n        self.buf\n    }\n}\n"],["2606","//! Module converting command-line arguments into test configuration.\n\nuse std::env;\nuse std::path::PathBuf;\n\nuse super::helpers::isatty;\nuse super::options::{ColorConfig, Options, OutputFormat, RunIgnored};\nuse super::time::TestTimeOptions;\n\n#[derive(Debug)]\npub struct TestOpts {\n    pub list: bool,\n    pub filters: Vec<String>,\n    pub filter_exact: bool,\n    pub force_run_in_process: bool,\n    pub exclude_should_panic: bool,\n    pub run_ignored: RunIgnored,\n    pub run_tests: bool,\n    pub bench_benchmarks: bool,\n    pub logfile: Option<PathBuf>,\n    pub nocapture: bool,\n    pub color: ColorConfig,\n    pub format: OutputFormat,\n    pub test_threads: Option<usize>,\n    pub skip: Vec<String>,\n    pub time_options: Option<TestTimeOptions>,\n    pub options: Options,\n}\n\nimpl TestOpts {\n    pub fn use_color(&self) -> bool {\n        match self.color {\n            ColorConfig::AutoColor => !self.nocapture && isatty::stdout_isatty(),\n            ColorConfig::AlwaysColor => true,\n            ColorConfig::NeverColor => false,\n        }\n    }\n}\n\n/// Result of parsing the options.\npub type OptRes = Result<TestOpts, String>;\n/// Result of parsing the option part.\ntype OptPartRes<T> = Result<T, String>;\n\nfn optgroups() -> getopts::Options {\n    let mut opts = getopts::Options::new();\n    opts.optflag(\"\", \"include-ignored\", \"Run ignored and not ignored tests\")\n        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n        .optflag(\"\", \"force-run-in-process\", \"Forces tests to run in-process when panic=abort\")\n        .optflag(\"\", \"exclude-should-panic\", \"Excludes tests marked as should_panic\")\n        .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n        .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n        .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n        .optflag(\"h\", \"help\", \"Display this message\")\n        .optopt(\"\", \"logfile\", \"Write logs to the specified file\", \"PATH\")\n        .optflag(\n            \"\",\n            \"nocapture\",\n            \"don't capture stdout/stderr of each \\\n             task, allow printing directly\",\n        )\n        .optopt(\n            \"\",\n            \"test-threads\",\n            \"Number of threads used for running tests \\\n             in parallel\",\n            \"n_threads\",\n        )\n        .optmulti(\n            \"\",\n            \"skip\",\n            \"Skip tests whose names contain FILTER (this flag can \\\n             be used multiple times)\",\n            \"FILTER\",\n        )\n        .optflag(\n            \"q\",\n            \"quiet\",\n            \"Display one character per test instead of one line. \\\n             Alias to --format=terse\",\n        )\n        .optflag(\"\", \"exact\", \"Exactly match filters rather than by substring\")\n        .optopt(\n            \"\",\n            \"color\",\n            \"Configure coloring of output:\n            auto   = colorize if stdout is a tty and tests are run on serially (default);\n            always = always colorize output;\n            never  = never colorize output;\",\n            \"auto|always|never\",\n        )\n        .optopt(\n            \"\",\n            \"format\",\n            \"Configure formatting of output:\n            pretty = Print verbose output;\n            terse  = Display one character per test;\n            json   = Output a json document;\n            junit  = Output a JUnit document\",\n            \"pretty|terse|json|junit\",\n        )\n        .optflag(\"\", \"show-output\", \"Show captured stdout of successful tests\")\n        .optopt(\n            \"Z\",\n            \"\",\n            \"Enable nightly-only flags:\n            unstable-options = Allow use of experimental features\",\n            \"unstable-options\",\n        )\n        .optflagopt(\n            \"\",\n            \"report-time\",\n            \"Show execution time of each test. Available values:\n            plain   = do not colorize the execution time (default);\n            colored = colorize output according to the `color` parameter value;\n\n            Threshold values for colorized output can be configured via\n            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n            `RUST_TEST_TIME_DOCTEST` environment variables.\n\n            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n            Durations must be specified in milliseconds, e.g. `500,2000` means that the warn time\n            is 0.5 seconds, and the critical time is 2 seconds.\n\n            Not available for --format=terse\",\n            \"plain|colored\",\n        )\n        .optflag(\n            \"\",\n            \"ensure-time\",\n            \"Treat excess of the test execution time limit as error.\n\n            Threshold values for this option can be configured via\n            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n            `RUST_TEST_TIME_DOCTEST` environment variables.\n\n            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n\n            `CRITICAL_TIME` here means the limit that should not be exceeded by test.\n            \",\n        );\n    opts\n}\n\nfn usage(binary: &str, options: &getopts::Options) {\n    let message = format!(\"Usage: {} [OPTIONS] [FILTERS...]\", binary);\n    println!(\n        r#\"{usage}\n\nThe FILTER string is tested against the name of all tests, and only those\ntests whose names contain the filter are run. Multiple filter strings may\nbe passed, which will run all tests matching any of the filters.\n\nBy default, all tests are run in parallel. This can be altered with the\n--test-threads flag or the RUST_TEST_THREADS environment variable when running\ntests (set it to 1).\n\nAll tests have their standard output and standard error captured by default.\nThis can be overridden with the --nocapture flag or setting RUST_TEST_NOCAPTURE\nenvironment variable to a value other than \"0\". Logging is not captured by default.\n\nTest Attributes:\n\n    `#[test]`        - Indicates a function is a test to be run. This function\n                       takes no arguments.\n    `#[bench]`       - Indicates a function is a benchmark to be run. This\n                       function takes one argument (test::Bencher).\n    `#[should_panic]` - This function (also labeled with `#[test]`) will only pass if\n                        the code causes a panic (an assertion failure or panic!)\n                        A message may be provided, which the failure string must\n                        contain: #[should_panic(expected = \"foo\")].\n    `#[ignore]`       - When applied to a function which is already attributed as a\n                        test, then the test runner will ignore these tests during\n                        normal test runs. Running with --ignored or --include-ignored will run\n                        these tests.\"#,\n        usage = options.usage(&message)\n    );\n}\n\n/// Parses command line arguments into test options.\n/// Returns `None` if help was requested (since we only show help message and don't run tests),\n/// returns `Some(Err(..))` if provided arguments are incorrect,\n/// otherwise creates a `TestOpts` object and returns it.\npub fn parse_opts(args: &[String]) -> Option<OptRes> {\n    // Parse matches.\n    let opts = optgroups();\n    let args = args.get(1..).unwrap_or(args);\n    let matches = match opts.parse(args) {\n        Ok(m) => m,\n        Err(f) => return Some(Err(f.to_string())),\n    };\n\n    // Check if help was requested.\n    if matches.opt_present(\"h\") {\n        // Show help and do nothing more.\n        usage(&args[0], &opts);\n        return None;\n    }\n\n    // Actually parse the opts.\n    let opts_result = parse_opts_impl(matches);\n\n    Some(opts_result)\n}\n\n// Gets the option value and checks if unstable features are enabled.\nmacro_rules! unstable_optflag {\n    ($matches:ident, $allow_unstable:ident, $option_name:literal) => {{\n        let opt = $matches.opt_present($option_name);\n        if !$allow_unstable && opt {\n            return Err(format!(\n                \"The \\\"{}\\\" flag is only accepted on the nightly compiler with -Z unstable-options\",\n                $option_name\n            ));\n        }\n\n        opt\n    }};\n}\n\n// Implementation of `parse_opts` that doesn't care about help message\n// and returns a `Result`.\nfn parse_opts_impl(matches: getopts::Matches) -> OptRes {\n    let allow_unstable = get_allow_unstable(&matches)?;\n\n    // Unstable flags\n    let force_run_in_process = unstable_optflag!(matches, allow_unstable, \"force-run-in-process\");\n    let exclude_should_panic = unstable_optflag!(matches, allow_unstable, \"exclude-should-panic\");\n    let time_options = get_time_options(&matches, allow_unstable)?;\n\n    let include_ignored = matches.opt_present(\"include-ignored\");\n    let quiet = matches.opt_present(\"quiet\");\n    let exact = matches.opt_present(\"exact\");\n    let list = matches.opt_present(\"list\");\n    let skip = matches.opt_strs(\"skip\");\n\n    let bench_benchmarks = matches.opt_present(\"bench\");\n    let run_tests = !bench_benchmarks || matches.opt_present(\"test\");\n\n    let logfile = get_log_file(&matches)?;\n    let run_ignored = get_run_ignored(&matches, include_ignored)?;\n    let filters = matches.free.clone();\n    let nocapture = get_nocapture(&matches)?;\n    let test_threads = get_test_threads(&matches)?;\n    let color = get_color_config(&matches)?;\n    let format = get_format(&matches, quiet, allow_unstable)?;\n\n    let options = Options::new().display_output(matches.opt_present(\"show-output\"));\n\n    let test_opts = TestOpts {\n        list,\n        filters,\n        filter_exact: exact,\n        force_run_in_process,\n        exclude_should_panic,\n        run_ignored,\n        run_tests,\n        bench_benchmarks,\n        logfile,\n        nocapture,\n        color,\n        format,\n        test_threads,\n        skip,\n        time_options,\n        options,\n    };\n\n    Ok(test_opts)\n}\n\n// FIXME: Copied from librustc_ast until linkage errors are resolved. Issue #47566\nfn is_nightly() -> bool {\n    // Whether this is a feature-staged build, i.e., on the beta or stable channel\n    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n    // Whether we should enable unstable features for bootstrapping\n    let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n\n    bootstrap || !disable_unstable_features\n}\n\n// Gets the CLI options associated with `report-time` feature.\nfn get_time_options(\n    matches: &getopts::Matches,\n    allow_unstable: bool,\n) -> OptPartRes<Option<TestTimeOptions>> {\n    let report_time = unstable_optflag!(matches, allow_unstable, \"report-time\");\n    let colored_opt_str = matches.opt_str(\"report-time\");\n    let mut report_time_colored = report_time && colored_opt_str == Some(\"colored\".into());\n    let ensure_test_time = unstable_optflag!(matches, allow_unstable, \"ensure-time\");\n\n    // If `ensure-test-time` option is provided, time output is enforced,\n    // so user won't be confused if any of tests will silently fail.\n    let options = if report_time || ensure_test_time {\n        if ensure_test_time && !report_time {\n            report_time_colored = true;\n        }\n        Some(TestTimeOptions::new_from_env(ensure_test_time, report_time_colored))\n    } else {\n        None\n    };\n\n    Ok(options)\n}\n\nfn get_test_threads(matches: &getopts::Matches) -> OptPartRes<Option<usize>> {\n    let test_threads = match matches.opt_str(\"test-threads\") {\n        Some(n_str) => match n_str.parse::<usize>() {\n            Ok(0) => return Err(\"argument for --test-threads must not be 0\".to_string()),\n            Ok(n) => Some(n),\n            Err(e) => {\n                return Err(format!(\n                    \"argument for --test-threads must be a number > 0 \\\n                     (error: {})\",\n                    e\n                ));\n            }\n        },\n        None => None,\n    };\n\n    Ok(test_threads)\n}\n\nfn get_format(\n    matches: &getopts::Matches,\n    quiet: bool,\n    allow_unstable: bool,\n) -> OptPartRes<OutputFormat> {\n    let format = match matches.opt_str(\"format\").as_deref() {\n        None if quiet => OutputFormat::Terse,\n        Some(\"pretty\") | None => OutputFormat::Pretty,\n        Some(\"terse\") => OutputFormat::Terse,\n        Some(\"json\") => {\n            if !allow_unstable {\n                return Err(\"The \\\"json\\\" format is only accepted on the nightly compiler\".into());\n            }\n            OutputFormat::Json\n        }\n        Some(\"junit\") => {\n            if !allow_unstable {\n                return Err(\"The \\\"junit\\\" format is only accepted on the nightly compiler\".into());\n            }\n            OutputFormat::Junit\n        }\n        Some(v) => {\n            return Err(format!(\n                \"argument for --format must be pretty, terse, json or junit (was \\\n                 {})\",\n                v\n            ));\n        }\n    };\n\n    Ok(format)\n}\n\nfn get_color_config(matches: &getopts::Matches) -> OptPartRes<ColorConfig> {\n    let color = match matches.opt_str(\"color\").as_deref() {\n        Some(\"auto\") | None => ColorConfig::AutoColor,\n        Some(\"always\") => ColorConfig::AlwaysColor,\n        Some(\"never\") => ColorConfig::NeverColor,\n\n        Some(v) => {\n            return Err(format!(\n                \"argument for --color must be auto, always, or never (was \\\n                 {})\",\n                v\n            ));\n        }\n    };\n\n    Ok(color)\n}\n\nfn get_nocapture(matches: &getopts::Matches) -> OptPartRes<bool> {\n    let mut nocapture = matches.opt_present(\"nocapture\");\n    if !nocapture {\n        nocapture = match env::var(\"RUST_TEST_NOCAPTURE\") {\n            Ok(val) => &val != \"0\",\n            Err(_) => false,\n        };\n    }\n\n    Ok(nocapture)\n}\n\nfn get_run_ignored(matches: &getopts::Matches, include_ignored: bool) -> OptPartRes<RunIgnored> {\n    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n        (true, true) => {\n            return Err(\"the options --include-ignored and --ignored are mutually exclusive\".into());\n        }\n        (true, false) => RunIgnored::Yes,\n        (false, true) => RunIgnored::Only,\n        (false, false) => RunIgnored::No,\n    };\n\n    Ok(run_ignored)\n}\n\nfn get_allow_unstable(matches: &getopts::Matches) -> OptPartRes<bool> {\n    let mut allow_unstable = false;\n\n    if let Some(opt) = matches.opt_str(\"Z\") {\n        if !is_nightly() {\n            return Err(\"the option `Z` is only accepted on the nightly compiler\".into());\n        }\n\n        match &*opt {\n            \"unstable-options\" => {\n                allow_unstable = true;\n            }\n            _ => {\n                return Err(\"Unrecognized option to `Z`\".into());\n            }\n        }\n    };\n\n    Ok(allow_unstable)\n}\n\nfn get_log_file(matches: &getopts::Matches) -> OptPartRes<Option<PathBuf>> {\n    let logfile = matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s));\n\n    Ok(logfile)\n}\n"],["2607","//! Helper module to detect subprocess exit code.\n\nuse std::process::ExitStatus;\n\n#[cfg(not(unix))]\npub fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n    status.code().ok_or_else(|| \"received no exit code from child process\".into())\n}\n\n#[cfg(unix)]\npub fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n    use std::os::unix::process::ExitStatusExt;\n    match status.code() {\n        Some(code) => Ok(code),\n        None => match status.signal() {\n            Some(signal) => Err(format!(\"child process exited with signal {}\", signal)),\n            None => Err(\"child process exited with unknown signal\".into()),\n        },\n    }\n}\n"],["2608","//! Module with common helpers not directly related to tests\n//! but used in `libtest`.\n\npub mod concurrency;\npub mod exit_code;\npub mod isatty;\npub mod metrics;\n"],["2609","//! Benchmark metrics.\nuse std::collections::BTreeMap;\n\n#[derive(Clone, PartialEq, Debug, Copy)]\npub struct Metric {\n    value: f64,\n    noise: f64,\n}\n\nimpl Metric {\n    pub fn new(value: f64, noise: f64) -> Metric {\n        Metric { value, noise }\n    }\n}\n\n#[derive(Clone, PartialEq)]\npub struct MetricMap(BTreeMap<String, Metric>);\n\nimpl MetricMap {\n    pub fn new() -> MetricMap {\n        MetricMap(BTreeMap::new())\n    }\n\n    /// Insert a named `value` (+/- `noise`) metric into the map. The value\n    /// must be non-negative. The `noise` indicates the uncertainty of the\n    /// metric, which doubles as the \"noise range\" of acceptable\n    /// pairwise-regressions on this named value, when comparing from one\n    /// metric to the next using `compare_to_old`.\n    ///\n    /// If `noise` is positive, then it means this metric is of a value\n    /// you want to see grow smaller, so a change larger than `noise` in the\n    /// positive direction represents a regression.\n    ///\n    /// If `noise` is negative, then it means this metric is of a value\n    /// you want to see grow larger, so a change larger than `noise` in the\n    /// negative direction represents a regression.\n    pub fn insert_metric(&mut self, name: &str, value: f64, noise: f64) {\n        let m = Metric { value, noise };\n        self.0.insert(name.to_owned(), m);\n    }\n\n    pub fn fmt_metrics(&self) -> String {\n        let v = self\n            .0\n            .iter()\n            .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n            .collect::<Vec<_>>();\n        v.join(\", \")\n    }\n}\n"],["2610","//! Helper module which provides a function to test\n//! if stdout is a tty.\n\ncfg_if::cfg_if! {\n    if #[cfg(unix)] {\n        pub fn stdout_isatty() -> bool {\n            unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n        }\n    } else if #[cfg(windows)] {\n        pub fn stdout_isatty() -> bool {\n            type DWORD = u32;\n            type BOOL = i32;\n            type HANDLE = *mut u8;\n            type LPDWORD = *mut u32;\n            const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n            extern \"system\" {\n                fn GetStdHandle(which: DWORD) -> HANDLE;\n                fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n            }\n            unsafe {\n                let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n                let mut out = 0;\n                GetConsoleMode(handle, &mut out) != 0\n            }\n        }\n    } else {\n        // FIXME: Implement isatty on SGX\n        pub fn stdout_isatty() -> bool {\n            false\n        }\n    }\n}\n"],["2611","//! Helper module which helps to determine amount of threads to be used\n//! during tests execution.\nuse std::{env, num::NonZeroUsize, thread};\n\npub fn get_concurrency() -> usize {\n    if let Ok(value) = env::var(\"RUST_TEST_THREADS\") {\n        match value.parse::<NonZeroUsize>().ok() {\n            Some(n) => n.get(),\n            _ => panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\", value),\n        }\n    } else {\n        thread::available_concurrency().map(|n| n.get()).unwrap_or(1)\n    }\n}\n"],["2612","//! Module providing interface for running tests in the console.\n\nuse std::fs::File;\nuse std::io;\nuse std::io::prelude::Write;\nuse std::time::Instant;\n\nuse super::{\n    bench::fmt_bench_samples,\n    cli::TestOpts,\n    event::{CompletedTest, TestEvent},\n    filter_tests,\n    formatters::{JsonFormatter, JunitFormatter, OutputFormatter, PrettyFormatter, TerseFormatter},\n    helpers::{concurrency::get_concurrency, metrics::MetricMap},\n    options::{Options, OutputFormat},\n    run_tests,\n    test_result::TestResult,\n    time::{TestExecTime, TestSuiteExecTime},\n    types::{NamePadding, TestDesc, TestDescAndFn},\n};\n\n/// Generic wrapper over stdout.\npub enum OutputLocation<T> {\n    Pretty(Box<term::StdoutTerminal>),\n    Raw(T),\n}\n\nimpl<T: Write> Write for OutputLocation<T> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        match *self {\n            OutputLocation::Pretty(ref mut term) => term.write(buf),\n            OutputLocation::Raw(ref mut stdout) => stdout.write(buf),\n        }\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        match *self {\n            OutputLocation::Pretty(ref mut term) => term.flush(),\n            OutputLocation::Raw(ref mut stdout) => stdout.flush(),\n        }\n    }\n}\n\npub struct ConsoleTestState {\n    pub log_out: Option<File>,\n    pub total: usize,\n    pub passed: usize,\n    pub failed: usize,\n    pub ignored: usize,\n    pub allowed_fail: usize,\n    pub filtered_out: usize,\n    pub measured: usize,\n    pub exec_time: Option<TestSuiteExecTime>,\n    pub metrics: MetricMap,\n    pub failures: Vec<(TestDesc, Vec<u8>)>,\n    pub not_failures: Vec<(TestDesc, Vec<u8>)>,\n    pub time_failures: Vec<(TestDesc, Vec<u8>)>,\n    pub options: Options,\n}\n\nimpl ConsoleTestState {\n    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestState> {\n        let log_out = match opts.logfile {\n            Some(ref path) => Some(File::create(path)?),\n            None => None,\n        };\n\n        Ok(ConsoleTestState {\n            log_out,\n            total: 0,\n            passed: 0,\n            failed: 0,\n            ignored: 0,\n            allowed_fail: 0,\n            filtered_out: 0,\n            measured: 0,\n            exec_time: None,\n            metrics: MetricMap::new(),\n            failures: Vec::new(),\n            not_failures: Vec::new(),\n            time_failures: Vec::new(),\n            options: opts.options,\n        })\n    }\n\n    pub fn write_log<F, S>(&mut self, msg: F) -> io::Result<()>\n    where\n        S: AsRef<str>,\n        F: FnOnce() -> S,\n    {\n        match self.log_out {\n            None => Ok(()),\n            Some(ref mut o) => {\n                let msg = msg();\n                let msg = msg.as_ref();\n                o.write_all(msg.as_bytes())\n            }\n        }\n    }\n\n    pub fn write_log_result(\n        &mut self,\n        test: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&TestExecTime>,\n    ) -> io::Result<()> {\n        self.write_log(|| {\n            format!(\n                \"{} {}\",\n                match *result {\n                    TestResult::TrOk => \"ok\".to_owned(),\n                    TestResult::TrFailed => \"failed\".to_owned(),\n                    TestResult::TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n                    TestResult::TrIgnored => \"ignored\".to_owned(),\n                    TestResult::TrAllowedFail => \"failed (allowed)\".to_owned(),\n                    TestResult::TrBench(ref bs) => fmt_bench_samples(bs),\n                    TestResult::TrTimedFail => \"failed (time limit exceeded)\".to_owned(),\n                },\n                test.name,\n            )\n        })?;\n        if let Some(exec_time) = exec_time {\n            self.write_log(|| format!(\" <{}>\", exec_time))?;\n        }\n        self.write_log(|| \"\\n\")\n    }\n\n    fn current_test_count(&self) -> usize {\n        self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n    }\n}\n\n// List the tests to console, and optionally to logfile. Filters are honored.\npub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n    let mut output = match term::stdout() {\n        None => OutputLocation::Raw(io::stdout()),\n        Some(t) => OutputLocation::Pretty(t),\n    };\n\n    let quiet = opts.format == OutputFormat::Terse;\n    let mut st = ConsoleTestState::new(opts)?;\n\n    let mut ntest = 0;\n    let mut nbench = 0;\n\n    for test in filter_tests(&opts, tests) {\n        use crate::TestFn::*;\n\n        let TestDescAndFn { desc: TestDesc { name, .. }, testfn } = test;\n\n        let fntype = match testfn {\n            StaticTestFn(..) | DynTestFn(..) => {\n                ntest += 1;\n                \"test\"\n            }\n            StaticBenchFn(..) | DynBenchFn(..) => {\n                nbench += 1;\n                \"benchmark\"\n            }\n        };\n\n        writeln!(output, \"{}: {}\", name, fntype)?;\n        st.write_log(|| format!(\"{} {}\\n\", fntype, name))?;\n    }\n\n    fn plural(count: u32, s: &str) -> String {\n        match count {\n            1 => format!(\"{} {}\", 1, s),\n            n => format!(\"{} {}s\", n, s),\n        }\n    }\n\n    if !quiet {\n        if ntest != 0 || nbench != 0 {\n            writeln!(output)?;\n        }\n\n        writeln!(output, \"{}, {}\", plural(ntest, \"test\"), plural(nbench, \"benchmark\"))?;\n    }\n\n    Ok(())\n}\n\n// Updates `ConsoleTestState` depending on result of the test execution.\nfn handle_test_result(st: &mut ConsoleTestState, completed_test: CompletedTest) {\n    let test = completed_test.desc;\n    let stdout = completed_test.stdout;\n    match completed_test.result {\n        TestResult::TrOk => {\n            st.passed += 1;\n            st.not_failures.push((test, stdout));\n        }\n        TestResult::TrIgnored => st.ignored += 1,\n        TestResult::TrAllowedFail => st.allowed_fail += 1,\n        TestResult::TrBench(bs) => {\n            st.metrics.insert_metric(\n                test.name.as_slice(),\n                bs.ns_iter_summ.median,\n                bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n            );\n            st.measured += 1\n        }\n        TestResult::TrFailed => {\n            st.failed += 1;\n            st.failures.push((test, stdout));\n        }\n        TestResult::TrFailedMsg(msg) => {\n            st.failed += 1;\n            let mut stdout = stdout;\n            stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n            st.failures.push((test, stdout));\n        }\n        TestResult::TrTimedFail => {\n            st.failed += 1;\n            st.time_failures.push((test, stdout));\n        }\n    }\n}\n\n// Handler for events that occur during test execution.\n// It is provided as a callback to the `run_tests` function.\nfn on_test_event(\n    event: &TestEvent,\n    st: &mut ConsoleTestState,\n    out: &mut dyn OutputFormatter,\n) -> io::Result<()> {\n    match (*event).clone() {\n        TestEvent::TeFiltered(ref filtered_tests) => {\n            st.total = filtered_tests.len();\n            out.write_run_start(filtered_tests.len())?;\n        }\n        TestEvent::TeFilteredOut(filtered_out) => {\n            st.filtered_out = filtered_out;\n        }\n        TestEvent::TeWait(ref test) => out.write_test_start(test)?,\n        TestEvent::TeTimeout(ref test) => out.write_timeout(test)?,\n        TestEvent::TeResult(completed_test) => {\n            let test = &completed_test.desc;\n            let result = &completed_test.result;\n            let exec_time = &completed_test.exec_time;\n            let stdout = &completed_test.stdout;\n\n            st.write_log_result(test, result, exec_time.as_ref())?;\n            out.write_result(test, result, exec_time.as_ref(), &*stdout, st)?;\n            handle_test_result(st, completed_test);\n        }\n    }\n\n    Ok(())\n}\n\n/// A simple console test runner.\n/// Runs provided tests reporting process and results to the stdout.\npub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n    let output = match term::stdout() {\n        None => OutputLocation::Raw(io::stdout()),\n        Some(t) => OutputLocation::Pretty(t),\n    };\n\n    let max_name_len = tests\n        .iter()\n        .max_by_key(|t| len_if_padded(*t))\n        .map(|t| t.desc.name.as_slice().len())\n        .unwrap_or(0);\n\n    let is_multithreaded = opts.test_threads.unwrap_or_else(get_concurrency) > 1;\n\n    let mut out: Box<dyn OutputFormatter> = match opts.format {\n        OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n            output,\n            opts.use_color(),\n            max_name_len,\n            is_multithreaded,\n            opts.time_options,\n        )),\n        OutputFormat::Terse => {\n            Box::new(TerseFormatter::new(output, opts.use_color(), max_name_len, is_multithreaded))\n        }\n        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n        OutputFormat::Junit => Box::new(JunitFormatter::new(output)),\n    };\n    let mut st = ConsoleTestState::new(opts)?;\n\n    // Prevent the usage of `Instant` in some cases:\n    // - It's currently not supported for wasm targets.\n    // - We disable it for miri because it's not available when isolation is enabled.\n    let is_instant_supported = !cfg!(target_arch = \"wasm32\") && !cfg!(miri);\n\n    let start_time = is_instant_supported.then(Instant::now);\n    run_tests(opts, tests, |x| on_test_event(&x, &mut st, &mut *out))?;\n    st.exec_time = start_time.map(|t| TestSuiteExecTime(t.elapsed()));\n\n    assert!(st.current_test_count() == st.total);\n\n    out.write_run_finish(&st)\n}\n\n// Calculates padding for given test description.\nfn len_if_padded(t: &TestDescAndFn) -> usize {\n    match t.testfn.padding() {\n        NamePadding::PadNone => 0,\n        NamePadding::PadOnRight => t.desc.name.as_slice().len(),\n    }\n}\n"],["2613","use super::*;\n\nextern crate test;\nuse self::test::test::Bencher;\nuse std::io;\nuse std::io::prelude::*;\n\n// Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n\nmacro_rules! assert_approx_eq {\n    ($a: expr, $b: expr) => {{\n        let (a, b) = (&$a, &$b);\n        assert!((*a - *b).abs() < 1.0e-6, \"{} is not approximately equal to {}\", *a, *b);\n    }};\n}\n\nfn check(samples: &[f64], summ: &Summary) {\n    let summ2 = Summary::new(samples);\n\n    let mut w = io::sink();\n    let w = &mut w;\n    (write!(w, \"\\n\")).unwrap();\n\n    assert_eq!(summ.sum, summ2.sum);\n    assert_eq!(summ.min, summ2.min);\n    assert_eq!(summ.max, summ2.max);\n    assert_eq!(summ.mean, summ2.mean);\n    assert_eq!(summ.median, summ2.median);\n\n    // We needed a few more digits to get exact equality on these\n    // but they're within float epsilon, which is 1.0e-6.\n    assert_approx_eq!(summ.var, summ2.var);\n    assert_approx_eq!(summ.std_dev, summ2.std_dev);\n    assert_approx_eq!(summ.std_dev_pct, summ2.std_dev_pct);\n    assert_approx_eq!(summ.median_abs_dev, summ2.median_abs_dev);\n    assert_approx_eq!(summ.median_abs_dev_pct, summ2.median_abs_dev_pct);\n\n    assert_eq!(summ.quartiles, summ2.quartiles);\n    assert_eq!(summ.iqr, summ2.iqr);\n}\n\n#[test]\nfn test_min_max_nan() {\n    let xs = &[1.0, 2.0, f64::NAN, 3.0, 4.0];\n    let summary = Summary::new(xs);\n    assert_eq!(summary.min, 1.0);\n    assert_eq!(summary.max, 4.0);\n}\n\n#[test]\nfn test_norm2() {\n    let val = &[958.0000000000, 924.0000000000];\n    let summ = &Summary {\n        sum: 1882.0000000000,\n        min: 924.0000000000,\n        max: 958.0000000000,\n        mean: 941.0000000000,\n        median: 941.0000000000,\n        var: 578.0000000000,\n        std_dev: 24.0416305603,\n        std_dev_pct: 2.5549022912,\n        median_abs_dev: 25.2042000000,\n        median_abs_dev_pct: 2.6784484591,\n        quartiles: (932.5000000000, 941.0000000000, 949.5000000000),\n        iqr: 17.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_norm10narrow() {\n    let val = &[\n        966.0000000000,\n        985.0000000000,\n        1110.0000000000,\n        848.0000000000,\n        821.0000000000,\n        975.0000000000,\n        962.0000000000,\n        1157.0000000000,\n        1217.0000000000,\n        955.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 9996.0000000000,\n        min: 821.0000000000,\n        max: 1217.0000000000,\n        mean: 999.6000000000,\n        median: 970.5000000000,\n        var: 16050.7111111111,\n        std_dev: 126.6914010938,\n        std_dev_pct: 12.6742097933,\n        median_abs_dev: 102.2994000000,\n        median_abs_dev_pct: 10.5408964451,\n        quartiles: (956.7500000000, 970.5000000000, 1078.7500000000),\n        iqr: 122.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_norm10medium() {\n    let val = &[\n        954.0000000000,\n        1064.0000000000,\n        855.0000000000,\n        1000.0000000000,\n        743.0000000000,\n        1084.0000000000,\n        704.0000000000,\n        1023.0000000000,\n        357.0000000000,\n        869.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 8653.0000000000,\n        min: 357.0000000000,\n        max: 1084.0000000000,\n        mean: 865.3000000000,\n        median: 911.5000000000,\n        var: 48628.4555555556,\n        std_dev: 220.5186059170,\n        std_dev_pct: 25.4846418487,\n        median_abs_dev: 195.7032000000,\n        median_abs_dev_pct: 21.4704552935,\n        quartiles: (771.0000000000, 911.5000000000, 1017.2500000000),\n        iqr: 246.2500000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_norm10wide() {\n    let val = &[\n        505.0000000000,\n        497.0000000000,\n        1591.0000000000,\n        887.0000000000,\n        1026.0000000000,\n        136.0000000000,\n        1580.0000000000,\n        940.0000000000,\n        754.0000000000,\n        1433.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 9349.0000000000,\n        min: 136.0000000000,\n        max: 1591.0000000000,\n        mean: 934.9000000000,\n        median: 913.5000000000,\n        var: 239208.9888888889,\n        std_dev: 489.0899599142,\n        std_dev_pct: 52.3146817750,\n        median_abs_dev: 611.5725000000,\n        median_abs_dev_pct: 66.9482758621,\n        quartiles: (567.2500000000, 913.5000000000, 1331.2500000000),\n        iqr: 764.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_norm25verynarrow() {\n    let val = &[\n        991.0000000000,\n        1018.0000000000,\n        998.0000000000,\n        1013.0000000000,\n        974.0000000000,\n        1007.0000000000,\n        1014.0000000000,\n        999.0000000000,\n        1011.0000000000,\n        978.0000000000,\n        985.0000000000,\n        999.0000000000,\n        983.0000000000,\n        982.0000000000,\n        1015.0000000000,\n        1002.0000000000,\n        977.0000000000,\n        948.0000000000,\n        1040.0000000000,\n        974.0000000000,\n        996.0000000000,\n        989.0000000000,\n        1015.0000000000,\n        994.0000000000,\n        1024.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 24926.0000000000,\n        min: 948.0000000000,\n        max: 1040.0000000000,\n        mean: 997.0400000000,\n        median: 998.0000000000,\n        var: 393.2066666667,\n        std_dev: 19.8294393937,\n        std_dev_pct: 1.9888308788,\n        median_abs_dev: 22.2390000000,\n        median_abs_dev_pct: 2.2283567134,\n        quartiles: (983.0000000000, 998.0000000000, 1013.0000000000),\n        iqr: 30.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_exp10a() {\n    let val = &[\n        23.0000000000,\n        11.0000000000,\n        2.0000000000,\n        57.0000000000,\n        4.0000000000,\n        12.0000000000,\n        5.0000000000,\n        29.0000000000,\n        3.0000000000,\n        21.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 167.0000000000,\n        min: 2.0000000000,\n        max: 57.0000000000,\n        mean: 16.7000000000,\n        median: 11.5000000000,\n        var: 287.7888888889,\n        std_dev: 16.9643416875,\n        std_dev_pct: 101.5828843560,\n        median_abs_dev: 13.3434000000,\n        median_abs_dev_pct: 116.0295652174,\n        quartiles: (4.2500000000, 11.5000000000, 22.5000000000),\n        iqr: 18.2500000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_exp10b() {\n    let val = &[\n        24.0000000000,\n        17.0000000000,\n        6.0000000000,\n        38.0000000000,\n        25.0000000000,\n        7.0000000000,\n        51.0000000000,\n        2.0000000000,\n        61.0000000000,\n        32.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 263.0000000000,\n        min: 2.0000000000,\n        max: 61.0000000000,\n        mean: 26.3000000000,\n        median: 24.5000000000,\n        var: 383.5666666667,\n        std_dev: 19.5848580967,\n        std_dev_pct: 74.4671410520,\n        median_abs_dev: 22.9803000000,\n        median_abs_dev_pct: 93.7971428571,\n        quartiles: (9.5000000000, 24.5000000000, 36.5000000000),\n        iqr: 27.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_exp10c() {\n    let val = &[\n        71.0000000000,\n        2.0000000000,\n        32.0000000000,\n        1.0000000000,\n        6.0000000000,\n        28.0000000000,\n        13.0000000000,\n        37.0000000000,\n        16.0000000000,\n        36.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 242.0000000000,\n        min: 1.0000000000,\n        max: 71.0000000000,\n        mean: 24.2000000000,\n        median: 22.0000000000,\n        var: 458.1777777778,\n        std_dev: 21.4050876611,\n        std_dev_pct: 88.4507754589,\n        median_abs_dev: 21.4977000000,\n        median_abs_dev_pct: 97.7168181818,\n        quartiles: (7.7500000000, 22.0000000000, 35.0000000000),\n        iqr: 27.2500000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_exp25() {\n    let val = &[\n        3.0000000000,\n        24.0000000000,\n        1.0000000000,\n        19.0000000000,\n        7.0000000000,\n        5.0000000000,\n        30.0000000000,\n        39.0000000000,\n        31.0000000000,\n        13.0000000000,\n        25.0000000000,\n        48.0000000000,\n        1.0000000000,\n        6.0000000000,\n        42.0000000000,\n        63.0000000000,\n        2.0000000000,\n        12.0000000000,\n        108.0000000000,\n        26.0000000000,\n        1.0000000000,\n        7.0000000000,\n        44.0000000000,\n        25.0000000000,\n        11.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 593.0000000000,\n        min: 1.0000000000,\n        max: 108.0000000000,\n        mean: 23.7200000000,\n        median: 19.0000000000,\n        var: 601.0433333333,\n        std_dev: 24.5161851301,\n        std_dev_pct: 103.3565983562,\n        median_abs_dev: 19.2738000000,\n        median_abs_dev_pct: 101.4410526316,\n        quartiles: (6.0000000000, 19.0000000000, 31.0000000000),\n        iqr: 25.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_binom25() {\n    let val = &[\n        18.0000000000,\n        17.0000000000,\n        27.0000000000,\n        15.0000000000,\n        21.0000000000,\n        25.0000000000,\n        17.0000000000,\n        24.0000000000,\n        25.0000000000,\n        24.0000000000,\n        26.0000000000,\n        26.0000000000,\n        23.0000000000,\n        15.0000000000,\n        23.0000000000,\n        17.0000000000,\n        18.0000000000,\n        18.0000000000,\n        21.0000000000,\n        16.0000000000,\n        15.0000000000,\n        31.0000000000,\n        20.0000000000,\n        17.0000000000,\n        15.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 514.0000000000,\n        min: 15.0000000000,\n        max: 31.0000000000,\n        mean: 20.5600000000,\n        median: 20.0000000000,\n        var: 20.8400000000,\n        std_dev: 4.5650848842,\n        std_dev_pct: 22.2037202539,\n        median_abs_dev: 5.9304000000,\n        median_abs_dev_pct: 29.6520000000,\n        quartiles: (17.0000000000, 20.0000000000, 24.0000000000),\n        iqr: 7.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_pois25lambda30() {\n    let val = &[\n        27.0000000000,\n        33.0000000000,\n        34.0000000000,\n        34.0000000000,\n        24.0000000000,\n        39.0000000000,\n        28.0000000000,\n        27.0000000000,\n        31.0000000000,\n        28.0000000000,\n        38.0000000000,\n        21.0000000000,\n        33.0000000000,\n        36.0000000000,\n        29.0000000000,\n        37.0000000000,\n        32.0000000000,\n        34.0000000000,\n        31.0000000000,\n        39.0000000000,\n        25.0000000000,\n        31.0000000000,\n        32.0000000000,\n        40.0000000000,\n        24.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 787.0000000000,\n        min: 21.0000000000,\n        max: 40.0000000000,\n        mean: 31.4800000000,\n        median: 32.0000000000,\n        var: 26.5933333333,\n        std_dev: 5.1568724372,\n        std_dev_pct: 16.3814245145,\n        median_abs_dev: 5.9304000000,\n        median_abs_dev_pct: 18.5325000000,\n        quartiles: (28.0000000000, 32.0000000000, 34.0000000000),\n        iqr: 6.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_pois25lambda40() {\n    let val = &[\n        42.0000000000,\n        50.0000000000,\n        42.0000000000,\n        46.0000000000,\n        34.0000000000,\n        45.0000000000,\n        34.0000000000,\n        49.0000000000,\n        39.0000000000,\n        28.0000000000,\n        40.0000000000,\n        35.0000000000,\n        37.0000000000,\n        39.0000000000,\n        46.0000000000,\n        44.0000000000,\n        32.0000000000,\n        45.0000000000,\n        42.0000000000,\n        37.0000000000,\n        48.0000000000,\n        42.0000000000,\n        33.0000000000,\n        42.0000000000,\n        48.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 1019.0000000000,\n        min: 28.0000000000,\n        max: 50.0000000000,\n        mean: 40.7600000000,\n        median: 42.0000000000,\n        var: 34.4400000000,\n        std_dev: 5.8685603004,\n        std_dev_pct: 14.3978417577,\n        median_abs_dev: 5.9304000000,\n        median_abs_dev_pct: 14.1200000000,\n        quartiles: (37.0000000000, 42.0000000000, 45.0000000000),\n        iqr: 8.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_pois25lambda50() {\n    let val = &[\n        45.0000000000,\n        43.0000000000,\n        44.0000000000,\n        61.0000000000,\n        51.0000000000,\n        53.0000000000,\n        59.0000000000,\n        52.0000000000,\n        49.0000000000,\n        51.0000000000,\n        51.0000000000,\n        50.0000000000,\n        49.0000000000,\n        56.0000000000,\n        42.0000000000,\n        52.0000000000,\n        51.0000000000,\n        43.0000000000,\n        48.0000000000,\n        48.0000000000,\n        50.0000000000,\n        42.0000000000,\n        43.0000000000,\n        42.0000000000,\n        60.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 1235.0000000000,\n        min: 42.0000000000,\n        max: 61.0000000000,\n        mean: 49.4000000000,\n        median: 50.0000000000,\n        var: 31.6666666667,\n        std_dev: 5.6273143387,\n        std_dev_pct: 11.3913245723,\n        median_abs_dev: 4.4478000000,\n        median_abs_dev_pct: 8.8956000000,\n        quartiles: (44.0000000000, 50.0000000000, 52.0000000000),\n        iqr: 8.0000000000,\n    };\n    check(val, summ);\n}\n#[test]\nfn test_unif25() {\n    let val = &[\n        99.0000000000,\n        55.0000000000,\n        92.0000000000,\n        79.0000000000,\n        14.0000000000,\n        2.0000000000,\n        33.0000000000,\n        49.0000000000,\n        3.0000000000,\n        32.0000000000,\n        84.0000000000,\n        59.0000000000,\n        22.0000000000,\n        86.0000000000,\n        76.0000000000,\n        31.0000000000,\n        29.0000000000,\n        11.0000000000,\n        41.0000000000,\n        53.0000000000,\n        45.0000000000,\n        44.0000000000,\n        98.0000000000,\n        98.0000000000,\n        7.0000000000,\n    ];\n    let summ = &Summary {\n        sum: 1242.0000000000,\n        min: 2.0000000000,\n        max: 99.0000000000,\n        mean: 49.6800000000,\n        median: 45.0000000000,\n        var: 1015.6433333333,\n        std_dev: 31.8691595957,\n        std_dev_pct: 64.1488719719,\n        median_abs_dev: 45.9606000000,\n        median_abs_dev_pct: 102.1346666667,\n        quartiles: (29.0000000000, 45.0000000000, 79.0000000000),\n        iqr: 50.0000000000,\n    };\n    check(val, summ);\n}\n\n#[test]\nfn test_sum_f64s() {\n    assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(), 5.2999);\n}\n#[test]\nfn test_sum_f64_between_ints_that_sum_to_0() {\n    assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n}\n\n#[bench]\npub fn sum_three_items(b: &mut Bencher) {\n    b.iter(|| {\n        [1e20f64, 1.5f64, -1e20f64].sum();\n    })\n}\n#[bench]\npub fn sum_many_f64(b: &mut Bencher) {\n    let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n    let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n\n    b.iter(|| {\n        v.sum();\n    })\n}\n\n#[bench]\npub fn no_iter(_: &mut Bencher) {}\n"],["2614","#![allow(missing_docs)]\n#![allow(deprecated)] // Float\n\nuse std::mem;\n\n#[cfg(test)]\nmod tests;\n\nfn local_sort(v: &mut [f64]) {\n    v.sort_by(|x: &f64, y: &f64| x.total_cmp(y));\n}\n\n/// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\npub trait Stats {\n    /// Sum of the samples.\n    ///\n    /// Note: this method sacrifices performance at the altar of accuracy\n    /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n    /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric\n    /// Predicates\"][paper]\n    ///\n    /// [paper]: http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps\n    fn sum(&self) -> f64;\n\n    /// Minimum value of the samples.\n    fn min(&self) -> f64;\n\n    /// Maximum value of the samples.\n    fn max(&self) -> f64;\n\n    /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Arithmetic_mean>\n    fn mean(&self) -> f64;\n\n    /// Median of the samples: value separating the lower half of the samples from the higher half.\n    /// Equal to `self.percentile(50.0)`.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Median>\n    fn median(&self) -> f64;\n\n    /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n    /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n    /// population variance, which is assumed to be unknown. It therefore corrects the `(n-1)/n`\n    /// bias that would appear if we calculated a population variance, by dividing by `(n-1)` rather\n    /// than `n`.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Variance>\n    fn var(&self) -> f64;\n\n    /// Standard deviation: the square root of the sample variance.\n    ///\n    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n    /// `median_abs_dev` for unknown distributions.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Standard_deviation>\n    fn std_dev(&self) -> f64;\n\n    /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n    ///\n    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n    /// `median_abs_dev_pct` for unknown distributions.\n    fn std_dev_pct(&self) -> f64;\n\n    /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n    /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n    /// `std_dev` if you cannot assume your sample is normally distributed. Note that this is scaled\n    /// by the constant `1.4826` to allow its use as a consistent estimator for the standard\n    /// deviation.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Median_absolute_deviation>\n    fn median_abs_dev(&self) -> f64;\n\n    /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n    fn median_abs_dev_pct(&self) -> f64;\n\n    /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n    /// percentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\n    /// satisfy `s <= v`.\n    ///\n    /// Calculated by linear interpolation between closest ranks.\n    ///\n    /// See: <https://en.wikipedia.org/wiki/Percentile>\n    fn percentile(&self, pct: f64) -> f64;\n\n    /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n    /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n    /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n    /// is otherwise equivalent.\n    ///\n    /// See also: <https://en.wikipedia.org/wiki/Quartile>\n    fn quartiles(&self) -> (f64, f64, f64);\n\n    /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n    /// percentile (3rd quartile). See `quartiles`.\n    ///\n    /// See also: <https://en.wikipedia.org/wiki/Interquartile_range>\n    fn iqr(&self) -> f64;\n}\n\n/// Extracted collection of all the summary statistics of a sample set.\n#[derive(Debug, Clone, PartialEq, Copy)]\n#[allow(missing_docs)]\npub struct Summary {\n    pub sum: f64,\n    pub min: f64,\n    pub max: f64,\n    pub mean: f64,\n    pub median: f64,\n    pub var: f64,\n    pub std_dev: f64,\n    pub std_dev_pct: f64,\n    pub median_abs_dev: f64,\n    pub median_abs_dev_pct: f64,\n    pub quartiles: (f64, f64, f64),\n    pub iqr: f64,\n}\n\nimpl Summary {\n    /// Construct a new summary of a sample set.\n    pub fn new(samples: &[f64]) -> Summary {\n        Summary {\n            sum: samples.sum(),\n            min: samples.min(),\n            max: samples.max(),\n            mean: samples.mean(),\n            median: samples.median(),\n            var: samples.var(),\n            std_dev: samples.std_dev(),\n            std_dev_pct: samples.std_dev_pct(),\n            median_abs_dev: samples.median_abs_dev(),\n            median_abs_dev_pct: samples.median_abs_dev_pct(),\n            quartiles: samples.quartiles(),\n            iqr: samples.iqr(),\n        }\n    }\n}\n\nimpl Stats for [f64] {\n    // FIXME #11059 handle NaN, inf and overflow\n    fn sum(&self) -> f64 {\n        let mut partials = vec![];\n\n        for &x in self {\n            let mut x = x;\n            let mut j = 0;\n            // This inner loop applies `hi`/`lo` summation to each\n            // partial so that the list of partial sums remains exact.\n            for i in 0..partials.len() {\n                let mut y: f64 = partials[i];\n                if x.abs() < y.abs() {\n                    mem::swap(&mut x, &mut y);\n                }\n                // Rounded `x+y` is stored in `hi` with round-off stored in\n                // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n                let hi = x + y;\n                let lo = y - (hi - x);\n                if lo != 0.0 {\n                    partials[j] = lo;\n                    j += 1;\n                }\n                x = hi;\n            }\n            if j >= partials.len() {\n                partials.push(x);\n            } else {\n                partials[j] = x;\n                partials.truncate(j + 1);\n            }\n        }\n        let zero: f64 = 0.0;\n        partials.iter().fold(zero, |p, q| p + *q)\n    }\n\n    fn min(&self) -> f64 {\n        assert!(!self.is_empty());\n        self.iter().fold(self[0], |p, q| p.min(*q))\n    }\n\n    fn max(&self) -> f64 {\n        assert!(!self.is_empty());\n        self.iter().fold(self[0], |p, q| p.max(*q))\n    }\n\n    fn mean(&self) -> f64 {\n        assert!(!self.is_empty());\n        self.sum() / (self.len() as f64)\n    }\n\n    fn median(&self) -> f64 {\n        self.percentile(50_f64)\n    }\n\n    fn var(&self) -> f64 {\n        if self.len() < 2 {\n            0.0\n        } else {\n            let mean = self.mean();\n            let mut v: f64 = 0.0;\n            for s in self {\n                let x = *s - mean;\n                v += x * x;\n            }\n            // N.B., this is _supposed to be_ len-1, not len. If you\n            // change it back to len, you will be calculating a\n            // population variance, not a sample variance.\n            let denom = (self.len() - 1) as f64;\n            v / denom\n        }\n    }\n\n    fn std_dev(&self) -> f64 {\n        self.var().sqrt()\n    }\n\n    fn std_dev_pct(&self) -> f64 {\n        let hundred = 100_f64;\n        (self.std_dev() / self.mean()) * hundred\n    }\n\n    fn median_abs_dev(&self) -> f64 {\n        let med = self.median();\n        let abs_devs: Vec<f64> = self.iter().map(|&v| (med - v).abs()).collect();\n        // This constant is derived by smarter statistics brains than me, but it is\n        // consistent with how R and other packages treat the MAD.\n        let number = 1.4826;\n        abs_devs.median() * number\n    }\n\n    fn median_abs_dev_pct(&self) -> f64 {\n        let hundred = 100_f64;\n        (self.median_abs_dev() / self.median()) * hundred\n    }\n\n    fn percentile(&self, pct: f64) -> f64 {\n        let mut tmp = self.to_vec();\n        local_sort(&mut tmp);\n        percentile_of_sorted(&tmp, pct)\n    }\n\n    fn quartiles(&self) -> (f64, f64, f64) {\n        let mut tmp = self.to_vec();\n        local_sort(&mut tmp);\n        let first = 25_f64;\n        let a = percentile_of_sorted(&tmp, first);\n        let second = 50_f64;\n        let b = percentile_of_sorted(&tmp, second);\n        let third = 75_f64;\n        let c = percentile_of_sorted(&tmp, third);\n        (a, b, c)\n    }\n\n    fn iqr(&self) -> f64 {\n        let (a, _, c) = self.quartiles();\n        c - a\n    }\n}\n\n// Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n// linear interpolation. If samples are not sorted, return nonsensical value.\nfn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n    assert!(!sorted_samples.is_empty());\n    if sorted_samples.len() == 1 {\n        return sorted_samples[0];\n    }\n    let zero: f64 = 0.0;\n    assert!(zero <= pct);\n    let hundred = 100_f64;\n    assert!(pct <= hundred);\n    if pct == hundred {\n        return sorted_samples[sorted_samples.len() - 1];\n    }\n    let length = (sorted_samples.len() - 1) as f64;\n    let rank = (pct / hundred) * length;\n    let lrank = rank.floor();\n    let d = rank - lrank;\n    let n = lrank as usize;\n    let lo = sorted_samples[n];\n    let hi = sorted_samples[n + 1];\n    lo + (hi - lo) * d\n}\n\n/// Winsorize a set of samples, replacing values above the `100-pct` percentile\n/// and below the `pct` percentile with those percentiles themselves. This is a\n/// way of minimizing the effect of outliers, at the cost of biasing the sample.\n/// It differs from trimming in that it does not change the number of samples,\n/// just changes the values of those that are outliers.\n///\n/// See: <https://en.wikipedia.org/wiki/Winsorising>\npub fn winsorize(samples: &mut [f64], pct: f64) {\n    let mut tmp = samples.to_vec();\n    local_sort(&mut tmp);\n    let lo = percentile_of_sorted(&tmp, pct);\n    let hundred = 100_f64;\n    let hi = percentile_of_sorted(&tmp, hundred - pct);\n    for samp in samples {\n        if *samp > hi {\n            *samp = hi\n        } else if *samp < lo {\n            *samp = lo\n        }\n    }\n}\n"],["2615","use std::{io, io::prelude::Write};\n\nuse super::OutputFormatter;\nuse crate::{\n    bench::fmt_bench_samples,\n    console::{ConsoleTestState, OutputLocation},\n    test_result::TestResult,\n    time,\n    types::TestDesc,\n};\n\npub(crate) struct PrettyFormatter<T> {\n    out: OutputLocation<T>,\n    use_color: bool,\n    time_options: Option<time::TestTimeOptions>,\n\n    /// Number of columns to fill when aligning names\n    max_name_len: usize,\n\n    is_multithreaded: bool,\n}\n\nimpl<T: Write> PrettyFormatter<T> {\n    pub fn new(\n        out: OutputLocation<T>,\n        use_color: bool,\n        max_name_len: usize,\n        is_multithreaded: bool,\n        time_options: Option<time::TestTimeOptions>,\n    ) -> Self {\n        PrettyFormatter { out, use_color, max_name_len, is_multithreaded, time_options }\n    }\n\n    #[cfg(test)]\n    pub fn output_location(&self) -> &OutputLocation<T> {\n        &self.out\n    }\n\n    pub fn write_ok(&mut self) -> io::Result<()> {\n        self.write_short_result(\"ok\", term::color::GREEN)\n    }\n\n    pub fn write_failed(&mut self) -> io::Result<()> {\n        self.write_short_result(\"FAILED\", term::color::RED)\n    }\n\n    pub fn write_ignored(&mut self) -> io::Result<()> {\n        self.write_short_result(\"ignored\", term::color::YELLOW)\n    }\n\n    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n        self.write_short_result(\"FAILED (allowed)\", term::color::YELLOW)\n    }\n\n    pub fn write_time_failed(&mut self) -> io::Result<()> {\n        self.write_short_result(\"FAILED (time limit exceeded)\", term::color::RED)\n    }\n\n    pub fn write_bench(&mut self) -> io::Result<()> {\n        self.write_pretty(\"bench\", term::color::CYAN)\n    }\n\n    pub fn write_short_result(\n        &mut self,\n        result: &str,\n        color: term::color::Color,\n    ) -> io::Result<()> {\n        self.write_pretty(result, color)\n    }\n\n    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n        match self.out {\n            OutputLocation::Pretty(ref mut term) => {\n                if self.use_color {\n                    term.fg(color)?;\n                }\n                term.write_all(word.as_bytes())?;\n                if self.use_color {\n                    term.reset()?;\n                }\n                term.flush()\n            }\n            OutputLocation::Raw(ref mut stdout) => {\n                stdout.write_all(word.as_bytes())?;\n                stdout.flush()\n            }\n        }\n    }\n\n    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n        let s = s.as_ref();\n        self.out.write_all(s.as_bytes())?;\n        self.out.flush()\n    }\n\n    fn write_time(\n        &mut self,\n        desc: &TestDesc,\n        exec_time: Option<&time::TestExecTime>,\n    ) -> io::Result<()> {\n        if let (Some(opts), Some(time)) = (self.time_options, exec_time) {\n            let time_str = format!(\" <{}>\", time);\n\n            let color = if opts.colored {\n                if opts.is_critical(desc, time) {\n                    Some(term::color::RED)\n                } else if opts.is_warn(desc, time) {\n                    Some(term::color::YELLOW)\n                } else {\n                    None\n                }\n            } else {\n                None\n            };\n\n            match color {\n                Some(color) => self.write_pretty(&time_str, color)?,\n                None => self.write_plain(&time_str)?,\n            }\n        }\n\n        Ok(())\n    }\n\n    fn write_results(\n        &mut self,\n        inputs: &Vec<(TestDesc, Vec<u8>)>,\n        results_type: &str,\n    ) -> io::Result<()> {\n        let results_out_str = format!(\"\\n{}:\\n\", results_type);\n\n        self.write_plain(&results_out_str)?;\n\n        let mut results = Vec::new();\n        let mut stdouts = String::new();\n        for &(ref f, ref stdout) in inputs {\n            results.push(f.name.to_string());\n            if !stdout.is_empty() {\n                stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                let output = String::from_utf8_lossy(stdout);\n                stdouts.push_str(&output);\n                stdouts.push('\\n');\n            }\n        }\n        if !stdouts.is_empty() {\n            self.write_plain(\"\\n\")?;\n            self.write_plain(&stdouts)?;\n        }\n\n        self.write_plain(&results_out_str)?;\n        results.sort();\n        for name in &results {\n            self.write_plain(&format!(\"    {}\\n\", name))?;\n        }\n        Ok(())\n    }\n\n    pub fn write_successes(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_results(&state.not_failures, \"successes\")\n    }\n\n    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_results(&state.failures, \"failures\")\n    }\n\n    pub fn write_time_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_results(&state.time_failures, \"failures (time limit exceeded)\")\n    }\n\n    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n        if let Some(test_mode) = desc.test_mode() {\n            self.write_plain(&format!(\"test {} - {} ... \", name, test_mode))?;\n        } else {\n            self.write_plain(&format!(\"test {} ... \", name))?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl<T: Write> OutputFormatter for PrettyFormatter<T> {\n    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n    }\n\n    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n        // When running tests concurrently, we should not print\n        // the test's name as the result will be mis-aligned.\n        // When running the tests serially, we print the name here so\n        // that the user can see which test hangs.\n        if !self.is_multithreaded {\n            self.write_test_name(desc)?;\n        }\n\n        Ok(())\n    }\n\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&time::TestExecTime>,\n        _: &[u8],\n        _: &ConsoleTestState,\n    ) -> io::Result<()> {\n        if self.is_multithreaded {\n            self.write_test_name(desc)?;\n        }\n\n        match *result {\n            TestResult::TrOk => self.write_ok()?,\n            TestResult::TrFailed | TestResult::TrFailedMsg(_) => self.write_failed()?,\n            TestResult::TrIgnored => self.write_ignored()?,\n            TestResult::TrAllowedFail => self.write_allowed_fail()?,\n            TestResult::TrBench(ref bs) => {\n                self.write_bench()?;\n                self.write_plain(&format!(\": {}\", fmt_bench_samples(bs)))?;\n            }\n            TestResult::TrTimedFail => self.write_time_failed()?,\n        }\n\n        self.write_time(desc, exec_time)?;\n        self.write_plain(\"\\n\")\n    }\n\n    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n        self.write_plain(&format!(\n            \"test {} has been running for over {} seconds\\n\",\n            desc.name,\n            time::TEST_WARN_TIMEOUT_S\n        ))\n    }\n\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n        if state.options.display_output {\n            self.write_successes(state)?;\n        }\n        let success = state.failed == 0;\n        if !success {\n            if !state.failures.is_empty() {\n                self.write_failures(state)?;\n            }\n\n            if !state.time_failures.is_empty() {\n                self.write_time_failures(state)?;\n            }\n        }\n\n        self.write_plain(\"\\ntest result: \")?;\n\n        if success {\n            // There's no parallelism at this point so it's safe to use color\n            self.write_pretty(\"ok\", term::color::GREEN)?;\n        } else {\n            self.write_pretty(\"FAILED\", term::color::RED)?;\n        }\n\n        let s = if state.allowed_fail > 0 {\n            format!(\n                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\",\n                state.passed,\n                state.failed + state.allowed_fail,\n                state.allowed_fail,\n                state.ignored,\n                state.measured,\n                state.filtered_out\n            )\n        } else {\n            format!(\n                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\",\n                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n            )\n        };\n\n        self.write_plain(&s)?;\n\n        if let Some(ref exec_time) = state.exec_time {\n            let time_str = format!(\"; finished in {}\", exec_time);\n            self.write_plain(&time_str)?;\n        }\n\n        self.write_plain(\"\\n\\n\")?;\n\n        Ok(success)\n    }\n}\n"],["2616","use std::{borrow::Cow, io, io::prelude::Write};\n\nuse super::OutputFormatter;\nuse crate::{\n    console::{ConsoleTestState, OutputLocation},\n    test_result::TestResult,\n    time,\n    types::TestDesc,\n};\n\npub(crate) struct JsonFormatter<T> {\n    out: OutputLocation<T>,\n}\n\nimpl<T: Write> JsonFormatter<T> {\n    pub fn new(out: OutputLocation<T>) -> Self {\n        Self { out }\n    }\n\n    fn writeln_message(&mut self, s: &str) -> io::Result<()> {\n        assert!(!s.contains('\\n'));\n\n        self.out.write_all(s.as_ref())?;\n        self.out.write_all(b\"\\n\")\n    }\n\n    fn write_message(&mut self, s: &str) -> io::Result<()> {\n        assert!(!s.contains('\\n'));\n\n        self.out.write_all(s.as_ref())\n    }\n\n    fn write_event(\n        &mut self,\n        ty: &str,\n        name: &str,\n        evt: &str,\n        exec_time: Option<&time::TestExecTime>,\n        stdout: Option<Cow<'_, str>>,\n        extra: Option<&str>,\n    ) -> io::Result<()> {\n        // A doc test's name includes a filename which must be escaped for correct json.\n        self.write_message(&*format!(\n            r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\"\"#,\n            ty,\n            EscapedString(name),\n            evt\n        ))?;\n        if let Some(exec_time) = exec_time {\n            self.write_message(&*format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64()))?;\n        }\n        if let Some(stdout) = stdout {\n            self.write_message(&*format!(r#\", \"stdout\": \"{}\"\"#, EscapedString(stdout)))?;\n        }\n        if let Some(extra) = extra {\n            self.write_message(&*format!(r#\", {}\"#, extra))?;\n        }\n        self.writeln_message(\" }\")\n    }\n}\n\nimpl<T: Write> OutputFormatter for JsonFormatter<T> {\n    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n        self.writeln_message(&*format!(\n            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {} }}\"#,\n            test_count\n        ))\n    }\n\n    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n        self.writeln_message(&*format!(\n            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n            EscapedString(desc.name.as_slice())\n        ))\n    }\n\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&time::TestExecTime>,\n        stdout: &[u8],\n        state: &ConsoleTestState,\n    ) -> io::Result<()> {\n        let display_stdout = state.options.display_output || *result != TestResult::TrOk;\n        let stdout = if display_stdout && !stdout.is_empty() {\n            Some(String::from_utf8_lossy(stdout))\n        } else {\n            None\n        };\n        match *result {\n            TestResult::TrOk => {\n                self.write_event(\"test\", desc.name.as_slice(), \"ok\", exec_time, stdout, None)\n            }\n\n            TestResult::TrFailed => {\n                self.write_event(\"test\", desc.name.as_slice(), \"failed\", exec_time, stdout, None)\n            }\n\n            TestResult::TrTimedFail => self.write_event(\n                \"test\",\n                desc.name.as_slice(),\n                \"failed\",\n                exec_time,\n                stdout,\n                Some(r#\"\"reason\": \"time limit exceeded\"\"#),\n            ),\n\n            TestResult::TrFailedMsg(ref m) => self.write_event(\n                \"test\",\n                desc.name.as_slice(),\n                \"failed\",\n                exec_time,\n                stdout,\n                Some(&*format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n            ),\n\n            TestResult::TrIgnored => {\n                self.write_event(\"test\", desc.name.as_slice(), \"ignored\", exec_time, stdout, None)\n            }\n\n            TestResult::TrAllowedFail => self.write_event(\n                \"test\",\n                desc.name.as_slice(),\n                \"allowed_failure\",\n                exec_time,\n                stdout,\n                None,\n            ),\n\n            TestResult::TrBench(ref bs) => {\n                let median = bs.ns_iter_summ.median as usize;\n                let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n\n                let mbps = if bs.mb_s == 0 {\n                    String::new()\n                } else {\n                    format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n                };\n\n                let line = format!(\n                    \"{{ \\\"type\\\": \\\"bench\\\", \\\n                     \\\"name\\\": \\\"{}\\\", \\\n                     \\\"median\\\": {}, \\\n                     \\\"deviation\\\": {}{} }}\",\n                    EscapedString(desc.name.as_slice()),\n                    median,\n                    deviation,\n                    mbps\n                );\n\n                self.writeln_message(&*line)\n            }\n        }\n    }\n\n    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n        self.writeln_message(&*format!(\n            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n            EscapedString(desc.name.as_slice())\n        ))\n    }\n\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n        self.write_message(&*format!(\n            \"{{ \\\"type\\\": \\\"suite\\\", \\\n             \\\"event\\\": \\\"{}\\\", \\\n             \\\"passed\\\": {}, \\\n             \\\"failed\\\": {}, \\\n             \\\"allowed_fail\\\": {}, \\\n             \\\"ignored\\\": {}, \\\n             \\\"measured\\\": {}, \\\n             \\\"filtered_out\\\": {}\",\n            if state.failed == 0 { \"ok\" } else { \"failed\" },\n            state.passed,\n            state.failed + state.allowed_fail,\n            state.allowed_fail,\n            state.ignored,\n            state.measured,\n            state.filtered_out,\n        ))?;\n\n        if let Some(ref exec_time) = state.exec_time {\n            let time_str = format!(\", \\\"exec_time\\\": {}\", exec_time.0.as_secs_f64());\n            self.write_message(&time_str)?;\n        }\n\n        self.writeln_message(\" }\")?;\n\n        Ok(state.failed == 0)\n    }\n}\n\n/// A formatting utility used to print strings with characters in need of escaping.\n/// Base code taken form `libserialize::json::escape_str`\nstruct EscapedString<S: AsRef<str>>(S);\n\nimpl<S: AsRef<str>> std::fmt::Display for EscapedString<S> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n        let mut start = 0;\n\n        for (i, byte) in self.0.as_ref().bytes().enumerate() {\n            let escaped = match byte {\n                b'\"' => \"\\\\\\\"\",\n                b'\\\\' => \"\\\\\\\\\",\n                b'\\x00' => \"\\\\u0000\",\n                b'\\x01' => \"\\\\u0001\",\n                b'\\x02' => \"\\\\u0002\",\n                b'\\x03' => \"\\\\u0003\",\n                b'\\x04' => \"\\\\u0004\",\n                b'\\x05' => \"\\\\u0005\",\n                b'\\x06' => \"\\\\u0006\",\n                b'\\x07' => \"\\\\u0007\",\n                b'\\x08' => \"\\\\b\",\n                b'\\t' => \"\\\\t\",\n                b'\\n' => \"\\\\n\",\n                b'\\x0b' => \"\\\\u000b\",\n                b'\\x0c' => \"\\\\f\",\n                b'\\r' => \"\\\\r\",\n                b'\\x0e' => \"\\\\u000e\",\n                b'\\x0f' => \"\\\\u000f\",\n                b'\\x10' => \"\\\\u0010\",\n                b'\\x11' => \"\\\\u0011\",\n                b'\\x12' => \"\\\\u0012\",\n                b'\\x13' => \"\\\\u0013\",\n                b'\\x14' => \"\\\\u0014\",\n                b'\\x15' => \"\\\\u0015\",\n                b'\\x16' => \"\\\\u0016\",\n                b'\\x17' => \"\\\\u0017\",\n                b'\\x18' => \"\\\\u0018\",\n                b'\\x19' => \"\\\\u0019\",\n                b'\\x1a' => \"\\\\u001a\",\n                b'\\x1b' => \"\\\\u001b\",\n                b'\\x1c' => \"\\\\u001c\",\n                b'\\x1d' => \"\\\\u001d\",\n                b'\\x1e' => \"\\\\u001e\",\n                b'\\x1f' => \"\\\\u001f\",\n                b'\\x7f' => \"\\\\u007f\",\n                _ => {\n                    continue;\n                }\n            };\n\n            if start < i {\n                f.write_str(&self.0.as_ref()[start..i])?;\n            }\n\n            f.write_str(escaped)?;\n\n            start = i + 1;\n        }\n\n        if start != self.0.as_ref().len() {\n            f.write_str(&self.0.as_ref()[start..])?;\n        }\n\n        Ok(())\n    }\n}\n"],["2617","use std::io::{self, prelude::Write};\nuse std::time::Duration;\n\nuse super::OutputFormatter;\nuse crate::{\n    console::{ConsoleTestState, OutputLocation},\n    test_result::TestResult,\n    time,\n    types::{TestDesc, TestType},\n};\n\npub struct JunitFormatter<T> {\n    out: OutputLocation<T>,\n    results: Vec<(TestDesc, TestResult, Duration)>,\n}\n\nimpl<T: Write> JunitFormatter<T> {\n    pub fn new(out: OutputLocation<T>) -> Self {\n        Self { out, results: Vec::new() }\n    }\n\n    fn write_message(&mut self, s: &str) -> io::Result<()> {\n        assert!(!s.contains('\\n'));\n\n        self.out.write_all(s.as_ref())\n    }\n}\n\nimpl<T: Write> OutputFormatter for JunitFormatter<T> {\n    fn write_run_start(&mut self, _test_count: usize) -> io::Result<()> {\n        // We write xml header on run start\n        self.write_message(&\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\")\n    }\n\n    fn write_test_start(&mut self, _desc: &TestDesc) -> io::Result<()> {\n        // We do not output anything on test start.\n        Ok(())\n    }\n\n    fn write_timeout(&mut self, _desc: &TestDesc) -> io::Result<()> {\n        // We do not output anything on test timeout.\n        Ok(())\n    }\n\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&time::TestExecTime>,\n        _stdout: &[u8],\n        _state: &ConsoleTestState,\n    ) -> io::Result<()> {\n        // Because the testsuit node holds some of the information as attributes, we can't write it\n        // until all of the tests has ran. Instead of writting every result as they come in, we add\n        // them to a Vec and write them all at once when run is complete.\n        let duration = exec_time.map(|t| t.0.clone()).unwrap_or_default();\n        self.results.push((desc.clone(), result.clone(), duration));\n        Ok(())\n    }\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n        self.write_message(\"<testsuites>\")?;\n\n        self.write_message(&*format!(\n            \"<testsuite name=\\\"test\\\" package=\\\"test\\\" id=\\\"0\\\" \\\n             errors=\\\"0\\\" \\\n             failures=\\\"{}\\\" \\\n             tests=\\\"{}\\\" \\\n             skipped=\\\"{}\\\" \\\n             >\",\n            state.failed, state.total, state.ignored\n        ))?;\n        for (desc, result, duration) in std::mem::replace(&mut self.results, Vec::new()) {\n            let (class_name, test_name) = parse_class_name(&desc);\n            match result {\n                TestResult::TrIgnored => { /* no-op */ }\n                TestResult::TrFailed => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\">\",\n                        class_name,\n                        test_name,\n                        duration.as_secs()\n                    ))?;\n                    self.write_message(\"<failure type=\\\"assert\\\"/>\")?;\n                    self.write_message(\"</testcase>\")?;\n                }\n\n                TestResult::TrFailedMsg(ref m) => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\">\",\n                        class_name,\n                        test_name,\n                        duration.as_secs()\n                    ))?;\n                    self.write_message(&*format!(\"<failure message=\\\"{}\\\" type=\\\"assert\\\"/>\", m))?;\n                    self.write_message(\"</testcase>\")?;\n                }\n\n                TestResult::TrTimedFail => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\">\",\n                        class_name,\n                        test_name,\n                        duration.as_secs()\n                    ))?;\n                    self.write_message(\"<failure type=\\\"timeout\\\"/>\")?;\n                    self.write_message(\"</testcase>\")?;\n                }\n\n                TestResult::TrBench(ref b) => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"benchmark::{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\" />\",\n                        class_name, test_name, b.ns_iter_summ.sum\n                    ))?;\n                }\n\n                TestResult::TrOk | TestResult::TrAllowedFail => {\n                    self.write_message(&*format!(\n                        \"<testcase classname=\\\"{}\\\" \\\n                         name=\\\"{}\\\" time=\\\"{}\\\"/>\",\n                        class_name,\n                        test_name,\n                        duration.as_secs()\n                    ))?;\n                }\n            }\n        }\n        self.write_message(\"<system-out/>\")?;\n        self.write_message(\"<system-err/>\")?;\n        self.write_message(\"</testsuite>\")?;\n        self.write_message(\"</testsuites>\")?;\n\n        Ok(state.failed == 0)\n    }\n}\n\nfn parse_class_name(desc: &TestDesc) -> (String, String) {\n    match desc.test_type {\n        TestType::UnitTest => parse_class_name_unit(desc),\n        TestType::DocTest => parse_class_name_doc(desc),\n        TestType::IntegrationTest => parse_class_name_integration(desc),\n        TestType::Unknown => (String::from(\"unknown\"), String::from(desc.name.as_slice())),\n    }\n}\n\nfn parse_class_name_unit(desc: &TestDesc) -> (String, String) {\n    // Module path => classname\n    // Function name => name\n    let module_segments: Vec<&str> = desc.name.as_slice().split(\"::\").collect();\n    let (class_name, test_name) = match module_segments[..] {\n        [test] => (String::from(\"crate\"), String::from(test)),\n        [ref path @ .., test] => (path.join(\"::\"), String::from(test)),\n        [..] => unreachable!(),\n    };\n    (class_name, test_name)\n}\n\nfn parse_class_name_doc(desc: &TestDesc) -> (String, String) {\n    // File path => classname\n    // Line # => test name\n    let segments: Vec<&str> = desc.name.as_slice().split(\" - \").collect();\n    let (class_name, test_name) = match segments[..] {\n        [file, line] => (String::from(file.trim()), String::from(line.trim())),\n        [..] => unreachable!(),\n    };\n    (class_name, test_name)\n}\n\nfn parse_class_name_integration(desc: &TestDesc) -> (String, String) {\n    (String::from(\"integration\"), String::from(desc.name.as_slice()))\n}\n"],["2618","use std::{io, io::prelude::Write};\n\nuse crate::{\n    console::ConsoleTestState,\n    test_result::TestResult,\n    time,\n    types::{TestDesc, TestName},\n};\n\nmod json;\nmod junit;\nmod pretty;\nmod terse;\n\npub(crate) use self::json::JsonFormatter;\npub(crate) use self::junit::JunitFormatter;\npub(crate) use self::pretty::PrettyFormatter;\npub(crate) use self::terse::TerseFormatter;\n\npub(crate) trait OutputFormatter {\n    fn write_run_start(&mut self, test_count: usize) -> io::Result<()>;\n    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()>;\n    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        exec_time: Option<&time::TestExecTime>,\n        stdout: &[u8],\n        state: &ConsoleTestState,\n    ) -> io::Result<()>;\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n}\n\npub(crate) fn write_stderr_delimiter(test_output: &mut Vec<u8>, test_name: &TestName) {\n    match test_output.last() {\n        Some(b'\\n') => (),\n        Some(_) => test_output.push(b'\\n'),\n        None => (),\n    }\n    writeln!(test_output, \"---- {} stderr ----\", test_name).unwrap();\n}\n"],["2619","use std::{io, io::prelude::Write};\n\nuse super::OutputFormatter;\nuse crate::{\n    bench::fmt_bench_samples,\n    console::{ConsoleTestState, OutputLocation},\n    test_result::TestResult,\n    time,\n    types::NamePadding,\n    types::TestDesc,\n};\n\n// insert a '\\n' after 100 tests in quiet mode\nconst QUIET_MODE_MAX_COLUMN: usize = 100;\n\npub(crate) struct TerseFormatter<T> {\n    out: OutputLocation<T>,\n    use_color: bool,\n    is_multithreaded: bool,\n    /// Number of columns to fill when aligning names\n    max_name_len: usize,\n\n    test_count: usize,\n    total_test_count: usize,\n}\n\nimpl<T: Write> TerseFormatter<T> {\n    pub fn new(\n        out: OutputLocation<T>,\n        use_color: bool,\n        max_name_len: usize,\n        is_multithreaded: bool,\n    ) -> Self {\n        TerseFormatter {\n            out,\n            use_color,\n            max_name_len,\n            is_multithreaded,\n            test_count: 0,\n            total_test_count: 0, // initialized later, when write_run_start is called\n        }\n    }\n\n    pub fn write_ok(&mut self) -> io::Result<()> {\n        self.write_short_result(\".\", term::color::GREEN)\n    }\n\n    pub fn write_failed(&mut self) -> io::Result<()> {\n        self.write_short_result(\"F\", term::color::RED)\n    }\n\n    pub fn write_ignored(&mut self) -> io::Result<()> {\n        self.write_short_result(\"i\", term::color::YELLOW)\n    }\n\n    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n        self.write_short_result(\"a\", term::color::YELLOW)\n    }\n\n    pub fn write_bench(&mut self) -> io::Result<()> {\n        self.write_pretty(\"bench\", term::color::CYAN)\n    }\n\n    pub fn write_short_result(\n        &mut self,\n        result: &str,\n        color: term::color::Color,\n    ) -> io::Result<()> {\n        self.write_pretty(result, color)?;\n        if self.test_count % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n            // we insert a new line every 100 dots in order to flush the\n            // screen when dealing with line-buffered output (e.g., piping to\n            // `stamp` in the rust CI).\n            let out = format!(\" {}/{}\\n\", self.test_count + 1, self.total_test_count);\n            self.write_plain(&out)?;\n        }\n\n        self.test_count += 1;\n        Ok(())\n    }\n\n    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n        match self.out {\n            OutputLocation::Pretty(ref mut term) => {\n                if self.use_color {\n                    term.fg(color)?;\n                }\n                term.write_all(word.as_bytes())?;\n                if self.use_color {\n                    term.reset()?;\n                }\n                term.flush()\n            }\n            OutputLocation::Raw(ref mut stdout) => {\n                stdout.write_all(word.as_bytes())?;\n                stdout.flush()\n            }\n        }\n    }\n\n    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n        let s = s.as_ref();\n        self.out.write_all(s.as_bytes())?;\n        self.out.flush()\n    }\n\n    pub fn write_outputs(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_plain(\"\\nsuccesses:\\n\")?;\n        let mut successes = Vec::new();\n        let mut stdouts = String::new();\n        for &(ref f, ref stdout) in &state.not_failures {\n            successes.push(f.name.to_string());\n            if !stdout.is_empty() {\n                stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                let output = String::from_utf8_lossy(stdout);\n                stdouts.push_str(&output);\n                stdouts.push('\\n');\n            }\n        }\n        if !stdouts.is_empty() {\n            self.write_plain(\"\\n\")?;\n            self.write_plain(&stdouts)?;\n        }\n\n        self.write_plain(\"\\nsuccesses:\\n\")?;\n        successes.sort();\n        for name in &successes {\n            self.write_plain(&format!(\"    {}\\n\", name))?;\n        }\n        Ok(())\n    }\n\n    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n        self.write_plain(\"\\nfailures:\\n\")?;\n        let mut failures = Vec::new();\n        let mut fail_out = String::new();\n        for &(ref f, ref stdout) in &state.failures {\n            failures.push(f.name.to_string());\n            if !stdout.is_empty() {\n                fail_out.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                let output = String::from_utf8_lossy(stdout);\n                fail_out.push_str(&output);\n                fail_out.push('\\n');\n            }\n        }\n        if !fail_out.is_empty() {\n            self.write_plain(\"\\n\")?;\n            self.write_plain(&fail_out)?;\n        }\n\n        self.write_plain(\"\\nfailures:\\n\")?;\n        failures.sort();\n        for name in &failures {\n            self.write_plain(&format!(\"    {}\\n\", name))?;\n        }\n        Ok(())\n    }\n\n    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n        if let Some(test_mode) = desc.test_mode() {\n            self.write_plain(&format!(\"test {} - {} ... \", name, test_mode))?;\n        } else {\n            self.write_plain(&format!(\"test {} ... \", name))?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl<T: Write> OutputFormatter for TerseFormatter<T> {\n    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n        self.total_test_count = test_count;\n        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n    }\n\n    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n        // Remnants from old libtest code that used the padding value\n        // in order to indicate benchmarks.\n        // When running benchmarks, terse-mode should still print their name as if\n        // it is the Pretty formatter.\n        if !self.is_multithreaded && desc.name.padding() == NamePadding::PadOnRight {\n            self.write_test_name(desc)?;\n        }\n\n        Ok(())\n    }\n\n    fn write_result(\n        &mut self,\n        desc: &TestDesc,\n        result: &TestResult,\n        _: Option<&time::TestExecTime>,\n        _: &[u8],\n        _: &ConsoleTestState,\n    ) -> io::Result<()> {\n        match *result {\n            TestResult::TrOk => self.write_ok(),\n            TestResult::TrFailed | TestResult::TrFailedMsg(_) | TestResult::TrTimedFail => {\n                self.write_failed()\n            }\n            TestResult::TrIgnored => self.write_ignored(),\n            TestResult::TrAllowedFail => self.write_allowed_fail(),\n            TestResult::TrBench(ref bs) => {\n                if self.is_multithreaded {\n                    self.write_test_name(desc)?;\n                }\n                self.write_bench()?;\n                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n            }\n        }\n    }\n\n    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n        self.write_plain(&format!(\n            \"test {} has been running for over {} seconds\\n\",\n            desc.name,\n            time::TEST_WARN_TIMEOUT_S\n        ))\n    }\n\n    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n        if state.options.display_output {\n            self.write_outputs(state)?;\n        }\n        let success = state.failed == 0;\n        if !success {\n            self.write_failures(state)?;\n        }\n\n        self.write_plain(\"\\ntest result: \")?;\n\n        if success {\n            // There's no parallelism at this point so it's safe to use color\n            self.write_pretty(\"ok\", term::color::GREEN)?;\n        } else {\n            self.write_pretty(\"FAILED\", term::color::RED)?;\n        }\n\n        let s = if state.allowed_fail > 0 {\n            format!(\n                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\",\n                state.passed,\n                state.failed + state.allowed_fail,\n                state.allowed_fail,\n                state.ignored,\n                state.measured,\n                state.filtered_out\n            )\n        } else {\n            format!(\n                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\",\n                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n            )\n        };\n\n        self.write_plain(&s)?;\n\n        if let Some(ref exec_time) = state.exec_time {\n            let time_str = format!(\"; finished in {}\", exec_time);\n            self.write_plain(&time_str)?;\n        }\n\n        self.write_plain(\"\\n\\n\")?;\n\n        Ok(success)\n    }\n}\n"],["2620","//! Benchmarking module.\nuse super::{\n    event::CompletedTest,\n    options::BenchMode,\n    test_result::TestResult,\n    types::{TestDesc, TestId},\n    Sender,\n};\n\nuse crate::stats;\nuse std::cmp;\nuse std::io;\nuse std::panic::{catch_unwind, AssertUnwindSafe};\nuse std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\n\n/// An identity function that *__hints__* to the compiler to be maximally pessimistic about what\n/// `black_box` could do.\n///\n/// See [`std::hint::black_box`] for details.\n#[inline(always)]\npub fn black_box<T>(dummy: T) -> T {\n    std::hint::black_box(dummy)\n}\n\n/// Manager of the benchmarking runs.\n///\n/// This is fed into functions marked with `#[bench]` to allow for\n/// set-up & tear-down before running a piece of code repeatedly via a\n/// call to `iter`.\n#[derive(Clone)]\npub struct Bencher {\n    mode: BenchMode,\n    summary: Option<stats::Summary>,\n    pub bytes: u64,\n}\n\nimpl Bencher {\n    /// Callback for benchmark functions to run in their body.\n    pub fn iter<T, F>(&mut self, mut inner: F)\n    where\n        F: FnMut() -> T,\n    {\n        if self.mode == BenchMode::Single {\n            ns_iter_inner(&mut inner, 1);\n            return;\n        }\n\n        self.summary = Some(iter(&mut inner));\n    }\n\n    pub fn bench<F>(&mut self, mut f: F) -> Option<stats::Summary>\n    where\n        F: FnMut(&mut Bencher),\n    {\n        f(self);\n        self.summary\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct BenchSamples {\n    pub ns_iter_summ: stats::Summary,\n    pub mb_s: usize,\n}\n\npub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n    use std::fmt::Write;\n    let mut output = String::new();\n\n    let median = bs.ns_iter_summ.median as usize;\n    let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n\n    write!(\n        output,\n        \"{:>11} ns/iter (+/- {})\",\n        fmt_thousands_sep(median, ','),\n        fmt_thousands_sep(deviation, ',')\n    )\n    .unwrap();\n    if bs.mb_s != 0 {\n        write!(output, \" = {} MB/s\", bs.mb_s).unwrap();\n    }\n    output\n}\n\n// Format a number with thousands separators\nfn fmt_thousands_sep(mut n: usize, sep: char) -> String {\n    use std::fmt::Write;\n    let mut output = String::new();\n    let mut trailing = false;\n    for &pow in &[9, 6, 3, 0] {\n        let base = 10_usize.pow(pow);\n        if pow == 0 || trailing || n / base != 0 {\n            if !trailing {\n                write!(output, \"{}\", n / base).unwrap();\n            } else {\n                write!(output, \"{:03}\", n / base).unwrap();\n            }\n            if pow != 0 {\n                output.push(sep);\n            }\n            trailing = true;\n        }\n        n %= base;\n    }\n\n    output\n}\n\nfn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\nwhere\n    F: FnMut() -> T,\n{\n    let start = Instant::now();\n    for _ in 0..k {\n        black_box(inner());\n    }\n    start.elapsed().as_nanos() as u64\n}\n\npub fn iter<T, F>(inner: &mut F) -> stats::Summary\nwhere\n    F: FnMut() -> T,\n{\n    // Initial bench run to get ballpark figure.\n    let ns_single = ns_iter_inner(inner, 1);\n\n    // Try to estimate iter count for 1ms falling back to 1m\n    // iterations if first run took < 1ns.\n    let ns_target_total = 1_000_000; // 1ms\n    let mut n = ns_target_total / cmp::max(1, ns_single);\n\n    // if the first run took more than 1ms we don't want to just\n    // be left doing 0 iterations on every loop. The unfortunate\n    // side effect of not being able to do as many runs is\n    // automatically handled by the statistical analysis below\n    // (i.e., larger error bars).\n    n = cmp::max(1, n);\n\n    let mut total_run = Duration::new(0, 0);\n    let samples: &mut [f64] = &mut [0.0_f64; 50];\n    loop {\n        let loop_start = Instant::now();\n\n        for p in &mut *samples {\n            *p = ns_iter_inner(inner, n) as f64 / n as f64;\n        }\n\n        stats::winsorize(samples, 5.0);\n        let summ = stats::Summary::new(samples);\n\n        for p in &mut *samples {\n            let ns = ns_iter_inner(inner, 5 * n);\n            *p = ns as f64 / (5 * n) as f64;\n        }\n\n        stats::winsorize(samples, 5.0);\n        let summ5 = stats::Summary::new(samples);\n\n        let loop_run = loop_start.elapsed();\n\n        // If we've run for 100ms and seem to have converged to a\n        // stable median.\n        if loop_run > Duration::from_millis(100)\n            && summ.median_abs_dev_pct < 1.0\n            && summ.median - summ5.median < summ5.median_abs_dev\n        {\n            return summ5;\n        }\n\n        total_run += loop_run;\n        // Longest we ever run for is 3s.\n        if total_run > Duration::from_secs(3) {\n            return summ5;\n        }\n\n        // If we overflow here just return the results so far. We check a\n        // multiplier of 10 because we're about to multiply by 2 and the\n        // next iteration of the loop will also multiply by 5 (to calculate\n        // the summ5 result)\n        n = match n.checked_mul(10) {\n            Some(_) => n * 2,\n            None => {\n                return summ5;\n            }\n        };\n    }\n}\n\npub fn benchmark<F>(\n    id: TestId,\n    desc: TestDesc,\n    monitor_ch: Sender<CompletedTest>,\n    nocapture: bool,\n    f: F,\n) where\n    F: FnMut(&mut Bencher),\n{\n    let mut bs = Bencher { mode: BenchMode::Auto, summary: None, bytes: 0 };\n\n    let data = Arc::new(Mutex::new(Vec::new()));\n\n    if !nocapture {\n        io::set_output_capture(Some(data.clone()));\n    }\n\n    let result = catch_unwind(AssertUnwindSafe(|| bs.bench(f)));\n\n    io::set_output_capture(None);\n\n    let test_result = match result {\n        //bs.bench(f) {\n        Ok(Some(ns_iter_summ)) => {\n            let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n            let mb_s = bs.bytes * 1000 / ns_iter;\n\n            let bs = BenchSamples { ns_iter_summ, mb_s: mb_s as usize };\n            TestResult::TrBench(bs)\n        }\n        Ok(None) => {\n            // iter not called, so no data.\n            // FIXME: error in this case?\n            let samples: &mut [f64] = &mut [0.0_f64; 1];\n            let bs = BenchSamples { ns_iter_summ: stats::Summary::new(samples), mb_s: 0 };\n            TestResult::TrBench(bs)\n        }\n        Err(_) => TestResult::TrFailed,\n    };\n\n    let stdout = data.lock().unwrap().to_vec();\n    let message = CompletedTest::new(id, desc, test_result, None, stdout);\n    monitor_ch.send(message).unwrap();\n}\n\npub fn run_once<F>(f: F)\nwhere\n    F: FnMut(&mut Bencher),\n{\n    let mut bs = Bencher { mode: BenchMode::Single, summary: None, bytes: 0 };\n    bs.bench(f);\n}\n"],["2621","//! Common types used by `libtest`.\n\nuse std::borrow::Cow;\nuse std::fmt;\n\nuse super::bench::Bencher;\nuse super::options;\n\npub use NamePadding::*;\npub use TestFn::*;\npub use TestName::*;\n\n/// Type of the test according to the [rust book](https://doc.rust-lang.org/cargo/guide/tests.html)\n/// conventions.\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\npub enum TestType {\n    /// Unit-tests are expected to be in the `src` folder of the crate.\n    UnitTest,\n    /// Integration-style tests are expected to be in the `tests` folder of the crate.\n    IntegrationTest,\n    /// Doctests are created by the `librustdoc` manually, so it's a different type of test.\n    DocTest,\n    /// Tests for the sources that don't follow the project layout convention\n    /// (e.g. tests in raw `main.rs` compiled by calling `rustc --test` directly).\n    Unknown,\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\npub enum NamePadding {\n    PadNone,\n    PadOnRight,\n}\n\n// The name of a test. By convention this follows the rules for rust\n// paths; i.e., it should be a series of identifiers separated by double\n// colons. This way if some test runner wants to arrange the tests\n// hierarchically it may.\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum TestName {\n    StaticTestName(&'static str),\n    DynTestName(String),\n    AlignedTestName(Cow<'static, str>, NamePadding),\n}\n\nimpl TestName {\n    pub fn as_slice(&self) -> &str {\n        match *self {\n            StaticTestName(s) => s,\n            DynTestName(ref s) => s,\n            AlignedTestName(ref s, _) => &*s,\n        }\n    }\n\n    pub fn padding(&self) -> NamePadding {\n        match self {\n            &AlignedTestName(_, p) => p,\n            _ => PadNone,\n        }\n    }\n\n    pub fn with_padding(&self, padding: NamePadding) -> TestName {\n        let name = match *self {\n            TestName::StaticTestName(name) => Cow::Borrowed(name),\n            TestName::DynTestName(ref name) => Cow::Owned(name.clone()),\n            TestName::AlignedTestName(ref name, _) => name.clone(),\n        };\n\n        TestName::AlignedTestName(name, padding)\n    }\n}\nimpl fmt::Display for TestName {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.as_slice(), f)\n    }\n}\n\n/// Represents a benchmark function.\npub trait TDynBenchFn: Send {\n    fn run(&self, harness: &mut Bencher);\n}\n\n// A function that runs a test. If the function returns successfully,\n// the test succeeds; if the function panics then the test fails. We\n// may need to come up with a more clever definition of test in order\n// to support isolation of tests into threads.\npub enum TestFn {\n    StaticTestFn(fn()),\n    StaticBenchFn(fn(&mut Bencher)),\n    DynTestFn(Box<dyn FnOnce() + Send>),\n    DynBenchFn(Box<dyn TDynBenchFn + 'static>),\n}\n\nimpl TestFn {\n    pub fn padding(&self) -> NamePadding {\n        match *self {\n            StaticTestFn(..) => PadNone,\n            StaticBenchFn(..) => PadOnRight,\n            DynTestFn(..) => PadNone,\n            DynBenchFn(..) => PadOnRight,\n        }\n    }\n}\n\nimpl fmt::Debug for TestFn {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(match *self {\n            StaticTestFn(..) => \"StaticTestFn(..)\",\n            StaticBenchFn(..) => \"StaticBenchFn(..)\",\n            DynTestFn(..) => \"DynTestFn(..)\",\n            DynBenchFn(..) => \"DynBenchFn(..)\",\n        })\n    }\n}\n\n// A unique integer associated with each test.\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct TestId(pub usize);\n\n// The definition of a single test. A test runner will run a list of\n// these.\n#[derive(Clone, Debug)]\npub struct TestDesc {\n    pub name: TestName,\n    pub ignore: bool,\n    pub should_panic: options::ShouldPanic,\n    pub allow_fail: bool,\n    #[cfg(not(bootstrap))]\n    pub compile_fail: bool,\n    #[cfg(not(bootstrap))]\n    pub no_run: bool,\n    pub test_type: TestType,\n}\n\nimpl TestDesc {\n    pub fn padded_name(&self, column_count: usize, align: NamePadding) -> String {\n        let mut name = String::from(self.name.as_slice());\n        let fill = column_count.saturating_sub(name.len());\n        let pad = \" \".repeat(fill);\n        match align {\n            PadNone => name,\n            PadOnRight => {\n                name.push_str(&pad);\n                name\n            }\n        }\n    }\n\n    /// Returns None for ignored test or that that are just run, otherwise give a description of the type of test.\n    /// Descriptions include \"should panic\", \"compile fail\" and \"compile\".\n    #[cfg(not(bootstrap))]\n    pub fn test_mode(&self) -> Option<&'static str> {\n        if self.ignore {\n            return None;\n        }\n        match self.should_panic {\n            options::ShouldPanic::Yes | options::ShouldPanic::YesWithMessage(_) => {\n                return Some(\"should panic\");\n            }\n            options::ShouldPanic::No => {}\n        }\n        if self.allow_fail {\n            return Some(\"allow fail\");\n        }\n        if self.compile_fail {\n            return Some(\"compile fail\");\n        }\n        if self.no_run {\n            return Some(\"compile\");\n        }\n        None\n    }\n\n    #[cfg(bootstrap)]\n    pub fn test_mode(&self) -> Option<&'static str> {\n        None\n    }\n}\n\n#[derive(Debug)]\npub struct TestDescAndFn {\n    pub desc: TestDesc,\n    pub testfn: TestFn,\n}\n"],["2622","//! Module `time` contains everything related to the time measurement of unit tests\n//! execution.\n//! The purposes of this module:\n//! - Check whether test is timed out.\n//! - Provide helpers for `report-time` and `measure-time` options.\n//! - Provide newtypes for executions times.\n\nuse std::env;\nuse std::fmt;\nuse std::str::FromStr;\nuse std::time::{Duration, Instant};\n\nuse super::types::{TestDesc, TestType};\n\npub const TEST_WARN_TIMEOUT_S: u64 = 60;\n\n/// This small module contains constants used by `report-time` option.\n/// Those constants values will be used if corresponding environment variables are not set.\n///\n/// To override values for unit-tests, use a constant `RUST_TEST_TIME_UNIT`,\n/// To override values for integration tests, use a constant `RUST_TEST_TIME_INTEGRATION`,\n/// To override values for doctests, use a constant `RUST_TEST_TIME_DOCTEST`.\n///\n/// Example of the expected format is `RUST_TEST_TIME_xxx=100,200`, where 100 means\n/// warn time, and 200 means critical time.\npub mod time_constants {\n    use super::TEST_WARN_TIMEOUT_S;\n    use std::time::Duration;\n\n    /// Environment variable for overriding default threshold for unit-tests.\n    pub const UNIT_ENV_NAME: &str = \"RUST_TEST_TIME_UNIT\";\n\n    // Unit tests are supposed to be really quick.\n    pub const UNIT_WARN: Duration = Duration::from_millis(50);\n    pub const UNIT_CRITICAL: Duration = Duration::from_millis(100);\n\n    /// Environment variable for overriding default threshold for unit-tests.\n    pub const INTEGRATION_ENV_NAME: &str = \"RUST_TEST_TIME_INTEGRATION\";\n\n    // Integration tests may have a lot of work, so they can take longer to execute.\n    pub const INTEGRATION_WARN: Duration = Duration::from_millis(500);\n    pub const INTEGRATION_CRITICAL: Duration = Duration::from_millis(1000);\n\n    /// Environment variable for overriding default threshold for unit-tests.\n    pub const DOCTEST_ENV_NAME: &str = \"RUST_TEST_TIME_DOCTEST\";\n\n    // Doctests are similar to integration tests, because they can include a lot of\n    // initialization code.\n    pub const DOCTEST_WARN: Duration = INTEGRATION_WARN;\n    pub const DOCTEST_CRITICAL: Duration = INTEGRATION_CRITICAL;\n\n    // Do not suppose anything about unknown tests, base limits on the\n    // `TEST_WARN_TIMEOUT_S` constant.\n    pub const UNKNOWN_WARN: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S);\n    pub const UNKNOWN_CRITICAL: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S * 2);\n}\n\n/// Returns an `Instance` object denoting when the test should be considered\n/// timed out.\npub fn get_default_test_timeout() -> Instant {\n    Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S)\n}\n\n/// The measured execution time of a unit test.\n#[derive(Debug, Clone, PartialEq)]\npub struct TestExecTime(pub Duration);\n\nimpl fmt::Display for TestExecTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:.3}s\", self.0.as_secs_f64())\n    }\n}\n\n/// The measured execution time of the whole test suite.\n#[derive(Debug, Clone, Default, PartialEq)]\npub struct TestSuiteExecTime(pub Duration);\n\nimpl fmt::Display for TestSuiteExecTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:.2}s\", self.0.as_secs_f64())\n    }\n}\n\n/// Structure denoting time limits for test execution.\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\npub struct TimeThreshold {\n    pub warn: Duration,\n    pub critical: Duration,\n}\n\nimpl TimeThreshold {\n    /// Creates a new `TimeThreshold` instance with provided durations.\n    pub fn new(warn: Duration, critical: Duration) -> Self {\n        Self { warn, critical }\n    }\n\n    /// Attempts to create a `TimeThreshold` instance with values obtained\n    /// from the environment variable, and returns `None` if the variable\n    /// is not set.\n    /// Environment variable format is expected to match `\\d+,\\d+`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if variable with provided name is set but contains inappropriate\n    /// value.\n    pub fn from_env_var(env_var_name: &str) -> Option<Self> {\n        let durations_str = env::var(env_var_name).ok()?;\n        let (warn_str, critical_str) = durations_str.split_once(',').unwrap_or_else(|| {\n            panic!(\n                \"Duration variable {} expected to have 2 numbers separated by comma, but got {}\",\n                env_var_name, durations_str\n            )\n        });\n\n        let parse_u64 = |v| {\n            u64::from_str(v).unwrap_or_else(|_| {\n                panic!(\n                    \"Duration value in variable {} is expected to be a number, but got {}\",\n                    env_var_name, v\n                )\n            })\n        };\n\n        let warn = parse_u64(warn_str);\n        let critical = parse_u64(critical_str);\n        if warn > critical {\n            panic!(\"Test execution warn time should be less or equal to the critical time\");\n        }\n\n        Some(Self::new(Duration::from_millis(warn), Duration::from_millis(critical)))\n    }\n}\n\n/// Structure with parameters for calculating test execution time.\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\npub struct TestTimeOptions {\n    /// Denotes if the test critical execution time limit excess should be considered\n    /// a test failure.\n    pub error_on_excess: bool,\n    pub colored: bool,\n    pub unit_threshold: TimeThreshold,\n    pub integration_threshold: TimeThreshold,\n    pub doctest_threshold: TimeThreshold,\n}\n\nimpl TestTimeOptions {\n    pub fn new_from_env(error_on_excess: bool, colored: bool) -> Self {\n        let unit_threshold = TimeThreshold::from_env_var(time_constants::UNIT_ENV_NAME)\n            .unwrap_or_else(Self::default_unit);\n\n        let integration_threshold =\n            TimeThreshold::from_env_var(time_constants::INTEGRATION_ENV_NAME)\n                .unwrap_or_else(Self::default_integration);\n\n        let doctest_threshold = TimeThreshold::from_env_var(time_constants::DOCTEST_ENV_NAME)\n            .unwrap_or_else(Self::default_doctest);\n\n        Self { error_on_excess, colored, unit_threshold, integration_threshold, doctest_threshold }\n    }\n\n    pub fn is_warn(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n        exec_time.0 >= self.warn_time(test)\n    }\n\n    pub fn is_critical(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n        exec_time.0 >= self.critical_time(test)\n    }\n\n    fn warn_time(&self, test: &TestDesc) -> Duration {\n        match test.test_type {\n            TestType::UnitTest => self.unit_threshold.warn,\n            TestType::IntegrationTest => self.integration_threshold.warn,\n            TestType::DocTest => self.doctest_threshold.warn,\n            TestType::Unknown => time_constants::UNKNOWN_WARN,\n        }\n    }\n\n    fn critical_time(&self, test: &TestDesc) -> Duration {\n        match test.test_type {\n            TestType::UnitTest => self.unit_threshold.critical,\n            TestType::IntegrationTest => self.integration_threshold.critical,\n            TestType::DocTest => self.doctest_threshold.critical,\n            TestType::Unknown => time_constants::UNKNOWN_CRITICAL,\n        }\n    }\n\n    fn default_unit() -> TimeThreshold {\n        TimeThreshold::new(time_constants::UNIT_WARN, time_constants::UNIT_CRITICAL)\n    }\n\n    fn default_integration() -> TimeThreshold {\n        TimeThreshold::new(time_constants::INTEGRATION_WARN, time_constants::INTEGRATION_CRITICAL)\n    }\n\n    fn default_doctest() -> TimeThreshold {\n        TimeThreshold::new(time_constants::DOCTEST_WARN, time_constants::DOCTEST_CRITICAL)\n    }\n}\n"],["2623","use super::*;\n\nuse crate::{\n    bench::Bencher,\n    console::OutputLocation,\n    formatters::PrettyFormatter,\n    options::OutputFormat,\n    test::{\n        filter_tests,\n        parse_opts,\n        run_test,\n        DynTestFn,\n        DynTestName,\n        MetricMap,\n        RunIgnored,\n        RunStrategy,\n        ShouldPanic,\n        StaticTestName,\n        TestDesc,\n        TestDescAndFn,\n        TestOpts,\n        TrIgnored,\n        TrOk,\n        // FIXME (introduced by #65251)\n        // ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TestTimeOptions,\n        // TestType, TrFailedMsg, TrIgnored, TrOk,\n    },\n    time::{TestTimeOptions, TimeThreshold},\n};\nuse std::sync::mpsc::channel;\nuse std::time::Duration;\n\nimpl TestOpts {\n    fn new() -> TestOpts {\n        TestOpts {\n            list: false,\n            filters: vec![],\n            filter_exact: false,\n            force_run_in_process: false,\n            exclude_should_panic: false,\n            run_ignored: RunIgnored::No,\n            run_tests: false,\n            bench_benchmarks: false,\n            logfile: None,\n            nocapture: false,\n            color: AutoColor,\n            format: OutputFormat::Pretty,\n            test_threads: None,\n            skip: vec![],\n            time_options: None,\n            options: Options::new(),\n        }\n    }\n}\n\nfn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n    vec![\n        TestDescAndFn {\n            desc: TestDesc {\n                name: StaticTestName(\"1\"),\n                ignore: true,\n                should_panic: ShouldPanic::No,\n                allow_fail: false,\n                #[cfg(not(bootstrap))]\n                compile_fail: false,\n                #[cfg(not(bootstrap))]\n                no_run: false,\n                test_type: TestType::Unknown,\n            },\n            testfn: DynTestFn(Box::new(move || {})),\n        },\n        TestDescAndFn {\n            desc: TestDesc {\n                name: StaticTestName(\"2\"),\n                ignore: false,\n                should_panic: ShouldPanic::No,\n                allow_fail: false,\n                #[cfg(not(bootstrap))]\n                compile_fail: false,\n                #[cfg(not(bootstrap))]\n                no_run: false,\n                test_type: TestType::Unknown,\n            },\n            testfn: DynTestFn(Box::new(move || {})),\n        },\n    ]\n}\n\n#[test]\npub fn do_not_run_ignored_tests() {\n    fn f() {\n        panic!();\n    }\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: true,\n            should_panic: ShouldPanic::No,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_ne!(result, TrOk);\n}\n\n#[test]\npub fn ignored_tests_result_in_ignored() {\n    fn f() {}\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: true,\n            should_panic: ShouldPanic::No,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrIgnored);\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic() {\n    fn f() {\n        panic!();\n    }\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::Yes,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrOk);\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic_good_message() {\n    fn f() {\n        panic!(\"an error message\");\n    }\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrOk);\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic_bad_message() {\n    use crate::tests::TrFailedMsg;\n    fn f() {\n        panic!(\"an error message\");\n    }\n    let expected = \"foobar\";\n    let failed_msg = r#\"panic did not contain expected string\n      panic message: `\"an error message\"`,\n expected substring: `\"foobar\"`\"#;\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::YesWithMessage(expected),\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrFailedMsg(failed_msg.to_string()));\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic_non_string_message_type() {\n    use crate::tests::TrFailedMsg;\n    use std::any::TypeId;\n    fn f() {\n        std::panic::panic_any(1i32);\n    }\n    let expected = \"foobar\";\n    let failed_msg = format!(\n        r#\"expected panic with string value,\n found non-string value: `{:?}`\n     expected substring: `\"foobar\"`\"#,\n        TypeId::of::<i32>()\n    );\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::YesWithMessage(expected),\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let (tx, rx) = channel();\n    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n    assert_eq!(result, TrFailedMsg(failed_msg));\n}\n\n// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n#[test]\n#[cfg(not(target_os = \"emscripten\"))]\nfn test_should_panic_but_succeeds() {\n    let should_panic_variants = [ShouldPanic::Yes, ShouldPanic::YesWithMessage(\"error message\")];\n\n    for &should_panic in should_panic_variants.iter() {\n        fn f() {}\n        let desc = TestDescAndFn {\n            desc: TestDesc {\n                name: StaticTestName(\"whatever\"),\n                ignore: false,\n                should_panic,\n                allow_fail: false,\n                #[cfg(not(bootstrap))]\n                compile_fail: false,\n                #[cfg(not(bootstrap))]\n                no_run: false,\n                test_type: TestType::Unknown,\n            },\n            testfn: DynTestFn(Box::new(f)),\n        };\n        let (tx, rx) = channel();\n        run_test(\n            &TestOpts::new(),\n            false,\n            TestId(0),\n            desc,\n            RunStrategy::InProcess,\n            tx,\n            Concurrent::No,\n        );\n        let result = rx.recv().unwrap().result;\n        assert_eq!(\n            result,\n            TrFailedMsg(\"test did not panic as expected\".to_string()),\n            \"should_panic == {:?}\",\n            should_panic\n        );\n    }\n}\n\nfn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n    fn f() {}\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::No,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    let time_options = if report_time { Some(TestTimeOptions::default()) } else { None };\n\n    let test_opts = TestOpts { time_options, ..TestOpts::new() };\n    let (tx, rx) = channel();\n    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let exec_time = rx.recv().unwrap().exec_time;\n    exec_time\n}\n\n#[test]\nfn test_should_not_report_time() {\n    let exec_time = report_time_test_template(false);\n    assert!(exec_time.is_none());\n}\n\n#[test]\nfn test_should_report_time() {\n    let exec_time = report_time_test_template(true);\n    assert!(exec_time.is_some());\n}\n\nfn time_test_failure_template(test_type: TestType) -> TestResult {\n    fn f() {}\n    let desc = TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"whatever\"),\n            ignore: false,\n            should_panic: ShouldPanic::No,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type,\n        },\n        testfn: DynTestFn(Box::new(f)),\n    };\n    // `Default` will initialize all the thresholds to 0 milliseconds.\n    let mut time_options = TestTimeOptions::default();\n    time_options.error_on_excess = true;\n\n    let test_opts = TestOpts { time_options: Some(time_options), ..TestOpts::new() };\n    let (tx, rx) = channel();\n    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n    let result = rx.recv().unwrap().result;\n\n    result\n}\n\n#[test]\nfn test_error_on_exceed() {\n    let types = [TestType::UnitTest, TestType::IntegrationTest, TestType::DocTest];\n\n    for test_type in types.iter() {\n        let result = time_test_failure_template(*test_type);\n\n        assert_eq!(result, TestResult::TrTimedFail);\n    }\n\n    // Check that for unknown tests thresholds aren't applied.\n    let result = time_test_failure_template(TestType::Unknown);\n    assert_eq!(result, TestResult::TrOk);\n}\n\nfn typed_test_desc(test_type: TestType) -> TestDesc {\n    TestDesc {\n        name: StaticTestName(\"whatever\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type,\n    }\n}\n\nfn test_exec_time(millis: u64) -> TestExecTime {\n    TestExecTime(Duration::from_millis(millis))\n}\n\n#[test]\nfn test_time_options_threshold() {\n    let unit = TimeThreshold::new(Duration::from_millis(50), Duration::from_millis(100));\n    let integration = TimeThreshold::new(Duration::from_millis(500), Duration::from_millis(1000));\n    let doc = TimeThreshold::new(Duration::from_millis(5000), Duration::from_millis(10000));\n\n    let options = TestTimeOptions {\n        error_on_excess: false,\n        colored: false,\n        unit_threshold: unit.clone(),\n        integration_threshold: integration.clone(),\n        doctest_threshold: doc.clone(),\n    };\n\n    let test_vector = [\n        (TestType::UnitTest, unit.warn.as_millis() - 1, false, false),\n        (TestType::UnitTest, unit.warn.as_millis(), true, false),\n        (TestType::UnitTest, unit.critical.as_millis(), true, true),\n        (TestType::IntegrationTest, integration.warn.as_millis() - 1, false, false),\n        (TestType::IntegrationTest, integration.warn.as_millis(), true, false),\n        (TestType::IntegrationTest, integration.critical.as_millis(), true, true),\n        (TestType::DocTest, doc.warn.as_millis() - 1, false, false),\n        (TestType::DocTest, doc.warn.as_millis(), true, false),\n        (TestType::DocTest, doc.critical.as_millis(), true, true),\n    ];\n\n    for (test_type, time, expected_warn, expected_critical) in test_vector.iter() {\n        let test_desc = typed_test_desc(*test_type);\n        let exec_time = test_exec_time(*time as u64);\n\n        assert_eq!(options.is_warn(&test_desc, &exec_time), *expected_warn);\n        assert_eq!(options.is_critical(&test_desc, &exec_time), *expected_critical);\n    }\n}\n\n#[test]\nfn parse_ignored_flag() {\n    let args = vec![\"progname\".to_string(), \"filter\".to_string(), \"--ignored\".to_string()];\n    let opts = parse_opts(&args).unwrap().unwrap();\n    assert_eq!(opts.run_ignored, RunIgnored::Only);\n}\n\n#[test]\nfn parse_show_output_flag() {\n    let args = vec![\"progname\".to_string(), \"filter\".to_string(), \"--show-output\".to_string()];\n    let opts = parse_opts(&args).unwrap().unwrap();\n    assert!(opts.options.display_output);\n}\n\n#[test]\nfn parse_include_ignored_flag() {\n    let args = vec![\"progname\".to_string(), \"filter\".to_string(), \"--include-ignored\".to_string()];\n    let opts = parse_opts(&args).unwrap().unwrap();\n    assert_eq!(opts.run_ignored, RunIgnored::Yes);\n}\n\n#[test]\npub fn filter_for_ignored_option() {\n    // When we run ignored tests the test filter should filter out all the\n    // unignored tests and flip the ignore flag on the rest to false\n\n    let mut opts = TestOpts::new();\n    opts.run_tests = true;\n    opts.run_ignored = RunIgnored::Only;\n\n    let tests = one_ignored_one_unignored_test();\n    let filtered = filter_tests(&opts, tests);\n\n    assert_eq!(filtered.len(), 1);\n    assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n    assert!(!filtered[0].desc.ignore);\n}\n\n#[test]\npub fn run_include_ignored_option() {\n    // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n    // all tests and no test filtered out\n\n    let mut opts = TestOpts::new();\n    opts.run_tests = true;\n    opts.run_ignored = RunIgnored::Yes;\n\n    let tests = one_ignored_one_unignored_test();\n    let filtered = filter_tests(&opts, tests);\n\n    assert_eq!(filtered.len(), 2);\n    assert!(!filtered[0].desc.ignore);\n    assert!(!filtered[1].desc.ignore);\n}\n\n#[test]\npub fn exclude_should_panic_option() {\n    let mut opts = TestOpts::new();\n    opts.run_tests = true;\n    opts.exclude_should_panic = true;\n\n    let mut tests = one_ignored_one_unignored_test();\n    tests.push(TestDescAndFn {\n        desc: TestDesc {\n            name: StaticTestName(\"3\"),\n            ignore: false,\n            should_panic: ShouldPanic::Yes,\n            allow_fail: false,\n            #[cfg(not(bootstrap))]\n            compile_fail: false,\n            #[cfg(not(bootstrap))]\n            no_run: false,\n            test_type: TestType::Unknown,\n        },\n        testfn: DynTestFn(Box::new(move || {})),\n    });\n\n    let filtered = filter_tests(&opts, tests);\n\n    assert_eq!(filtered.len(), 2);\n    assert!(filtered.iter().all(|test| test.desc.should_panic == ShouldPanic::No));\n}\n\n#[test]\npub fn exact_filter_match() {\n    fn tests() -> Vec<TestDescAndFn> {\n        vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n            .into_iter()\n            .map(|name| TestDescAndFn {\n                desc: TestDesc {\n                    name: StaticTestName(name),\n                    ignore: false,\n                    should_panic: ShouldPanic::No,\n                    allow_fail: false,\n                    #[cfg(not(bootstrap))]\n                    compile_fail: false,\n                    #[cfg(not(bootstrap))]\n                    no_run: false,\n                    test_type: TestType::Unknown,\n                },\n                testfn: DynTestFn(Box::new(move || {})),\n            })\n            .collect()\n    }\n\n    let substr =\n        filter_tests(&TestOpts { filters: vec![\"base\".into()], ..TestOpts::new() }, tests());\n    assert_eq!(substr.len(), 4);\n\n    let substr =\n        filter_tests(&TestOpts { filters: vec![\"bas\".into()], ..TestOpts::new() }, tests());\n    assert_eq!(substr.len(), 4);\n\n    let substr =\n        filter_tests(&TestOpts { filters: vec![\"::test\".into()], ..TestOpts::new() }, tests());\n    assert_eq!(substr.len(), 3);\n\n    let substr =\n        filter_tests(&TestOpts { filters: vec![\"base::test\".into()], ..TestOpts::new() }, tests());\n    assert_eq!(substr.len(), 3);\n\n    let substr = filter_tests(\n        &TestOpts { filters: vec![\"test1\".into(), \"test2\".into()], ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(substr.len(), 2);\n\n    let exact = filter_tests(\n        &TestOpts { filters: vec![\"base\".into()], filter_exact: true, ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(exact.len(), 1);\n\n    let exact = filter_tests(\n        &TestOpts { filters: vec![\"bas\".into()], filter_exact: true, ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(exact.len(), 0);\n\n    let exact = filter_tests(\n        &TestOpts { filters: vec![\"::test\".into()], filter_exact: true, ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(exact.len(), 0);\n\n    let exact = filter_tests(\n        &TestOpts { filters: vec![\"base::test\".into()], filter_exact: true, ..TestOpts::new() },\n        tests(),\n    );\n    assert_eq!(exact.len(), 1);\n\n    let exact = filter_tests(\n        &TestOpts {\n            filters: vec![\"base\".into(), \"base::test\".into()],\n            filter_exact: true,\n            ..TestOpts::new()\n        },\n        tests(),\n    );\n    assert_eq!(exact.len(), 2);\n}\n\n#[test]\npub fn sort_tests() {\n    let mut opts = TestOpts::new();\n    opts.run_tests = true;\n\n    let names = vec![\n        \"sha1::test\".to_string(),\n        \"isize::test_to_str\".to_string(),\n        \"isize::test_pow\".to_string(),\n        \"test::do_not_run_ignored_tests\".to_string(),\n        \"test::ignored_tests_result_in_ignored\".to_string(),\n        \"test::first_free_arg_should_be_a_filter\".to_string(),\n        \"test::parse_ignored_flag\".to_string(),\n        \"test::parse_include_ignored_flag\".to_string(),\n        \"test::filter_for_ignored_option\".to_string(),\n        \"test::run_include_ignored_option\".to_string(),\n        \"test::sort_tests\".to_string(),\n    ];\n    let tests = {\n        fn testfn() {}\n        let mut tests = Vec::new();\n        for name in &names {\n            let test = TestDescAndFn {\n                desc: TestDesc {\n                    name: DynTestName((*name).clone()),\n                    ignore: false,\n                    should_panic: ShouldPanic::No,\n                    allow_fail: false,\n                    #[cfg(not(bootstrap))]\n                    compile_fail: false,\n                    #[cfg(not(bootstrap))]\n                    no_run: false,\n                    test_type: TestType::Unknown,\n                },\n                testfn: DynTestFn(Box::new(testfn)),\n            };\n            tests.push(test);\n        }\n        tests\n    };\n    let filtered = filter_tests(&opts, tests);\n\n    let expected = vec![\n        \"isize::test_pow\".to_string(),\n        \"isize::test_to_str\".to_string(),\n        \"sha1::test\".to_string(),\n        \"test::do_not_run_ignored_tests\".to_string(),\n        \"test::filter_for_ignored_option\".to_string(),\n        \"test::first_free_arg_should_be_a_filter\".to_string(),\n        \"test::ignored_tests_result_in_ignored\".to_string(),\n        \"test::parse_ignored_flag\".to_string(),\n        \"test::parse_include_ignored_flag\".to_string(),\n        \"test::run_include_ignored_option\".to_string(),\n        \"test::sort_tests\".to_string(),\n    ];\n\n    for (a, b) in expected.iter().zip(filtered) {\n        assert_eq!(*a, b.desc.name.to_string());\n    }\n}\n\n#[test]\npub fn test_metricmap_compare() {\n    let mut m1 = MetricMap::new();\n    let mut m2 = MetricMap::new();\n    m1.insert_metric(\"in-both-noise\", 1000.0, 200.0);\n    m2.insert_metric(\"in-both-noise\", 1100.0, 200.0);\n\n    m1.insert_metric(\"in-first-noise\", 1000.0, 2.0);\n    m2.insert_metric(\"in-second-noise\", 1000.0, 2.0);\n\n    m1.insert_metric(\"in-both-want-downwards-but-regressed\", 1000.0, 10.0);\n    m2.insert_metric(\"in-both-want-downwards-but-regressed\", 2000.0, 10.0);\n\n    m1.insert_metric(\"in-both-want-downwards-and-improved\", 2000.0, 10.0);\n    m2.insert_metric(\"in-both-want-downwards-and-improved\", 1000.0, 10.0);\n\n    m1.insert_metric(\"in-both-want-upwards-but-regressed\", 2000.0, -10.0);\n    m2.insert_metric(\"in-both-want-upwards-but-regressed\", 1000.0, -10.0);\n\n    m1.insert_metric(\"in-both-want-upwards-and-improved\", 1000.0, -10.0);\n    m2.insert_metric(\"in-both-want-upwards-and-improved\", 2000.0, -10.0);\n}\n\n#[test]\npub fn test_bench_once_no_iter() {\n    fn f(_: &mut Bencher) {}\n    bench::run_once(f);\n}\n\n#[test]\npub fn test_bench_once_iter() {\n    fn f(b: &mut Bencher) {\n        b.iter(|| {})\n    }\n    bench::run_once(f);\n}\n\n#[test]\npub fn test_bench_no_iter() {\n    fn f(_: &mut Bencher) {}\n\n    let (tx, rx) = channel();\n\n    let desc = TestDesc {\n        name: StaticTestName(\"f\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type: TestType::Unknown,\n    };\n\n    crate::bench::benchmark(TestId(0), desc, tx, true, f);\n    rx.recv().unwrap();\n}\n\n#[test]\npub fn test_bench_iter() {\n    fn f(b: &mut Bencher) {\n        b.iter(|| {})\n    }\n\n    let (tx, rx) = channel();\n\n    let desc = TestDesc {\n        name: StaticTestName(\"f\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type: TestType::Unknown,\n    };\n\n    crate::bench::benchmark(TestId(0), desc, tx, true, f);\n    rx.recv().unwrap();\n}\n\n#[test]\nfn should_sort_failures_before_printing_them() {\n    let test_a = TestDesc {\n        name: StaticTestName(\"a\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type: TestType::Unknown,\n    };\n\n    let test_b = TestDesc {\n        name: StaticTestName(\"b\"),\n        ignore: false,\n        should_panic: ShouldPanic::No,\n        allow_fail: false,\n        #[cfg(not(bootstrap))]\n        compile_fail: false,\n        #[cfg(not(bootstrap))]\n        no_run: false,\n        test_type: TestType::Unknown,\n    };\n\n    let mut out = PrettyFormatter::new(OutputLocation::Raw(Vec::new()), false, 10, false, None);\n\n    let st = console::ConsoleTestState {\n        log_out: None,\n        total: 0,\n        passed: 0,\n        failed: 0,\n        ignored: 0,\n        allowed_fail: 0,\n        filtered_out: 0,\n        measured: 0,\n        exec_time: None,\n        metrics: MetricMap::new(),\n        failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n        options: Options::new(),\n        not_failures: Vec::new(),\n        time_failures: Vec::new(),\n    };\n\n    out.write_failures(&st).unwrap();\n    let s = match out.output_location() {\n        &OutputLocation::Raw(ref m) => String::from_utf8_lossy(&m[..]),\n        &OutputLocation::Pretty(_) => unreachable!(),\n    };\n\n    let apos = s.find(\"a\").unwrap();\n    let bpos = s.find(\"b\").unwrap();\n    assert!(apos < bpos);\n}\n"],["2624","//! Enums denoting options for test execution.\n\n/// Whether to execute tests concurrently or not\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub enum Concurrent {\n    Yes,\n    No,\n}\n\n/// Number of times to run a benchmarked function\n#[derive(Clone, PartialEq, Eq)]\npub enum BenchMode {\n    Auto,\n    Single,\n}\n\n/// Whether test is expected to panic or not\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\npub enum ShouldPanic {\n    No,\n    Yes,\n    YesWithMessage(&'static str),\n}\n\n/// Whether should console output be colored or not\n#[derive(Copy, Clone, Debug)]\npub enum ColorConfig {\n    AutoColor,\n    AlwaysColor,\n    NeverColor,\n}\n\n/// Format of the test results output\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub enum OutputFormat {\n    /// Verbose output\n    Pretty,\n    /// Quiet output\n    Terse,\n    /// JSON output\n    Json,\n    /// JUnit output\n    Junit,\n}\n\n/// Whether ignored test should be run or not\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub enum RunIgnored {\n    Yes,\n    No,\n    /// Run only ignored tests\n    Only,\n}\n\n#[derive(Clone, Copy)]\npub enum RunStrategy {\n    /// Runs the test in the current process, and sends the result back over the\n    /// supplied channel.\n    InProcess,\n\n    /// Spawns a subprocess to run the test, and sends the result back over the\n    /// supplied channel. Requires `argv[0]` to exist and point to the binary\n    /// that's currently running.\n    SpawnPrimary,\n}\n\n/// Options for the test run defined by the caller (instead of CLI arguments).\n/// In case we want to add other options as well, just add them in this struct.\n#[derive(Copy, Clone, Debug)]\npub struct Options {\n    pub display_output: bool,\n    pub panic_abort: bool,\n}\n\nimpl Options {\n    pub fn new() -> Options {\n        Options { display_output: false, panic_abort: false }\n    }\n\n    pub fn display_output(mut self, display_output: bool) -> Options {\n        self.display_output = display_output;\n        self\n    }\n\n    pub fn panic_abort(mut self, panic_abort: bool) -> Options {\n        self.panic_abort = panic_abort;\n        self\n    }\n}\n"],["2625","//! Module containing different events that can occur\n//! during tests execution process.\n\nuse super::test_result::TestResult;\nuse super::time::TestExecTime;\nuse super::types::{TestDesc, TestId};\n\n#[derive(Debug, Clone)]\npub struct CompletedTest {\n    pub id: TestId,\n    pub desc: TestDesc,\n    pub result: TestResult,\n    pub exec_time: Option<TestExecTime>,\n    pub stdout: Vec<u8>,\n}\n\nimpl CompletedTest {\n    pub fn new(\n        id: TestId,\n        desc: TestDesc,\n        result: TestResult,\n        exec_time: Option<TestExecTime>,\n        stdout: Vec<u8>,\n    ) -> Self {\n        Self { id, desc, result, exec_time, stdout }\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum TestEvent {\n    TeFiltered(Vec<TestDesc>),\n    TeWait(TestDesc),\n    TeResult(CompletedTest),\n    TeTimeout(TestDesc),\n    TeFilteredOut(usize),\n}\n"],["2626","use std::any::Any;\n\nuse super::bench::BenchSamples;\nuse super::options::ShouldPanic;\nuse super::time;\nuse super::types::TestDesc;\n\npub use self::TestResult::*;\n\n// Return codes for secondary process.\n// Start somewhere other than 0 so we know the return code means what we think\n// it means.\npub const TR_OK: i32 = 50;\npub const TR_FAILED: i32 = 51;\n\n#[derive(Debug, Clone, PartialEq)]\npub enum TestResult {\n    TrOk,\n    TrFailed,\n    TrFailedMsg(String),\n    TrIgnored,\n    TrAllowedFail,\n    TrBench(BenchSamples),\n    TrTimedFail,\n}\n\n/// Creates a `TestResult` depending on the raw result of test execution\n/// and associated data.\npub fn calc_result<'a>(\n    desc: &TestDesc,\n    task_result: Result<(), &'a (dyn Any + 'static + Send)>,\n    time_opts: &Option<time::TestTimeOptions>,\n    exec_time: &Option<time::TestExecTime>,\n) -> TestResult {\n    let result = match (&desc.should_panic, task_result) {\n        (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TestResult::TrOk,\n        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n            let maybe_panic_str = err\n                .downcast_ref::<String>()\n                .map(|e| &**e)\n                .or_else(|| err.downcast_ref::<&'static str>().copied());\n\n            if maybe_panic_str.map(|e| e.contains(msg)).unwrap_or(false) {\n                TestResult::TrOk\n            } else if desc.allow_fail {\n                TestResult::TrAllowedFail\n            } else if let Some(panic_str) = maybe_panic_str {\n                TestResult::TrFailedMsg(format!(\n                    r#\"panic did not contain expected string\n      panic message: `{:?}`,\n expected substring: `{:?}`\"#,\n                    panic_str, msg\n                ))\n            } else {\n                TestResult::TrFailedMsg(format!(\n                    r#\"expected panic with string value,\n found non-string value: `{:?}`\n     expected substring: `{:?}`\"#,\n                    (**err).type_id(),\n                    msg\n                ))\n            }\n        }\n        (&ShouldPanic::Yes, Ok(())) | (&ShouldPanic::YesWithMessage(_), Ok(())) => {\n            TestResult::TrFailedMsg(\"test did not panic as expected\".to_string())\n        }\n        _ if desc.allow_fail => TestResult::TrAllowedFail,\n        _ => TestResult::TrFailed,\n    };\n\n    // If test is already failed (or allowed to fail), do not change the result.\n    if result != TestResult::TrOk {\n        return result;\n    }\n\n    // Check if test is failed due to timeout.\n    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n        if opts.error_on_excess && opts.is_critical(desc, time) {\n            return TestResult::TrTimedFail;\n        }\n    }\n\n    result\n}\n\n/// Creates a `TestResult` depending on the exit code of test subprocess.\npub fn get_result_from_exit_code(\n    desc: &TestDesc,\n    code: i32,\n    time_opts: &Option<time::TestTimeOptions>,\n    exec_time: &Option<time::TestExecTime>,\n) -> TestResult {\n    let result = match (desc.allow_fail, code) {\n        (_, TR_OK) => TestResult::TrOk,\n        (true, TR_FAILED) => TestResult::TrAllowedFail,\n        (false, TR_FAILED) => TestResult::TrFailed,\n        (_, _) => TestResult::TrFailedMsg(format!(\"got unexpected return code {}\", code)),\n    };\n\n    // If test is already failed (or allowed to fail), do not change the result.\n    if result != TestResult::TrOk {\n        return result;\n    }\n\n    // Check if test is failed due to timeout.\n    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n        if opts.error_on_excess && opts.is_critical(desc, time) {\n            return TestResult::TrTimedFail;\n        }\n    }\n\n    result\n}\n"],["2627","#![allow(nonstandard_style)]\n\nuse libc::{c_int, c_void, uintptr_t};\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum _Unwind_Reason_Code {\n    _URC_NO_REASON = 0,\n    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n    _URC_FATAL_PHASE2_ERROR = 2,\n    _URC_FATAL_PHASE1_ERROR = 3,\n    _URC_NORMAL_STOP = 4,\n    _URC_END_OF_STACK = 5,\n    _URC_HANDLER_FOUND = 6,\n    _URC_INSTALL_CONTEXT = 7,\n    _URC_CONTINUE_UNWIND = 8,\n    _URC_FAILURE = 9, // used only by ARM EHABI\n}\npub use _Unwind_Reason_Code::*;\n\npub type _Unwind_Exception_Class = u64;\npub type _Unwind_Word = uintptr_t;\npub type _Unwind_Ptr = uintptr_t;\npub type _Unwind_Trace_Fn =\n    extern \"C\" fn(ctx: *mut _Unwind_Context, arg: *mut c_void) -> _Unwind_Reason_Code;\n\n#[cfg(target_arch = \"x86\")]\npub const unwinder_private_data_size: usize = 5;\n\n#[cfg(target_arch = \"x86_64\")]\npub const unwinder_private_data_size: usize = 6;\n\n#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\npub const unwinder_private_data_size: usize = 20;\n\n#[cfg(all(target_arch = \"arm\", target_os = \"ios\"))]\npub const unwinder_private_data_size: usize = 5;\n\n#[cfg(all(target_arch = \"aarch64\", target_pointer_width = \"64\"))]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(all(target_arch = \"aarch64\", target_pointer_width = \"32\"))]\npub const unwinder_private_data_size: usize = 5;\n\n#[cfg(target_arch = \"mips\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_arch = \"mips64\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_arch = \"s390x\")]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(any(target_arch = \"sparc\", target_arch = \"sparc64\"))]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(any(target_arch = \"riscv64\", target_arch = \"riscv32\"))]\npub const unwinder_private_data_size: usize = 2;\n\n#[cfg(target_os = \"emscripten\")]\npub const unwinder_private_data_size: usize = 20;\n\n#[cfg(all(target_arch = \"hexagon\", target_os = \"linux\"))]\npub const unwinder_private_data_size: usize = 35;\n\n#[repr(C)]\npub struct _Unwind_Exception {\n    pub exception_class: _Unwind_Exception_Class,\n    pub exception_cleanup: _Unwind_Exception_Cleanup_Fn,\n    pub private: [_Unwind_Word; unwinder_private_data_size],\n}\n\npub enum _Unwind_Context {}\n\npub type _Unwind_Exception_Cleanup_Fn =\n    extern \"C\" fn(unwind_code: _Unwind_Reason_Code, exception: *mut _Unwind_Exception);\n#[cfg_attr(\n    all(feature = \"llvm-libunwind\", any(target_os = \"fuchsia\", target_os = \"linux\")),\n    link(name = \"unwind\", kind = \"static\")\n)]\nextern \"C\" {\n    #[unwind(allowed)]\n    pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;\n    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);\n    pub fn _Unwind_GetLanguageSpecificData(ctx: *mut _Unwind_Context) -> *mut c_void;\n    pub fn _Unwind_GetRegionStart(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n    pub fn _Unwind_GetTextRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n    pub fn _Unwind_GetDataRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n}\n\ncfg_if::cfg_if! {\nif #[cfg(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\")))] {\n    // Not ARM EHABI\n    #[repr(C)]\n    #[derive(Copy, Clone, PartialEq)]\n    pub enum _Unwind_Action {\n        _UA_SEARCH_PHASE = 1,\n        _UA_CLEANUP_PHASE = 2,\n        _UA_HANDLER_FRAME = 4,\n        _UA_FORCE_UNWIND = 8,\n        _UA_END_OF_STACK = 16,\n    }\n    pub use _Unwind_Action::*;\n\n    #[cfg_attr(all(feature = \"llvm-libunwind\",\n                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n               link(name = \"unwind\", kind = \"static\"))]\n    extern \"C\" {\n        pub fn _Unwind_GetGR(ctx: *mut _Unwind_Context, reg_index: c_int) -> _Unwind_Word;\n        pub fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: c_int, value: _Unwind_Word);\n        pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> _Unwind_Word;\n        pub fn _Unwind_SetIP(ctx: *mut _Unwind_Context, value: _Unwind_Word);\n        pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context, ip_before_insn: *mut c_int)\n                                 -> _Unwind_Word;\n        pub fn _Unwind_FindEnclosingFunction(pc: *mut c_void) -> *mut c_void;\n    }\n\n} else {\n    // ARM EHABI\n    #[repr(C)]\n    #[derive(Copy, Clone, PartialEq)]\n    pub enum _Unwind_State {\n        _US_VIRTUAL_UNWIND_FRAME = 0,\n        _US_UNWIND_FRAME_STARTING = 1,\n        _US_UNWIND_FRAME_RESUME = 2,\n        _US_ACTION_MASK = 3,\n        _US_FORCE_UNWIND = 8,\n        _US_END_OF_STACK = 16,\n    }\n    pub use _Unwind_State::*;\n\n    #[repr(C)]\n    enum _Unwind_VRS_Result {\n        _UVRSR_OK = 0,\n        _UVRSR_NOT_IMPLEMENTED = 1,\n        _UVRSR_FAILED = 2,\n    }\n    #[repr(C)]\n    enum _Unwind_VRS_RegClass {\n        _UVRSC_CORE = 0,\n        _UVRSC_VFP = 1,\n        _UVRSC_FPA = 2,\n        _UVRSC_WMMXD = 3,\n        _UVRSC_WMMXC = 4,\n    }\n    use _Unwind_VRS_RegClass::*;\n    #[repr(C)]\n    enum _Unwind_VRS_DataRepresentation {\n        _UVRSD_UINT32 = 0,\n        _UVRSD_VFPX = 1,\n        _UVRSD_FPAX = 2,\n        _UVRSD_UINT64 = 3,\n        _UVRSD_FLOAT = 4,\n        _UVRSD_DOUBLE = 5,\n    }\n    use _Unwind_VRS_DataRepresentation::*;\n\n    pub const UNWIND_POINTER_REG: c_int = 12;\n    pub const UNWIND_SP_REG: c_int = 13;\n    pub const UNWIND_IP_REG: c_int = 15;\n\n    #[cfg_attr(all(feature = \"llvm-libunwind\",\n                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n               link(name = \"unwind\", kind = \"static\"))]\n    extern \"C\" {\n        fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n                           regclass: _Unwind_VRS_RegClass,\n                           regno: _Unwind_Word,\n                           repr: _Unwind_VRS_DataRepresentation,\n                           data: *mut c_void)\n                           -> _Unwind_VRS_Result;\n\n        fn _Unwind_VRS_Set(ctx: *mut _Unwind_Context,\n                           regclass: _Unwind_VRS_RegClass,\n                           regno: _Unwind_Word,\n                           repr: _Unwind_VRS_DataRepresentation,\n                           data: *mut c_void)\n                           -> _Unwind_VRS_Result;\n    }\n\n    // On Android or ARM/Linux, these are implemented as macros:\n\n    pub unsafe fn _Unwind_GetGR(ctx: *mut _Unwind_Context, reg_index: c_int) -> _Unwind_Word {\n        let mut val: _Unwind_Word = 0;\n        _Unwind_VRS_Get(ctx, _UVRSC_CORE, reg_index as _Unwind_Word, _UVRSD_UINT32,\n                        &mut val as *mut _ as *mut c_void);\n        val\n    }\n\n    pub unsafe fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: c_int, value: _Unwind_Word) {\n        let mut value = value;\n        _Unwind_VRS_Set(ctx, _UVRSC_CORE, reg_index as _Unwind_Word, _UVRSD_UINT32,\n                        &mut value as *mut _ as *mut c_void);\n    }\n\n    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context)\n                                -> _Unwind_Word {\n        let val = _Unwind_GetGR(ctx, UNWIND_IP_REG);\n        (val & !1) as _Unwind_Word\n    }\n\n    pub unsafe fn _Unwind_SetIP(ctx: *mut _Unwind_Context,\n                                value: _Unwind_Word) {\n        // Propagate thumb bit to instruction pointer\n        let thumb_state = _Unwind_GetGR(ctx, UNWIND_IP_REG) & 1;\n        let value = value | thumb_state;\n        _Unwind_SetGR(ctx, UNWIND_IP_REG, value);\n    }\n\n    pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n                                    ip_before_insn: *mut c_int)\n                                    -> _Unwind_Word {\n        *ip_before_insn = 0;\n        _Unwind_GetIP(ctx)\n    }\n\n    // This function also doesn't exist on Android or ARM/Linux, so make it a no-op\n    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut c_void) -> *mut c_void {\n        pc\n    }\n}\n} // cfg_if!\n\ncfg_if::cfg_if! {\nif #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n    // Not 32-bit iOS\n    #[cfg_attr(all(feature = \"llvm-libunwind\",\n                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n               link(name = \"unwind\", kind = \"static\"))]\n    extern \"C\" {\n        #[unwind(allowed)]\n        pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n                                 trace_argument: *mut c_void)\n                                 -> _Unwind_Reason_Code;\n    }\n} else {\n    // 32-bit iOS uses SjLj and does not provide _Unwind_Backtrace()\n    #[cfg_attr(all(feature = \"llvm-libunwind\",\n                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n               link(name = \"unwind\", kind = \"static\"))]\n    extern \"C\" {\n        #[unwind(allowed)]\n        pub fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n    }\n\n    #[inline]\n    pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception) -> _Unwind_Reason_Code {\n        _Unwind_SjLj_RaiseException(exc)\n    }\n}\n} // cfg_if!\n\ncfg_if::cfg_if! {\nif #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n    // We declare these as opaque types. This is fine since you just need to\n    // pass them to _GCC_specific_handler and forget about them.\n    pub enum EXCEPTION_RECORD {}\n    pub type LPVOID = *mut c_void;\n    pub enum CONTEXT {}\n    pub enum DISPATCHER_CONTEXT {}\n    pub type EXCEPTION_DISPOSITION = c_int;\n    type PersonalityFn = unsafe extern \"C\" fn(version: c_int,\n                                              actions: _Unwind_Action,\n                                              exception_class: _Unwind_Exception_Class,\n                                              exception_object: *mut _Unwind_Exception,\n                                              context: *mut _Unwind_Context)\n                                              -> _Unwind_Reason_Code;\n\n    extern \"C\" {\n        pub fn _GCC_specific_handler(exceptionRecord: *mut EXCEPTION_RECORD,\n                                establisherFrame: LPVOID,\n                                contextRecord: *mut CONTEXT,\n                                dispatcherContext: *mut DISPATCHER_CONTEXT,\n                                personality: PersonalityFn)\n                                -> EXCEPTION_DISPOSITION;\n    }\n}\n} // cfg_if!\n"]]}